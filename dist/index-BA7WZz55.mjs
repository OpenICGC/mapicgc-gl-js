var ER = Object.defineProperty;
var CR = (r, e, t) => e in r ? ER(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var H = (r, e, t) => CR(r, typeof e != "symbol" ? e + "" : e, t);
function Dv(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Gm = { exports: {} }, IR = Gm.exports, Vw;
function MR() {
  return Vw || (Vw = 1, function(r, e) {
    (function(t, n) {
      r.exports = n();
    })(IR, function() {
      var t = {}, n = {};
      function i(l, o, d) {
        if (n[l] = d, l === "index") {
          var m = "var sharedModule = {}; (" + n.shared + ")(sharedModule); (" + n.worker + ")(sharedModule);", b = {};
          return n.shared(b), n.index(t, b), typeof window < "u" && t.setWorkerUrl(window.URL.createObjectURL(new Blob([m], { type: "text/javascript" }))), t;
        }
      }
      i("shared", ["exports"], function(l) {
        function o(f, c, h, p) {
          return new (h || (h = Promise))(function(y, x) {
            function A(N) {
              try {
                B(p.next(N));
              } catch (z) {
                x(z);
              }
            }
            function I(N) {
              try {
                B(p.throw(N));
              } catch (z) {
                x(z);
              }
            }
            function B(N) {
              var z;
              N.done ? y(N.value) : (z = N.value, z instanceof h ? z : new h(function(j) {
                j(z);
              })).then(A, I);
            }
            B((p = p.apply(f, c || [])).next());
          });
        }
        function d(f) {
          return f && f.__esModule && Object.prototype.hasOwnProperty.call(f, "default") ? f.default : f;
        }
        var m, b;
        function T() {
          if (b) return m;
          function f(c, h) {
            this.x = c, this.y = h;
          }
          return b = 1, m = f, f.prototype = { clone: function() {
            return new f(this.x, this.y);
          }, add: function(c) {
            return this.clone()._add(c);
          }, sub: function(c) {
            return this.clone()._sub(c);
          }, multByPoint: function(c) {
            return this.clone()._multByPoint(c);
          }, divByPoint: function(c) {
            return this.clone()._divByPoint(c);
          }, mult: function(c) {
            return this.clone()._mult(c);
          }, div: function(c) {
            return this.clone()._div(c);
          }, rotate: function(c) {
            return this.clone()._rotate(c);
          }, rotateAround: function(c, h) {
            return this.clone()._rotateAround(c, h);
          }, matMult: function(c) {
            return this.clone()._matMult(c);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(c) {
            return this.x === c.x && this.y === c.y;
          }, dist: function(c) {
            return Math.sqrt(this.distSqr(c));
          }, distSqr: function(c) {
            var h = c.x - this.x, p = c.y - this.y;
            return h * h + p * p;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(c) {
            return Math.atan2(this.y - c.y, this.x - c.x);
          }, angleWith: function(c) {
            return this.angleWithSep(c.x, c.y);
          }, angleWithSep: function(c, h) {
            return Math.atan2(this.x * h - this.y * c, this.x * c + this.y * h);
          }, _matMult: function(c) {
            var h = c[2] * this.x + c[3] * this.y;
            return this.x = c[0] * this.x + c[1] * this.y, this.y = h, this;
          }, _add: function(c) {
            return this.x += c.x, this.y += c.y, this;
          }, _sub: function(c) {
            return this.x -= c.x, this.y -= c.y, this;
          }, _mult: function(c) {
            return this.x *= c, this.y *= c, this;
          }, _div: function(c) {
            return this.x /= c, this.y /= c, this;
          }, _multByPoint: function(c) {
            return this.x *= c.x, this.y *= c.y, this;
          }, _divByPoint: function(c) {
            return this.x /= c.x, this.y /= c.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var c = this.y;
            return this.y = this.x, this.x = -c, this;
          }, _rotate: function(c) {
            var h = Math.cos(c), p = Math.sin(c), y = p * this.x + h * this.y;
            return this.x = h * this.x - p * this.y, this.y = y, this;
          }, _rotateAround: function(c, h) {
            var p = Math.cos(c), y = Math.sin(c), x = h.y + y * (this.x - h.x) + p * (this.y - h.y);
            return this.x = h.x + p * (this.x - h.x) - y * (this.y - h.y), this.y = x, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, f.convert = function(c) {
            return c instanceof f ? c : Array.isArray(c) ? new f(c[0], c[1]) : c;
          }, m;
        }
        typeof SuppressedError == "function" && SuppressedError;
        var M, E, D = d(T()), U = function() {
          if (E) return M;
          function f(c, h, p, y) {
            this.cx = 3 * c, this.bx = 3 * (p - c) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * h, this.by = 3 * (y - h) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = c, this.p1y = h, this.p2x = p, this.p2y = y;
          }
          return E = 1, M = f, f.prototype = { sampleCurveX: function(c) {
            return ((this.ax * c + this.bx) * c + this.cx) * c;
          }, sampleCurveY: function(c) {
            return ((this.ay * c + this.by) * c + this.cy) * c;
          }, sampleCurveDerivativeX: function(c) {
            return (3 * this.ax * c + 2 * this.bx) * c + this.cx;
          }, solveCurveX: function(c, h) {
            if (h === void 0 && (h = 1e-6), c < 0) return 0;
            if (c > 1) return 1;
            for (var p = c, y = 0; y < 8; y++) {
              var x = this.sampleCurveX(p) - c;
              if (Math.abs(x) < h) return p;
              var A = this.sampleCurveDerivativeX(p);
              if (Math.abs(A) < 1e-6) break;
              p -= x / A;
            }
            var I = 0, B = 1;
            for (p = c, y = 0; y < 20 && (x = this.sampleCurveX(p), !(Math.abs(x - c) < h)); y++) c > x ? I = p : B = p, p = 0.5 * (B - I) + I;
            return p;
          }, solve: function(c, h) {
            return this.sampleCurveY(this.solveCurveX(c, h));
          } }, M;
        }(), q = d(U);
        let G, Y;
        function he() {
          return G == null && (G = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), G;
        }
        function X() {
          if (Y == null && (Y = !1, he())) {
            const c = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
            if (c) {
              for (let p = 0; p < 5 * 5; p++) {
                const y = 4 * p;
                c.fillStyle = `rgb(${y},${y + 1},${y + 2})`, c.fillRect(p % 5, Math.floor(p / 5), 1, 1);
              }
              const h = c.getImageData(0, 0, 5, 5).data;
              for (let p = 0; p < 5 * 5 * 4; p++) if (p % 4 != 3 && h[p] !== p) {
                Y = !0;
                break;
              }
            }
          }
          return Y || !1;
        }
        var J, ie = 1e-6, ye = typeof Float32Array < "u" ? Float32Array : Array;
        function oe() {
          var f = new ye(9);
          return ye != Float32Array && (f[1] = 0, f[2] = 0, f[3] = 0, f[5] = 0, f[6] = 0, f[7] = 0), f[0] = 1, f[4] = 1, f[8] = 1, f;
        }
        function Re(f) {
          return f[0] = 1, f[1] = 0, f[2] = 0, f[3] = 0, f[4] = 0, f[5] = 1, f[6] = 0, f[7] = 0, f[8] = 0, f[9] = 0, f[10] = 1, f[11] = 0, f[12] = 0, f[13] = 0, f[14] = 0, f[15] = 1, f;
        }
        function Ne() {
          var f = new ye(3);
          return ye != Float32Array && (f[0] = 0, f[1] = 0, f[2] = 0), f;
        }
        function me(f, c, h) {
          var p = new ye(3);
          return p[0] = f, p[1] = c, p[2] = h, p;
        }
        function _e(f, c, h) {
          var p = c[0], y = c[1], x = c[2], A = c[3];
          return f[0] = h[0] * p + h[4] * y + h[8] * x + h[12] * A, f[1] = h[1] * p + h[5] * y + h[9] * x + h[13] * A, f[2] = h[2] * p + h[6] * y + h[10] * x + h[14] * A, f[3] = h[3] * p + h[7] * y + h[11] * x + h[15] * A, f;
        }
        function Fe() {
          var f = new ye(4);
          return ye != Float32Array && (f[0] = 0, f[1] = 0, f[2] = 0), f[3] = 1, f;
        }
        function Me() {
          var f = new ye(2);
          return ye != Float32Array && (f[0] = 0, f[1] = 0), f;
        }
        function Ct(f, c) {
          var h = new ye(2);
          return h[0] = f, h[1] = c, h;
        }
        Math.hypot || (Math.hypot = function() {
          for (var f = 0, c = arguments.length; c--; ) f += arguments[c] * arguments[c];
          return Math.sqrt(f);
        }), Ne(), J = new ye(4), ye != Float32Array && (J[0] = 0, J[1] = 0, J[2] = 0, J[3] = 0), Ne(), me(1, 0, 0), me(0, 1, 0), Fe(), Fe(), oe(), Me();
        const ht = 8192;
        function Pt(f, c, h) {
          return c * (ht / (f.tileSize * Math.pow(2, h - f.tileID.overscaledZ)));
        }
        function bt(f, c) {
          return (f % c + c) % c;
        }
        function kt(f, c, h) {
          return f * (1 - h) + c * h;
        }
        function Nt(f) {
          if (f <= 0) return 0;
          if (f >= 1) return 1;
          const c = f * f, h = c * f;
          return 4 * (f < 0.5 ? h : 3 * (f - c) + h - 0.75);
        }
        function mr(f, c, h, p) {
          const y = new q(f, c, h, p);
          return (x) => y.solve(x);
        }
        const ce = mr(0.25, 0.1, 0.25, 1);
        function Be(f, c, h) {
          return Math.min(h, Math.max(c, f));
        }
        function Ue(f, c, h) {
          const p = h - c, y = ((f - c) % p + p) % p + c;
          return y === c ? h : y;
        }
        function Xe(f) {
          for (var c = arguments.length, h = new Array(c > 1 ? c - 1 : 0), p = 1; p < c; p++)
            h[p - 1] = arguments[p];
          for (const y of h) for (const x in y) f[x] = y[x];
          return f;
        }
        let it = 1;
        function ft(f, c, h) {
          const p = {};
          for (const y in f) p[y] = c.call(this, f[y], y, f);
          return p;
        }
        function St(f, c, h) {
          const p = {};
          for (const y in f) c.call(this, f[y], y, f) && (p[y] = f[y]);
          return p;
        }
        function wt(f) {
          return Array.isArray(f) ? f.map(wt) : typeof f == "object" && f ? ft(f, wt) : f;
        }
        const ar = {};
        function Yt(f) {
          ar[f] || (typeof console < "u" && console.warn(f), ar[f] = !0);
        }
        function cr(f, c, h) {
          return (h.y - f.y) * (c.x - f.x) > (c.y - f.y) * (h.x - f.x);
        }
        function _r(f) {
          return typeof WorkerGlobalScope < "u" && f !== void 0 && f instanceof WorkerGlobalScope;
        }
        let Cr = null;
        function Ut(f) {
          return typeof ImageBitmap < "u" && f instanceof ImageBitmap;
        }
        const Ve = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
        function jr(f, c, h, p, y) {
          return o(this, void 0, void 0, function* () {
            if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
            const x = new VideoFrame(f, { timestamp: 0 });
            try {
              const A = x == null ? void 0 : x.format;
              if (!A || !A.startsWith("BGR") && !A.startsWith("RGB")) throw new Error(`Unrecognized format ${A}`);
              const I = A.startsWith("BGR"), B = new Uint8ClampedArray(p * y * 4);
              if (yield x.copyTo(B, function(N, z, j, K, ee) {
                const te = 4 * Math.max(1, 0), le = (Math.max(0, j) - j) * K * 4 + te, Ae = 4 * K, Te = Math.max(0, z), Qe = Math.max(0, j);
                return { rect: { x: Te, y: Qe, width: Math.min(N.width, z + K) - Te, height: Math.min(N.height, j + ee) - Qe }, layout: [{ offset: le, stride: Ae }] };
              }(f, c, h, p, y)), I) for (let N = 0; N < B.length; N += 4) {
                const z = B[N];
                B[N] = B[N + 2], B[N + 2] = z;
              }
              return B;
            } finally {
              x.close();
            }
          });
        }
        let Ir, rr;
        function hr(f) {
          return f / Math.PI * 180;
        }
        const wr = "AbortError";
        function br() {
          return new Error(wr);
        }
        const Rr = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
        function $r(f) {
          return Rr.REGISTERED_PROTOCOLS[f.substring(0, f.indexOf("://"))];
        }
        const Wr = "global-dispatcher";
        class Zr extends Error {
          constructor(c, h, p, y) {
            super(`AJAXError: ${h} (${c}): ${p}`), this.status = c, this.statusText = h, this.url = p, this.body = y;
          }
        }
        const hn = () => _r(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, yn = function(f, c) {
          if (/:\/\//.test(f.url) && !/^https?:|^file:/.test(f.url)) {
            const p = $r(f.url);
            if (p) return p(f, c);
            if (_r(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: f, targetMapId: Wr }, c);
          }
          if (!(/^file:/.test(h = f.url) || /^file:/.test(hn()) && !/^\w+:/.test(h))) {
            if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(p, y) {
              return o(this, void 0, void 0, function* () {
                const x = new Request(p.url, { method: p.method || "GET", body: p.body, credentials: p.credentials, headers: p.headers, cache: p.cache, referrer: hn(), signal: y.signal });
                let A, I;
                p.type !== "json" || x.headers.has("Accept") || x.headers.set("Accept", "application/json");
                try {
                  A = yield fetch(x);
                } catch (N) {
                  throw new Zr(0, N.message, p.url, new Blob());
                }
                if (!A.ok) {
                  const N = yield A.blob();
                  throw new Zr(A.status, A.statusText, p.url, N);
                }
                I = p.type === "arrayBuffer" || p.type === "image" ? A.arrayBuffer() : p.type === "json" ? A.json() : A.text();
                const B = yield I;
                if (y.signal.aborted) throw br();
                return { data: B, cacheControl: A.headers.get("Cache-Control"), expires: A.headers.get("Expires") };
              });
            }(f, c);
            if (_r(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: f, mustQueue: !0, targetMapId: Wr }, c);
          }
          var h;
          return function(p, y) {
            return new Promise((x, A) => {
              var I;
              const B = new XMLHttpRequest();
              B.open(p.method || "GET", p.url, !0), p.type !== "arrayBuffer" && p.type !== "image" || (B.responseType = "arraybuffer");
              for (const N in p.headers) B.setRequestHeader(N, p.headers[N]);
              p.type === "json" && (B.responseType = "text", !((I = p.headers) === null || I === void 0) && I.Accept || B.setRequestHeader("Accept", "application/json")), B.withCredentials = p.credentials === "include", B.onerror = () => {
                A(new Error(B.statusText));
              }, B.onload = () => {
                if (!y.signal.aborted) if ((B.status >= 200 && B.status < 300 || B.status === 0) && B.response !== null) {
                  let N = B.response;
                  if (p.type === "json") try {
                    N = JSON.parse(B.response);
                  } catch (z) {
                    return void A(z);
                  }
                  x({ data: N, cacheControl: B.getResponseHeader("Cache-Control"), expires: B.getResponseHeader("Expires") });
                } else {
                  const N = new Blob([B.response], { type: B.getResponseHeader("Content-Type") });
                  A(new Zr(B.status, B.statusText, p.url, N));
                }
              }, y.signal.addEventListener("abort", () => {
                B.abort(), A(br());
              }), B.send(p.body);
            });
          }(f, c);
        };
        function Vr(f) {
          if (!f || f.indexOf("://") <= 0 || f.indexOf("data:image/") === 0 || f.indexOf("blob:") === 0) return !0;
          const c = new URL(f), h = window.location;
          return c.protocol === h.protocol && c.host === h.host;
        }
        function en(f, c, h) {
          h[f] && h[f].indexOf(c) !== -1 || (h[f] = h[f] || [], h[f].push(c));
        }
        function Ar(f, c, h) {
          if (h && h[f]) {
            const p = h[f].indexOf(c);
            p !== -1 && h[f].splice(p, 1);
          }
        }
        class Ii {
          constructor(c) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            Xe(this, h), this.type = c;
          }
        }
        class bn extends Ii {
          constructor(c) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            super("error", Xe({ error: c }, h));
          }
        }
        class Xi {
          on(c, h) {
            return this._listeners = this._listeners || {}, en(c, h, this._listeners), { unsubscribe: () => {
              this.off(c, h);
            } };
          }
          off(c, h) {
            return Ar(c, h, this._listeners), Ar(c, h, this._oneTimeListeners), this;
          }
          once(c, h) {
            return h ? (this._oneTimeListeners = this._oneTimeListeners || {}, en(c, h, this._oneTimeListeners), this) : new Promise((p) => this.once(c, p));
          }
          fire(c, h) {
            typeof c == "string" && (c = new Ii(c, h || {}));
            const p = c.type;
            if (this.listens(p)) {
              c.target = this;
              const y = this._listeners && this._listeners[p] ? this._listeners[p].slice() : [];
              for (const I of y) I.call(this, c);
              const x = this._oneTimeListeners && this._oneTimeListeners[p] ? this._oneTimeListeners[p].slice() : [];
              for (const I of x) Ar(p, I, this._oneTimeListeners), I.call(this, c);
              const A = this._eventedParent;
              A && (Xe(c, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), A.fire(c));
            } else c instanceof bn && console.error(c.error);
            return this;
          }
          listens(c) {
            return this._listeners && this._listeners[c] && this._listeners[c].length > 0 || this._oneTimeListeners && this._oneTimeListeners[c] && this._oneTimeListeners[c].length > 0 || this._eventedParent && this._eventedParent.listens(c);
          }
          setEventedParent(c, h) {
            return this._eventedParent = c, this._eventedParentData = h, this;
          }
        }
        var ve = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
        const se = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
        function de(f, c) {
          const h = {};
          for (const p in f) p !== "ref" && (h[p] = f[p]);
          return se.forEach((p) => {
            p in c && (h[p] = c[p]);
          }), h;
        }
        function pe(f, c) {
          if (Array.isArray(f)) {
            if (!Array.isArray(c) || f.length !== c.length) return !1;
            for (let h = 0; h < f.length; h++) if (!pe(f[h], c[h])) return !1;
            return !0;
          }
          if (typeof f == "object" && f !== null && c !== null) {
            if (typeof c != "object" || Object.keys(f).length !== Object.keys(c).length) return !1;
            for (const h in f) if (!pe(f[h], c[h])) return !1;
            return !0;
          }
          return f === c;
        }
        function Oe(f, c) {
          f.push(c);
        }
        function Ge(f, c, h) {
          Oe(h, { command: "addSource", args: [f, c[f]] });
        }
        function rt(f, c, h) {
          Oe(c, { command: "removeSource", args: [f] }), h[f] = !0;
        }
        function gt(f, c, h, p) {
          rt(f, h, p), Ge(f, c, h);
        }
        function Ye(f, c, h) {
          let p;
          for (p in f[h]) if (Object.prototype.hasOwnProperty.call(f[h], p) && p !== "data" && !pe(f[h][p], c[h][p])) return !1;
          for (p in c[h]) if (Object.prototype.hasOwnProperty.call(c[h], p) && p !== "data" && !pe(f[h][p], c[h][p])) return !1;
          return !0;
        }
        function lt(f, c, h, p, y, x) {
          f = f || {}, c = c || {};
          for (const A in f) Object.prototype.hasOwnProperty.call(f, A) && (pe(f[A], c[A]) || h.push({ command: x, args: [p, A, c[A], y] }));
          for (const A in c) Object.prototype.hasOwnProperty.call(c, A) && !Object.prototype.hasOwnProperty.call(f, A) && (pe(f[A], c[A]) || h.push({ command: x, args: [p, A, c[A], y] }));
        }
        function pt(f) {
          return f.id;
        }
        function ct(f, c) {
          return f[c.id] = c, f;
        }
        class We {
          constructor(c, h, p, y) {
            this.message = (c ? `${c}: ` : "") + p, y && (this.identifier = y), h != null && h.__line__ && (this.line = h.__line__);
          }
        }
        function or(f) {
          for (var c = arguments.length, h = new Array(c > 1 ? c - 1 : 0), p = 1; p < c; p++)
            h[p - 1] = arguments[p];
          for (const y of h) for (const x in y) f[x] = y[x];
          return f;
        }
        class Jt extends Error {
          constructor(c, h) {
            super(h), this.message = h, this.key = c;
          }
        }
        class Kt {
          constructor(c) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
            this.parent = c, this.bindings = {};
            for (const [p, y] of h) this.bindings[p] = y;
          }
          concat(c) {
            return new Kt(this, c);
          }
          get(c) {
            if (this.bindings[c]) return this.bindings[c];
            if (this.parent) return this.parent.get(c);
            throw new Error(`${c} not found in scope.`);
          }
          has(c) {
            return !!this.bindings[c] || !!this.parent && this.parent.has(c);
          }
        }
        const Mr = { kind: "null" }, Bt = { kind: "number" }, Qt = { kind: "string" }, fr = { kind: "boolean" }, Lr = { kind: "color" }, Hr = { kind: "projectionDefinition" }, Or = { kind: "object" }, gr = { kind: "value" }, Sn = { kind: "collator" }, Zi = { kind: "formatted" }, Dn = { kind: "padding" }, kn = { kind: "resolvedImage" }, vn = { kind: "variableAnchorOffsetCollection" };
        function Ai(f, c) {
          return { kind: "array", itemType: f, N: c };
        }
        function In(f) {
          if (f.kind === "array") {
            const c = In(f.itemType);
            return typeof f.N == "number" ? `array<${c}, ${f.N}>` : f.itemType.kind === "value" ? "array" : `array<${c}>`;
          }
          return f.kind;
        }
        const aa = [Mr, Bt, Qt, fr, Lr, Hr, Zi, Or, Ai(gr), Dn, kn, vn];
        function Wo(f, c) {
          if (c.kind === "error") return null;
          if (f.kind === "array") {
            if (c.kind === "array" && (c.N === 0 && c.itemType.kind === "value" || !Wo(f.itemType, c.itemType)) && (typeof f.N != "number" || f.N === c.N)) return null;
          } else {
            if (f.kind === c.kind) return null;
            if (f.kind === "value") {
              for (const h of aa) if (!Wo(h, c)) return null;
            }
          }
          return `Expected ${In(f)} but found ${In(c)} instead.`;
        }
        function tl(f, c) {
          return c.some((h) => h.kind === f.kind);
        }
        function wo(f, c) {
          return c.some((h) => h === "null" ? f === null : h === "array" ? Array.isArray(f) : h === "object" ? f && !Array.isArray(f) && typeof f == "object" : h === typeof f);
        }
        function la(f, c) {
          return f.kind === "array" && c.kind === "array" ? f.itemType.kind === c.itemType.kind && typeof f.N == "number" : f.kind === c.kind;
        }
        const ju = 0.96422, hu = 0.82521, Pl = 4 / 29, Ca = 6 / 29, Vu = 3 * Ca * Ca, fu = Ca * Ca * Ca, kh = Math.PI / 180, qu = 180 / Math.PI;
        function Gu(f) {
          return (f %= 360) < 0 && (f += 360), f;
        }
        function rl(f) {
          let [c, h, p, y] = f, x, A;
          const I = pi((0.2225045 * (c = Ia(c)) + 0.7168786 * (h = Ia(h)) + 0.0606169 * (p = Ia(p))) / 1);
          c === h && h === p ? x = A = I : (x = pi((0.4360747 * c + 0.3850649 * h + 0.1430804 * p) / ju), A = pi((0.0139322 * c + 0.0971045 * h + 0.7141733 * p) / hu));
          const B = 116 * I - 16;
          return [B < 0 ? 0 : B, 500 * (x - I), 200 * (I - A), y];
        }
        function Ia(f) {
          return f <= 0.04045 ? f / 12.92 : Math.pow((f + 0.055) / 1.055, 2.4);
        }
        function pi(f) {
          return f > fu ? Math.pow(f, 1 / 3) : f / Vu + Pl;
        }
        function du(f) {
          let [c, h, p, y] = f, x = (c + 16) / 116, A = isNaN(h) ? x : x + h / 500, I = isNaN(p) ? x : x - p / 200;
          return x = 1 * Nc(x), A = ju * Nc(A), I = hu * Nc(I), [ca(3.1338561 * A - 1.6168667 * x - 0.4906146 * I), ca(-0.9787684 * A + 1.9161415 * x + 0.033454 * I), ca(0.0719453 * A - 0.2289914 * x + 1.4052427 * I), y];
        }
        function ca(f) {
          return (f = f <= 304e-5 ? 12.92 * f : 1.055 * Math.pow(f, 1 / 2.4) - 0.055) < 0 ? 0 : f > 1 ? 1 : f;
        }
        function Nc(f) {
          return f > Ca ? f * f * f : Vu * (f - Pl);
        }
        function nl(f) {
          return parseInt(f.padEnd(2, f), 16) / 255;
        }
        function $u(f, c) {
          return hs(c ? f / 100 : f, 0, 1);
        }
        function hs(f, c, h) {
          return Math.min(Math.max(c, f), h);
        }
        function il(f) {
          return !f.some(Number.isNaN);
        }
        const gi = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
        function Yr(f, c, h) {
          return f + h * (c - f);
        }
        function co(f, c, h) {
          return f.map((p, y) => Yr(p, c[y], h));
        }
        class nn {
          constructor(c, h, p) {
            let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0;
            this.r = c, this.g = h, this.b = p, this.a = y, x || (this.r *= y, this.g *= y, this.b *= y, y || this.overwriteGetter("rgb", [c, h, p, y]));
          }
          static parse(c) {
            if (c instanceof nn) return c;
            if (typeof c != "string") return;
            const h = function(p) {
              if ((p = p.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
              const y = gi[p];
              if (y) {
                const [A, I, B] = y;
                return [A / 255, I / 255, B / 255, 1];
              }
              if (p.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(p)) {
                const A = p.length < 6 ? 1 : 2;
                let I = 1;
                return [nl(p.slice(I, I += A)), nl(p.slice(I, I += A)), nl(p.slice(I, I += A)), nl(p.slice(I, I + A) || "ff")];
              }
              if (p.startsWith("rgb")) {
                const A = p.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (A) {
                  const [I, B, N, z, j, K, ee, te, le, Ae, Te, Qe] = A, ke = [z || " ", ee || " ", Ae].join("");
                  if (ke === "  " || ke === "  /" || ke === ",," || ke === ",,,") {
                    const Q = [N, K, le].join(""), xe = Q === "%%%" ? 100 : Q === "" ? 255 : 0;
                    if (xe) {
                      const ze = [hs(+B / xe, 0, 1), hs(+j / xe, 0, 1), hs(+te / xe, 0, 1), Te ? $u(+Te, Qe) : 1];
                      if (il(ze)) return ze;
                    }
                  }
                  return;
                }
              }
              const x = p.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (x) {
                const [A, I, B, N, z, j, K, ee, te] = x, le = [B || " ", z || " ", K].join("");
                if (le === "  " || le === "  /" || le === ",," || le === ",,,") {
                  const Ae = [+I, hs(+N, 0, 100), hs(+j, 0, 100), ee ? $u(+ee, te) : 1];
                  if (il(Ae)) return function(Te) {
                    let [Qe, ke, Q, xe] = Te;
                    function ze(yt) {
                      const $t = (yt + Qe / 30) % 12, It = ke * Math.min(Q, 1 - Q);
                      return Q - It * Math.max(-1, Math.min($t - 3, 9 - $t, 1));
                    }
                    return Qe = Gu(Qe), ke /= 100, Q /= 100, [ze(0), ze(8), ze(4), xe];
                  }(Ae);
                }
              }
            }(c);
            return h ? new nn(...h, !1) : void 0;
          }
          get rgb() {
            const { r: c, g: h, b: p, a: y } = this, x = y || 1 / 0;
            return this.overwriteGetter("rgb", [c / x, h / x, p / x, y]);
          }
          get hcl() {
            return this.overwriteGetter("hcl", function(c) {
              const [h, p, y, x] = rl(c), A = Math.sqrt(p * p + y * y);
              return [Math.round(1e4 * A) ? Gu(Math.atan2(y, p) * qu) : NaN, A, h, x];
            }(this.rgb));
          }
          get lab() {
            return this.overwriteGetter("lab", rl(this.rgb));
          }
          overwriteGetter(c, h) {
            return Object.defineProperty(this, c, { value: h }), h;
          }
          toString() {
            const [c, h, p, y] = this.rgb;
            return `rgba(${[c, h, p].map((x) => Math.round(255 * x)).join(",")},${y})`;
          }
          static interpolate(c, h, p) {
            switch (arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "rgb") {
              case "rgb": {
                const [x, A, I, B] = co(c.rgb, h.rgb, p);
                return new nn(x, A, I, B, !1);
              }
              case "hcl": {
                const [x, A, I, B] = c.hcl, [N, z, j, K] = h.hcl;
                let ee, te;
                if (isNaN(x) || isNaN(N)) isNaN(x) ? isNaN(N) ? ee = NaN : (ee = N, I !== 1 && I !== 0 || (te = z)) : (ee = x, j !== 1 && j !== 0 || (te = A));
                else {
                  let ke = N - x;
                  N > x && ke > 180 ? ke -= 360 : N < x && x - N > 180 && (ke += 360), ee = x + p * ke;
                }
                const [le, Ae, Te, Qe] = function(ke) {
                  let [Q, xe, ze, yt] = ke;
                  return Q = isNaN(Q) ? 0 : Q * kh, du([ze, Math.cos(Q) * xe, Math.sin(Q) * xe, yt]);
                }([ee, te ?? Yr(A, z, p), Yr(I, j, p), Yr(B, K, p)]);
                return new nn(le, Ae, Te, Qe, !1);
              }
              case "lab": {
                const [x, A, I, B] = du(co(c.lab, h.lab, p));
                return new nn(x, A, I, B, !1);
              }
            }
          }
        }
        nn.black = new nn(0, 0, 0, 1), nn.white = new nn(1, 1, 1, 1), nn.transparent = new nn(0, 0, 0, 0), nn.red = new nn(1, 0, 0, 1);
        class Rl {
          constructor(c, h, p) {
            this.sensitivity = c ? h ? "variant" : "case" : h ? "accent" : "base", this.locale = p, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          }
          compare(c, h) {
            return this.collator.compare(c, h);
          }
          resolvedLocale() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          }
        }
        const Hu = ["bottom", "center", "top"];
        class sl {
          constructor(c, h, p, y, x, A) {
            this.text = c, this.image = h, this.scale = p, this.fontStack = y, this.textColor = x, this.verticalAlign = A;
          }
        }
        class oi {
          constructor(c) {
            this.sections = c;
          }
          static fromString(c) {
            return new oi([new sl(c, null, null, null, null, null)]);
          }
          isEmpty() {
            return this.sections.length === 0 || !this.sections.some((c) => c.text.length !== 0 || c.image && c.image.name.length !== 0);
          }
          static factory(c) {
            return c instanceof oi ? c : oi.fromString(c);
          }
          toString() {
            return this.sections.length === 0 ? "" : this.sections.map((c) => c.text).join("");
          }
        }
        class mi {
          constructor(c) {
            this.values = c.slice();
          }
          static parse(c) {
            if (c instanceof mi) return c;
            if (typeof c == "number") return new mi([c, c, c, c]);
            if (Array.isArray(c) && !(c.length < 1 || c.length > 4)) {
              for (const h of c) if (typeof h != "number") return;
              switch (c.length) {
                case 1:
                  c = [c[0], c[0], c[0], c[0]];
                  break;
                case 2:
                  c = [c[0], c[1], c[0], c[1]];
                  break;
                case 3:
                  c = [c[0], c[1], c[2], c[1]];
              }
              return new mi(c);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(c, h, p) {
            return new mi(co(c.values, h.values, p));
          }
        }
        class Kn {
          constructor(c) {
            this.name = "ExpressionEvaluationError", this.message = c;
          }
          toJSON() {
            return this.message;
          }
        }
        const pu = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
        class Yi {
          constructor(c) {
            this.values = c.slice();
          }
          static parse(c) {
            if (c instanceof Yi) return c;
            if (Array.isArray(c) && !(c.length < 1) && c.length % 2 == 0) {
              for (let h = 0; h < c.length; h += 2) {
                const p = c[h], y = c[h + 1];
                if (typeof p != "string" || !pu.has(p) || !Array.isArray(y) || y.length !== 2 || typeof y[0] != "number" || typeof y[1] != "number") return;
              }
              return new Yi(c);
            }
          }
          toString() {
            return JSON.stringify(this.values);
          }
          static interpolate(c, h, p) {
            const y = c.values, x = h.values;
            if (y.length !== x.length) throw new Kn(`Cannot interpolate values of different length. from: ${c.toString()}, to: ${h.toString()}`);
            const A = [];
            for (let I = 0; I < y.length; I += 2) {
              if (y[I] !== x[I]) throw new Kn(`Cannot interpolate values containing mismatched anchors. from[${I}]: ${y[I]}, to[${I}]: ${x[I]}`);
              A.push(y[I]);
              const [B, N] = y[I + 1], [z, j] = x[I + 1];
              A.push([Yr(B, z, p), Yr(N, j, p)]);
            }
            return new Yi(A);
          }
        }
        class ai {
          constructor(c) {
            this.name = c.name, this.available = c.available;
          }
          toString() {
            return this.name;
          }
          static fromString(c) {
            return c ? new ai({ name: c, available: !1 }) : null;
          }
        }
        class Mi {
          constructor(c, h, p) {
            this.from = c, this.to = h, this.transition = p;
          }
          static interpolate(c, h, p) {
            return new Mi(c, h, p);
          }
          static parse(c) {
            return c instanceof Mi ? c : Array.isArray(c) && c.length === 3 && typeof c[0] == "string" && typeof c[1] == "string" && typeof c[2] == "number" ? new Mi(c[0], c[1], c[2]) : typeof c == "object" && typeof c.from == "string" && typeof c.to == "string" && typeof c.transition == "number" ? new Mi(c.from, c.to, c.transition) : typeof c == "string" ? new Mi(c, c, 1) : void 0;
          }
        }
        function ol(f, c, h, p) {
          return typeof f == "number" && f >= 0 && f <= 255 && typeof c == "number" && c >= 0 && c <= 255 && typeof h == "number" && h >= 0 && h <= 255 ? p === void 0 || typeof p == "number" && p >= 0 && p <= 1 ? null : `Invalid rgba value [${[f, c, h, p].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof p == "number" ? [f, c, h, p] : [f, c, h]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
        }
        function ua(f) {
          if (f === null || typeof f == "string" || typeof f == "boolean" || typeof f == "number" || f instanceof Mi || f instanceof nn || f instanceof Rl || f instanceof oi || f instanceof mi || f instanceof Yi || f instanceof ai) return !0;
          if (Array.isArray(f)) {
            for (const c of f) if (!ua(c)) return !1;
            return !0;
          }
          if (typeof f == "object") {
            for (const c in f) if (!ua(f[c])) return !1;
            return !0;
          }
          return !1;
        }
        function an(f) {
          if (f === null) return Mr;
          if (typeof f == "string") return Qt;
          if (typeof f == "boolean") return fr;
          if (typeof f == "number") return Bt;
          if (f instanceof nn) return Lr;
          if (f instanceof Mi) return Hr;
          if (f instanceof Rl) return Sn;
          if (f instanceof oi) return Zi;
          if (f instanceof mi) return Dn;
          if (f instanceof Yi) return vn;
          if (f instanceof ai) return kn;
          if (Array.isArray(f)) {
            const c = f.length;
            let h;
            for (const p of f) {
              const y = an(p);
              if (h) {
                if (h === y) continue;
                h = gr;
                break;
              }
              h = y;
            }
            return Ai(h || gr, c);
          }
          return Or;
        }
        function Bl(f) {
          const c = typeof f;
          return f === null ? "" : c === "string" || c === "number" || c === "boolean" ? String(f) : f instanceof nn || f instanceof Mi || f instanceof oi || f instanceof mi || f instanceof Yi || f instanceof ai ? f.toString() : JSON.stringify(f);
        }
        class uo {
          constructor(c, h) {
            this.type = c, this.value = h;
          }
          static parse(c, h) {
            if (c.length !== 2) return h.error(`'literal' expression requires exactly one argument, but found ${c.length - 1} instead.`);
            if (!ua(c[1])) return h.error("invalid value");
            const p = c[1];
            let y = an(p);
            const x = h.expectedType;
            return y.kind !== "array" || y.N !== 0 || !x || x.kind !== "array" || typeof x.N == "number" && x.N !== 0 || (y = x), new uo(y, p);
          }
          evaluate() {
            return this.value;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const qr = { string: Qt, number: Bt, boolean: fr, object: Or };
        class Ys {
          constructor(c, h) {
            this.type = c, this.args = h;
          }
          static parse(c, h) {
            if (c.length < 2) return h.error("Expected at least one argument.");
            let p, y = 1;
            const x = c[0];
            if (x === "array") {
              let I, B;
              if (c.length > 2) {
                const N = c[1];
                if (typeof N != "string" || !(N in qr) || N === "object") return h.error('The item type argument of "array" must be one of string, number, boolean', 1);
                I = qr[N], y++;
              } else I = gr;
              if (c.length > 3) {
                if (c[2] !== null && (typeof c[2] != "number" || c[2] < 0 || c[2] !== Math.floor(c[2]))) return h.error('The length argument to "array" must be a positive integer literal', 2);
                B = c[2], y++;
              }
              p = Ai(I, B);
            } else {
              if (!qr[x]) throw new Error(`Types doesn't contain name = ${x}`);
              p = qr[x];
            }
            const A = [];
            for (; y < c.length; y++) {
              const I = h.parse(c[y], y, gr);
              if (!I) return null;
              A.push(I);
            }
            return new Ys(p, A);
          }
          evaluate(c) {
            for (let h = 0; h < this.args.length; h++) {
              const p = this.args[h].evaluate(c);
              if (!Wo(this.type, an(p))) return p;
              if (h === this.args.length - 1) throw new Kn(`Expected value to be of type ${In(this.type)}, but found ${In(an(p))} instead.`);
            }
            throw new Error();
          }
          eachChild(c) {
            this.args.forEach(c);
          }
          outputDefined() {
            return this.args.every((c) => c.outputDefined());
          }
        }
        const gu = { "to-boolean": fr, "to-color": Lr, "to-number": Bt, "to-string": Qt };
        class Ki {
          constructor(c, h) {
            this.type = c, this.args = h;
          }
          static parse(c, h) {
            if (c.length < 2) return h.error("Expected at least one argument.");
            const p = c[0];
            if (!gu[p]) throw new Error(`Can't parse ${p} as it is not part of the known types`);
            if ((p === "to-boolean" || p === "to-string") && c.length !== 2) return h.error("Expected one argument.");
            const y = gu[p], x = [];
            for (let A = 1; A < c.length; A++) {
              const I = h.parse(c[A], A, gr);
              if (!I) return null;
              x.push(I);
            }
            return new Ki(y, x);
          }
          evaluate(c) {
            switch (this.type.kind) {
              case "boolean":
                return !!this.args[0].evaluate(c);
              case "color": {
                let h, p;
                for (const y of this.args) {
                  if (h = y.evaluate(c), p = null, h instanceof nn) return h;
                  if (typeof h == "string") {
                    const x = c.parseColor(h);
                    if (x) return x;
                  } else if (Array.isArray(h) && (p = h.length < 3 || h.length > 4 ? `Invalid rgba value ${JSON.stringify(h)}: expected an array containing either three or four numeric values.` : ol(h[0], h[1], h[2], h[3]), !p)) return new nn(h[0] / 255, h[1] / 255, h[2] / 255, h[3]);
                }
                throw new Kn(p || `Could not parse color from value '${typeof h == "string" ? h : JSON.stringify(h)}'`);
              }
              case "padding": {
                let h;
                for (const p of this.args) {
                  h = p.evaluate(c);
                  const y = mi.parse(h);
                  if (y) return y;
                }
                throw new Kn(`Could not parse padding from value '${typeof h == "string" ? h : JSON.stringify(h)}'`);
              }
              case "variableAnchorOffsetCollection": {
                let h;
                for (const p of this.args) {
                  h = p.evaluate(c);
                  const y = Yi.parse(h);
                  if (y) return y;
                }
                throw new Kn(`Could not parse variableAnchorOffsetCollection from value '${typeof h == "string" ? h : JSON.stringify(h)}'`);
              }
              case "number": {
                let h = null;
                for (const p of this.args) {
                  if (h = p.evaluate(c), h === null) return 0;
                  const y = Number(h);
                  if (!isNaN(y)) return y;
                }
                throw new Kn(`Could not convert ${JSON.stringify(h)} to number.`);
              }
              case "formatted":
                return oi.fromString(Bl(this.args[0].evaluate(c)));
              case "resolvedImage":
                return ai.fromString(Bl(this.args[0].evaluate(c)));
              case "projectionDefinition":
                return this.args[0].evaluate(c);
              default:
                return Bl(this.args[0].evaluate(c));
            }
          }
          eachChild(c) {
            this.args.forEach(c);
          }
          outputDefined() {
            return this.args.every((c) => c.outputDefined());
          }
        }
        const Ll = ["Unknown", "Point", "LineString", "Polygon"];
        class Fn {
          constructor() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          }
          id() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }
          geometryType() {
            return this.feature ? typeof this.feature.type == "number" ? Ll[this.feature.type] : this.feature.type : null;
          }
          geometry() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }
          canonicalID() {
            return this.canonical;
          }
          properties() {
            return this.feature && this.feature.properties || {};
          }
          parseColor(c) {
            let h = this._parseColorCache[c];
            return h || (h = this._parseColorCache[c] = nn.parse(c)), h;
          }
        }
        class Xo {
          constructor(c, h) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], y = arguments.length > 3 ? arguments[3] : void 0, x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new Kt(), A = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
            this.registry = c, this.path = p, this.key = p.map((I) => `[${I}]`).join(""), this.scope = x, this.errors = A, this.expectedType = y, this._isConstant = h;
          }
          parse(c, h, p, y) {
            let x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
            return h ? this.concat(h, p, y)._parse(c, x) : this._parse(c, x);
          }
          _parse(c, h) {
            function p(y, x, A) {
              return A === "assert" ? new Ys(x, [y]) : A === "coerce" ? new Ki(x, [y]) : y;
            }
            if (c !== null && typeof c != "string" && typeof c != "boolean" && typeof c != "number" || (c = ["literal", c]), Array.isArray(c)) {
              if (c.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              const y = c[0];
              if (typeof y != "string") return this.error(`Expression name must be a string, but found ${typeof y} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
              const x = this.registry[y];
              if (x) {
                let A = x.parse(c, this);
                if (!A) return null;
                if (this.expectedType) {
                  const I = this.expectedType, B = A.type;
                  if (I.kind !== "string" && I.kind !== "number" && I.kind !== "boolean" && I.kind !== "object" && I.kind !== "array" || B.kind !== "value")
                    if (I.kind !== "projectionDefinition" || B.kind !== "string" && B.kind !== "array")
                      if (I.kind !== "color" && I.kind !== "formatted" && I.kind !== "resolvedImage" || B.kind !== "value" && B.kind !== "string")
                        if (I.kind !== "padding" || B.kind !== "value" && B.kind !== "number" && B.kind !== "array")
                          if (I.kind !== "variableAnchorOffsetCollection" || B.kind !== "value" && B.kind !== "array") {
                            if (this.checkSubtype(I, B)) return null;
                          } else A = p(A, I, h.typeAnnotation || "coerce");
                        else A = p(A, I, h.typeAnnotation || "coerce");
                      else A = p(A, I, h.typeAnnotation || "coerce");
                    else A = p(A, I, h.typeAnnotation || "coerce");
                  else A = p(A, I, h.typeAnnotation || "assert");
                }
                if (!(A instanceof uo) && A.type.kind !== "resolvedImage" && this._isConstant(A)) {
                  const I = new Fn();
                  try {
                    A = new uo(A.type, A.evaluate(I));
                  } catch (B) {
                    return this.error(B.message), null;
                  }
                }
                return A;
              }
              return this.error(`Unknown expression "${y}". If you wanted a literal array, use ["literal", [...]].`, 0);
            }
            return this.error(c === void 0 ? "'undefined' value invalid. Use null instead." : typeof c == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof c} instead.`);
          }
          concat(c, h, p) {
            const y = typeof c == "number" ? this.path.concat(c) : this.path, x = p ? this.scope.concat(p) : this.scope;
            return new Xo(this.registry, this._isConstant, y, h || null, x, this.errors);
          }
          error(c) {
            for (var h = arguments.length, p = new Array(h > 1 ? h - 1 : 0), y = 1; y < h; y++)
              p[y - 1] = arguments[y];
            const x = `${this.key}${p.map((A) => `[${A}]`).join("")}`;
            this.errors.push(new Jt(x, c));
          }
          checkSubtype(c, h) {
            const p = Wo(c, h);
            return p && this.error(p), p;
          }
        }
        class ln {
          constructor(c, h) {
            this.type = h.type, this.bindings = [].concat(c), this.result = h;
          }
          evaluate(c) {
            return this.result.evaluate(c);
          }
          eachChild(c) {
            for (const h of this.bindings) c(h[1]);
            c(this.result);
          }
          static parse(c, h) {
            if (c.length < 4) return h.error(`Expected at least 3 arguments, but found ${c.length - 1} instead.`);
            const p = [];
            for (let x = 1; x < c.length - 1; x += 2) {
              const A = c[x];
              if (typeof A != "string") return h.error(`Expected string, but found ${typeof A} instead.`, x);
              if (/[^a-zA-Z0-9_]/.test(A)) return h.error("Variable names must contain only alphanumeric characters or '_'.", x);
              const I = h.parse(c[x + 1], x + 1);
              if (!I) return null;
              p.push([A, I]);
            }
            const y = h.parse(c[c.length - 1], c.length - 1, h.expectedType, p);
            return y ? new ln(p, y) : null;
          }
          outputDefined() {
            return this.result.outputDefined();
          }
        }
        class Xr {
          constructor(c, h) {
            this.type = h.type, this.name = c, this.boundExpression = h;
          }
          static parse(c, h) {
            if (c.length !== 2 || typeof c[1] != "string") return h.error("'var' expression requires exactly one string literal argument.");
            const p = c[1];
            return h.scope.has(p) ? new Xr(p, h.scope.get(p)) : h.error(`Unknown variable "${p}". Make sure "${p}" has been bound in an enclosing "let" expression before using it.`, 1);
          }
          evaluate(c) {
            return this.boundExpression.evaluate(c);
          }
          eachChild() {
          }
          outputDefined() {
            return !1;
          }
        }
        class Ol {
          constructor(c, h, p) {
            this.type = c, this.index = h, this.input = p;
          }
          static parse(c, h) {
            if (c.length !== 3) return h.error(`Expected 2 arguments, but found ${c.length - 1} instead.`);
            const p = h.parse(c[1], 1, Bt), y = h.parse(c[2], 2, Ai(h.expectedType || gr));
            return p && y ? new Ol(y.type.itemType, p, y) : null;
          }
          evaluate(c) {
            const h = this.index.evaluate(c), p = this.input.evaluate(c);
            if (h < 0) throw new Kn(`Array index out of bounds: ${h} < 0.`);
            if (h >= p.length) throw new Kn(`Array index out of bounds: ${h} > ${p.length - 1}.`);
            if (h !== Math.floor(h)) throw new Kn(`Array index must be an integer, but found ${h} instead.`);
            return p[h];
          }
          eachChild(c) {
            c(this.index), c(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class dn {
          constructor(c, h) {
            this.type = fr, this.needle = c, this.haystack = h;
          }
          static parse(c, h) {
            if (c.length !== 3) return h.error(`Expected 2 arguments, but found ${c.length - 1} instead.`);
            const p = h.parse(c[1], 1, gr), y = h.parse(c[2], 2, gr);
            return p && y ? tl(p.type, [fr, Qt, Bt, Mr, gr]) ? new dn(p, y) : h.error(`Expected first argument to be of type boolean, string, number or null, but found ${In(p.type)} instead`) : null;
          }
          evaluate(c) {
            const h = this.needle.evaluate(c), p = this.haystack.evaluate(c);
            if (!p) return !1;
            if (!wo(h, ["boolean", "string", "number", "null"])) throw new Kn(`Expected first argument to be of type boolean, string, number or null, but found ${In(an(h))} instead.`);
            if (!wo(p, ["string", "array"])) throw new Kn(`Expected second argument to be of type array or string, but found ${In(an(p))} instead.`);
            return p.indexOf(h) >= 0;
          }
          eachChild(c) {
            c(this.needle), c(this.haystack);
          }
          outputDefined() {
            return !0;
          }
        }
        class ha {
          constructor(c, h, p) {
            this.type = Bt, this.needle = c, this.haystack = h, this.fromIndex = p;
          }
          static parse(c, h) {
            if (c.length <= 2 || c.length >= 5) return h.error(`Expected 3 or 4 arguments, but found ${c.length - 1} instead.`);
            const p = h.parse(c[1], 1, gr), y = h.parse(c[2], 2, gr);
            if (!p || !y) return null;
            if (!tl(p.type, [fr, Qt, Bt, Mr, gr])) return h.error(`Expected first argument to be of type boolean, string, number or null, but found ${In(p.type)} instead`);
            if (c.length === 4) {
              const x = h.parse(c[3], 3, Bt);
              return x ? new ha(p, y, x) : null;
            }
            return new ha(p, y);
          }
          evaluate(c) {
            const h = this.needle.evaluate(c), p = this.haystack.evaluate(c);
            if (!wo(h, ["boolean", "string", "number", "null"])) throw new Kn(`Expected first argument to be of type boolean, string, number or null, but found ${In(an(h))} instead.`);
            let y;
            if (this.fromIndex && (y = this.fromIndex.evaluate(c)), wo(p, ["string"])) {
              const x = p.indexOf(h, y);
              return x === -1 ? -1 : [...p.slice(0, x)].length;
            }
            if (wo(p, ["array"])) return p.indexOf(h, y);
            throw new Kn(`Expected second argument to be of type array or string, but found ${In(an(p))} instead.`);
          }
          eachChild(c) {
            c(this.needle), c(this.haystack), this.fromIndex && c(this.fromIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        class fs {
          constructor(c, h, p, y, x, A) {
            this.inputType = c, this.type = h, this.input = p, this.cases = y, this.outputs = x, this.otherwise = A;
          }
          static parse(c, h) {
            if (c.length < 5) return h.error(`Expected at least 4 arguments, but found only ${c.length - 1}.`);
            if (c.length % 2 != 1) return h.error("Expected an even number of arguments.");
            let p, y;
            h.expectedType && h.expectedType.kind !== "value" && (y = h.expectedType);
            const x = {}, A = [];
            for (let N = 2; N < c.length - 1; N += 2) {
              let z = c[N];
              const j = c[N + 1];
              Array.isArray(z) || (z = [z]);
              const K = h.concat(N);
              if (z.length === 0) return K.error("Expected at least one branch label.");
              for (const te of z) {
                if (typeof te != "number" && typeof te != "string") return K.error("Branch labels must be numbers or strings.");
                if (typeof te == "number" && Math.abs(te) > Number.MAX_SAFE_INTEGER) return K.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                if (typeof te == "number" && Math.floor(te) !== te) return K.error("Numeric branch labels must be integer values.");
                if (p) {
                  if (K.checkSubtype(p, an(te))) return null;
                } else p = an(te);
                if (x[String(te)] !== void 0) return K.error("Branch labels must be unique.");
                x[String(te)] = A.length;
              }
              const ee = h.parse(j, N, y);
              if (!ee) return null;
              y = y || ee.type, A.push(ee);
            }
            const I = h.parse(c[1], 1, gr);
            if (!I) return null;
            const B = h.parse(c[c.length - 1], c.length - 1, y);
            return B ? I.type.kind !== "value" && h.concat(1).checkSubtype(p, I.type) ? null : new fs(p, y, I, x, A, B) : null;
          }
          evaluate(c) {
            const h = this.input.evaluate(c);
            return (an(h) === this.inputType && this.outputs[this.cases[h]] || this.otherwise).evaluate(c);
          }
          eachChild(c) {
            c(this.input), this.outputs.forEach(c), c(this.otherwise);
          }
          outputDefined() {
            return this.outputs.every((c) => c.outputDefined()) && this.otherwise.outputDefined();
          }
        }
        class Ao {
          constructor(c, h, p) {
            this.type = c, this.branches = h, this.otherwise = p;
          }
          static parse(c, h) {
            if (c.length < 4) return h.error(`Expected at least 3 arguments, but found only ${c.length - 1}.`);
            if (c.length % 2 != 0) return h.error("Expected an odd number of arguments.");
            let p;
            h.expectedType && h.expectedType.kind !== "value" && (p = h.expectedType);
            const y = [];
            for (let A = 1; A < c.length - 1; A += 2) {
              const I = h.parse(c[A], A, fr);
              if (!I) return null;
              const B = h.parse(c[A + 1], A + 1, p);
              if (!B) return null;
              y.push([I, B]), p = p || B.type;
            }
            const x = h.parse(c[c.length - 1], c.length - 1, p);
            if (!x) return null;
            if (!p) throw new Error("Can't infer output type");
            return new Ao(p, y, x);
          }
          evaluate(c) {
            for (const [h, p] of this.branches) if (h.evaluate(c)) return p.evaluate(c);
            return this.otherwise.evaluate(c);
          }
          eachChild(c) {
            for (const [h, p] of this.branches) c(h), c(p);
            c(this.otherwise);
          }
          outputDefined() {
            return this.branches.every((c) => {
              let [h, p] = c;
              return p.outputDefined();
            }) && this.otherwise.outputDefined();
          }
        }
        class Nl {
          constructor(c, h, p, y) {
            this.type = c, this.input = h, this.beginIndex = p, this.endIndex = y;
          }
          static parse(c, h) {
            if (c.length <= 2 || c.length >= 5) return h.error(`Expected 3 or 4 arguments, but found ${c.length - 1} instead.`);
            const p = h.parse(c[1], 1, gr), y = h.parse(c[2], 2, Bt);
            if (!p || !y) return null;
            if (!tl(p.type, [Ai(gr), Qt, gr])) return h.error(`Expected first argument to be of type array or string, but found ${In(p.type)} instead`);
            if (c.length === 4) {
              const x = h.parse(c[3], 3, Bt);
              return x ? new Nl(p.type, p, y, x) : null;
            }
            return new Nl(p.type, p, y);
          }
          evaluate(c) {
            const h = this.input.evaluate(c), p = this.beginIndex.evaluate(c);
            let y;
            if (this.endIndex && (y = this.endIndex.evaluate(c)), wo(h, ["string"])) return [...h].slice(p, y).join("");
            if (wo(h, ["array"])) return h.slice(p, y);
            throw new Kn(`Expected first argument to be of type array or string, but found ${In(an(h))} instead.`);
          }
          eachChild(c) {
            c(this.input), c(this.beginIndex), this.endIndex && c(this.endIndex);
          }
          outputDefined() {
            return !1;
          }
        }
        function Zo(f, c) {
          const h = f.length - 1;
          let p, y, x = 0, A = h, I = 0;
          for (; x <= A; ) if (I = Math.floor((x + A) / 2), p = f[I], y = f[I + 1], p <= c) {
            if (I === h || c < y) return I;
            x = I + 1;
          } else {
            if (!(p > c)) throw new Kn("Input is not a number.");
            A = I - 1;
          }
          return 0;
        }
        class Yo {
          constructor(c, h, p) {
            this.type = c, this.input = h, this.labels = [], this.outputs = [];
            for (const [y, x] of p) this.labels.push(y), this.outputs.push(x);
          }
          static parse(c, h) {
            if (c.length - 1 < 4) return h.error(`Expected at least 4 arguments, but found only ${c.length - 1}.`);
            if ((c.length - 1) % 2 != 0) return h.error("Expected an even number of arguments.");
            const p = h.parse(c[1], 1, Bt);
            if (!p) return null;
            const y = [];
            let x = null;
            h.expectedType && h.expectedType.kind !== "value" && (x = h.expectedType);
            for (let A = 1; A < c.length; A += 2) {
              const I = A === 1 ? -1 / 0 : c[A], B = c[A + 1], N = A, z = A + 1;
              if (typeof I != "number") return h.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', N);
              if (y.length && y[y.length - 1][0] >= I) return h.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', N);
              const j = h.parse(B, z, x);
              if (!j) return null;
              x = x || j.type, y.push([I, j]);
            }
            return new Yo(x, p, y);
          }
          evaluate(c) {
            const h = this.labels, p = this.outputs;
            if (h.length === 1) return p[0].evaluate(c);
            const y = this.input.evaluate(c);
            if (y <= h[0]) return p[0].evaluate(c);
            const x = h.length;
            return y >= h[x - 1] ? p[x - 1].evaluate(c) : p[Zo(h, y)].evaluate(c);
          }
          eachChild(c) {
            c(this.input);
            for (const h of this.outputs) c(h);
          }
          outputDefined() {
            return this.outputs.every((c) => c.outputDefined());
          }
        }
        function Dl(f) {
          return f && f.__esModule && Object.prototype.hasOwnProperty.call(f, "default") ? f.default : f;
        }
        var Dc, kc, mu = function() {
          if (kc) return Dc;
          function f(c, h, p, y) {
            this.cx = 3 * c, this.bx = 3 * (p - c) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * h, this.by = 3 * (y - h) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = c, this.p1y = h, this.p2x = p, this.p2y = y;
          }
          return kc = 1, Dc = f, f.prototype = { sampleCurveX: function(c) {
            return ((this.ax * c + this.bx) * c + this.cx) * c;
          }, sampleCurveY: function(c) {
            return ((this.ay * c + this.by) * c + this.cy) * c;
          }, sampleCurveDerivativeX: function(c) {
            return (3 * this.ax * c + 2 * this.bx) * c + this.cx;
          }, solveCurveX: function(c, h) {
            if (h === void 0 && (h = 1e-6), c < 0) return 0;
            if (c > 1) return 1;
            for (var p = c, y = 0; y < 8; y++) {
              var x = this.sampleCurveX(p) - c;
              if (Math.abs(x) < h) return p;
              var A = this.sampleCurveDerivativeX(p);
              if (Math.abs(A) < 1e-6) break;
              p -= x / A;
            }
            var I = 0, B = 1;
            for (p = c, y = 0; y < 20 && (x = this.sampleCurveX(p), !(Math.abs(x - c) < h)); y++) c > x ? I = p : B = p, p = 0.5 * (B - I) + I;
            return p;
          }, solve: function(c, h) {
            return this.sampleCurveY(this.solveCurveX(c, h));
          } }, Dc;
        }(), al = Dl(mu);
        class gn {
          constructor(c, h, p, y, x) {
            this.type = c, this.operator = h, this.interpolation = p, this.input = y, this.labels = [], this.outputs = [];
            for (const [A, I] of x) this.labels.push(A), this.outputs.push(I);
          }
          static interpolationFactor(c, h, p, y) {
            let x = 0;
            if (c.name === "exponential") x = Ks(h, c.base, p, y);
            else if (c.name === "linear") x = Ks(h, 1, p, y);
            else if (c.name === "cubic-bezier") {
              const A = c.controlPoints;
              x = new al(A[0], A[1], A[2], A[3]).solve(Ks(h, 1, p, y));
            }
            return x;
          }
          static parse(c, h) {
            let [p, y, x, ...A] = c;
            if (!Array.isArray(y) || y.length === 0) return h.error("Expected an interpolation type expression.", 1);
            if (y[0] === "linear") y = { name: "linear" };
            else if (y[0] === "exponential") {
              const N = y[1];
              if (typeof N != "number") return h.error("Exponential interpolation requires a numeric base.", 1, 1);
              y = { name: "exponential", base: N };
            } else {
              if (y[0] !== "cubic-bezier") return h.error(`Unknown interpolation type ${String(y[0])}`, 1, 0);
              {
                const N = y.slice(1);
                if (N.length !== 4 || N.some((z) => typeof z != "number" || z < 0 || z > 1)) return h.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                y = { name: "cubic-bezier", controlPoints: N };
              }
            }
            if (c.length - 1 < 4) return h.error(`Expected at least 4 arguments, but found only ${c.length - 1}.`);
            if ((c.length - 1) % 2 != 0) return h.error("Expected an even number of arguments.");
            if (x = h.parse(x, 2, Bt), !x) return null;
            const I = [];
            let B = null;
            p === "interpolate-hcl" || p === "interpolate-lab" ? B = Lr : h.expectedType && h.expectedType.kind !== "value" && (B = h.expectedType);
            for (let N = 0; N < A.length; N += 2) {
              const z = A[N], j = A[N + 1], K = N + 3, ee = N + 4;
              if (typeof z != "number") return h.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', K);
              if (I.length && I[I.length - 1][0] >= z) return h.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', K);
              const te = h.parse(j, ee, B);
              if (!te) return null;
              B = B || te.type, I.push([z, te]);
            }
            return la(B, Bt) || la(B, Hr) || la(B, Lr) || la(B, Dn) || la(B, vn) || la(B, Ai(Bt)) ? new gn(B, p, y, x, I) : h.error(`Type ${In(B)} is not interpolatable.`);
          }
          evaluate(c) {
            const h = this.labels, p = this.outputs;
            if (h.length === 1) return p[0].evaluate(c);
            const y = this.input.evaluate(c);
            if (y <= h[0]) return p[0].evaluate(c);
            const x = h.length;
            if (y >= h[x - 1]) return p[x - 1].evaluate(c);
            const A = Zo(h, y), I = gn.interpolationFactor(this.interpolation, y, h[A], h[A + 1]), B = p[A].evaluate(c), N = p[A + 1].evaluate(c);
            switch (this.operator) {
              case "interpolate":
                switch (this.type.kind) {
                  case "number":
                    return Yr(B, N, I);
                  case "color":
                    return nn.interpolate(B, N, I);
                  case "padding":
                    return mi.interpolate(B, N, I);
                  case "variableAnchorOffsetCollection":
                    return Yi.interpolate(B, N, I);
                  case "array":
                    return co(B, N, I);
                  case "projectionDefinition":
                    return Mi.interpolate(B, N, I);
                }
              case "interpolate-hcl":
                return nn.interpolate(B, N, I, "hcl");
              case "interpolate-lab":
                return nn.interpolate(B, N, I, "lab");
            }
          }
          eachChild(c) {
            c(this.input);
            for (const h of this.outputs) c(h);
          }
          outputDefined() {
            return this.outputs.every((c) => c.outputDefined());
          }
        }
        function Ks(f, c, h, p) {
          const y = p - h, x = f - h;
          return y === 0 ? 0 : c === 1 ? x / y : (Math.pow(c, x) - 1) / (Math.pow(c, y) - 1);
        }
        const ho = { color: nn.interpolate, number: Yr, padding: mi.interpolate, variableAnchorOffsetCollection: Yi.interpolate, array: co };
        class Js {
          constructor(c, h) {
            this.type = c, this.args = h;
          }
          static parse(c, h) {
            if (c.length < 2) return h.error("Expected at least one argument.");
            let p = null;
            const y = h.expectedType;
            y && y.kind !== "value" && (p = y);
            const x = [];
            for (const I of c.slice(1)) {
              const B = h.parse(I, 1 + x.length, p, void 0, { typeAnnotation: "omit" });
              if (!B) return null;
              p = p || B.type, x.push(B);
            }
            if (!p) throw new Error("No output type");
            const A = y && x.some((I) => Wo(y, I.type));
            return new Js(A ? gr : p, x);
          }
          evaluate(c) {
            let h, p = null, y = 0;
            for (const x of this.args) if (y++, p = x.evaluate(c), p && p instanceof ai && !p.available && (h || (h = p.name), p = null, y === this.args.length && (p = h)), p !== null) break;
            return p;
          }
          eachChild(c) {
            this.args.forEach(c);
          }
          outputDefined() {
            return this.args.every((c) => c.outputDefined());
          }
        }
        function Un(f, c) {
          return f === "==" || f === "!=" ? c.kind === "boolean" || c.kind === "string" || c.kind === "number" || c.kind === "null" || c.kind === "value" : c.kind === "string" || c.kind === "number" || c.kind === "value";
        }
        function kl(f, c, h, p) {
          return p.compare(c, h) === 0;
        }
        function Qs(f, c, h) {
          const p = f !== "==" && f !== "!=";
          return class sE {
            constructor(x, A, I) {
              this.type = fr, this.lhs = x, this.rhs = A, this.collator = I, this.hasUntypedArgument = x.type.kind === "value" || A.type.kind === "value";
            }
            static parse(x, A) {
              if (x.length !== 3 && x.length !== 4) return A.error("Expected two or three arguments.");
              const I = x[0];
              let B = A.parse(x[1], 1, gr);
              if (!B) return null;
              if (!Un(I, B.type)) return A.concat(1).error(`"${I}" comparisons are not supported for type '${In(B.type)}'.`);
              let N = A.parse(x[2], 2, gr);
              if (!N) return null;
              if (!Un(I, N.type)) return A.concat(2).error(`"${I}" comparisons are not supported for type '${In(N.type)}'.`);
              if (B.type.kind !== N.type.kind && B.type.kind !== "value" && N.type.kind !== "value") return A.error(`Cannot compare types '${In(B.type)}' and '${In(N.type)}'.`);
              p && (B.type.kind === "value" && N.type.kind !== "value" ? B = new Ys(N.type, [B]) : B.type.kind !== "value" && N.type.kind === "value" && (N = new Ys(B.type, [N])));
              let z = null;
              if (x.length === 4) {
                if (B.type.kind !== "string" && N.type.kind !== "string" && B.type.kind !== "value" && N.type.kind !== "value") return A.error("Cannot use collator to compare non-string types.");
                if (z = A.parse(x[3], 3, Sn), !z) return null;
              }
              return new sE(B, N, z);
            }
            evaluate(x) {
              const A = this.lhs.evaluate(x), I = this.rhs.evaluate(x);
              if (p && this.hasUntypedArgument) {
                const B = an(A), N = an(I);
                if (B.kind !== N.kind || B.kind !== "string" && B.kind !== "number") throw new Kn(`Expected arguments for "${f}" to be (string, string) or (number, number), but found (${B.kind}, ${N.kind}) instead.`);
              }
              if (this.collator && !p && this.hasUntypedArgument) {
                const B = an(A), N = an(I);
                if (B.kind !== "string" || N.kind !== "string") return c(x, A, I);
              }
              return this.collator ? h(x, A, I, this.collator.evaluate(x)) : c(x, A, I);
            }
            eachChild(x) {
              x(this.lhs), x(this.rhs), this.collator && x(this.collator);
            }
            outputDefined() {
              return !0;
            }
          };
        }
        const Wu = Qs("==", function(f, c, h) {
          return c === h;
        }, kl), Fc = Qs("!=", function(f, c, h) {
          return c !== h;
        }, function(f, c, h, p) {
          return !kl(0, c, h, p);
        }), Uc = Qs("<", function(f, c, h) {
          return c < h;
        }, function(f, c, h, p) {
          return p.compare(c, h) < 0;
        }), Fl = Qs(">", function(f, c, h) {
          return c > h;
        }, function(f, c, h, p) {
          return p.compare(c, h) > 0;
        }), _u = Qs("<=", function(f, c, h) {
          return c <= h;
        }, function(f, c, h, p) {
          return p.compare(c, h) <= 0;
        }), Ul = Qs(">=", function(f, c, h) {
          return c >= h;
        }, function(f, c, h, p) {
          return p.compare(c, h) >= 0;
        });
        class To {
          constructor(c, h, p) {
            this.type = Sn, this.locale = p, this.caseSensitive = c, this.diacriticSensitive = h;
          }
          static parse(c, h) {
            if (c.length !== 2) return h.error("Expected one argument.");
            const p = c[1];
            if (typeof p != "object" || Array.isArray(p)) return h.error("Collator options argument must be an object.");
            const y = h.parse(p["case-sensitive"] !== void 0 && p["case-sensitive"], 1, fr);
            if (!y) return null;
            const x = h.parse(p["diacritic-sensitive"] !== void 0 && p["diacritic-sensitive"], 1, fr);
            if (!x) return null;
            let A = null;
            return p.locale && (A = h.parse(p.locale, 1, Qt), !A) ? null : new To(y, x, A);
          }
          evaluate(c) {
            return new Rl(this.caseSensitive.evaluate(c), this.diacriticSensitive.evaluate(c), this.locale ? this.locale.evaluate(c) : null);
          }
          eachChild(c) {
            c(this.caseSensitive), c(this.diacriticSensitive), this.locale && c(this.locale);
          }
          outputDefined() {
            return !1;
          }
        }
        class ds {
          constructor(c, h, p, y, x) {
            this.type = Qt, this.number = c, this.locale = h, this.currency = p, this.minFractionDigits = y, this.maxFractionDigits = x;
          }
          static parse(c, h) {
            if (c.length !== 3) return h.error("Expected two arguments.");
            const p = h.parse(c[1], 1, Bt);
            if (!p) return null;
            const y = c[2];
            if (typeof y != "object" || Array.isArray(y)) return h.error("NumberFormat options argument must be an object.");
            let x = null;
            if (y.locale && (x = h.parse(y.locale, 1, Qt), !x)) return null;
            let A = null;
            if (y.currency && (A = h.parse(y.currency, 1, Qt), !A)) return null;
            let I = null;
            if (y["min-fraction-digits"] && (I = h.parse(y["min-fraction-digits"], 1, Bt), !I)) return null;
            let B = null;
            return y["max-fraction-digits"] && (B = h.parse(y["max-fraction-digits"], 1, Bt), !B) ? null : new ds(p, x, A, I, B);
          }
          evaluate(c) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(c) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(c) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(c) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(c) : void 0 }).format(this.number.evaluate(c));
          }
          eachChild(c) {
            c(this.number), this.locale && c(this.locale), this.currency && c(this.currency), this.minFractionDigits && c(this.minFractionDigits), this.maxFractionDigits && c(this.maxFractionDigits);
          }
          outputDefined() {
            return !1;
          }
        }
        class Ma {
          constructor(c) {
            this.type = Zi, this.sections = c;
          }
          static parse(c, h) {
            if (c.length < 2) return h.error("Expected at least one argument.");
            const p = c[1];
            if (!Array.isArray(p) && typeof p == "object") return h.error("First argument must be an image or text section.");
            const y = [];
            let x = !1;
            for (let A = 1; A <= c.length - 1; ++A) {
              const I = c[A];
              if (x && typeof I == "object" && !Array.isArray(I)) {
                x = !1;
                let B = null;
                if (I["font-scale"] && (B = h.parse(I["font-scale"], 1, Bt), !B)) return null;
                let N = null;
                if (I["text-font"] && (N = h.parse(I["text-font"], 1, Ai(Qt)), !N)) return null;
                let z = null;
                if (I["text-color"] && (z = h.parse(I["text-color"], 1, Lr), !z)) return null;
                let j = null;
                if (I["vertical-align"]) {
                  if (typeof I["vertical-align"] == "string" && !Hu.includes(I["vertical-align"])) return h.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${I["vertical-align"]}' instead.`);
                  if (j = h.parse(I["vertical-align"], 1, Qt), !j) return null;
                }
                const K = y[y.length - 1];
                K.scale = B, K.font = N, K.textColor = z, K.verticalAlign = j;
              } else {
                const B = h.parse(c[A], 1, gr);
                if (!B) return null;
                const N = B.type.kind;
                if (N !== "string" && N !== "value" && N !== "null" && N !== "resolvedImage") return h.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                x = !0, y.push({ content: B, scale: null, font: null, textColor: null, verticalAlign: null });
              }
            }
            return new Ma(y);
          }
          evaluate(c) {
            return new oi(this.sections.map((h) => {
              const p = h.content.evaluate(c);
              return an(p) === kn ? new sl("", p, null, null, null, h.verticalAlign ? h.verticalAlign.evaluate(c) : null) : new sl(Bl(p), null, h.scale ? h.scale.evaluate(c) : null, h.font ? h.font.evaluate(c).join(",") : null, h.textColor ? h.textColor.evaluate(c) : null, h.verticalAlign ? h.verticalAlign.evaluate(c) : null);
            }));
          }
          eachChild(c) {
            for (const h of this.sections) c(h.content), h.scale && c(h.scale), h.font && c(h.font), h.textColor && c(h.textColor), h.verticalAlign && c(h.verticalAlign);
          }
          outputDefined() {
            return !1;
          }
        }
        class Pa {
          constructor(c) {
            this.type = kn, this.input = c;
          }
          static parse(c, h) {
            if (c.length !== 2) return h.error("Expected two arguments.");
            const p = h.parse(c[1], 1, Qt);
            return p ? new Pa(p) : h.error("No image name provided.");
          }
          evaluate(c) {
            const h = this.input.evaluate(c), p = ai.fromString(h);
            return p && c.availableImages && (p.available = c.availableImages.indexOf(h) > -1), p;
          }
          eachChild(c) {
            c(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        class yu {
          constructor(c) {
            this.type = Bt, this.input = c;
          }
          static parse(c, h) {
            if (c.length !== 2) return h.error(`Expected 1 argument, but found ${c.length - 1} instead.`);
            const p = h.parse(c[1], 1);
            return p ? p.type.kind !== "array" && p.type.kind !== "string" && p.type.kind !== "value" ? h.error(`Expected argument of type string or array, but found ${In(p.type)} instead.`) : new yu(p) : null;
          }
          evaluate(c) {
            const h = this.input.evaluate(c);
            if (typeof h == "string") return [...h].length;
            if (Array.isArray(h)) return h.length;
            throw new Kn(`Expected value to be of type string or array, but found ${In(an(h))} instead.`);
          }
          eachChild(c) {
            c(this.input);
          }
          outputDefined() {
            return !1;
          }
        }
        const ps = 8192;
        function zl(f, c) {
          const h = (180 + f[0]) / 360, p = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + f[1] * Math.PI / 360))) / 360, y = Math.pow(2, c.z);
          return [Math.round(h * y * ps), Math.round(p * y * ps)];
        }
        function jl(f, c) {
          const h = Math.pow(2, c.z);
          return [(y = (f[0] / ps + c.x) / h, 360 * y - 180), (p = (f[1] / ps + c.y) / h, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * p) * Math.PI / 180)) - 90)];
          var p, y;
        }
        function So(f, c) {
          f[0] = Math.min(f[0], c[0]), f[1] = Math.min(f[1], c[1]), f[2] = Math.max(f[2], c[0]), f[3] = Math.max(f[3], c[1]);
        }
        function Ra(f, c) {
          return !(f[0] <= c[0] || f[2] >= c[2] || f[1] <= c[1] || f[3] >= c[3]);
        }
        function O(f, c, h) {
          const p = f[0] - c[0], y = f[1] - c[1], x = f[0] - h[0], A = f[1] - h[1];
          return p * A - x * y == 0 && p * x <= 0 && y * A <= 0;
        }
        function ne(f, c, h, p) {
          return (y = [p[0] - h[0], p[1] - h[1]])[0] * (x = [c[0] - f[0], c[1] - f[1]])[1] - y[1] * x[0] != 0 && !(!Tr(f, c, h, p) || !Tr(h, p, f, c));
          var y, x;
        }
        function De(f, c, h) {
          for (const p of h) for (let y = 0; y < p.length - 1; ++y) if (ne(f, c, p[y], p[y + 1])) return !0;
          return !1;
        }
        function Ke(f, c) {
          let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, p = !1;
          for (const I of c) for (let B = 0; B < I.length - 1; B++) {
            if (O(f, I[B], I[B + 1])) return h;
            (x = I[B])[1] > (y = f)[1] != (A = I[B + 1])[1] > y[1] && y[0] < (A[0] - x[0]) * (y[1] - x[1]) / (A[1] - x[1]) + x[0] && (p = !p);
          }
          var y, x, A;
          return p;
        }
        function mt(f, c) {
          for (const h of c) if (Ke(f, h)) return !0;
          return !1;
        }
        function zt(f, c) {
          for (const h of f) if (!Ke(h, c)) return !1;
          for (let h = 0; h < f.length - 1; ++h) if (De(f[h], f[h + 1], c)) return !1;
          return !0;
        }
        function tr(f, c) {
          for (const h of c) if (zt(f, h)) return !0;
          return !1;
        }
        function Tr(f, c, h, p) {
          const y = p[0] - h[0], x = p[1] - h[1], A = (f[0] - h[0]) * x - y * (f[1] - h[1]), I = (c[0] - h[0]) * x - y * (c[1] - h[1]);
          return A > 0 && I < 0 || A < 0 && I > 0;
        }
        function kr(f, c, h) {
          const p = [];
          for (let y = 0; y < f.length; y++) {
            const x = [];
            for (let A = 0; A < f[y].length; A++) {
              const I = zl(f[y][A], h);
              So(c, I), x.push(I);
            }
            p.push(x);
          }
          return p;
        }
        function tn(f, c, h) {
          const p = [];
          for (let y = 0; y < f.length; y++) {
            const x = kr(f[y], c, h);
            p.push(x);
          }
          return p;
        }
        function Kr(f, c, h, p) {
          if (f[0] < h[0] || f[0] > h[2]) {
            const y = 0.5 * p;
            let x = f[0] - h[0] > y ? -p : h[0] - f[0] > y ? p : 0;
            x === 0 && (x = f[0] - h[2] > y ? -p : h[2] - f[0] > y ? p : 0), f[0] += x;
          }
          So(c, f);
        }
        function xn(f, c, h, p) {
          const y = Math.pow(2, p.z) * ps, x = [p.x * ps, p.y * ps], A = [];
          for (const I of f) for (const B of I) {
            const N = [B.x + x[0], B.y + x[1]];
            Kr(N, c, h, y), A.push(N);
          }
          return A;
        }
        function ti(f, c, h, p) {
          const y = Math.pow(2, p.z) * ps, x = [p.x * ps, p.y * ps], A = [];
          for (const B of f) {
            const N = [];
            for (const z of B) {
              const j = [z.x + x[0], z.y + x[1]];
              So(c, j), N.push(j);
            }
            A.push(N);
          }
          if (c[2] - c[0] <= y / 2) {
            (I = c)[0] = I[1] = 1 / 0, I[2] = I[3] = -1 / 0;
            for (const B of A) for (const N of B) Kr(N, c, h, y);
          }
          var I;
          return A;
        }
        class Gn {
          constructor(c, h) {
            this.type = fr, this.geojson = c, this.geometries = h;
          }
          static parse(c, h) {
            if (c.length !== 2) return h.error(`'within' expression requires exactly one argument, but found ${c.length - 1} instead.`);
            if (ua(c[1])) {
              const p = c[1];
              if (p.type === "FeatureCollection") {
                const y = [];
                for (const x of p.features) {
                  const { type: A, coordinates: I } = x.geometry;
                  A === "Polygon" && y.push(I), A === "MultiPolygon" && y.push(...I);
                }
                if (y.length) return new Gn(p, { type: "MultiPolygon", coordinates: y });
              } else if (p.type === "Feature") {
                const y = p.geometry.type;
                if (y === "Polygon" || y === "MultiPolygon") return new Gn(p, p.geometry);
              } else if (p.type === "Polygon" || p.type === "MultiPolygon") return new Gn(p, p);
            }
            return h.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(c) {
            if (c.geometry() != null && c.canonicalID() != null) {
              if (c.geometryType() === "Point") return function(h, p) {
                const y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], A = h.canonicalID();
                if (p.type === "Polygon") {
                  const I = kr(p.coordinates, x, A), B = xn(h.geometry(), y, x, A);
                  if (!Ra(y, x)) return !1;
                  for (const N of B) if (!Ke(N, I)) return !1;
                }
                if (p.type === "MultiPolygon") {
                  const I = tn(p.coordinates, x, A), B = xn(h.geometry(), y, x, A);
                  if (!Ra(y, x)) return !1;
                  for (const N of B) if (!mt(N, I)) return !1;
                }
                return !0;
              }(c, this.geometries);
              if (c.geometryType() === "LineString") return function(h, p) {
                const y = [1 / 0, 1 / 0, -1 / 0, -1 / 0], x = [1 / 0, 1 / 0, -1 / 0, -1 / 0], A = h.canonicalID();
                if (p.type === "Polygon") {
                  const I = kr(p.coordinates, x, A), B = ti(h.geometry(), y, x, A);
                  if (!Ra(y, x)) return !1;
                  for (const N of B) if (!zt(N, I)) return !1;
                }
                if (p.type === "MultiPolygon") {
                  const I = tn(p.coordinates, x, A), B = ti(h.geometry(), y, x, A);
                  if (!Ra(y, x)) return !1;
                  for (const N of B) if (!tr(N, I)) return !1;
                }
                return !0;
              }(c, this.geometries);
            }
            return !1;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        let Pi = class {
          constructor() {
            let f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (h, p) => h < p ? -1 : h > p ? 1 : 0;
            if (this.data = f, this.length = this.data.length, this.compare = c, this.length > 0) for (let h = (this.length >> 1) - 1; h >= 0; h--) this._down(h);
          }
          push(f) {
            this.data.push(f), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const f = this.data[0], c = this.data.pop();
            return --this.length > 0 && (this.data[0] = c, this._down(0)), f;
          }
          peek() {
            return this.data[0];
          }
          _up(f) {
            const { data: c, compare: h } = this, p = c[f];
            for (; f > 0; ) {
              const y = f - 1 >> 1, x = c[y];
              if (h(p, x) >= 0) break;
              c[f] = x, f = y;
            }
            c[f] = p;
          }
          _down(f) {
            const { data: c, compare: h } = this, p = this.length >> 1, y = c[f];
            for (; f < p; ) {
              let x = 1 + (f << 1);
              const A = x + 1;
              if (A < this.length && h(c[A], c[x]) < 0 && (x = A), h(c[x], y) >= 0) break;
              c[f] = c[x], f = x;
            }
            c[f] = y;
          }
        };
        function gs(f, c) {
          let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : f.length - 1, y = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : fo;
          for (; p > h; ) {
            if (p - h > 600) {
              const B = p - h + 1, N = c - h + 1, z = Math.log(B), j = 0.5 * Math.exp(2 * z / 3), K = 0.5 * Math.sqrt(z * j * (B - j) / B) * (N - B / 2 < 0 ? -1 : 1);
              gs(f, c, Math.max(h, Math.floor(c - N * j / B + K)), Math.min(p, Math.floor(c + (B - N) * j / B + K)), y);
            }
            const x = f[c];
            let A = h, I = p;
            for (Ti(f, h, c), y(f[p], x) > 0 && Ti(f, h, p); A < I; ) {
              for (Ti(f, A, I), A++, I--; y(f[A], x) < 0; ) A++;
              for (; y(f[I], x) > 0; ) I--;
            }
            y(f[h], x) === 0 ? Ti(f, h, I) : (I++, Ti(f, I, p)), I <= c && (h = I + 1), c <= I && (p = I - 1);
          }
        }
        function Ti(f, c, h) {
          const p = f[c];
          f[c] = f[h], f[h] = p;
        }
        function fo(f, c) {
          return f < c ? -1 : f > c ? 1 : 0;
        }
        function Us(f, c) {
          if (f.length <= 1) return [f];
          const h = [];
          let p, y;
          for (const x of f) {
            const A = Xu(x);
            A !== 0 && (x.area = Math.abs(A), y === void 0 && (y = A < 0), y === A < 0 ? (p && h.push(p), p = [x]) : p.push(x));
          }
          if (p && h.push(p), c > 1) for (let x = 0; x < h.length; x++) h[x].length <= c || (gs(h[x], c, 1, h[x].length - 1, fa), h[x] = h[x].slice(0, c));
          return h;
        }
        function fa(f, c) {
          return c.area - f.area;
        }
        function Xu(f) {
          let c = 0;
          for (let h, p, y = 0, x = f.length, A = x - 1; y < x; A = y++) h = f[y], p = f[A], c += (p.x - h.x) * (h.y + p.y);
          return c;
        }
        const Vl = 1 / 298.257223563, ql = Vl * (2 - Vl), Gl = Math.PI / 180;
        class $l {
          constructor(c) {
            const h = 6378.137 * Gl * 1e3, p = Math.cos(c * Gl), y = 1 / (1 - ql * (1 - p * p)), x = Math.sqrt(y);
            this.kx = h * x * p, this.ky = h * x * y * (1 - ql);
          }
          distance(c, h) {
            const p = this.wrap(c[0] - h[0]) * this.kx, y = (c[1] - h[1]) * this.ky;
            return Math.sqrt(p * p + y * y);
          }
          pointOnLine(c, h) {
            let p, y, x, A, I = 1 / 0;
            for (let B = 0; B < c.length - 1; B++) {
              let N = c[B][0], z = c[B][1], j = this.wrap(c[B + 1][0] - N) * this.kx, K = (c[B + 1][1] - z) * this.ky, ee = 0;
              j === 0 && K === 0 || (ee = (this.wrap(h[0] - N) * this.kx * j + (h[1] - z) * this.ky * K) / (j * j + K * K), ee > 1 ? (N = c[B + 1][0], z = c[B + 1][1]) : ee > 0 && (N += j / this.kx * ee, z += K / this.ky * ee)), j = this.wrap(h[0] - N) * this.kx, K = (h[1] - z) * this.ky;
              const te = j * j + K * K;
              te < I && (I = te, p = N, y = z, x = B, A = ee);
            }
            return { point: [p, y], index: x, t: Math.max(0, Math.min(1, A)) };
          }
          wrap(c) {
            for (; c < -180; ) c += 360;
            for (; c > 180; ) c -= 360;
            return c;
          }
        }
        function Hl(f, c) {
          return c[0] - f[0];
        }
        function da(f) {
          return f[1] - f[0] + 1;
        }
        function ri(f, c) {
          return f[1] >= f[0] && f[1] < c;
        }
        function ll(f, c) {
          if (f[0] > f[1]) return [null, null];
          const h = da(f);
          if (c) {
            if (h === 2) return [f, null];
            const y = Math.floor(h / 2);
            return [[f[0], f[0] + y], [f[0] + y, f[1]]];
          }
          if (h === 1) return [f, null];
          const p = Math.floor(h / 2) - 1;
          return [[f[0], f[0] + p], [f[0] + p + 1, f[1]]];
        }
        function cl(f, c) {
          if (!ri(c, f.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (let p = c[0]; p <= c[1]; ++p) So(h, f[p]);
          return h;
        }
        function Ba(f) {
          const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
          for (const h of f) for (const p of h) So(c, p);
          return c;
        }
        function zc(f) {
          return f[0] !== -1 / 0 && f[1] !== -1 / 0 && f[2] !== 1 / 0 && f[3] !== 1 / 0;
        }
        function Cs(f, c, h) {
          if (!zc(f) || !zc(c)) return NaN;
          let p = 0, y = 0;
          return f[2] < c[0] && (p = c[0] - f[2]), f[0] > c[2] && (p = f[0] - c[2]), f[1] > c[3] && (y = f[1] - c[3]), f[3] < c[1] && (y = c[1] - f[3]), h.distance([0, 0], [p, y]);
        }
        function La(f, c, h) {
          const p = h.pointOnLine(c, f);
          return h.distance(f, p.point);
        }
        function Wl(f, c, h, p, y) {
          const x = Math.min(La(f, [h, p], y), La(c, [h, p], y)), A = Math.min(La(h, [f, c], y), La(p, [f, c], y));
          return Math.min(x, A);
        }
        function An(f, c, h, p, y) {
          if (!ri(c, f.length) || !ri(p, h.length)) return 1 / 0;
          let x = 1 / 0;
          for (let A = c[0]; A < c[1]; ++A) {
            const I = f[A], B = f[A + 1];
            for (let N = p[0]; N < p[1]; ++N) {
              const z = h[N], j = h[N + 1];
              if (ne(I, B, z, j)) return 0;
              x = Math.min(x, Wl(I, B, z, j, y));
            }
          }
          return x;
        }
        function Eo(f, c, h, p, y) {
          if (!ri(c, f.length) || !ri(p, h.length)) return NaN;
          let x = 1 / 0;
          for (let A = c[0]; A <= c[1]; ++A) for (let I = p[0]; I <= p[1]; ++I) if (x = Math.min(x, y.distance(f[A], h[I])), x === 0) return x;
          return x;
        }
        function jc(f, c, h) {
          if (Ke(f, c, !0)) return 0;
          let p = 1 / 0;
          for (const y of c) {
            const x = y[0], A = y[y.length - 1];
            if (x !== A && (p = Math.min(p, La(f, [A, x], h)), p === 0)) return p;
            const I = h.pointOnLine(y, f);
            if (p = Math.min(p, h.distance(f, I.point)), p === 0) return p;
          }
          return p;
        }
        function Zu(f, c, h, p) {
          if (!ri(c, f.length)) return NaN;
          for (let x = c[0]; x <= c[1]; ++x) if (Ke(f[x], h, !0)) return 0;
          let y = 1 / 0;
          for (let x = c[0]; x < c[1]; ++x) {
            const A = f[x], I = f[x + 1];
            for (const B of h) for (let N = 0, z = B.length, j = z - 1; N < z; j = N++) {
              const K = B[j], ee = B[N];
              if (ne(A, I, K, ee)) return 0;
              y = Math.min(y, Wl(A, I, K, ee, p));
            }
          }
          return y;
        }
        function bu(f, c) {
          for (const h of f) for (const p of h) if (Ke(p, c, !0)) return !0;
          return !1;
        }
        function ul(f, c, h) {
          let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1 / 0;
          const y = Ba(f), x = Ba(c);
          if (p !== 1 / 0 && Cs(y, x, h) >= p) return p;
          if (Ra(y, x)) {
            if (bu(f, c)) return 0;
          } else if (bu(c, f)) return 0;
          let A = 1 / 0;
          for (const I of f) for (let B = 0, N = I.length, z = N - 1; B < N; z = B++) {
            const j = I[z], K = I[B];
            for (const ee of c) for (let te = 0, le = ee.length, Ae = le - 1; te < le; Ae = te++) {
              const Te = ee[Ae], Qe = ee[te];
              if (ne(j, K, Te, Qe)) return 0;
              A = Math.min(A, Wl(j, K, Te, Qe, h));
            }
          }
          return A;
        }
        function hl(f, c, h, p, y, x) {
          if (!x) return;
          const A = Cs(cl(p, x), y, h);
          A < c && f.push([A, x, [0, 0]]);
        }
        function ms(f, c, h, p, y, x, A) {
          if (!x || !A) return;
          const I = Cs(cl(p, x), cl(y, A), h);
          I < c && f.push([I, x, A]);
        }
        function Ji(f, c, h, p) {
          let y = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1 / 0, x = Math.min(p.distance(f[0], h[0][0]), y);
          if (x === 0) return x;
          const A = new Pi([[0, [0, f.length - 1], [0, 0]]], Hl), I = Ba(h);
          for (; A.length > 0; ) {
            const B = A.pop();
            if (B[0] >= x) continue;
            const N = B[1], z = c ? 50 : 100;
            if (da(N) <= z) {
              if (!ri(N, f.length)) return NaN;
              if (c) {
                const j = Zu(f, N, h, p);
                if (isNaN(j) || j === 0) return j;
                x = Math.min(x, j);
              } else for (let j = N[0]; j <= N[1]; ++j) {
                const K = jc(f[j], h, p);
                if (x = Math.min(x, K), x === 0) return 0;
              }
            } else {
              const j = ll(N, c);
              hl(A, x, p, f, I, j[0]), hl(A, x, p, f, I, j[1]);
            }
          }
          return x;
        }
        function Ko(f, c, h, p, y) {
          let x = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1 / 0, A = Math.min(x, y.distance(f[0], h[0]));
          if (A === 0) return A;
          const I = new Pi([[0, [0, f.length - 1], [0, h.length - 1]]], Hl);
          for (; I.length > 0; ) {
            const B = I.pop();
            if (B[0] >= A) continue;
            const N = B[1], z = B[2], j = c ? 50 : 100, K = p ? 50 : 100;
            if (da(N) <= j && da(z) <= K) {
              if (!ri(N, f.length) && ri(z, h.length)) return NaN;
              let ee;
              if (c && p) ee = An(f, N, h, z, y), A = Math.min(A, ee);
              else if (c && !p) {
                const te = f.slice(N[0], N[1] + 1);
                for (let le = z[0]; le <= z[1]; ++le) if (ee = La(h[le], te, y), A = Math.min(A, ee), A === 0) return A;
              } else if (!c && p) {
                const te = h.slice(z[0], z[1] + 1);
                for (let le = N[0]; le <= N[1]; ++le) if (ee = La(f[le], te, y), A = Math.min(A, ee), A === 0) return A;
              } else ee = Eo(f, N, h, z, y), A = Math.min(A, ee);
            } else {
              const ee = ll(N, c), te = ll(z, p);
              ms(I, A, y, f, h, ee[0], te[0]), ms(I, A, y, f, h, ee[0], te[1]), ms(I, A, y, f, h, ee[1], te[0]), ms(I, A, y, f, h, ee[1], te[1]);
            }
          }
          return A;
        }
        function Jo(f) {
          return f.type === "MultiPolygon" ? f.coordinates.map((c) => ({ type: "Polygon", coordinates: c })) : f.type === "MultiLineString" ? f.coordinates.map((c) => ({ type: "LineString", coordinates: c })) : f.type === "MultiPoint" ? f.coordinates.map((c) => ({ type: "Point", coordinates: c })) : [f];
        }
        class zs {
          constructor(c, h) {
            this.type = Bt, this.geojson = c, this.geometries = h;
          }
          static parse(c, h) {
            if (c.length !== 2) return h.error(`'distance' expression requires exactly one argument, but found ${c.length - 1} instead.`);
            if (ua(c[1])) {
              const p = c[1];
              if (p.type === "FeatureCollection") return new zs(p, p.features.map((y) => Jo(y.geometry)).flat());
              if (p.type === "Feature") return new zs(p, Jo(p.geometry));
              if ("type" in p && "coordinates" in p) return new zs(p, Jo(p));
            }
            return h.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
          }
          evaluate(c) {
            if (c.geometry() != null && c.canonicalID() != null) {
              if (c.geometryType() === "Point") return function(h, p) {
                const y = h.geometry(), x = y.flat().map((B) => jl([B.x, B.y], h.canonical));
                if (y.length === 0) return NaN;
                const A = new $l(x[0][1]);
                let I = 1 / 0;
                for (const B of p) {
                  switch (B.type) {
                    case "Point":
                      I = Math.min(I, Ko(x, !1, [B.coordinates], !1, A, I));
                      break;
                    case "LineString":
                      I = Math.min(I, Ko(x, !1, B.coordinates, !0, A, I));
                      break;
                    case "Polygon":
                      I = Math.min(I, Ji(x, !1, B.coordinates, A, I));
                  }
                  if (I === 0) return I;
                }
                return I;
              }(c, this.geometries);
              if (c.geometryType() === "LineString") return function(h, p) {
                const y = h.geometry(), x = y.flat().map((B) => jl([B.x, B.y], h.canonical));
                if (y.length === 0) return NaN;
                const A = new $l(x[0][1]);
                let I = 1 / 0;
                for (const B of p) {
                  switch (B.type) {
                    case "Point":
                      I = Math.min(I, Ko(x, !0, [B.coordinates], !1, A, I));
                      break;
                    case "LineString":
                      I = Math.min(I, Ko(x, !0, B.coordinates, !0, A, I));
                      break;
                    case "Polygon":
                      I = Math.min(I, Ji(x, !0, B.coordinates, A, I));
                  }
                  if (I === 0) return I;
                }
                return I;
              }(c, this.geometries);
              if (c.geometryType() === "Polygon") return function(h, p) {
                const y = h.geometry();
                if (y.length === 0 || y[0].length === 0) return NaN;
                const x = Us(y, 0).map((B) => B.map((N) => N.map((z) => jl([z.x, z.y], h.canonical)))), A = new $l(x[0][0][0][1]);
                let I = 1 / 0;
                for (const B of p) for (const N of x) {
                  switch (B.type) {
                    case "Point":
                      I = Math.min(I, Ji([B.coordinates], !1, N, A, I));
                      break;
                    case "LineString":
                      I = Math.min(I, Ji(B.coordinates, !0, N, A, I));
                      break;
                    case "Polygon":
                      I = Math.min(I, ul(N, B.coordinates, A, I));
                  }
                  if (I === 0) return I;
                }
                return I;
              }(c, this.geometries);
            }
            return NaN;
          }
          eachChild() {
          }
          outputDefined() {
            return !0;
          }
        }
        const Qo = { "==": Wu, "!=": Fc, ">": Fl, "<": Uc, ">=": Ul, "<=": _u, array: Ys, at: Ol, boolean: Ys, case: Ao, coalesce: Js, collator: To, format: Ma, image: Pa, in: dn, "index-of": ha, interpolate: gn, "interpolate-hcl": gn, "interpolate-lab": gn, length: yu, let: ln, literal: uo, match: fs, number: Ys, "number-format": ds, object: Ys, slice: Nl, step: Yo, string: Ys, "to-boolean": Ki, "to-color": Ki, "to-number": Ki, "to-string": Ki, var: Xr, within: Gn, distance: zs };
        class Fi {
          constructor(c, h, p, y) {
            this.name = c, this.type = h, this._evaluate = p, this.args = y;
          }
          evaluate(c) {
            return this._evaluate(c, this.args);
          }
          eachChild(c) {
            this.args.forEach(c);
          }
          outputDefined() {
            return !1;
          }
          static parse(c, h) {
            const p = c[0], y = Fi.definitions[p];
            if (!y) return h.error(`Unknown expression "${p}". If you wanted a literal array, use ["literal", [...]].`, 0);
            const x = Array.isArray(y) ? y[0] : y.type, A = Array.isArray(y) ? [[y[1], y[2]]] : y.overloads, I = A.filter((N) => {
              let [z] = N;
              return !Array.isArray(z) || z.length === c.length - 1;
            });
            let B = null;
            for (const [N, z] of I) {
              B = new Xo(h.registry, Oa, h.path, null, h.scope);
              const j = [];
              let K = !1;
              for (let ee = 1; ee < c.length; ee++) {
                const te = c[ee], le = Array.isArray(N) ? N[ee - 1] : N.type, Ae = B.parse(te, 1 + j.length, le);
                if (!Ae) {
                  K = !0;
                  break;
                }
                j.push(Ae);
              }
              if (!K) if (Array.isArray(N) && N.length !== j.length) B.error(`Expected ${N.length} arguments, but found ${j.length} instead.`);
              else {
                for (let ee = 0; ee < j.length; ee++) {
                  const te = Array.isArray(N) ? N[ee] : N.type, le = j[ee];
                  B.concat(ee + 1).checkSubtype(te, le.type);
                }
                if (B.errors.length === 0) return new Fi(p, x, z, j);
              }
            }
            if (I.length === 1) h.errors.push(...B.errors);
            else {
              const N = (I.length ? I : A).map((j) => {
                let [K] = j;
                return ee = K, Array.isArray(ee) ? `(${ee.map(In).join(", ")})` : `(${In(ee.type)}...)`;
                var ee;
              }).join(" | "), z = [];
              for (let j = 1; j < c.length; j++) {
                const K = h.parse(c[j], 1 + z.length);
                if (!K) return null;
                z.push(In(K.type));
              }
              h.error(`Expected arguments of type ${N}, but found (${z.join(", ")}) instead.`);
            }
            return null;
          }
          static register(c, h) {
            Fi.definitions = h;
            for (const p in h) c[p] = Fi;
          }
        }
        function Si(f, c) {
          let [h, p, y, x] = c;
          h = h.evaluate(f), p = p.evaluate(f), y = y.evaluate(f);
          const A = x ? x.evaluate(f) : 1, I = ol(h, p, y, A);
          if (I) throw new Kn(I);
          return new nn(h / 255, p / 255, y / 255, A, !1);
        }
        function Vc(f, c) {
          return f in c;
        }
        function _s(f, c) {
          const h = c[f];
          return h === void 0 ? null : h;
        }
        function Qi(f) {
          return { type: f };
        }
        function Oa(f) {
          if (f instanceof Xr) return Oa(f.boundExpression);
          if (f instanceof Fi && f.name === "error" || f instanceof To || f instanceof Gn || f instanceof zs) return !1;
          const c = f instanceof Ki || f instanceof Ys;
          let h = !0;
          return f.eachChild((p) => {
            h = c ? h && Oa(p) : h && p instanceof uo;
          }), !!h && Xl(f) && pa(f, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
        }
        function Xl(f) {
          if (f instanceof Fi && (f.name === "get" && f.args.length === 1 || f.name === "feature-state" || f.name === "has" && f.args.length === 1 || f.name === "properties" || f.name === "geometry-type" || f.name === "id" || /^filter-/.test(f.name)) || f instanceof Gn || f instanceof zs) return !1;
          let c = !0;
          return f.eachChild((h) => {
            c && !Xl(h) && (c = !1);
          }), c;
        }
        function Na(f) {
          if (f instanceof Fi && f.name === "feature-state") return !1;
          let c = !0;
          return f.eachChild((h) => {
            c && !Na(h) && (c = !1);
          }), c;
        }
        function pa(f, c) {
          if (f instanceof Fi && c.indexOf(f.name) >= 0) return !1;
          let h = !0;
          return f.eachChild((p) => {
            h && !pa(p, c) && (h = !1);
          }), h;
        }
        function fl(f) {
          return { result: "success", value: f };
        }
        function po(f) {
          return { result: "error", value: f };
        }
        function Co(f) {
          return f["property-type"] === "data-driven" || f["property-type"] === "cross-faded-data-driven";
        }
        function Zl(f) {
          return !!f.expression && f.expression.parameters.indexOf("zoom") > -1;
        }
        function Da(f) {
          return !!f.expression && f.expression.interpolated;
        }
        function sn(f) {
          return f instanceof Number ? "number" : f instanceof String ? "string" : f instanceof Boolean ? "boolean" : Array.isArray(f) ? "array" : f === null ? "null" : typeof f;
        }
        function dl(f) {
          return typeof f == "object" && f !== null && !Array.isArray(f);
        }
        function Io(f) {
          return f;
        }
        function go(f, c) {
          const h = c.type === "color", p = f.stops && typeof f.stops[0][0] == "object", y = p || !(p || f.property !== void 0), x = f.type || (Da(c) ? "exponential" : "interval");
          if (h || c.type === "padding") {
            const z = h ? nn.parse : mi.parse;
            (f = or({}, f)).stops && (f.stops = f.stops.map((j) => [j[0], z(j[1])])), f.default = z(f.default ? f.default : c.default);
          }
          if (f.colorSpace && (A = f.colorSpace) !== "rgb" && A !== "hcl" && A !== "lab") throw new Error(`Unknown color space: "${f.colorSpace}"`);
          var A;
          let I, B, N;
          if (x === "exponential") I = Ui;
          else if (x === "interval") I = Ri;
          else if (x === "categorical") {
            I = $n, B = /* @__PURE__ */ Object.create(null);
            for (const z of f.stops) B[z[0]] = z[1];
            N = typeof f.stops[0][0];
          } else {
            if (x !== "identity") throw new Error(`Unknown function type "${x}"`);
            I = ka;
          }
          if (p) {
            const z = {}, j = [];
            for (let te = 0; te < f.stops.length; te++) {
              const le = f.stops[te], Ae = le[0].zoom;
              z[Ae] === void 0 && (z[Ae] = { zoom: Ae, type: f.type, property: f.property, default: f.default, stops: [] }, j.push(Ae)), z[Ae].stops.push([le[0].value, le[1]]);
            }
            const K = [];
            for (const te of j) K.push([z[te].zoom, go(z[te], c)]);
            const ee = { name: "linear" };
            return { kind: "composite", interpolationType: ee, interpolationFactor: gn.interpolationFactor.bind(void 0, ee), zoomStops: K.map((te) => te[0]), evaluate: (te, le) => {
              let { zoom: Ae } = te;
              return Ui({ stops: K, base: f.base }, c, Ae).evaluate(Ae, le);
            } };
          }
          if (y) {
            const z = x === "exponential" ? { name: "exponential", base: f.base !== void 0 ? f.base : 1 } : null;
            return { kind: "camera", interpolationType: z, interpolationFactor: gn.interpolationFactor.bind(void 0, z), zoomStops: f.stops.map((j) => j[0]), evaluate: (j) => {
              let { zoom: K } = j;
              return I(f, c, K, B, N);
            } };
          }
          return { kind: "source", evaluate(z, j) {
            const K = j && j.properties ? j.properties[f.property] : void 0;
            return K === void 0 ? Bn(f.default, c.default) : I(f, c, K, B, N);
          } };
        }
        function Bn(f, c, h) {
          return f !== void 0 ? f : c !== void 0 ? c : h !== void 0 ? h : void 0;
        }
        function $n(f, c, h, p, y) {
          return Bn(typeof h === y ? p[h] : void 0, f.default, c.default);
        }
        function Ri(f, c, h) {
          if (sn(h) !== "number") return Bn(f.default, c.default);
          const p = f.stops.length;
          if (p === 1 || h <= f.stops[0][0]) return f.stops[0][1];
          if (h >= f.stops[p - 1][0]) return f.stops[p - 1][1];
          const y = Zo(f.stops.map((x) => x[0]), h);
          return f.stops[y][1];
        }
        function Ui(f, c, h) {
          const p = f.base !== void 0 ? f.base : 1;
          if (sn(h) !== "number") return Bn(f.default, c.default);
          const y = f.stops.length;
          if (y === 1 || h <= f.stops[0][0]) return f.stops[0][1];
          if (h >= f.stops[y - 1][0]) return f.stops[y - 1][1];
          const x = Zo(f.stops.map((z) => z[0]), h), A = function(z, j, K, ee) {
            const te = ee - K, le = z - K;
            return te === 0 ? 0 : j === 1 ? le / te : (Math.pow(j, le) - 1) / (Math.pow(j, te) - 1);
          }(h, p, f.stops[x][0], f.stops[x + 1][0]), I = f.stops[x][1], B = f.stops[x + 1][1], N = ho[c.type] || Io;
          return typeof I.evaluate == "function" ? { evaluate() {
            for (var z = arguments.length, j = new Array(z), K = 0; K < z; K++)
              j[K] = arguments[K];
            const ee = I.evaluate.apply(void 0, j), te = B.evaluate.apply(void 0, j);
            if (ee !== void 0 && te !== void 0) return N(ee, te, A, f.colorSpace);
          } } : N(I, B, A, f.colorSpace);
        }
        function ka(f, c, h) {
          switch (c.type) {
            case "color":
              h = nn.parse(h);
              break;
            case "formatted":
              h = oi.fromString(h.toString());
              break;
            case "resolvedImage":
              h = ai.fromString(h.toString());
              break;
            case "padding":
              h = mi.parse(h);
              break;
            default:
              sn(h) === c.type || c.type === "enum" && c.values[h] || (h = void 0);
          }
          return Bn(h, f.default, c.default);
        }
        Fi.register(Qo, { error: [{ kind: "error" }, [Qt], (f, c) => {
          let [h] = c;
          throw new Kn(h.evaluate(f));
        }], typeof: [Qt, [gr], (f, c) => {
          let [h] = c;
          return In(an(h.evaluate(f)));
        }], "to-rgba": [Ai(Bt, 4), [Lr], (f, c) => {
          let [h] = c;
          const [p, y, x, A] = h.evaluate(f).rgb;
          return [255 * p, 255 * y, 255 * x, A];
        }], rgb: [Lr, [Bt, Bt, Bt], Si], rgba: [Lr, [Bt, Bt, Bt, Bt], Si], has: { type: fr, overloads: [[[Qt], (f, c) => {
          let [h] = c;
          return Vc(h.evaluate(f), f.properties());
        }], [[Qt, Or], (f, c) => {
          let [h, p] = c;
          return Vc(h.evaluate(f), p.evaluate(f));
        }]] }, get: { type: gr, overloads: [[[Qt], (f, c) => {
          let [h] = c;
          return _s(h.evaluate(f), f.properties());
        }], [[Qt, Or], (f, c) => {
          let [h, p] = c;
          return _s(h.evaluate(f), p.evaluate(f));
        }]] }, "feature-state": [gr, [Qt], (f, c) => {
          let [h] = c;
          return _s(h.evaluate(f), f.featureState || {});
        }], properties: [Or, [], (f) => f.properties()], "geometry-type": [Qt, [], (f) => f.geometryType()], id: [gr, [], (f) => f.id()], zoom: [Bt, [], (f) => f.globals.zoom], "heatmap-density": [Bt, [], (f) => f.globals.heatmapDensity || 0], "line-progress": [Bt, [], (f) => f.globals.lineProgress || 0], accumulated: [gr, [], (f) => f.globals.accumulated === void 0 ? null : f.globals.accumulated], "+": [Bt, Qi(Bt), (f, c) => {
          let h = 0;
          for (const p of c) h += p.evaluate(f);
          return h;
        }], "*": [Bt, Qi(Bt), (f, c) => {
          let h = 1;
          for (const p of c) h *= p.evaluate(f);
          return h;
        }], "-": { type: Bt, overloads: [[[Bt, Bt], (f, c) => {
          let [h, p] = c;
          return h.evaluate(f) - p.evaluate(f);
        }], [[Bt], (f, c) => {
          let [h] = c;
          return -h.evaluate(f);
        }]] }, "/": [Bt, [Bt, Bt], (f, c) => {
          let [h, p] = c;
          return h.evaluate(f) / p.evaluate(f);
        }], "%": [Bt, [Bt, Bt], (f, c) => {
          let [h, p] = c;
          return h.evaluate(f) % p.evaluate(f);
        }], ln2: [Bt, [], () => Math.LN2], pi: [Bt, [], () => Math.PI], e: [Bt, [], () => Math.E], "^": [Bt, [Bt, Bt], (f, c) => {
          let [h, p] = c;
          return Math.pow(h.evaluate(f), p.evaluate(f));
        }], sqrt: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.sqrt(h.evaluate(f));
        }], log10: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.log(h.evaluate(f)) / Math.LN10;
        }], ln: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.log(h.evaluate(f));
        }], log2: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.log(h.evaluate(f)) / Math.LN2;
        }], sin: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.sin(h.evaluate(f));
        }], cos: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.cos(h.evaluate(f));
        }], tan: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.tan(h.evaluate(f));
        }], asin: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.asin(h.evaluate(f));
        }], acos: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.acos(h.evaluate(f));
        }], atan: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.atan(h.evaluate(f));
        }], min: [Bt, Qi(Bt), (f, c) => Math.min(...c.map((h) => h.evaluate(f)))], max: [Bt, Qi(Bt), (f, c) => Math.max(...c.map((h) => h.evaluate(f)))], abs: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.abs(h.evaluate(f));
        }], round: [Bt, [Bt], (f, c) => {
          let [h] = c;
          const p = h.evaluate(f);
          return p < 0 ? -Math.round(-p) : Math.round(p);
        }], floor: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.floor(h.evaluate(f));
        }], ceil: [Bt, [Bt], (f, c) => {
          let [h] = c;
          return Math.ceil(h.evaluate(f));
        }], "filter-==": [fr, [Qt, gr], (f, c) => {
          let [h, p] = c;
          return f.properties()[h.value] === p.value;
        }], "filter-id-==": [fr, [gr], (f, c) => {
          let [h] = c;
          return f.id() === h.value;
        }], "filter-type-==": [fr, [Qt], (f, c) => {
          let [h] = c;
          return f.geometryType() === h.value;
        }], "filter-<": [fr, [Qt, gr], (f, c) => {
          let [h, p] = c;
          const y = f.properties()[h.value], x = p.value;
          return typeof y == typeof x && y < x;
        }], "filter-id-<": [fr, [gr], (f, c) => {
          let [h] = c;
          const p = f.id(), y = h.value;
          return typeof p == typeof y && p < y;
        }], "filter->": [fr, [Qt, gr], (f, c) => {
          let [h, p] = c;
          const y = f.properties()[h.value], x = p.value;
          return typeof y == typeof x && y > x;
        }], "filter-id->": [fr, [gr], (f, c) => {
          let [h] = c;
          const p = f.id(), y = h.value;
          return typeof p == typeof y && p > y;
        }], "filter-<=": [fr, [Qt, gr], (f, c) => {
          let [h, p] = c;
          const y = f.properties()[h.value], x = p.value;
          return typeof y == typeof x && y <= x;
        }], "filter-id-<=": [fr, [gr], (f, c) => {
          let [h] = c;
          const p = f.id(), y = h.value;
          return typeof p == typeof y && p <= y;
        }], "filter->=": [fr, [Qt, gr], (f, c) => {
          let [h, p] = c;
          const y = f.properties()[h.value], x = p.value;
          return typeof y == typeof x && y >= x;
        }], "filter-id->=": [fr, [gr], (f, c) => {
          let [h] = c;
          const p = f.id(), y = h.value;
          return typeof p == typeof y && p >= y;
        }], "filter-has": [fr, [gr], (f, c) => {
          let [h] = c;
          return h.value in f.properties();
        }], "filter-has-id": [fr, [], (f) => f.id() !== null && f.id() !== void 0], "filter-type-in": [fr, [Ai(Qt)], (f, c) => {
          let [h] = c;
          return h.value.indexOf(f.geometryType()) >= 0;
        }], "filter-id-in": [fr, [Ai(gr)], (f, c) => {
          let [h] = c;
          return h.value.indexOf(f.id()) >= 0;
        }], "filter-in-small": [fr, [Qt, Ai(gr)], (f, c) => {
          let [h, p] = c;
          return p.value.indexOf(f.properties()[h.value]) >= 0;
        }], "filter-in-large": [fr, [Qt, Ai(gr)], (f, c) => {
          let [h, p] = c;
          return function(y, x, A, I) {
            for (; A <= I; ) {
              const B = A + I >> 1;
              if (x[B] === y) return !0;
              x[B] > y ? I = B - 1 : A = B + 1;
            }
            return !1;
          }(f.properties()[h.value], p.value, 0, p.value.length - 1);
        }], all: { type: fr, overloads: [[[fr, fr], (f, c) => {
          let [h, p] = c;
          return h.evaluate(f) && p.evaluate(f);
        }], [Qi(fr), (f, c) => {
          for (const h of c) if (!h.evaluate(f)) return !1;
          return !0;
        }]] }, any: { type: fr, overloads: [[[fr, fr], (f, c) => {
          let [h, p] = c;
          return h.evaluate(f) || p.evaluate(f);
        }], [Qi(fr), (f, c) => {
          for (const h of c) if (h.evaluate(f)) return !0;
          return !1;
        }]] }, "!": [fr, [fr], (f, c) => {
          let [h] = c;
          return !h.evaluate(f);
        }], "is-supported-script": [fr, [Qt], (f, c) => {
          let [h] = c;
          const p = f.globals && f.globals.isSupportedScript;
          return !p || p(h.evaluate(f));
        }], upcase: [Qt, [Qt], (f, c) => {
          let [h] = c;
          return h.evaluate(f).toUpperCase();
        }], downcase: [Qt, [Qt], (f, c) => {
          let [h] = c;
          return h.evaluate(f).toLowerCase();
        }], concat: [Qt, Qi(gr), (f, c) => c.map((h) => Bl(h.evaluate(f))).join("")], "resolved-locale": [Qt, [Sn], (f, c) => {
          let [h] = c;
          return h.evaluate(f).resolvedLocale();
        }] });
        class pl {
          constructor(c, h) {
            var p;
            this.expression = c, this._warningHistory = {}, this._evaluator = new Fn(), this._defaultValue = h ? (p = h).type === "color" && dl(p.default) ? new nn(0, 0, 0, 0) : p.type === "color" ? nn.parse(p.default) || null : p.type === "padding" ? mi.parse(p.default) || null : p.type === "variableAnchorOffsetCollection" ? Yi.parse(p.default) || null : p.type === "projectionDefinition" ? Mi.parse(p.default) || null : p.default === void 0 ? null : p.default : null, this._enumValues = h && h.type === "enum" ? h.values : null;
          }
          evaluateWithoutErrorHandling(c, h, p, y, x, A) {
            return this._evaluator.globals = c, this._evaluator.feature = h, this._evaluator.featureState = p, this._evaluator.canonical = y, this._evaluator.availableImages = x || null, this._evaluator.formattedSection = A, this.expression.evaluate(this._evaluator);
          }
          evaluate(c, h, p, y, x, A) {
            this._evaluator.globals = c, this._evaluator.feature = h || null, this._evaluator.featureState = p || null, this._evaluator.canonical = y, this._evaluator.availableImages = x || null, this._evaluator.formattedSection = A || null;
            try {
              const I = this.expression.evaluate(this._evaluator);
              if (I == null || typeof I == "number" && I != I) return this._defaultValue;
              if (this._enumValues && !(I in this._enumValues)) throw new Kn(`Expected value to be one of ${Object.keys(this._enumValues).map((B) => JSON.stringify(B)).join(", ")}, but found ${JSON.stringify(I)} instead.`);
              return I;
            } catch (I) {
              return this._warningHistory[I.message] || (this._warningHistory[I.message] = !0, typeof console < "u" && console.warn(I.message)), this._defaultValue;
            }
          }
        }
        function Fa(f) {
          return Array.isArray(f) && f.length > 0 && typeof f[0] == "string" && f[0] in Qo;
        }
        function Yl(f, c) {
          const h = new Xo(Qo, Oa, [], c ? function(y) {
            const x = { color: Lr, string: Qt, number: Bt, enum: Qt, boolean: fr, formatted: Zi, padding: Dn, projectionDefinition: Hr, resolvedImage: kn, variableAnchorOffsetCollection: vn };
            return y.type === "array" ? Ai(x[y.value] || gr, y.length) : x[y.type];
          }(c) : void 0), p = h.parse(f, void 0, void 0, void 0, c && c.type === "string" ? { typeAnnotation: "coerce" } : void 0);
          return p ? fl(new pl(p, c)) : po(h.errors);
        }
        class gl {
          constructor(c, h) {
            this.kind = c, this._styleExpression = h, this.isStateDependent = c !== "constant" && !Na(h.expression);
          }
          evaluateWithoutErrorHandling(c, h, p, y, x, A) {
            return this._styleExpression.evaluateWithoutErrorHandling(c, h, p, y, x, A);
          }
          evaluate(c, h, p, y, x, A) {
            return this._styleExpression.evaluate(c, h, p, y, x, A);
          }
        }
        class Kl {
          constructor(c, h, p, y) {
            this.kind = c, this.zoomStops = p, this._styleExpression = h, this.isStateDependent = c !== "camera" && !Na(h.expression), this.interpolationType = y;
          }
          evaluateWithoutErrorHandling(c, h, p, y, x, A) {
            return this._styleExpression.evaluateWithoutErrorHandling(c, h, p, y, x, A);
          }
          evaluate(c, h, p, y, x, A) {
            return this._styleExpression.evaluate(c, h, p, y, x, A);
          }
          interpolationFactor(c, h, p) {
            return this.interpolationType ? gn.interpolationFactor(this.interpolationType, c, h, p) : 0;
          }
        }
        function eo(f, c) {
          const h = Yl(f, c);
          if (h.result === "error") return h;
          const p = h.value.expression, y = Xl(p);
          if (!y && !Co(c)) return po([new Jt("", "data expressions not supported")]);
          const x = pa(p, ["zoom"]);
          if (!x && !Zl(c)) return po([new Jt("", "zoom expressions not supported")]);
          const A = Jl(p);
          return A || x ? A instanceof Jt ? po([A]) : A instanceof gn && !Da(c) ? po([new Jt("", '"interpolate" expressions cannot be used with this property')]) : fl(A ? new Kl(y ? "camera" : "composite", h.value, A.labels, A instanceof gn ? A.interpolation : void 0) : new gl(y ? "constant" : "source", h.value)) : po([new Jt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
        }
        class js {
          constructor(c, h) {
            this._parameters = c, this._specification = h, or(this, go(this._parameters, this._specification));
          }
          static deserialize(c) {
            return new js(c._parameters, c._specification);
          }
          static serialize(c) {
            return { _parameters: c._parameters, _specification: c._specification };
          }
        }
        function Jl(f) {
          let c = null;
          if (f instanceof ln) c = Jl(f.result);
          else if (f instanceof Js) {
            for (const h of f.args) if (c = Jl(h), c) break;
          } else (f instanceof Yo || f instanceof gn) && f.input instanceof Fi && f.input.name === "zoom" && (c = f);
          return c instanceof Jt || f.eachChild((h) => {
            const p = Jl(h);
            p instanceof Jt ? c = p : !c && p ? c = new Jt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : c && p && c !== p && (c = new Jt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
          }), c;
        }
        function qc(f) {
          if (f === !0 || f === !1) return !0;
          if (!Array.isArray(f) || f.length === 0) return !1;
          switch (f[0]) {
            case "has":
              return f.length >= 2 && f[1] !== "$id" && f[1] !== "$type";
            case "in":
              return f.length >= 3 && (typeof f[1] != "string" || Array.isArray(f[2]));
            case "!in":
            case "!has":
            case "none":
              return !1;
            case "==":
            case "!=":
            case ">":
            case ">=":
            case "<":
            case "<=":
              return f.length !== 3 || Array.isArray(f[1]) || Array.isArray(f[2]);
            case "any":
            case "all":
              for (const c of f.slice(1)) if (!qc(c) && typeof c != "boolean") return !1;
              return !0;
            default:
              return !0;
          }
        }
        const Nf = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
        function Ql(f) {
          if (f == null) return { filter: () => !0, needGeometry: !1 };
          qc(f) || (f = xu(f));
          const c = Yl(f, Nf);
          if (c.result === "error") throw new Error(c.value.map((h) => `${h.key}: ${h.message}`).join(", "));
          return { filter: (h, p, y) => c.value.evaluate(h, p, {}, y), needGeometry: Yu(f) };
        }
        function vu(f, c) {
          return f < c ? -1 : f > c ? 1 : 0;
        }
        function Yu(f) {
          if (!Array.isArray(f)) return !1;
          if (f[0] === "within" || f[0] === "distance") return !0;
          for (let c = 1; c < f.length; c++) if (Yu(f[c])) return !0;
          return !1;
        }
        function xu(f) {
          if (!f) return !0;
          const c = f[0];
          return f.length <= 1 ? c !== "any" : c === "==" ? Gc(f[1], f[2], "==") : c === "!=" ? ec(Gc(f[1], f[2], "==")) : c === "<" || c === ">" || c === "<=" || c === ">=" ? Gc(f[1], f[2], c) : c === "any" ? (h = f.slice(1), ["any"].concat(h.map(xu))) : c === "all" ? ["all"].concat(f.slice(1).map(xu)) : c === "none" ? ["all"].concat(f.slice(1).map(xu).map(ec)) : c === "in" ? wu(f[1], f.slice(2)) : c === "!in" ? ec(wu(f[1], f.slice(2))) : c === "has" ? $c(f[1]) : c !== "!has" || ec($c(f[1]));
          var h;
        }
        function Gc(f, c, h) {
          switch (f) {
            case "$type":
              return [`filter-type-${h}`, c];
            case "$id":
              return [`filter-id-${h}`, c];
            default:
              return [`filter-${h}`, f, c];
          }
        }
        function wu(f, c) {
          if (c.length === 0) return !1;
          switch (f) {
            case "$type":
              return ["filter-type-in", ["literal", c]];
            case "$id":
              return ["filter-id-in", ["literal", c]];
            default:
              return c.length > 200 && !c.some((h) => typeof h != typeof c[0]) ? ["filter-in-large", f, ["literal", c.sort(vu)]] : ["filter-in-small", f, ["literal", c]];
          }
        }
        function $c(f) {
          switch (f) {
            case "$type":
              return !0;
            case "$id":
              return ["filter-has-id"];
            default:
              return ["filter-has", f];
          }
        }
        function ec(f) {
          return ["!", f];
        }
        function Au(f) {
          const c = typeof f;
          if (c === "number" || c === "boolean" || c === "string" || f == null) return JSON.stringify(f);
          if (Array.isArray(f)) {
            let y = "[";
            for (const x of f) y += `${Au(x)},`;
            return `${y}]`;
          }
          const h = Object.keys(f).sort();
          let p = "{";
          for (let y = 0; y < h.length; y++) p += `${JSON.stringify(h[y])}:${Au(f[h[y]])},`;
          return `${p}}`;
        }
        function Fh(f) {
          let c = "";
          for (const h of se) c += `/${Au(f[h])}`;
          return c;
        }
        function Tu(f) {
          const c = f.value;
          return c ? [new We(f.key, c, "constants have been deprecated as of v8")] : [];
        }
        function ni(f) {
          return f instanceof Number || f instanceof String || f instanceof Boolean ? f.valueOf() : f;
        }
        function tc(f) {
          if (Array.isArray(f)) return f.map(tc);
          if (f instanceof Object && !(f instanceof Number || f instanceof String || f instanceof Boolean)) {
            const c = {};
            for (const h in f) c[h] = tc(f[h]);
            return c;
          }
          return ni(f);
        }
        function Mo(f) {
          const c = f.key, h = f.value, p = f.valueSpec || {}, y = f.objectElementValidators || {}, x = f.style, A = f.styleSpec, I = f.validateSpec;
          let B = [];
          const N = sn(h);
          if (N !== "object") return [new We(c, h, `object expected, ${N} found`)];
          for (const z in h) {
            const j = z.split(".")[0], K = p[j] || p["*"];
            let ee;
            if (y[j]) ee = y[j];
            else if (p[j]) ee = I;
            else if (y["*"]) ee = y["*"];
            else {
              if (!p["*"]) {
                B.push(new We(c, h[z], `unknown property "${z}"`));
                continue;
              }
              ee = I;
            }
            B = B.concat(ee({ key: (c && `${c}.`) + z, value: h[z], valueSpec: K, style: x, styleSpec: A, object: h, objectKey: z, validateSpec: I }, h));
          }
          for (const z in p) y[z] || p[z].required && p[z].default === void 0 && h[z] === void 0 && B.push(new We(c, h, `missing required property "${z}"`));
          return B;
        }
        function Uh(f) {
          const c = f.value, h = f.valueSpec, p = f.style, y = f.styleSpec, x = f.key, A = f.arrayElementValidator || f.validateSpec;
          if (sn(c) !== "array") return [new We(x, c, `array expected, ${sn(c)} found`)];
          if (h.length && c.length !== h.length) return [new We(x, c, `array length ${h.length} expected, length ${c.length} found`)];
          if (h["min-length"] && c.length < h["min-length"]) return [new We(x, c, `array length at least ${h["min-length"]} expected, length ${c.length} found`)];
          let I = { type: h.value, values: h.values };
          y.$version < 7 && (I.function = h.function), sn(h.value) === "object" && (I = h.value);
          let B = [];
          for (let N = 0; N < c.length; N++) B = B.concat(A({ array: c, arrayIndex: N, value: c[N], valueSpec: I, validateSpec: f.validateSpec, style: p, styleSpec: y, key: `${x}[${N}]` }));
          return B;
        }
        function zh(f) {
          const c = f.key, h = f.value, p = f.valueSpec;
          let y = sn(h);
          return y === "number" && h != h && (y = "NaN"), y !== "number" ? [new We(c, h, `number expected, ${y} found`)] : "minimum" in p && h < p.minimum ? [new We(c, h, `${h} is less than the minimum value ${p.minimum}`)] : "maximum" in p && h > p.maximum ? [new We(c, h, `${h} is greater than the maximum value ${p.maximum}`)] : [];
        }
        function Ku(f) {
          const c = f.valueSpec, h = ni(f.value.type);
          let p, y, x, A = {};
          const I = h !== "categorical" && f.value.property === void 0, B = !I, N = sn(f.value.stops) === "array" && sn(f.value.stops[0]) === "array" && sn(f.value.stops[0][0]) === "object", z = Mo({ key: f.key, value: f.value, valueSpec: f.styleSpec.function, validateSpec: f.validateSpec, style: f.style, styleSpec: f.styleSpec, objectElementValidators: { stops: function(ee) {
            if (h === "identity") return [new We(ee.key, ee.value, 'identity function may not have a "stops" property')];
            let te = [];
            const le = ee.value;
            return te = te.concat(Uh({ key: ee.key, value: le, valueSpec: ee.valueSpec, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec, arrayElementValidator: j })), sn(le) === "array" && le.length === 0 && te.push(new We(ee.key, le, "array must have at least one stop")), te;
          }, default: function(ee) {
            return ee.validateSpec({ key: ee.key, value: ee.value, valueSpec: c, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec });
          } } });
          return h === "identity" && I && z.push(new We(f.key, f.value, 'missing required property "property"')), h === "identity" || f.value.stops || z.push(new We(f.key, f.value, 'missing required property "stops"')), h === "exponential" && f.valueSpec.expression && !Da(f.valueSpec) && z.push(new We(f.key, f.value, "exponential functions not supported")), f.styleSpec.$version >= 8 && (B && !Co(f.valueSpec) ? z.push(new We(f.key, f.value, "property functions not supported")) : I && !Zl(f.valueSpec) && z.push(new We(f.key, f.value, "zoom functions not supported"))), h !== "categorical" && !N || f.value.property !== void 0 || z.push(new We(f.key, f.value, '"property" property is required')), z;
          function j(ee) {
            let te = [];
            const le = ee.value, Ae = ee.key;
            if (sn(le) !== "array") return [new We(Ae, le, `array expected, ${sn(le)} found`)];
            if (le.length !== 2) return [new We(Ae, le, `array length 2 expected, length ${le.length} found`)];
            if (N) {
              if (sn(le[0]) !== "object") return [new We(Ae, le, `object expected, ${sn(le[0])} found`)];
              if (le[0].zoom === void 0) return [new We(Ae, le, "object stop key must have zoom")];
              if (le[0].value === void 0) return [new We(Ae, le, "object stop key must have value")];
              if (x && x > ni(le[0].zoom)) return [new We(Ae, le[0].zoom, "stop zoom values must appear in ascending order")];
              ni(le[0].zoom) !== x && (x = ni(le[0].zoom), y = void 0, A = {}), te = te.concat(Mo({ key: `${Ae}[0]`, value: le[0], valueSpec: { zoom: {} }, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec, objectElementValidators: { zoom: zh, value: K } }));
            } else te = te.concat(K({ key: `${Ae}[0]`, value: le[0], validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec }, le));
            return Fa(tc(le[1])) ? te.concat([new We(`${Ae}[1]`, le[1], "expressions are not allowed in function stops.")]) : te.concat(ee.validateSpec({ key: `${Ae}[1]`, value: le[1], valueSpec: c, validateSpec: ee.validateSpec, style: ee.style, styleSpec: ee.styleSpec }));
          }
          function K(ee, te) {
            const le = sn(ee.value), Ae = ni(ee.value), Te = ee.value !== null ? ee.value : te;
            if (p) {
              if (le !== p) return [new We(ee.key, Te, `${le} stop domain type must match previous stop domain type ${p}`)];
            } else p = le;
            if (le !== "number" && le !== "string" && le !== "boolean") return [new We(ee.key, Te, "stop domain value must be a number, string, or boolean")];
            if (le !== "number" && h !== "categorical") {
              let Qe = `number expected, ${le} found`;
              return Co(c) && h === void 0 && (Qe += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new We(ee.key, Te, Qe)];
            }
            return h !== "categorical" || le !== "number" || isFinite(Ae) && Math.floor(Ae) === Ae ? h !== "categorical" && le === "number" && y !== void 0 && Ae < y ? [new We(ee.key, Te, "stop domain values must appear in ascending order")] : (y = Ae, h === "categorical" && Ae in A ? [new We(ee.key, Te, "stop domain values must be unique")] : (A[Ae] = !0, [])) : [new We(ee.key, Te, `integer expected, found ${Ae}`)];
          }
        }
        function ml(f) {
          const c = (f.expressionContext === "property" ? eo : Yl)(tc(f.value), f.valueSpec);
          if (c.result === "error") return c.value.map((p) => new We(`${f.key}${p.key}`, f.value, p.message));
          const h = c.value.expression || c.value._styleExpression.expression;
          if (f.expressionContext === "property" && f.propertyKey === "text-font" && !h.outputDefined()) return [new We(f.key, f.value, `Invalid data expression for "${f.propertyKey}". Output values must be contained as literals within the expression.`)];
          if (f.expressionContext === "property" && f.propertyType === "layout" && !Na(h)) return [new We(f.key, f.value, '"feature-state" data expressions are not supported with layout properties.')];
          if (f.expressionContext === "filter" && !Na(h)) return [new We(f.key, f.value, '"feature-state" data expressions are not supported with filters.')];
          if (f.expressionContext && f.expressionContext.indexOf("cluster") === 0) {
            if (!pa(h, ["zoom", "feature-state"])) return [new We(f.key, f.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
            if (f.expressionContext === "cluster-initial" && !Xl(h)) return [new We(f.key, f.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
          }
          return [];
        }
        function ga(f) {
          const c = f.key, h = f.value, p = f.valueSpec, y = [];
          return Array.isArray(p.values) ? p.values.indexOf(ni(h)) === -1 && y.push(new We(c, h, `expected one of [${p.values.join(", ")}], ${JSON.stringify(h)} found`)) : Object.keys(p.values).indexOf(ni(h)) === -1 && y.push(new We(c, h, `expected one of [${Object.keys(p.values).join(", ")}], ${JSON.stringify(h)} found`)), y;
        }
        function Ju(f) {
          return qc(tc(f.value)) ? ml(or({}, f, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : Su(f);
        }
        function Su(f) {
          const c = f.value, h = f.key;
          if (sn(c) !== "array") return [new We(h, c, `array expected, ${sn(c)} found`)];
          const p = f.styleSpec;
          let y, x = [];
          if (c.length < 1) return [new We(h, c, "filter array must have at least 1 element")];
          switch (x = x.concat(ga({ key: `${h}[0]`, value: c[0], valueSpec: p.filter_operator, style: f.style, styleSpec: f.styleSpec })), ni(c[0])) {
            case "<":
            case "<=":
            case ">":
            case ">=":
              c.length >= 2 && ni(c[1]) === "$type" && x.push(new We(h, c, `"$type" cannot be use with operator "${c[0]}"`));
            case "==":
            case "!=":
              c.length !== 3 && x.push(new We(h, c, `filter array for operator "${c[0]}" must have 3 elements`));
            case "in":
            case "!in":
              c.length >= 2 && (y = sn(c[1]), y !== "string" && x.push(new We(`${h}[1]`, c[1], `string expected, ${y} found`)));
              for (let A = 2; A < c.length; A++) y = sn(c[A]), ni(c[1]) === "$type" ? x = x.concat(ga({ key: `${h}[${A}]`, value: c[A], valueSpec: p.geometry_type, style: f.style, styleSpec: f.styleSpec })) : y !== "string" && y !== "number" && y !== "boolean" && x.push(new We(`${h}[${A}]`, c[A], `string, number, or boolean expected, ${y} found`));
              break;
            case "any":
            case "all":
            case "none":
              for (let A = 1; A < c.length; A++) x = x.concat(Su({ key: `${h}[${A}]`, value: c[A], style: f.style, styleSpec: f.styleSpec }));
              break;
            case "has":
            case "!has":
              y = sn(c[1]), c.length !== 2 ? x.push(new We(h, c, `filter array for "${c[0]}" operator must have 2 elements`)) : y !== "string" && x.push(new We(`${h}[1]`, c[1], `string expected, ${y} found`));
          }
          return x;
        }
        function jh(f, c) {
          const h = f.key, p = f.validateSpec, y = f.style, x = f.styleSpec, A = f.value, I = f.objectKey, B = x[`${c}_${f.layerType}`];
          if (!B) return [];
          const N = I.match(/^(.*)-transition$/);
          if (c === "paint" && N && B[N[1]] && B[N[1]].transition) return p({ key: h, value: A, valueSpec: x.transition, style: y, styleSpec: x });
          const z = f.valueSpec || B[I];
          if (!z) return [new We(h, A, `unknown property "${I}"`)];
          let j;
          if (sn(A) === "string" && Co(z) && !z.tokens && (j = /^{([^}]+)}$/.exec(A))) return [new We(h, A, `"${I}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(j[1])} }\`.`)];
          const K = [];
          return f.layerType === "symbol" && (I === "text-field" && y && !y.glyphs && K.push(new We(h, A, 'use of "text-field" requires a style "glyphs" property')), I === "text-font" && dl(tc(A)) && ni(A.type) === "identity" && K.push(new We(h, A, '"text-font" does not support identity functions'))), K.concat(p({ key: f.key, value: A, valueSpec: z, style: y, styleSpec: x, expressionContext: "property", propertyType: c, propertyKey: I }));
        }
        function Vh(f) {
          return jh(f, "paint");
        }
        function qh(f) {
          return jh(f, "layout");
        }
        function Df(f) {
          let c = [];
          const h = f.value, p = f.key, y = f.style, x = f.styleSpec;
          h.type || h.ref || c.push(new We(p, h, 'either "type" or "ref" is required'));
          let A = ni(h.type);
          const I = ni(h.ref);
          if (h.id) {
            const B = ni(h.id);
            for (let N = 0; N < f.arrayIndex; N++) {
              const z = y.layers[N];
              ni(z.id) === B && c.push(new We(p, h.id, `duplicate layer id "${h.id}", previously used at line ${z.id.__line__}`));
            }
          }
          if ("ref" in h) {
            let B;
            ["type", "source", "source-layer", "filter", "layout"].forEach((N) => {
              N in h && c.push(new We(p, h[N], `"${N}" is prohibited for ref layers`));
            }), y.layers.forEach((N) => {
              ni(N.id) === I && (B = N);
            }), B ? B.ref ? c.push(new We(p, h.ref, "ref cannot reference another ref layer")) : A = ni(B.type) : c.push(new We(p, h.ref, `ref layer "${I}" not found`));
          } else if (A !== "background") if (h.source) {
            const B = y.sources && y.sources[h.source], N = B && ni(B.type);
            B ? N === "vector" && A === "raster" ? c.push(new We(p, h.source, `layer "${h.id}" requires a raster source`)) : N !== "raster-dem" && A === "hillshade" ? c.push(new We(p, h.source, `layer "${h.id}" requires a raster-dem source`)) : N === "raster" && A !== "raster" ? c.push(new We(p, h.source, `layer "${h.id}" requires a vector source`)) : N !== "vector" || h["source-layer"] ? N === "raster-dem" && A !== "hillshade" ? c.push(new We(p, h.source, "raster-dem source can only be used with layer type 'hillshade'.")) : A !== "line" || !h.paint || !h.paint["line-gradient"] || N === "geojson" && B.lineMetrics || c.push(new We(p, h, `layer "${h.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : c.push(new We(p, h, `layer "${h.id}" must specify a "source-layer"`)) : c.push(new We(p, h.source, `source "${h.source}" not found`));
          } else c.push(new We(p, h, 'missing required property "source"'));
          return c = c.concat(Mo({ key: p, value: h, valueSpec: x.layer, style: f.style, styleSpec: f.styleSpec, validateSpec: f.validateSpec, objectElementValidators: { "*": () => [], type: () => f.validateSpec({ key: `${p}.type`, value: h.type, valueSpec: x.layer.type, style: f.style, styleSpec: f.styleSpec, validateSpec: f.validateSpec, object: h, objectKey: "type" }), filter: Ju, layout: (B) => Mo({ layer: h, key: B.key, value: B.value, style: B.style, styleSpec: B.styleSpec, validateSpec: B.validateSpec, objectElementValidators: { "*": (N) => qh(or({ layerType: A }, N)) } }), paint: (B) => Mo({ layer: h, key: B.key, value: B.value, style: B.style, styleSpec: B.styleSpec, validateSpec: B.validateSpec, objectElementValidators: { "*": (N) => Vh(or({ layerType: A }, N)) } }) } })), c;
        }
        function _l(f) {
          const c = f.value, h = f.key, p = sn(c);
          return p !== "string" ? [new We(h, c, `string expected, ${p} found`)] : [];
        }
        const ma = { promoteId: function(f) {
          let { key: c, value: h } = f;
          if (sn(h) === "string") return _l({ key: c, value: h });
          {
            const p = [];
            for (const y in h) p.push(..._l({ key: `${c}.${y}`, value: h[y] }));
            return p;
          }
        } };
        function Is(f) {
          const c = f.value, h = f.key, p = f.styleSpec, y = f.style, x = f.validateSpec;
          if (!c.type) return [new We(h, c, '"type" is required')];
          const A = ni(c.type);
          let I;
          switch (A) {
            case "vector":
            case "raster":
              return I = Mo({ key: h, value: c, valueSpec: p[`source_${A.replace("-", "_")}`], style: f.style, styleSpec: p, objectElementValidators: ma, validateSpec: x }), I;
            case "raster-dem":
              return I = function(B) {
                var N;
                const z = (N = B.sourceName) !== null && N !== void 0 ? N : "", j = B.value, K = B.styleSpec, ee = K.source_raster_dem, te = B.style;
                let le = [];
                const Ae = sn(j);
                if (j === void 0) return le;
                if (Ae !== "object") return le.push(new We("source_raster_dem", j, `object expected, ${Ae} found`)), le;
                const Te = ni(j.encoding) === "custom", Qe = ["redFactor", "greenFactor", "blueFactor", "baseShift"], ke = B.value.encoding ? `"${B.value.encoding}"` : "Default";
                for (const Q in j) !Te && Qe.includes(Q) ? le.push(new We(Q, j[Q], `In "${z}": "${Q}" is only valid when "encoding" is set to "custom". ${ke} encoding found`)) : ee[Q] ? le = le.concat(B.validateSpec({ key: Q, value: j[Q], valueSpec: ee[Q], validateSpec: B.validateSpec, style: te, styleSpec: K })) : le.push(new We(Q, j[Q], `unknown property "${Q}"`));
                return le;
              }({ sourceName: h, value: c, style: f.style, styleSpec: p, validateSpec: x }), I;
            case "geojson":
              if (I = Mo({ key: h, value: c, valueSpec: p.source_geojson, style: y, styleSpec: p, validateSpec: x, objectElementValidators: ma }), c.cluster) for (const B in c.clusterProperties) {
                const [N, z] = c.clusterProperties[B], j = typeof N == "string" ? [N, ["accumulated"], ["get", B]] : N;
                I.push(...ml({ key: `${h}.${B}.map`, value: z, expressionContext: "cluster-map" })), I.push(...ml({ key: `${h}.${B}.reduce`, value: j, expressionContext: "cluster-reduce" }));
              }
              return I;
            case "video":
              return Mo({ key: h, value: c, valueSpec: p.source_video, style: y, validateSpec: x, styleSpec: p });
            case "image":
              return Mo({ key: h, value: c, valueSpec: p.source_image, style: y, validateSpec: x, styleSpec: p });
            case "canvas":
              return [new We(h, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
            default:
              return ga({ key: `${h}.type`, value: c.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
          }
        }
        function _a(f) {
          const c = f.value, h = f.styleSpec, p = h.light, y = f.style;
          let x = [];
          const A = sn(c);
          if (c === void 0) return x;
          if (A !== "object") return x = x.concat([new We("light", c, `object expected, ${A} found`)]), x;
          for (const I in c) {
            const B = I.match(/^(.*)-transition$/);
            x = x.concat(B && p[B[1]] && p[B[1]].transition ? f.validateSpec({ key: I, value: c[I], valueSpec: h.transition, validateSpec: f.validateSpec, style: y, styleSpec: h }) : p[I] ? f.validateSpec({ key: I, value: c[I], valueSpec: p[I], validateSpec: f.validateSpec, style: y, styleSpec: h }) : [new We(I, c[I], `unknown property "${I}"`)]);
          }
          return x;
        }
        function kf(f) {
          const c = f.value, h = f.styleSpec, p = h.sky, y = f.style, x = sn(c);
          if (c === void 0) return [];
          if (x !== "object") return [new We("sky", c, `object expected, ${x} found`)];
          let A = [];
          for (const I in c) A = A.concat(p[I] ? f.validateSpec({ key: I, value: c[I], valueSpec: p[I], style: y, styleSpec: h }) : [new We(I, c[I], `unknown property "${I}"`)]);
          return A;
        }
        function Gh(f) {
          const c = f.value, h = f.styleSpec, p = h.terrain, y = f.style;
          let x = [];
          const A = sn(c);
          if (c === void 0) return x;
          if (A !== "object") return x = x.concat([new We("terrain", c, `object expected, ${A} found`)]), x;
          for (const I in c) x = x.concat(p[I] ? f.validateSpec({ key: I, value: c[I], valueSpec: p[I], validateSpec: f.validateSpec, style: y, styleSpec: h }) : [new We(I, c[I], `unknown property "${I}"`)]);
          return x;
        }
        function Ua(f) {
          let c = [];
          const h = f.value, p = f.key;
          if (Array.isArray(h)) {
            const y = [], x = [];
            for (const A in h) h[A].id && y.includes(h[A].id) && c.push(new We(p, h, `all the sprites' ids must be unique, but ${h[A].id} is duplicated`)), y.push(h[A].id), h[A].url && x.includes(h[A].url) && c.push(new We(p, h, `all the sprites' URLs must be unique, but ${h[A].url} is duplicated`)), x.push(h[A].url), c = c.concat(Mo({ key: `${p}[${A}]`, value: h[A], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: f.validateSpec }));
            return c;
          }
          return _l({ key: p, value: h });
        }
        const mo = { "*": () => [], array: Uh, boolean: function(f) {
          const c = f.value, h = f.key, p = sn(c);
          return p !== "boolean" ? [new We(h, c, `boolean expected, ${p} found`)] : [];
        }, number: zh, color: function(f) {
          const c = f.key, h = f.value, p = sn(h);
          return p !== "string" ? [new We(c, h, `color expected, ${p} found`)] : nn.parse(String(h)) ? [] : [new We(c, h, `color expected, "${h}" found`)];
        }, constants: Tu, enum: ga, filter: Ju, function: Ku, layer: Df, object: Mo, source: Is, light: _a, sky: kf, terrain: Gh, projection: function(f) {
          const c = f.value, h = f.styleSpec, p = h.projection, y = f.style, x = sn(c);
          if (c === void 0) return [];
          if (x !== "object") return [new We("projection", c, `object expected, ${x} found`)];
          let A = [];
          for (const I in c) A = A.concat(p[I] ? f.validateSpec({ key: I, value: c[I], valueSpec: p[I], style: y, styleSpec: h }) : [new We(I, c[I], `unknown property "${I}"`)]);
          return A;
        }, projectionDefinition: function(f) {
          const c = f.key;
          let h = f.value;
          h = h instanceof String ? h.valueOf() : h;
          const p = sn(h);
          return p !== "array" || function(y) {
            return Array.isArray(y) && y.length === 3 && typeof y[0] == "string" && typeof y[1] == "string" && typeof y[2] == "number";
          }(h) || function(y) {
            return !!["interpolate", "step", "literal"].includes(y[0]);
          }(h) ? ["array", "string"].includes(p) ? [] : [new We(c, h, `projection expected, invalid type "${p}" found`)] : [new We(c, h, `projection expected, invalid array ${JSON.stringify(h)} found`)];
        }, string: _l, formatted: function(f) {
          return _l(f).length === 0 ? [] : ml(f);
        }, resolvedImage: function(f) {
          return _l(f).length === 0 ? [] : ml(f);
        }, padding: function(f) {
          const c = f.key, h = f.value;
          if (sn(h) === "array") {
            if (h.length < 1 || h.length > 4) return [new We(c, h, `padding requires 1 to 4 values; ${h.length} values found`)];
            const p = { type: "number" };
            let y = [];
            for (let x = 0; x < h.length; x++) y = y.concat(f.validateSpec({ key: `${c}[${x}]`, value: h[x], validateSpec: f.validateSpec, valueSpec: p }));
            return y;
          }
          return zh({ key: c, value: h, valueSpec: {} });
        }, variableAnchorOffsetCollection: function(f) {
          const c = f.key, h = f.value, p = sn(h), y = f.styleSpec;
          if (p !== "array" || h.length < 1 || h.length % 2 != 0) return [new We(c, h, "variableAnchorOffsetCollection requires a non-empty array of even length")];
          let x = [];
          for (let A = 0; A < h.length; A += 2) x = x.concat(ga({ key: `${c}[${A}]`, value: h[A], valueSpec: y.layout_symbol["text-anchor"] })), x = x.concat(Uh({ key: `${c}[${A + 1}]`, value: h[A + 1], valueSpec: { length: 2, value: "number" }, validateSpec: f.validateSpec, style: f.style, styleSpec: y }));
          return x;
        }, sprite: Ua };
        function Qu(f) {
          const c = f.value, h = f.valueSpec, p = f.styleSpec;
          return f.validateSpec = Qu, h.expression && dl(ni(c)) ? Ku(f) : h.expression && Fa(tc(c)) ? ml(f) : h.type && mo[h.type] ? mo[h.type](f) : Mo(or({}, f, { valueSpec: h.type ? p[h.type] : h }));
        }
        function Hc(f) {
          const c = f.value, h = f.key, p = _l(f);
          return p.length || (c.indexOf("{fontstack}") === -1 && p.push(new We(h, c, '"glyphs" url must include a "{fontstack}" token')), c.indexOf("{range}") === -1 && p.push(new We(h, c, '"glyphs" url must include a "{range}" token'))), p;
        }
        function Ms(f) {
          let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ve, h = [];
          return h = h.concat(Qu({ key: "", value: f, valueSpec: c.$root, styleSpec: c, style: f, validateSpec: Qu, objectElementValidators: { glyphs: Hc, "*": () => [] } })), f.constants && (h = h.concat(Tu({ key: "constants", value: f.constants }))), rc(h);
        }
        function _i(f) {
          return function(c) {
            return f({ ...c, validateSpec: Qu });
          };
        }
        function rc(f) {
          return [].concat(f).sort((c, h) => c.line - h.line);
        }
        function Po(f) {
          return function() {
            for (var c = arguments.length, h = new Array(c), p = 0; p < c; p++)
              h[p] = arguments[p];
            return rc(f.apply(this, h));
          };
        }
        Ms.source = Po(_i(Is)), Ms.sprite = Po(_i(Ua)), Ms.glyphs = Po(_i(Hc)), Ms.light = Po(_i(_a)), Ms.sky = Po(_i(kf)), Ms.terrain = Po(_i(Gh)), Ms.layer = Po(_i(Df)), Ms.filter = Po(_i(Ju)), Ms.paintProperty = Po(_i(Vh)), Ms.layoutProperty = Po(_i(qh));
        const Wc = Ms, eh = Wc.light, yl = Wc.sky, Xc = Wc.paintProperty, Eu = Wc.layoutProperty;
        function Ff(f, c) {
          let h = !1;
          if (c && c.length) for (const p of c) f.fire(new bn(new Error(p.message))), h = !0;
          return h;
        }
        class bl {
          constructor(c, h, p) {
            const y = this.cells = [];
            if (c instanceof ArrayBuffer) {
              this.arrayBuffer = c;
              const A = new Int32Array(this.arrayBuffer);
              c = A[0], this.d = (h = A[1]) + 2 * (p = A[2]);
              for (let B = 0; B < this.d * this.d; B++) {
                const N = A[3 + B], z = A[3 + B + 1];
                y.push(N === z ? null : A.subarray(N, z));
              }
              const I = A[3 + y.length + 1];
              this.keys = A.subarray(A[3 + y.length], I), this.bboxes = A.subarray(I), this.insert = this._insertReadonly;
            } else {
              this.d = h + 2 * p;
              for (let A = 0; A < this.d * this.d; A++) y.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = h, this.extent = c, this.padding = p, this.scale = h / c, this.uid = 0;
            const x = p / h * c;
            this.min = -x, this.max = c + x;
          }
          insert(c, h, p, y, x) {
            this._forEachCell(h, p, y, x, this._insertCell, this.uid++, void 0, void 0), this.keys.push(c), this.bboxes.push(h), this.bboxes.push(p), this.bboxes.push(y), this.bboxes.push(x);
          }
          _insertReadonly() {
            throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
          }
          _insertCell(c, h, p, y, x, A) {
            this.cells[x].push(A);
          }
          query(c, h, p, y, x) {
            const A = this.min, I = this.max;
            if (c <= A && h <= A && I <= p && I <= y && !x) return Array.prototype.slice.call(this.keys);
            {
              const B = [];
              return this._forEachCell(c, h, p, y, this._queryCell, B, {}, x), B;
            }
          }
          _queryCell(c, h, p, y, x, A, I, B) {
            const N = this.cells[x];
            if (N !== null) {
              const z = this.keys, j = this.bboxes;
              for (let K = 0; K < N.length; K++) {
                const ee = N[K];
                if (I[ee] === void 0) {
                  const te = 4 * ee;
                  (B ? B(j[te + 0], j[te + 1], j[te + 2], j[te + 3]) : c <= j[te + 2] && h <= j[te + 3] && p >= j[te + 0] && y >= j[te + 1]) ? (I[ee] = !0, A.push(z[ee])) : I[ee] = !1;
                }
              }
            }
          }
          _forEachCell(c, h, p, y, x, A, I, B) {
            const N = this._convertToCellCoord(c), z = this._convertToCellCoord(h), j = this._convertToCellCoord(p), K = this._convertToCellCoord(y);
            for (let ee = N; ee <= j; ee++) for (let te = z; te <= K; te++) {
              const le = this.d * te + ee;
              if ((!B || B(this._convertFromCellCoord(ee), this._convertFromCellCoord(te), this._convertFromCellCoord(ee + 1), this._convertFromCellCoord(te + 1))) && x.call(this, c, h, p, y, le, A, I, B)) return;
            }
          }
          _convertFromCellCoord(c) {
            return (c - this.padding) / this.scale;
          }
          _convertToCellCoord(c) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(c * this.scale) + this.padding));
          }
          toArrayBuffer() {
            if (this.arrayBuffer) return this.arrayBuffer;
            const c = this.cells, h = 3 + this.cells.length + 1 + 1;
            let p = 0;
            for (let A = 0; A < this.cells.length; A++) p += this.cells[A].length;
            const y = new Int32Array(h + p + this.keys.length + this.bboxes.length);
            y[0] = this.extent, y[1] = this.n, y[2] = this.padding;
            let x = h;
            for (let A = 0; A < c.length; A++) {
              const I = c[A];
              y[3 + A] = x, y.set(I, x), x += I.length;
            }
            return y[3 + c.length] = x, y.set(this.keys, x), x += this.keys.length, y[3 + c.length + 1] = x, y.set(this.bboxes, x), x += this.bboxes.length, y.buffer;
          }
          static serialize(c, h) {
            const p = c.toArrayBuffer();
            return h && h.push(p), { buffer: p };
          }
          static deserialize(c) {
            return new bl(c.buffer);
          }
        }
        const za = {};
        function vr(f, c) {
          let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (za[f]) throw new Error(`${f} is already registered.`);
          Object.defineProperty(c, "_classRegistryKey", { value: f, writeable: !1 }), za[f] = { klass: c, omit: h.omit || [], shallow: h.shallow || [] };
        }
        vr("Object", Object), vr("TransferableGridIndex", bl), vr("Color", nn), vr("Error", Error), vr("AJAXError", Zr), vr("ResolvedImage", ai), vr("StylePropertyFunction", js), vr("StyleExpression", pl, { omit: ["_evaluator"] }), vr("ZoomDependentExpression", Kl), vr("ZoomConstantExpression", gl), vr("CompoundExpression", Fi, { omit: ["_evaluate"] });
        for (const f in Qo) Qo[f]._classRegistryKey || vr(`Expression_${f}`, Qo[f]);
        function Uf(f) {
          return f && typeof ArrayBuffer < "u" && (f instanceof ArrayBuffer || f.constructor && f.constructor.name === "ArrayBuffer");
        }
        function nc(f) {
          return f.$name || f.constructor._classRegistryKey;
        }
        function zf(f) {
          return !function(c) {
            if (c === null || typeof c != "object") return !1;
            const h = nc(c);
            return !(!h || h === "Object");
          }(f) && (f == null || typeof f == "boolean" || typeof f == "number" || typeof f == "string" || f instanceof Boolean || f instanceof Number || f instanceof String || f instanceof Date || f instanceof RegExp || f instanceof Blob || f instanceof Error || Uf(f) || Ut(f) || ArrayBuffer.isView(f) || f instanceof ImageData);
        }
        function Cu(f, c) {
          if (zf(f)) return (Uf(f) || Ut(f)) && c && c.push(f), ArrayBuffer.isView(f) && c && c.push(f.buffer), f instanceof ImageData && c && c.push(f.data.buffer), f;
          if (Array.isArray(f)) {
            const x = [];
            for (const A of f) x.push(Cu(A, c));
            return x;
          }
          if (typeof f != "object") throw new Error("can't serialize object of type " + typeof f);
          const h = nc(f);
          if (!h) throw new Error(`can't serialize object of unregistered class ${f.constructor.name}`);
          if (!za[h]) throw new Error(`${h} is not registered.`);
          const { klass: p } = za[h], y = p.serialize ? p.serialize(f, c) : {};
          if (p.serialize) {
            if (c && y === c[c.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
          } else {
            for (const x in f) {
              if (!f.hasOwnProperty(x) || za[h].omit.indexOf(x) >= 0) continue;
              const A = f[x];
              y[x] = za[h].shallow.indexOf(x) >= 0 ? A : Cu(A, c);
            }
            f instanceof Error && (y.message = f.message);
          }
          if (y.$name) throw new Error("$name property is reserved for worker serialization logic.");
          return h !== "Object" && (y.$name = h), y;
        }
        function ja(f) {
          if (zf(f)) return f;
          if (Array.isArray(f)) return f.map(ja);
          if (typeof f != "object") throw new Error("can't deserialize object of type " + typeof f);
          const c = nc(f) || "Object";
          if (!za[c]) throw new Error(`can't deserialize unregistered class ${c}`);
          const { klass: h } = za[c];
          if (!h) throw new Error(`can't deserialize unregistered class ${c}`);
          if (h.deserialize) return h.deserialize(f);
          const p = Object.create(h.prototype);
          for (const y of Object.keys(f)) {
            if (y === "$name") continue;
            const x = f[y];
            p[y] = za[c].shallow.indexOf(y) >= 0 ? x : ja(x);
          }
          return p;
        }
        class Iu {
          constructor() {
            this.first = !0;
          }
          update(c, h) {
            const p = Math.floor(c);
            return this.first ? (this.first = !1, this.lastIntegerZoom = p, this.lastIntegerZoomTime = 0, this.lastZoom = c, this.lastFloorZoom = p, !0) : (this.lastFloorZoom > p ? (this.lastIntegerZoom = p + 1, this.lastIntegerZoomTime = h) : this.lastFloorZoom < p && (this.lastIntegerZoom = p, this.lastIntegerZoomTime = h), c !== this.lastZoom && (this.lastZoom = c, this.lastFloorZoom = p, !0));
          }
        }
        const cn = { "Latin-1 Supplement": (f) => f >= 128 && f <= 255, "Hangul Jamo": (f) => f >= 4352 && f <= 4607, Khmer: (f) => f >= 6016 && f <= 6143, "General Punctuation": (f) => f >= 8192 && f <= 8303, "Letterlike Symbols": (f) => f >= 8448 && f <= 8527, "Number Forms": (f) => f >= 8528 && f <= 8591, "Miscellaneous Technical": (f) => f >= 8960 && f <= 9215, "Control Pictures": (f) => f >= 9216 && f <= 9279, "Optical Character Recognition": (f) => f >= 9280 && f <= 9311, "Enclosed Alphanumerics": (f) => f >= 9312 && f <= 9471, "Geometric Shapes": (f) => f >= 9632 && f <= 9727, "Miscellaneous Symbols": (f) => f >= 9728 && f <= 9983, "Miscellaneous Symbols and Arrows": (f) => f >= 11008 && f <= 11263, "Ideographic Description Characters": (f) => f >= 12272 && f <= 12287, "CJK Symbols and Punctuation": (f) => f >= 12288 && f <= 12351, Hiragana: (f) => f >= 12352 && f <= 12447, Katakana: (f) => f >= 12448 && f <= 12543, Kanbun: (f) => f >= 12688 && f <= 12703, "CJK Strokes": (f) => f >= 12736 && f <= 12783, "Enclosed CJK Letters and Months": (f) => f >= 12800 && f <= 13055, "CJK Compatibility": (f) => f >= 13056 && f <= 13311, "Yijing Hexagram Symbols": (f) => f >= 19904 && f <= 19967, "CJK Unified Ideographs": (f) => f >= 19968 && f <= 40959, "Hangul Syllables": (f) => f >= 44032 && f <= 55215, "Private Use Area": (f) => f >= 57344 && f <= 63743, "Vertical Forms": (f) => f >= 65040 && f <= 65055, "CJK Compatibility Forms": (f) => f >= 65072 && f <= 65103, "Small Form Variants": (f) => f >= 65104 && f <= 65135, "Halfwidth and Fullwidth Forms": (f) => f >= 65280 && f <= 65519 };
        function Zc(f) {
          for (const c of f) if (re(c.charCodeAt(0))) return !0;
          return !1;
        }
        function $h(f) {
          for (const c of f) if (!F(c.charCodeAt(0))) return !1;
          return !0;
        }
        function S(f) {
          const c = f.map((h) => {
            try {
              return new RegExp(`\\p{sc=${h}}`, "u").source;
            } catch {
              return null;
            }
          }).filter((h) => h);
          return new RegExp(c.join("|"), "u");
        }
        const P = S(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
        function F(f) {
          return !P.test(String.fromCodePoint(f));
        }
        const $ = S(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
        function re(f) {
          return !(f !== 746 && f !== 747 && (f < 4352 || !(cn["CJK Compatibility Forms"](f) && !(f >= 65097 && f <= 65103) || cn["CJK Compatibility"](f) || cn["CJK Strokes"](f) || !(!cn["CJK Symbols and Punctuation"](f) || f >= 12296 && f <= 12305 || f >= 12308 && f <= 12319 || f === 12336) || cn["Enclosed CJK Letters and Months"](f) || cn["Ideographic Description Characters"](f) || cn.Kanbun(f) || cn.Katakana(f) && f !== 12540 || !(!cn["Halfwidth and Fullwidth Forms"](f) || f === 65288 || f === 65289 || f === 65293 || f >= 65306 && f <= 65310 || f === 65339 || f === 65341 || f === 65343 || f >= 65371 && f <= 65503 || f === 65507 || f >= 65512 && f <= 65519) || !(!cn["Small Form Variants"](f) || f >= 65112 && f <= 65118 || f >= 65123 && f <= 65126) || cn["Vertical Forms"](f) || cn["Yijing Hexagram Symbols"](f) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(f)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(f)) || $.test(String.fromCodePoint(f)))));
        }
        function fe(f) {
          return !(re(f) || function(c) {
            return !!(cn["Latin-1 Supplement"](c) && (c === 167 || c === 169 || c === 174 || c === 177 || c === 188 || c === 189 || c === 190 || c === 215 || c === 247) || cn["General Punctuation"](c) && (c === 8214 || c === 8224 || c === 8225 || c === 8240 || c === 8241 || c === 8251 || c === 8252 || c === 8258 || c === 8263 || c === 8264 || c === 8265 || c === 8273) || cn["Letterlike Symbols"](c) || cn["Number Forms"](c) || cn["Miscellaneous Technical"](c) && (c >= 8960 && c <= 8967 || c >= 8972 && c <= 8991 || c >= 8996 && c <= 9e3 || c === 9003 || c >= 9085 && c <= 9114 || c >= 9150 && c <= 9165 || c === 9167 || c >= 9169 && c <= 9179 || c >= 9186 && c <= 9215) || cn["Control Pictures"](c) && c !== 9251 || cn["Optical Character Recognition"](c) || cn["Enclosed Alphanumerics"](c) || cn["Geometric Shapes"](c) || cn["Miscellaneous Symbols"](c) && !(c >= 9754 && c <= 9759) || cn["Miscellaneous Symbols and Arrows"](c) && (c >= 11026 && c <= 11055 || c >= 11088 && c <= 11097 || c >= 11192 && c <= 11243) || cn["CJK Symbols and Punctuation"](c) || cn.Katakana(c) || cn["Private Use Area"](c) || cn["CJK Compatibility Forms"](c) || cn["Small Form Variants"](c) || cn["Halfwidth and Fullwidth Forms"](c) || c === 8734 || c === 8756 || c === 8757 || c >= 9984 && c <= 10087 || c >= 10102 && c <= 10131 || c === 65532 || c === 65533);
          }(f));
        }
        const ge = S(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
        function be(f) {
          return ge.test(String.fromCodePoint(f));
        }
        function we(f, c) {
          return !(!c && be(f) || f >= 2304 && f <= 3583 || f >= 3840 && f <= 4255 || cn.Khmer(f));
        }
        function Pe(f) {
          for (const c of f) if (be(c.charCodeAt(0))) return !0;
          return !1;
        }
        const et = new class {
          constructor() {
            this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
            };
          }
          setState(f) {
            this.pluginStatus = f.pluginStatus, this.pluginURL = f.pluginURL;
          }
          getState() {
            return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
          }
          setMethods(f) {
            if (et.isParsed()) throw new Error("RTL text plugin already registered.");
            this.applyArabicShaping = f.applyArabicShaping, this.processBidirectionalText = f.processBidirectionalText, this.processStyledBidirectionalText = f.processStyledBidirectionalText, this.loadScriptResolve();
          }
          isParsed() {
            return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
          }
          getRTLTextPluginStatus() {
            return this.pluginStatus;
          }
          syncState(f, c) {
            return o(this, void 0, void 0, function* () {
              if (this.isParsed()) return this.getState();
              if (f.pluginStatus !== "loading") return this.setState(f), f;
              const h = f.pluginURL, p = new Promise((x) => {
                this.loadScriptResolve = x;
              });
              c(h);
              const y = new Promise((x) => setTimeout(() => x(), this.TIMEOUT));
              if (yield Promise.race([p, y]), this.isParsed()) {
                const x = { pluginStatus: "loaded", pluginURL: h };
                return this.setState(x), x;
              }
              throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${h}`);
            });
          }
        }();
        class ot {
          constructor(c, h) {
            this.zoom = c, h ? (this.now = h.now, this.fadeDuration = h.fadeDuration, this.zoomHistory = h.zoomHistory, this.transition = h.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Iu(), this.transition = {});
          }
          isSupportedScript(c) {
            return function(h, p) {
              for (const y of h) if (!we(y.charCodeAt(0), p)) return !1;
              return !0;
            }(c, et.getRTLTextPluginStatus() === "loaded");
          }
          crossFadingFactor() {
            return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }
          getCrossfadeParameters() {
            const c = this.zoom, h = c - Math.floor(c), p = this.crossFadingFactor();
            return c > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: h + (1 - h) * p } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - p) * h };
          }
        }
        class xt {
          constructor(c, h) {
            this.property = c, this.value = h, this.expression = function(p, y) {
              if (dl(p)) return new js(p, y);
              if (Fa(p)) {
                const x = eo(p, y);
                if (x.result === "error") throw new Error(x.value.map((A) => `${A.key}: ${A.message}`).join(", "));
                return x.value;
              }
              {
                let x = p;
                return y.type === "color" && typeof p == "string" ? x = nn.parse(p) : y.type !== "padding" || typeof p != "number" && !Array.isArray(p) ? y.type === "variableAnchorOffsetCollection" && Array.isArray(p) ? x = Yi.parse(p) : y.type === "projectionDefinition" && typeof p == "string" && (x = Mi.parse(p)) : x = mi.parse(p), { kind: "constant", evaluate: () => x };
              }
            }(h === void 0 ? c.specification.default : h, c.specification);
          }
          isDataDriven() {
            return this.expression.kind === "source" || this.expression.kind === "composite";
          }
          possiblyEvaluate(c, h, p) {
            return this.property.possiblyEvaluate(this, c, h, p);
          }
        }
        class st {
          constructor(c) {
            this.property = c, this.value = new xt(c, void 0);
          }
          transitioned(c, h) {
            return new Ot(this.property, this.value, h, Xe({}, c.transition, this.transition), c.now);
          }
          untransitioned() {
            return new Ot(this.property, this.value, null, {}, 0);
          }
        }
        class Wt {
          constructor(c) {
            this._properties = c, this._values = Object.create(c.defaultTransitionablePropertyValues);
          }
          getValue(c) {
            return wt(this._values[c].value.value);
          }
          setValue(c, h) {
            Object.prototype.hasOwnProperty.call(this._values, c) || (this._values[c] = new st(this._values[c].property)), this._values[c].value = new xt(this._values[c].property, h === null ? void 0 : wt(h));
          }
          getTransition(c) {
            return wt(this._values[c].transition);
          }
          setTransition(c, h) {
            Object.prototype.hasOwnProperty.call(this._values, c) || (this._values[c] = new st(this._values[c].property)), this._values[c].transition = wt(h) || void 0;
          }
          serialize() {
            const c = {};
            for (const h of Object.keys(this._values)) {
              const p = this.getValue(h);
              p !== void 0 && (c[h] = p);
              const y = this.getTransition(h);
              y !== void 0 && (c[`${h}-transition`] = y);
            }
            return c;
          }
          transitioned(c, h) {
            const p = new tt(this._properties);
            for (const y of Object.keys(this._values)) p._values[y] = this._values[y].transitioned(c, h._values[y]);
            return p;
          }
          untransitioned() {
            const c = new tt(this._properties);
            for (const h of Object.keys(this._values)) c._values[h] = this._values[h].untransitioned();
            return c;
          }
        }
        class Ot {
          constructor(c, h, p, y, x) {
            this.property = c, this.value = h, this.begin = x + y.delay || 0, this.end = this.begin + y.duration || 0, c.specification.transition && (y.delay || y.duration) && (this.prior = p);
          }
          possiblyEvaluate(c, h, p) {
            const y = c.now || 0, x = this.value.possiblyEvaluate(c, h, p), A = this.prior;
            if (A) {
              if (y > this.end) return this.prior = null, x;
              if (this.value.isDataDriven()) return this.prior = null, x;
              if (y < this.begin) return A.possiblyEvaluate(c, h, p);
              {
                const I = (y - this.begin) / (this.end - this.begin);
                return this.property.interpolate(A.possiblyEvaluate(c, h, p), x, Nt(I));
              }
            }
            return x;
          }
        }
        class tt {
          constructor(c) {
            this._properties = c, this._values = Object.create(c.defaultTransitioningPropertyValues);
          }
          possiblyEvaluate(c, h, p) {
            const y = new Zt(this._properties);
            for (const x of Object.keys(this._values)) y._values[x] = this._values[x].possiblyEvaluate(c, h, p);
            return y;
          }
          hasTransition() {
            for (const c of Object.keys(this._values)) if (this._values[c].prior) return !0;
            return !1;
          }
        }
        class nt {
          constructor(c) {
            this._properties = c, this._values = Object.create(c.defaultPropertyValues);
          }
          hasValue(c) {
            return this._values[c].value !== void 0;
          }
          getValue(c) {
            return wt(this._values[c].value);
          }
          setValue(c, h) {
            this._values[c] = new xt(this._values[c].property, h === null ? void 0 : wt(h));
          }
          serialize() {
            const c = {};
            for (const h of Object.keys(this._values)) {
              const p = this.getValue(h);
              p !== void 0 && (c[h] = p);
            }
            return c;
          }
          possiblyEvaluate(c, h, p) {
            const y = new Zt(this._properties);
            for (const x of Object.keys(this._values)) y._values[x] = this._values[x].possiblyEvaluate(c, h, p);
            return y;
          }
        }
        class qt {
          constructor(c, h, p) {
            this.property = c, this.value = h, this.parameters = p;
          }
          isConstant() {
            return this.value.kind === "constant";
          }
          constantOr(c) {
            return this.value.kind === "constant" ? this.value.value : c;
          }
          evaluate(c, h, p, y) {
            return this.property.evaluate(this.value, this.parameters, c, h, p, y);
          }
        }
        class Zt {
          constructor(c) {
            this._properties = c, this._values = Object.create(c.defaultPossiblyEvaluatedValues);
          }
          get(c) {
            return this._values[c];
          }
        }
        class dt {
          constructor(c) {
            this.specification = c;
          }
          possiblyEvaluate(c, h) {
            if (c.isDataDriven()) throw new Error("Value should not be data driven");
            return c.expression.evaluate(h);
          }
          interpolate(c, h, p) {
            const y = ho[this.specification.type];
            return y ? y(c, h, p) : c;
          }
        }
        class Vt {
          constructor(c, h) {
            this.specification = c, this.overrides = h;
          }
          possiblyEvaluate(c, h, p, y) {
            return new qt(this, c.expression.kind === "constant" || c.expression.kind === "camera" ? { kind: "constant", value: c.expression.evaluate(h, null, {}, p, y) } : c.expression, h);
          }
          interpolate(c, h, p) {
            if (c.value.kind !== "constant" || h.value.kind !== "constant") return c;
            if (c.value.value === void 0 || h.value.value === void 0) return new qt(this, { kind: "constant", value: void 0 }, c.parameters);
            const y = ho[this.specification.type];
            if (y) {
              const x = y(c.value.value, h.value.value, p);
              return new qt(this, { kind: "constant", value: x }, c.parameters);
            }
            return c;
          }
          evaluate(c, h, p, y, x, A) {
            return c.kind === "constant" ? c.value : c.evaluate(h, p, y, x, A);
          }
        }
        class yr extends Vt {
          possiblyEvaluate(c, h, p, y) {
            if (c.value === void 0) return new qt(this, { kind: "constant", value: void 0 }, h);
            if (c.expression.kind === "constant") {
              const x = c.expression.evaluate(h, null, {}, p, y), A = c.property.specification.type === "resolvedImage" && typeof x != "string" ? x.name : x, I = this._calculate(A, A, A, h);
              return new qt(this, { kind: "constant", value: I }, h);
            }
            if (c.expression.kind === "camera") {
              const x = this._calculate(c.expression.evaluate({ zoom: h.zoom - 1 }), c.expression.evaluate({ zoom: h.zoom }), c.expression.evaluate({ zoom: h.zoom + 1 }), h);
              return new qt(this, { kind: "constant", value: x }, h);
            }
            return new qt(this, c.expression, h);
          }
          evaluate(c, h, p, y, x, A) {
            if (c.kind === "source") {
              const I = c.evaluate(h, p, y, x, A);
              return this._calculate(I, I, I, h);
            }
            return c.kind === "composite" ? this._calculate(c.evaluate({ zoom: Math.floor(h.zoom) - 1 }, p, y), c.evaluate({ zoom: Math.floor(h.zoom) }, p, y), c.evaluate({ zoom: Math.floor(h.zoom) + 1 }, p, y), h) : c.value;
          }
          _calculate(c, h, p, y) {
            return y.zoom > y.zoomHistory.lastIntegerZoom ? { from: c, to: h } : { from: p, to: h };
          }
          interpolate(c) {
            return c;
          }
        }
        class Ur {
          constructor(c) {
            this.specification = c;
          }
          possiblyEvaluate(c, h, p, y) {
            if (c.value !== void 0) {
              if (c.expression.kind === "constant") {
                const x = c.expression.evaluate(h, null, {}, p, y);
                return this._calculate(x, x, x, h);
              }
              return this._calculate(c.expression.evaluate(new ot(Math.floor(h.zoom - 1), h)), c.expression.evaluate(new ot(Math.floor(h.zoom), h)), c.expression.evaluate(new ot(Math.floor(h.zoom + 1), h)), h);
            }
          }
          _calculate(c, h, p, y) {
            return y.zoom > y.zoomHistory.lastIntegerZoom ? { from: c, to: h } : { from: p, to: h };
          }
          interpolate(c) {
            return c;
          }
        }
        class xr {
          constructor(c) {
            this.specification = c;
          }
          possiblyEvaluate(c, h, p, y) {
            return !!c.expression.evaluate(h, null, {}, p, y);
          }
          interpolate() {
            return !1;
          }
        }
        class rn {
          constructor(c) {
            this.properties = c, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
            for (const h in c) {
              const p = c[h];
              p.specification.overridable && this.overridableProperties.push(h);
              const y = this.defaultPropertyValues[h] = new xt(p, void 0), x = this.defaultTransitionablePropertyValues[h] = new st(p);
              this.defaultTransitioningPropertyValues[h] = x.untransitioned(), this.defaultPossiblyEvaluatedValues[h] = y.possiblyEvaluate({});
            }
          }
        }
        vr("DataDrivenProperty", Vt), vr("DataConstantProperty", dt), vr("CrossFadedDataDrivenProperty", yr), vr("CrossFadedProperty", Ur), vr("ColorRampProperty", xr);
        const Ln = "-transition";
        class on extends Xi {
          constructor(c, h) {
            if (super(), this.id = c.id, this.type = c.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, c.type !== "custom" && (this.metadata = c.metadata, this.minzoom = c.minzoom, this.maxzoom = c.maxzoom, c.type !== "background" && (this.source = c.source, this.sourceLayer = c["source-layer"], this.filter = c.filter), h.layout && (this._unevaluatedLayout = new nt(h.layout)), h.paint)) {
              this._transitionablePaint = new Wt(h.paint);
              for (const p in c.paint) this.setPaintProperty(p, c.paint[p], { validate: !1 });
              for (const p in c.layout) this.setLayoutProperty(p, c.layout[p], { validate: !1 });
              this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Zt(h.paint);
            }
          }
          getCrossfadeParameters() {
            return this._crossfadeParameters;
          }
          getLayoutProperty(c) {
            return c === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(c);
          }
          setLayoutProperty(c, h) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            h != null && this._validate(Eu, `layers.${this.id}.layout.${c}`, c, h, p) || (c !== "visibility" ? this._unevaluatedLayout.setValue(c, h) : this.visibility = h);
          }
          getPaintProperty(c) {
            return c.endsWith(Ln) ? this._transitionablePaint.getTransition(c.slice(0, -11)) : this._transitionablePaint.getValue(c);
          }
          setPaintProperty(c, h) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (h != null && this._validate(Xc, `layers.${this.id}.paint.${c}`, c, h, p)) return !1;
            if (c.endsWith(Ln)) return this._transitionablePaint.setTransition(c.slice(0, -11), h || void 0), !1;
            {
              const y = this._transitionablePaint._values[c], x = y.property.specification["property-type"] === "cross-faded-data-driven", A = y.value.isDataDriven(), I = y.value;
              this._transitionablePaint.setValue(c, h), this._handleSpecialPaintPropertyUpdate(c);
              const B = this._transitionablePaint._values[c].value;
              return B.isDataDriven() || A || x || this._handleOverridablePaintPropertyUpdate(c, I, B);
            }
          }
          _handleSpecialPaintPropertyUpdate(c) {
          }
          _handleOverridablePaintPropertyUpdate(c, h, p) {
            return !1;
          }
          isHidden(c) {
            return !!(this.minzoom && c < this.minzoom) || !!(this.maxzoom && c >= this.maxzoom) || this.visibility === "none";
          }
          updateTransitions(c) {
            this._transitioningPaint = this._transitionablePaint.transitioned(c, this._transitioningPaint);
          }
          hasTransition() {
            return this._transitioningPaint.hasTransition();
          }
          recalculate(c, h) {
            c.getCrossfadeParameters && (this._crossfadeParameters = c.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(c, void 0, h)), this.paint = this._transitioningPaint.possiblyEvaluate(c, void 0, h);
          }
          serialize() {
            const c = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
            return this.visibility && (c.layout = c.layout || {}, c.layout.visibility = this.visibility), St(c, (h, p) => !(h === void 0 || p === "layout" && !Object.keys(h).length || p === "paint" && !Object.keys(h).length));
          }
          _validate(c, h, p, y) {
            let x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
            return (!x || x.validate !== !1) && Ff(this, c.call(Wc, { key: h, layerType: this.type, objectKey: p, value: y, styleSpec: ve, style: { glyphs: !0, sprite: !0 } }));
          }
          is3D() {
            return !1;
          }
          isTileClipped() {
            return !1;
          }
          hasOffscreenPass() {
            return !1;
          }
          resize() {
          }
          isStateDependent() {
            for (const c in this.paint._values) {
              const h = this.paint.get(c);
              if (h instanceof qt && Co(h.property.specification) && (h.value.kind === "source" || h.value.kind === "composite") && h.value.isStateDependent) return !0;
            }
            return !1;
          }
        }
        const wn = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
        class Mn {
          constructor(c, h) {
            this._structArray = c, this._pos1 = h * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }
        }
        class zr {
          constructor() {
            this.isTransferred = !1, this.capacity = -1, this.resize(0);
          }
          static serialize(c, h) {
            return c._trim(), h && (c.isTransferred = !0, h.push(c.arrayBuffer)), { length: c.length, arrayBuffer: c.arrayBuffer };
          }
          static deserialize(c) {
            const h = Object.create(this.prototype);
            return h.arrayBuffer = c.arrayBuffer, h.length = c.length, h.capacity = c.arrayBuffer.byteLength / h.bytesPerElement, h._refreshViews(), h;
          }
          _trim() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }
          clear() {
            this.length = 0;
          }
          resize(c) {
            this.reserve(c), this.length = c;
          }
          reserve(c) {
            if (c > this.capacity) {
              this.capacity = Math.max(c, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              const h = this.uint8;
              this._refreshViews(), h && this.uint8.set(h);
            }
          }
          _refreshViews() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          }
        }
        function Br(f) {
          let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, h = 0, p = 0;
          return { members: f.map((y) => {
            const x = wn[y.type].BYTES_PER_ELEMENT, A = h = Bi(h, Math.max(c, x)), I = y.components || 1;
            return p = Math.max(p, x), h += x * I, { name: y.name, type: y.type, components: I, offset: A };
          }), size: Bi(h, Math.max(p, c)), alignment: c };
        }
        function Bi(f, c) {
          return Math.ceil(f / c) * c;
        }
        class es extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, h) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, c, h);
          }
          emplace(c, h, p) {
            const y = 2 * c;
            return this.int16[y + 0] = h, this.int16[y + 1] = p, c;
          }
        }
        es.prototype.bytesPerElement = 4, vr("StructArrayLayout2i4", es);
        class li extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, c, h, p);
          }
          emplace(c, h, p, y) {
            const x = 3 * c;
            return this.int16[x + 0] = h, this.int16[x + 1] = p, this.int16[x + 2] = y, c;
          }
        }
        li.prototype.bytesPerElement = 6, vr("StructArrayLayout3i6", li);
        class Ps extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y) {
            const x = this.length;
            return this.resize(x + 1), this.emplace(x, c, h, p, y);
          }
          emplace(c, h, p, y, x) {
            const A = 4 * c;
            return this.int16[A + 0] = h, this.int16[A + 1] = p, this.int16[A + 2] = y, this.int16[A + 3] = x, c;
          }
        }
        Ps.prototype.bytesPerElement = 8, vr("StructArrayLayout4i8", Ps);
        class Pn extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y, x, A) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, c, h, p, y, x, A);
          }
          emplace(c, h, p, y, x, A, I) {
            const B = 6 * c;
            return this.int16[B + 0] = h, this.int16[B + 1] = p, this.int16[B + 2] = y, this.int16[B + 3] = x, this.int16[B + 4] = A, this.int16[B + 5] = I, c;
          }
        }
        Pn.prototype.bytesPerElement = 12, vr("StructArrayLayout2i4i12", Pn);
        class Li extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y, x, A) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, c, h, p, y, x, A);
          }
          emplace(c, h, p, y, x, A, I) {
            const B = 4 * c, N = 8 * c;
            return this.int16[B + 0] = h, this.int16[B + 1] = p, this.uint8[N + 4] = y, this.uint8[N + 5] = x, this.uint8[N + 6] = A, this.uint8[N + 7] = I, c;
          }
        }
        Li.prototype.bytesPerElement = 8, vr("StructArrayLayout2i4ub8", Li);
        class ts extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, h) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, c, h);
          }
          emplace(c, h, p) {
            const y = 2 * c;
            return this.float32[y + 0] = h, this.float32[y + 1] = p, c;
          }
        }
        ts.prototype.bytesPerElement = 8, vr("StructArrayLayout2f8", ts);
        class Ei extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y, x, A, I, B, N, z) {
            const j = this.length;
            return this.resize(j + 1), this.emplace(j, c, h, p, y, x, A, I, B, N, z);
          }
          emplace(c, h, p, y, x, A, I, B, N, z, j) {
            const K = 10 * c;
            return this.uint16[K + 0] = h, this.uint16[K + 1] = p, this.uint16[K + 2] = y, this.uint16[K + 3] = x, this.uint16[K + 4] = A, this.uint16[K + 5] = I, this.uint16[K + 6] = B, this.uint16[K + 7] = N, this.uint16[K + 8] = z, this.uint16[K + 9] = j, c;
          }
        }
        Ei.prototype.bytesPerElement = 20, vr("StructArrayLayout10ui20", Ei);
        class zi extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y, x, A, I, B, N, z, j, K) {
            const ee = this.length;
            return this.resize(ee + 1), this.emplace(ee, c, h, p, y, x, A, I, B, N, z, j, K);
          }
          emplace(c, h, p, y, x, A, I, B, N, z, j, K, ee) {
            const te = 12 * c;
            return this.int16[te + 0] = h, this.int16[te + 1] = p, this.int16[te + 2] = y, this.int16[te + 3] = x, this.uint16[te + 4] = A, this.uint16[te + 5] = I, this.uint16[te + 6] = B, this.uint16[te + 7] = N, this.int16[te + 8] = z, this.int16[te + 9] = j, this.int16[te + 10] = K, this.int16[te + 11] = ee, c;
          }
        }
        zi.prototype.bytesPerElement = 24, vr("StructArrayLayout4i4ui4i24", zi);
        class Gi extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, c, h, p);
          }
          emplace(c, h, p, y) {
            const x = 3 * c;
            return this.float32[x + 0] = h, this.float32[x + 1] = p, this.float32[x + 2] = y, c;
          }
        }
        Gi.prototype.bytesPerElement = 12, vr("StructArrayLayout3f12", Gi);
        class to extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
          }
          emplaceBack(c) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, c);
          }
          emplace(c, h) {
            return this.uint32[1 * c + 0] = h, c;
          }
        }
        to.prototype.bytesPerElement = 4, vr("StructArrayLayout1ul4", to);
        class Vs extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y, x, A, I, B, N) {
            const z = this.length;
            return this.resize(z + 1), this.emplace(z, c, h, p, y, x, A, I, B, N);
          }
          emplace(c, h, p, y, x, A, I, B, N, z) {
            const j = 10 * c, K = 5 * c;
            return this.int16[j + 0] = h, this.int16[j + 1] = p, this.int16[j + 2] = y, this.int16[j + 3] = x, this.int16[j + 4] = A, this.int16[j + 5] = I, this.uint32[K + 3] = B, this.uint16[j + 8] = N, this.uint16[j + 9] = z, c;
          }
        }
        Vs.prototype.bytesPerElement = 20, vr("StructArrayLayout6i1ul2ui20", Vs);
        class ci extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y, x, A) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, c, h, p, y, x, A);
          }
          emplace(c, h, p, y, x, A, I) {
            const B = 6 * c;
            return this.int16[B + 0] = h, this.int16[B + 1] = p, this.int16[B + 2] = y, this.int16[B + 3] = x, this.int16[B + 4] = A, this.int16[B + 5] = I, c;
          }
        }
        ci.prototype.bytesPerElement = 12, vr("StructArrayLayout2i2i2i12", ci);
        class ea extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y, x) {
            const A = this.length;
            return this.resize(A + 1), this.emplace(A, c, h, p, y, x);
          }
          emplace(c, h, p, y, x, A) {
            const I = 4 * c, B = 8 * c;
            return this.float32[I + 0] = h, this.float32[I + 1] = p, this.float32[I + 2] = y, this.int16[B + 6] = x, this.int16[B + 7] = A, c;
          }
        }
        ea.prototype.bytesPerElement = 16, vr("StructArrayLayout2f1f2i16", ea);
        class ya extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y, x, A) {
            const I = this.length;
            return this.resize(I + 1), this.emplace(I, c, h, p, y, x, A);
          }
          emplace(c, h, p, y, x, A, I) {
            const B = 16 * c, N = 4 * c, z = 8 * c;
            return this.uint8[B + 0] = h, this.uint8[B + 1] = p, this.float32[N + 1] = y, this.float32[N + 2] = x, this.int16[z + 6] = A, this.int16[z + 7] = I, c;
          }
        }
        ya.prototype.bytesPerElement = 16, vr("StructArrayLayout2ub2f2i16", ya);
        class _o extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, c, h, p);
          }
          emplace(c, h, p, y) {
            const x = 3 * c;
            return this.uint16[x + 0] = h, this.uint16[x + 1] = p, this.uint16[x + 2] = y, c;
          }
        }
        _o.prototype.bytesPerElement = 6, vr("StructArrayLayout3ui6", _o);
        class ba extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y, x, A, I, B, N, z, j, K, ee, te, le, Ae, Te) {
            const Qe = this.length;
            return this.resize(Qe + 1), this.emplace(Qe, c, h, p, y, x, A, I, B, N, z, j, K, ee, te, le, Ae, Te);
          }
          emplace(c, h, p, y, x, A, I, B, N, z, j, K, ee, te, le, Ae, Te, Qe) {
            const ke = 24 * c, Q = 12 * c, xe = 48 * c;
            return this.int16[ke + 0] = h, this.int16[ke + 1] = p, this.uint16[ke + 2] = y, this.uint16[ke + 3] = x, this.uint32[Q + 2] = A, this.uint32[Q + 3] = I, this.uint32[Q + 4] = B, this.uint16[ke + 10] = N, this.uint16[ke + 11] = z, this.uint16[ke + 12] = j, this.float32[Q + 7] = K, this.float32[Q + 8] = ee, this.uint8[xe + 36] = te, this.uint8[xe + 37] = le, this.uint8[xe + 38] = Ae, this.uint32[Q + 10] = Te, this.int16[ke + 22] = Qe, c;
          }
        }
        ba.prototype.bytesPerElement = 48, vr("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", ba);
        class ui extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y, x, A, I, B, N, z, j, K, ee, te, le, Ae, Te, Qe, ke, Q, xe, ze, yt, $t, It, Lt, er, Xt) {
            const ir = this.length;
            return this.resize(ir + 1), this.emplace(ir, c, h, p, y, x, A, I, B, N, z, j, K, ee, te, le, Ae, Te, Qe, ke, Q, xe, ze, yt, $t, It, Lt, er, Xt);
          }
          emplace(c, h, p, y, x, A, I, B, N, z, j, K, ee, te, le, Ae, Te, Qe, ke, Q, xe, ze, yt, $t, It, Lt, er, Xt, ir) {
            const Dt = 32 * c, Er = 16 * c;
            return this.int16[Dt + 0] = h, this.int16[Dt + 1] = p, this.int16[Dt + 2] = y, this.int16[Dt + 3] = x, this.int16[Dt + 4] = A, this.int16[Dt + 5] = I, this.int16[Dt + 6] = B, this.int16[Dt + 7] = N, this.uint16[Dt + 8] = z, this.uint16[Dt + 9] = j, this.uint16[Dt + 10] = K, this.uint16[Dt + 11] = ee, this.uint16[Dt + 12] = te, this.uint16[Dt + 13] = le, this.uint16[Dt + 14] = Ae, this.uint16[Dt + 15] = Te, this.uint16[Dt + 16] = Qe, this.uint16[Dt + 17] = ke, this.uint16[Dt + 18] = Q, this.uint16[Dt + 19] = xe, this.uint16[Dt + 20] = ze, this.uint16[Dt + 21] = yt, this.uint16[Dt + 22] = $t, this.uint32[Er + 12] = It, this.float32[Er + 13] = Lt, this.float32[Er + 14] = er, this.uint16[Dt + 30] = Xt, this.uint16[Dt + 31] = ir, c;
          }
        }
        ui.prototype.bytesPerElement = 64, vr("StructArrayLayout8i15ui1ul2f2ui64", ui);
        class ic extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, c);
          }
          emplace(c, h) {
            return this.float32[1 * c + 0] = h, c;
          }
        }
        ic.prototype.bytesPerElement = 4, vr("StructArrayLayout1f4", ic);
        class th extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, c, h, p);
          }
          emplace(c, h, p, y) {
            const x = 3 * c;
            return this.uint16[6 * c + 0] = h, this.float32[x + 1] = p, this.float32[x + 2] = y, c;
          }
        }
        th.prototype.bytesPerElement = 12, vr("StructArrayLayout1ui2f12", th);
        class v extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p) {
            const y = this.length;
            return this.resize(y + 1), this.emplace(y, c, h, p);
          }
          emplace(c, h, p, y) {
            const x = 4 * c;
            return this.uint32[2 * c + 0] = h, this.uint16[x + 2] = p, this.uint16[x + 3] = y, c;
          }
        }
        v.prototype.bytesPerElement = 8, vr("StructArrayLayout1ul2ui8", v);
        class a extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c, h) {
            const p = this.length;
            return this.resize(p + 1), this.emplace(p, c, h);
          }
          emplace(c, h, p) {
            const y = 2 * c;
            return this.uint16[y + 0] = h, this.uint16[y + 1] = p, c;
          }
        }
        a.prototype.bytesPerElement = 4, vr("StructArrayLayout2ui4", a);
        class u extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
          }
          emplaceBack(c) {
            const h = this.length;
            return this.resize(h + 1), this.emplace(h, c);
          }
          emplace(c, h) {
            return this.uint16[1 * c + 0] = h, c;
          }
        }
        u.prototype.bytesPerElement = 2, vr("StructArrayLayout1ui2", u);
        class g extends zr {
          _refreshViews() {
            this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
          }
          emplaceBack(c, h, p, y) {
            const x = this.length;
            return this.resize(x + 1), this.emplace(x, c, h, p, y);
          }
          emplace(c, h, p, y, x) {
            const A = 4 * c;
            return this.float32[A + 0] = h, this.float32[A + 1] = p, this.float32[A + 2] = y, this.float32[A + 3] = x, c;
          }
        }
        g.prototype.bytesPerElement = 16, vr("StructArrayLayout4f16", g);
        class _ extends Mn {
          get anchorPointX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorPointY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get x1() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get y1() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get x2() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get y2() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get anchorPoint() {
            return new D(this.anchorPointX, this.anchorPointY);
          }
        }
        _.prototype.size = 20;
        class w extends Vs {
          get(c) {
            return new _(this, c);
          }
        }
        vr("CollisionBoxArray", w);
        class C extends Mn {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get glyphStartIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get numGlyphs() {
            return this._structArray.uint16[this._pos2 + 3];
          }
          get vertexStartIndex() {
            return this._structArray.uint32[this._pos4 + 2];
          }
          get lineStartIndex() {
            return this._structArray.uint32[this._pos4 + 3];
          }
          get lineLength() {
            return this._structArray.uint32[this._pos4 + 4];
          }
          get segment() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get lowerSize() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get upperSize() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get lineOffsetX() {
            return this._structArray.float32[this._pos4 + 7];
          }
          get lineOffsetY() {
            return this._structArray.float32[this._pos4 + 8];
          }
          get writingMode() {
            return this._structArray.uint8[this._pos1 + 36];
          }
          get placedOrientation() {
            return this._structArray.uint8[this._pos1 + 37];
          }
          set placedOrientation(c) {
            this._structArray.uint8[this._pos1 + 37] = c;
          }
          get hidden() {
            return this._structArray.uint8[this._pos1 + 38];
          }
          set hidden(c) {
            this._structArray.uint8[this._pos1 + 38] = c;
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 10];
          }
          set crossTileID(c) {
            this._structArray.uint32[this._pos4 + 10] = c;
          }
          get associatedIconIndex() {
            return this._structArray.int16[this._pos2 + 22];
          }
        }
        C.prototype.size = 48;
        class R extends ba {
          get(c) {
            return new C(this, c);
          }
        }
        vr("PlacedSymbolArray", R);
        class L extends Mn {
          get anchorX() {
            return this._structArray.int16[this._pos2 + 0];
          }
          get anchorY() {
            return this._structArray.int16[this._pos2 + 1];
          }
          get rightJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 2];
          }
          get centerJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 3];
          }
          get leftJustifiedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 4];
          }
          get verticalPlacedTextSymbolIndex() {
            return this._structArray.int16[this._pos2 + 5];
          }
          get placedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 6];
          }
          get verticalPlacedIconSymbolIndex() {
            return this._structArray.int16[this._pos2 + 7];
          }
          get key() {
            return this._structArray.uint16[this._pos2 + 8];
          }
          get textBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 9];
          }
          get textBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 10];
          }
          get verticalTextBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 11];
          }
          get verticalTextBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 12];
          }
          get iconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 13];
          }
          get iconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 14];
          }
          get verticalIconBoxStartIndex() {
            return this._structArray.uint16[this._pos2 + 15];
          }
          get verticalIconBoxEndIndex() {
            return this._structArray.uint16[this._pos2 + 16];
          }
          get featureIndex() {
            return this._structArray.uint16[this._pos2 + 17];
          }
          get numHorizontalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 18];
          }
          get numVerticalGlyphVertices() {
            return this._structArray.uint16[this._pos2 + 19];
          }
          get numIconVertices() {
            return this._structArray.uint16[this._pos2 + 20];
          }
          get numVerticalIconVertices() {
            return this._structArray.uint16[this._pos2 + 21];
          }
          get useRuntimeCollisionCircles() {
            return this._structArray.uint16[this._pos2 + 22];
          }
          get crossTileID() {
            return this._structArray.uint32[this._pos4 + 12];
          }
          set crossTileID(c) {
            this._structArray.uint32[this._pos4 + 12] = c;
          }
          get textBoxScale() {
            return this._structArray.float32[this._pos4 + 13];
          }
          get collisionCircleDiameter() {
            return this._structArray.float32[this._pos4 + 14];
          }
          get textAnchorOffsetStartIndex() {
            return this._structArray.uint16[this._pos2 + 30];
          }
          get textAnchorOffsetEndIndex() {
            return this._structArray.uint16[this._pos2 + 31];
          }
        }
        L.prototype.size = 64;
        class k extends ui {
          get(c) {
            return new L(this, c);
          }
        }
        vr("SymbolInstanceArray", k);
        class V extends ic {
          getoffsetX(c) {
            return this.float32[1 * c + 0];
          }
        }
        vr("GlyphOffsetArray", V);
        class W extends li {
          getx(c) {
            return this.int16[3 * c + 0];
          }
          gety(c) {
            return this.int16[3 * c + 1];
          }
          gettileUnitDistanceFromAnchor(c) {
            return this.int16[3 * c + 2];
          }
        }
        vr("SymbolLineVertexArray", W);
        class Z extends Mn {
          get textAnchor() {
            return this._structArray.uint16[this._pos2 + 0];
          }
          get textOffset0() {
            return this._structArray.float32[this._pos4 + 1];
          }
          get textOffset1() {
            return this._structArray.float32[this._pos4 + 2];
          }
        }
        Z.prototype.size = 12;
        class ae extends th {
          get(c) {
            return new Z(this, c);
          }
        }
        vr("TextAnchorOffsetArray", ae);
        class ue extends Mn {
          get featureIndex() {
            return this._structArray.uint32[this._pos4 + 0];
          }
          get sourceLayerIndex() {
            return this._structArray.uint16[this._pos2 + 2];
          }
          get bucketIndex() {
            return this._structArray.uint16[this._pos2 + 3];
          }
        }
        ue.prototype.size = 8;
        class Ce extends v {
          get(c) {
            return new ue(this, c);
          }
        }
        vr("FeatureIndexArray", Ce);
        class Se extends es {
        }
        class Ie extends es {
        }
        class Le extends es {
        }
        class qe extends Pn {
        }
        class $e extends Li {
        }
        class He extends ts {
        }
        class Ze extends Ei {
        }
        class Je extends zi {
        }
        class vt extends Gi {
        }
        class _t extends to {
        }
        class Rt extends ci {
        }
        class Ft extends ya {
        }
        class Mt extends _o {
        }
        class sr extends a {
        }
        const nr = Br([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Gt } = nr;
        class dr {
          constructor() {
            let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            this._forceNewSegmentOnNextPrepare = !1, this.segments = c;
          }
          prepareSegment(c, h, p, y) {
            const x = this.segments[this.segments.length - 1];
            return c > dr.MAX_VERTEX_ARRAY_LENGTH && Yt(`Max vertices per segment is ${dr.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${c}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${dr.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !x || x.vertexLength + c > dr.MAX_VERTEX_ARRAY_LENGTH || x.sortKey !== y ? this.createNewSegment(h, p, y) : x;
          }
          createNewSegment(c, h, p) {
            const y = { vertexOffset: c.length, primitiveOffset: h.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
            return p !== void 0 && (y.sortKey = p), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(y), y;
          }
          getOrCreateLatestSegment(c, h, p) {
            return this.prepareSegment(0, c, h, p);
          }
          forceNewSegmentOnNextPrepare() {
            this._forceNewSegmentOnNextPrepare = !0;
          }
          get() {
            return this.segments;
          }
          destroy() {
            for (const c of this.segments) for (const h in c.vaos) c.vaos[h].destroy();
          }
          static simpleSegment(c, h, p, y) {
            return new dr([{ vertexOffset: c, primitiveOffset: h, vertexLength: p, primitiveLength: y, vaos: {}, sortKey: 0 }]);
          }
        }
        function Gr(f, c) {
          return 256 * (f = Be(Math.floor(f), 0, 255)) + Be(Math.floor(c), 0, 255);
        }
        dr.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, vr("SegmentVector", dr);
        const mn = Br([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
        var Jn, zn, Qn, Tn = { exports: {} }, On = { exports: {} }, Nn = { exports: {} }, ys = function() {
          if (Qn) return Tn.exports;
          Qn = 1;
          var f = (Jn || (Jn = 1, On.exports = function(h, p) {
            var y, x, A, I, B, N, z, j;
            for (x = h.length - (y = 3 & h.length), A = p, B = 3432918353, N = 461845907, j = 0; j < x; ) z = 255 & h.charCodeAt(j) | (255 & h.charCodeAt(++j)) << 8 | (255 & h.charCodeAt(++j)) << 16 | (255 & h.charCodeAt(++j)) << 24, ++j, A = 27492 + (65535 & (I = 5 * (65535 & (A = (A ^= z = (65535 & (z = (z = (65535 & z) * B + (((z >>> 16) * B & 65535) << 16) & 4294967295) << 15 | z >>> 17)) * N + (((z >>> 16) * N & 65535) << 16) & 4294967295) << 13 | A >>> 19)) + ((5 * (A >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (I >>> 16) & 65535) << 16);
            switch (z = 0, y) {
              case 3:
                z ^= (255 & h.charCodeAt(j + 2)) << 16;
              case 2:
                z ^= (255 & h.charCodeAt(j + 1)) << 8;
              case 1:
                A ^= z = (65535 & (z = (z = (65535 & (z ^= 255 & h.charCodeAt(j))) * B + (((z >>> 16) * B & 65535) << 16) & 4294967295) << 15 | z >>> 17)) * N + (((z >>> 16) * N & 65535) << 16) & 4294967295;
            }
            return A ^= h.length, A = 2246822507 * (65535 & (A ^= A >>> 16)) + ((2246822507 * (A >>> 16) & 65535) << 16) & 4294967295, A = 3266489909 * (65535 & (A ^= A >>> 13)) + ((3266489909 * (A >>> 16) & 65535) << 16) & 4294967295, (A ^= A >>> 16) >>> 0;
          }), On.exports), c = (zn || (zn = 1, Nn.exports = function(h, p) {
            for (var y, x = h.length, A = p ^ x, I = 0; x >= 4; ) y = 1540483477 * (65535 & (y = 255 & h.charCodeAt(I) | (255 & h.charCodeAt(++I)) << 8 | (255 & h.charCodeAt(++I)) << 16 | (255 & h.charCodeAt(++I)) << 24)) + ((1540483477 * (y >>> 16) & 65535) << 16), A = 1540483477 * (65535 & A) + ((1540483477 * (A >>> 16) & 65535) << 16) ^ (y = 1540483477 * (65535 & (y ^= y >>> 24)) + ((1540483477 * (y >>> 16) & 65535) << 16)), x -= 4, ++I;
            switch (x) {
              case 3:
                A ^= (255 & h.charCodeAt(I + 2)) << 16;
              case 2:
                A ^= (255 & h.charCodeAt(I + 1)) << 8;
              case 1:
                A = 1540483477 * (65535 & (A ^= 255 & h.charCodeAt(I))) + ((1540483477 * (A >>> 16) & 65535) << 16);
            }
            return A = 1540483477 * (65535 & (A ^= A >>> 13)) + ((1540483477 * (A >>> 16) & 65535) << 16), (A ^= A >>> 15) >>> 0;
          }), Nn.exports);
          return Tn.exports = f, Tn.exports.murmur3 = f, Tn.exports.murmur2 = c, Tn.exports;
        }(), Oi = d(ys);
        class ji {
          constructor() {
            this.ids = [], this.positions = [], this.indexed = !1;
          }
          add(c, h, p, y) {
            this.ids.push($i(c)), this.positions.push(h, p, y);
          }
          getPositions(c) {
            if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
            const h = $i(c);
            let p = 0, y = this.ids.length - 1;
            for (; p < y; ) {
              const A = p + y >> 1;
              this.ids[A] >= h ? y = A : p = A + 1;
            }
            const x = [];
            for (; this.ids[p] === h; ) x.push({ index: this.positions[3 * p], start: this.positions[3 * p + 1], end: this.positions[3 * p + 2] }), p++;
            return x;
          }
          static serialize(c, h) {
            const p = new Float64Array(c.ids), y = new Uint32Array(c.positions);
            return ta(p, y, 0, p.length - 1), h && h.push(p.buffer, y.buffer), { ids: p, positions: y };
          }
          static deserialize(c) {
            const h = new ji();
            return h.ids = c.ids, h.positions = c.positions, h.indexed = !0, h;
          }
        }
        function $i(f) {
          const c = +f;
          return !isNaN(c) && c <= Number.MAX_SAFE_INTEGER ? c : Oi(String(f));
        }
        function ta(f, c, h, p) {
          for (; h < p; ) {
            const y = f[h + p >> 1];
            let x = h - 1, A = p + 1;
            for (; ; ) {
              do
                x++;
              while (f[x] < y);
              do
                A--;
              while (f[A] > y);
              if (x >= A) break;
              yo(f, x, A), yo(c, 3 * x, 3 * A), yo(c, 3 * x + 1, 3 * A + 1), yo(c, 3 * x + 2, 3 * A + 2);
            }
            A - h < p - A ? (ta(f, c, h, A), h = A + 1) : (ta(f, c, A + 1, p), p = A);
          }
        }
        function yo(f, c, h) {
          const p = f[c];
          f[c] = f[h], f[h] = p;
        }
        vr("FeaturePositionMap", ji);
        class Ni {
          constructor(c, h) {
            this.gl = c.gl, this.location = h;
          }
        }
        class Rs extends Ni {
          constructor(c, h) {
            super(c, h), this.current = 0;
          }
          set(c) {
            this.current !== c && (this.current = c, this.gl.uniform1f(this.location, c));
          }
        }
        class Ro extends Ni {
          constructor(c, h) {
            super(c, h), this.current = [0, 0, 0, 0];
          }
          set(c) {
            c[0] === this.current[0] && c[1] === this.current[1] && c[2] === this.current[2] && c[3] === this.current[3] || (this.current = c, this.gl.uniform4f(this.location, c[0], c[1], c[2], c[3]));
          }
        }
        class vl extends Ni {
          constructor(c, h) {
            super(c, h), this.current = nn.transparent;
          }
          set(c) {
            c.r === this.current.r && c.g === this.current.g && c.b === this.current.b && c.a === this.current.a || (this.current = c, this.gl.uniform4f(this.location, c.r, c.g, c.b, c.a));
          }
        }
        const xl = new Float32Array(16);
        function qs(f) {
          return [Gr(255 * f.r, 255 * f.g), Gr(255 * f.b, 255 * f.a)];
        }
        class Bo {
          constructor(c, h, p) {
            this.value = c, this.uniformNames = h.map((y) => `u_${y}`), this.type = p;
          }
          setUniform(c, h, p) {
            c.set(p.constantOr(this.value));
          }
          getBinding(c, h, p) {
            return this.type === "color" ? new vl(c, h) : new Rs(c, h);
          }
        }
        class ro {
          constructor(c, h) {
            this.uniformNames = h.map((p) => `u_${p}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          }
          setConstantPatternPositions(c, h) {
            this.pixelRatioFrom = h.pixelRatio, this.pixelRatioTo = c.pixelRatio, this.patternFrom = h.tlbr, this.patternTo = c.tlbr;
          }
          setUniform(c, h, p, y) {
            const x = y === "u_pattern_to" ? this.patternTo : y === "u_pattern_from" ? this.patternFrom : y === "u_pixel_ratio_to" ? this.pixelRatioTo : y === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
            x && c.set(x);
          }
          getBinding(c, h, p) {
            return p.substr(0, 9) === "u_pattern" ? new Ro(c, h) : new Rs(c, h);
          }
        }
        class Gs {
          constructor(c, h, p, y) {
            this.expression = c, this.type = p, this.maxValue = 0, this.paintVertexAttributes = h.map((x) => ({ name: `a_${x}`, type: "Float32", components: p === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new y();
          }
          populatePaintArray(c, h, p, y, x) {
            const A = this.paintVertexArray.length, I = this.expression.evaluate(new ot(0), h, {}, y, [], x);
            this.paintVertexArray.resize(c), this._setPaintValue(A, c, I);
          }
          updatePaintArray(c, h, p, y) {
            const x = this.expression.evaluate({ zoom: 0 }, p, y);
            this._setPaintValue(c, h, x);
          }
          _setPaintValue(c, h, p) {
            if (this.type === "color") {
              const y = qs(p);
              for (let x = c; x < h; x++) this.paintVertexArray.emplace(x, y[0], y[1]);
            } else {
              for (let y = c; y < h; y++) this.paintVertexArray.emplace(y, p);
              this.maxValue = Math.max(this.maxValue, Math.abs(p));
            }
          }
          upload(c) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = c.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
        }
        class Xn {
          constructor(c, h, p, y, x, A) {
            this.expression = c, this.uniformNames = h.map((I) => `u_${I}_t`), this.type = p, this.useIntegerZoom = y, this.zoom = x, this.maxValue = 0, this.paintVertexAttributes = h.map((I) => ({ name: `a_${I}`, type: "Float32", components: p === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new A();
          }
          populatePaintArray(c, h, p, y, x) {
            const A = this.expression.evaluate(new ot(this.zoom), h, {}, y, [], x), I = this.expression.evaluate(new ot(this.zoom + 1), h, {}, y, [], x), B = this.paintVertexArray.length;
            this.paintVertexArray.resize(c), this._setPaintValue(B, c, A, I);
          }
          updatePaintArray(c, h, p, y) {
            const x = this.expression.evaluate({ zoom: this.zoom }, p, y), A = this.expression.evaluate({ zoom: this.zoom + 1 }, p, y);
            this._setPaintValue(c, h, x, A);
          }
          _setPaintValue(c, h, p, y) {
            if (this.type === "color") {
              const x = qs(p), A = qs(y);
              for (let I = c; I < h; I++) this.paintVertexArray.emplace(I, x[0], x[1], A[0], A[1]);
            } else {
              for (let x = c; x < h; x++) this.paintVertexArray.emplace(x, p, y);
              this.maxValue = Math.max(this.maxValue, Math.abs(p), Math.abs(y));
            }
          }
          upload(c) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = c.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }
          destroy() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }
          setUniform(c, h) {
            const p = this.useIntegerZoom ? Math.floor(h.zoom) : h.zoom, y = Be(this.expression.interpolationFactor(p, this.zoom, this.zoom + 1), 0, 1);
            c.set(y);
          }
          getBinding(c, h, p) {
            return new Rs(c, h);
          }
        }
        class yi {
          constructor(c, h, p, y, x, A) {
            this.expression = c, this.type = h, this.useIntegerZoom = p, this.zoom = y, this.layerId = A, this.zoomInPaintVertexArray = new x(), this.zoomOutPaintVertexArray = new x();
          }
          populatePaintArray(c, h, p) {
            const y = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(c), this.zoomOutPaintVertexArray.resize(c), this._setPaintValues(y, c, h.patterns && h.patterns[this.layerId], p);
          }
          updatePaintArray(c, h, p, y, x) {
            this._setPaintValues(c, h, p.patterns && p.patterns[this.layerId], x);
          }
          _setPaintValues(c, h, p, y) {
            if (!y || !p) return;
            const { min: x, mid: A, max: I } = p, B = y[x], N = y[A], z = y[I];
            if (B && N && z) for (let j = c; j < h; j++) this.zoomInPaintVertexArray.emplace(j, N.tl[0], N.tl[1], N.br[0], N.br[1], B.tl[0], B.tl[1], B.br[0], B.br[1], N.pixelRatio, B.pixelRatio), this.zoomOutPaintVertexArray.emplace(j, N.tl[0], N.tl[1], N.br[0], N.br[1], z.tl[0], z.tl[1], z.br[0], z.br[1], N.pixelRatio, z.pixelRatio);
          }
          upload(c) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = c.createVertexBuffer(this.zoomInPaintVertexArray, mn.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = c.createVertexBuffer(this.zoomOutPaintVertexArray, mn.members, this.expression.isStateDependent));
          }
          destroy() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          }
        }
        class ra {
          constructor(c, h, p) {
            this.binders = {}, this._buffers = [];
            const y = [];
            for (const x in c.paint._values) {
              if (!p(x)) continue;
              const A = c.paint.get(x);
              if (!(A instanceof qt && Co(A.property.specification))) continue;
              const I = jy(x, c.type), B = A.value, N = A.property.specification.type, z = A.property.useIntegerZoom, j = A.property.specification["property-type"], K = j === "cross-faded" || j === "cross-faded-data-driven";
              if (B.kind === "constant") this.binders[x] = K ? new ro(B.value, I) : new Bo(B.value, I, N), y.push(`/u_${x}`);
              else if (B.kind === "source" || K) {
                const ee = Dg(x, N, "source");
                this.binders[x] = K ? new yi(B, N, z, h, ee, c.id) : new Gs(B, I, N, ee), y.push(`/a_${x}`);
              } else {
                const ee = Dg(x, N, "composite");
                this.binders[x] = new Xn(B, I, N, z, h, ee), y.push(`/z_${x}`);
              }
            }
            this.cacheKey = y.sort().join("");
          }
          getMaxValue(c) {
            const h = this.binders[c];
            return h instanceof Gs || h instanceof Xn ? h.maxValue : 0;
          }
          populatePaintArrays(c, h, p, y, x) {
            for (const A in this.binders) {
              const I = this.binders[A];
              (I instanceof Gs || I instanceof Xn || I instanceof yi) && I.populatePaintArray(c, h, p, y, x);
            }
          }
          setConstantPatternPositions(c, h) {
            for (const p in this.binders) {
              const y = this.binders[p];
              y instanceof ro && y.setConstantPatternPositions(c, h);
            }
          }
          updatePaintArrays(c, h, p, y, x) {
            let A = !1;
            for (const I in c) {
              const B = h.getPositions(I);
              for (const N of B) {
                const z = p.feature(N.index);
                for (const j in this.binders) {
                  const K = this.binders[j];
                  if ((K instanceof Gs || K instanceof Xn || K instanceof yi) && K.expression.isStateDependent === !0) {
                    const ee = y.paint.get(j);
                    K.expression = ee.value, K.updatePaintArray(N.start, N.end, z, c[I], x), A = !0;
                  }
                }
              }
            }
            return A;
          }
          defines() {
            const c = [];
            for (const h in this.binders) {
              const p = this.binders[h];
              (p instanceof Bo || p instanceof ro) && c.push(...p.uniformNames.map((y) => `#define HAS_UNIFORM_${y}`));
            }
            return c;
          }
          getBinderAttributes() {
            const c = [];
            for (const h in this.binders) {
              const p = this.binders[h];
              if (p instanceof Gs || p instanceof Xn) for (let y = 0; y < p.paintVertexAttributes.length; y++) c.push(p.paintVertexAttributes[y].name);
              else if (p instanceof yi) for (let y = 0; y < mn.members.length; y++) c.push(mn.members[y].name);
            }
            return c;
          }
          getBinderUniforms() {
            const c = [];
            for (const h in this.binders) {
              const p = this.binders[h];
              if (p instanceof Bo || p instanceof ro || p instanceof Xn) for (const y of p.uniformNames) c.push(y);
            }
            return c;
          }
          getPaintVertexBuffers() {
            return this._buffers;
          }
          getUniforms(c, h) {
            const p = [];
            for (const y in this.binders) {
              const x = this.binders[y];
              if (x instanceof Bo || x instanceof ro || x instanceof Xn) {
                for (const A of x.uniformNames) if (h[A]) {
                  const I = x.getBinding(c, h[A], A);
                  p.push({ name: A, property: y, binding: I });
                }
              }
            }
            return p;
          }
          setUniforms(c, h, p, y) {
            for (const { name: x, property: A, binding: I } of h) this.binders[A].setUniform(I, y, p.get(A), x);
          }
          updatePaintBuffers(c) {
            this._buffers = [];
            for (const h in this.binders) {
              const p = this.binders[h];
              if (c && p instanceof yi) {
                const y = c.fromScale === 2 ? p.zoomInPaintVertexBuffer : p.zoomOutPaintVertexBuffer;
                y && this._buffers.push(y);
              } else (p instanceof Gs || p instanceof Xn) && p.paintVertexBuffer && this._buffers.push(p.paintVertexBuffer);
            }
          }
          upload(c) {
            for (const h in this.binders) {
              const p = this.binders[h];
              (p instanceof Gs || p instanceof Xn || p instanceof yi) && p.upload(c);
            }
            this.updatePaintBuffers();
          }
          destroy() {
            for (const c in this.binders) {
              const h = this.binders[c];
              (h instanceof Gs || h instanceof Xn || h instanceof yi) && h.destroy();
            }
          }
        }
        class Ci {
          constructor(c, h) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : () => !0;
            this.programConfigurations = {};
            for (const y of c) this.programConfigurations[y.id] = new ra(y, h, p);
            this.needsUpload = !1, this._featureMap = new ji(), this._bufferOffset = 0;
          }
          populatePaintArrays(c, h, p, y, x, A) {
            for (const I in this.programConfigurations) this.programConfigurations[I].populatePaintArrays(c, h, y, x, A);
            h.id !== void 0 && this._featureMap.add(h.id, p, this._bufferOffset, c), this._bufferOffset = c, this.needsUpload = !0;
          }
          updatePaintArrays(c, h, p, y) {
            for (const x of p) this.needsUpload = this.programConfigurations[x.id].updatePaintArrays(c, this._featureMap, h, x, y) || this.needsUpload;
          }
          get(c) {
            return this.programConfigurations[c];
          }
          upload(c) {
            if (this.needsUpload) {
              for (const h in this.programConfigurations) this.programConfigurations[h].upload(c);
              this.needsUpload = !1;
            }
          }
          destroy() {
            for (const c in this.programConfigurations) this.programConfigurations[c].destroy();
          }
        }
        function jy(f, c) {
          return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[f] || [f.replace(`${c}-`, "").replace(/-/g, "_")];
        }
        function Dg(f, c, h) {
          const p = { color: { source: ts, composite: g }, number: { source: ic, composite: ts } }, y = function(x) {
            return { "line-pattern": { source: Ze, composite: Ze }, "fill-pattern": { source: Ze, composite: Ze }, "fill-extrusion-pattern": { source: Ze, composite: Ze } }[x];
          }(f);
          return y && y[h] || p[c][h];
        }
        vr("ConstantBinder", Bo), vr("CrossFadedConstantBinder", ro), vr("SourceExpressionBinder", Gs), vr("CrossFadedCompositeBinder", yi), vr("CompositeExpressionBinder", Xn), vr("ProgramConfiguration", ra, { omit: ["_buffers"] }), vr("ProgramConfigurationSet", Ci);
        const ip = Math.pow(2, 14) - 1, kg = -ip - 1;
        function Mu(f) {
          const c = ht / f.extent, h = f.loadGeometry();
          for (let p = 0; p < h.length; p++) {
            const y = h[p];
            for (let x = 0; x < y.length; x++) {
              const A = y[x], I = Math.round(A.x * c), B = Math.round(A.y * c);
              A.x = Be(I, kg, ip), A.y = Be(B, kg, ip), (I < A.x || I > A.x + 1 || B < A.y || B > A.y + 1) && Yt("Geometry exceeds allowed extent, reduce your vector tile buffer size");
            }
          }
          return h;
        }
        function Pu(f, c) {
          return { type: f.type, id: f.id, properties: f.properties, geometry: c ? Mu(f) : [] };
        }
        const Yc = -32768;
        function Fg(f, c, h, p, y) {
          f.emplaceBack(Yc + 8 * c + p, Yc + 8 * h + y);
        }
        class jf {
          constructor(c) {
            this.zoom = c.zoom, this.overscaling = c.overscaling, this.layers = c.layers, this.layerIds = this.layers.map((h) => h.id), this.index = c.index, this.hasPattern = !1, this.layoutVertexArray = new Ie(), this.indexArray = new Mt(), this.segments = new dr(), this.programConfigurations = new Ci(c.layers, c.zoom), this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
          }
          populate(c, h, p) {
            const y = this.layers[0], x = [];
            let A = null, I = !1, B = y.type === "heatmap";
            if (y.type === "circle") {
              const z = y;
              A = z.layout.get("circle-sort-key"), I = !A.isConstant(), B = B || z.paint.get("circle-pitch-alignment") === "map";
            }
            const N = B ? h.subdivisionGranularity.circle : 1;
            for (const { feature: z, id: j, index: K, sourceLayerIndex: ee } of c) {
              const te = this.layers[0]._featureFilter.needGeometry, le = Pu(z, te);
              if (!this.layers[0]._featureFilter.filter(new ot(this.zoom), le, p)) continue;
              const Ae = I ? A.evaluate(le, {}, p) : void 0, Te = { id: j, properties: z.properties, type: z.type, sourceLayerIndex: ee, index: K, geometry: te ? le.geometry : Mu(z), patterns: {}, sortKey: Ae };
              x.push(Te);
            }
            I && x.sort((z, j) => z.sortKey - j.sortKey);
            for (const z of x) {
              const { geometry: j, index: K, sourceLayerIndex: ee } = z, te = c[K].feature;
              this.addFeature(z, j, K, p, N), h.featureIndex.insert(te, j, K, ee, this.index);
            }
          }
          update(c, h, p) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(c, h, this.stateDependentLayers, p);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(c) {
            this.uploaded || (this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, Gt), this.indexBuffer = c.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(c), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          addFeature(c, h, p, y) {
            let x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1, A;
            switch (x) {
              case 1:
                A = [0, 7];
                break;
              case 3:
                A = [0, 2, 5, 7];
                break;
              case 5:
                A = [0, 1, 3, 4, 6, 7];
                break;
              case 7:
                A = [0, 1, 2, 3, 4, 5, 6, 7];
                break;
              default:
                throw new Error(`Invalid circle bucket granularity: ${x}; valid values are 1, 3, 5, 7.`);
            }
            const I = A.length;
            for (const B of h) for (const N of B) {
              const z = N.x, j = N.y;
              if (z < 0 || z >= ht || j < 0 || j >= ht) continue;
              const K = this.segments.prepareSegment(I * I, this.layoutVertexArray, this.indexArray, c.sortKey), ee = K.vertexLength;
              for (let te = 0; te < I; te++) for (let le = 0; le < I; le++) Fg(this.layoutVertexArray, z, j, A[le], A[te]);
              for (let te = 0; te < I - 1; te++) for (let le = 0; le < I - 1; le++) {
                const Ae = ee + te * I + le, Te = ee + (te + 1) * I + le;
                this.indexArray.emplaceBack(Ae, Te + 1, Ae + 1), this.indexArray.emplaceBack(Ae, Te, Te + 1);
              }
              K.vertexLength += I * I, K.primitiveLength += (I - 1) * (I - 1) * 2;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, c, p, {}, y);
          }
        }
        function sp(f, c) {
          for (let h = 0; h < f.length; h++) if (Vf(c, f[h])) return !0;
          for (let h = 0; h < c.length; h++) if (Vf(f, c[h])) return !0;
          return !!Vy(f, c);
        }
        function op(f, c, h) {
          return !!Vf(f, c) || !!qy(c, f, h);
        }
        function ap(f, c) {
          if (f.length === 1) return lx(c, f[0]);
          for (let h = 0; h < c.length; h++) {
            const p = c[h];
            for (let y = 0; y < p.length; y++) if (Vf(f, p[y])) return !0;
          }
          for (let h = 0; h < f.length; h++) if (lx(c, f[h])) return !0;
          for (let h = 0; h < c.length; h++) if (Vy(f, c[h])) return !0;
          return !1;
        }
        function lp(f, c, h) {
          if (f.length > 1) {
            if (Vy(f, c)) return !0;
            for (let p = 0; p < c.length; p++) if (qy(c[p], f, h)) return !0;
          }
          for (let p = 0; p < f.length; p++) if (qy(f[p], c, h)) return !0;
          return !1;
        }
        function Vy(f, c) {
          if (f.length === 0 || c.length === 0) return !1;
          for (let h = 0; h < f.length - 1; h++) {
            const p = f[h], y = f[h + 1];
            for (let x = 0; x < c.length - 1; x++) if (HM(p, y, c[x], c[x + 1])) return !0;
          }
          return !1;
        }
        function HM(f, c, h, p) {
          return cr(f, h, p) !== cr(c, h, p) && cr(f, c, h) !== cr(f, c, p);
        }
        function qy(f, c, h) {
          const p = h * h;
          if (c.length === 1) return f.distSqr(c[0]) < p;
          for (let y = 1; y < c.length; y++) if (ax(f, c[y - 1], c[y]) < p) return !0;
          return !1;
        }
        function ax(f, c, h) {
          const p = c.distSqr(h);
          if (p === 0) return f.distSqr(c);
          const y = ((f.x - c.x) * (h.x - c.x) + (f.y - c.y) * (h.y - c.y)) / p;
          return f.distSqr(y < 0 ? c : y > 1 ? h : h.sub(c)._mult(y)._add(c));
        }
        function lx(f, c) {
          let h, p, y, x = !1;
          for (let A = 0; A < f.length; A++) {
            h = f[A];
            for (let I = 0, B = h.length - 1; I < h.length; B = I++) p = h[I], y = h[B], p.y > c.y != y.y > c.y && c.x < (y.x - p.x) * (c.y - p.y) / (y.y - p.y) + p.x && (x = !x);
          }
          return x;
        }
        function Vf(f, c) {
          let h = !1;
          for (let p = 0, y = f.length - 1; p < f.length; y = p++) {
            const x = f[p], A = f[y];
            x.y > c.y != A.y > c.y && c.x < (A.x - x.x) * (c.y - x.y) / (A.y - x.y) + x.x && (h = !h);
          }
          return h;
        }
        function WM(f, c, h) {
          const p = h[0], y = h[2];
          if (f.x < p.x && c.x < p.x || f.x > y.x && c.x > y.x || f.y < p.y && c.y < p.y || f.y > y.y && c.y > y.y) return !1;
          const x = cr(f, c, h[0]);
          return x !== cr(f, c, h[1]) || x !== cr(f, c, h[2]) || x !== cr(f, c, h[3]);
        }
        function cp(f, c, h) {
          const p = c.paint.get(f).value;
          return p.kind === "constant" ? p.value : h.programConfigurations.get(c.id).getMaxValue(f);
        }
        function Ug(f) {
          return Math.sqrt(f[0] * f[0] + f[1] * f[1]);
        }
        function zg(f, c, h, p, y) {
          if (!c[0] && !c[1]) return f;
          const x = D.convert(c)._mult(y);
          h === "viewport" && x._rotate(-p);
          const A = [];
          for (let I = 0; I < f.length; I++) A.push(f[I].sub(x));
          return A;
        }
        let cx, ux;
        vr("CircleBucket", jf, { omit: ["layers"] });
        var XM = { get paint() {
          return ux = ux || new rn({ "circle-radius": new Vt(ve.paint_circle["circle-radius"]), "circle-color": new Vt(ve.paint_circle["circle-color"]), "circle-blur": new Vt(ve.paint_circle["circle-blur"]), "circle-opacity": new Vt(ve.paint_circle["circle-opacity"]), "circle-translate": new dt(ve.paint_circle["circle-translate"]), "circle-translate-anchor": new dt(ve.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new dt(ve.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new dt(ve.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Vt(ve.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Vt(ve.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Vt(ve.paint_circle["circle-stroke-opacity"]) });
        }, get layout() {
          return cx = cx || new rn({ "circle-sort-key": new Vt(ve.layout_circle["circle-sort-key"]) });
        } };
        class ZM extends on {
          constructor(c) {
            super(c, XM);
          }
          createBucket(c) {
            return new jf(c);
          }
          queryRadius(c) {
            const h = c;
            return cp("circle-radius", this, h) + cp("circle-stroke-width", this, h) + Ug(this.paint.get("circle-translate"));
          }
          queryIntersectsFeature(c) {
            let { queryGeometry: h, feature: p, featureState: y, geometry: x, transform: A, pixelsToTileUnits: I, pixelPosMatrix: B } = c;
            const N = zg(h, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -A.bearingInRadians, I), z = this.paint.get("circle-radius").evaluate(p, y) + this.paint.get("circle-stroke-width").evaluate(p, y), j = this.paint.get("circle-pitch-alignment") === "map", K = j ? N : function(te, le) {
              return te.map((Ae) => hx(Ae, le));
            }(N, B), ee = j ? z * I : z;
            for (const te of x) for (const le of te) {
              const Ae = j ? le : hx(le, B);
              let Te = ee;
              const Qe = _e([], [le.x, le.y, 0, 1], B);
              if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Te *= Qe[3] / A.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Te *= A.cameraToCenterDistance / Qe[3]), op(K, Ae, Te)) return !0;
            }
            return !1;
          }
        }
        function hx(f, c) {
          const h = _e([], [f.x, f.y, 0, 1], c);
          return new D(h[0] / h[3], h[1] / h[3]);
        }
        class fx extends jf {
        }
        let dx;
        vr("HeatmapBucket", fx, { omit: ["layers"] });
        var YM = { get paint() {
          return dx = dx || new rn({ "heatmap-radius": new Vt(ve.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Vt(ve.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new dt(ve.paint_heatmap["heatmap-intensity"]), "heatmap-color": new xr(ve.paint_heatmap["heatmap-color"]), "heatmap-opacity": new dt(ve.paint_heatmap["heatmap-opacity"]) });
        } };
        function Gy(f, c, h, p) {
          let { width: y, height: x } = c;
          if (p) {
            if (p instanceof Uint8ClampedArray) p = new Uint8Array(p.buffer);
            else if (p.length !== y * x * h) throw new RangeError(`mismatched image size. expected: ${p.length} but got: ${y * x * h}`);
          } else p = new Uint8Array(y * x * h);
          return f.width = y, f.height = x, f.data = p, f;
        }
        function px(f, c, h) {
          let { width: p, height: y } = c;
          if (p === f.width && y === f.height) return;
          const x = Gy({}, { width: p, height: y }, h);
          $y(f, x, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(f.width, p), height: Math.min(f.height, y) }, h), f.width = p, f.height = y, f.data = x.data;
        }
        function $y(f, c, h, p, y, x) {
          if (y.width === 0 || y.height === 0) return c;
          if (y.width > f.width || y.height > f.height || h.x > f.width - y.width || h.y > f.height - y.height) throw new RangeError("out of range source coordinates for image copy");
          if (y.width > c.width || y.height > c.height || p.x > c.width - y.width || p.y > c.height - y.height) throw new RangeError("out of range destination coordinates for image copy");
          const A = f.data, I = c.data;
          if (A === I) throw new Error("srcData equals dstData, so image is already copied");
          for (let B = 0; B < y.height; B++) {
            const N = ((h.y + B) * f.width + h.x) * x, z = ((p.y + B) * c.width + p.x) * x;
            for (let j = 0; j < y.width * x; j++) I[z + j] = A[N + j];
          }
          return c;
        }
        class up {
          constructor(c, h) {
            Gy(this, c, 1, h);
          }
          resize(c) {
            px(this, c, 1);
          }
          clone() {
            return new up({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(c, h, p, y, x) {
            $y(c, h, p, y, x, 1);
          }
        }
        class Va {
          constructor(c, h) {
            Gy(this, c, 4, h);
          }
          resize(c) {
            px(this, c, 4);
          }
          replace(c, h) {
            h ? this.data.set(c) : this.data = c instanceof Uint8ClampedArray ? new Uint8Array(c.buffer) : c;
          }
          clone() {
            return new Va({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }
          static copy(c, h, p, y, x) {
            $y(c, h, p, y, x, 4);
          }
        }
        function gx(f) {
          const c = {}, h = f.resolution || 256, p = f.clips ? f.clips.length : 1, y = f.image || new Va({ width: h, height: p });
          if (Math.log(h) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${h}`);
          const x = (A, I, B) => {
            c[f.evaluationKey] = B;
            const N = f.expression.evaluate(c);
            y.data[A + I + 0] = Math.floor(255 * N.r / N.a), y.data[A + I + 1] = Math.floor(255 * N.g / N.a), y.data[A + I + 2] = Math.floor(255 * N.b / N.a), y.data[A + I + 3] = Math.floor(255 * N.a);
          };
          if (f.clips) for (let A = 0, I = 0; A < p; ++A, I += 4 * h) for (let B = 0, N = 0; B < h; B++, N += 4) {
            const z = B / (h - 1), { start: j, end: K } = f.clips[A];
            x(I, N, j * (1 - z) + K * z);
          }
          else for (let A = 0, I = 0; A < h; A++, I += 4) x(0, I, A / (h - 1));
          return y;
        }
        vr("AlphaImage", up), vr("RGBAImage", Va);
        const Hy = "big-fb";
        class KM extends on {
          createBucket(c) {
            return new fx(c);
          }
          constructor(c) {
            super(c, YM), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
          }
          _handleSpecialPaintPropertyUpdate(c) {
            c === "heatmap-color" && this._updateColorRamp();
          }
          _updateColorRamp() {
            this.colorRamp = gx({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
          }
          resize() {
            this.heatmapFbos.has(Hy) && this.heatmapFbos.delete(Hy);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            return !1;
          }
          hasOffscreenPass() {
            return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
          }
        }
        let mx;
        var JM = { get paint() {
          return mx = mx || new rn({ "hillshade-illumination-direction": new dt(ve.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new dt(ve.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new dt(ve.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new dt(ve.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new dt(ve.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new dt(ve.paint_hillshade["hillshade-accent-color"]) });
        } };
        class QM extends on {
          constructor(c) {
            super(c, JM);
          }
          hasOffscreenPass() {
            return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
          }
        }
        const eP = Br([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: tP } = eP;
        function Wy(f, c, h) {
          const p = h.patternDependencies;
          let y = !1;
          for (const x of c) {
            const A = x.paint.get(`${f}-pattern`);
            A.isConstant() || (y = !0);
            const I = A.constantOr(null);
            I && (y = !0, p[I.to] = !0, p[I.from] = !0);
          }
          return y;
        }
        function Xy(f, c, h, p, y) {
          const x = y.patternDependencies;
          for (const A of c) {
            const I = A.paint.get(`${f}-pattern`).value;
            if (I.kind !== "constant") {
              let B = I.evaluate({ zoom: p - 1 }, h, {}, y.availableImages), N = I.evaluate({ zoom: p }, h, {}, y.availableImages), z = I.evaluate({ zoom: p + 1 }, h, {}, y.availableImages);
              B = B && B.name ? B.name : B, N = N && N.name ? N.name : N, z = z && z.name ? z.name : z, x[B] = !0, x[N] = !0, x[z] = !0, h.patterns[A.id] = { min: B, mid: N, max: z };
            }
          }
          return h;
        }
        function _x(f, c, h, p, y) {
          let x;
          if (y === function(A, I, B, N) {
            let z = 0;
            for (let j = I, K = B - N; j < B; j += N) z += (A[K] - A[j]) * (A[j + 1] + A[K + 1]), K = j;
            return z;
          }(f, c, h, p) > 0) for (let A = c; A < h; A += p) x = xx(A / p | 0, f[A], f[A + 1], x);
          else for (let A = h - p; A >= c; A -= p) x = xx(A / p | 0, f[A], f[A + 1], x);
          return x && qf(x, x.next) && (pp(x), x = x.next), x;
        }
        function Hh(f, c) {
          if (!f) return f;
          c || (c = f);
          let h, p = f;
          do
            if (h = !1, p.steiner || !qf(p, p.next) && Hi(p.prev, p, p.next) !== 0) p = p.next;
            else {
              if (pp(p), p = c = p.prev, p === p.next) break;
              h = !0;
            }
          while (h || p !== c);
          return c;
        }
        function hp(f, c, h, p, y, x, A) {
          if (!f) return;
          !A && x && function(B, N, z, j) {
            let K = B;
            do
              K.z === 0 && (K.z = Zy(K.x, K.y, N, z, j)), K.prevZ = K.prev, K.nextZ = K.next, K = K.next;
            while (K !== B);
            K.prevZ.nextZ = null, K.prevZ = null, function(ee) {
              let te, le = 1;
              do {
                let Ae, Te = ee;
                ee = null;
                let Qe = null;
                for (te = 0; Te; ) {
                  te++;
                  let ke = Te, Q = 0;
                  for (let ze = 0; ze < le && (Q++, ke = ke.nextZ, ke); ze++) ;
                  let xe = le;
                  for (; Q > 0 || xe > 0 && ke; ) Q !== 0 && (xe === 0 || !ke || Te.z <= ke.z) ? (Ae = Te, Te = Te.nextZ, Q--) : (Ae = ke, ke = ke.nextZ, xe--), Qe ? Qe.nextZ = Ae : ee = Ae, Ae.prevZ = Qe, Qe = Ae;
                  Te = ke;
                }
                Qe.nextZ = null, le *= 2;
              } while (te > 1);
            }(K);
          }(f, p, y, x);
          let I = f;
          for (; f.prev !== f.next; ) {
            const B = f.prev, N = f.next;
            if (x ? nP(f, p, y, x) : rP(f)) c.push(B.i, f.i, N.i), pp(f), f = N.next, I = N.next;
            else if ((f = N) === I) {
              A ? A === 1 ? hp(f = iP(Hh(f), c), c, h, p, y, x, 2) : A === 2 && sP(f, c, h, p, y, x) : hp(Hh(f), c, h, p, y, x, 1);
              break;
            }
          }
        }
        function rP(f) {
          const c = f.prev, h = f, p = f.next;
          if (Hi(c, h, p) >= 0) return !1;
          const y = c.x, x = h.x, A = p.x, I = c.y, B = h.y, N = p.y, z = Math.min(y, x, A), j = Math.min(I, B, N), K = Math.max(y, x, A), ee = Math.max(I, B, N);
          let te = p.next;
          for (; te !== c; ) {
            if (te.x >= z && te.x <= K && te.y >= j && te.y <= ee && fp(y, I, x, B, A, N, te.x, te.y) && Hi(te.prev, te, te.next) >= 0) return !1;
            te = te.next;
          }
          return !0;
        }
        function nP(f, c, h, p) {
          const y = f.prev, x = f, A = f.next;
          if (Hi(y, x, A) >= 0) return !1;
          const I = y.x, B = x.x, N = A.x, z = y.y, j = x.y, K = A.y, ee = Math.min(I, B, N), te = Math.min(z, j, K), le = Math.max(I, B, N), Ae = Math.max(z, j, K), Te = Zy(ee, te, c, h, p), Qe = Zy(le, Ae, c, h, p);
          let ke = f.prevZ, Q = f.nextZ;
          for (; ke && ke.z >= Te && Q && Q.z <= Qe; ) {
            if (ke.x >= ee && ke.x <= le && ke.y >= te && ke.y <= Ae && ke !== y && ke !== A && fp(I, z, B, j, N, K, ke.x, ke.y) && Hi(ke.prev, ke, ke.next) >= 0 || (ke = ke.prevZ, Q.x >= ee && Q.x <= le && Q.y >= te && Q.y <= Ae && Q !== y && Q !== A && fp(I, z, B, j, N, K, Q.x, Q.y) && Hi(Q.prev, Q, Q.next) >= 0)) return !1;
            Q = Q.nextZ;
          }
          for (; ke && ke.z >= Te; ) {
            if (ke.x >= ee && ke.x <= le && ke.y >= te && ke.y <= Ae && ke !== y && ke !== A && fp(I, z, B, j, N, K, ke.x, ke.y) && Hi(ke.prev, ke, ke.next) >= 0) return !1;
            ke = ke.prevZ;
          }
          for (; Q && Q.z <= Qe; ) {
            if (Q.x >= ee && Q.x <= le && Q.y >= te && Q.y <= Ae && Q !== y && Q !== A && fp(I, z, B, j, N, K, Q.x, Q.y) && Hi(Q.prev, Q, Q.next) >= 0) return !1;
            Q = Q.nextZ;
          }
          return !0;
        }
        function iP(f, c) {
          let h = f;
          do {
            const p = h.prev, y = h.next.next;
            !qf(p, y) && bx(p, h, h.next, y) && dp(p, y) && dp(y, p) && (c.push(p.i, h.i, y.i), pp(h), pp(h.next), h = f = y), h = h.next;
          } while (h !== f);
          return Hh(h);
        }
        function sP(f, c, h, p, y, x) {
          let A = f;
          do {
            let I = A.next.next;
            for (; I !== A.prev; ) {
              if (A.i !== I.i && uP(A, I)) {
                let B = vx(A, I);
                return A = Hh(A, A.next), B = Hh(B, B.next), hp(A, c, h, p, y, x, 0), void hp(B, c, h, p, y, x, 0);
              }
              I = I.next;
            }
            A = A.next;
          } while (A !== f);
        }
        function oP(f, c) {
          let h = f.x - c.x;
          return h === 0 && (h = f.y - c.y, h === 0) && (h = (f.next.y - f.y) / (f.next.x - f.x) - (c.next.y - c.y) / (c.next.x - c.x)), h;
        }
        function aP(f, c) {
          const h = function(y, x) {
            let A = x;
            const I = y.x, B = y.y;
            let N, z = -1 / 0;
            if (qf(y, A)) return A;
            do {
              if (qf(y, A.next)) return A.next;
              if (B <= A.y && B >= A.next.y && A.next.y !== A.y) {
                const le = A.x + (B - A.y) * (A.next.x - A.x) / (A.next.y - A.y);
                if (le <= I && le > z && (z = le, N = A.x < A.next.x ? A : A.next, le === I)) return N;
              }
              A = A.next;
            } while (A !== x);
            if (!N) return null;
            const j = N, K = N.x, ee = N.y;
            let te = 1 / 0;
            A = N;
            do {
              if (I >= A.x && A.x >= K && I !== A.x && yx(B < ee ? I : z, B, K, ee, B < ee ? z : I, B, A.x, A.y)) {
                const le = Math.abs(B - A.y) / (I - A.x);
                dp(A, y) && (le < te || le === te && (A.x > N.x || A.x === N.x && lP(N, A))) && (N = A, te = le);
              }
              A = A.next;
            } while (A !== j);
            return N;
          }(f, c);
          if (!h) return c;
          const p = vx(h, f);
          return Hh(p, p.next), Hh(h, h.next);
        }
        function lP(f, c) {
          return Hi(f.prev, f, c.prev) < 0 && Hi(c.next, f, f.next) < 0;
        }
        function Zy(f, c, h, p, y) {
          return (f = 1431655765 & ((f = 858993459 & ((f = 252645135 & ((f = 16711935 & ((f = (f - h) * y | 0) | f << 8)) | f << 4)) | f << 2)) | f << 1)) | (c = 1431655765 & ((c = 858993459 & ((c = 252645135 & ((c = 16711935 & ((c = (c - p) * y | 0) | c << 8)) | c << 4)) | c << 2)) | c << 1)) << 1;
        }
        function cP(f) {
          let c = f, h = f;
          do
            (c.x < h.x || c.x === h.x && c.y < h.y) && (h = c), c = c.next;
          while (c !== f);
          return h;
        }
        function yx(f, c, h, p, y, x, A, I) {
          return (y - A) * (c - I) >= (f - A) * (x - I) && (f - A) * (p - I) >= (h - A) * (c - I) && (h - A) * (x - I) >= (y - A) * (p - I);
        }
        function fp(f, c, h, p, y, x, A, I) {
          return !(f === A && c === I) && yx(f, c, h, p, y, x, A, I);
        }
        function uP(f, c) {
          return f.next.i !== c.i && f.prev.i !== c.i && !function(h, p) {
            let y = h;
            do {
              if (y.i !== h.i && y.next.i !== h.i && y.i !== p.i && y.next.i !== p.i && bx(y, y.next, h, p)) return !0;
              y = y.next;
            } while (y !== h);
            return !1;
          }(f, c) && (dp(f, c) && dp(c, f) && function(h, p) {
            let y = h, x = !1;
            const A = (h.x + p.x) / 2, I = (h.y + p.y) / 2;
            do
              y.y > I != y.next.y > I && y.next.y !== y.y && A < (y.next.x - y.x) * (I - y.y) / (y.next.y - y.y) + y.x && (x = !x), y = y.next;
            while (y !== h);
            return x;
          }(f, c) && (Hi(f.prev, f, c.prev) || Hi(f, c.prev, c)) || qf(f, c) && Hi(f.prev, f, f.next) > 0 && Hi(c.prev, c, c.next) > 0);
        }
        function Hi(f, c, h) {
          return (c.y - f.y) * (h.x - c.x) - (c.x - f.x) * (h.y - c.y);
        }
        function qf(f, c) {
          return f.x === c.x && f.y === c.y;
        }
        function bx(f, c, h, p) {
          const y = Vg(Hi(f, c, h)), x = Vg(Hi(f, c, p)), A = Vg(Hi(h, p, f)), I = Vg(Hi(h, p, c));
          return y !== x && A !== I || !(y !== 0 || !jg(f, h, c)) || !(x !== 0 || !jg(f, p, c)) || !(A !== 0 || !jg(h, f, p)) || !(I !== 0 || !jg(h, c, p));
        }
        function jg(f, c, h) {
          return c.x <= Math.max(f.x, h.x) && c.x >= Math.min(f.x, h.x) && c.y <= Math.max(f.y, h.y) && c.y >= Math.min(f.y, h.y);
        }
        function Vg(f) {
          return f > 0 ? 1 : f < 0 ? -1 : 0;
        }
        function dp(f, c) {
          return Hi(f.prev, f, f.next) < 0 ? Hi(f, c, f.next) >= 0 && Hi(f, f.prev, c) >= 0 : Hi(f, c, f.prev) < 0 || Hi(f, f.next, c) < 0;
        }
        function vx(f, c) {
          const h = Yy(f.i, f.x, f.y), p = Yy(c.i, c.x, c.y), y = f.next, x = c.prev;
          return f.next = c, c.prev = f, h.next = y, y.prev = h, p.next = h, h.prev = p, x.next = p, p.prev = x, p;
        }
        function xx(f, c, h, p) {
          const y = Yy(f, c, h);
          return p ? (y.next = p.next, y.prev = p, p.next.prev = y, p.next = y) : (y.prev = y, y.next = y), y;
        }
        function pp(f) {
          f.next.prev = f.prev, f.prev.next = f.next, f.prevZ && (f.prevZ.nextZ = f.nextZ), f.nextZ && (f.nextZ.prevZ = f.prevZ);
        }
        function Yy(f, c, h) {
          return { i: f, x: c, y: h, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
        }
        class Gf {
          constructor(c, h) {
            if (h > c) throw new Error("Min granularity must not be greater than base granularity.");
            this._baseZoomGranularity = c, this._minGranularity = h;
          }
          getGranularityForZoomLevel(c) {
            return Math.max(Math.floor(this._baseZoomGranularity / (1 << c)), this._minGranularity, 1);
          }
        }
        class qg {
          constructor(c) {
            this.fill = c.fill, this.line = c.line, this.tile = c.tile, this.stencil = c.stencil, this.circle = c.circle;
          }
        }
        qg.noSubdivision = new qg({ fill: new Gf(0, 0), line: new Gf(0, 0), tile: new Gf(0, 0), stencil: new Gf(0, 0), circle: 1 }), vr("SubdivisionGranularityExpression", Gf), vr("SubdivisionGranularitySetting", qg);
        const $f = -32768, gp = 32767;
        class hP {
          constructor(c, h) {
            this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = c, this._granularityCellSize = ht / c, this._canonical = h;
          }
          _getKey(c, h) {
            return (c += 32768) << 16 | (h += 32768) << 0;
          }
          _vertexToIndex(c, h) {
            if (c < -32768 || h < -32768 || c > 32767 || h > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
            const p = 0 | Math.round(c), y = 0 | Math.round(h), x = this._getKey(p, y);
            if (this._vertexDictionary.has(x)) return this._vertexDictionary.get(x);
            const A = this._vertexBuffer.length / 2;
            return this._vertexDictionary.set(x, A), this._vertexBuffer.push(p, y), A;
          }
          _subdivideTrianglesScanline(c) {
            if (this._granularity < 2) return function(y, x) {
              const A = [];
              for (let I = 0; I < x.length; I += 3) {
                const B = x[I], N = x[I + 1], z = x[I + 2], j = y[2 * B], K = y[2 * B + 1];
                (y[2 * N] - j) * (y[2 * z + 1] - K) - (y[2 * N + 1] - K) * (y[2 * z] - j) > 0 ? (A.push(B), A.push(z), A.push(N)) : (A.push(B), A.push(N), A.push(z));
              }
              return A;
            }(this._vertexBuffer, c);
            const h = [], p = c.length;
            for (let y = 0; y < p; y += 3) {
              const x = [c[y + 0], c[y + 1], c[y + 2]], A = [this._vertexBuffer[2 * c[y + 0] + 0], this._vertexBuffer[2 * c[y + 0] + 1], this._vertexBuffer[2 * c[y + 1] + 0], this._vertexBuffer[2 * c[y + 1] + 1], this._vertexBuffer[2 * c[y + 2] + 0], this._vertexBuffer[2 * c[y + 2] + 1]];
              let I = 1 / 0, B = 1 / 0, N = -1 / 0, z = -1 / 0;
              for (let le = 0; le < 3; le++) {
                const Ae = A[2 * le], Te = A[2 * le + 1];
                I = Math.min(I, Ae), N = Math.max(N, Ae), B = Math.min(B, Te), z = Math.max(z, Te);
              }
              if (I === N || B === z) continue;
              const j = Math.floor(I / this._granularityCellSize), K = Math.ceil(N / this._granularityCellSize), ee = Math.floor(B / this._granularityCellSize), te = Math.ceil(z / this._granularityCellSize);
              if (j !== K || ee !== te) for (let le = ee; le < te; le++) {
                const Ae = this._scanlineGenerateVertexRingForCellRow(le, A, x);
                fP(this._vertexBuffer, Ae, h);
              }
              else h.push(...x);
            }
            return h;
          }
          _scanlineGenerateVertexRingForCellRow(c, h, p) {
            const y = c * this._granularityCellSize, x = y + this._granularityCellSize, A = [];
            for (let I = 0; I < 3; I++) {
              const B = h[2 * I], N = h[2 * I + 1], z = h[2 * (I + 1) % 6], j = h[(2 * (I + 1) + 1) % 6], K = h[2 * (I + 2) % 6], ee = h[(2 * (I + 2) + 1) % 6], te = z - B, le = j - N, Ae = te === 0, Te = le === 0, Qe = (y - N) / le, ke = (x - N) / le, Q = Math.min(Qe, ke), xe = Math.max(Qe, ke);
              if (!Te && (Q >= 1 || xe <= 0) || Te && (N < y || N > x)) {
                j >= y && j <= x && A.push(p[(I + 1) % 3]);
                continue;
              }
              !Te && Q > 0 && A.push(this._vertexToIndex(B + te * Q, N + le * Q));
              const ze = B + te * Math.max(Q, 0), yt = B + te * Math.min(xe, 1);
              Ae || this._generateIntraEdgeVertices(A, B, N, z, j, ze, yt), !Te && xe < 1 && A.push(this._vertexToIndex(B + te * xe, N + le * xe)), (Te || j >= y && j <= x) && A.push(p[(I + 1) % 3]), !Te && (j <= y || j >= x) && this._generateInterEdgeVertices(A, B, N, z, j, K, ee, yt, y, x);
            }
            return A;
          }
          _generateIntraEdgeVertices(c, h, p, y, x, A, I) {
            const B = y - h, N = x - p, z = N === 0, j = z ? Math.min(h, y) : Math.min(A, I), K = z ? Math.max(h, y) : Math.max(A, I), ee = Math.floor(j / this._granularityCellSize) + 1, te = Math.ceil(K / this._granularityCellSize) - 1;
            if (z ? h < y : A < I) for (let le = ee; le <= te; le++) {
              const Ae = le * this._granularityCellSize;
              c.push(this._vertexToIndex(Ae, p + N * (Ae - h) / B));
            }
            else for (let le = te; le >= ee; le--) {
              const Ae = le * this._granularityCellSize;
              c.push(this._vertexToIndex(Ae, p + N * (Ae - h) / B));
            }
          }
          _generateInterEdgeVertices(c, h, p, y, x, A, I, B, N, z) {
            const j = x - p, K = A - y, ee = I - x, te = (N - x) / ee, le = (z - x) / ee, Ae = Math.min(te, le), Te = Math.max(te, le), Qe = y + K * Ae;
            let ke = Math.floor(Math.min(Qe, B) / this._granularityCellSize) + 1, Q = Math.ceil(Math.max(Qe, B) / this._granularityCellSize) - 1, xe = B < Qe;
            const ze = ee === 0;
            if (ze && (I === N || I === z)) return;
            if (ze || Ae >= 1 || Te <= 0) {
              const $t = p - I, It = A + (h - A) * Math.min((N - I) / $t, (z - I) / $t);
              ke = Math.floor(Math.min(It, B) / this._granularityCellSize) + 1, Q = Math.ceil(Math.max(It, B) / this._granularityCellSize) - 1, xe = B < It;
            }
            const yt = j > 0 ? z : N;
            if (xe) for (let $t = ke; $t <= Q; $t++) c.push(this._vertexToIndex($t * this._granularityCellSize, yt));
            else for (let $t = Q; $t >= ke; $t--) c.push(this._vertexToIndex($t * this._granularityCellSize, yt));
          }
          _generateOutline(c) {
            const h = [];
            for (const p of c) {
              const y = Wh(p, this._granularity, !0), x = this._pointArrayToIndices(y), A = [];
              for (let I = 1; I < x.length; I++) A.push(x[I - 1]), A.push(x[I]);
              h.push(A);
            }
            return h;
          }
          _handlePoles(c) {
            let h = !1, p = !1;
            this._canonical && (this._canonical.y === 0 && (h = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (p = !0)), (h || p) && this._fillPoles(c, h, p);
          }
          _ensureNoPoleVertices() {
            const c = this._vertexBuffer;
            for (let h = 0; h < c.length; h += 2) {
              const p = c[h + 1];
              p === $f && (c[h + 1] = -32767), p === gp && (c[h + 1] = 32766);
            }
          }
          _generatePoleQuad(c, h, p, y, x, A) {
            y > x != (A === $f) ? (c.push(h), c.push(p), c.push(this._vertexToIndex(y, A)), c.push(p), c.push(this._vertexToIndex(x, A)), c.push(this._vertexToIndex(y, A))) : (c.push(p), c.push(h), c.push(this._vertexToIndex(y, A)), c.push(this._vertexToIndex(x, A)), c.push(p), c.push(this._vertexToIndex(y, A)));
          }
          _fillPoles(c, h, p) {
            const y = this._vertexBuffer, x = ht, A = c.length;
            for (let I = 2; I < A; I += 3) {
              const B = c[I - 2], N = c[I - 1], z = c[I], j = y[2 * B], K = y[2 * B + 1], ee = y[2 * N], te = y[2 * N + 1], le = y[2 * z], Ae = y[2 * z + 1];
              h && (K === 0 && te === 0 && this._generatePoleQuad(c, B, N, j, ee, $f), te === 0 && Ae === 0 && this._generatePoleQuad(c, N, z, ee, le, $f), Ae === 0 && K === 0 && this._generatePoleQuad(c, z, B, le, j, $f)), p && (K === x && te === x && this._generatePoleQuad(c, B, N, j, ee, gp), te === x && Ae === x && this._generatePoleQuad(c, N, z, ee, le, gp), Ae === x && K === x && this._generatePoleQuad(c, z, B, le, j, gp));
            }
          }
          _initializeVertices(c) {
            for (let h = 0; h < c.length; h += 2) this._vertexToIndex(c[h], c[h + 1]);
          }
          subdividePolygonInternal(c, h) {
            if (this._used) throw new Error("Subdivision: multiple use not allowed.");
            this._used = !0;
            const { flattened: p, holeIndices: y } = function(I) {
              const B = [], N = [];
              for (const z of I) if (z.length !== 0) {
                z !== I[0] && B.push(N.length / 2);
                for (let j = 0; j < z.length; j++) N.push(z[j].x), N.push(z[j].y);
              }
              return { flattened: N, holeIndices: B };
            }(c);
            let x;
            this._initializeVertices(p);
            try {
              const I = function(N, z) {
                let j = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;
                const K = z && z.length, ee = K ? z[0] * j : N.length;
                let te = _x(N, 0, ee, j, !0);
                const le = [];
                if (!te || te.next === te.prev) return le;
                let Ae, Te, Qe;
                if (K && (te = function(ke, Q, xe, ze) {
                  const yt = [];
                  for (let $t = 0, It = Q.length; $t < It; $t++) {
                    const Lt = _x(ke, Q[$t] * ze, $t < It - 1 ? Q[$t + 1] * ze : ke.length, ze, !1);
                    Lt === Lt.next && (Lt.steiner = !0), yt.push(cP(Lt));
                  }
                  yt.sort(oP);
                  for (let $t = 0; $t < yt.length; $t++) xe = aP(yt[$t], xe);
                  return xe;
                }(N, z, te, j)), N.length > 80 * j) {
                  Ae = 1 / 0, Te = 1 / 0;
                  let ke = -1 / 0, Q = -1 / 0;
                  for (let xe = j; xe < ee; xe += j) {
                    const ze = N[xe], yt = N[xe + 1];
                    ze < Ae && (Ae = ze), yt < Te && (Te = yt), ze > ke && (ke = ze), yt > Q && (Q = yt);
                  }
                  Qe = Math.max(ke - Ae, Q - Te), Qe = Qe !== 0 ? 32767 / Qe : 0;
                }
                return hp(te, le, j, Ae, Te, Qe, 0), le;
              }(p, y), B = this._convertIndices(p, I);
              x = this._subdivideTrianglesScanline(B);
            } catch (I) {
              console.error(I);
            }
            let A = [];
            return h && (A = this._generateOutline(c)), this._ensureNoPoleVertices(), this._handlePoles(x), { verticesFlattened: this._vertexBuffer, indicesTriangles: x, indicesLineList: A };
          }
          _convertIndices(c, h) {
            const p = [];
            for (let y = 0; y < h.length; y++) p.push(this._vertexToIndex(c[2 * h[y]], c[2 * h[y] + 1]));
            return p;
          }
          _pointArrayToIndices(c) {
            const h = [];
            for (let p = 0; p < c.length; p++) {
              const y = c[p];
              h.push(this._vertexToIndex(y.x, y.y));
            }
            return h;
          }
        }
        function wx(f, c, h) {
          let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
          return new hP(h, c).subdividePolygonInternal(f, p);
        }
        function Wh(f, c) {
          let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
          if (!f || f.length < 1) return [];
          if (f.length < 2) return [];
          const p = f[0], y = f[f.length - 1], x = h && (p.x !== y.x || p.y !== y.y);
          if (c < 2) return x ? [...f, f[0]] : [...f];
          const A = Math.floor(ht / c), I = [];
          I.push(new D(f[0].x, f[0].y));
          const B = f.length, N = x ? B : B - 1;
          for (let z = 0; z < N; z++) {
            const j = f[z], K = z < B - 1 ? f[z + 1] : f[0], ee = j.x, te = j.y, le = K.x, Ae = K.y, Te = ee !== le, Qe = te !== Ae;
            if (!Te && !Qe) continue;
            const ke = le - ee, Q = Ae - te, xe = Math.abs(ke), ze = Math.abs(Q);
            let yt = ee, $t = te;
            for (; ; ) {
              const Lt = ke > 0 ? (Math.floor(yt / A) + 1) * A : (Math.ceil(yt / A) - 1) * A, er = Q > 0 ? (Math.floor($t / A) + 1) * A : (Math.ceil($t / A) - 1) * A, Xt = Math.abs(yt - Lt), ir = Math.abs($t - er), Dt = Math.abs(yt - le), Er = Math.abs($t - Ae), Fr = Te ? Xt / xe : Number.POSITIVE_INFINITY, Nr = Qe ? ir / ze : Number.POSITIVE_INFINITY;
              if ((Dt <= Xt || !Te) && (Er <= ir || !Qe)) break;
              if (Fr < Nr && Te || !Qe) {
                yt = Lt, $t += Q * Fr;
                const Pr = new D(yt, Math.round($t));
                I[I.length - 1].x === Pr.x && I[I.length - 1].y === Pr.y || I.push(Pr);
              } else {
                yt += ke * Nr, $t = er;
                const Pr = new D(Math.round(yt), $t);
                I[I.length - 1].x === Pr.x && I[I.length - 1].y === Pr.y || I.push(Pr);
              }
            }
            const It = new D(le, Ae);
            I[I.length - 1].x === It.x && I[I.length - 1].y === It.y || I.push(It);
          }
          return I;
        }
        function fP(f, c, h) {
          if (c.length === 0) throw new Error("Subdivision vertex ring is empty.");
          let p = 0, y = f[2 * c[0]];
          for (let B = 1; B < c.length; B++) {
            const N = f[2 * c[B]];
            N < y && (y = N, p = B);
          }
          const x = c.length;
          let A = p, I = (A + 1) % x;
          for (; ; ) {
            const B = A - 1 >= 0 ? A - 1 : x - 1, N = (I + 1) % x, z = f[2 * c[B]], j = f[2 * c[N]], K = f[2 * c[A]], ee = f[2 * c[A] + 1], te = f[2 * c[I] + 1];
            let le = !1;
            if (z < j) le = !0;
            else if (z > j) le = !1;
            else {
              const Ae = te - ee, Te = -(f[2 * c[I]] - K), Qe = ee < te ? 1 : -1;
              ((z - K) * Ae + (f[2 * c[B] + 1] - ee) * Te) * Qe > ((j - K) * Ae + (f[2 * c[N] + 1] - ee) * Te) * Qe && (le = !0);
            }
            if (le) {
              const Ae = c[B], Te = c[A], Qe = c[I];
              Ae !== Te && Ae !== Qe && Te !== Qe && h.push(Qe, Te, Ae), A--, A < 0 && (A = x - 1);
            } else {
              const Ae = c[N], Te = c[A], Qe = c[I];
              Ae !== Te && Ae !== Qe && Te !== Qe && h.push(Qe, Te, Ae), I++, I >= x && (I = 0);
            }
            if (B === N) break;
          }
        }
        function Ax(f, c, h, p, y, x, A, I, B) {
          const N = y.length / 2, z = A && I && B;
          if (N < dr.MAX_VERTEX_ARRAY_LENGTH) {
            const j = c.prepareSegment(N, h, p), K = j.vertexLength;
            for (let le = 0; le < x.length; le += 3) p.emplaceBack(K + x[le], K + x[le + 1], K + x[le + 2]);
            let ee, te;
            j.vertexLength += N, j.primitiveLength += x.length / 3, z && (te = A.prepareSegment(N, h, I), ee = te.vertexLength, te.vertexLength += N);
            for (let le = 0; le < y.length; le += 2) f(y[le], y[le + 1]);
            if (z) for (let le = 0; le < B.length; le++) {
              const Ae = B[le];
              for (let Te = 1; Te < Ae.length; Te += 2) I.emplaceBack(ee + Ae[Te - 1], ee + Ae[Te]);
              te.primitiveLength += Ae.length / 2;
            }
          } else (function(j, K, ee, te, le, Ae) {
            const Te = [];
            for (let ze = 0; ze < te.length / 2; ze++) Te.push(-1);
            const Qe = { count: 0 };
            let ke = 0, Q = j.getOrCreateLatestSegment(K, ee), xe = Q.vertexLength;
            for (let ze = 2; ze < le.length; ze += 3) {
              const yt = le[ze - 2], $t = le[ze - 1], It = le[ze];
              let Lt = Te[yt] < ke, er = Te[$t] < ke, Xt = Te[It] < ke;
              Q.vertexLength + ((Lt ? 1 : 0) + (er ? 1 : 0) + (Xt ? 1 : 0)) > dr.MAX_VERTEX_ARRAY_LENGTH && (Q = j.createNewSegment(K, ee), ke = Qe.count, Lt = !0, er = !0, Xt = !0, xe = 0);
              const ir = mp(Te, te, Ae, Qe, yt, Lt, Q), Dt = mp(Te, te, Ae, Qe, $t, er, Q), Er = mp(Te, te, Ae, Qe, It, Xt, Q);
              ee.emplaceBack(xe + ir - ke, xe + Dt - ke, xe + Er - ke), Q.primitiveLength++;
            }
          })(c, h, p, y, x, f), z && function(j, K, ee, te, le, Ae) {
            const Te = [];
            for (let ze = 0; ze < te.length / 2; ze++) Te.push(-1);
            const Qe = { count: 0 };
            let ke = 0, Q = j.getOrCreateLatestSegment(K, ee), xe = Q.vertexLength;
            for (let ze = 0; ze < le.length; ze++) {
              const yt = le[ze];
              for (let $t = 1; $t < le[ze].length; $t += 2) {
                const It = yt[$t - 1], Lt = yt[$t];
                let er = Te[It] < ke, Xt = Te[Lt] < ke;
                Q.vertexLength + ((er ? 1 : 0) + (Xt ? 1 : 0)) > dr.MAX_VERTEX_ARRAY_LENGTH && (Q = j.createNewSegment(K, ee), ke = Qe.count, er = !0, Xt = !0, xe = 0);
                const ir = mp(Te, te, Ae, Qe, It, er, Q), Dt = mp(Te, te, Ae, Qe, Lt, Xt, Q);
                ee.emplaceBack(xe + ir - ke, xe + Dt - ke), Q.primitiveLength++;
              }
            }
          }(A, h, I, y, B, f), c.forceNewSegmentOnNextPrepare(), A == null || A.forceNewSegmentOnNextPrepare();
        }
        function mp(f, c, h, p, y, x, A) {
          if (x) {
            const I = p.count;
            return h(c[2 * y], c[2 * y + 1]), f[y] = p.count, p.count++, A.vertexLength++, I;
          }
          return f[y];
        }
        class Ky {
          constructor(c) {
            this.zoom = c.zoom, this.overscaling = c.overscaling, this.layers = c.layers, this.layerIds = this.layers.map((h) => h.id), this.index = c.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Le(), this.indexArray = new Mt(), this.indexArray2 = new sr(), this.programConfigurations = new Ci(c.layers, c.zoom), this.segments = new dr(), this.segments2 = new dr(), this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
          }
          populate(c, h, p) {
            this.hasPattern = Wy("fill", this.layers, h);
            const y = this.layers[0].layout.get("fill-sort-key"), x = !y.isConstant(), A = [];
            for (const { feature: I, id: B, index: N, sourceLayerIndex: z } of c) {
              const j = this.layers[0]._featureFilter.needGeometry, K = Pu(I, j);
              if (!this.layers[0]._featureFilter.filter(new ot(this.zoom), K, p)) continue;
              const ee = x ? y.evaluate(K, {}, p, h.availableImages) : void 0, te = { id: B, properties: I.properties, type: I.type, sourceLayerIndex: z, index: N, geometry: j ? K.geometry : Mu(I), patterns: {}, sortKey: ee };
              A.push(te);
            }
            x && A.sort((I, B) => I.sortKey - B.sortKey);
            for (const I of A) {
              const { geometry: B, index: N, sourceLayerIndex: z } = I;
              if (this.hasPattern) {
                const j = Xy("fill", this.layers, I, this.zoom, h);
                this.patternFeatures.push(j);
              } else this.addFeature(I, B, N, p, {}, h.subdivisionGranularity);
              h.featureIndex.insert(c[N].feature, B, N, z, this.index);
            }
          }
          update(c, h, p) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(c, h, this.stateDependentLayers, p);
          }
          addFeatures(c, h, p) {
            for (const y of this.patternFeatures) this.addFeature(y, y.geometry, y.index, h, p, c.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(c) {
            this.uploaded || (this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, tP), this.indexBuffer = c.createIndexBuffer(this.indexArray), this.indexBuffer2 = c.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(c), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }
          addFeature(c, h, p, y, x, A) {
            for (const I of Us(h, 500)) {
              const B = wx(I, y, A.fill.getGranularityForZoomLevel(y.z)), N = this.layoutVertexArray;
              Ax((z, j) => {
                N.emplaceBack(z, j);
              }, this.segments, this.layoutVertexArray, this.indexArray, B.verticesFlattened, B.indicesTriangles, this.segments2, this.indexArray2, B.indicesLineList);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, c, p, x, y);
          }
        }
        let Tx, Sx;
        vr("FillBucket", Ky, { omit: ["layers", "patternFeatures"] });
        var dP = { get paint() {
          return Sx = Sx || new rn({ "fill-antialias": new dt(ve.paint_fill["fill-antialias"]), "fill-opacity": new Vt(ve.paint_fill["fill-opacity"]), "fill-color": new Vt(ve.paint_fill["fill-color"]), "fill-outline-color": new Vt(ve.paint_fill["fill-outline-color"]), "fill-translate": new dt(ve.paint_fill["fill-translate"]), "fill-translate-anchor": new dt(ve.paint_fill["fill-translate-anchor"]), "fill-pattern": new yr(ve.paint_fill["fill-pattern"]) });
        }, get layout() {
          return Tx = Tx || new rn({ "fill-sort-key": new Vt(ve.layout_fill["fill-sort-key"]) });
        } };
        class pP extends on {
          constructor(c) {
            super(c, dP);
          }
          recalculate(c, h) {
            super.recalculate(c, h);
            const p = this.paint._values["fill-outline-color"];
            p.value.kind === "constant" && p.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
          }
          createBucket(c) {
            return new Ky(c);
          }
          queryRadius() {
            return Ug(this.paint.get("fill-translate"));
          }
          queryIntersectsFeature(c) {
            let { queryGeometry: h, geometry: p, transform: y, pixelsToTileUnits: x } = c;
            return ap(zg(h, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -y.bearingInRadians, x), p);
          }
          isTileClipped() {
            return !0;
          }
        }
        const gP = Br([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), mP = Br([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: _P } = gP;
        var Jy, Ex, Qy, Cx, e0, Ix, Mx, Gg = {};
        function Px() {
          if (Ex) return Jy;
          Ex = 1;
          var f = T();
          function c(y, x, A, I, B) {
            this.properties = {}, this.extent = A, this.type = 0, this._pbf = y, this._geometry = -1, this._keys = I, this._values = B, y.readFields(h, this, x);
          }
          function h(y, x, A) {
            y == 1 ? x.id = A.readVarint() : y == 2 ? function(I, B) {
              for (var N = I.readVarint() + I.pos; I.pos < N; ) {
                var z = B._keys[I.readVarint()], j = B._values[I.readVarint()];
                B.properties[z] = j;
              }
            }(A, x) : y == 3 ? x.type = A.readVarint() : y == 4 && (x._geometry = A.pos);
          }
          function p(y) {
            for (var x, A, I = 0, B = 0, N = y.length, z = N - 1; B < N; z = B++) I += ((A = y[z]).x - (x = y[B]).x) * (x.y + A.y);
            return I;
          }
          return Jy = c, c.types = ["Unknown", "Point", "LineString", "Polygon"], c.prototype.loadGeometry = function() {
            var y = this._pbf;
            y.pos = this._geometry;
            for (var x, A = y.readVarint() + y.pos, I = 1, B = 0, N = 0, z = 0, j = []; y.pos < A; ) {
              if (B <= 0) {
                var K = y.readVarint();
                I = 7 & K, B = K >> 3;
              }
              if (B--, I === 1 || I === 2) N += y.readSVarint(), z += y.readSVarint(), I === 1 && (x && j.push(x), x = []), x.push(new f(N, z));
              else {
                if (I !== 7) throw new Error("unknown command " + I);
                x && x.push(x[0].clone());
              }
            }
            return x && j.push(x), j;
          }, c.prototype.bbox = function() {
            var y = this._pbf;
            y.pos = this._geometry;
            for (var x = y.readVarint() + y.pos, A = 1, I = 0, B = 0, N = 0, z = 1 / 0, j = -1 / 0, K = 1 / 0, ee = -1 / 0; y.pos < x; ) {
              if (I <= 0) {
                var te = y.readVarint();
                A = 7 & te, I = te >> 3;
              }
              if (I--, A === 1 || A === 2) (B += y.readSVarint()) < z && (z = B), B > j && (j = B), (N += y.readSVarint()) < K && (K = N), N > ee && (ee = N);
              else if (A !== 7) throw new Error("unknown command " + A);
            }
            return [z, K, j, ee];
          }, c.prototype.toGeoJSON = function(y, x, A) {
            var I, B, N = this.extent * Math.pow(2, A), z = this.extent * y, j = this.extent * x, K = this.loadGeometry(), ee = c.types[this.type];
            function te(Te) {
              for (var Qe = 0; Qe < Te.length; Qe++) {
                var ke = Te[Qe];
                Te[Qe] = [360 * (ke.x + z) / N - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (ke.y + j) / N) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var le = [];
                for (I = 0; I < K.length; I++) le[I] = K[I][0];
                te(K = le);
                break;
              case 2:
                for (I = 0; I < K.length; I++) te(K[I]);
                break;
              case 3:
                for (K = function(Te) {
                  var Qe = Te.length;
                  if (Qe <= 1) return [Te];
                  for (var ke, Q, xe = [], ze = 0; ze < Qe; ze++) {
                    var yt = p(Te[ze]);
                    yt !== 0 && (Q === void 0 && (Q = yt < 0), Q === yt < 0 ? (ke && xe.push(ke), ke = [Te[ze]]) : ke.push(Te[ze]));
                  }
                  return ke && xe.push(ke), xe;
                }(K), I = 0; I < K.length; I++) for (B = 0; B < K[I].length; B++) te(K[I][B]);
            }
            K.length === 1 ? K = K[0] : ee = "Multi" + ee;
            var Ae = { type: "Feature", geometry: { type: ee, coordinates: K }, properties: this.properties };
            return "id" in this && (Ae.id = this.id), Ae;
          }, Jy;
        }
        function Rx() {
          if (Cx) return Qy;
          Cx = 1;
          var f = Px();
          function c(p, y) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = p, this._keys = [], this._values = [], this._features = [], p.readFields(h, this, y), this.length = this._features.length;
          }
          function h(p, y, x) {
            p === 15 ? y.version = x.readVarint() : p === 1 ? y.name = x.readString() : p === 5 ? y.extent = x.readVarint() : p === 2 ? y._features.push(x.pos) : p === 3 ? y._keys.push(x.readString()) : p === 4 && y._values.push(function(A) {
              for (var I = null, B = A.readVarint() + A.pos; A.pos < B; ) {
                var N = A.readVarint() >> 3;
                I = N === 1 ? A.readString() : N === 2 ? A.readFloat() : N === 3 ? A.readDouble() : N === 4 ? A.readVarint64() : N === 5 ? A.readVarint() : N === 6 ? A.readSVarint() : N === 7 ? A.readBoolean() : null;
              }
              return I;
            }(x));
          }
          return Qy = c, c.prototype.feature = function(p) {
            if (p < 0 || p >= this._features.length) throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[p];
            var y = this._pbf.readVarint() + this._pbf.pos;
            return new f(this._pbf, y, this.extent, this._keys, this._values);
          }, Qy;
        }
        function Bx() {
          return Mx || (Mx = 1, Gg.VectorTile = function() {
            if (Ix) return e0;
            Ix = 1;
            var f = Rx();
            function c(h, p, y) {
              if (h === 3) {
                var x = new f(y, y.readVarint() + y.pos);
                x.length && (p[x.name] = x);
              }
            }
            return e0 = function(h, p) {
              this.layers = h.readFields(c, {}, p);
            }, e0;
          }(), Gg.VectorTileFeature = Px(), Gg.VectorTileLayer = Rx()), Gg;
        }
        var _p = d(Bx());
        const yP = _p.VectorTileFeature.types, t0 = Math.pow(2, 13);
        function yp(f, c, h, p, y, x, A, I) {
          f.emplaceBack(c, h, 2 * Math.floor(p * t0) + A, y * t0 * 2, x * t0 * 2, Math.round(I));
        }
        class r0 {
          constructor(c) {
            this.zoom = c.zoom, this.overscaling = c.overscaling, this.layers = c.layers, this.layerIds = this.layers.map((h) => h.id), this.index = c.index, this.hasPattern = !1, this.layoutVertexArray = new qe(), this.centroidVertexArray = new Se(), this.indexArray = new Mt(), this.programConfigurations = new Ci(c.layers, c.zoom), this.segments = new dr(), this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
          }
          populate(c, h, p) {
            this.features = [], this.hasPattern = Wy("fill-extrusion", this.layers, h);
            for (const { feature: y, id: x, index: A, sourceLayerIndex: I } of c) {
              const B = this.layers[0]._featureFilter.needGeometry, N = Pu(y, B);
              if (!this.layers[0]._featureFilter.filter(new ot(this.zoom), N, p)) continue;
              const z = { id: x, sourceLayerIndex: I, index: A, geometry: B ? N.geometry : Mu(y), properties: y.properties, type: y.type, patterns: {} };
              this.hasPattern ? this.features.push(Xy("fill-extrusion", this.layers, z, this.zoom, h)) : this.addFeature(z, z.geometry, A, p, {}, h.subdivisionGranularity), h.featureIndex.insert(y, z.geometry, A, I, this.index, !0);
            }
          }
          addFeatures(c, h, p) {
            for (const y of this.features) {
              const { geometry: x } = y;
              this.addFeature(y, x, y.index, h, p, c.subdivisionGranularity);
            }
          }
          update(c, h, p) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(c, h, this.stateDependentLayers, p);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(c) {
            this.uploaded || (this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, _P), this.centroidVertexBuffer = c.createVertexBuffer(this.centroidVertexArray, mP.members, !0), this.indexBuffer = c.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(c), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
          }
          addFeature(c, h, p, y, x, A) {
            for (const I of Us(h, 500)) {
              const B = { x: 0, y: 0, sampleCount: 0 }, N = this.layoutVertexArray.length;
              this.processPolygon(B, y, c, I, A);
              const z = this.layoutVertexArray.length - N, j = Math.floor(B.x / B.sampleCount), K = Math.floor(B.y / B.sampleCount);
              for (let ee = 0; ee < z; ee++) this.centroidVertexArray.emplaceBack(j, K);
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, c, p, x, y);
          }
          processPolygon(c, h, p, y, x) {
            if (y.length < 1 || Lx(y[0])) return;
            for (const j of y) j.length !== 0 && bP(c, j);
            const A = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, I = x.fill.getGranularityForZoomLevel(h.z), B = yP[p.type] === "Polygon";
            for (const j of y) {
              if (j.length === 0 || Lx(j)) continue;
              const K = Wh(j, I, B);
              this._generateSideFaces(K, A);
            }
            if (!B) return;
            const N = wx(y, h, I, !1), z = this.layoutVertexArray;
            Ax((j, K) => {
              yp(z, j, K, 0, 0, 1, 1, 0);
            }, this.segments, this.layoutVertexArray, this.indexArray, N.verticesFlattened, N.indicesTriangles);
          }
          _generateSideFaces(c, h) {
            let p = 0;
            for (let y = 1; y < c.length; y++) {
              const x = c[y], A = c[y - 1];
              if (vP(x, A)) continue;
              h.segment.vertexLength + 4 > dr.MAX_VERTEX_ARRAY_LENGTH && (h.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
              const I = x.sub(A)._perp()._unit(), B = A.dist(x);
              p + B > 32768 && (p = 0), yp(this.layoutVertexArray, x.x, x.y, I.x, I.y, 0, 0, p), yp(this.layoutVertexArray, x.x, x.y, I.x, I.y, 0, 1, p), p += B, yp(this.layoutVertexArray, A.x, A.y, I.x, I.y, 0, 0, p), yp(this.layoutVertexArray, A.x, A.y, I.x, I.y, 0, 1, p);
              const N = h.segment.vertexLength;
              this.indexArray.emplaceBack(N, N + 2, N + 1), this.indexArray.emplaceBack(N + 1, N + 2, N + 3), h.segment.vertexLength += 4, h.segment.primitiveLength += 2;
            }
          }
        }
        function bP(f, c) {
          for (let h = 0; h < c.length; h++) {
            const p = c[h];
            h === c.length - 1 && c[0].x === p.x && c[0].y === p.y || (f.x += p.x, f.y += p.y, f.sampleCount++);
          }
        }
        function vP(f, c) {
          return f.x === c.x && (f.x < 0 || f.x > ht) || f.y === c.y && (f.y < 0 || f.y > ht);
        }
        function Lx(f) {
          return f.every((c) => c.x < 0) || f.every((c) => c.x > ht) || f.every((c) => c.y < 0) || f.every((c) => c.y > ht);
        }
        let Ox;
        vr("FillExtrusionBucket", r0, { omit: ["layers", "features"] });
        var xP = { get paint() {
          return Ox = Ox || new rn({ "fill-extrusion-opacity": new dt(ve["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Vt(ve["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new dt(ve["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new dt(ve["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new yr(ve["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Vt(ve["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Vt(ve["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new dt(ve["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
        } };
        class wP extends on {
          constructor(c) {
            super(c, xP);
          }
          createBucket(c) {
            return new r0(c);
          }
          queryRadius() {
            return Ug(this.paint.get("fill-extrusion-translate"));
          }
          is3D() {
            return !0;
          }
          queryIntersectsFeature(c) {
            let { queryGeometry: h, feature: p, featureState: y, geometry: x, transform: A, pixelsToTileUnits: I, pixelPosMatrix: B } = c;
            const N = zg(h, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -A.bearingInRadians, I), z = this.paint.get("fill-extrusion-height").evaluate(p, y), j = this.paint.get("fill-extrusion-base").evaluate(p, y), K = function(te, le, Ae) {
              const Te = [];
              for (const Qe of te) {
                const ke = [Qe.x, Qe.y, 0, 1];
                _e(ke, ke, le), Te.push(new D(ke[0] / ke[3], ke[1] / ke[3]));
              }
              return Te;
            }(N, B), ee = function(te, le, Ae, Te) {
              const Qe = [], ke = [], Q = Te[8] * le, xe = Te[9] * le, ze = Te[10] * le, yt = Te[11] * le, $t = Te[8] * Ae, It = Te[9] * Ae, Lt = Te[10] * Ae, er = Te[11] * Ae;
              for (const Xt of te) {
                const ir = [], Dt = [];
                for (const Er of Xt) {
                  const Fr = Er.x, Nr = Er.y, Pr = Te[0] * Fr + Te[4] * Nr + Te[12], _n = Te[1] * Fr + Te[5] * Nr + Te[13], Di = Te[2] * Fr + Te[6] * Nr + Te[14], rs = Te[3] * Fr + Te[7] * Nr + Te[15], Lo = Di + ze, ia = rs + yt, sa = Pr + $t, $s = _n + It, Vi = Di + Lt, vs = rs + er, Hs = new D((Pr + Q) / ia, (_n + xe) / ia);
                  Hs.z = Lo / ia, ir.push(Hs);
                  const ns = new D(sa / vs, $s / vs);
                  ns.z = Vi / vs, Dt.push(ns);
                }
                Qe.push(ir), ke.push(Dt);
              }
              return [Qe, ke];
            }(x, j, z, B);
            return function(te, le, Ae) {
              let Te = 1 / 0;
              ap(Ae, le) && (Te = Nx(Ae, le[0]));
              for (let Qe = 0; Qe < le.length; Qe++) {
                const ke = le[Qe], Q = te[Qe];
                for (let xe = 0; xe < ke.length - 1; xe++) {
                  const ze = ke[xe], yt = [ze, ke[xe + 1], Q[xe + 1], Q[xe], ze];
                  sp(Ae, yt) && (Te = Math.min(Te, Nx(Ae, yt)));
                }
              }
              return Te !== 1 / 0 && Te;
            }(ee[0], ee[1], K);
          }
        }
        function bp(f, c) {
          return f.x * c.x + f.y * c.y;
        }
        function Nx(f, c) {
          if (f.length === 1) {
            let h = 0;
            const p = c[h++];
            let y;
            for (; !y || p.equals(y); ) if (y = c[h++], !y) return 1 / 0;
            for (; h < c.length; h++) {
              const x = c[h], A = f[0], I = y.sub(p), B = x.sub(p), N = A.sub(p), z = bp(I, I), j = bp(I, B), K = bp(B, B), ee = bp(N, I), te = bp(N, B), le = z * K - j * j, Ae = (K * ee - j * te) / le, Te = (z * te - j * ee) / le, Qe = p.z * (1 - Ae - Te) + y.z * Ae + x.z * Te;
              if (isFinite(Qe)) return Qe;
            }
            return 1 / 0;
          }
          {
            let h = 1 / 0;
            for (const p of c) h = Math.min(h, p.z);
            return h;
          }
        }
        const AP = Br([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: TP } = AP, SP = Br([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: EP } = SP, CP = _p.VectorTileFeature.types, IP = Math.cos(Math.PI / 180 * 37.5), Dx = Math.pow(2, 14) / 0.5;
        class n0 {
          constructor(c) {
            this.zoom = c.zoom, this.overscaling = c.overscaling, this.layers = c.layers, this.layerIds = this.layers.map((h) => h.id), this.index = c.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((h) => {
              this.gradients[h.id] = {};
            }), this.layoutVertexArray = new $e(), this.layoutVertexArray2 = new He(), this.indexArray = new Mt(), this.programConfigurations = new Ci(c.layers, c.zoom), this.segments = new dr(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
          }
          populate(c, h, p) {
            this.hasPattern = Wy("line", this.layers, h);
            const y = this.layers[0].layout.get("line-sort-key"), x = !y.isConstant(), A = [];
            for (const { feature: I, id: B, index: N, sourceLayerIndex: z } of c) {
              const j = this.layers[0]._featureFilter.needGeometry, K = Pu(I, j);
              if (!this.layers[0]._featureFilter.filter(new ot(this.zoom), K, p)) continue;
              const ee = x ? y.evaluate(K, {}, p) : void 0, te = { id: B, properties: I.properties, type: I.type, sourceLayerIndex: z, index: N, geometry: j ? K.geometry : Mu(I), patterns: {}, sortKey: ee };
              A.push(te);
            }
            x && A.sort((I, B) => I.sortKey - B.sortKey);
            for (const I of A) {
              const { geometry: B, index: N, sourceLayerIndex: z } = I;
              if (this.hasPattern) {
                const j = Xy("line", this.layers, I, this.zoom, h);
                this.patternFeatures.push(j);
              } else this.addFeature(I, B, N, p, {}, h.subdivisionGranularity);
              h.featureIndex.insert(c[N].feature, B, N, z, this.index);
            }
          }
          update(c, h, p) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(c, h, this.stateDependentLayers, p);
          }
          addFeatures(c, h, p) {
            for (const y of this.patternFeatures) this.addFeature(y, y.geometry, y.index, h, p, c.subdivisionGranularity);
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0;
          }
          uploadPending() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }
          upload(c) {
            this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = c.createVertexBuffer(this.layoutVertexArray2, EP)), this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, TP), this.indexBuffer = c.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(c), this.uploaded = !0;
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }
          lineFeatureClips(c) {
            if (c.properties && Object.prototype.hasOwnProperty.call(c.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(c.properties, "mapbox_clip_end")) return { start: +c.properties.mapbox_clip_start, end: +c.properties.mapbox_clip_end };
          }
          addFeature(c, h, p, y, x, A) {
            const I = this.layers[0].layout, B = I.get("line-join").evaluate(c, {}), N = I.get("line-cap"), z = I.get("line-miter-limit"), j = I.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(c);
            for (const K of h) this.addLine(K, c, B, N, z, j, y, A);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, c, p, x, y);
          }
          addLine(c, h, p, y, x, A, I, B) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, c = Wh(c, I ? B.line.getGranularityForZoomLevel(I.z) : 1), this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (let ke = 0; ke < c.length - 1; ke++) this.totalDistance += c[ke].dist(c[ke + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            const N = CP[h.type] === "Polygon";
            let z = c.length;
            for (; z >= 2 && c[z - 1].equals(c[z - 2]); ) z--;
            let j = 0;
            for (; j < z - 1 && c[j].equals(c[j + 1]); ) j++;
            if (z < (N ? 3 : 2)) return;
            p === "bevel" && (x = 1.05);
            const K = this.overscaling <= 16 ? 15 * ht / (512 * this.overscaling) : 0, ee = this.segments.prepareSegment(10 * z, this.layoutVertexArray, this.indexArray);
            let te, le, Ae, Te, Qe;
            this.e1 = this.e2 = -1, N && (te = c[z - 2], Qe = c[j].sub(te)._unit()._perp());
            for (let ke = j; ke < z; ke++) {
              if (Ae = ke === z - 1 ? N ? c[j + 1] : void 0 : c[ke + 1], Ae && c[ke].equals(Ae)) continue;
              Qe && (Te = Qe), te && (le = te), te = c[ke], Qe = Ae ? Ae.sub(te)._unit()._perp() : Te, Te = Te || Qe;
              let Q = Te.add(Qe);
              Q.x === 0 && Q.y === 0 || Q._unit();
              const xe = Te.x * Qe.x + Te.y * Qe.y, ze = Q.x * Qe.x + Q.y * Qe.y, yt = ze !== 0 ? 1 / ze : 1 / 0, $t = 2 * Math.sqrt(2 - 2 * ze), It = ze < IP && le && Ae, Lt = Te.x * Qe.y - Te.y * Qe.x > 0;
              if (It && ke > j) {
                const ir = te.dist(le);
                if (ir > 2 * K) {
                  const Dt = te.sub(te.sub(le)._mult(K / ir)._round());
                  this.updateDistance(le, Dt), this.addCurrentVertex(Dt, Te, 0, 0, ee), le = Dt;
                }
              }
              const er = le && Ae;
              let Xt = er ? p : N ? "butt" : y;
              if (er && Xt === "round" && (yt < A ? Xt = "miter" : yt <= 2 && (Xt = "fakeround")), Xt === "miter" && yt > x && (Xt = "bevel"), Xt === "bevel" && (yt > 2 && (Xt = "flipbevel"), yt < x && (Xt = "miter")), le && this.updateDistance(le, te), Xt === "miter") Q._mult(yt), this.addCurrentVertex(te, Q, 0, 0, ee);
              else if (Xt === "flipbevel") {
                if (yt > 100) Q = Qe.mult(-1);
                else {
                  const ir = yt * Te.add(Qe).mag() / Te.sub(Qe).mag();
                  Q._perp()._mult(ir * (Lt ? -1 : 1));
                }
                this.addCurrentVertex(te, Q, 0, 0, ee), this.addCurrentVertex(te, Q.mult(-1), 0, 0, ee);
              } else if (Xt === "bevel" || Xt === "fakeround") {
                const ir = -Math.sqrt(yt * yt - 1), Dt = Lt ? ir : 0, Er = Lt ? 0 : ir;
                if (le && this.addCurrentVertex(te, Te, Dt, Er, ee), Xt === "fakeround") {
                  const Fr = Math.round(180 * $t / Math.PI / 20);
                  for (let Nr = 1; Nr < Fr; Nr++) {
                    let Pr = Nr / Fr;
                    if (Pr !== 0.5) {
                      const Di = Pr - 0.5;
                      Pr += Pr * Di * (Pr - 1) * ((1.0904 + xe * (xe * (3.55645 - 1.43519 * xe) - 3.2452)) * Di * Di + (0.848013 + xe * (0.215638 * xe - 1.06021)));
                    }
                    const _n = Qe.sub(Te)._mult(Pr)._add(Te)._unit()._mult(Lt ? -1 : 1);
                    this.addHalfVertex(te, _n.x, _n.y, !1, Lt, 0, ee);
                  }
                }
                Ae && this.addCurrentVertex(te, Qe, -Dt, -Er, ee);
              } else if (Xt === "butt") this.addCurrentVertex(te, Q, 0, 0, ee);
              else if (Xt === "square") {
                const ir = le ? 1 : -1;
                this.addCurrentVertex(te, Q, ir, ir, ee);
              } else Xt === "round" && (le && (this.addCurrentVertex(te, Te, 0, 0, ee), this.addCurrentVertex(te, Te, 1, 1, ee, !0)), Ae && (this.addCurrentVertex(te, Qe, -1, -1, ee, !0), this.addCurrentVertex(te, Qe, 0, 0, ee)));
              if (It && ke < z - 1) {
                const ir = te.dist(Ae);
                if (ir > 2 * K) {
                  const Dt = te.add(Ae.sub(te)._mult(K / ir)._round());
                  this.updateDistance(te, Dt), this.addCurrentVertex(Dt, Qe, 0, 0, ee), te = Dt;
                }
              }
            }
          }
          addCurrentVertex(c, h, p, y, x) {
            let A = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
            const I = h.y * y - h.x, B = -h.y - h.x * y;
            this.addHalfVertex(c, h.x + h.y * p, h.y - h.x * p, A, !1, p, x), this.addHalfVertex(c, I, B, A, !0, -y, x), this.distance > Dx / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(c, h, p, y, x, A));
          }
          addHalfVertex(c, h, p, y, x, A, I) {
            let { x: B, y: N } = c;
            const z = 0.5 * (this.lineClips ? this.scaledDistance * (Dx - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((B << 1) + (y ? 1 : 0), (N << 1) + (x ? 1 : 0), Math.round(63 * h) + 128, Math.round(63 * p) + 128, 1 + (A === 0 ? 0 : A < 0 ? -1 : 1) | (63 & z) << 2, z >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            const j = I.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, j, this.e2), I.primitiveLength++), x ? this.e2 = j : this.e1 = j;
          }
          updateScaledDistance() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }
          updateDistance(c, h) {
            this.distance += c.dist(h), this.updateScaledDistance();
          }
        }
        let kx, Fx;
        vr("LineBucket", n0, { omit: ["layers", "patternFeatures"] });
        var Ux = { get paint() {
          return Fx = Fx || new rn({ "line-opacity": new Vt(ve.paint_line["line-opacity"]), "line-color": new Vt(ve.paint_line["line-color"]), "line-translate": new dt(ve.paint_line["line-translate"]), "line-translate-anchor": new dt(ve.paint_line["line-translate-anchor"]), "line-width": new Vt(ve.paint_line["line-width"]), "line-gap-width": new Vt(ve.paint_line["line-gap-width"]), "line-offset": new Vt(ve.paint_line["line-offset"]), "line-blur": new Vt(ve.paint_line["line-blur"]), "line-dasharray": new Ur(ve.paint_line["line-dasharray"]), "line-pattern": new yr(ve.paint_line["line-pattern"]), "line-gradient": new xr(ve.paint_line["line-gradient"]) });
        }, get layout() {
          return kx = kx || new rn({ "line-cap": new dt(ve.layout_line["line-cap"]), "line-join": new Vt(ve.layout_line["line-join"]), "line-miter-limit": new dt(ve.layout_line["line-miter-limit"]), "line-round-limit": new dt(ve.layout_line["line-round-limit"]), "line-sort-key": new Vt(ve.layout_line["line-sort-key"]) });
        } };
        class MP extends Vt {
          possiblyEvaluate(c, h) {
            return h = new ot(Math.floor(h.zoom), { now: h.now, fadeDuration: h.fadeDuration, zoomHistory: h.zoomHistory, transition: h.transition }), super.possiblyEvaluate(c, h);
          }
          evaluate(c, h, p, y) {
            return h = Xe({}, h, { zoom: Math.floor(h.zoom) }), super.evaluate(c, h, p, y);
          }
        }
        let $g;
        class PP extends on {
          constructor(c) {
            super(c, Ux), this.gradientVersion = 0, $g || ($g = new MP(Ux.paint.properties["line-width"].specification), $g.useIntegerZoom = !0);
          }
          _handleSpecialPaintPropertyUpdate(c) {
            if (c === "line-gradient") {
              const h = this.gradientExpression();
              this.stepInterpolant = !!function(p) {
                return p._styleExpression !== void 0;
              }(h) && h._styleExpression.expression instanceof Yo, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
            }
          }
          gradientExpression() {
            return this._transitionablePaint._values["line-gradient"].value.expression;
          }
          recalculate(c, h) {
            super.recalculate(c, h), this.paint._values["line-floorwidth"] = $g.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, c);
          }
          createBucket(c) {
            return new n0(c);
          }
          queryRadius(c) {
            const h = c, p = zx(cp("line-width", this, h), cp("line-gap-width", this, h)), y = cp("line-offset", this, h);
            return p / 2 + Math.abs(y) + Ug(this.paint.get("line-translate"));
          }
          queryIntersectsFeature(c) {
            let { queryGeometry: h, feature: p, featureState: y, geometry: x, transform: A, pixelsToTileUnits: I } = c;
            const B = zg(h, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -A.bearingInRadians, I), N = I / 2 * zx(this.paint.get("line-width").evaluate(p, y), this.paint.get("line-gap-width").evaluate(p, y)), z = this.paint.get("line-offset").evaluate(p, y);
            return z && (x = function(j, K) {
              const ee = [];
              for (let te = 0; te < j.length; te++) {
                const le = j[te], Ae = [];
                for (let Te = 0; Te < le.length; Te++) {
                  const Qe = le[Te - 1], ke = le[Te], Q = le[Te + 1], xe = Te === 0 ? new D(0, 0) : ke.sub(Qe)._unit()._perp(), ze = Te === le.length - 1 ? new D(0, 0) : Q.sub(ke)._unit()._perp(), yt = xe._add(ze)._unit(), $t = yt.x * ze.x + yt.y * ze.y;
                  $t !== 0 && yt._mult(1 / $t), Ae.push(yt._mult(K)._add(ke));
                }
                ee.push(Ae);
              }
              return ee;
            }(x, z * I)), function(j, K, ee) {
              for (let te = 0; te < K.length; te++) {
                const le = K[te];
                if (j.length >= 3) {
                  for (let Ae = 0; Ae < le.length; Ae++) if (Vf(j, le[Ae])) return !0;
                }
                if (lp(j, le, ee)) return !0;
              }
              return !1;
            }(B, x, N);
          }
          isTileClipped() {
            return !0;
          }
        }
        function zx(f, c) {
          return c > 0 ? c + 2 * f : f;
        }
        const RP = Br([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), BP = Br([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
        Br([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
        const LP = Br([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
        Br([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
        const jx = Br([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), OP = Br([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
        function NP(f, c, h) {
          return f.sections.forEach((p) => {
            p.text = function(y, x, A) {
              const I = x.layout.get("text-transform").evaluate(A, {});
              return I === "uppercase" ? y = y.toLocaleUpperCase() : I === "lowercase" && (y = y.toLocaleLowerCase()), et.applyArabicShaping && (y = et.applyArabicShaping(y)), y;
            }(p.text, c, h);
          }), f;
        }
        Br([{ name: "triangle", components: 3, type: "Uint16" }]), Br([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Br([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Br([{ type: "Float32", name: "offsetX" }]), Br([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Br([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
        const vp = { "!": "", "#": "", $: "", "%": "", "&": "", "(": "", ")": "", "*": "", "+": "", ",": "", "-": "", ".": "", "/": "", ":": "", ";": "", "<": "", "=": "", ">": "", "?": "", "@": "", "[": "", "\\": "", "]": "", "^": "", _: "", "`": "", "{": "", "|": "", "}": "", "~": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "", "": "" };
        var Vx, i0, qx, bs = 24, s0 = {};
        function DP() {
          return Vx || (Vx = 1, s0.read = function(f, c, h, p, y) {
            var x, A, I = 8 * y - p - 1, B = (1 << I) - 1, N = B >> 1, z = -7, j = h ? y - 1 : 0, K = h ? -1 : 1, ee = f[c + j];
            for (j += K, x = ee & (1 << -z) - 1, ee >>= -z, z += I; z > 0; x = 256 * x + f[c + j], j += K, z -= 8) ;
            for (A = x & (1 << -z) - 1, x >>= -z, z += p; z > 0; A = 256 * A + f[c + j], j += K, z -= 8) ;
            if (x === 0) x = 1 - N;
            else {
              if (x === B) return A ? NaN : 1 / 0 * (ee ? -1 : 1);
              A += Math.pow(2, p), x -= N;
            }
            return (ee ? -1 : 1) * A * Math.pow(2, x - p);
          }, s0.write = function(f, c, h, p, y, x) {
            var A, I, B, N = 8 * x - y - 1, z = (1 << N) - 1, j = z >> 1, K = y === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ee = p ? 0 : x - 1, te = p ? 1 : -1, le = c < 0 || c === 0 && 1 / c < 0 ? 1 : 0;
            for (c = Math.abs(c), isNaN(c) || c === 1 / 0 ? (I = isNaN(c) ? 1 : 0, A = z) : (A = Math.floor(Math.log(c) / Math.LN2), c * (B = Math.pow(2, -A)) < 1 && (A--, B *= 2), (c += A + j >= 1 ? K / B : K * Math.pow(2, 1 - j)) * B >= 2 && (A++, B /= 2), A + j >= z ? (I = 0, A = z) : A + j >= 1 ? (I = (c * B - 1) * Math.pow(2, y), A += j) : (I = c * Math.pow(2, j - 1) * Math.pow(2, y), A = 0)); y >= 8; f[h + ee] = 255 & I, ee += te, I /= 256, y -= 8) ;
            for (A = A << y | I, N += y; N > 0; f[h + ee] = 255 & A, ee += te, A /= 256, N -= 8) ;
            f[h + ee - te] |= 128 * le;
          }), s0;
        }
        function Gx() {
          if (qx) return i0;
          qx = 1, i0 = c;
          var f = DP();
          function c(Q) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(Q) ? Q : new Uint8Array(Q || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          c.Varint = 0, c.Fixed64 = 1, c.Bytes = 2, c.Fixed32 = 5;
          var h = 4294967296, p = 1 / h, y = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
          function x(Q) {
            return Q.type === c.Bytes ? Q.readVarint() + Q.pos : Q.pos + 1;
          }
          function A(Q, xe, ze) {
            return ze ? 4294967296 * xe + (Q >>> 0) : 4294967296 * (xe >>> 0) + (Q >>> 0);
          }
          function I(Q, xe, ze) {
            var yt = xe <= 16383 ? 1 : xe <= 2097151 ? 2 : xe <= 268435455 ? 3 : Math.floor(Math.log(xe) / (7 * Math.LN2));
            ze.realloc(yt);
            for (var $t = ze.pos - 1; $t >= Q; $t--) ze.buf[$t + yt] = ze.buf[$t];
          }
          function B(Q, xe) {
            for (var ze = 0; ze < Q.length; ze++) xe.writeVarint(Q[ze]);
          }
          function N(Q, xe) {
            for (var ze = 0; ze < Q.length; ze++) xe.writeSVarint(Q[ze]);
          }
          function z(Q, xe) {
            for (var ze = 0; ze < Q.length; ze++) xe.writeFloat(Q[ze]);
          }
          function j(Q, xe) {
            for (var ze = 0; ze < Q.length; ze++) xe.writeDouble(Q[ze]);
          }
          function K(Q, xe) {
            for (var ze = 0; ze < Q.length; ze++) xe.writeBoolean(Q[ze]);
          }
          function ee(Q, xe) {
            for (var ze = 0; ze < Q.length; ze++) xe.writeFixed32(Q[ze]);
          }
          function te(Q, xe) {
            for (var ze = 0; ze < Q.length; ze++) xe.writeSFixed32(Q[ze]);
          }
          function le(Q, xe) {
            for (var ze = 0; ze < Q.length; ze++) xe.writeFixed64(Q[ze]);
          }
          function Ae(Q, xe) {
            for (var ze = 0; ze < Q.length; ze++) xe.writeSFixed64(Q[ze]);
          }
          function Te(Q, xe) {
            return (Q[xe] | Q[xe + 1] << 8 | Q[xe + 2] << 16) + 16777216 * Q[xe + 3];
          }
          function Qe(Q, xe, ze) {
            Q[ze] = xe, Q[ze + 1] = xe >>> 8, Q[ze + 2] = xe >>> 16, Q[ze + 3] = xe >>> 24;
          }
          function ke(Q, xe) {
            return (Q[xe] | Q[xe + 1] << 8 | Q[xe + 2] << 16) + (Q[xe + 3] << 24);
          }
          return c.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(Q, xe, ze) {
            for (ze = ze || this.length; this.pos < ze; ) {
              var yt = this.readVarint(), $t = yt >> 3, It = this.pos;
              this.type = 7 & yt, Q($t, xe, this), this.pos === It && this.skip(yt);
            }
            return xe;
          }, readMessage: function(Q, xe) {
            return this.readFields(Q, xe, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var Q = Te(this.buf, this.pos);
            return this.pos += 4, Q;
          }, readSFixed32: function() {
            var Q = ke(this.buf, this.pos);
            return this.pos += 4, Q;
          }, readFixed64: function() {
            var Q = Te(this.buf, this.pos) + Te(this.buf, this.pos + 4) * h;
            return this.pos += 8, Q;
          }, readSFixed64: function() {
            var Q = Te(this.buf, this.pos) + ke(this.buf, this.pos + 4) * h;
            return this.pos += 8, Q;
          }, readFloat: function() {
            var Q = f.read(this.buf, this.pos, !0, 23, 4);
            return this.pos += 4, Q;
          }, readDouble: function() {
            var Q = f.read(this.buf, this.pos, !0, 52, 8);
            return this.pos += 8, Q;
          }, readVarint: function(Q) {
            var xe, ze, yt = this.buf;
            return xe = 127 & (ze = yt[this.pos++]), ze < 128 ? xe : (xe |= (127 & (ze = yt[this.pos++])) << 7, ze < 128 ? xe : (xe |= (127 & (ze = yt[this.pos++])) << 14, ze < 128 ? xe : (xe |= (127 & (ze = yt[this.pos++])) << 21, ze < 128 ? xe : function($t, It, Lt) {
              var er, Xt, ir = Lt.buf;
              if (er = (112 & (Xt = ir[Lt.pos++])) >> 4, Xt < 128 || (er |= (127 & (Xt = ir[Lt.pos++])) << 3, Xt < 128) || (er |= (127 & (Xt = ir[Lt.pos++])) << 10, Xt < 128) || (er |= (127 & (Xt = ir[Lt.pos++])) << 17, Xt < 128) || (er |= (127 & (Xt = ir[Lt.pos++])) << 24, Xt < 128) || (er |= (1 & (Xt = ir[Lt.pos++])) << 31, Xt < 128)) return A($t, er, It);
              throw new Error("Expected varint not more than 10 bytes");
            }(xe |= (15 & (ze = yt[this.pos])) << 28, Q, this))));
          }, readVarint64: function() {
            return this.readVarint(!0);
          }, readSVarint: function() {
            var Q = this.readVarint();
            return Q % 2 == 1 ? (Q + 1) / -2 : Q / 2;
          }, readBoolean: function() {
            return !!this.readVarint();
          }, readString: function() {
            var Q = this.readVarint() + this.pos, xe = this.pos;
            return this.pos = Q, Q - xe >= 12 && y ? function(ze, yt, $t) {
              return y.decode(ze.subarray(yt, $t));
            }(this.buf, xe, Q) : function(ze, yt, $t) {
              for (var It = "", Lt = yt; Lt < $t; ) {
                var er, Xt, ir, Dt = ze[Lt], Er = null, Fr = Dt > 239 ? 4 : Dt > 223 ? 3 : Dt > 191 ? 2 : 1;
                if (Lt + Fr > $t) break;
                Fr === 1 ? Dt < 128 && (Er = Dt) : Fr === 2 ? (192 & (er = ze[Lt + 1])) == 128 && (Er = (31 & Dt) << 6 | 63 & er) <= 127 && (Er = null) : Fr === 3 ? (Xt = ze[Lt + 2], (192 & (er = ze[Lt + 1])) == 128 && (192 & Xt) == 128 && ((Er = (15 & Dt) << 12 | (63 & er) << 6 | 63 & Xt) <= 2047 || Er >= 55296 && Er <= 57343) && (Er = null)) : Fr === 4 && (Xt = ze[Lt + 2], ir = ze[Lt + 3], (192 & (er = ze[Lt + 1])) == 128 && (192 & Xt) == 128 && (192 & ir) == 128 && ((Er = (15 & Dt) << 18 | (63 & er) << 12 | (63 & Xt) << 6 | 63 & ir) <= 65535 || Er >= 1114112) && (Er = null)), Er === null ? (Er = 65533, Fr = 1) : Er > 65535 && (Er -= 65536, It += String.fromCharCode(Er >>> 10 & 1023 | 55296), Er = 56320 | 1023 & Er), It += String.fromCharCode(Er), Lt += Fr;
              }
              return It;
            }(this.buf, xe, Q);
          }, readBytes: function() {
            var Q = this.readVarint() + this.pos, xe = this.buf.subarray(this.pos, Q);
            return this.pos = Q, xe;
          }, readPackedVarint: function(Q, xe) {
            if (this.type !== c.Bytes) return Q.push(this.readVarint(xe));
            var ze = x(this);
            for (Q = Q || []; this.pos < ze; ) Q.push(this.readVarint(xe));
            return Q;
          }, readPackedSVarint: function(Q) {
            if (this.type !== c.Bytes) return Q.push(this.readSVarint());
            var xe = x(this);
            for (Q = Q || []; this.pos < xe; ) Q.push(this.readSVarint());
            return Q;
          }, readPackedBoolean: function(Q) {
            if (this.type !== c.Bytes) return Q.push(this.readBoolean());
            var xe = x(this);
            for (Q = Q || []; this.pos < xe; ) Q.push(this.readBoolean());
            return Q;
          }, readPackedFloat: function(Q) {
            if (this.type !== c.Bytes) return Q.push(this.readFloat());
            var xe = x(this);
            for (Q = Q || []; this.pos < xe; ) Q.push(this.readFloat());
            return Q;
          }, readPackedDouble: function(Q) {
            if (this.type !== c.Bytes) return Q.push(this.readDouble());
            var xe = x(this);
            for (Q = Q || []; this.pos < xe; ) Q.push(this.readDouble());
            return Q;
          }, readPackedFixed32: function(Q) {
            if (this.type !== c.Bytes) return Q.push(this.readFixed32());
            var xe = x(this);
            for (Q = Q || []; this.pos < xe; ) Q.push(this.readFixed32());
            return Q;
          }, readPackedSFixed32: function(Q) {
            if (this.type !== c.Bytes) return Q.push(this.readSFixed32());
            var xe = x(this);
            for (Q = Q || []; this.pos < xe; ) Q.push(this.readSFixed32());
            return Q;
          }, readPackedFixed64: function(Q) {
            if (this.type !== c.Bytes) return Q.push(this.readFixed64());
            var xe = x(this);
            for (Q = Q || []; this.pos < xe; ) Q.push(this.readFixed64());
            return Q;
          }, readPackedSFixed64: function(Q) {
            if (this.type !== c.Bytes) return Q.push(this.readSFixed64());
            var xe = x(this);
            for (Q = Q || []; this.pos < xe; ) Q.push(this.readSFixed64());
            return Q;
          }, skip: function(Q) {
            var xe = 7 & Q;
            if (xe === c.Varint) for (; this.buf[this.pos++] > 127; ) ;
            else if (xe === c.Bytes) this.pos = this.readVarint() + this.pos;
            else if (xe === c.Fixed32) this.pos += 4;
            else {
              if (xe !== c.Fixed64) throw new Error("Unimplemented type: " + xe);
              this.pos += 8;
            }
          }, writeTag: function(Q, xe) {
            this.writeVarint(Q << 3 | xe);
          }, realloc: function(Q) {
            for (var xe = this.length || 16; xe < this.pos + Q; ) xe *= 2;
            if (xe !== this.length) {
              var ze = new Uint8Array(xe);
              ze.set(this.buf), this.buf = ze, this.length = xe;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(Q) {
            this.realloc(4), Qe(this.buf, Q, this.pos), this.pos += 4;
          }, writeSFixed32: function(Q) {
            this.realloc(4), Qe(this.buf, Q, this.pos), this.pos += 4;
          }, writeFixed64: function(Q) {
            this.realloc(8), Qe(this.buf, -1 & Q, this.pos), Qe(this.buf, Math.floor(Q * p), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(Q) {
            this.realloc(8), Qe(this.buf, -1 & Q, this.pos), Qe(this.buf, Math.floor(Q * p), this.pos + 4), this.pos += 8;
          }, writeVarint: function(Q) {
            (Q = +Q || 0) > 268435455 || Q < 0 ? function(xe, ze) {
              var yt, $t;
              if (xe >= 0 ? (yt = xe % 4294967296 | 0, $t = xe / 4294967296 | 0) : ($t = ~(-xe / 4294967296), 4294967295 ^ (yt = ~(-xe % 4294967296)) ? yt = yt + 1 | 0 : (yt = 0, $t = $t + 1 | 0)), xe >= 18446744073709552e3 || xe < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
              ze.realloc(10), function(It, Lt, er) {
                er.buf[er.pos++] = 127 & It | 128, It >>>= 7, er.buf[er.pos++] = 127 & It | 128, It >>>= 7, er.buf[er.pos++] = 127 & It | 128, It >>>= 7, er.buf[er.pos++] = 127 & It | 128, er.buf[er.pos] = 127 & (It >>>= 7);
              }(yt, 0, ze), function(It, Lt) {
                var er = (7 & It) << 4;
                Lt.buf[Lt.pos++] |= er | ((It >>>= 3) ? 128 : 0), It && (Lt.buf[Lt.pos++] = 127 & It | ((It >>>= 7) ? 128 : 0), It && (Lt.buf[Lt.pos++] = 127 & It | ((It >>>= 7) ? 128 : 0), It && (Lt.buf[Lt.pos++] = 127 & It | ((It >>>= 7) ? 128 : 0), It && (Lt.buf[Lt.pos++] = 127 & It | ((It >>>= 7) ? 128 : 0), It && (Lt.buf[Lt.pos++] = 127 & It)))));
              }($t, ze);
            }(Q, this) : (this.realloc(4), this.buf[this.pos++] = 127 & Q | (Q > 127 ? 128 : 0), Q <= 127 || (this.buf[this.pos++] = 127 & (Q >>>= 7) | (Q > 127 ? 128 : 0), Q <= 127 || (this.buf[this.pos++] = 127 & (Q >>>= 7) | (Q > 127 ? 128 : 0), Q <= 127 || (this.buf[this.pos++] = Q >>> 7 & 127))));
          }, writeSVarint: function(Q) {
            this.writeVarint(Q < 0 ? 2 * -Q - 1 : 2 * Q);
          }, writeBoolean: function(Q) {
            this.writeVarint(!!Q);
          }, writeString: function(Q) {
            Q = String(Q), this.realloc(4 * Q.length), this.pos++;
            var xe = this.pos;
            this.pos = function(yt, $t, It) {
              for (var Lt, er, Xt = 0; Xt < $t.length; Xt++) {
                if ((Lt = $t.charCodeAt(Xt)) > 55295 && Lt < 57344) {
                  if (!er) {
                    Lt > 56319 || Xt + 1 === $t.length ? (yt[It++] = 239, yt[It++] = 191, yt[It++] = 189) : er = Lt;
                    continue;
                  }
                  if (Lt < 56320) {
                    yt[It++] = 239, yt[It++] = 191, yt[It++] = 189, er = Lt;
                    continue;
                  }
                  Lt = er - 55296 << 10 | Lt - 56320 | 65536, er = null;
                } else er && (yt[It++] = 239, yt[It++] = 191, yt[It++] = 189, er = null);
                Lt < 128 ? yt[It++] = Lt : (Lt < 2048 ? yt[It++] = Lt >> 6 | 192 : (Lt < 65536 ? yt[It++] = Lt >> 12 | 224 : (yt[It++] = Lt >> 18 | 240, yt[It++] = Lt >> 12 & 63 | 128), yt[It++] = Lt >> 6 & 63 | 128), yt[It++] = 63 & Lt | 128);
              }
              return It;
            }(this.buf, Q, this.pos);
            var ze = this.pos - xe;
            ze >= 128 && I(xe, ze, this), this.pos = xe - 1, this.writeVarint(ze), this.pos += ze;
          }, writeFloat: function(Q) {
            this.realloc(4), f.write(this.buf, Q, this.pos, !0, 23, 4), this.pos += 4;
          }, writeDouble: function(Q) {
            this.realloc(8), f.write(this.buf, Q, this.pos, !0, 52, 8), this.pos += 8;
          }, writeBytes: function(Q) {
            var xe = Q.length;
            this.writeVarint(xe), this.realloc(xe);
            for (var ze = 0; ze < xe; ze++) this.buf[this.pos++] = Q[ze];
          }, writeRawMessage: function(Q, xe) {
            this.pos++;
            var ze = this.pos;
            Q(xe, this);
            var yt = this.pos - ze;
            yt >= 128 && I(ze, yt, this), this.pos = ze - 1, this.writeVarint(yt), this.pos += yt;
          }, writeMessage: function(Q, xe, ze) {
            this.writeTag(Q, c.Bytes), this.writeRawMessage(xe, ze);
          }, writePackedVarint: function(Q, xe) {
            xe.length && this.writeMessage(Q, B, xe);
          }, writePackedSVarint: function(Q, xe) {
            xe.length && this.writeMessage(Q, N, xe);
          }, writePackedBoolean: function(Q, xe) {
            xe.length && this.writeMessage(Q, K, xe);
          }, writePackedFloat: function(Q, xe) {
            xe.length && this.writeMessage(Q, z, xe);
          }, writePackedDouble: function(Q, xe) {
            xe.length && this.writeMessage(Q, j, xe);
          }, writePackedFixed32: function(Q, xe) {
            xe.length && this.writeMessage(Q, ee, xe);
          }, writePackedSFixed32: function(Q, xe) {
            xe.length && this.writeMessage(Q, te, xe);
          }, writePackedFixed64: function(Q, xe) {
            xe.length && this.writeMessage(Q, le, xe);
          }, writePackedSFixed64: function(Q, xe) {
            xe.length && this.writeMessage(Q, Ae, xe);
          }, writeBytesField: function(Q, xe) {
            this.writeTag(Q, c.Bytes), this.writeBytes(xe);
          }, writeFixed32Field: function(Q, xe) {
            this.writeTag(Q, c.Fixed32), this.writeFixed32(xe);
          }, writeSFixed32Field: function(Q, xe) {
            this.writeTag(Q, c.Fixed32), this.writeSFixed32(xe);
          }, writeFixed64Field: function(Q, xe) {
            this.writeTag(Q, c.Fixed64), this.writeFixed64(xe);
          }, writeSFixed64Field: function(Q, xe) {
            this.writeTag(Q, c.Fixed64), this.writeSFixed64(xe);
          }, writeVarintField: function(Q, xe) {
            this.writeTag(Q, c.Varint), this.writeVarint(xe);
          }, writeSVarintField: function(Q, xe) {
            this.writeTag(Q, c.Varint), this.writeSVarint(xe);
          }, writeStringField: function(Q, xe) {
            this.writeTag(Q, c.Bytes), this.writeString(xe);
          }, writeFloatField: function(Q, xe) {
            this.writeTag(Q, c.Fixed32), this.writeFloat(xe);
          }, writeDoubleField: function(Q, xe) {
            this.writeTag(Q, c.Fixed64), this.writeDouble(xe);
          }, writeBooleanField: function(Q, xe) {
            this.writeVarintField(Q, !!xe);
          } }, i0;
        }
        var o0 = d(Gx());
        const a0 = 3;
        function kP(f, c, h) {
          f === 1 && h.readMessage(FP, c);
        }
        function FP(f, c, h) {
          if (f === 3) {
            const { id: p, bitmap: y, width: x, height: A, left: I, top: B, advance: N } = h.readMessage(UP, {});
            c.push({ id: p, bitmap: new up({ width: x + 2 * a0, height: A + 2 * a0 }, y), metrics: { width: x, height: A, left: I, top: B, advance: N } });
          }
        }
        function UP(f, c, h) {
          f === 1 ? c.id = h.readVarint() : f === 2 ? c.bitmap = h.readBytes() : f === 3 ? c.width = h.readVarint() : f === 4 ? c.height = h.readVarint() : f === 5 ? c.left = h.readSVarint() : f === 6 ? c.top = h.readSVarint() : f === 7 && (c.advance = h.readVarint());
        }
        const zP = a0;
        function $x(f) {
          let c = 0, h = 0;
          for (const A of f) c += A.w * A.h, h = Math.max(h, A.w);
          f.sort((A, I) => I.h - A.h);
          const p = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(c / 0.95)), h), h: 1 / 0 }];
          let y = 0, x = 0;
          for (const A of f) for (let I = p.length - 1; I >= 0; I--) {
            const B = p[I];
            if (!(A.w > B.w || A.h > B.h)) {
              if (A.x = B.x, A.y = B.y, x = Math.max(x, A.y + A.h), y = Math.max(y, A.x + A.w), A.w === B.w && A.h === B.h) {
                const N = p.pop();
                I < p.length && (p[I] = N);
              } else A.h === B.h ? (B.x += A.w, B.w -= A.w) : A.w === B.w ? (B.y += A.h, B.h -= A.h) : (p.push({ x: B.x + A.w, y: B.y, w: B.w - A.w, h: A.h }), B.y += A.h, B.h -= A.h);
              break;
            }
          }
          return { w: y, h: x, fill: c / (y * x) || 0 };
        }
        const na = 1;
        class l0 {
          constructor(c, h) {
            let { pixelRatio: p, version: y, stretchX: x, stretchY: A, content: I, textFitWidth: B, textFitHeight: N } = h;
            this.paddedRect = c, this.pixelRatio = p, this.stretchX = x, this.stretchY = A, this.content = I, this.version = y, this.textFitWidth = B, this.textFitHeight = N;
          }
          get tl() {
            return [this.paddedRect.x + na, this.paddedRect.y + na];
          }
          get br() {
            return [this.paddedRect.x + this.paddedRect.w - na, this.paddedRect.y + this.paddedRect.h - na];
          }
          get tlbr() {
            return this.tl.concat(this.br);
          }
          get displaySize() {
            return [(this.paddedRect.w - 2 * na) / this.pixelRatio, (this.paddedRect.h - 2 * na) / this.pixelRatio];
          }
        }
        class Hx {
          constructor(c, h) {
            const p = {}, y = {};
            this.haveRenderCallbacks = [];
            const x = [];
            this.addImages(c, p, x), this.addImages(h, y, x);
            const { w: A, h: I } = $x(x), B = new Va({ width: A || 1, height: I || 1 });
            for (const N in c) {
              const z = c[N], j = p[N].paddedRect;
              Va.copy(z.data, B, { x: 0, y: 0 }, { x: j.x + na, y: j.y + na }, z.data);
            }
            for (const N in h) {
              const z = h[N], j = y[N].paddedRect, K = j.x + na, ee = j.y + na, te = z.data.width, le = z.data.height;
              Va.copy(z.data, B, { x: 0, y: 0 }, { x: K, y: ee }, z.data), Va.copy(z.data, B, { x: 0, y: le - 1 }, { x: K, y: ee - 1 }, { width: te, height: 1 }), Va.copy(z.data, B, { x: 0, y: 0 }, { x: K, y: ee + le }, { width: te, height: 1 }), Va.copy(z.data, B, { x: te - 1, y: 0 }, { x: K - 1, y: ee }, { width: 1, height: le }), Va.copy(z.data, B, { x: 0, y: 0 }, { x: K + te, y: ee }, { width: 1, height: le });
            }
            this.image = B, this.iconPositions = p, this.patternPositions = y;
          }
          addImages(c, h, p) {
            for (const y in c) {
              const x = c[y], A = { x: 0, y: 0, w: x.data.width + 2 * na, h: x.data.height + 2 * na };
              p.push(A), h[y] = new l0(A, x), x.hasRenderCallback && this.haveRenderCallbacks.push(y);
            }
          }
          patchUpdatedImages(c, h) {
            c.dispatchRenderCallbacks(this.haveRenderCallbacks);
            for (const p in c.updatedImages) this.patchUpdatedImage(this.iconPositions[p], c.getImage(p), h), this.patchUpdatedImage(this.patternPositions[p], c.getImage(p), h);
          }
          patchUpdatedImage(c, h, p) {
            if (!c || !h || c.version === h.version) return;
            c.version = h.version;
            const [y, x] = c.tl;
            p.update(h.data, void 0, { x: y, y: x });
          }
        }
        var rh;
        vr("ImagePosition", l0), vr("ImageAtlas", Hx), l.af = void 0, (rh = l.af || (l.af = {}))[rh.none = 0] = "none", rh[rh.horizontal = 1] = "horizontal", rh[rh.vertical = 2] = "vertical", rh[rh.horizontalOnly = 3] = "horizontalOnly";
        const Hg = -17;
        class xp {
          constructor() {
            this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
          }
          static forText(c, h, p) {
            const y = new xp();
            return y.scale = c || 1, y.fontStack = h, y.verticalAlign = p || "bottom", y;
          }
          static forImage(c, h) {
            const p = new xp();
            return p.imageName = c, p.verticalAlign = h || "bottom", p;
          }
        }
        class Hf {
          constructor() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          }
          static fromFeature(c, h) {
            const p = new Hf();
            for (let y = 0; y < c.sections.length; y++) {
              const x = c.sections[y];
              x.image ? p.addImageSection(x) : p.addTextSection(x, h);
            }
            return p;
          }
          length() {
            return this.text.length;
          }
          getSection(c) {
            return this.sections[this.sectionIndex[c]];
          }
          getSectionIndex(c) {
            return this.sectionIndex[c];
          }
          getCharCode(c) {
            return this.text.charCodeAt(c);
          }
          verticalizePunctuation() {
            this.text = function(c) {
              let h = "";
              for (let p = 0; p < c.length; p++) {
                const y = c.charCodeAt(p + 1) || null, x = c.charCodeAt(p - 1) || null;
                h += y && fe(y) && !vp[c[p + 1]] || x && fe(x) && !vp[c[p - 1]] || !vp[c[p]] ? c[p] : vp[c[p]];
              }
              return h;
            }(this.text);
          }
          trim() {
            let c = 0;
            for (let p = 0; p < this.text.length && Xg[this.text.charCodeAt(p)]; p++) c++;
            let h = this.text.length;
            for (let p = this.text.length - 1; p >= 0 && p >= c && Xg[this.text.charCodeAt(p)]; p--) h--;
            this.text = this.text.substring(c, h), this.sectionIndex = this.sectionIndex.slice(c, h);
          }
          substring(c, h) {
            const p = new Hf();
            return p.text = this.text.substring(c, h), p.sectionIndex = this.sectionIndex.slice(c, h), p.sections = this.sections, p;
          }
          toString() {
            return this.text;
          }
          getMaxScale() {
            return this.sectionIndex.reduce((c, h) => Math.max(c, this.sections[h].scale), 0);
          }
          getMaxImageSize(c) {
            let h = 0, p = 0;
            for (let y = 0; y < this.length(); y++) {
              const x = this.getSection(y);
              if (x.imageName) {
                const A = c[x.imageName];
                if (!A) continue;
                const I = A.displaySize;
                h = Math.max(h, I[0]), p = Math.max(p, I[1]);
              }
            }
            return { maxImageWidth: h, maxImageHeight: p };
          }
          addTextSection(c, h) {
            this.text += c.text, this.sections.push(xp.forText(c.scale, c.fontStack || h, c.verticalAlign));
            const p = this.sections.length - 1;
            for (let y = 0; y < c.text.length; ++y) this.sectionIndex.push(p);
          }
          addImageSection(c) {
            const h = c.image ? c.image.name : "";
            if (h.length === 0) return void Yt("Can't add FormattedSection with an empty image.");
            const p = this.getNextImageSectionCharCode();
            p ? (this.text += String.fromCharCode(p), this.sections.push(xp.forImage(h, c.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Yt("Reached maximum number of images 6401");
          }
          getNextImageSectionCharCode() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          }
        }
        function Wg(f, c, h, p, y, x, A, I, B, N, z, j, K, ee, te) {
          const le = Hf.fromFeature(f, y);
          let Ae;
          j === l.af.vertical && le.verticalizePunctuation();
          const { processBidirectionalText: Te, processStyledBidirectionalText: Qe } = et;
          if (Te && le.sections.length === 1) {
            Ae = [];
            const xe = Te(le.toString(), c0(le, N, x, c, p, ee));
            for (const ze of xe) {
              const yt = new Hf();
              yt.text = ze, yt.sections = le.sections;
              for (let $t = 0; $t < ze.length; $t++) yt.sectionIndex.push(0);
              Ae.push(yt);
            }
          } else if (Qe) {
            Ae = [];
            const xe = Qe(le.text, le.sectionIndex, c0(le, N, x, c, p, ee));
            for (const ze of xe) {
              const yt = new Hf();
              yt.text = ze[0], yt.sectionIndex = ze[1], yt.sections = le.sections, Ae.push(yt);
            }
          } else Ae = function(xe, ze) {
            const yt = [], $t = xe.text;
            let It = 0;
            for (const Lt of ze) yt.push(xe.substring(It, Lt)), It = Lt;
            return It < $t.length && yt.push(xe.substring(It, $t.length)), yt;
          }(le, c0(le, N, x, c, p, ee));
          const ke = [], Q = { positionedLines: ke, text: le.toString(), top: z[1], bottom: z[1], left: z[0], right: z[0], writingMode: j, iconsInText: !1, verticalizable: !1 };
          return function(xe, ze, yt, $t, It, Lt, er, Xt, ir, Dt, Er, Fr) {
            let Nr = 0, Pr = 0, _n = 0, Di = 0;
            const rs = Xt === "right" ? 1 : Xt === "left" ? 0 : 0.5, Lo = bs / Fr;
            let ia = 0;
            for (const Vi of It) {
              Vi.trim();
              const vs = Vi.getMaxScale(), Hs = { positionedGlyphs: [], lineOffset: 0 };
              xe.positionedLines[ia] = Hs;
              const ns = Hs.positionedGlyphs;
              let Oo = 0;
              if (!Vi.length()) {
                Pr += Lt, ++ia;
                continue;
              }
              const Ga = GP($t, Vi, Lo);
              for (let oa = 0; oa < Vi.length(); oa++) {
                const xs = Vi.getSection(oa), Ls = Vi.getSectionIndex(oa), Os = Vi.getCharCode(oa), is = $P(ir, Er, Os);
                let hi;
                if (xs.imageName) {
                  if (xe.iconsInText = !0, xs.scale = xs.scale * Lo, hi = WP(xs, is, vs, Ga, $t), !hi) continue;
                  Oo = Math.max(Oo, hi.imageOffset);
                } else if (hi = HP(xs, Os, is, Ga, ze, yt), !hi) continue;
                const { rect: sc, metrics: Yf, baselineOffset: oc } = hi;
                ns.push({ glyph: Os, imageName: xs.imageName, x: Nr, y: Pr + oc + Hg, vertical: is, scale: xs.scale, fontStack: xs.fontStack, sectionIndex: Ls, metrics: Yf, rect: sc }), is ? (xe.verticalizable = !0, Nr += (xs.imageName ? Yf.advance : bs) * xs.scale + Dt) : Nr += Yf.advance * xs.scale + Dt;
              }
              ns.length !== 0 && (_n = Math.max(Nr - Dt, _n), XP(ns, 0, ns.length - 1, rs)), Nr = 0, Hs.lineOffset = Math.max(Oo, (vs - 1) * bs);
              const Bs = Lt * vs + Oo;
              Pr += Bs, Di = Math.max(Bs, Di), ++ia;
            }
            const { horizontalAlign: sa, verticalAlign: $s } = u0(er);
            (function(Vi, vs, Hs, ns, Oo, Ga, Bs, oa, xs) {
              const Ls = (vs - Hs) * Oo;
              let Os = 0;
              Os = Ga !== Bs ? -oa * ns - Hg : -ns * xs * Bs + 0.5 * Bs;
              for (const is of Vi) for (const hi of is.positionedGlyphs) hi.x += Ls, hi.y += Os;
            })(xe.positionedLines, rs, sa, $s, _n, Di, Lt, Pr, It.length), xe.top += -$s * Pr, xe.bottom = xe.top + Pr, xe.left += -sa * _n, xe.right = xe.left + _n;
          }(Q, c, h, p, Ae, A, I, B, j, N, K, te), !function(xe) {
            for (const ze of xe) if (ze.positionedGlyphs.length !== 0) return !1;
            return !0;
          }(ke) && Q;
        }
        const Xg = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, jP = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, VP = { 40: !0 };
        function Wx(f, c, h, p, y, x) {
          if (c.imageName) {
            const A = p[c.imageName];
            return A ? A.displaySize[0] * c.scale * bs / x + y : 0;
          }
          {
            const A = h[c.fontStack], I = A && A[f];
            return I ? I.metrics.advance * c.scale + y : 0;
          }
        }
        function Xx(f, c, h, p) {
          const y = Math.pow(f - c, 2);
          return p ? f < c ? y / 2 : 2 * y : y + Math.abs(h) * h;
        }
        function qP(f, c, h) {
          let p = 0;
          return f === 10 && (p -= 1e4), h && (p += 150), f !== 40 && f !== 65288 || (p += 50), c !== 41 && c !== 65289 || (p += 50), p;
        }
        function Zx(f, c, h, p, y, x) {
          let A = null, I = Xx(c, h, y, x);
          for (const B of p) {
            const N = Xx(c - B.x, h, y, x) + B.badness;
            N <= I && (A = B, I = N);
          }
          return { index: f, x: c, priorBreak: A, badness: I };
        }
        function Yx(f) {
          return f ? Yx(f.priorBreak).concat(f.index) : [];
        }
        function c0(f, c, h, p, y, x) {
          if (!f) return [];
          const A = [], I = function(j, K, ee, te, le, Ae) {
            let Te = 0;
            for (let Qe = 0; Qe < j.length(); Qe++) {
              const ke = j.getSection(Qe);
              Te += Wx(j.getCharCode(Qe), ke, te, le, K, Ae);
            }
            return Te / Math.max(1, Math.ceil(Te / ee));
          }(f, c, h, p, y, x), B = f.text.indexOf("") >= 0;
          let N = 0;
          for (let j = 0; j < f.length(); j++) {
            const K = f.getSection(j), ee = f.getCharCode(j);
            if (Xg[ee] || (N += Wx(ee, K, p, y, c, x)), j < f.length() - 1) {
              const te = !((z = ee) < 11904) && (!!cn["CJK Compatibility Forms"](z) || !!cn["CJK Compatibility"](z) || !!cn["CJK Strokes"](z) || !!cn["CJK Symbols and Punctuation"](z) || !!cn["Enclosed CJK Letters and Months"](z) || !!cn["Halfwidth and Fullwidth Forms"](z) || !!cn["Ideographic Description Characters"](z) || !!cn["Vertical Forms"](z) || $.test(String.fromCodePoint(z)));
              (jP[ee] || te || K.imageName || j !== f.length() - 2 && VP[f.getCharCode(j + 1)]) && A.push(Zx(j + 1, N, I, A, qP(ee, f.getCharCode(j + 1), te && B), !1));
            }
          }
          var z;
          return Yx(Zx(f.length(), N, I, A, 0, !0));
        }
        function u0(f) {
          let c = 0.5, h = 0.5;
          switch (f) {
            case "right":
            case "top-right":
            case "bottom-right":
              c = 1;
              break;
            case "left":
            case "top-left":
            case "bottom-left":
              c = 0;
          }
          switch (f) {
            case "bottom":
            case "bottom-right":
            case "bottom-left":
              h = 1;
              break;
            case "top":
            case "top-right":
            case "top-left":
              h = 0;
          }
          return { horizontalAlign: c, verticalAlign: h };
        }
        function GP(f, c, h) {
          const p = c.getMaxScale() * bs, { maxImageWidth: y, maxImageHeight: x } = c.getMaxImageSize(f), A = Math.max(p, x * h);
          return { verticalLineContentWidth: Math.max(p, y * h), horizontalLineContentHeight: A };
        }
        function Kx(f) {
          switch (f) {
            case "top":
              return 0;
            case "center":
              return 0.5;
            default:
              return 1;
          }
        }
        function $P(f, c, h) {
          return !(f === l.af.horizontal || !c && !re(h) || c && (Xg[h] || (p = h, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(p)))));
          var p;
        }
        function HP(f, c, h, p, y, x) {
          const A = x[f.fontStack], I = function(N, z, j, K) {
            if (N && N.rect) return N;
            const ee = z[j.fontStack], te = ee && ee[K];
            return te ? { rect: null, metrics: te.metrics } : null;
          }(A && A[c], y, f, c);
          if (I === null) return null;
          let B;
          if (h) B = p.verticalLineContentWidth - f.scale * bs;
          else {
            const N = Kx(f.verticalAlign);
            B = (p.horizontalLineContentHeight - f.scale * bs) * N;
          }
          return { rect: I.rect, metrics: I.metrics, baselineOffset: B };
        }
        function WP(f, c, h, p, y) {
          const x = y[f.imageName];
          if (!x) return null;
          const A = x.paddedRect, I = x.displaySize, B = { width: I[0], height: I[1], left: na, top: -3, advance: c ? I[1] : I[0] };
          let N;
          if (c) N = p.verticalLineContentWidth - I[1] * f.scale;
          else {
            const z = Kx(f.verticalAlign);
            N = (p.horizontalLineContentHeight - I[1] * f.scale) * z;
          }
          return { rect: A, metrics: B, baselineOffset: N, imageOffset: (c ? I[0] : I[1]) * f.scale - bs * h };
        }
        function XP(f, c, h, p) {
          if (p === 0) return;
          const y = f[h], x = (f[h].x + y.metrics.advance * y.scale) * p;
          for (let A = c; A <= h; A++) f[A].x -= x;
        }
        function ZP(f, c, h) {
          const { horizontalAlign: p, verticalAlign: y } = u0(h), x = c[0] - f.displaySize[0] * p, A = c[1] - f.displaySize[1] * y;
          return { image: f, top: A, bottom: A + f.displaySize[1], left: x, right: x + f.displaySize[0] };
        }
        function Jx(f) {
          var c, h;
          let p = f.left, y = f.top, x = f.right - p, A = f.bottom - y;
          const I = (c = f.image.textFitWidth) !== null && c !== void 0 ? c : "stretchOrShrink", B = (h = f.image.textFitHeight) !== null && h !== void 0 ? h : "stretchOrShrink", N = (f.image.content[2] - f.image.content[0]) / (f.image.content[3] - f.image.content[1]);
          if (B === "proportional") {
            if (I === "stretchOnly" && x / A < N || I === "proportional") {
              const z = Math.ceil(A * N);
              p *= z / x, x = z;
            }
          } else if (I === "proportional" && B === "stretchOnly" && N !== 0 && x / A > N) {
            const z = Math.ceil(x / N);
            y *= z / A, A = z;
          }
          return { x1: p, y1: y, x2: p + x, y2: y + A };
        }
        function Qx(f, c, h, p, y, x) {
          const A = f.image;
          let I;
          if (A.content) {
            const Ae = A.content, Te = A.pixelRatio || 1;
            I = [Ae[0] / Te, Ae[1] / Te, A.displaySize[0] - Ae[2] / Te, A.displaySize[1] - Ae[3] / Te];
          }
          const B = c.left * x, N = c.right * x;
          let z, j, K, ee;
          h === "width" || h === "both" ? (ee = y[0] + B - p[3], j = y[0] + N + p[1]) : (ee = y[0] + (B + N - A.displaySize[0]) / 2, j = ee + A.displaySize[0]);
          const te = c.top * x, le = c.bottom * x;
          return h === "height" || h === "both" ? (z = y[1] + te - p[0], K = y[1] + le + p[2]) : (z = y[1] + (te + le - A.displaySize[1]) / 2, K = z + A.displaySize[1]), { image: A, top: z, right: j, bottom: K, left: ee, collisionPadding: I };
        }
        const wp = 255, Kc = 128, nh = wp * Kc;
        function ew(f, c) {
          const { expression: h } = c;
          if (h.kind === "constant") return { kind: "constant", layoutSize: h.evaluate(new ot(f + 1)) };
          if (h.kind === "source") return { kind: "source" };
          {
            const { zoomStops: p, interpolationType: y } = h;
            let x = 0;
            for (; x < p.length && p[x] <= f; ) x++;
            x = Math.max(0, x - 1);
            let A = x;
            for (; A < p.length && p[A] < f + 1; ) A++;
            A = Math.min(p.length - 1, A);
            const I = p[x], B = p[A];
            return h.kind === "composite" ? { kind: "composite", minZoom: I, maxZoom: B, interpolationType: y } : { kind: "camera", minZoom: I, maxZoom: B, minSize: h.evaluate(new ot(I)), maxSize: h.evaluate(new ot(B)), interpolationType: y };
          }
        }
        function h0(f, c, h) {
          let p = "never";
          const y = f.get(c);
          return y ? p = y : f.get(h) && (p = "always"), p;
        }
        const YP = _p.VectorTileFeature.types, KP = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
        function Zg(f, c, h, p, y, x, A, I, B, N, z, j, K) {
          const ee = I ? Math.min(nh, Math.round(I[0])) : 0, te = I ? Math.min(nh, Math.round(I[1])) : 0;
          f.emplaceBack(c, h, Math.round(32 * p), Math.round(32 * y), x, A, (ee << 1) + (B ? 1 : 0), te, 16 * N, 16 * z, 256 * j, 256 * K);
        }
        function f0(f, c, h) {
          f.emplaceBack(c.x, c.y, h), f.emplaceBack(c.x, c.y, h), f.emplaceBack(c.x, c.y, h), f.emplaceBack(c.x, c.y, h);
        }
        function JP(f) {
          for (const c of f.sections) if (Pe(c.text)) return !0;
          return !1;
        }
        class d0 {
          constructor(c) {
            this.layoutVertexArray = new Je(), this.indexArray = new Mt(), this.programConfigurations = c, this.segments = new dr(), this.dynamicLayoutVertexArray = new vt(), this.opacityVertexArray = new _t(), this.hasVisibleVertices = !1, this.placedSymbolArray = new R();
          }
          isEmpty() {
            return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
          }
          upload(c, h, p, y) {
            this.isEmpty() || (p && (this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, RP.members), this.indexBuffer = c.createIndexBuffer(this.indexArray, h), this.dynamicLayoutVertexBuffer = c.createVertexBuffer(this.dynamicLayoutVertexArray, BP.members, !0), this.opacityVertexBuffer = c.createVertexBuffer(this.opacityVertexArray, KP, !0), this.opacityVertexBuffer.itemSize = 1), (p || y) && this.programConfigurations.upload(c));
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }
        }
        vr("SymbolBuffers", d0);
        class p0 {
          constructor(c, h, p) {
            this.layoutVertexArray = new c(), this.layoutAttributes = h, this.indexArray = new p(), this.segments = new dr(), this.collisionVertexArray = new Ft();
          }
          upload(c) {
            this.layoutVertexBuffer = c.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = c.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = c.createVertexBuffer(this.collisionVertexArray, LP.members, !0);
          }
          destroy() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }
        }
        vr("CollisionBuffers", p0);
        class Wf {
          constructor(c) {
            this.collisionBoxArray = c.collisionBoxArray, this.zoom = c.zoom, this.overscaling = c.overscaling, this.layers = c.layers, this.layerIds = this.layers.map((A) => A.id), this.index = c.index, this.pixelRatio = c.pixelRatio, this.sourceLayerIndex = c.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
            const h = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = ew(this.zoom, h["text-size"]), this.iconSizeData = ew(this.zoom, h["icon-size"]);
            const p = this.layers[0].layout, y = p.get("symbol-sort-key"), x = p.get("symbol-z-order");
            this.canOverlap = h0(p, "text-overlap", "text-allow-overlap") !== "never" || h0(p, "icon-overlap", "icon-allow-overlap") !== "never" || p.get("text-ignore-placement") || p.get("icon-ignore-placement"), this.sortFeaturesByKey = x !== "viewport-y" && !y.isConstant(), this.sortFeaturesByY = (x === "viewport-y" || x === "auto" && !this.sortFeaturesByKey) && this.canOverlap, p.get("symbol-placement") === "point" && (this.writingModes = p.get("text-writing-mode").map((A) => l.af[A])), this.stateDependentLayerIds = this.layers.filter((A) => A.isStateDependent()).map((A) => A.id), this.sourceID = c.sourceID;
          }
          createArrays() {
            this.text = new d0(new Ci(this.layers, this.zoom, (c) => /^text/.test(c))), this.icon = new d0(new Ci(this.layers, this.zoom, (c) => /^icon/.test(c))), this.glyphOffsetArray = new V(), this.lineVertexArray = new W(), this.symbolInstances = new k(), this.textAnchorOffsets = new ae();
          }
          calculateGlyphDependencies(c, h, p, y, x) {
            for (let A = 0; A < c.length; A++) if (h[c.charCodeAt(A)] = !0, (p || y) && x) {
              const I = vp[c.charAt(A)];
              I && (h[I.charCodeAt(0)] = !0);
            }
          }
          populate(c, h, p) {
            const y = this.layers[0], x = y.layout, A = x.get("text-font"), I = x.get("text-field"), B = x.get("icon-image"), N = (I.value.kind !== "constant" || I.value.value instanceof oi && !I.value.value.isEmpty() || I.value.value.toString().length > 0) && (A.value.kind !== "constant" || A.value.value.length > 0), z = B.value.kind !== "constant" || !!B.value.value || Object.keys(B.parameters).length > 0, j = x.get("symbol-sort-key");
            if (this.features = [], !N && !z) return;
            const K = h.iconDependencies, ee = h.glyphDependencies, te = h.availableImages, le = new ot(this.zoom);
            for (const { feature: Ae, id: Te, index: Qe, sourceLayerIndex: ke } of c) {
              const Q = y._featureFilter.needGeometry, xe = Pu(Ae, Q);
              if (!y._featureFilter.filter(le, xe, p)) continue;
              let ze, yt;
              if (Q || (xe.geometry = Mu(Ae)), N) {
                const It = y.getValueAndResolveTokens("text-field", xe, p, te), Lt = oi.factory(It), er = this.hasRTLText = this.hasRTLText || JP(Lt);
                (!er || et.getRTLTextPluginStatus() === "unavailable" || er && et.isParsed()) && (ze = NP(Lt, y, xe));
              }
              if (z) {
                const It = y.getValueAndResolveTokens("icon-image", xe, p, te);
                yt = It instanceof ai ? It : ai.fromString(It);
              }
              if (!ze && !yt) continue;
              const $t = this.sortFeaturesByKey ? j.evaluate(xe, {}, p) : void 0;
              if (this.features.push({ id: Te, text: ze, icon: yt, index: Qe, sourceLayerIndex: ke, geometry: xe.geometry, properties: Ae.properties, type: YP[Ae.type], sortKey: $t }), yt && (K[yt.name] = !0), ze) {
                const It = A.evaluate(xe, {}, p).join(","), Lt = x.get("text-rotation-alignment") !== "viewport" && x.get("symbol-placement") !== "point";
                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(l.af.vertical) >= 0;
                for (const er of ze.sections) if (er.image) K[er.image.name] = !0;
                else {
                  const Xt = Zc(ze.toString()), ir = er.fontStack || It, Dt = ee[ir] = ee[ir] || {};
                  this.calculateGlyphDependencies(er.text, Dt, Lt, this.allowVerticalPlacement, Xt);
                }
              }
            }
            x.get("symbol-placement") === "line" && (this.features = function(Ae) {
              const Te = {}, Qe = {}, ke = [];
              let Q = 0;
              function xe(It) {
                ke.push(Ae[It]), Q++;
              }
              function ze(It, Lt, er) {
                const Xt = Qe[It];
                return delete Qe[It], Qe[Lt] = Xt, ke[Xt].geometry[0].pop(), ke[Xt].geometry[0] = ke[Xt].geometry[0].concat(er[0]), Xt;
              }
              function yt(It, Lt, er) {
                const Xt = Te[Lt];
                return delete Te[Lt], Te[It] = Xt, ke[Xt].geometry[0].shift(), ke[Xt].geometry[0] = er[0].concat(ke[Xt].geometry[0]), Xt;
              }
              function $t(It, Lt, er) {
                const Xt = er ? Lt[0][Lt[0].length - 1] : Lt[0][0];
                return `${It}:${Xt.x}:${Xt.y}`;
              }
              for (let It = 0; It < Ae.length; It++) {
                const Lt = Ae[It], er = Lt.geometry, Xt = Lt.text ? Lt.text.toString() : null;
                if (!Xt) {
                  xe(It);
                  continue;
                }
                const ir = $t(Xt, er), Dt = $t(Xt, er, !0);
                if (ir in Qe && Dt in Te && Qe[ir] !== Te[Dt]) {
                  const Er = yt(ir, Dt, er), Fr = ze(ir, Dt, ke[Er].geometry);
                  delete Te[ir], delete Qe[Dt], Qe[$t(Xt, ke[Fr].geometry, !0)] = Fr, ke[Er].geometry = null;
                } else ir in Qe ? ze(ir, Dt, er) : Dt in Te ? yt(ir, Dt, er) : (xe(It), Te[ir] = Q - 1, Qe[Dt] = Q - 1);
              }
              return ke.filter((It) => It.geometry);
            }(this.features)), this.sortFeaturesByKey && this.features.sort((Ae, Te) => Ae.sortKey - Te.sortKey);
          }
          update(c, h, p) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(c, h, this.layers, p), this.icon.programConfigurations.updatePaintArrays(c, h, this.layers, p));
          }
          isEmpty() {
            return this.symbolInstances.length === 0 && !this.hasRTLText;
          }
          uploadPending() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }
          upload(c) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(c), this.iconCollisionBox.upload(c)), this.text.upload(c, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(c, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
          }
          destroyDebugData() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }
          destroy() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }
          addToLineVertexArray(c, h) {
            const p = this.lineVertexArray.length;
            if (c.segment !== void 0) {
              let y = c.dist(h[c.segment + 1]), x = c.dist(h[c.segment]);
              const A = {};
              for (let I = c.segment + 1; I < h.length; I++) A[I] = { x: h[I].x, y: h[I].y, tileUnitDistanceFromAnchor: y }, I < h.length - 1 && (y += h[I + 1].dist(h[I]));
              for (let I = c.segment || 0; I >= 0; I--) A[I] = { x: h[I].x, y: h[I].y, tileUnitDistanceFromAnchor: x }, I > 0 && (x += h[I - 1].dist(h[I]));
              for (let I = 0; I < h.length; I++) {
                const B = A[I];
                this.lineVertexArray.emplaceBack(B.x, B.y, B.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: p, lineLength: this.lineVertexArray.length - p };
          }
          addSymbols(c, h, p, y, x, A, I, B, N, z, j, K) {
            const ee = c.indexArray, te = c.layoutVertexArray, le = c.segments.prepareSegment(4 * h.length, te, ee, this.canOverlap ? A.sortKey : void 0), Ae = this.glyphOffsetArray.length, Te = le.vertexLength, Qe = this.allowVerticalPlacement && I === l.af.vertical ? Math.PI / 2 : 0, ke = A.text && A.text.sections;
            for (let Q = 0; Q < h.length; Q++) {
              const { tl: xe, tr: ze, bl: yt, br: $t, tex: It, pixelOffsetTL: Lt, pixelOffsetBR: er, minFontScaleX: Xt, minFontScaleY: ir, glyphOffset: Dt, isSDF: Er, sectionIndex: Fr } = h[Q], Nr = le.vertexLength, Pr = Dt[1];
              Zg(te, B.x, B.y, xe.x, Pr + xe.y, It.x, It.y, p, Er, Lt.x, Lt.y, Xt, ir), Zg(te, B.x, B.y, ze.x, Pr + ze.y, It.x + It.w, It.y, p, Er, er.x, Lt.y, Xt, ir), Zg(te, B.x, B.y, yt.x, Pr + yt.y, It.x, It.y + It.h, p, Er, Lt.x, er.y, Xt, ir), Zg(te, B.x, B.y, $t.x, Pr + $t.y, It.x + It.w, It.y + It.h, p, Er, er.x, er.y, Xt, ir), f0(c.dynamicLayoutVertexArray, B, Qe), ee.emplaceBack(Nr, Nr + 2, Nr + 1), ee.emplaceBack(Nr + 1, Nr + 2, Nr + 3), le.vertexLength += 4, le.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Dt[0]), Q !== h.length - 1 && Fr === h[Q + 1].sectionIndex || c.programConfigurations.populatePaintArrays(te.length, A, A.index, {}, K, ke && ke[Fr]);
            }
            c.placedSymbolArray.emplaceBack(B.x, B.y, Ae, this.glyphOffsetArray.length - Ae, Te, N, z, B.segment, p ? p[0] : 0, p ? p[1] : 0, y[0], y[1], I, 0, !1, 0, j);
          }
          _addCollisionDebugVertex(c, h, p, y, x, A) {
            return h.emplaceBack(0, 0), c.emplaceBack(p.x, p.y, y, x, Math.round(A.x), Math.round(A.y));
          }
          addCollisionDebugVertices(c, h, p, y, x, A, I) {
            const B = x.segments.prepareSegment(4, x.layoutVertexArray, x.indexArray), N = B.vertexLength, z = x.layoutVertexArray, j = x.collisionVertexArray, K = I.anchorX, ee = I.anchorY;
            this._addCollisionDebugVertex(z, j, A, K, ee, new D(c, h)), this._addCollisionDebugVertex(z, j, A, K, ee, new D(p, h)), this._addCollisionDebugVertex(z, j, A, K, ee, new D(p, y)), this._addCollisionDebugVertex(z, j, A, K, ee, new D(c, y)), B.vertexLength += 4;
            const te = x.indexArray;
            te.emplaceBack(N, N + 1), te.emplaceBack(N + 1, N + 2), te.emplaceBack(N + 2, N + 3), te.emplaceBack(N + 3, N), B.primitiveLength += 4;
          }
          addDebugCollisionBoxes(c, h, p, y) {
            for (let x = c; x < h; x++) {
              const A = this.collisionBoxArray.get(x);
              this.addCollisionDebugVertices(A.x1, A.y1, A.x2, A.y2, y ? this.textCollisionBox : this.iconCollisionBox, A.anchorPoint, p);
            }
          }
          generateCollisionDebugBuffers() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new p0(Rt, jx.members, sr), this.iconCollisionBox = new p0(Rt, jx.members, sr);
            for (let c = 0; c < this.symbolInstances.length; c++) {
              const h = this.symbolInstances.get(c);
              this.addDebugCollisionBoxes(h.textBoxStartIndex, h.textBoxEndIndex, h, !0), this.addDebugCollisionBoxes(h.verticalTextBoxStartIndex, h.verticalTextBoxEndIndex, h, !0), this.addDebugCollisionBoxes(h.iconBoxStartIndex, h.iconBoxEndIndex, h, !1), this.addDebugCollisionBoxes(h.verticalIconBoxStartIndex, h.verticalIconBoxEndIndex, h, !1);
            }
          }
          _deserializeCollisionBoxesForSymbol(c, h, p, y, x, A, I, B, N) {
            const z = {};
            for (let j = h; j < p; j++) {
              const K = c.get(j);
              z.textBox = { x1: K.x1, y1: K.y1, x2: K.x2, y2: K.y2, anchorPointX: K.anchorPointX, anchorPointY: K.anchorPointY }, z.textFeatureIndex = K.featureIndex;
              break;
            }
            for (let j = y; j < x; j++) {
              const K = c.get(j);
              z.verticalTextBox = { x1: K.x1, y1: K.y1, x2: K.x2, y2: K.y2, anchorPointX: K.anchorPointX, anchorPointY: K.anchorPointY }, z.verticalTextFeatureIndex = K.featureIndex;
              break;
            }
            for (let j = A; j < I; j++) {
              const K = c.get(j);
              z.iconBox = { x1: K.x1, y1: K.y1, x2: K.x2, y2: K.y2, anchorPointX: K.anchorPointX, anchorPointY: K.anchorPointY }, z.iconFeatureIndex = K.featureIndex;
              break;
            }
            for (let j = B; j < N; j++) {
              const K = c.get(j);
              z.verticalIconBox = { x1: K.x1, y1: K.y1, x2: K.x2, y2: K.y2, anchorPointX: K.anchorPointX, anchorPointY: K.anchorPointY }, z.verticalIconFeatureIndex = K.featureIndex;
              break;
            }
            return z;
          }
          deserializeCollisionBoxes(c) {
            this.collisionArrays = [];
            for (let h = 0; h < this.symbolInstances.length; h++) {
              const p = this.symbolInstances.get(h);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(c, p.textBoxStartIndex, p.textBoxEndIndex, p.verticalTextBoxStartIndex, p.verticalTextBoxEndIndex, p.iconBoxStartIndex, p.iconBoxEndIndex, p.verticalIconBoxStartIndex, p.verticalIconBoxEndIndex));
            }
          }
          hasTextData() {
            return this.text.segments.get().length > 0;
          }
          hasIconData() {
            return this.icon.segments.get().length > 0;
          }
          hasDebugData() {
            return this.textCollisionBox && this.iconCollisionBox;
          }
          hasTextCollisionBoxData() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }
          hasIconCollisionBoxData() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }
          addIndicesForPlacedSymbol(c, h) {
            const p = c.placedSymbolArray.get(h), y = p.vertexStartIndex + 4 * p.numGlyphs;
            for (let x = p.vertexStartIndex; x < y; x += 4) c.indexArray.emplaceBack(x, x + 2, x + 1), c.indexArray.emplaceBack(x + 1, x + 2, x + 3);
          }
          getSortedSymbolIndexes(c) {
            if (this.sortedAngle === c && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
            const h = Math.sin(c), p = Math.cos(c), y = [], x = [], A = [];
            for (let I = 0; I < this.symbolInstances.length; ++I) {
              A.push(I);
              const B = this.symbolInstances.get(I);
              y.push(0 | Math.round(h * B.anchorX + p * B.anchorY)), x.push(B.featureIndex);
            }
            return A.sort((I, B) => y[I] - y[B] || x[B] - x[I]), A;
          }
          addToSortKeyRanges(c, h) {
            const p = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            p && p.sortKey === h ? p.symbolInstanceEnd = c + 1 : this.sortKeyRanges.push({ sortKey: h, symbolInstanceStart: c, symbolInstanceEnd: c + 1 });
          }
          sortFeatures(c) {
            if (this.sortFeaturesByY && this.sortedAngle !== c && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(c), this.sortedAngle = c, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (const h of this.symbolInstanceIndexes) {
                const p = this.symbolInstances.get(h);
                this.featureSortOrder.push(p.featureIndex), [p.rightJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.leftJustifiedTextSymbolIndex].forEach((y, x, A) => {
                  y >= 0 && A.indexOf(y) === x && this.addIndicesForPlacedSymbol(this.text, y);
                }), p.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, p.verticalPlacedTextSymbolIndex), p.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, p.placedIconSymbolIndex), p.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, p.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }
        }
        let tw, rw;
        vr("SymbolBucket", Wf, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Wf.MAX_GLYPHS = 65535, Wf.addDynamicAttributes = f0;
        var g0 = { get paint() {
          return rw = rw || new rn({ "icon-opacity": new Vt(ve.paint_symbol["icon-opacity"]), "icon-color": new Vt(ve.paint_symbol["icon-color"]), "icon-halo-color": new Vt(ve.paint_symbol["icon-halo-color"]), "icon-halo-width": new Vt(ve.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Vt(ve.paint_symbol["icon-halo-blur"]), "icon-translate": new dt(ve.paint_symbol["icon-translate"]), "icon-translate-anchor": new dt(ve.paint_symbol["icon-translate-anchor"]), "text-opacity": new Vt(ve.paint_symbol["text-opacity"]), "text-color": new Vt(ve.paint_symbol["text-color"], { runtimeType: Lr, getOverride: (f) => f.textColor, hasOverride: (f) => !!f.textColor }), "text-halo-color": new Vt(ve.paint_symbol["text-halo-color"]), "text-halo-width": new Vt(ve.paint_symbol["text-halo-width"]), "text-halo-blur": new Vt(ve.paint_symbol["text-halo-blur"]), "text-translate": new dt(ve.paint_symbol["text-translate"]), "text-translate-anchor": new dt(ve.paint_symbol["text-translate-anchor"]) });
        }, get layout() {
          return tw = tw || new rn({ "symbol-placement": new dt(ve.layout_symbol["symbol-placement"]), "symbol-spacing": new dt(ve.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new dt(ve.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Vt(ve.layout_symbol["symbol-sort-key"]), "symbol-z-order": new dt(ve.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new dt(ve.layout_symbol["icon-allow-overlap"]), "icon-overlap": new dt(ve.layout_symbol["icon-overlap"]), "icon-ignore-placement": new dt(ve.layout_symbol["icon-ignore-placement"]), "icon-optional": new dt(ve.layout_symbol["icon-optional"]), "icon-rotation-alignment": new dt(ve.layout_symbol["icon-rotation-alignment"]), "icon-size": new Vt(ve.layout_symbol["icon-size"]), "icon-text-fit": new dt(ve.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new dt(ve.layout_symbol["icon-text-fit-padding"]), "icon-image": new Vt(ve.layout_symbol["icon-image"]), "icon-rotate": new Vt(ve.layout_symbol["icon-rotate"]), "icon-padding": new Vt(ve.layout_symbol["icon-padding"]), "icon-keep-upright": new dt(ve.layout_symbol["icon-keep-upright"]), "icon-offset": new Vt(ve.layout_symbol["icon-offset"]), "icon-anchor": new Vt(ve.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new dt(ve.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new dt(ve.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new dt(ve.layout_symbol["text-rotation-alignment"]), "text-field": new Vt(ve.layout_symbol["text-field"]), "text-font": new Vt(ve.layout_symbol["text-font"]), "text-size": new Vt(ve.layout_symbol["text-size"]), "text-max-width": new Vt(ve.layout_symbol["text-max-width"]), "text-line-height": new dt(ve.layout_symbol["text-line-height"]), "text-letter-spacing": new Vt(ve.layout_symbol["text-letter-spacing"]), "text-justify": new Vt(ve.layout_symbol["text-justify"]), "text-radial-offset": new Vt(ve.layout_symbol["text-radial-offset"]), "text-variable-anchor": new dt(ve.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Vt(ve.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Vt(ve.layout_symbol["text-anchor"]), "text-max-angle": new dt(ve.layout_symbol["text-max-angle"]), "text-writing-mode": new dt(ve.layout_symbol["text-writing-mode"]), "text-rotate": new Vt(ve.layout_symbol["text-rotate"]), "text-padding": new dt(ve.layout_symbol["text-padding"]), "text-keep-upright": new dt(ve.layout_symbol["text-keep-upright"]), "text-transform": new Vt(ve.layout_symbol["text-transform"]), "text-offset": new Vt(ve.layout_symbol["text-offset"]), "text-allow-overlap": new dt(ve.layout_symbol["text-allow-overlap"]), "text-overlap": new dt(ve.layout_symbol["text-overlap"]), "text-ignore-placement": new dt(ve.layout_symbol["text-ignore-placement"]), "text-optional": new dt(ve.layout_symbol["text-optional"]) });
        } };
        class nw {
          constructor(c) {
            if (c.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
            this.type = c.property.overrides ? c.property.overrides.runtimeType : Mr, this.defaultValue = c;
          }
          evaluate(c) {
            if (c.formattedSection) {
              const h = this.defaultValue.property.overrides;
              if (h && h.hasOverride(c.formattedSection)) return h.getOverride(c.formattedSection);
            }
            return c.feature && c.featureState ? this.defaultValue.evaluate(c.feature, c.featureState) : this.defaultValue.property.specification.default;
          }
          eachChild(c) {
            this.defaultValue.isConstant() || c(this.defaultValue.value._styleExpression.expression);
          }
          outputDefined() {
            return !1;
          }
          serialize() {
            return null;
          }
        }
        vr("FormatSectionOverride", nw, { omit: ["defaultValue"] });
        class Yg extends on {
          constructor(c) {
            super(c, g0);
          }
          recalculate(c, h) {
            if (super.recalculate(c, h), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
              const p = this.layout.get("text-writing-mode");
              if (p) {
                const y = [];
                for (const x of p) y.indexOf(x) < 0 && y.push(x);
                this.layout._values["text-writing-mode"] = y;
              } else this.layout._values["text-writing-mode"] = ["horizontal"];
            }
            this._setPaintOverrides();
          }
          getValueAndResolveTokens(c, h, p, y) {
            const x = this.layout.get(c).evaluate(h, {}, p, y), A = this._unevaluatedLayout._values[c];
            return A.isDataDriven() || Fa(A.value) || !x ? x : function(I, B) {
              return B.replace(/{([^{}]+)}/g, (N, z) => I && z in I ? String(I[z]) : "");
            }(h.properties, x);
          }
          createBucket(c) {
            return new Wf(c);
          }
          queryRadius() {
            return 0;
          }
          queryIntersectsFeature() {
            throw new Error("Should take a different path in FeatureIndex");
          }
          _setPaintOverrides() {
            for (const c of g0.paint.overridableProperties) {
              if (!Yg.hasPaintOverride(this.layout, c)) continue;
              const h = this.paint.get(c), p = new nw(h), y = new pl(p, h.property.specification);
              let x = null;
              x = h.value.kind === "constant" || h.value.kind === "source" ? new gl("source", y) : new Kl("composite", y, h.value.zoomStops), this.paint._values[c] = new qt(h.property, x, h.parameters);
            }
          }
          _handleOverridablePaintPropertyUpdate(c, h, p) {
            return !(!this.layout || h.isDataDriven() || p.isDataDriven()) && Yg.hasPaintOverride(this.layout, c);
          }
          static hasPaintOverride(c, h) {
            const p = c.get("text-field"), y = g0.paint.properties[h];
            let x = !1;
            const A = (I) => {
              for (const B of I) if (y.overrides && y.overrides.hasOverride(B)) return void (x = !0);
            };
            if (p.value.kind === "constant" && p.value.value instanceof oi) A(p.value.value.sections);
            else if (p.value.kind === "source") {
              const I = (N) => {
                x || (N instanceof uo && an(N.value) === Zi ? A(N.value.sections) : N instanceof Ma ? A(N.sections) : N.eachChild(I));
              }, B = p.value;
              B._styleExpression && I(B._styleExpression.expression);
            }
            return x;
          }
        }
        let iw;
        var QP = { get paint() {
          return iw = iw || new rn({ "background-color": new dt(ve.paint_background["background-color"]), "background-pattern": new Ur(ve.paint_background["background-pattern"]), "background-opacity": new dt(ve.paint_background["background-opacity"]) });
        } };
        class eR extends on {
          constructor(c) {
            super(c, QP);
          }
        }
        let sw;
        var tR = { get paint() {
          return sw = sw || new rn({ "raster-opacity": new dt(ve.paint_raster["raster-opacity"]), "raster-hue-rotate": new dt(ve.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new dt(ve.paint_raster["raster-brightness-min"]), "raster-brightness-max": new dt(ve.paint_raster["raster-brightness-max"]), "raster-saturation": new dt(ve.paint_raster["raster-saturation"]), "raster-contrast": new dt(ve.paint_raster["raster-contrast"]), "raster-resampling": new dt(ve.paint_raster["raster-resampling"]), "raster-fade-duration": new dt(ve.paint_raster["raster-fade-duration"]) });
        } };
        class rR extends on {
          constructor(c) {
            super(c, tR);
          }
        }
        class nR extends on {
          constructor(c) {
            super(c, {}), this.onAdd = (h) => {
              this.implementation.onAdd && this.implementation.onAdd(h, h.painter.context.gl);
            }, this.onRemove = (h) => {
              this.implementation.onRemove && this.implementation.onRemove(h, h.painter.context.gl);
            }, this.implementation = c;
          }
          is3D() {
            return this.implementation.renderingMode === "3d";
          }
          hasOffscreenPass() {
            return this.implementation.prerender !== void 0;
          }
          recalculate() {
          }
          updateTransitions() {
          }
          hasTransition() {
            return !1;
          }
          serialize() {
            throw new Error("Custom layers cannot be serialized");
          }
        }
        class iR {
          constructor(c) {
            this._methodToThrottle = c, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
              this._triggered = !1, this._methodToThrottle();
            });
          }
          trigger() {
            this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
              this._triggered = !1, this._methodToThrottle();
            }, 0));
          }
          remove() {
            delete this._channel, this._methodToThrottle = () => {
            };
          }
        }
        const m0 = 63710088e-1;
        class ih {
          constructor(c, h) {
            if (isNaN(c) || isNaN(h)) throw new Error(`Invalid LngLat object: (${c}, ${h})`);
            if (this.lng = +c, this.lat = +h, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          }
          wrap() {
            return new ih(Ue(this.lng, -180, 180), this.lat);
          }
          toArray() {
            return [this.lng, this.lat];
          }
          toString() {
            return `LngLat(${this.lng}, ${this.lat})`;
          }
          distanceTo(c) {
            const h = Math.PI / 180, p = this.lat * h, y = c.lat * h, x = Math.sin(p) * Math.sin(y) + Math.cos(p) * Math.cos(y) * Math.cos((c.lng - this.lng) * h);
            return m0 * Math.acos(Math.min(x, 1));
          }
          static convert(c) {
            if (c instanceof ih) return c;
            if (Array.isArray(c) && (c.length === 2 || c.length === 3)) return new ih(Number(c[0]), Number(c[1]));
            if (!Array.isArray(c) && typeof c == "object" && c !== null) return new ih(Number("lng" in c ? c.lng : c.lon), Number(c.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          }
        }
        const ow = 2 * Math.PI * m0;
        function aw(f) {
          return ow * Math.cos(f * Math.PI / 180);
        }
        function lw(f) {
          return (180 + f) / 360;
        }
        function cw(f) {
          return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + f * Math.PI / 360))) / 360;
        }
        function uw(f, c) {
          return f / aw(c);
        }
        function _0(f) {
          return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * f) * Math.PI / 180)) - 90;
        }
        function hw(f, c) {
          return f * aw(_0(c));
        }
        class Ap {
          constructor(c, h) {
            let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            this.x = +c, this.y = +h, this.z = +p;
          }
          static fromLngLat(c) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
            const p = ih.convert(c);
            return new Ap(lw(p.lng), cw(p.lat), uw(h, p.lat));
          }
          toLngLat() {
            return new ih(360 * this.x - 180, _0(this.y));
          }
          toAltitude() {
            return hw(this.z, this.y);
          }
          meterInMercatorCoordinateUnits() {
            return 1 / ow * (c = _0(this.y), 1 / Math.cos(c * Math.PI / 180));
            var c;
          }
        }
        function fw(f, c, h) {
          var p = 2 * Math.PI * 6378137 / 256 / Math.pow(2, h);
          return [f * p - 2 * Math.PI * 6378137 / 2, c * p - 2 * Math.PI * 6378137 / 2];
        }
        class y0 {
          constructor(c, h, p) {
            if (!function(y, x, A) {
              return !(y < 0 || y > 25 || A < 0 || A >= Math.pow(2, y) || x < 0 || x >= Math.pow(2, y));
            }(c, h, p)) throw new Error(`x=${h}, y=${p}, z=${c} outside of bounds. 0<=x<${Math.pow(2, c)}, 0<=y<${Math.pow(2, c)} 0<=z<=25 `);
            this.z = c, this.x = h, this.y = p, this.key = Xf(0, c, c, h, p);
          }
          equals(c) {
            return this.z === c.z && this.x === c.x && this.y === c.y;
          }
          url(c, h, p) {
            const y = (A = this.y, I = this.z, B = fw(256 * (x = this.x), 256 * (A = Math.pow(2, I) - A - 1), I), N = fw(256 * (x + 1), 256 * (A + 1), I), B[0] + "," + B[1] + "," + N[0] + "," + N[1]);
            var x, A, I, B, N;
            const z = function(j, K, ee) {
              let te, le = "";
              for (let Ae = j; Ae > 0; Ae--) te = 1 << Ae - 1, le += (K & te ? 1 : 0) + (ee & te ? 2 : 0);
              return le;
            }(this.z, this.x, this.y);
            return c[(this.x + this.y) % c.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(p === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, h > 1 ? "@2x" : "").replace(/{quadkey}/g, z).replace(/{bbox-epsg-3857}/g, y);
          }
          isChildOf(c) {
            const h = this.z - c.z;
            return h > 0 && c.x === this.x >> h && c.y === this.y >> h;
          }
          getTilePoint(c) {
            const h = Math.pow(2, this.z);
            return new D((c.x * h - this.x) * ht, (c.y * h - this.y) * ht);
          }
          toString() {
            return `${this.z}/${this.x}/${this.y}`;
          }
        }
        class dw {
          constructor(c, h) {
            this.wrap = c, this.canonical = h, this.key = Xf(c, h.z, h.z, h.x, h.y);
          }
        }
        class qa {
          constructor(c, h, p, y, x) {
            if (this.terrainRttPosMatrix32f = null, c < p) throw new Error(`overscaledZ should be >= z; overscaledZ = ${c}; z = ${p}`);
            this.overscaledZ = c, this.wrap = h, this.canonical = new y0(p, +y, +x), this.key = Xf(h, c, p, y, x);
          }
          clone() {
            return new qa(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          equals(c) {
            return this.overscaledZ === c.overscaledZ && this.wrap === c.wrap && this.canonical.equals(c.canonical);
          }
          scaledTo(c) {
            if (c > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${c}; overscaledZ = ${this.overscaledZ}`);
            const h = this.canonical.z - c;
            return c > this.canonical.z ? new qa(c, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new qa(c, this.wrap, c, this.canonical.x >> h, this.canonical.y >> h);
          }
          calculateScaledKey(c, h) {
            if (c > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${c}; overscaledZ = ${this.overscaledZ}`);
            const p = this.canonical.z - c;
            return c > this.canonical.z ? Xf(this.wrap * +h, c, this.canonical.z, this.canonical.x, this.canonical.y) : Xf(this.wrap * +h, c, c, this.canonical.x >> p, this.canonical.y >> p);
          }
          isChildOf(c) {
            if (c.wrap !== this.wrap) return !1;
            const h = this.canonical.z - c.canonical.z;
            return c.overscaledZ === 0 || c.overscaledZ < this.overscaledZ && c.canonical.x === this.canonical.x >> h && c.canonical.y === this.canonical.y >> h;
          }
          children(c) {
            if (this.overscaledZ >= c) return [new qa(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            const h = this.canonical.z + 1, p = 2 * this.canonical.x, y = 2 * this.canonical.y;
            return [new qa(h, this.wrap, h, p, y), new qa(h, this.wrap, h, p + 1, y), new qa(h, this.wrap, h, p, y + 1), new qa(h, this.wrap, h, p + 1, y + 1)];
          }
          isLessThan(c) {
            return this.wrap < c.wrap || !(this.wrap > c.wrap) && (this.overscaledZ < c.overscaledZ || !(this.overscaledZ > c.overscaledZ) && (this.canonical.x < c.canonical.x || !(this.canonical.x > c.canonical.x) && this.canonical.y < c.canonical.y));
          }
          wrapped() {
            return new qa(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          unwrapTo(c) {
            return new qa(this.overscaledZ, c, this.canonical.z, this.canonical.x, this.canonical.y);
          }
          overscaleFactor() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }
          toUnwrapped() {
            return new dw(this.wrap, this.canonical);
          }
          toString() {
            return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
          }
          getTilePoint(c) {
            return this.canonical.getTilePoint(new Ap(c.x - this.wrap, c.y));
          }
        }
        function Xf(f, c, h, p, y) {
          (f *= 2) < 0 && (f = -1 * f - 1);
          const x = 1 << h;
          return (x * x * f + x * y + p).toString(36) + h.toString(36) + c.toString(36);
        }
        vr("CanonicalTileID", y0), vr("OverscaledTileID", qa, { omit: ["terrainRttPosMatrix32f"] });
        class pw {
          constructor(c, h, p) {
            let y = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1, A = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1, I = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
            if (this.uid = c, h.height !== h.width) throw new RangeError("DEM tiles must be square");
            if (p && !["mapbox", "terrarium", "custom"].includes(p)) return void Yt(`"${p}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
            this.stride = h.height;
            const B = this.dim = h.height - 2;
            switch (this.data = new Uint32Array(h.data.buffer), p) {
              case "terrarium":
                this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                break;
              case "custom":
                this.redFactor = y, this.greenFactor = x, this.blueFactor = A, this.baseShift = I;
                break;
              default:
                this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
            }
            for (let N = 0; N < B; N++) this.data[this._idx(-1, N)] = this.data[this._idx(0, N)], this.data[this._idx(B, N)] = this.data[this._idx(B - 1, N)], this.data[this._idx(N, -1)] = this.data[this._idx(N, 0)], this.data[this._idx(N, B)] = this.data[this._idx(N, B - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(B, -1)] = this.data[this._idx(B - 1, 0)], this.data[this._idx(-1, B)] = this.data[this._idx(0, B - 1)], this.data[this._idx(B, B)] = this.data[this._idx(B - 1, B - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
            for (let N = 0; N < B; N++) for (let z = 0; z < B; z++) {
              const j = this.get(N, z);
              j > this.max && (this.max = j), j < this.min && (this.min = j);
            }
          }
          get(c, h) {
            const p = new Uint8Array(this.data.buffer), y = 4 * this._idx(c, h);
            return this.unpack(p[y], p[y + 1], p[y + 2]);
          }
          getUnpackVector() {
            return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
          }
          _idx(c, h) {
            if (c < -1 || c >= this.dim + 1 || h < -1 || h >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
            return (h + 1) * this.stride + (c + 1);
          }
          unpack(c, h, p) {
            return c * this.redFactor + h * this.greenFactor + p * this.blueFactor - this.baseShift;
          }
          getPixels() {
            return new Va({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }
          backfillBorder(c, h, p) {
            if (this.dim !== c.dim) throw new Error("dem dimension mismatch");
            let y = h * this.dim, x = h * this.dim + this.dim, A = p * this.dim, I = p * this.dim + this.dim;
            switch (h) {
              case -1:
                y = x - 1;
                break;
              case 1:
                x = y + 1;
            }
            switch (p) {
              case -1:
                A = I - 1;
                break;
              case 1:
                I = A + 1;
            }
            const B = -h * this.dim, N = -p * this.dim;
            for (let z = A; z < I; z++) for (let j = y; j < x; j++) this.data[this._idx(j, z)] = c.data[this._idx(j + B, z + N)];
          }
        }
        vr("DEMData", pw);
        class gw {
          constructor(c) {
            this._stringToNumber = {}, this._numberToString = [];
            for (let h = 0; h < c.length; h++) {
              const p = c[h];
              this._stringToNumber[p] = h, this._numberToString[h] = p;
            }
          }
          encode(c) {
            return this._stringToNumber[c];
          }
          decode(c) {
            if (c >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${c} can't be >= this._numberToString.length ${this._numberToString.length}`);
            return this._numberToString[c];
          }
        }
        class mw {
          constructor(c, h, p, y, x) {
            this.type = "Feature", this._vectorTileFeature = c, c._z = h, c._x = p, c._y = y, this.properties = c.properties, this.id = x;
          }
          get geometry() {
            return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }
          set geometry(c) {
            this._geometry = c;
          }
          toJSON() {
            const c = { geometry: this.geometry };
            for (const h in this) h !== "_geometry" && h !== "_vectorTileFeature" && (c[h] = this[h]);
            return c;
          }
        }
        class _w {
          constructor(c, h) {
            this.tileID = c, this.x = c.canonical.x, this.y = c.canonical.y, this.z = c.canonical.z, this.grid = new bl(ht, 16, 0), this.grid3D = new bl(ht, 16, 0), this.featureIndexArray = new Ce(), this.promoteId = h;
          }
          insert(c, h, p, y, x, A) {
            const I = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(p, y, x);
            const B = A ? this.grid3D : this.grid;
            for (let N = 0; N < h.length; N++) {
              const z = h[N], j = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
              for (let K = 0; K < z.length; K++) {
                const ee = z[K];
                j[0] = Math.min(j[0], ee.x), j[1] = Math.min(j[1], ee.y), j[2] = Math.max(j[2], ee.x), j[3] = Math.max(j[3], ee.y);
              }
              j[0] < ht && j[1] < ht && j[2] >= 0 && j[3] >= 0 && B.insert(I, j[0], j[1], j[2], j[3]);
            }
          }
          loadVTLayers() {
            return this.vtLayers || (this.vtLayers = new _p.VectorTile(new o0(this.rawTileData)).layers, this.sourceLayerCoder = new gw(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }
          query(c, h, p, y) {
            this.loadVTLayers();
            const x = c.params, A = ht / c.tileSize / c.scale, I = Ql(x.filter), B = c.queryGeometry, N = c.queryPadding * A, z = bw(B), j = this.grid.query(z.minX - N, z.minY - N, z.maxX + N, z.maxY + N), K = bw(c.cameraQueryGeometry), ee = this.grid3D.query(K.minX - N, K.minY - N, K.maxX + N, K.maxY + N, (Ae, Te, Qe, ke) => function(Q, xe, ze, yt, $t) {
              for (const Lt of Q) if (xe <= Lt.x && ze <= Lt.y && yt >= Lt.x && $t >= Lt.y) return !0;
              const It = [new D(xe, ze), new D(xe, $t), new D(yt, $t), new D(yt, ze)];
              if (Q.length > 2) {
                for (const Lt of It) if (Vf(Q, Lt)) return !0;
              }
              for (let Lt = 0; Lt < Q.length - 1; Lt++) if (WM(Q[Lt], Q[Lt + 1], It)) return !0;
              return !1;
            }(c.cameraQueryGeometry, Ae - N, Te - N, Qe + N, ke + N));
            for (const Ae of ee) j.push(Ae);
            j.sort(sR);
            const te = {};
            let le;
            for (let Ae = 0; Ae < j.length; Ae++) {
              const Te = j[Ae];
              if (Te === le) continue;
              le = Te;
              const Qe = this.featureIndexArray.get(Te);
              let ke = null;
              this.loadMatchingFeature(te, Qe.bucketIndex, Qe.sourceLayerIndex, Qe.featureIndex, I, x.layers, x.availableImages, h, p, y, (Q, xe, ze) => (ke || (ke = Mu(Q)), xe.queryIntersectsFeature({ queryGeometry: B, feature: Q, featureState: ze, geometry: ke, zoom: this.z, transform: c.transform, pixelsToTileUnits: A, pixelPosMatrix: c.pixelPosMatrix })));
            }
            return te;
          }
          loadMatchingFeature(c, h, p, y, x, A, I, B, N, z, j) {
            const K = this.bucketLayerIDs[h];
            if (A && !K.some((Ae) => A.has(Ae))) return;
            const ee = this.sourceLayerCoder.decode(p), te = this.vtLayers[ee].feature(y);
            if (x.needGeometry) {
              const Ae = Pu(te, !0);
              if (!x.filter(new ot(this.tileID.overscaledZ), Ae, this.tileID.canonical)) return;
            } else if (!x.filter(new ot(this.tileID.overscaledZ), te)) return;
            const le = this.getId(te, ee);
            for (let Ae = 0; Ae < K.length; Ae++) {
              const Te = K[Ae];
              if (A && !A.has(Te)) continue;
              const Qe = B[Te];
              if (!Qe) continue;
              let ke = {};
              le && z && (ke = z.getState(Qe.sourceLayer || "_geojsonTileLayer", le));
              const Q = Xe({}, N[Te]);
              Q.paint = yw(Q.paint, Qe.paint, te, ke, I), Q.layout = yw(Q.layout, Qe.layout, te, ke, I);
              const xe = !j || j(te, Qe, ke);
              if (!xe) continue;
              const ze = new mw(te, this.z, this.x, this.y, le);
              ze.layer = Q;
              let yt = c[Te];
              yt === void 0 && (yt = c[Te] = []), yt.push({ featureIndex: y, feature: ze, intersectionZ: xe });
            }
          }
          lookupSymbolFeatures(c, h, p, y, x, A, I, B) {
            const N = {};
            this.loadVTLayers();
            const z = Ql(x);
            for (const j of c) this.loadMatchingFeature(N, p, y, j, z, A, I, B, h);
            return N;
          }
          hasLayer(c) {
            for (const h of this.bucketLayerIDs) for (const p of h) if (c === p) return !0;
            return !1;
          }
          getId(c, h) {
            var p;
            let y = c.id;
            return this.promoteId && (y = c.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[h]], typeof y == "boolean" && (y = Number(y)), y === void 0 && (!((p = c.properties) === null || p === void 0) && p.cluster) && this.promoteId && (y = Number(c.properties.cluster_id))), y;
          }
        }
        function yw(f, c, h, p, y) {
          return ft(f, (x, A) => {
            const I = c instanceof Zt ? c.get(A) : null;
            return I && I.evaluate ? I.evaluate(h, p, y) : I;
          });
        }
        function bw(f) {
          let c = 1 / 0, h = 1 / 0, p = -1 / 0, y = -1 / 0;
          for (const x of f) c = Math.min(c, x.x), h = Math.min(h, x.y), p = Math.max(p, x.x), y = Math.max(y, x.y);
          return { minX: c, minY: h, maxX: p, maxY: y };
        }
        function sR(f, c) {
          return c - f;
        }
        function vw(f, c, h, p, y) {
          const x = [];
          for (let A = 0; A < f.length; A++) {
            const I = f[A];
            let B;
            for (let N = 0; N < I.length - 1; N++) {
              let z = I[N], j = I[N + 1];
              z.x < c && j.x < c || (z.x < c ? z = new D(c, z.y + (c - z.x) / (j.x - z.x) * (j.y - z.y))._round() : j.x < c && (j = new D(c, z.y + (c - z.x) / (j.x - z.x) * (j.y - z.y))._round()), z.y < h && j.y < h || (z.y < h ? z = new D(z.x + (h - z.y) / (j.y - z.y) * (j.x - z.x), h)._round() : j.y < h && (j = new D(z.x + (h - z.y) / (j.y - z.y) * (j.x - z.x), h)._round()), z.x >= p && j.x >= p || (z.x >= p ? z = new D(p, z.y + (p - z.x) / (j.x - z.x) * (j.y - z.y))._round() : j.x >= p && (j = new D(p, z.y + (p - z.x) / (j.x - z.x) * (j.y - z.y))._round()), z.y >= y && j.y >= y || (z.y >= y ? z = new D(z.x + (y - z.y) / (j.y - z.y) * (j.x - z.x), y)._round() : j.y >= y && (j = new D(z.x + (y - z.y) / (j.y - z.y) * (j.x - z.x), y)._round()), B && z.equals(B[B.length - 1]) || (B = [z], x.push(B)), B.push(j)))));
            }
          }
          return x;
        }
        vr("FeatureIndex", _w, { omit: ["rawTileData", "sourceLayerCoder"] });
        class sh extends D {
          constructor(c, h, p, y) {
            super(c, h), this.angle = p, y !== void 0 && (this.segment = y);
          }
          clone() {
            return new sh(this.x, this.y, this.angle, this.segment);
          }
        }
        function xw(f, c, h, p, y) {
          if (c.segment === void 0 || h === 0) return !0;
          let x = c, A = c.segment + 1, I = 0;
          for (; I > -h / 2; ) {
            if (A--, A < 0) return !1;
            I -= f[A].dist(x), x = f[A];
          }
          I += f[A].dist(f[A + 1]), A++;
          const B = [];
          let N = 0;
          for (; I < h / 2; ) {
            const z = f[A], j = f[A + 1];
            if (!j) return !1;
            let K = f[A - 1].angleTo(z) - z.angleTo(j);
            for (K = Math.abs((K + 3 * Math.PI) % (2 * Math.PI) - Math.PI), B.push({ distance: I, angleDelta: K }), N += K; I - B[0].distance > p; ) N -= B.shift().angleDelta;
            if (N > y) return !1;
            A++, I += z.dist(j);
          }
          return !0;
        }
        function ww(f) {
          let c = 0;
          for (let h = 0; h < f.length - 1; h++) c += f[h].dist(f[h + 1]);
          return c;
        }
        function Aw(f, c, h) {
          return f ? 0.6 * c * h : 0;
        }
        function Tw(f, c) {
          return Math.max(f ? f.right - f.left : 0, c ? c.right - c.left : 0);
        }
        function oR(f, c, h, p, y, x) {
          const A = Aw(h, y, x), I = Tw(h, p) * x;
          let B = 0;
          const N = ww(f) / 2;
          for (let z = 0; z < f.length - 1; z++) {
            const j = f[z], K = f[z + 1], ee = j.dist(K);
            if (B + ee > N) {
              const te = (N - B) / ee, le = ho.number(j.x, K.x, te), Ae = ho.number(j.y, K.y, te), Te = new sh(le, Ae, K.angleTo(j), z);
              return Te._round(), !A || xw(f, Te, I, A, c) ? Te : void 0;
            }
            B += ee;
          }
        }
        function aR(f, c, h, p, y, x, A, I, B) {
          const N = Aw(p, x, A), z = Tw(p, y), j = z * A, K = f[0].x === 0 || f[0].x === B || f[0].y === 0 || f[0].y === B;
          return c - j < c / 4 && (c = j + c / 4), Sw(f, K ? c / 2 * I % c : (z / 2 + 2 * x) * A * I % c, c, N, h, j, K, !1, B);
        }
        function Sw(f, c, h, p, y, x, A, I, B) {
          const N = x / 2, z = ww(f);
          let j = 0, K = c - h, ee = [];
          for (let te = 0; te < f.length - 1; te++) {
            const le = f[te], Ae = f[te + 1], Te = le.dist(Ae), Qe = Ae.angleTo(le);
            for (; K + h < j + Te; ) {
              K += h;
              const ke = (K - j) / Te, Q = ho.number(le.x, Ae.x, ke), xe = ho.number(le.y, Ae.y, ke);
              if (Q >= 0 && Q < B && xe >= 0 && xe < B && K - N >= 0 && K + N <= z) {
                const ze = new sh(Q, xe, Qe, te);
                ze._round(), p && !xw(f, ze, x, p, y) || ee.push(ze);
              }
            }
            j += Te;
          }
          return I || ee.length || A || (ee = Sw(f, j / 2, h, p, y, x, A, !0, B)), ee;
        }
        vr("Anchor", sh);
        const Tp = na;
        function Ew(f, c, h, p) {
          const y = [], x = f.image, A = x.pixelRatio, I = x.paddedRect.w - 2 * Tp, B = x.paddedRect.h - 2 * Tp;
          let N = { x1: f.left, y1: f.top, x2: f.right, y2: f.bottom };
          const z = x.stretchX || [[0, I]], j = x.stretchY || [[0, B]], K = (Dt, Er) => Dt + Er[1] - Er[0], ee = z.reduce(K, 0), te = j.reduce(K, 0), le = I - ee, Ae = B - te;
          let Te = 0, Qe = ee, ke = 0, Q = te, xe = 0, ze = le, yt = 0, $t = Ae;
          if (x.content && p) {
            const Dt = x.content, Er = Dt[2] - Dt[0], Fr = Dt[3] - Dt[1];
            (x.textFitWidth || x.textFitHeight) && (N = Jx(f)), Te = Kg(z, 0, Dt[0]), ke = Kg(j, 0, Dt[1]), Qe = Kg(z, Dt[0], Dt[2]), Q = Kg(j, Dt[1], Dt[3]), xe = Dt[0] - Te, yt = Dt[1] - ke, ze = Er - Qe, $t = Fr - Q;
          }
          const It = N.x1, Lt = N.y1, er = N.x2 - It, Xt = N.y2 - Lt, ir = (Dt, Er, Fr, Nr) => {
            const Pr = Jg(Dt.stretch - Te, Qe, er, It), _n = Qg(Dt.fixed - xe, ze, Dt.stretch, ee), Di = Jg(Er.stretch - ke, Q, Xt, Lt), rs = Qg(Er.fixed - yt, $t, Er.stretch, te), Lo = Jg(Fr.stretch - Te, Qe, er, It), ia = Qg(Fr.fixed - xe, ze, Fr.stretch, ee), sa = Jg(Nr.stretch - ke, Q, Xt, Lt), $s = Qg(Nr.fixed - yt, $t, Nr.stretch, te), Vi = new D(Pr, Di), vs = new D(Lo, Di), Hs = new D(Lo, sa), ns = new D(Pr, sa), Oo = new D(_n / A, rs / A), Ga = new D(ia / A, $s / A), Bs = c * Math.PI / 180;
            if (Bs) {
              const Ls = Math.sin(Bs), Os = Math.cos(Bs), is = [Os, -Ls, Ls, Os];
              Vi._matMult(is), vs._matMult(is), ns._matMult(is), Hs._matMult(is);
            }
            const oa = Dt.stretch + Dt.fixed, xs = Er.stretch + Er.fixed;
            return { tl: Vi, tr: vs, bl: ns, br: Hs, tex: { x: x.paddedRect.x + Tp + oa, y: x.paddedRect.y + Tp + xs, w: Fr.stretch + Fr.fixed - oa, h: Nr.stretch + Nr.fixed - xs }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: Oo, pixelOffsetBR: Ga, minFontScaleX: ze / A / er, minFontScaleY: $t / A / Xt, isSDF: h };
          };
          if (p && (x.stretchX || x.stretchY)) {
            const Dt = Cw(z, le, ee), Er = Cw(j, Ae, te);
            for (let Fr = 0; Fr < Dt.length - 1; Fr++) {
              const Nr = Dt[Fr], Pr = Dt[Fr + 1];
              for (let _n = 0; _n < Er.length - 1; _n++) y.push(ir(Nr, Er[_n], Pr, Er[_n + 1]));
            }
          } else y.push(ir({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: I + 1 }, { fixed: 0, stretch: B + 1 }));
          return y;
        }
        function Kg(f, c, h) {
          let p = 0;
          for (const y of f) p += Math.max(c, Math.min(h, y[1])) - Math.max(c, Math.min(h, y[0]));
          return p;
        }
        function Cw(f, c, h) {
          const p = [{ fixed: -1, stretch: 0 }];
          for (const [y, x] of f) {
            const A = p[p.length - 1];
            p.push({ fixed: y - A.stretch, stretch: A.stretch }), p.push({ fixed: y - A.stretch, stretch: A.stretch + (x - y) });
          }
          return p.push({ fixed: c + Tp, stretch: h }), p;
        }
        function Jg(f, c, h, p) {
          return f / c * h + p;
        }
        function Qg(f, c, h, p) {
          return f - c * h / p;
        }
        class em {
          constructor(c, h, p, y, x, A, I, B, N, z) {
            var j;
            if (this.boxStartIndex = c.length, N) {
              let K = A.top, ee = A.bottom;
              const te = A.collisionPadding;
              te && (K -= te[1], ee += te[3]);
              let le = ee - K;
              le > 0 && (le = Math.max(10, le), this.circleDiameter = le);
            } else {
              const K = !((j = A.image) === null || j === void 0) && j.content && (A.image.textFitWidth || A.image.textFitHeight) ? Jx(A) : { x1: A.left, y1: A.top, x2: A.right, y2: A.bottom };
              K.y1 = K.y1 * I - B[0], K.y2 = K.y2 * I + B[2], K.x1 = K.x1 * I - B[3], K.x2 = K.x2 * I + B[1];
              const ee = A.collisionPadding;
              if (ee && (K.x1 -= ee[0] * I, K.y1 -= ee[1] * I, K.x2 += ee[2] * I, K.y2 += ee[3] * I), z) {
                const te = new D(K.x1, K.y1), le = new D(K.x2, K.y1), Ae = new D(K.x1, K.y2), Te = new D(K.x2, K.y2), Qe = z * Math.PI / 180;
                te._rotate(Qe), le._rotate(Qe), Ae._rotate(Qe), Te._rotate(Qe), K.x1 = Math.min(te.x, le.x, Ae.x, Te.x), K.x2 = Math.max(te.x, le.x, Ae.x, Te.x), K.y1 = Math.min(te.y, le.y, Ae.y, Te.y), K.y2 = Math.max(te.y, le.y, Ae.y, Te.y);
              }
              c.emplaceBack(h.x, h.y, K.x1, K.y1, K.x2, K.y2, p, y, x);
            }
            this.boxEndIndex = c.length;
          }
        }
        class lR {
          constructor() {
            let c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (p, y) => p < y ? -1 : p > y ? 1 : 0;
            if (this.data = c, this.length = this.data.length, this.compare = h, this.length > 0) for (let p = (this.length >> 1) - 1; p >= 0; p--) this._down(p);
          }
          push(c) {
            this.data.push(c), this._up(this.length++);
          }
          pop() {
            if (this.length === 0) return;
            const c = this.data[0], h = this.data.pop();
            return --this.length > 0 && (this.data[0] = h, this._down(0)), c;
          }
          peek() {
            return this.data[0];
          }
          _up(c) {
            const { data: h, compare: p } = this, y = h[c];
            for (; c > 0; ) {
              const x = c - 1 >> 1, A = h[x];
              if (p(y, A) >= 0) break;
              h[c] = A, c = x;
            }
            h[c] = y;
          }
          _down(c) {
            const { data: h, compare: p } = this, y = this.length >> 1, x = h[c];
            for (; c < y; ) {
              let A = 1 + (c << 1);
              const I = A + 1;
              if (I < this.length && p(h[I], h[A]) < 0 && (A = I), p(h[A], x) >= 0) break;
              h[c] = h[A], c = A;
            }
            h[c] = x;
          }
        }
        function cR(f) {
          let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, p = 1 / 0, y = 1 / 0, x = -1 / 0, A = -1 / 0;
          const I = f[0];
          for (let ee = 0; ee < I.length; ee++) {
            const te = I[ee];
            (!ee || te.x < p) && (p = te.x), (!ee || te.y < y) && (y = te.y), (!ee || te.x > x) && (x = te.x), (!ee || te.y > A) && (A = te.y);
          }
          const B = Math.min(x - p, A - y);
          let N = B / 2;
          const z = new lR([], uR);
          if (B === 0) return new D(p, y);
          for (let ee = p; ee < x; ee += B) for (let te = y; te < A; te += B) z.push(new Zf(ee + N, te + N, N, f));
          let j = function(ee) {
            let te = 0, le = 0, Ae = 0;
            const Te = ee[0];
            for (let Qe = 0, ke = Te.length, Q = ke - 1; Qe < ke; Q = Qe++) {
              const xe = Te[Qe], ze = Te[Q], yt = xe.x * ze.y - ze.x * xe.y;
              le += (xe.x + ze.x) * yt, Ae += (xe.y + ze.y) * yt, te += 3 * yt;
            }
            return new Zf(le / te, Ae / te, 0, ee);
          }(f), K = z.length;
          for (; z.length; ) {
            const ee = z.pop();
            (ee.d > j.d || !j.d) && (j = ee, h && console.log("found best %d after %d probes", Math.round(1e4 * ee.d) / 1e4, K)), ee.max - j.d <= c || (N = ee.h / 2, z.push(new Zf(ee.p.x - N, ee.p.y - N, N, f)), z.push(new Zf(ee.p.x + N, ee.p.y - N, N, f)), z.push(new Zf(ee.p.x - N, ee.p.y + N, N, f)), z.push(new Zf(ee.p.x + N, ee.p.y + N, N, f)), K += 4);
          }
          return h && (console.log(`num probes: ${K}`), console.log(`best distance: ${j.d}`)), j.p;
        }
        function uR(f, c) {
          return c.max - f.max;
        }
        function Zf(f, c, h, p) {
          this.p = new D(f, c), this.h = h, this.d = function(y, x) {
            let A = !1, I = 1 / 0;
            for (let B = 0; B < x.length; B++) {
              const N = x[B];
              for (let z = 0, j = N.length, K = j - 1; z < j; K = z++) {
                const ee = N[z], te = N[K];
                ee.y > y.y != te.y > y.y && y.x < (te.x - ee.x) * (y.y - ee.y) / (te.y - ee.y) + ee.x && (A = !A), I = Math.min(I, ax(y, ee, te));
              }
            }
            return (A ? 1 : -1) * Math.sqrt(I);
          }(this.p, p), this.max = this.d + this.h * Math.SQRT2;
        }
        var no;
        l.aw = void 0, (no = l.aw || (l.aw = {}))[no.center = 1] = "center", no[no.left = 2] = "left", no[no.right = 3] = "right", no[no.top = 4] = "top", no[no.bottom = 5] = "bottom", no[no["top-left"] = 6] = "top-left", no[no["top-right"] = 7] = "top-right", no[no["bottom-left"] = 8] = "bottom-left", no[no["bottom-right"] = 9] = "bottom-right";
        const oh = 7, b0 = Number.POSITIVE_INFINITY;
        function Iw(f, c) {
          return c[1] !== b0 ? function(h, p, y) {
            let x = 0, A = 0;
            switch (p = Math.abs(p), y = Math.abs(y), h) {
              case "top-right":
              case "top-left":
              case "top":
                A = y - oh;
                break;
              case "bottom-right":
              case "bottom-left":
              case "bottom":
                A = -y + oh;
            }
            switch (h) {
              case "top-right":
              case "bottom-right":
              case "right":
                x = -p;
                break;
              case "top-left":
              case "bottom-left":
              case "left":
                x = p;
            }
            return [x, A];
          }(f, c[0], c[1]) : function(h, p) {
            let y = 0, x = 0;
            p < 0 && (p = 0);
            const A = p / Math.SQRT2;
            switch (h) {
              case "top-right":
              case "top-left":
                x = A - oh;
                break;
              case "bottom-right":
              case "bottom-left":
                x = -A + oh;
                break;
              case "bottom":
                x = -p + oh;
                break;
              case "top":
                x = p - oh;
            }
            switch (h) {
              case "top-right":
              case "bottom-right":
                y = -A;
                break;
              case "top-left":
              case "bottom-left":
                y = A;
                break;
              case "left":
                y = p;
                break;
              case "right":
                y = -p;
            }
            return [y, x];
          }(f, c[0]);
        }
        function Mw(f, c, h) {
          var p;
          const y = f.layout, x = (p = y.get("text-variable-anchor-offset")) === null || p === void 0 ? void 0 : p.evaluate(c, {}, h);
          if (x) {
            const I = x.values, B = [];
            for (let N = 0; N < I.length; N += 2) {
              const z = B[N] = I[N], j = I[N + 1].map((K) => K * bs);
              z.startsWith("top") ? j[1] -= oh : z.startsWith("bottom") && (j[1] += oh), B[N + 1] = j;
            }
            return new Yi(B);
          }
          const A = y.get("text-variable-anchor");
          if (A) {
            let I;
            I = f._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [y.get("text-radial-offset").evaluate(c, {}, h) * bs, b0] : y.get("text-offset").evaluate(c, {}, h).map((N) => N * bs);
            const B = [];
            for (const N of A) B.push(N, Iw(N, I));
            return new Yi(B);
          }
          return null;
        }
        function v0(f) {
          switch (f) {
            case "right":
            case "top-right":
            case "bottom-right":
              return "right";
            case "left":
            case "top-left":
            case "bottom-left":
              return "left";
          }
          return "center";
        }
        function hR(f, c, h, p, y, x, A, I, B, N, z, j) {
          let K = x.textMaxSize.evaluate(c, {});
          K === void 0 && (K = A);
          const ee = f.layers[0].layout, te = ee.get("icon-offset").evaluate(c, {}, z), le = Rw(h.horizontal), Ae = A / 24, Te = f.tilePixelRatio * Ae, Qe = f.tilePixelRatio * K / 24, ke = f.tilePixelRatio * I, Q = f.tilePixelRatio * ee.get("symbol-spacing"), xe = ee.get("text-padding") * f.tilePixelRatio, ze = function(Fr, Nr, Pr) {
            let _n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
            const Di = Fr.get("icon-padding").evaluate(Nr, {}, Pr), rs = Di && Di.values;
            return [rs[0] * _n, rs[1] * _n, rs[2] * _n, rs[3] * _n];
          }(ee, c, z, f.tilePixelRatio), yt = ee.get("text-max-angle") / 180 * Math.PI, $t = ee.get("text-rotation-alignment") !== "viewport" && ee.get("symbol-placement") !== "point", It = ee.get("icon-rotation-alignment") === "map" && ee.get("symbol-placement") !== "point", Lt = ee.get("symbol-placement"), er = Q / 2, Xt = ee.get("icon-text-fit");
          let ir;
          p && Xt !== "none" && (f.allowVerticalPlacement && h.vertical && (ir = Qx(p, h.vertical, Xt, ee.get("icon-text-fit-padding"), te, Ae)), le && (p = Qx(p, le, Xt, ee.get("icon-text-fit-padding"), te, Ae)));
          const Dt = z ? j.line.getGranularityForZoomLevel(z.z) : 1, Er = (Fr, Nr) => {
            Nr.x < 0 || Nr.x >= ht || Nr.y < 0 || Nr.y >= ht || function(Pr, _n, Di, rs, Lo, ia, sa, $s, Vi, vs, Hs, ns, Oo, Ga, Bs, oa, xs, Ls, Os, is, hi, sc, Yf, oc, pR) {
              const Kf = Pr.addToLineVertexArray(_n, Di);
              let Xh, Jf, Qf, ed, Nw = 0, Dw = 0, kw = 0, Fw = 0, I0 = -1, M0 = -1;
              const Ru = {};
              let Uw = Oi("");
              if (Pr.allowVerticalPlacement && rs.vertical) {
                const bo = $s.layout.get("text-rotate").evaluate(hi, {}, oc) + 90;
                Qf = new em(Vi, _n, vs, Hs, ns, rs.vertical, Oo, Ga, Bs, bo), sa && (ed = new em(Vi, _n, vs, Hs, ns, sa, xs, Ls, Bs, bo));
              }
              if (Lo) {
                const bo = $s.layout.get("icon-rotate").evaluate(hi, {}), $a = $s.layout.get("icon-text-fit") !== "none", Zh = Ew(Lo, bo, Yf, $a), lc = sa ? Ew(sa, bo, Yf, $a) : void 0;
                Jf = new em(Vi, _n, vs, Hs, ns, Lo, xs, Ls, !1, bo), Nw = 4 * Zh.length;
                const Yh = Pr.iconSizeData;
                let Jc = null;
                Yh.kind === "source" ? (Jc = [Kc * $s.layout.get("icon-size").evaluate(hi, {})], Jc[0] > nh && Yt(`${Pr.layerIds[0]}: Value for "icon-size" is >= ${wp}. Reduce your "icon-size".`)) : Yh.kind === "composite" && (Jc = [Kc * sc.compositeIconSizes[0].evaluate(hi, {}, oc), Kc * sc.compositeIconSizes[1].evaluate(hi, {}, oc)], (Jc[0] > nh || Jc[1] > nh) && Yt(`${Pr.layerIds[0]}: Value for "icon-size" is >= ${wp}. Reduce your "icon-size".`)), Pr.addSymbols(Pr.icon, Zh, Jc, is, Os, hi, l.af.none, _n, Kf.lineStartIndex, Kf.lineLength, -1, oc), I0 = Pr.icon.placedSymbolArray.length - 1, lc && (Dw = 4 * lc.length, Pr.addSymbols(Pr.icon, lc, Jc, is, Os, hi, l.af.vertical, _n, Kf.lineStartIndex, Kf.lineLength, -1, oc), M0 = Pr.icon.placedSymbolArray.length - 1);
              }
              const zw = Object.keys(rs.horizontal);
              for (const bo of zw) {
                const $a = rs.horizontal[bo];
                if (!Xh) {
                  Uw = Oi($a.text);
                  const lc = $s.layout.get("text-rotate").evaluate(hi, {}, oc);
                  Xh = new em(Vi, _n, vs, Hs, ns, $a, Oo, Ga, Bs, lc);
                }
                const Zh = $a.positionedLines.length === 1;
                if (kw += Pw(Pr, _n, $a, ia, $s, Bs, hi, oa, Kf, rs.vertical ? l.af.horizontal : l.af.horizontalOnly, Zh ? zw : [bo], Ru, I0, sc, oc), Zh) break;
              }
              rs.vertical && (Fw += Pw(Pr, _n, rs.vertical, ia, $s, Bs, hi, oa, Kf, l.af.vertical, ["vertical"], Ru, M0, sc, oc));
              const gR = Xh ? Xh.boxStartIndex : Pr.collisionBoxArray.length, mR = Xh ? Xh.boxEndIndex : Pr.collisionBoxArray.length, _R = Qf ? Qf.boxStartIndex : Pr.collisionBoxArray.length, yR = Qf ? Qf.boxEndIndex : Pr.collisionBoxArray.length, bR = Jf ? Jf.boxStartIndex : Pr.collisionBoxArray.length, vR = Jf ? Jf.boxEndIndex : Pr.collisionBoxArray.length, xR = ed ? ed.boxStartIndex : Pr.collisionBoxArray.length, wR = ed ? ed.boxEndIndex : Pr.collisionBoxArray.length;
              let ac = -1;
              const rm = (bo, $a) => bo && bo.circleDiameter ? Math.max(bo.circleDiameter, $a) : $a;
              ac = rm(Xh, ac), ac = rm(Qf, ac), ac = rm(Jf, ac), ac = rm(ed, ac);
              const jw = ac > -1 ? 1 : 0;
              jw && (ac *= pR / bs), Pr.glyphOffsetArray.length >= Wf.MAX_GLYPHS && Yt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), hi.sortKey !== void 0 && Pr.addToSortKeyRanges(Pr.symbolInstances.length, hi.sortKey);
              const AR = Mw($s, hi, oc), [TR, SR] = function(bo, $a) {
                const Zh = bo.length, lc = $a == null ? void 0 : $a.values;
                if ((lc == null ? void 0 : lc.length) > 0) for (let Yh = 0; Yh < lc.length; Yh += 2) {
                  const Jc = lc[Yh + 1];
                  bo.emplaceBack(l.aw[lc[Yh]], Jc[0], Jc[1]);
                }
                return [Zh, bo.length];
              }(Pr.textAnchorOffsets, AR);
              Pr.symbolInstances.emplaceBack(_n.x, _n.y, Ru.right >= 0 ? Ru.right : -1, Ru.center >= 0 ? Ru.center : -1, Ru.left >= 0 ? Ru.left : -1, Ru.vertical || -1, I0, M0, Uw, gR, mR, _R, yR, bR, vR, xR, wR, vs, kw, Fw, Nw, Dw, jw, 0, Oo, ac, TR, SR);
            }(f, Nr, Fr, h, p, y, ir, f.layers[0], f.collisionBoxArray, c.index, c.sourceLayerIndex, f.index, Te, [xe, xe, xe, xe], $t, B, ke, ze, It, te, c, x, N, z, A);
          };
          if (Lt === "line") for (const Fr of vw(c.geometry, 0, 0, ht, ht)) {
            const Nr = Wh(Fr, Dt), Pr = aR(Nr, Q, yt, h.vertical || le, p, 24, Qe, f.overscaling, ht);
            for (const _n of Pr) le && fR(f, le.text, er, _n) || Er(Nr, _n);
          }
          else if (Lt === "line-center") {
            for (const Fr of c.geometry) if (Fr.length > 1) {
              const Nr = Wh(Fr, Dt), Pr = oR(Nr, yt, h.vertical || le, p, 24, Qe);
              Pr && Er(Nr, Pr);
            }
          } else if (c.type === "Polygon") for (const Fr of Us(c.geometry, 0)) {
            const Nr = cR(Fr, 16);
            Er(Wh(Fr[0], Dt, !0), new sh(Nr.x, Nr.y, 0));
          }
          else if (c.type === "LineString") for (const Fr of c.geometry) {
            const Nr = Wh(Fr, Dt);
            Er(Nr, new sh(Nr[0].x, Nr[0].y, 0));
          }
          else if (c.type === "Point") for (const Fr of c.geometry) for (const Nr of Fr) Er([Nr], new sh(Nr.x, Nr.y, 0));
        }
        function Pw(f, c, h, p, y, x, A, I, B, N, z, j, K, ee, te) {
          const le = function(Qe, ke, Q, xe, ze, yt, $t, It) {
            const Lt = xe.layout.get("text-rotate").evaluate(yt, {}) * Math.PI / 180, er = [];
            for (const Xt of ke.positionedLines) for (const ir of Xt.positionedGlyphs) {
              if (!ir.rect) continue;
              const Dt = ir.rect || {};
              let Er = zP + 1, Fr = !0, Nr = 1, Pr = 0;
              const _n = (ze || It) && ir.vertical, Di = ir.metrics.advance * ir.scale / 2;
              if (It && ke.verticalizable && (Pr = Xt.lineOffset / 2 - (ir.imageName ? -(bs - ir.metrics.width * ir.scale) / 2 : (ir.scale - 1) * bs)), ir.imageName) {
                const Ls = $t[ir.imageName];
                Fr = Ls.sdf, Nr = Ls.pixelRatio, Er = na / Nr;
              }
              const rs = ze ? [ir.x + Di, ir.y] : [0, 0];
              let Lo = ze ? [0, 0] : [ir.x + Di + Q[0], ir.y + Q[1] - Pr], ia = [0, 0];
              _n && (ia = Lo, Lo = [0, 0]);
              const sa = ir.metrics.isDoubleResolution ? 2 : 1, $s = (ir.metrics.left - Er) * ir.scale - Di + Lo[0], Vi = (-ir.metrics.top - Er) * ir.scale + Lo[1], vs = $s + Dt.w / sa * ir.scale / Nr, Hs = Vi + Dt.h / sa * ir.scale / Nr, ns = new D($s, Vi), Oo = new D(vs, Vi), Ga = new D($s, Hs), Bs = new D(vs, Hs);
              if (_n) {
                const Ls = new D(-Di, Di - Hg), Os = -Math.PI / 2, is = bs / 2 - Di, hi = new D(5 - Hg - is, -(ir.imageName ? is : 0)), sc = new D(...ia);
                ns._rotateAround(Os, Ls)._add(hi)._add(sc), Oo._rotateAround(Os, Ls)._add(hi)._add(sc), Ga._rotateAround(Os, Ls)._add(hi)._add(sc), Bs._rotateAround(Os, Ls)._add(hi)._add(sc);
              }
              if (Lt) {
                const Ls = Math.sin(Lt), Os = Math.cos(Lt), is = [Os, -Ls, Ls, Os];
                ns._matMult(is), Oo._matMult(is), Ga._matMult(is), Bs._matMult(is);
              }
              const oa = new D(0, 0), xs = new D(0, 0);
              er.push({ tl: ns, tr: Oo, bl: Ga, br: Bs, tex: Dt, writingMode: ke.writingMode, glyphOffset: rs, sectionIndex: ir.sectionIndex, isSDF: Fr, pixelOffsetTL: oa, pixelOffsetBR: xs, minFontScaleX: 0, minFontScaleY: 0 });
            }
            return er;
          }(0, h, I, y, x, A, p, f.allowVerticalPlacement), Ae = f.textSizeData;
          let Te = null;
          Ae.kind === "source" ? (Te = [Kc * y.layout.get("text-size").evaluate(A, {})], Te[0] > nh && Yt(`${f.layerIds[0]}: Value for "text-size" is >= ${wp}. Reduce your "text-size".`)) : Ae.kind === "composite" && (Te = [Kc * ee.compositeTextSizes[0].evaluate(A, {}, te), Kc * ee.compositeTextSizes[1].evaluate(A, {}, te)], (Te[0] > nh || Te[1] > nh) && Yt(`${f.layerIds[0]}: Value for "text-size" is >= ${wp}. Reduce your "text-size".`)), f.addSymbols(f.text, le, Te, I, x, A, N, c, B.lineStartIndex, B.lineLength, K, te);
          for (const Qe of z) j[Qe] = f.text.placedSymbolArray.length - 1;
          return 4 * le.length;
        }
        function Rw(f) {
          for (const c in f) return f[c];
          return null;
        }
        function fR(f, c, h, p) {
          const y = f.compareText;
          if (c in y) {
            const x = y[c];
            for (let A = x.length - 1; A >= 0; A--) if (p.dist(x[A]) < h) return !0;
          } else y[c] = [];
          return y[c].push(p), !1;
        }
        const Bw = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
        class x0 {
          static from(c) {
            if (!(c instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
            const [h, p] = new Uint8Array(c, 0, 2);
            if (h !== 219) throw new Error("Data does not appear to be in a KDBush format.");
            const y = p >> 4;
            if (y !== 1) throw new Error(`Got v${y} data when expected v1.`);
            const x = Bw[15 & p];
            if (!x) throw new Error("Unrecognized array type.");
            const [A] = new Uint16Array(c, 2, 1), [I] = new Uint32Array(c, 4, 1);
            return new x0(I, A, x, c);
          }
          constructor(c) {
            let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, y = arguments.length > 3 ? arguments[3] : void 0;
            if (isNaN(c) || c < 0) throw new Error(`Unpexpected numItems value: ${c}.`);
            this.numItems = +c, this.nodeSize = Math.min(Math.max(+h, 2), 65535), this.ArrayType = p, this.IndexArrayType = c < 65536 ? Uint16Array : Uint32Array;
            const x = Bw.indexOf(this.ArrayType), A = 2 * c * this.ArrayType.BYTES_PER_ELEMENT, I = c * this.IndexArrayType.BYTES_PER_ELEMENT, B = (8 - I % 8) % 8;
            if (x < 0) throw new Error(`Unexpected typed array class: ${p}.`);
            y && y instanceof ArrayBuffer ? (this.data = y, this.ids = new this.IndexArrayType(this.data, 8, c), this.coords = new this.ArrayType(this.data, 8 + I + B, 2 * c), this._pos = 2 * c, this._finished = !0) : (this.data = new ArrayBuffer(8 + A + I + B), this.ids = new this.IndexArrayType(this.data, 8, c), this.coords = new this.ArrayType(this.data, 8 + I + B, 2 * c), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + x]), new Uint16Array(this.data, 2, 1)[0] = h, new Uint32Array(this.data, 4, 1)[0] = c);
          }
          add(c, h) {
            const p = this._pos >> 1;
            return this.ids[p] = p, this.coords[this._pos++] = c, this.coords[this._pos++] = h, p;
          }
          finish() {
            const c = this._pos >> 1;
            if (c !== this.numItems) throw new Error(`Added ${c} items when expected ${this.numItems}.`);
            return w0(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
          }
          range(c, h, p, y) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: x, coords: A, nodeSize: I } = this, B = [0, x.length - 1, 0], N = [];
            for (; B.length; ) {
              const z = B.pop() || 0, j = B.pop() || 0, K = B.pop() || 0;
              if (j - K <= I) {
                for (let Ae = K; Ae <= j; Ae++) {
                  const Te = A[2 * Ae], Qe = A[2 * Ae + 1];
                  Te >= c && Te <= p && Qe >= h && Qe <= y && N.push(x[Ae]);
                }
                continue;
              }
              const ee = K + j >> 1, te = A[2 * ee], le = A[2 * ee + 1];
              te >= c && te <= p && le >= h && le <= y && N.push(x[ee]), (z === 0 ? c <= te : h <= le) && (B.push(K), B.push(ee - 1), B.push(1 - z)), (z === 0 ? p >= te : y >= le) && (B.push(ee + 1), B.push(j), B.push(1 - z));
            }
            return N;
          }
          within(c, h, p) {
            if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
            const { ids: y, coords: x, nodeSize: A } = this, I = [0, y.length - 1, 0], B = [], N = p * p;
            for (; I.length; ) {
              const z = I.pop() || 0, j = I.pop() || 0, K = I.pop() || 0;
              if (j - K <= A) {
                for (let Ae = K; Ae <= j; Ae++) Ow(x[2 * Ae], x[2 * Ae + 1], c, h) <= N && B.push(y[Ae]);
                continue;
              }
              const ee = K + j >> 1, te = x[2 * ee], le = x[2 * ee + 1];
              Ow(te, le, c, h) <= N && B.push(y[ee]), (z === 0 ? c - p <= te : h - p <= le) && (I.push(K), I.push(ee - 1), I.push(1 - z)), (z === 0 ? c + p >= te : h + p >= le) && (I.push(ee + 1), I.push(j), I.push(1 - z));
            }
            return B;
          }
        }
        function w0(f, c, h, p, y, x) {
          if (y - p <= h) return;
          const A = p + y >> 1;
          Lw(f, c, A, p, y, x), w0(f, c, h, p, A - 1, 1 - x), w0(f, c, h, A + 1, y, 1 - x);
        }
        function Lw(f, c, h, p, y, x) {
          for (; y > p; ) {
            if (y - p > 600) {
              const N = y - p + 1, z = h - p + 1, j = Math.log(N), K = 0.5 * Math.exp(2 * j / 3), ee = 0.5 * Math.sqrt(j * K * (N - K) / N) * (z - N / 2 < 0 ? -1 : 1);
              Lw(f, c, h, Math.max(p, Math.floor(h - z * K / N + ee)), Math.min(y, Math.floor(h + (N - z) * K / N + ee)), x);
            }
            const A = c[2 * h + x];
            let I = p, B = y;
            for (Sp(f, c, p, h), c[2 * y + x] > A && Sp(f, c, p, y); I < B; ) {
              for (Sp(f, c, I, B), I++, B--; c[2 * I + x] < A; ) I++;
              for (; c[2 * B + x] > A; ) B--;
            }
            c[2 * p + x] === A ? Sp(f, c, p, B) : (B++, Sp(f, c, B, y)), B <= h && (p = B + 1), h <= B && (y = B - 1);
          }
        }
        function Sp(f, c, h, p) {
          A0(f, h, p), A0(c, 2 * h, 2 * p), A0(c, 2 * h + 1, 2 * p + 1);
        }
        function A0(f, c, h) {
          const p = f[c];
          f[c] = f[h], f[h] = p;
        }
        function Ow(f, c, h, p) {
          const y = f - h, x = c - p;
          return y * y + x * x;
        }
        var T0;
        l.cf = void 0, (T0 = l.cf || (l.cf = {})).create = "create", T0.load = "load", T0.fullLoad = "fullLoad";
        let tm = null, Ep = [];
        const S0 = 1e3 / 60, E0 = "loadTime", C0 = "fullLoadTime", dR = { mark(f) {
          performance.mark(f);
        }, frame(f) {
          const c = f;
          tm != null && Ep.push(c - tm), tm = c;
        }, clearMetrics() {
          tm = null, Ep = [], performance.clearMeasures(E0), performance.clearMeasures(C0);
          for (const f in l.cf) performance.clearMarks(l.cf[f]);
        }, getPerformanceMetrics() {
          performance.measure(E0, l.cf.create, l.cf.load), performance.measure(C0, l.cf.create, l.cf.fullLoad);
          const f = performance.getEntriesByName(E0)[0].duration, c = performance.getEntriesByName(C0)[0].duration, h = Ep.length, p = 1 / (Ep.reduce((x, A) => x + A, 0) / h / 1e3), y = Ep.filter((x) => x > S0).reduce((x, A) => x + (A - S0) / S0, 0);
          return { loadTime: f, fullLoadTime: c, fps: p, percentDroppedFrames: y / (h + y) * 100, totalFrames: h };
        } };
        l.$ = y0, l.A = ye, l.B = ot, l.C = yl, l.D = dt, l.E = Xi, l.F = function(f) {
          if (Cr == null) {
            const c = f.navigator ? f.navigator.userAgent : null;
            Cr = !!f.safari || !(!c || !(/\b(iPad|iPhone|iPod)\b/.test(c) || c.match("Safari") && !c.match("Chrome")));
          }
          return Cr;
        }, l.G = class {
          constructor(f, c) {
            this.target = f, this.mapId = c, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new iR(() => this.process()), this.subscription = function(h, p, y, x) {
              return h.addEventListener(p, y, !1), { unsubscribe: () => {
                h.removeEventListener(p, y, !1);
              } };
            }(this.target, "message", (h) => this.receive(h)), this.globalScope = _r(self) ? f : window;
          }
          registerMessageHandler(f, c) {
            this.messageHandlers[f] = c;
          }
          sendAsync(f, c) {
            return new Promise((h, p) => {
              const y = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              this.resolveRejects[y] = { resolve: h, reject: p }, c && c.signal.addEventListener("abort", () => {
                delete this.resolveRejects[y];
                const I = { id: y, type: "<cancel>", origin: location.origin, targetMapId: f.targetMapId, sourceMapId: this.mapId };
                this.target.postMessage(I);
              }, { once: !0 });
              const x = [], A = Object.assign(Object.assign({}, f), { id: y, sourceMapId: this.mapId, origin: location.origin, data: Cu(f.data, x) });
              this.target.postMessage(A, { transfer: x });
            });
          }
          receive(f) {
            const c = f.data, h = c.id;
            if (!(c.origin !== "file://" && location.origin !== "file://" && c.origin !== "resource://android" && location.origin !== "resource://android" && c.origin !== location.origin || c.targetMapId && this.mapId !== c.targetMapId)) {
              if (c.type === "<cancel>") {
                delete this.tasks[h];
                const p = this.abortControllers[h];
                return delete this.abortControllers[h], void (p && p.abort());
              }
              if (_r(self) || c.mustQueue) return this.tasks[h] = c, this.taskQueue.push(h), void this.invoker.trigger();
              this.processTask(h, c);
            }
          }
          process() {
            if (this.taskQueue.length === 0) return;
            const f = this.taskQueue.shift(), c = this.tasks[f];
            delete this.tasks[f], this.taskQueue.length > 0 && this.invoker.trigger(), c && this.processTask(f, c);
          }
          processTask(f, c) {
            return o(this, void 0, void 0, function* () {
              if (c.type === "<response>") {
                const y = this.resolveRejects[f];
                return delete this.resolveRejects[f], y ? void (c.error ? y.reject(ja(c.error)) : y.resolve(ja(c.data))) : void 0;
              }
              if (!this.messageHandlers[c.type]) return void this.completeTask(f, new Error(`Could not find a registered handler for ${c.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
              const h = ja(c.data), p = new AbortController();
              this.abortControllers[f] = p;
              try {
                const y = yield this.messageHandlers[c.type](c.sourceMapId, h, p);
                this.completeTask(f, null, y);
              } catch (y) {
                this.completeTask(f, y);
              }
            });
          }
          completeTask(f, c, h) {
            const p = [];
            delete this.abortControllers[f];
            const y = { id: f, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: c ? Cu(c) : null, data: Cu(h, p) };
            this.target.postMessage(y, { transfer: p });
          }
          remove() {
            this.invoker.remove(), this.subscription.unsubscribe();
          }
        }, l.H = Wr, l.I = l0, l.J = function() {
          var f = new ye(16);
          return ye != Float32Array && (f[1] = 0, f[2] = 0, f[3] = 0, f[4] = 0, f[6] = 0, f[7] = 0, f[8] = 0, f[9] = 0, f[11] = 0, f[12] = 0, f[13] = 0, f[14] = 0), f[0] = 1, f[5] = 1, f[10] = 1, f[15] = 1, f;
        }, l.K = function(f, c, h) {
          var p, y, x, A, I, B, N, z, j, K, ee, te, le = h[0], Ae = h[1], Te = h[2];
          return c === f ? (f[12] = c[0] * le + c[4] * Ae + c[8] * Te + c[12], f[13] = c[1] * le + c[5] * Ae + c[9] * Te + c[13], f[14] = c[2] * le + c[6] * Ae + c[10] * Te + c[14], f[15] = c[3] * le + c[7] * Ae + c[11] * Te + c[15]) : (y = c[1], x = c[2], A = c[3], I = c[4], B = c[5], N = c[6], z = c[7], j = c[8], K = c[9], ee = c[10], te = c[11], f[0] = p = c[0], f[1] = y, f[2] = x, f[3] = A, f[4] = I, f[5] = B, f[6] = N, f[7] = z, f[8] = j, f[9] = K, f[10] = ee, f[11] = te, f[12] = p * le + I * Ae + j * Te + c[12], f[13] = y * le + B * Ae + K * Te + c[13], f[14] = x * le + N * Ae + ee * Te + c[14], f[15] = A * le + z * Ae + te * Te + c[15]), f;
        }, l.L = function(f, c, h) {
          var p = h[0], y = h[1], x = h[2];
          return f[0] = c[0] * p, f[1] = c[1] * p, f[2] = c[2] * p, f[3] = c[3] * p, f[4] = c[4] * y, f[5] = c[5] * y, f[6] = c[6] * y, f[7] = c[7] * y, f[8] = c[8] * x, f[9] = c[9] * x, f[10] = c[10] * x, f[11] = c[11] * x, f[12] = c[12], f[13] = c[13], f[14] = c[14], f[15] = c[15], f;
        }, l.M = function(f, c, h) {
          var p = c[0], y = c[1], x = c[2], A = c[3], I = c[4], B = c[5], N = c[6], z = c[7], j = c[8], K = c[9], ee = c[10], te = c[11], le = c[12], Ae = c[13], Te = c[14], Qe = c[15], ke = h[0], Q = h[1], xe = h[2], ze = h[3];
          return f[0] = ke * p + Q * I + xe * j + ze * le, f[1] = ke * y + Q * B + xe * K + ze * Ae, f[2] = ke * x + Q * N + xe * ee + ze * Te, f[3] = ke * A + Q * z + xe * te + ze * Qe, f[4] = (ke = h[4]) * p + (Q = h[5]) * I + (xe = h[6]) * j + (ze = h[7]) * le, f[5] = ke * y + Q * B + xe * K + ze * Ae, f[6] = ke * x + Q * N + xe * ee + ze * Te, f[7] = ke * A + Q * z + xe * te + ze * Qe, f[8] = (ke = h[8]) * p + (Q = h[9]) * I + (xe = h[10]) * j + (ze = h[11]) * le, f[9] = ke * y + Q * B + xe * K + ze * Ae, f[10] = ke * x + Q * N + xe * ee + ze * Te, f[11] = ke * A + Q * z + xe * te + ze * Qe, f[12] = (ke = h[12]) * p + (Q = h[13]) * I + (xe = h[14]) * j + (ze = h[15]) * le, f[13] = ke * y + Q * B + xe * K + ze * Ae, f[14] = ke * x + Q * N + xe * ee + ze * Te, f[15] = ke * A + Q * z + xe * te + ze * Qe, f;
        }, l.N = function(f, c) {
          const h = {};
          for (let p = 0; p < c.length; p++) {
            const y = c[p];
            y in f && (h[y] = f[y]);
          }
          return h;
        }, l.O = ih, l.P = D, l.Q = cw, l.R = Va, l.S = lw, l.T = Wt, l.U = he, l.V = X, l.W = jr, l.X = qa, l.Y = ht, l.Z = Ap, l._ = o, l.a = Rr, l.a$ = function() {
          const f = new Float64Array(16);
          return Re(f), f;
        }, l.a0 = (f) => {
          const c = window.document.createElement("video");
          return c.muted = !0, new Promise((h) => {
            c.onloadstart = () => {
              h(c);
            };
            for (const p of f) {
              const y = window.document.createElement("source");
              Vr(p) || (c.crossOrigin = "Anonymous"), y.src = p, c.appendChild(y);
            }
          });
        }, l.a1 = We, l.a2 = function() {
          return it++;
        }, l.a3 = w, l.a4 = Wf, l.a5 = Ql, l.a6 = Pu, l.a7 = mw, l.a8 = function(f) {
          const c = {};
          if (f.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (h, p, y, x) => {
            const A = y || x;
            return c[p] = !A || A.toLowerCase(), "";
          }), c["max-age"]) {
            const h = parseInt(c["max-age"], 10);
            isNaN(h) ? delete c["max-age"] : c["max-age"] = h;
          }
          return c;
        }, l.a9 = function(f) {
          return Math.log(f) / Math.LN2;
        }, l.aA = x0, l.aB = Br, l.aC = qg, l.aD = Se, l.aE = dr, l.aF = Mt, l.aG = function(f) {
          return Math.pow(2, f);
        }, l.aH = 85.051129, l.aI = uw, l.aJ = Ue, l.aK = hr, l.aL = hw, l.aM = function(f, c, h) {
          return f[0] = c[0] * h, f[1] = c[1] * h, f[2] = c[2] * h, f;
        }, l.aN = function(f, c, h) {
          return f[0] = c[0] + h[0], f[1] = c[1] + h[1], f[2] = c[2] + h[2], f;
        }, l.aO = function(f) {
          var c = new ye(3);
          return c[0] = f[0], c[1] = f[1], c[2] = f[2], c;
        }, l.aP = function(f, c, h) {
          return f[0] = c[0] * h[0], f[1] = c[1] * h[1], f[2] = c[2] * h[2], f[3] = c[3] * h[3], f;
        }, l.aQ = function(f, c, h) {
          return f[0] = c[0] - h[0], f[1] = c[1] - h[1], f[2] = c[2] - h[2], f;
        }, l.aR = function(f, c) {
          var h = c[0], p = c[1], y = c[2], x = h * h + p * p + y * y;
          return x > 0 && (x = 1 / Math.sqrt(x)), f[0] = c[0] * x, f[1] = c[1] * x, f[2] = c[2] * x, f;
        }, l.aS = function(f, c, h) {
          var p = c[0], y = c[1], x = c[2], A = h[0], I = h[1], B = h[2];
          return f[0] = y * B - x * I, f[1] = x * A - p * B, f[2] = p * I - y * A, f;
        }, l.aT = function(f, c) {
          return f[0] * c[0] + f[1] * c[1] + f[2] * c[2];
        }, l.aU = dw, l.aV = Xf, l.aW = function(f, c, h, p, y) {
          var x, A = 1 / Math.tan(c / 2);
          return f[0] = A / h, f[1] = 0, f[2] = 0, f[3] = 0, f[4] = 0, f[5] = A, f[6] = 0, f[7] = 0, f[8] = 0, f[9] = 0, f[11] = -1, f[12] = 0, f[13] = 0, f[15] = 0, y != null && y !== 1 / 0 ? (f[10] = (y + p) * (x = 1 / (p - y)), f[14] = 2 * y * p * x) : (f[10] = -1, f[14] = -2 * p), f;
        }, l.aX = function(f) {
          var c = new ye(16);
          return c[0] = f[0], c[1] = f[1], c[2] = f[2], c[3] = f[3], c[4] = f[4], c[5] = f[5], c[6] = f[6], c[7] = f[7], c[8] = f[8], c[9] = f[9], c[10] = f[10], c[11] = f[11], c[12] = f[12], c[13] = f[13], c[14] = f[14], c[15] = f[15], c;
        }, l.aY = function(f, c, h) {
          var p = Math.sin(h), y = Math.cos(h), x = c[0], A = c[1], I = c[2], B = c[3], N = c[4], z = c[5], j = c[6], K = c[7];
          return c !== f && (f[8] = c[8], f[9] = c[9], f[10] = c[10], f[11] = c[11], f[12] = c[12], f[13] = c[13], f[14] = c[14], f[15] = c[15]), f[0] = x * y + N * p, f[1] = A * y + z * p, f[2] = I * y + j * p, f[3] = B * y + K * p, f[4] = N * y - x * p, f[5] = z * y - A * p, f[6] = j * y - I * p, f[7] = K * y - B * p, f;
        }, l.aZ = function(f, c, h) {
          var p = Math.sin(h), y = Math.cos(h), x = c[4], A = c[5], I = c[6], B = c[7], N = c[8], z = c[9], j = c[10], K = c[11];
          return c !== f && (f[0] = c[0], f[1] = c[1], f[2] = c[2], f[3] = c[3], f[12] = c[12], f[13] = c[13], f[14] = c[14], f[15] = c[15]), f[4] = x * y + N * p, f[5] = A * y + z * p, f[6] = I * y + j * p, f[7] = B * y + K * p, f[8] = N * y - x * p, f[9] = z * y - A * p, f[10] = j * y - I * p, f[11] = K * y - B * p, f;
        }, l.a_ = function() {
          const f = new Float32Array(16);
          return Re(f), f;
        }, l.aa = function(f) {
          var c = f[0], h = f[1];
          return c * c + h * h;
        }, l.ab = function(f) {
          return f * Math.PI / 180;
        }, l.ac = Be, l.ad = function(f, c) {
          const h = [];
          for (const p in f) p in c || h.push(p);
          return h;
        }, l.ae = function(f, c) {
          let h = 0, p = 0;
          if (f.kind === "constant") p = f.layoutSize;
          else if (f.kind !== "source") {
            const { interpolationType: y, minZoom: x, maxZoom: A } = f, I = y ? Be(gn.interpolationFactor(y, c, x, A), 0, 1) : 0;
            f.kind === "camera" ? p = ho.number(f.minSize, f.maxSize, I) : h = I;
          }
          return { uSizeT: h, uSize: p };
        }, l.ag = function(f, c, h) {
          let { uSize: p, uSizeT: y } = c, { lowerSize: x, upperSize: A } = h;
          return f.kind === "source" ? x / Kc : f.kind === "composite" ? ho.number(x / Kc, A / Kc, y) : p;
        }, l.ah = function(f, c) {
          var h = c[0], p = c[1], y = c[2], x = c[3], A = c[4], I = c[5], B = c[6], N = c[7], z = c[8], j = c[9], K = c[10], ee = c[11], te = c[12], le = c[13], Ae = c[14], Te = c[15], Qe = h * I - p * A, ke = h * B - y * A, Q = h * N - x * A, xe = p * B - y * I, ze = p * N - x * I, yt = y * N - x * B, $t = z * le - j * te, It = z * Ae - K * te, Lt = z * Te - ee * te, er = j * Ae - K * le, Xt = j * Te - ee * le, ir = K * Te - ee * Ae, Dt = Qe * ir - ke * Xt + Q * er + xe * Lt - ze * It + yt * $t;
          return Dt ? (f[0] = (I * ir - B * Xt + N * er) * (Dt = 1 / Dt), f[1] = (y * Xt - p * ir - x * er) * Dt, f[2] = (le * yt - Ae * ze + Te * xe) * Dt, f[3] = (K * ze - j * yt - ee * xe) * Dt, f[4] = (B * Lt - A * ir - N * It) * Dt, f[5] = (h * ir - y * Lt + x * It) * Dt, f[6] = (Ae * Q - te * yt - Te * ke) * Dt, f[7] = (z * yt - K * Q + ee * ke) * Dt, f[8] = (A * Xt - I * Lt + N * $t) * Dt, f[9] = (p * Lt - h * Xt - x * $t) * Dt, f[10] = (te * ze - le * Q + Te * Qe) * Dt, f[11] = (j * Q - z * ze - ee * Qe) * Dt, f[12] = (I * It - A * er - B * $t) * Dt, f[13] = (h * er - p * It + y * $t) * Dt, f[14] = (le * ke - te * xe - Ae * Qe) * Dt, f[15] = (z * xe - j * ke + K * Qe) * Dt, f) : null;
        }, l.ai = Me, l.aj = function(f) {
          return Math.hypot(f[0], f[1]);
        }, l.ak = function(f) {
          return f[0] = 0, f[1] = 0, f;
        }, l.al = function(f, c, h) {
          return f[0] = c[0] * h, f[1] = c[1] * h, f;
        }, l.am = f0, l.an = _e, l.ao = function(f, c, h, p) {
          const y = c.y - f.y, x = c.x - f.x, A = p.y - h.y, I = p.x - h.x, B = A * x - I * y;
          if (B === 0) return null;
          const N = (I * (f.y - h.y) - A * (f.x - h.x)) / B;
          return new D(f.x + N * x, f.y + N * y);
        }, l.ap = vw, l.aq = sp, l.ar = Re, l.as = function(f) {
          let c = 1 / 0, h = 1 / 0, p = -1 / 0, y = -1 / 0;
          for (const x of f) c = Math.min(c, x.x), h = Math.min(h, x.y), p = Math.max(p, x.x), y = Math.max(y, x.y);
          return [c, h, p, y];
        }, l.at = bs, l.au = Pt, l.av = function(f, c, h, p) {
          let y = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
          if (!h[0] && !h[1]) return [0, 0];
          const x = y ? p === "map" ? -f.bearingInRadians : 0 : p === "viewport" ? f.bearingInRadians : 0;
          if (x) {
            const A = Math.sin(x), I = Math.cos(x);
            h = [h[0] * I - h[1] * A, h[0] * A + h[1] * I];
          }
          return [y ? h[0] : Pt(c, h[0], f.zoom), y ? h[1] : Pt(c, h[1], f.zoom)];
        }, l.ax = h0, l.ay = v0, l.az = u0, l.b = Ut, l.b$ = (f) => f.type === "heatmap", l.b0 = function() {
          return new Float64Array(16);
        }, l.b1 = function(f, c, h) {
          const p = new Float64Array(4);
          return function(y, x, A, I) {
            var B = 0.5 * Math.PI / 180;
            x *= B, A *= B, I *= B;
            var N = Math.sin(x), z = Math.cos(x), j = Math.sin(A), K = Math.cos(A), ee = Math.sin(I), te = Math.cos(I);
            y[0] = N * K * te - z * j * ee, y[1] = z * j * te + N * K * ee, y[2] = z * K * ee - N * j * te, y[3] = z * K * te + N * j * ee;
          }(p, f, c - 90, h), p;
        }, l.b2 = function(f, c, h, p) {
          var y, x, A, I, B, N = c[0], z = c[1], j = c[2], K = c[3], ee = h[0], te = h[1], le = h[2], Ae = h[3];
          return (x = N * ee + z * te + j * le + K * Ae) < 0 && (x = -x, ee = -ee, te = -te, le = -le, Ae = -Ae), 1 - x > ie ? (y = Math.acos(x), A = Math.sin(y), I = Math.sin((1 - p) * y) / A, B = Math.sin(p * y) / A) : (I = 1 - p, B = p), f[0] = I * N + B * ee, f[1] = I * z + B * te, f[2] = I * j + B * le, f[3] = I * K + B * Ae, f;
        }, l.b3 = function(f) {
          const c = new Float64Array(9);
          var h, p, y, x, A, I, B, N, z, j, K, ee, te, le, Ae, Te, Qe, ke;
          j = (y = (p = f)[0]) * (B = y + y), K = (x = p[1]) * B, te = (A = p[2]) * B, le = A * (N = x + x), Te = (I = p[3]) * B, Qe = I * N, ke = I * (z = A + A), (h = c)[0] = 1 - (ee = x * N) - (Ae = A * z), h[3] = K - ke, h[6] = te + Qe, h[1] = K + ke, h[4] = 1 - j - Ae, h[7] = le - Te, h[2] = te - Qe, h[5] = le + Te, h[8] = 1 - j - ee;
          const Q = hr(-Math.asin(Be(c[2], -1, 1)));
          let xe, ze;
          return Math.hypot(c[5], c[8]) < 1e-3 ? (xe = 0, ze = -hr(Math.atan2(c[3], c[4]))) : (xe = hr(c[5] === 0 && c[8] === 0 ? 0 : Math.atan2(c[5], c[8])), ze = hr(c[1] === 0 && c[0] === 0 ? 0 : Math.atan2(c[1], c[0]))), { roll: xe, pitch: Q + 90, bearing: ze };
        }, l.b4 = function(f, c) {
          return f.roll == c.roll && f.pitch == c.pitch && f.bearing == c.bearing;
        }, l.b5 = nn, l.b6 = Rs, l.b7 = $f, l.b8 = gp, l.b9 = Gf, l.bA = function f(c, h) {
          if (Array.isArray(c)) {
            if (!Array.isArray(h) || c.length !== h.length) return !1;
            for (let p = 0; p < c.length; p++) if (!f(c[p], h[p])) return !1;
            return !0;
          }
          if (typeof c == "object" && c !== null && h !== null) {
            if (typeof h != "object" || Object.keys(c).length !== Object.keys(h).length) return !1;
            for (const p in c) if (!f(c[p], h[p])) return !1;
            return !0;
          }
          return c === h;
        }, l.bB = ft, l.bC = St, l.bD = class extends Ni {
          constructor(f, c) {
            super(f, c), this.current = 0;
          }
          set(f) {
            this.current !== f && (this.current = f, this.gl.uniform1i(this.location, f));
          }
        }, l.bE = vl, l.bF = class extends Ni {
          constructor(f, c) {
            super(f, c), this.current = xl;
          }
          set(f) {
            if (f[12] !== this.current[12] || f[0] !== this.current[0]) return this.current = f, void this.gl.uniformMatrix4fv(this.location, !1, f);
            for (let c = 1; c < 16; c++) if (f[c] !== this.current[c]) {
              this.current = f, this.gl.uniformMatrix4fv(this.location, !1, f);
              break;
            }
          }
        }, l.bG = Ro, l.bH = class extends Ni {
          constructor(f, c) {
            super(f, c), this.current = [0, 0, 0];
          }
          set(f) {
            f[0] === this.current[0] && f[1] === this.current[1] && f[2] === this.current[2] || (this.current = f, this.gl.uniform3f(this.location, f[0], f[1], f[2]));
          }
        }, l.bI = class extends Ni {
          constructor(f, c) {
            super(f, c), this.current = [0, 0];
          }
          set(f) {
            f[0] === this.current[0] && f[1] === this.current[1] || (this.current = f, this.gl.uniform2f(this.location, f[0], f[1]));
          }
        }, l.bJ = oe, l.bK = function(f, c) {
          var h = Math.sin(c), p = Math.cos(c);
          return f[0] = p, f[1] = h, f[2] = 0, f[3] = -h, f[4] = p, f[5] = 0, f[6] = 0, f[7] = 0, f[8] = 1, f;
        }, l.bL = function(f, c, h) {
          var p = c[0], y = c[1], x = c[2];
          return f[0] = p * h[0] + y * h[3] + x * h[6], f[1] = p * h[1] + y * h[4] + x * h[7], f[2] = p * h[2] + y * h[5] + x * h[8], f;
        }, l.bM = function(f, c, h, p, y, x, A) {
          var I = 1 / (c - h), B = 1 / (p - y), N = 1 / (x - A);
          return f[0] = -2 * I, f[1] = 0, f[2] = 0, f[3] = 0, f[4] = 0, f[5] = -2 * B, f[6] = 0, f[7] = 0, f[8] = 0, f[9] = 0, f[10] = 2 * N, f[11] = 0, f[12] = (c + h) * I, f[13] = (y + p) * B, f[14] = (A + x) * N, f[15] = 1, f;
        }, l.bN = class extends ea {
        }, l.bO = OP, l.bP = class extends _o {
        }, l.bQ = Hy, l.bR = function(f) {
          return f <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(f) / Math.LN2));
        }, l.bS = gx, l.bT = function(f, c, h) {
          var p = c[0], y = c[1], x = c[2], A = h[3] * p + h[7] * y + h[11] * x + h[15];
          return f[0] = (h[0] * p + h[4] * y + h[8] * x + h[12]) / (A = A || 1), f[1] = (h[1] * p + h[5] * y + h[9] * x + h[13]) / A, f[2] = (h[2] * p + h[6] * y + h[10] * x + h[14]) / A, f;
        }, l.bU = class extends Ps {
        }, l.bV = class extends u {
        }, l.bW = function(f, c) {
          return f[0] === c[0] && f[1] === c[1] && f[2] === c[2] && f[3] === c[3] && f[4] === c[4] && f[5] === c[5] && f[6] === c[6] && f[7] === c[7] && f[8] === c[8] && f[9] === c[9] && f[10] === c[10] && f[11] === c[11] && f[12] === c[12] && f[13] === c[13] && f[14] === c[14] && f[15] === c[15];
        }, l.bX = function(f, c) {
          var h = f[0], p = f[1], y = f[2], x = f[3], A = f[4], I = f[5], B = f[6], N = f[7], z = f[8], j = f[9], K = f[10], ee = f[11], te = f[12], le = f[13], Ae = f[14], Te = f[15], Qe = c[0], ke = c[1], Q = c[2], xe = c[3], ze = c[4], yt = c[5], $t = c[6], It = c[7], Lt = c[8], er = c[9], Xt = c[10], ir = c[11], Dt = c[12], Er = c[13], Fr = c[14], Nr = c[15];
          return Math.abs(h - Qe) <= ie * Math.max(1, Math.abs(h), Math.abs(Qe)) && Math.abs(p - ke) <= ie * Math.max(1, Math.abs(p), Math.abs(ke)) && Math.abs(y - Q) <= ie * Math.max(1, Math.abs(y), Math.abs(Q)) && Math.abs(x - xe) <= ie * Math.max(1, Math.abs(x), Math.abs(xe)) && Math.abs(A - ze) <= ie * Math.max(1, Math.abs(A), Math.abs(ze)) && Math.abs(I - yt) <= ie * Math.max(1, Math.abs(I), Math.abs(yt)) && Math.abs(B - $t) <= ie * Math.max(1, Math.abs(B), Math.abs($t)) && Math.abs(N - It) <= ie * Math.max(1, Math.abs(N), Math.abs(It)) && Math.abs(z - Lt) <= ie * Math.max(1, Math.abs(z), Math.abs(Lt)) && Math.abs(j - er) <= ie * Math.max(1, Math.abs(j), Math.abs(er)) && Math.abs(K - Xt) <= ie * Math.max(1, Math.abs(K), Math.abs(Xt)) && Math.abs(ee - ir) <= ie * Math.max(1, Math.abs(ee), Math.abs(ir)) && Math.abs(te - Dt) <= ie * Math.max(1, Math.abs(te), Math.abs(Dt)) && Math.abs(le - Er) <= ie * Math.max(1, Math.abs(le), Math.abs(Er)) && Math.abs(Ae - Fr) <= ie * Math.max(1, Math.abs(Ae), Math.abs(Fr)) && Math.abs(Te - Nr) <= ie * Math.max(1, Math.abs(Te), Math.abs(Nr));
        }, l.bY = function(f, c) {
          return f[0] = c[0], f[1] = c[1], f[2] = c[2], f[3] = c[3], f[4] = c[4], f[5] = c[5], f[6] = c[6], f[7] = c[7], f[8] = c[8], f[9] = c[9], f[10] = c[10], f[11] = c[11], f[12] = c[12], f[13] = c[13], f[14] = c[14], f[15] = c[15], f;
        }, l.bZ = (f) => f.type === "symbol", l.b_ = (f) => f.type === "circle", l.ba = kt, l.bb = Nt, l.bc = Mi, l.bd = function(f, c, h, p, y) {
          return kt(p, y, Be((f - c) / (h - c), 0, 1));
        }, l.be = bt, l.bf = function() {
          return new Float64Array(4);
        }, l.bg = function() {
          return new Float64Array(3);
        }, l.bh = function(f, c, h, p) {
          var y = [], x = [];
          return y[0] = c[0] - h[0], y[1] = c[1] - h[1], y[2] = c[2] - h[2], x[0] = y[0] * Math.cos(p) - y[1] * Math.sin(p), x[1] = y[0] * Math.sin(p) + y[1] * Math.cos(p), x[2] = y[2], f[0] = x[0] + h[0], f[1] = x[1] + h[1], f[2] = x[2] + h[2], f;
        }, l.bi = function(f, c, h, p) {
          var y = [], x = [];
          return y[0] = c[0] - h[0], y[1] = c[1] - h[1], y[2] = c[2] - h[2], x[0] = y[0], x[1] = y[1] * Math.cos(p) - y[2] * Math.sin(p), x[2] = y[1] * Math.sin(p) + y[2] * Math.cos(p), f[0] = x[0] + h[0], f[1] = x[1] + h[1], f[2] = x[2] + h[2], f;
        }, l.bj = function(f, c, h, p) {
          var y = [], x = [];
          return y[0] = c[0] - h[0], y[1] = c[1] - h[1], y[2] = c[2] - h[2], x[0] = y[2] * Math.sin(p) + y[0] * Math.cos(p), x[1] = y[1], x[2] = y[2] * Math.cos(p) - y[0] * Math.sin(p), f[0] = x[0] + h[0], f[1] = x[1] + h[1], f[2] = x[2] + h[2], f;
        }, l.bk = function(f, c, h) {
          var p = Math.sin(h), y = Math.cos(h), x = c[0], A = c[1], I = c[2], B = c[3], N = c[8], z = c[9], j = c[10], K = c[11];
          return c !== f && (f[4] = c[4], f[5] = c[5], f[6] = c[6], f[7] = c[7], f[12] = c[12], f[13] = c[13], f[14] = c[14], f[15] = c[15]), f[0] = x * y - N * p, f[1] = A * y - z * p, f[2] = I * y - j * p, f[3] = B * y - K * p, f[8] = x * p + N * y, f[9] = A * p + z * y, f[10] = I * p + j * y, f[11] = B * p + K * y, f;
        }, l.bl = function(f, c) {
          const h = bt(f, 360), p = bt(c, 360), y = p - h, x = p > h ? y - 360 : y + 360;
          return Math.abs(y) < Math.abs(x) ? y : x;
        }, l.bm = function(f) {
          return f[0] = 0, f[1] = 0, f[2] = 0, f;
        }, l.bn = function(f, c, h, p) {
          const y = Math.sqrt(f * f + c * c), x = Math.sqrt(h * h + p * p);
          f /= y, c /= y, h /= x, p /= x;
          const A = Math.acos(f * h + c * p);
          return -c * h + f * p > 0 ? A : -A;
        }, l.bo = function(f, c) {
          return f[0] * c[0] + f[1] * c[1] + f[2] * c[2] + f[3];
        }, l.bp = m0, l.bq = function(f, c) {
          const h = bt(f, 2 * Math.PI), p = bt(c, 2 * Math.PI);
          return Math.min(Math.abs(h - p), Math.abs(h - p + 2 * Math.PI), Math.abs(h - p - 2 * Math.PI));
        }, l.br = function(f) {
          return Math.hypot(f[0], f[1], f[2]);
        }, l.bs = function() {
          const f = {}, c = ve.$version;
          for (const h in ve.$root) {
            const p = ve.$root[h];
            if (p.required) {
              let y = null;
              y = h === "version" ? c : p.type === "array" ? [] : {}, y != null && (f[h] = y);
            }
          }
          return f;
        }, l.bt = Iu, l.bu = hn, l.bv = function(f) {
          f = f.slice();
          const c = /* @__PURE__ */ Object.create(null);
          for (let h = 0; h < f.length; h++) c[f[h].id] = f[h];
          for (let h = 0; h < f.length; h++) "ref" in f[h] && (f[h] = de(f[h], c[f[h].ref]));
          return f;
        }, l.bw = function(f) {
          if (f.type === "custom") return new nR(f);
          switch (f.type) {
            case "background":
              return new eR(f);
            case "circle":
              return new ZM(f);
            case "fill":
              return new pP(f);
            case "fill-extrusion":
              return new wP(f);
            case "heatmap":
              return new KM(f);
            case "hillshade":
              return new QM(f);
            case "line":
              return new PP(f);
            case "raster":
              return new rR(f);
            case "symbol":
              return new Yg(f);
          }
        }, l.bx = wt, l.by = function(f, c) {
          if (!f) return [{ command: "setStyle", args: [c] }];
          let h = [];
          try {
            if (!pe(f.version, c.version)) return [{ command: "setStyle", args: [c] }];
            pe(f.center, c.center) || h.push({ command: "setCenter", args: [c.center] }), pe(f.centerAltitude, c.centerAltitude) || h.push({ command: "setCenterAltitude", args: [c.centerAltitude] }), pe(f.zoom, c.zoom) || h.push({ command: "setZoom", args: [c.zoom] }), pe(f.bearing, c.bearing) || h.push({ command: "setBearing", args: [c.bearing] }), pe(f.pitch, c.pitch) || h.push({ command: "setPitch", args: [c.pitch] }), pe(f.roll, c.roll) || h.push({ command: "setRoll", args: [c.roll] }), pe(f.sprite, c.sprite) || h.push({ command: "setSprite", args: [c.sprite] }), pe(f.glyphs, c.glyphs) || h.push({ command: "setGlyphs", args: [c.glyphs] }), pe(f.transition, c.transition) || h.push({ command: "setTransition", args: [c.transition] }), pe(f.light, c.light) || h.push({ command: "setLight", args: [c.light] }), pe(f.terrain, c.terrain) || h.push({ command: "setTerrain", args: [c.terrain] }), pe(f.sky, c.sky) || h.push({ command: "setSky", args: [c.sky] }), pe(f.projection, c.projection) || h.push({ command: "setProjection", args: [c.projection] });
            const p = {}, y = [];
            (function(A, I, B, N) {
              let z;
              for (z in I = I || {}, A = A || {}) Object.prototype.hasOwnProperty.call(A, z) && (Object.prototype.hasOwnProperty.call(I, z) || rt(z, B, N));
              for (z in I) Object.prototype.hasOwnProperty.call(I, z) && (Object.prototype.hasOwnProperty.call(A, z) ? pe(A[z], I[z]) || (A[z].type === "geojson" && I[z].type === "geojson" && Ye(A, I, z) ? Oe(B, { command: "setGeoJSONSourceData", args: [z, I[z].data] }) : gt(z, I, B, N)) : Ge(z, I, B));
            })(f.sources, c.sources, y, p);
            const x = [];
            f.layers && f.layers.forEach((A) => {
              "source" in A && p[A.source] ? h.push({ command: "removeLayer", args: [A.id] }) : x.push(A);
            }), h = h.concat(y), function(A, I, B) {
              I = I || [];
              const N = (A = A || []).map(pt), z = I.map(pt), j = A.reduce(ct, {}), K = I.reduce(ct, {}), ee = N.slice(), te = /* @__PURE__ */ Object.create(null);
              let le, Ae, Te, Qe, ke;
              for (let Q = 0, xe = 0; Q < N.length; Q++) le = N[Q], Object.prototype.hasOwnProperty.call(K, le) ? xe++ : (Oe(B, { command: "removeLayer", args: [le] }), ee.splice(ee.indexOf(le, xe), 1));
              for (let Q = 0, xe = 0; Q < z.length; Q++) le = z[z.length - 1 - Q], ee[ee.length - 1 - Q] !== le && (Object.prototype.hasOwnProperty.call(j, le) ? (Oe(B, { command: "removeLayer", args: [le] }), ee.splice(ee.lastIndexOf(le, ee.length - xe), 1)) : xe++, Qe = ee[ee.length - Q], Oe(B, { command: "addLayer", args: [K[le], Qe] }), ee.splice(ee.length - Q, 0, le), te[le] = !0);
              for (let Q = 0; Q < z.length; Q++) if (le = z[Q], Ae = j[le], Te = K[le], !te[le] && !pe(Ae, Te)) if (pe(Ae.source, Te.source) && pe(Ae["source-layer"], Te["source-layer"]) && pe(Ae.type, Te.type)) {
                for (ke in lt(Ae.layout, Te.layout, B, le, null, "setLayoutProperty"), lt(Ae.paint, Te.paint, B, le, null, "setPaintProperty"), pe(Ae.filter, Te.filter) || Oe(B, { command: "setFilter", args: [le, Te.filter] }), pe(Ae.minzoom, Te.minzoom) && pe(Ae.maxzoom, Te.maxzoom) || Oe(B, { command: "setLayerZoomRange", args: [le, Te.minzoom, Te.maxzoom] }), Ae) Object.prototype.hasOwnProperty.call(Ae, ke) && ke !== "layout" && ke !== "paint" && ke !== "filter" && ke !== "metadata" && ke !== "minzoom" && ke !== "maxzoom" && (ke.indexOf("paint.") === 0 ? lt(Ae[ke], Te[ke], B, le, ke.slice(6), "setPaintProperty") : pe(Ae[ke], Te[ke]) || Oe(B, { command: "setLayerProperty", args: [le, ke, Te[ke]] }));
                for (ke in Te) Object.prototype.hasOwnProperty.call(Te, ke) && !Object.prototype.hasOwnProperty.call(Ae, ke) && ke !== "layout" && ke !== "paint" && ke !== "filter" && ke !== "metadata" && ke !== "minzoom" && ke !== "maxzoom" && (ke.indexOf("paint.") === 0 ? lt(Ae[ke], Te[ke], B, le, ke.slice(6), "setPaintProperty") : pe(Ae[ke], Te[ke]) || Oe(B, { command: "setLayerProperty", args: [le, ke, Te[ke]] }));
              } else Oe(B, { command: "removeLayer", args: [le] }), Qe = ee[ee.lastIndexOf(le) + 1], Oe(B, { command: "addLayer", args: [Te, Qe] });
            }(x, c.layers, h);
          } catch (p) {
            console.warn("Unable to compute style diff:", p), h = [{ command: "setStyle", args: [c] }];
          }
          return h;
        }, l.bz = function(f) {
          const c = [], h = f.id;
          return h === void 0 && c.push({ message: `layers.${h}: missing required property "id"` }), f.render === void 0 && c.push({ message: `layers.${h}: missing required method "render"` }), f.renderingMode && f.renderingMode !== "2d" && f.renderingMode !== "3d" && c.push({ message: `layers.${h}: property "renderingMode" must be either "2d" or "3d"` }), c;
        }, l.c = br, l.c0 = (f) => f.type === "line", l.c1 = (f) => f.type === "fill", l.c2 = (f) => f.type === "fill-extrusion", l.c3 = (f) => f.type === "hillshade", l.c4 = (f) => f.type === "raster", l.c5 = (f) => f.type === "background", l.c6 = (f) => f.type === "custom", l.c7 = mr, l.c8 = function(f, c, h) {
          const p = Ct(c.x - h.x, c.y - h.y), y = Ct(f.x - h.x, f.y - h.y);
          var x, A;
          return hr(Math.atan2(p[0] * y[1] - p[1] * y[0], (x = p)[0] * (A = y)[0] + x[1] * A[1]));
        }, l.c9 = ce, l.cA = Bx, l.cB = Gx, l.cC = Yl, l.cD = et, l.ca = function(f, c, h) {
          var p = c[0], y = c[1];
          return f[0] = h[0] * p + h[4] * y + h[12], f[1] = h[1] * p + h[5] * y + h[13], f;
        }, l.cb = function(f, c) {
          const { x: h, y: p } = Ap.fromLngLat(c);
          return !(f < 0 || f > 25 || p < 0 || p >= 1 || h < 0 || h >= 1);
        }, l.cc = function(f, c) {
          return f[0] = c[0], f[1] = 0, f[2] = 0, f[3] = 0, f[4] = 0, f[5] = c[1], f[6] = 0, f[7] = 0, f[8] = 0, f[9] = 0, f[10] = c[2], f[11] = 0, f[12] = 0, f[13] = 0, f[14] = 0, f[15] = 1, f;
        }, l.cd = class extends li {
        }, l.ce = dR, l.cg = function(f) {
          return f.message === wr;
        }, l.ch = Zr, l.ci = function(f, c) {
          Rr.REGISTERED_PROTOCOLS[f] = c;
        }, l.cj = function(f) {
          delete Rr.REGISTERED_PROTOCOLS[f];
        }, l.ck = function(f, c) {
          const h = {};
          for (let y = 0; y < f.length; y++) {
            const x = c && c[f[y].id] || Fh(f[y]);
            c && (c[f[y].id] = x);
            let A = h[x];
            A || (A = h[x] = []), A.push(f[y]);
          }
          const p = [];
          for (const y in h) p.push(h[y]);
          return p;
        }, l.cl = vr, l.cm = gw, l.cn = _w, l.co = Hx, l.cp = function(f) {
          f.bucket.createArrays(), f.bucket.tilePixelRatio = ht / (512 * f.bucket.overscaling), f.bucket.compareText = {}, f.bucket.iconsNeedLinear = !1;
          const c = f.bucket.layers[0], h = c.layout, p = c._unevaluatedLayout._values, y = { layoutIconSize: p["icon-size"].possiblyEvaluate(new ot(f.bucket.zoom + 1), f.canonical), layoutTextSize: p["text-size"].possiblyEvaluate(new ot(f.bucket.zoom + 1), f.canonical), textMaxSize: p["text-size"].possiblyEvaluate(new ot(18)) };
          if (f.bucket.textSizeData.kind === "composite") {
            const { minZoom: N, maxZoom: z } = f.bucket.textSizeData;
            y.compositeTextSizes = [p["text-size"].possiblyEvaluate(new ot(N), f.canonical), p["text-size"].possiblyEvaluate(new ot(z), f.canonical)];
          }
          if (f.bucket.iconSizeData.kind === "composite") {
            const { minZoom: N, maxZoom: z } = f.bucket.iconSizeData;
            y.compositeIconSizes = [p["icon-size"].possiblyEvaluate(new ot(N), f.canonical), p["icon-size"].possiblyEvaluate(new ot(z), f.canonical)];
          }
          const x = h.get("text-line-height") * bs, A = h.get("text-rotation-alignment") !== "viewport" && h.get("symbol-placement") !== "point", I = h.get("text-keep-upright"), B = h.get("text-size");
          for (const N of f.bucket.features) {
            const z = h.get("text-font").evaluate(N, {}, f.canonical).join(","), j = B.evaluate(N, {}, f.canonical), K = y.layoutTextSize.evaluate(N, {}, f.canonical), ee = y.layoutIconSize.evaluate(N, {}, f.canonical), te = { horizontal: {}, vertical: void 0 }, le = N.text;
            let Ae, Te = [0, 0];
            if (le) {
              const Q = le.toString(), xe = h.get("text-letter-spacing").evaluate(N, {}, f.canonical) * bs, ze = $h(Q) ? xe : 0, yt = h.get("text-anchor").evaluate(N, {}, f.canonical), $t = Mw(c, N, f.canonical);
              if (!$t) {
                const Xt = h.get("text-radial-offset").evaluate(N, {}, f.canonical);
                Te = Xt ? Iw(yt, [Xt * bs, b0]) : h.get("text-offset").evaluate(N, {}, f.canonical).map((ir) => ir * bs);
              }
              let It = A ? "center" : h.get("text-justify").evaluate(N, {}, f.canonical);
              const Lt = h.get("symbol-placement") === "point" ? h.get("text-max-width").evaluate(N, {}, f.canonical) * bs : 1 / 0, er = () => {
                f.bucket.allowVerticalPlacement && Zc(Q) && (te.vertical = Wg(le, f.glyphMap, f.glyphPositions, f.imagePositions, z, Lt, x, yt, "left", ze, Te, l.af.vertical, !0, K, j));
              };
              if (!A && $t) {
                const Xt = /* @__PURE__ */ new Set();
                if (It === "auto") for (let Dt = 0; Dt < $t.values.length; Dt += 2) Xt.add(v0($t.values[Dt]));
                else Xt.add(It);
                let ir = !1;
                for (const Dt of Xt) if (!te.horizontal[Dt]) if (ir) te.horizontal[Dt] = te.horizontal[0];
                else {
                  const Er = Wg(le, f.glyphMap, f.glyphPositions, f.imagePositions, z, Lt, x, "center", Dt, ze, Te, l.af.horizontal, !1, K, j);
                  Er && (te.horizontal[Dt] = Er, ir = Er.positionedLines.length === 1);
                }
                er();
              } else {
                It === "auto" && (It = v0(yt));
                const Xt = Wg(le, f.glyphMap, f.glyphPositions, f.imagePositions, z, Lt, x, yt, It, ze, Te, l.af.horizontal, !1, K, j);
                Xt && (te.horizontal[It] = Xt), er(), Zc(Q) && A && I && (te.vertical = Wg(le, f.glyphMap, f.glyphPositions, f.imagePositions, z, Lt, x, yt, It, ze, Te, l.af.vertical, !1, K, j));
              }
            }
            let Qe = !1;
            if (N.icon && N.icon.name) {
              const Q = f.imageMap[N.icon.name];
              Q && (Ae = ZP(f.imagePositions[N.icon.name], h.get("icon-offset").evaluate(N, {}, f.canonical), h.get("icon-anchor").evaluate(N, {}, f.canonical)), Qe = !!Q.sdf, f.bucket.sdfIcons === void 0 ? f.bucket.sdfIcons = Qe : f.bucket.sdfIcons !== Qe && Yt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (Q.pixelRatio !== f.bucket.pixelRatio || h.get("icon-rotate").constantOr(1) !== 0) && (f.bucket.iconsNeedLinear = !0));
            }
            const ke = Rw(te.horizontal) || te.vertical;
            f.bucket.iconsInText = !!ke && ke.iconsInText, (ke || Ae) && hR(f.bucket, N, te, Ae, f.imageMap, y, K, ee, Te, Qe, f.canonical, f.subdivisionGranularity);
          }
          f.showCollisionBoxes && f.bucket.generateCollisionDebugBuffers();
        }, l.cq = n0, l.cr = Ky, l.cs = r0, l.ct = _p, l.cu = o0, l.cv = class {
          constructor(f) {
            this._marks = { start: [f.url, "start"].join("#"), end: [f.url, "end"].join("#"), measure: f.url.toString() }, performance.mark(this._marks.start);
          }
          finish() {
            performance.mark(this._marks.end);
            let f = performance.getEntriesByName(this._marks.measure);
            return f.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), f = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), f;
          }
        }, l.cw = function(f, c, h, p, y) {
          return o(this, void 0, void 0, function* () {
            if (X()) try {
              return yield jr(f, c, h, p, y);
            } catch {
            }
            return function(x, A, I, B, N) {
              const z = x.width, j = x.height;
              Ir && rr || (Ir = new OffscreenCanvas(z, j), rr = Ir.getContext("2d", { willReadFrequently: !0 })), Ir.width = z, Ir.height = j, rr.drawImage(x, 0, 0, z, j);
              const K = rr.getImageData(A, I, B, N);
              return rr.clearRect(0, 0, z, j), K.data;
            }(f, c, h, p, y);
          });
        }, l.cx = pw, l.cy = d, l.cz = T, l.d = (f) => o(void 0, void 0, void 0, function* () {
          if (f.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
          const c = new Blob([new Uint8Array(f)], { type: "image/png" });
          try {
            return createImageBitmap(c);
          } catch (h) {
            throw new Error(`Could not load image because of ${h.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
          }
        }), l.e = Xe, l.f = (f) => new Promise((c, h) => {
          const p = new Image();
          p.onload = () => {
            c(p), URL.revokeObjectURL(p.src), p.onload = null, window.requestAnimationFrame(() => {
              p.src = Ve;
            });
          }, p.onerror = () => h(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          const y = new Blob([new Uint8Array(f)], { type: "image/png" });
          p.src = f.byteLength ? URL.createObjectURL(y) : Ve;
        }), l.g = $r, l.h = (f, c) => yn(Xe(f, { type: "json" }), c), l.i = _r, l.j = bn, l.k = Ii, l.l = (f, c) => yn(Xe(f, { type: "arrayBuffer" }), c), l.m = yn, l.n = function(f) {
          return new o0(f).readFields(kP, []);
        }, l.o = up, l.p = $x, l.q = rn, l.r = eh, l.s = Vr, l.t = Ff, l.u = cn, l.v = ve, l.w = Yt, l.x = Wc, l.y = function(f) {
          let [c, h, p] = f;
          return h += 90, h *= Math.PI / 180, p *= Math.PI / 180, { x: c * Math.cos(h) * Math.sin(p), y: c * Math.sin(h) * Math.sin(p), z: c * Math.cos(p) };
        }, l.z = ho;
      }), i("worker", ["./shared"], function(l) {
        class o {
          constructor(se) {
            this.keyCache = {}, se && this.replace(se);
          }
          replace(se) {
            this._layerConfigs = {}, this._layers = {}, this.update(se, []);
          }
          update(se, de) {
            for (const Oe of se) {
              this._layerConfigs[Oe.id] = Oe;
              const Ge = this._layers[Oe.id] = l.bw(Oe);
              Ge._featureFilter = l.a5(Ge.filter), this.keyCache[Oe.id] && delete this.keyCache[Oe.id];
            }
            for (const Oe of de) delete this.keyCache[Oe], delete this._layerConfigs[Oe], delete this._layers[Oe];
            this.familiesBySource = {};
            const pe = l.ck(Object.values(this._layerConfigs), this.keyCache);
            for (const Oe of pe) {
              const Ge = Oe.map((ct) => this._layers[ct.id]), rt = Ge[0];
              if (rt.visibility === "none") continue;
              const gt = rt.source || "";
              let Ye = this.familiesBySource[gt];
              Ye || (Ye = this.familiesBySource[gt] = {});
              const lt = rt.sourceLayer || "_geojsonTileLayer";
              let pt = Ye[lt];
              pt || (pt = Ye[lt] = []), pt.push(Ge);
            }
          }
        }
        class d {
          constructor(se) {
            const de = {}, pe = [];
            for (const gt in se) {
              const Ye = se[gt], lt = de[gt] = {};
              for (const pt in Ye) {
                const ct = Ye[+pt];
                if (!ct || ct.bitmap.width === 0 || ct.bitmap.height === 0) continue;
                const We = { x: 0, y: 0, w: ct.bitmap.width + 2, h: ct.bitmap.height + 2 };
                pe.push(We), lt[pt] = { rect: We, metrics: ct.metrics };
              }
            }
            const { w: Oe, h: Ge } = l.p(pe), rt = new l.o({ width: Oe || 1, height: Ge || 1 });
            for (const gt in se) {
              const Ye = se[gt];
              for (const lt in Ye) {
                const pt = Ye[+lt];
                if (!pt || pt.bitmap.width === 0 || pt.bitmap.height === 0) continue;
                const ct = de[gt][lt].rect;
                l.o.copy(pt.bitmap, rt, { x: 0, y: 0 }, { x: ct.x + 1, y: ct.y + 1 }, pt.bitmap);
              }
            }
            this.image = rt, this.positions = de;
          }
        }
        l.cl("GlyphAtlas", d);
        class m {
          constructor(se) {
            this.tileID = new l.X(se.tileID.overscaledZ, se.tileID.wrap, se.tileID.canonical.z, se.tileID.canonical.x, se.tileID.canonical.y), this.uid = se.uid, this.zoom = se.zoom, this.pixelRatio = se.pixelRatio, this.tileSize = se.tileSize, this.source = se.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = se.showCollisionBoxes, this.collectResourceTiming = !!se.collectResourceTiming, this.returnDependencies = !!se.returnDependencies, this.promoteId = se.promoteId, this.inFlightDependencies = [];
          }
          parse(se, de, pe, Oe, Ge) {
            return l._(this, void 0, void 0, function* () {
              this.status = "parsing", this.data = se, this.collisionBoxArray = new l.a3();
              const rt = new l.cm(Object.keys(se.layers).sort()), gt = new l.cn(this.tileID, this.promoteId);
              gt.bucketLayerIDs = [];
              const Ye = {}, lt = { featureIndex: gt, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: pe, subdivisionGranularity: Ge }, pt = de.familiesBySource[this.source];
              for (const Or in pt) {
                const gr = se.layers[Or];
                if (!gr) continue;
                gr.version === 1 && l.w(`Vector tile source "${this.source}" layer "${Or}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const Sn = rt.encode(Or), Zi = [];
                for (let Dn = 0; Dn < gr.length; Dn++) {
                  const kn = gr.feature(Dn), vn = gt.getId(kn, Or);
                  Zi.push({ feature: kn, id: vn, index: Dn, sourceLayerIndex: Sn });
                }
                for (const Dn of pt[Or]) {
                  const kn = Dn[0];
                  kn.source !== this.source && l.w(`layer.source = ${kn.source} does not equal this.source = ${this.source}`), kn.minzoom && this.zoom < Math.floor(kn.minzoom) || kn.maxzoom && this.zoom >= kn.maxzoom || kn.visibility !== "none" && (b(Dn, this.zoom, pe), (Ye[kn.id] = kn.createBucket({ index: gt.bucketLayerIDs.length, layers: Dn, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: Sn, sourceID: this.source })).populate(Zi, lt, this.tileID.canonical), gt.bucketLayerIDs.push(Dn.map((vn) => vn.id)));
                }
              }
              const ct = l.bB(lt.glyphDependencies, (Or) => Object.keys(Or).map(Number));
              this.inFlightDependencies.forEach((Or) => Or == null ? void 0 : Or.abort()), this.inFlightDependencies = [];
              let We = Promise.resolve({});
              if (Object.keys(ct).length) {
                const Or = new AbortController();
                this.inFlightDependencies.push(Or), We = Oe.sendAsync({ type: "GG", data: { stacks: ct, source: this.source, tileID: this.tileID, type: "glyphs" } }, Or);
              }
              const or = Object.keys(lt.iconDependencies);
              let Jt = Promise.resolve({});
              if (or.length) {
                const Or = new AbortController();
                this.inFlightDependencies.push(Or), Jt = Oe.sendAsync({ type: "GI", data: { icons: or, source: this.source, tileID: this.tileID, type: "icons" } }, Or);
              }
              const Kt = Object.keys(lt.patternDependencies);
              let Mr = Promise.resolve({});
              if (Kt.length) {
                const Or = new AbortController();
                this.inFlightDependencies.push(Or), Mr = Oe.sendAsync({ type: "GI", data: { icons: Kt, source: this.source, tileID: this.tileID, type: "patterns" } }, Or);
              }
              const [Bt, Qt, fr] = yield Promise.all([We, Jt, Mr]), Lr = new d(Bt), Hr = new l.co(Qt, fr);
              for (const Or in Ye) {
                const gr = Ye[Or];
                gr instanceof l.a4 ? (b(gr.layers, this.zoom, pe), l.cp({ bucket: gr, glyphMap: Bt, glyphPositions: Lr.positions, imageMap: Qt, imagePositions: Hr.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: lt.subdivisionGranularity })) : gr.hasPattern && (gr instanceof l.cq || gr instanceof l.cr || gr instanceof l.cs) && (b(gr.layers, this.zoom, pe), gr.addFeatures(lt, this.tileID.canonical, Hr.patternPositions));
              }
              return this.status = "done", { buckets: Object.values(Ye).filter((Or) => !Or.isEmpty()), featureIndex: gt, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: Lr.image, imageAtlas: Hr, glyphMap: this.returnDependencies ? Bt : null, iconMap: this.returnDependencies ? Qt : null, glyphPositions: this.returnDependencies ? Lr.positions : null };
            });
          }
        }
        function b(ve, se, de) {
          const pe = new l.B(se);
          for (const Oe of ve) Oe.recalculate(pe, de);
        }
        class T {
          constructor(se, de, pe) {
            this.actor = se, this.layerIndex = de, this.availableImages = pe, this.fetching = {}, this.loading = {}, this.loaded = {};
          }
          loadVectorTile(se, de) {
            return l._(this, void 0, void 0, function* () {
              const pe = yield l.l(se.request, de);
              try {
                return { vectorTile: new l.ct.VectorTile(new l.cu(pe.data)), rawData: pe.data, cacheControl: pe.cacheControl, expires: pe.expires };
              } catch (Oe) {
                const Ge = new Uint8Array(pe.data);
                let rt = `Unable to parse the tile at ${se.request.url}, `;
                throw rt += Ge[0] === 31 && Ge[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${Oe.message}`, new Error(rt);
              }
            });
          }
          loadTile(se) {
            return l._(this, void 0, void 0, function* () {
              const de = se.uid, pe = !!(se && se.request && se.request.collectResourceTiming) && new l.cv(se.request), Oe = new m(se);
              this.loading[de] = Oe;
              const Ge = new AbortController();
              Oe.abort = Ge;
              try {
                const rt = yield this.loadVectorTile(se, Ge);
                if (delete this.loading[de], !rt) return null;
                const gt = rt.rawData, Ye = {};
                rt.expires && (Ye.expires = rt.expires), rt.cacheControl && (Ye.cacheControl = rt.cacheControl);
                const lt = {};
                if (pe) {
                  const ct = pe.finish();
                  ct && (lt.resourceTiming = JSON.parse(JSON.stringify(ct)));
                }
                Oe.vectorTile = rt.vectorTile;
                const pt = Oe.parse(rt.vectorTile, this.layerIndex, this.availableImages, this.actor, se.subdivisionGranularity);
                this.loaded[de] = Oe, this.fetching[de] = { rawTileData: gt, cacheControl: Ye, resourceTiming: lt };
                try {
                  const ct = yield pt;
                  return l.e({ rawTileData: gt.slice(0) }, ct, Ye, lt);
                } finally {
                  delete this.fetching[de];
                }
              } catch (rt) {
                throw delete this.loading[de], Oe.status = "done", this.loaded[de] = Oe, rt;
              }
            });
          }
          reloadTile(se) {
            return l._(this, void 0, void 0, function* () {
              const de = se.uid;
              if (!this.loaded || !this.loaded[de]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
              const pe = this.loaded[de];
              if (pe.showCollisionBoxes = se.showCollisionBoxes, pe.status === "parsing") {
                const Oe = yield pe.parse(pe.vectorTile, this.layerIndex, this.availableImages, this.actor, se.subdivisionGranularity);
                let Ge;
                if (this.fetching[de]) {
                  const { rawTileData: rt, cacheControl: gt, resourceTiming: Ye } = this.fetching[de];
                  delete this.fetching[de], Ge = l.e({ rawTileData: rt.slice(0) }, Oe, gt, Ye);
                } else Ge = Oe;
                return Ge;
              }
              if (pe.status === "done" && pe.vectorTile) return pe.parse(pe.vectorTile, this.layerIndex, this.availableImages, this.actor, se.subdivisionGranularity);
            });
          }
          abortTile(se) {
            return l._(this, void 0, void 0, function* () {
              const de = this.loading, pe = se.uid;
              de && de[pe] && de[pe].abort && (de[pe].abort.abort(), delete de[pe]);
            });
          }
          removeTile(se) {
            return l._(this, void 0, void 0, function* () {
              this.loaded && this.loaded[se.uid] && delete this.loaded[se.uid];
            });
          }
        }
        class M {
          constructor() {
            this.loaded = {};
          }
          loadTile(se) {
            return l._(this, void 0, void 0, function* () {
              const { uid: de, encoding: pe, rawImageData: Oe, redFactor: Ge, greenFactor: rt, blueFactor: gt, baseShift: Ye } = se, lt = Oe.width + 2, pt = Oe.height + 2, ct = l.b(Oe) ? new l.R({ width: lt, height: pt }, yield l.cw(Oe, -1, -1, lt, pt)) : Oe, We = new l.cx(de, ct, pe, Ge, rt, gt, Ye);
              return this.loaded = this.loaded || {}, this.loaded[de] = We, We;
            });
          }
          removeTile(se) {
            const de = this.loaded, pe = se.uid;
            de && de[pe] && delete de[pe];
          }
        }
        var E, D, U = function() {
          if (D) return E;
          function ve(de, pe) {
            if (de.length !== 0) {
              se(de[0], pe);
              for (var Oe = 1; Oe < de.length; Oe++) se(de[Oe], !pe);
            }
          }
          function se(de, pe) {
            for (var Oe = 0, Ge = 0, rt = 0, gt = de.length, Ye = gt - 1; rt < gt; Ye = rt++) {
              var lt = (de[rt][0] - de[Ye][0]) * (de[Ye][1] + de[rt][1]), pt = Oe + lt;
              Ge += Math.abs(Oe) >= Math.abs(lt) ? Oe - pt + lt : lt - pt + Oe, Oe = pt;
            }
            Oe + Ge >= 0 != !!pe && de.reverse();
          }
          return D = 1, E = function de(pe, Oe) {
            var Ge, rt = pe && pe.type;
            if (rt === "FeatureCollection") for (Ge = 0; Ge < pe.features.length; Ge++) de(pe.features[Ge], Oe);
            else if (rt === "GeometryCollection") for (Ge = 0; Ge < pe.geometries.length; Ge++) de(pe.geometries[Ge], Oe);
            else if (rt === "Feature") de(pe.geometry, Oe);
            else if (rt === "Polygon") ve(pe.coordinates, Oe);
            else if (rt === "MultiPolygon") for (Ge = 0; Ge < pe.coordinates.length; Ge++) ve(pe.coordinates[Ge], Oe);
            return pe;
          };
        }(), q = l.cy(U);
        const G = l.ct.VectorTileFeature.prototype.toGeoJSON;
        class Y {
          constructor(se) {
            this._feature = se, this.extent = l.Y, this.type = se.type, this.properties = se.tags, "id" in se && !isNaN(se.id) && (this.id = parseInt(se.id, 10));
          }
          loadGeometry() {
            if (this._feature.type === 1) {
              const se = [];
              for (const de of this._feature.geometry) se.push([new l.P(de[0], de[1])]);
              return se;
            }
            {
              const se = [];
              for (const de of this._feature.geometry) {
                const pe = [];
                for (const Oe of de) pe.push(new l.P(Oe[0], Oe[1]));
                se.push(pe);
              }
              return se;
            }
          }
          toGeoJSON(se, de, pe) {
            return G.call(this, se, de, pe);
          }
        }
        class he {
          constructor(se) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = l.Y, this.length = se.length, this._features = se;
          }
          feature(se) {
            return new Y(this._features[se]);
          }
        }
        var X, J, ie, ye = { exports: {} }, oe = function() {
          if (ie) return ye.exports;
          ie = 1;
          var ve = l.cB(), se = function() {
            if (J) return X;
            J = 1;
            var pt = l.cz(), ct = l.cA().VectorTileFeature;
            function We(Jt, Kt) {
              this.options = Kt || {}, this.features = Jt, this.length = Jt.length;
            }
            function or(Jt, Kt) {
              this.id = typeof Jt.id == "number" ? Jt.id : void 0, this.type = Jt.type, this.rawGeometry = Jt.type === 1 ? [Jt.geometry] : Jt.geometry, this.properties = Jt.tags, this.extent = Kt || 4096;
            }
            return X = We, We.prototype.feature = function(Jt) {
              return new or(this.features[Jt], this.options.extent);
            }, or.prototype.loadGeometry = function() {
              var Jt = this.rawGeometry;
              this.geometry = [];
              for (var Kt = 0; Kt < Jt.length; Kt++) {
                for (var Mr = Jt[Kt], Bt = [], Qt = 0; Qt < Mr.length; Qt++) Bt.push(new pt(Mr[Qt][0], Mr[Qt][1]));
                this.geometry.push(Bt);
              }
              return this.geometry;
            }, or.prototype.bbox = function() {
              this.geometry || this.loadGeometry();
              for (var Jt = this.geometry, Kt = 1 / 0, Mr = -1 / 0, Bt = 1 / 0, Qt = -1 / 0, fr = 0; fr < Jt.length; fr++) for (var Lr = Jt[fr], Hr = 0; Hr < Lr.length; Hr++) {
                var Or = Lr[Hr];
                Kt = Math.min(Kt, Or.x), Mr = Math.max(Mr, Or.x), Bt = Math.min(Bt, Or.y), Qt = Math.max(Qt, Or.y);
              }
              return [Kt, Bt, Mr, Qt];
            }, or.prototype.toGeoJSON = ct.prototype.toGeoJSON, X;
          }();
          function de(pt) {
            var ct = new ve();
            return function(We, or) {
              for (var Jt in We.layers) or.writeMessage(3, pe, We.layers[Jt]);
            }(pt, ct), ct.finish();
          }
          function pe(pt, ct) {
            var We;
            ct.writeVarintField(15, pt.version || 1), ct.writeStringField(1, pt.name || ""), ct.writeVarintField(5, pt.extent || 4096);
            var or = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (We = 0; We < pt.length; We++) or.feature = pt.feature(We), ct.writeMessage(2, Oe, or);
            var Jt = or.keys;
            for (We = 0; We < Jt.length; We++) ct.writeStringField(3, Jt[We]);
            var Kt = or.values;
            for (We = 0; We < Kt.length; We++) ct.writeMessage(4, lt, Kt[We]);
          }
          function Oe(pt, ct) {
            var We = pt.feature;
            We.id !== void 0 && ct.writeVarintField(1, We.id), ct.writeMessage(2, Ge, pt), ct.writeVarintField(3, We.type), ct.writeMessage(4, Ye, We);
          }
          function Ge(pt, ct) {
            var We = pt.feature, or = pt.keys, Jt = pt.values, Kt = pt.keycache, Mr = pt.valuecache;
            for (var Bt in We.properties) {
              var Qt = We.properties[Bt], fr = Kt[Bt];
              if (Qt !== null) {
                fr === void 0 && (or.push(Bt), Kt[Bt] = fr = or.length - 1), ct.writeVarint(fr);
                var Lr = typeof Qt;
                Lr !== "string" && Lr !== "boolean" && Lr !== "number" && (Qt = JSON.stringify(Qt));
                var Hr = Lr + ":" + Qt, Or = Mr[Hr];
                Or === void 0 && (Jt.push(Qt), Mr[Hr] = Or = Jt.length - 1), ct.writeVarint(Or);
              }
            }
          }
          function rt(pt, ct) {
            return (ct << 3) + (7 & pt);
          }
          function gt(pt) {
            return pt << 1 ^ pt >> 31;
          }
          function Ye(pt, ct) {
            for (var We = pt.loadGeometry(), or = pt.type, Jt = 0, Kt = 0, Mr = We.length, Bt = 0; Bt < Mr; Bt++) {
              var Qt = We[Bt], fr = 1;
              or === 1 && (fr = Qt.length), ct.writeVarint(rt(1, fr));
              for (var Lr = or === 3 ? Qt.length - 1 : Qt.length, Hr = 0; Hr < Lr; Hr++) {
                Hr === 1 && or !== 1 && ct.writeVarint(rt(2, Lr - 1));
                var Or = Qt[Hr].x - Jt, gr = Qt[Hr].y - Kt;
                ct.writeVarint(gt(Or)), ct.writeVarint(gt(gr)), Jt += Or, Kt += gr;
              }
              or === 3 && ct.writeVarint(rt(7, 1));
            }
          }
          function lt(pt, ct) {
            var We = typeof pt;
            We === "string" ? ct.writeStringField(1, pt) : We === "boolean" ? ct.writeBooleanField(7, pt) : We === "number" && (pt % 1 != 0 ? ct.writeDoubleField(3, pt) : pt < 0 ? ct.writeSVarintField(6, pt) : ct.writeVarintField(5, pt));
          }
          return ye.exports = de, ye.exports.fromVectorTileJs = de, ye.exports.fromGeojsonVt = function(pt, ct) {
            ct = ct || {};
            var We = {};
            for (var or in pt) We[or] = new se(pt[or].features, ct), We[or].name = or, We[or].version = ct.version, We[or].extent = ct.extent;
            return de({ layers: We });
          }, ye.exports.GeoJSONWrapper = se, ye.exports;
        }(), Re = l.cy(oe);
        const Ne = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (ve) => ve }, me = Math.fround || (_e = new Float32Array(1), (ve) => (_e[0] = +ve, _e[0]));
        var _e;
        const Fe = 3, Me = 5, Ct = 6;
        class ht {
          constructor(se) {
            this.options = Object.assign(Object.create(Ne), se), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
          }
          load(se) {
            const { log: de, minZoom: pe, maxZoom: Oe } = this.options;
            de && console.time("total time");
            const Ge = `prepare ${se.length} points`;
            de && console.time(Ge), this.points = se;
            const rt = [];
            for (let Ye = 0; Ye < se.length; Ye++) {
              const lt = se[Ye];
              if (!lt.geometry) continue;
              const [pt, ct] = lt.geometry.coordinates, We = me(kt(pt)), or = me(Nt(ct));
              rt.push(We, or, 1 / 0, Ye, -1, 1), this.options.reduce && rt.push(0);
            }
            let gt = this.trees[Oe + 1] = this._createTree(rt);
            de && console.timeEnd(Ge);
            for (let Ye = Oe; Ye >= pe; Ye--) {
              const lt = +Date.now();
              gt = this.trees[Ye] = this._createTree(this._cluster(gt, Ye)), de && console.log("z%d: %d clusters in %dms", Ye, gt.numItems, +Date.now() - lt);
            }
            return de && console.timeEnd("total time"), this;
          }
          getClusters(se, de) {
            let pe = ((se[0] + 180) % 360 + 360) % 360 - 180;
            const Oe = Math.max(-90, Math.min(90, se[1]));
            let Ge = se[2] === 180 ? 180 : ((se[2] + 180) % 360 + 360) % 360 - 180;
            const rt = Math.max(-90, Math.min(90, se[3]));
            if (se[2] - se[0] >= 360) pe = -180, Ge = 180;
            else if (pe > Ge) {
              const ct = this.getClusters([pe, Oe, 180, rt], de), We = this.getClusters([-180, Oe, Ge, rt], de);
              return ct.concat(We);
            }
            const gt = this.trees[this._limitZoom(de)], Ye = gt.range(kt(pe), Nt(rt), kt(Ge), Nt(Oe)), lt = gt.data, pt = [];
            for (const ct of Ye) {
              const We = this.stride * ct;
              pt.push(lt[We + Me] > 1 ? Pt(lt, We, this.clusterProps) : this.points[lt[We + Fe]]);
            }
            return pt;
          }
          getChildren(se) {
            const de = this._getOriginId(se), pe = this._getOriginZoom(se), Oe = "No cluster with the specified id.", Ge = this.trees[pe];
            if (!Ge) throw new Error(Oe);
            const rt = Ge.data;
            if (de * this.stride >= rt.length) throw new Error(Oe);
            const gt = this.options.radius / (this.options.extent * Math.pow(2, pe - 1)), Ye = Ge.within(rt[de * this.stride], rt[de * this.stride + 1], gt), lt = [];
            for (const pt of Ye) {
              const ct = pt * this.stride;
              rt[ct + 4] === se && lt.push(rt[ct + Me] > 1 ? Pt(rt, ct, this.clusterProps) : this.points[rt[ct + Fe]]);
            }
            if (lt.length === 0) throw new Error(Oe);
            return lt;
          }
          getLeaves(se, de, pe) {
            const Oe = [];
            return this._appendLeaves(Oe, se, de = de || 10, pe = pe || 0, 0), Oe;
          }
          getTile(se, de, pe) {
            const Oe = this.trees[this._limitZoom(se)], Ge = Math.pow(2, se), { extent: rt, radius: gt } = this.options, Ye = gt / rt, lt = (pe - Ye) / Ge, pt = (pe + 1 + Ye) / Ge, ct = { features: [] };
            return this._addTileFeatures(Oe.range((de - Ye) / Ge, lt, (de + 1 + Ye) / Ge, pt), Oe.data, de, pe, Ge, ct), de === 0 && this._addTileFeatures(Oe.range(1 - Ye / Ge, lt, 1, pt), Oe.data, Ge, pe, Ge, ct), de === Ge - 1 && this._addTileFeatures(Oe.range(0, lt, Ye / Ge, pt), Oe.data, -1, pe, Ge, ct), ct.features.length ? ct : null;
          }
          getClusterExpansionZoom(se) {
            let de = this._getOriginZoom(se) - 1;
            for (; de <= this.options.maxZoom; ) {
              const pe = this.getChildren(se);
              if (de++, pe.length !== 1) break;
              se = pe[0].properties.cluster_id;
            }
            return de;
          }
          _appendLeaves(se, de, pe, Oe, Ge) {
            const rt = this.getChildren(de);
            for (const gt of rt) {
              const Ye = gt.properties;
              if (Ye && Ye.cluster ? Ge + Ye.point_count <= Oe ? Ge += Ye.point_count : Ge = this._appendLeaves(se, Ye.cluster_id, pe, Oe, Ge) : Ge < Oe ? Ge++ : se.push(gt), se.length === pe) break;
            }
            return Ge;
          }
          _createTree(se) {
            const de = new l.aA(se.length / this.stride | 0, this.options.nodeSize, Float32Array);
            for (let pe = 0; pe < se.length; pe += this.stride) de.add(se[pe], se[pe + 1]);
            return de.finish(), de.data = se, de;
          }
          _addTileFeatures(se, de, pe, Oe, Ge, rt) {
            for (const gt of se) {
              const Ye = gt * this.stride, lt = de[Ye + Me] > 1;
              let pt, ct, We;
              if (lt) pt = bt(de, Ye, this.clusterProps), ct = de[Ye], We = de[Ye + 1];
              else {
                const Kt = this.points[de[Ye + Fe]];
                pt = Kt.properties;
                const [Mr, Bt] = Kt.geometry.coordinates;
                ct = kt(Mr), We = Nt(Bt);
              }
              const or = { type: 1, geometry: [[Math.round(this.options.extent * (ct * Ge - pe)), Math.round(this.options.extent * (We * Ge - Oe))]], tags: pt };
              let Jt;
              Jt = lt || this.options.generateId ? de[Ye + Fe] : this.points[de[Ye + Fe]].id, Jt !== void 0 && (or.id = Jt), rt.features.push(or);
            }
          }
          _limitZoom(se) {
            return Math.max(this.options.minZoom, Math.min(Math.floor(+se), this.options.maxZoom + 1));
          }
          _cluster(se, de) {
            const { radius: pe, extent: Oe, reduce: Ge, minPoints: rt } = this.options, gt = pe / (Oe * Math.pow(2, de)), Ye = se.data, lt = [], pt = this.stride;
            for (let ct = 0; ct < Ye.length; ct += pt) {
              if (Ye[ct + 2] <= de) continue;
              Ye[ct + 2] = de;
              const We = Ye[ct], or = Ye[ct + 1], Jt = se.within(Ye[ct], Ye[ct + 1], gt), Kt = Ye[ct + Me];
              let Mr = Kt;
              for (const Bt of Jt) {
                const Qt = Bt * pt;
                Ye[Qt + 2] > de && (Mr += Ye[Qt + Me]);
              }
              if (Mr > Kt && Mr >= rt) {
                let Bt, Qt = We * Kt, fr = or * Kt, Lr = -1;
                const Hr = ((ct / pt | 0) << 5) + (de + 1) + this.points.length;
                for (const Or of Jt) {
                  const gr = Or * pt;
                  if (Ye[gr + 2] <= de) continue;
                  Ye[gr + 2] = de;
                  const Sn = Ye[gr + Me];
                  Qt += Ye[gr] * Sn, fr += Ye[gr + 1] * Sn, Ye[gr + 4] = Hr, Ge && (Bt || (Bt = this._map(Ye, ct, !0), Lr = this.clusterProps.length, this.clusterProps.push(Bt)), Ge(Bt, this._map(Ye, gr)));
                }
                Ye[ct + 4] = Hr, lt.push(Qt / Mr, fr / Mr, 1 / 0, Hr, -1, Mr), Ge && lt.push(Lr);
              } else {
                for (let Bt = 0; Bt < pt; Bt++) lt.push(Ye[ct + Bt]);
                if (Mr > 1) for (const Bt of Jt) {
                  const Qt = Bt * pt;
                  if (!(Ye[Qt + 2] <= de)) {
                    Ye[Qt + 2] = de;
                    for (let fr = 0; fr < pt; fr++) lt.push(Ye[Qt + fr]);
                  }
                }
              }
            }
            return lt;
          }
          _getOriginId(se) {
            return se - this.points.length >> 5;
          }
          _getOriginZoom(se) {
            return (se - this.points.length) % 32;
          }
          _map(se, de, pe) {
            if (se[de + Me] > 1) {
              const rt = this.clusterProps[se[de + Ct]];
              return pe ? Object.assign({}, rt) : rt;
            }
            const Oe = this.points[se[de + Fe]].properties, Ge = this.options.map(Oe);
            return pe && Ge === Oe ? Object.assign({}, Ge) : Ge;
          }
        }
        function Pt(ve, se, de) {
          return { type: "Feature", id: ve[se + Fe], properties: bt(ve, se, de), geometry: { type: "Point", coordinates: [(pe = ve[se], 360 * (pe - 0.5)), mr(ve[se + 1])] } };
          var pe;
        }
        function bt(ve, se, de) {
          const pe = ve[se + Me], Oe = pe >= 1e4 ? `${Math.round(pe / 1e3)}k` : pe >= 1e3 ? Math.round(pe / 100) / 10 + "k" : pe, Ge = ve[se + Ct], rt = Ge === -1 ? {} : Object.assign({}, de[Ge]);
          return Object.assign(rt, { cluster: !0, cluster_id: ve[se + Fe], point_count: pe, point_count_abbreviated: Oe });
        }
        function kt(ve) {
          return ve / 360 + 0.5;
        }
        function Nt(ve) {
          const se = Math.sin(ve * Math.PI / 180), de = 0.5 - 0.25 * Math.log((1 + se) / (1 - se)) / Math.PI;
          return de < 0 ? 0 : de > 1 ? 1 : de;
        }
        function mr(ve) {
          const se = (180 - 360 * ve) * Math.PI / 180;
          return 360 * Math.atan(Math.exp(se)) / Math.PI - 90;
        }
        function ce(ve, se, de, pe) {
          let Oe = pe;
          const Ge = se + (de - se >> 1);
          let rt, gt = de - se;
          const Ye = ve[se], lt = ve[se + 1], pt = ve[de], ct = ve[de + 1];
          for (let We = se + 3; We < de; We += 3) {
            const or = Be(ve[We], ve[We + 1], Ye, lt, pt, ct);
            if (or > Oe) rt = We, Oe = or;
            else if (or === Oe) {
              const Jt = Math.abs(We - Ge);
              Jt < gt && (rt = We, gt = Jt);
            }
          }
          Oe > pe && (rt - se > 3 && ce(ve, se, rt, pe), ve[rt + 2] = Oe, de - rt > 3 && ce(ve, rt, de, pe));
        }
        function Be(ve, se, de, pe, Oe, Ge) {
          let rt = Oe - de, gt = Ge - pe;
          if (rt !== 0 || gt !== 0) {
            const Ye = ((ve - de) * rt + (se - pe) * gt) / (rt * rt + gt * gt);
            Ye > 1 ? (de = Oe, pe = Ge) : Ye > 0 && (de += rt * Ye, pe += gt * Ye);
          }
          return rt = ve - de, gt = se - pe, rt * rt + gt * gt;
        }
        function Ue(ve, se, de, pe) {
          const Oe = { id: ve ?? null, type: se, geometry: de, tags: pe, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
          if (se === "Point" || se === "MultiPoint" || se === "LineString") Xe(Oe, de);
          else if (se === "Polygon") Xe(Oe, de[0]);
          else if (se === "MultiLineString") for (const Ge of de) Xe(Oe, Ge);
          else if (se === "MultiPolygon") for (const Ge of de) Xe(Oe, Ge[0]);
          return Oe;
        }
        function Xe(ve, se) {
          for (let de = 0; de < se.length; de += 3) ve.minX = Math.min(ve.minX, se[de]), ve.minY = Math.min(ve.minY, se[de + 1]), ve.maxX = Math.max(ve.maxX, se[de]), ve.maxY = Math.max(ve.maxY, se[de + 1]);
        }
        function it(ve, se, de, pe) {
          if (!se.geometry) return;
          const Oe = se.geometry.coordinates;
          if (Oe && Oe.length === 0) return;
          const Ge = se.geometry.type, rt = Math.pow(de.tolerance / ((1 << de.maxZoom) * de.extent), 2);
          let gt = [], Ye = se.id;
          if (de.promoteId ? Ye = se.properties[de.promoteId] : de.generateId && (Ye = pe || 0), Ge === "Point") ft(Oe, gt);
          else if (Ge === "MultiPoint") for (const lt of Oe) ft(lt, gt);
          else if (Ge === "LineString") St(Oe, gt, rt, !1);
          else if (Ge === "MultiLineString") {
            if (de.lineMetrics) {
              for (const lt of Oe) gt = [], St(lt, gt, rt, !1), ve.push(Ue(Ye, "LineString", gt, se.properties));
              return;
            }
            wt(Oe, gt, rt, !1);
          } else if (Ge === "Polygon") wt(Oe, gt, rt, !0);
          else {
            if (Ge !== "MultiPolygon") {
              if (Ge === "GeometryCollection") {
                for (const lt of se.geometry.geometries) it(ve, { id: Ye, geometry: lt, properties: se.properties }, de, pe);
                return;
              }
              throw new Error("Input data is not a valid GeoJSON object.");
            }
            for (const lt of Oe) {
              const pt = [];
              wt(lt, pt, rt, !0), gt.push(pt);
            }
          }
          ve.push(Ue(Ye, Ge, gt, se.properties));
        }
        function ft(ve, se) {
          se.push(ar(ve[0]), Yt(ve[1]), 0);
        }
        function St(ve, se, de, pe) {
          let Oe, Ge, rt = 0;
          for (let Ye = 0; Ye < ve.length; Ye++) {
            const lt = ar(ve[Ye][0]), pt = Yt(ve[Ye][1]);
            se.push(lt, pt, 0), Ye > 0 && (rt += pe ? (Oe * pt - lt * Ge) / 2 : Math.sqrt(Math.pow(lt - Oe, 2) + Math.pow(pt - Ge, 2))), Oe = lt, Ge = pt;
          }
          const gt = se.length - 3;
          se[2] = 1, ce(se, 0, gt, de), se[gt + 2] = 1, se.size = Math.abs(rt), se.start = 0, se.end = se.size;
        }
        function wt(ve, se, de, pe) {
          for (let Oe = 0; Oe < ve.length; Oe++) {
            const Ge = [];
            St(ve[Oe], Ge, de, pe), se.push(Ge);
          }
        }
        function ar(ve) {
          return ve / 360 + 0.5;
        }
        function Yt(ve) {
          const se = Math.sin(ve * Math.PI / 180), de = 0.5 - 0.25 * Math.log((1 + se) / (1 - se)) / Math.PI;
          return de < 0 ? 0 : de > 1 ? 1 : de;
        }
        function cr(ve, se, de, pe, Oe, Ge, rt, gt) {
          if (pe /= se, Ge >= (de /= se) && rt < pe) return ve;
          if (rt < de || Ge >= pe) return null;
          const Ye = [];
          for (const lt of ve) {
            const pt = lt.geometry;
            let ct = lt.type;
            const We = Oe === 0 ? lt.minX : lt.minY, or = Oe === 0 ? lt.maxX : lt.maxY;
            if (We >= de && or < pe) {
              Ye.push(lt);
              continue;
            }
            if (or < de || We >= pe) continue;
            let Jt = [];
            if (ct === "Point" || ct === "MultiPoint") _r(pt, Jt, de, pe, Oe);
            else if (ct === "LineString") Cr(pt, Jt, de, pe, Oe, !1, gt.lineMetrics);
            else if (ct === "MultiLineString") Ve(pt, Jt, de, pe, Oe, !1);
            else if (ct === "Polygon") Ve(pt, Jt, de, pe, Oe, !0);
            else if (ct === "MultiPolygon") for (const Kt of pt) {
              const Mr = [];
              Ve(Kt, Mr, de, pe, Oe, !0), Mr.length && Jt.push(Mr);
            }
            if (Jt.length) {
              if (gt.lineMetrics && ct === "LineString") {
                for (const Kt of Jt) Ye.push(Ue(lt.id, ct, Kt, lt.tags));
                continue;
              }
              ct !== "LineString" && ct !== "MultiLineString" || (Jt.length === 1 ? (ct = "LineString", Jt = Jt[0]) : ct = "MultiLineString"), ct !== "Point" && ct !== "MultiPoint" || (ct = Jt.length === 3 ? "Point" : "MultiPoint"), Ye.push(Ue(lt.id, ct, Jt, lt.tags));
            }
          }
          return Ye.length ? Ye : null;
        }
        function _r(ve, se, de, pe, Oe) {
          for (let Ge = 0; Ge < ve.length; Ge += 3) {
            const rt = ve[Ge + Oe];
            rt >= de && rt <= pe && jr(se, ve[Ge], ve[Ge + 1], ve[Ge + 2]);
          }
        }
        function Cr(ve, se, de, pe, Oe, Ge, rt) {
          let gt = Ut(ve);
          const Ye = Oe === 0 ? Ir : rr;
          let lt, pt, ct = ve.start;
          for (let Mr = 0; Mr < ve.length - 3; Mr += 3) {
            const Bt = ve[Mr], Qt = ve[Mr + 1], fr = ve[Mr + 2], Lr = ve[Mr + 3], Hr = ve[Mr + 4], Or = Oe === 0 ? Bt : Qt, gr = Oe === 0 ? Lr : Hr;
            let Sn = !1;
            rt && (lt = Math.sqrt(Math.pow(Bt - Lr, 2) + Math.pow(Qt - Hr, 2))), Or < de ? gr > de && (pt = Ye(gt, Bt, Qt, Lr, Hr, de), rt && (gt.start = ct + lt * pt)) : Or > pe ? gr < pe && (pt = Ye(gt, Bt, Qt, Lr, Hr, pe), rt && (gt.start = ct + lt * pt)) : jr(gt, Bt, Qt, fr), gr < de && Or >= de && (pt = Ye(gt, Bt, Qt, Lr, Hr, de), Sn = !0), gr > pe && Or <= pe && (pt = Ye(gt, Bt, Qt, Lr, Hr, pe), Sn = !0), !Ge && Sn && (rt && (gt.end = ct + lt * pt), se.push(gt), gt = Ut(ve)), rt && (ct += lt);
          }
          let We = ve.length - 3;
          const or = ve[We], Jt = ve[We + 1], Kt = Oe === 0 ? or : Jt;
          Kt >= de && Kt <= pe && jr(gt, or, Jt, ve[We + 2]), We = gt.length - 3, Ge && We >= 3 && (gt[We] !== gt[0] || gt[We + 1] !== gt[1]) && jr(gt, gt[0], gt[1], gt[2]), gt.length && se.push(gt);
        }
        function Ut(ve) {
          const se = [];
          return se.size = ve.size, se.start = ve.start, se.end = ve.end, se;
        }
        function Ve(ve, se, de, pe, Oe, Ge) {
          for (const rt of ve) Cr(rt, se, de, pe, Oe, Ge, !1);
        }
        function jr(ve, se, de, pe) {
          ve.push(se, de, pe);
        }
        function Ir(ve, se, de, pe, Oe, Ge) {
          const rt = (Ge - se) / (pe - se);
          return jr(ve, Ge, de + (Oe - de) * rt, 1), rt;
        }
        function rr(ve, se, de, pe, Oe, Ge) {
          const rt = (Ge - de) / (Oe - de);
          return jr(ve, se + (pe - se) * rt, Ge, 1), rt;
        }
        function hr(ve, se) {
          const de = [];
          for (let pe = 0; pe < ve.length; pe++) {
            const Oe = ve[pe], Ge = Oe.type;
            let rt;
            if (Ge === "Point" || Ge === "MultiPoint" || Ge === "LineString") rt = wr(Oe.geometry, se);
            else if (Ge === "MultiLineString" || Ge === "Polygon") {
              rt = [];
              for (const gt of Oe.geometry) rt.push(wr(gt, se));
            } else if (Ge === "MultiPolygon") {
              rt = [];
              for (const gt of Oe.geometry) {
                const Ye = [];
                for (const lt of gt) Ye.push(wr(lt, se));
                rt.push(Ye);
              }
            }
            de.push(Ue(Oe.id, Ge, rt, Oe.tags));
          }
          return de;
        }
        function wr(ve, se) {
          const de = [];
          de.size = ve.size, ve.start !== void 0 && (de.start = ve.start, de.end = ve.end);
          for (let pe = 0; pe < ve.length; pe += 3) de.push(ve[pe] + se, ve[pe + 1], ve[pe + 2]);
          return de;
        }
        function br(ve, se) {
          if (ve.transformed) return ve;
          const de = 1 << ve.z, pe = ve.x, Oe = ve.y;
          for (const Ge of ve.features) {
            const rt = Ge.geometry, gt = Ge.type;
            if (Ge.geometry = [], gt === 1) for (let Ye = 0; Ye < rt.length; Ye += 2) Ge.geometry.push(Rr(rt[Ye], rt[Ye + 1], se, de, pe, Oe));
            else for (let Ye = 0; Ye < rt.length; Ye++) {
              const lt = [];
              for (let pt = 0; pt < rt[Ye].length; pt += 2) lt.push(Rr(rt[Ye][pt], rt[Ye][pt + 1], se, de, pe, Oe));
              Ge.geometry.push(lt);
            }
          }
          return ve.transformed = !0, ve;
        }
        function Rr(ve, se, de, pe, Oe, Ge) {
          return [Math.round(de * (ve * pe - Oe)), Math.round(de * (se * pe - Ge))];
        }
        function $r(ve, se, de, pe, Oe) {
          const Ge = se === Oe.maxZoom ? 0 : Oe.tolerance / ((1 << se) * Oe.extent), rt = { features: [], numPoints: 0, numSimplified: 0, numFeatures: ve.length, source: null, x: de, y: pe, z: se, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
          for (const gt of ve) Wr(rt, gt, Ge, Oe);
          return rt;
        }
        function Wr(ve, se, de, pe) {
          const Oe = se.geometry, Ge = se.type, rt = [];
          if (ve.minX = Math.min(ve.minX, se.minX), ve.minY = Math.min(ve.minY, se.minY), ve.maxX = Math.max(ve.maxX, se.maxX), ve.maxY = Math.max(ve.maxY, se.maxY), Ge === "Point" || Ge === "MultiPoint") for (let gt = 0; gt < Oe.length; gt += 3) rt.push(Oe[gt], Oe[gt + 1]), ve.numPoints++, ve.numSimplified++;
          else if (Ge === "LineString") Zr(rt, Oe, ve, de, !1, !1);
          else if (Ge === "MultiLineString" || Ge === "Polygon") for (let gt = 0; gt < Oe.length; gt++) Zr(rt, Oe[gt], ve, de, Ge === "Polygon", gt === 0);
          else if (Ge === "MultiPolygon") for (let gt = 0; gt < Oe.length; gt++) {
            const Ye = Oe[gt];
            for (let lt = 0; lt < Ye.length; lt++) Zr(rt, Ye[lt], ve, de, !0, lt === 0);
          }
          if (rt.length) {
            let gt = se.tags || null;
            if (Ge === "LineString" && pe.lineMetrics) {
              gt = {};
              for (const lt in se.tags) gt[lt] = se.tags[lt];
              gt.mapbox_clip_start = Oe.start / Oe.size, gt.mapbox_clip_end = Oe.end / Oe.size;
            }
            const Ye = { geometry: rt, type: Ge === "Polygon" || Ge === "MultiPolygon" ? 3 : Ge === "LineString" || Ge === "MultiLineString" ? 2 : 1, tags: gt };
            se.id !== null && (Ye.id = se.id), ve.features.push(Ye);
          }
        }
        function Zr(ve, se, de, pe, Oe, Ge) {
          const rt = pe * pe;
          if (pe > 0 && se.size < (Oe ? rt : pe)) return void (de.numPoints += se.length / 3);
          const gt = [];
          for (let Ye = 0; Ye < se.length; Ye += 3) (pe === 0 || se[Ye + 2] > rt) && (de.numSimplified++, gt.push(se[Ye], se[Ye + 1])), de.numPoints++;
          Oe && function(Ye, lt) {
            let pt = 0;
            for (let ct = 0, We = Ye.length, or = We - 2; ct < We; or = ct, ct += 2) pt += (Ye[ct] - Ye[or]) * (Ye[ct + 1] + Ye[or + 1]);
            if (pt > 0 === lt) for (let ct = 0, We = Ye.length; ct < We / 2; ct += 2) {
              const or = Ye[ct], Jt = Ye[ct + 1];
              Ye[ct] = Ye[We - 2 - ct], Ye[ct + 1] = Ye[We - 1 - ct], Ye[We - 2 - ct] = or, Ye[We - 1 - ct] = Jt;
            }
          }(gt, Ge), ve.push(gt);
        }
        const hn = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
        class yn {
          constructor(se, de) {
            const pe = (de = this.options = function(Ge, rt) {
              for (const gt in rt) Ge[gt] = rt[gt];
              return Ge;
            }(Object.create(hn), de)).debug;
            if (pe && console.time("preprocess data"), de.maxZoom < 0 || de.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
            if (de.promoteId && de.generateId) throw new Error("promoteId and generateId cannot be used together.");
            let Oe = function(Ge, rt) {
              const gt = [];
              if (Ge.type === "FeatureCollection") for (let Ye = 0; Ye < Ge.features.length; Ye++) it(gt, Ge.features[Ye], rt, Ye);
              else it(gt, Ge.type === "Feature" ? Ge : { geometry: Ge }, rt);
              return gt;
            }(se, de);
            this.tiles = {}, this.tileCoords = [], pe && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", de.indexMaxZoom, de.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), Oe = function(Ge, rt) {
              const gt = rt.buffer / rt.extent;
              let Ye = Ge;
              const lt = cr(Ge, 1, -1 - gt, gt, 0, -1, 2, rt), pt = cr(Ge, 1, 1 - gt, 2 + gt, 0, -1, 2, rt);
              return (lt || pt) && (Ye = cr(Ge, 1, -gt, 1 + gt, 0, -1, 2, rt) || [], lt && (Ye = hr(lt, 1).concat(Ye)), pt && (Ye = Ye.concat(hr(pt, -1)))), Ye;
            }(Oe, de), Oe.length && this.splitTile(Oe, 0, 0, 0), pe && (Oe.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          splitTile(se, de, pe, Oe, Ge, rt, gt) {
            const Ye = [se, de, pe, Oe], lt = this.options, pt = lt.debug;
            for (; Ye.length; ) {
              Oe = Ye.pop(), pe = Ye.pop(), de = Ye.pop(), se = Ye.pop();
              const ct = 1 << de, We = Vr(de, pe, Oe);
              let or = this.tiles[We];
              if (!or && (pt > 1 && console.time("creation"), or = this.tiles[We] = $r(se, de, pe, Oe, lt), this.tileCoords.push({ z: de, x: pe, y: Oe }), pt)) {
                pt > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", de, pe, Oe, or.numFeatures, or.numPoints, or.numSimplified), console.timeEnd("creation"));
                const Sn = `z${de}`;
                this.stats[Sn] = (this.stats[Sn] || 0) + 1, this.total++;
              }
              if (or.source = se, Ge == null) {
                if (de === lt.indexMaxZoom || or.numPoints <= lt.indexMaxPoints) continue;
              } else {
                if (de === lt.maxZoom || de === Ge) continue;
                if (Ge != null) {
                  const Sn = Ge - de;
                  if (pe !== rt >> Sn || Oe !== gt >> Sn) continue;
                }
              }
              if (or.source = null, se.length === 0) continue;
              pt > 1 && console.time("clipping");
              const Jt = 0.5 * lt.buffer / lt.extent, Kt = 0.5 - Jt, Mr = 0.5 + Jt, Bt = 1 + Jt;
              let Qt = null, fr = null, Lr = null, Hr = null, Or = cr(se, ct, pe - Jt, pe + Mr, 0, or.minX, or.maxX, lt), gr = cr(se, ct, pe + Kt, pe + Bt, 0, or.minX, or.maxX, lt);
              se = null, Or && (Qt = cr(Or, ct, Oe - Jt, Oe + Mr, 1, or.minY, or.maxY, lt), fr = cr(Or, ct, Oe + Kt, Oe + Bt, 1, or.minY, or.maxY, lt), Or = null), gr && (Lr = cr(gr, ct, Oe - Jt, Oe + Mr, 1, or.minY, or.maxY, lt), Hr = cr(gr, ct, Oe + Kt, Oe + Bt, 1, or.minY, or.maxY, lt), gr = null), pt > 1 && console.timeEnd("clipping"), Ye.push(Qt || [], de + 1, 2 * pe, 2 * Oe), Ye.push(fr || [], de + 1, 2 * pe, 2 * Oe + 1), Ye.push(Lr || [], de + 1, 2 * pe + 1, 2 * Oe), Ye.push(Hr || [], de + 1, 2 * pe + 1, 2 * Oe + 1);
            }
          }
          getTile(se, de, pe) {
            se = +se, de = +de, pe = +pe;
            const Oe = this.options, { extent: Ge, debug: rt } = Oe;
            if (se < 0 || se > 24) return null;
            const gt = 1 << se, Ye = Vr(se, de = de + gt & gt - 1, pe);
            if (this.tiles[Ye]) return br(this.tiles[Ye], Ge);
            rt > 1 && console.log("drilling down to z%d-%d-%d", se, de, pe);
            let lt, pt = se, ct = de, We = pe;
            for (; !lt && pt > 0; ) pt--, ct >>= 1, We >>= 1, lt = this.tiles[Vr(pt, ct, We)];
            return lt && lt.source ? (rt > 1 && (console.log("found parent tile z%d-%d-%d", pt, ct, We), console.time("drilling down")), this.splitTile(lt.source, pt, ct, We, se, de, pe), rt > 1 && console.timeEnd("drilling down"), this.tiles[Ye] ? br(this.tiles[Ye], Ge) : null) : null;
          }
        }
        function Vr(ve, se, de) {
          return 32 * ((1 << ve) * de + se) + ve;
        }
        function en(ve, se) {
          return se ? ve.properties[se] : ve.id;
        }
        function Ar(ve, se) {
          if (ve == null) return !0;
          if (ve.type === "Feature") return en(ve, se) != null;
          if (ve.type === "FeatureCollection") {
            const de = /* @__PURE__ */ new Set();
            for (const pe of ve.features) {
              const Oe = en(pe, se);
              if (Oe == null || de.has(Oe)) return !1;
              de.add(Oe);
            }
            return !0;
          }
          return !1;
        }
        function Ii(ve, se) {
          const de = /* @__PURE__ */ new Map();
          if (ve != null) if (ve.type === "Feature") de.set(en(ve, se), ve);
          else for (const pe of ve.features) de.set(en(pe, se), pe);
          return de;
        }
        class bn extends T {
          constructor() {
            super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
          }
          loadVectorTile(se, de) {
            return l._(this, void 0, void 0, function* () {
              const pe = se.tileID.canonical;
              if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
              const Oe = this._geoJSONIndex.getTile(pe.z, pe.x, pe.y);
              if (!Oe) return null;
              const Ge = new he(Oe.features);
              let rt = Re(Ge);
              return rt.byteOffset === 0 && rt.byteLength === rt.buffer.byteLength || (rt = new Uint8Array(rt)), { vectorTile: Ge, rawData: rt.buffer };
            });
          }
          loadData(se) {
            return l._(this, void 0, void 0, function* () {
              var de;
              (de = this._pendingRequest) === null || de === void 0 || de.abort();
              const pe = !!(se && se.request && se.request.collectResourceTiming) && new l.cv(se.request);
              this._pendingRequest = new AbortController();
              try {
                this._pendingData = this.loadAndProcessGeoJSON(se, this._pendingRequest), this._geoJSONIndex = se.cluster ? new ht(function(rt) {
                  let { superclusterOptions: gt, clusterProperties: Ye } = rt;
                  if (!Ye || !gt) return gt;
                  const lt = {}, pt = {}, ct = { accumulated: null, zoom: 0 }, We = { properties: null }, or = Object.keys(Ye);
                  for (const Jt of or) {
                    const [Kt, Mr] = Ye[Jt], Bt = l.cC(Mr), Qt = l.cC(typeof Kt == "string" ? [Kt, ["accumulated"], ["get", Jt]] : Kt);
                    lt[Jt] = Bt.value, pt[Jt] = Qt.value;
                  }
                  return gt.map = (Jt) => {
                    We.properties = Jt;
                    const Kt = {};
                    for (const Mr of or) Kt[Mr] = lt[Mr].evaluate(ct, We);
                    return Kt;
                  }, gt.reduce = (Jt, Kt) => {
                    We.properties = Kt;
                    for (const Mr of or) ct.accumulated = Jt[Mr], Jt[Mr] = pt[Mr].evaluate(ct, We);
                  }, gt;
                }(se)).load((yield this._pendingData).features) : (Oe = yield this._pendingData, new yn(Oe, se.geojsonVtOptions)), this.loaded = {};
                const Ge = {};
                if (pe) {
                  const rt = pe.finish();
                  rt && (Ge.resourceTiming = {}, Ge.resourceTiming[se.source] = JSON.parse(JSON.stringify(rt)));
                }
                return Ge;
              } catch (Ge) {
                if (delete this._pendingRequest, l.cg(Ge)) return { abandoned: !0 };
                throw Ge;
              }
              var Oe;
            });
          }
          getData() {
            return l._(this, void 0, void 0, function* () {
              return this._pendingData;
            });
          }
          reloadTile(se) {
            const de = this.loaded;
            return de && de[se.uid] ? super.reloadTile(se) : this.loadTile(se);
          }
          loadAndProcessGeoJSON(se, de) {
            return l._(this, void 0, void 0, function* () {
              let pe = yield this.loadGeoJSON(se, de);
              if (delete this._pendingRequest, typeof pe != "object") throw new Error(`Input data given to '${se.source}' is not a valid GeoJSON object.`);
              if (q(pe, !0), se.filter) {
                const Oe = l.cC(se.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
                if (Oe.result === "error") throw new Error(Oe.value.map((rt) => `${rt.key}: ${rt.message}`).join(", "));
                pe = { type: "FeatureCollection", features: pe.features.filter((rt) => Oe.value.evaluate({ zoom: 0 }, rt)) };
              }
              return pe;
            });
          }
          loadGeoJSON(se, de) {
            return l._(this, void 0, void 0, function* () {
              const { promoteId: pe } = se;
              if (se.request) {
                const Oe = yield l.h(se.request, de);
                return this._dataUpdateable = Ar(Oe.data, pe) ? Ii(Oe.data, pe) : void 0, Oe.data;
              }
              if (typeof se.data == "string") try {
                const Oe = JSON.parse(se.data);
                return this._dataUpdateable = Ar(Oe, pe) ? Ii(Oe, pe) : void 0, Oe;
              } catch {
                throw new Error(`Input data given to '${se.source}' is not a valid GeoJSON object.`);
              }
              if (!se.dataDiff) throw new Error(`Input data given to '${se.source}' is not a valid GeoJSON object.`);
              if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${se.source}`);
              return function(Oe, Ge, rt) {
                var gt, Ye, lt, pt;
                if (Ge.removeAll && Oe.clear(), Ge.remove) for (const ct of Ge.remove) Oe.delete(ct);
                if (Ge.add) for (const ct of Ge.add) {
                  const We = en(ct, rt);
                  We != null && Oe.set(We, ct);
                }
                if (Ge.update) for (const ct of Ge.update) {
                  let We = Oe.get(ct.id);
                  if (We == null) continue;
                  const or = !ct.removeAllProperties && (((gt = ct.removeProperties) === null || gt === void 0 ? void 0 : gt.length) > 0 || ((Ye = ct.addOrUpdateProperties) === null || Ye === void 0 ? void 0 : Ye.length) > 0);
                  if ((ct.newGeometry || ct.removeAllProperties || or) && (We = Object.assign({}, We), Oe.set(ct.id, We), or && (We.properties = Object.assign({}, We.properties))), ct.newGeometry && (We.geometry = ct.newGeometry), ct.removeAllProperties) We.properties = {};
                  else if (((lt = ct.removeProperties) === null || lt === void 0 ? void 0 : lt.length) > 0) for (const Jt of ct.removeProperties) Object.prototype.hasOwnProperty.call(We.properties, Jt) && delete We.properties[Jt];
                  if (((pt = ct.addOrUpdateProperties) === null || pt === void 0 ? void 0 : pt.length) > 0) for (const { key: Jt, value: Kt } of ct.addOrUpdateProperties) We.properties[Jt] = Kt;
                }
              }(this._dataUpdateable, se.dataDiff, pe), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
            });
          }
          removeSource(se) {
            return l._(this, void 0, void 0, function* () {
              this._pendingRequest && this._pendingRequest.abort();
            });
          }
          getClusterExpansionZoom(se) {
            return this._geoJSONIndex.getClusterExpansionZoom(se.clusterId);
          }
          getClusterChildren(se) {
            return this._geoJSONIndex.getChildren(se.clusterId);
          }
          getClusterLeaves(se) {
            return this._geoJSONIndex.getLeaves(se.clusterId, se.limit, se.offset);
          }
        }
        class Xi {
          constructor(se) {
            this.self = se, this.actor = new l.G(se), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (de, pe) => {
              if (this.externalWorkerSourceTypes[de]) throw new Error(`Worker source with name "${de}" already registered.`);
              this.externalWorkerSourceTypes[de] = pe;
            }, this.self.addProtocol = l.ci, this.self.removeProtocol = l.cj, this.self.registerRTLTextPlugin = (de) => {
              l.cD.setMethods(de);
            }, this.actor.registerMessageHandler("LDT", (de, pe) => this._getDEMWorkerSource(de, pe.source).loadTile(pe)), this.actor.registerMessageHandler("RDT", (de, pe) => l._(this, void 0, void 0, function* () {
              this._getDEMWorkerSource(de, pe.source).removeTile(pe);
            })), this.actor.registerMessageHandler("GCEZ", (de, pe) => l._(this, void 0, void 0, function* () {
              return this._getWorkerSource(de, pe.type, pe.source).getClusterExpansionZoom(pe);
            })), this.actor.registerMessageHandler("GCC", (de, pe) => l._(this, void 0, void 0, function* () {
              return this._getWorkerSource(de, pe.type, pe.source).getClusterChildren(pe);
            })), this.actor.registerMessageHandler("GCL", (de, pe) => l._(this, void 0, void 0, function* () {
              return this._getWorkerSource(de, pe.type, pe.source).getClusterLeaves(pe);
            })), this.actor.registerMessageHandler("LD", (de, pe) => this._getWorkerSource(de, pe.type, pe.source).loadData(pe)), this.actor.registerMessageHandler("GD", (de, pe) => this._getWorkerSource(de, pe.type, pe.source).getData()), this.actor.registerMessageHandler("LT", (de, pe) => this._getWorkerSource(de, pe.type, pe.source).loadTile(pe)), this.actor.registerMessageHandler("RT", (de, pe) => this._getWorkerSource(de, pe.type, pe.source).reloadTile(pe)), this.actor.registerMessageHandler("AT", (de, pe) => this._getWorkerSource(de, pe.type, pe.source).abortTile(pe)), this.actor.registerMessageHandler("RMT", (de, pe) => this._getWorkerSource(de, pe.type, pe.source).removeTile(pe)), this.actor.registerMessageHandler("RS", (de, pe) => l._(this, void 0, void 0, function* () {
              if (!this.workerSources[de] || !this.workerSources[de][pe.type] || !this.workerSources[de][pe.type][pe.source]) return;
              const Oe = this.workerSources[de][pe.type][pe.source];
              delete this.workerSources[de][pe.type][pe.source], Oe.removeSource !== void 0 && Oe.removeSource(pe);
            })), this.actor.registerMessageHandler("RM", (de) => l._(this, void 0, void 0, function* () {
              delete this.layerIndexes[de], delete this.availableImages[de], delete this.workerSources[de], delete this.demWorkerSources[de];
            })), this.actor.registerMessageHandler("SR", (de, pe) => l._(this, void 0, void 0, function* () {
              this.referrer = pe;
            })), this.actor.registerMessageHandler("SRPS", (de, pe) => this._syncRTLPluginState(de, pe)), this.actor.registerMessageHandler("IS", (de, pe) => l._(this, void 0, void 0, function* () {
              this.self.importScripts(pe);
            })), this.actor.registerMessageHandler("SI", (de, pe) => this._setImages(de, pe)), this.actor.registerMessageHandler("UL", (de, pe) => l._(this, void 0, void 0, function* () {
              this._getLayerIndex(de).update(pe.layers, pe.removedIds);
            })), this.actor.registerMessageHandler("SL", (de, pe) => l._(this, void 0, void 0, function* () {
              this._getLayerIndex(de).replace(pe);
            }));
          }
          _setImages(se, de) {
            return l._(this, void 0, void 0, function* () {
              this.availableImages[se] = de;
              for (const pe in this.workerSources[se]) {
                const Oe = this.workerSources[se][pe];
                for (const Ge in Oe) Oe[Ge].availableImages = de;
              }
            });
          }
          _syncRTLPluginState(se, de) {
            return l._(this, void 0, void 0, function* () {
              return yield l.cD.syncState(de, this.self.importScripts);
            });
          }
          _getAvailableImages(se) {
            let de = this.availableImages[se];
            return de || (de = []), de;
          }
          _getLayerIndex(se) {
            let de = this.layerIndexes[se];
            return de || (de = this.layerIndexes[se] = new o()), de;
          }
          _getWorkerSource(se, de, pe) {
            if (this.workerSources[se] || (this.workerSources[se] = {}), this.workerSources[se][de] || (this.workerSources[se][de] = {}), !this.workerSources[se][de][pe]) {
              const Oe = { sendAsync: (Ge, rt) => (Ge.targetMapId = se, this.actor.sendAsync(Ge, rt)) };
              switch (de) {
                case "vector":
                  this.workerSources[se][de][pe] = new T(Oe, this._getLayerIndex(se), this._getAvailableImages(se));
                  break;
                case "geojson":
                  this.workerSources[se][de][pe] = new bn(Oe, this._getLayerIndex(se), this._getAvailableImages(se));
                  break;
                default:
                  this.workerSources[se][de][pe] = new this.externalWorkerSourceTypes[de](Oe, this._getLayerIndex(se), this._getAvailableImages(se));
              }
            }
            return this.workerSources[se][de][pe];
          }
          _getDEMWorkerSource(se, de) {
            return this.demWorkerSources[se] || (this.demWorkerSources[se] = {}), this.demWorkerSources[se][de] || (this.demWorkerSources[se][de] = new M()), this.demWorkerSources[se][de];
          }
        }
        return l.i(self) && (self.worker = new Xi(self)), Xi;
      }), i("index", ["exports", "./shared"], function(l, o) {
        var d = "5.1.1";
        function m() {
          var v = new o.A(4);
          return o.A != Float32Array && (v[1] = 0, v[2] = 0), v[0] = 1, v[3] = 1, v;
        }
        let b, T;
        const M = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(v, a, u) {
          const g = requestAnimationFrame(a);
          v.signal.addEventListener("abort", () => {
            cancelAnimationFrame(g), u(o.c());
          });
        }, frameAsync(v) {
          return new Promise((a, u) => {
            this.frame(v, a, u);
          });
        }, getImageData(v) {
          let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          return this.getImageCanvasContext(v).getImageData(-a, -a, v.width + 2 * a, v.height + 2 * a);
        }, getImageCanvasContext(v) {
          const a = window.document.createElement("canvas"), u = a.getContext("2d", { willReadFrequently: !0 });
          if (!u) throw new Error("failed to create canvas 2d context");
          return a.width = v.width, a.height = v.height, u.drawImage(v, 0, 0, v.width, v.height), u;
        }, resolveURL: (v) => (b || (b = document.createElement("a")), b.href = v, b.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
          return !!matchMedia && (T == null && (T = matchMedia("(prefers-reduced-motion: reduce)")), T.matches);
        } };
        class E {
          static testProp(a) {
            if (!E.docStyle) return a[0];
            for (let u = 0; u < a.length; u++) if (a[u] in E.docStyle) return a[u];
            return a[0];
          }
          static create(a, u, g) {
            const _ = window.document.createElement(a);
            return u !== void 0 && (_.className = u), g && g.appendChild(_), _;
          }
          static createNS(a, u) {
            return window.document.createElementNS(a, u);
          }
          static disableDrag() {
            E.docStyle && E.selectProp && (E.userSelect = E.docStyle[E.selectProp], E.docStyle[E.selectProp] = "none");
          }
          static enableDrag() {
            E.docStyle && E.selectProp && (E.docStyle[E.selectProp] = E.userSelect);
          }
          static setTransform(a, u) {
            a.style[E.transformProp] = u;
          }
          static addEventListener(a, u, g) {
            let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            a.addEventListener(u, g, "passive" in _ ? _ : _.capture);
          }
          static removeEventListener(a, u, g) {
            let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            a.removeEventListener(u, g, "passive" in _ ? _ : _.capture);
          }
          static suppressClickInternal(a) {
            a.preventDefault(), a.stopPropagation(), window.removeEventListener("click", E.suppressClickInternal, !0);
          }
          static suppressClick() {
            window.addEventListener("click", E.suppressClickInternal, !0), window.setTimeout(() => {
              window.removeEventListener("click", E.suppressClickInternal, !0);
            }, 0);
          }
          static getScale(a) {
            const u = a.getBoundingClientRect();
            return { x: u.width / a.offsetWidth || 1, y: u.height / a.offsetHeight || 1, boundingClientRect: u };
          }
          static getPoint(a, u, g) {
            const _ = u.boundingClientRect;
            return new o.P((g.clientX - _.left) / u.x - a.clientLeft, (g.clientY - _.top) / u.y - a.clientTop);
          }
          static mousePos(a, u) {
            const g = E.getScale(a);
            return E.getPoint(a, g, u);
          }
          static touchPos(a, u) {
            const g = [], _ = E.getScale(a);
            for (let w = 0; w < u.length; w++) g.push(E.getPoint(a, _, u[w]));
            return g;
          }
          static mouseButton(a) {
            return a.button;
          }
          static remove(a) {
            a.parentNode && a.parentNode.removeChild(a);
          }
          static sanitize(a) {
            const u = new DOMParser().parseFromString(a, "text/html").body || document.createElement("body"), g = u.querySelectorAll("script");
            for (const _ of g) _.remove();
            return E.clean(u), u.innerHTML;
          }
          static isPossiblyDangerous(a, u) {
            const g = u.replace(/\s+/g, "").toLowerCase();
            return !(!["src", "href", "xlink:href"].includes(a) || !g.includes("javascript:") && !g.includes("data:")) || !!a.startsWith("on") || void 0;
          }
          static clean(a) {
            const u = a.children;
            for (const g of u) E.removeAttributes(g), E.clean(g);
          }
          static removeAttributes(a) {
            for (const { name: u, value: g } of a.attributes) E.isPossiblyDangerous(u, g) && a.removeAttribute(u);
          }
        }
        E.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, E.selectProp = E.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), E.transformProp = E.testProp(["transform", "WebkitTransform"]);
        const D = { supported: !1, testSupport: function(v) {
          !G && q && (Y ? he(v) : U = v);
        } };
        let U, q, G = !1, Y = !1;
        function he(v) {
          const a = v.createTexture();
          v.bindTexture(v.TEXTURE_2D, a);
          try {
            if (v.texImage2D(v.TEXTURE_2D, 0, v.RGBA, v.RGBA, v.UNSIGNED_BYTE, q), v.isContextLost()) return;
            D.supported = !0;
          } catch {
          }
          v.deleteTexture(a), G = !0;
        }
        var X;
        typeof document < "u" && (q = document.createElement("img"), q.onload = () => {
          U && he(U), U = null, Y = !0;
        }, q.onerror = () => {
          G = !0, U = null;
        }, q.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(v) {
          let a, u, g, _;
          v.resetRequestQueue = () => {
            a = [], u = 0, g = 0, _ = {};
          }, v.addThrottleControl = (L) => {
            const k = g++;
            return _[k] = L, k;
          }, v.removeThrottleControl = (L) => {
            delete _[L], C();
          }, v.getImage = function(L, k) {
            let V = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            return new Promise((W, Z) => {
              D.supported && (L.headers || (L.headers = {}), L.headers.accept = "image/webp,*/*"), o.e(L, { type: "image" }), a.push({ abortController: k, requestParameters: L, supportImageRefresh: V, state: "queued", onError: (ae) => {
                Z(ae);
              }, onSuccess: (ae) => {
                W(ae);
              } }), C();
            });
          };
          const w = (L) => o._(this, void 0, void 0, function* () {
            L.state = "running";
            const { requestParameters: k, supportImageRefresh: V, onError: W, onSuccess: Z, abortController: ae } = L, ue = V === !1 && !o.i(self) && !o.g(k.url) && (!k.headers || Object.keys(k.headers).reduce((Ie, Le) => Ie && Le === "accept", !0));
            u++;
            const Ce = ue ? R(k, ae) : o.m(k, ae);
            try {
              const Ie = yield Ce;
              delete L.abortController, L.state = "completed", Ie.data instanceof HTMLImageElement || o.b(Ie.data) ? Z(Ie) : Ie.data && Z({ data: yield (Se = Ie.data, typeof createImageBitmap == "function" ? o.d(Se) : o.f(Se)), cacheControl: Ie.cacheControl, expires: Ie.expires });
            } catch (Ie) {
              delete L.abortController, W(Ie);
            } finally {
              u--, C();
            }
            var Se;
          }), C = () => {
            const L = (() => {
              for (const k of Object.keys(_)) if (_[k]()) return !0;
              return !1;
            })() ? o.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : o.a.MAX_PARALLEL_IMAGE_REQUESTS;
            for (let k = u; k < L && a.length > 0; k++) {
              const V = a.shift();
              V.abortController.signal.aborted ? k-- : w(V);
            }
          }, R = (L, k) => new Promise((V, W) => {
            const Z = new Image(), ae = L.url, ue = L.credentials;
            ue && ue === "include" ? Z.crossOrigin = "use-credentials" : (ue && ue === "same-origin" || !o.s(ae)) && (Z.crossOrigin = "anonymous"), k.signal.addEventListener("abort", () => {
              Z.src = "", W(o.c());
            }), Z.fetchPriority = "high", Z.onload = () => {
              Z.onerror = Z.onload = null, V({ data: Z });
            }, Z.onerror = () => {
              Z.onerror = Z.onload = null, k.signal.aborted || W(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            }, Z.src = ae;
          });
        }(X || (X = {})), X.resetRequestQueue();
        class J {
          constructor(a) {
            this._transformRequestFn = a;
          }
          transformRequest(a, u) {
            return this._transformRequestFn && this._transformRequestFn(a, u) || { url: a };
          }
          setTransformRequest(a) {
            this._transformRequestFn = a;
          }
        }
        function ie(v) {
          const a = [];
          if (typeof v == "string") a.push({ id: "default", url: v });
          else if (v && v.length > 0) {
            const u = [];
            for (const { id: g, url: _ } of v) {
              const w = `${g}${_}`;
              u.indexOf(w) === -1 && (u.push(w), a.push({ id: g, url: _ }));
            }
          }
          return a;
        }
        function ye(v, a, u) {
          try {
            const g = new URL(v);
            return g.pathname += `${a}${u}`, g.toString();
          } catch {
            throw new Error(`Invalid sprite URL "${v}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
          }
        }
        class oe {
          constructor(a, u, g, _) {
            this.context = a, this.format = g, this.texture = a.gl.createTexture(), this.update(u, _);
          }
          update(a, u, g) {
            const { width: _, height: w } = a, C = !(this.size && this.size[0] === _ && this.size[1] === w || g), { context: R } = this, { gl: L } = R;
            if (this.useMipmap = !!(u && u.useMipmap), L.bindTexture(L.TEXTURE_2D, this.texture), R.pixelStoreUnpackFlipY.set(!1), R.pixelStoreUnpack.set(1), R.pixelStoreUnpackPremultiplyAlpha.set(this.format === L.RGBA && (!u || u.premultiply !== !1)), C) this.size = [_, w], a instanceof HTMLImageElement || a instanceof HTMLCanvasElement || a instanceof HTMLVideoElement || a instanceof ImageData || o.b(a) ? L.texImage2D(L.TEXTURE_2D, 0, this.format, this.format, L.UNSIGNED_BYTE, a) : L.texImage2D(L.TEXTURE_2D, 0, this.format, _, w, 0, this.format, L.UNSIGNED_BYTE, a.data);
            else {
              const { x: k, y: V } = g || { x: 0, y: 0 };
              a instanceof HTMLImageElement || a instanceof HTMLCanvasElement || a instanceof HTMLVideoElement || a instanceof ImageData || o.b(a) ? L.texSubImage2D(L.TEXTURE_2D, 0, k, V, L.RGBA, L.UNSIGNED_BYTE, a) : L.texSubImage2D(L.TEXTURE_2D, 0, k, V, _, w, L.RGBA, L.UNSIGNED_BYTE, a.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && L.generateMipmap(L.TEXTURE_2D);
          }
          bind(a, u, g) {
            const { context: _ } = this, { gl: w } = _;
            w.bindTexture(w.TEXTURE_2D, this.texture), g !== w.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (g = w.LINEAR), a !== this.filter && (w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MAG_FILTER, a), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MIN_FILTER, g || a), this.filter = a), u !== this.wrap && (w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_S, u), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_T, u), this.wrap = u);
          }
          isSizePowerOfTwo() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }
          destroy() {
            const { gl: a } = this.context;
            a.deleteTexture(this.texture), this.texture = null;
          }
        }
        function Re(v) {
          const { userImage: a } = v;
          return !!(a && a.render && a.render()) && (v.data.replace(new Uint8Array(a.data.buffer)), !0);
        }
        class Ne extends o.E {
          constructor() {
            super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new o.R({ width: 1, height: 1 }), this.dirty = !0;
          }
          isLoaded() {
            return this.loaded;
          }
          setLoaded(a) {
            if (this.loaded !== a && (this.loaded = a, a)) {
              for (const { ids: u, promiseResolve: g } of this.requestors) g(this._getImagesForIds(u));
              this.requestors = [];
            }
          }
          getImage(a) {
            const u = this.images[a];
            if (u && !u.data && u.spriteData) {
              const g = u.spriteData;
              u.data = new o.R({ width: g.width, height: g.height }, g.context.getImageData(g.x, g.y, g.width, g.height).data), u.spriteData = null;
            }
            return u;
          }
          addImage(a, u) {
            if (this.images[a]) throw new Error(`Image id ${a} already exist, use updateImage instead`);
            this._validate(a, u) && (this.images[a] = u);
          }
          _validate(a, u) {
            let g = !0;
            const _ = u.data || u.spriteData;
            return this._validateStretch(u.stretchX, _ && _.width) || (this.fire(new o.j(new Error(`Image "${a}" has invalid "stretchX" value`))), g = !1), this._validateStretch(u.stretchY, _ && _.height) || (this.fire(new o.j(new Error(`Image "${a}" has invalid "stretchY" value`))), g = !1), this._validateContent(u.content, u) || (this.fire(new o.j(new Error(`Image "${a}" has invalid "content" value`))), g = !1), g;
          }
          _validateStretch(a, u) {
            if (!a) return !0;
            let g = 0;
            for (const _ of a) {
              if (_[0] < g || _[1] < _[0] || u < _[1]) return !1;
              g = _[1];
            }
            return !0;
          }
          _validateContent(a, u) {
            if (!a) return !0;
            if (a.length !== 4) return !1;
            const g = u.spriteData, _ = g && g.width || u.data.width, w = g && g.height || u.data.height;
            return !(a[0] < 0 || _ < a[0] || a[1] < 0 || w < a[1] || a[2] < 0 || _ < a[2] || a[3] < 0 || w < a[3] || a[2] < a[0] || a[3] < a[1]);
          }
          updateImage(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            const _ = this.getImage(a);
            if (g && (_.data.width !== u.data.width || _.data.height !== u.data.height)) throw new Error(`size mismatch between old image (${_.data.width}x${_.data.height}) and new image (${u.data.width}x${u.data.height}).`);
            u.version = _.version + 1, this.images[a] = u, this.updatedImages[a] = !0;
          }
          removeImage(a) {
            const u = this.images[a];
            delete this.images[a], delete this.patterns[a], u.userImage && u.userImage.onRemove && u.userImage.onRemove();
          }
          listImages() {
            return Object.keys(this.images);
          }
          getImages(a) {
            return new Promise((u, g) => {
              let _ = !0;
              if (!this.isLoaded()) for (const w of a) this.images[w] || (_ = !1);
              this.isLoaded() || _ ? u(this._getImagesForIds(a)) : this.requestors.push({ ids: a, promiseResolve: u });
            });
          }
          _getImagesForIds(a) {
            const u = {};
            for (const g of a) {
              let _ = this.getImage(g);
              _ || (this.fire(new o.k("styleimagemissing", { id: g })), _ = this.getImage(g)), _ ? u[g] = { data: _.data.clone(), pixelRatio: _.pixelRatio, sdf: _.sdf, version: _.version, stretchX: _.stretchX, stretchY: _.stretchY, content: _.content, textFitWidth: _.textFitWidth, textFitHeight: _.textFitHeight, hasRenderCallback: !!(_.userImage && _.userImage.render) } : o.w(`Image "${g}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
            }
            return u;
          }
          getPixelSize() {
            const { width: a, height: u } = this.atlasImage;
            return { width: a, height: u };
          }
          getPattern(a) {
            const u = this.patterns[a], g = this.getImage(a);
            if (!g) return null;
            if (u && u.position.version === g.version) return u.position;
            if (u) u.position.version = g.version;
            else {
              const _ = { w: g.data.width + 2, h: g.data.height + 2, x: 0, y: 0 }, w = new o.I(_, g);
              this.patterns[a] = { bin: _, position: w };
            }
            return this._updatePatternAtlas(), this.patterns[a].position;
          }
          bind(a) {
            const u = a.gl;
            this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new oe(a, this.atlasImage, u.RGBA), this.atlasTexture.bind(u.LINEAR, u.CLAMP_TO_EDGE);
          }
          _updatePatternAtlas() {
            const a = [];
            for (const w in this.patterns) a.push(this.patterns[w].bin);
            const { w: u, h: g } = o.p(a), _ = this.atlasImage;
            _.resize({ width: u || 1, height: g || 1 });
            for (const w in this.patterns) {
              const { bin: C } = this.patterns[w], R = C.x + 1, L = C.y + 1, k = this.getImage(w).data, V = k.width, W = k.height;
              o.R.copy(k, _, { x: 0, y: 0 }, { x: R, y: L }, { width: V, height: W }), o.R.copy(k, _, { x: 0, y: W - 1 }, { x: R, y: L - 1 }, { width: V, height: 1 }), o.R.copy(k, _, { x: 0, y: 0 }, { x: R, y: L + W }, { width: V, height: 1 }), o.R.copy(k, _, { x: V - 1, y: 0 }, { x: R - 1, y: L }, { width: 1, height: W }), o.R.copy(k, _, { x: 0, y: 0 }, { x: R + V, y: L }, { width: 1, height: W });
            }
            this.dirty = !0;
          }
          beginFrame() {
            this.callbackDispatchedThisFrame = {};
          }
          dispatchRenderCallbacks(a) {
            for (const u of a) {
              if (this.callbackDispatchedThisFrame[u]) continue;
              this.callbackDispatchedThisFrame[u] = !0;
              const g = this.getImage(u);
              g || o.w(`Image with ID: "${u}" was not found`), Re(g) && this.updateImage(u, g);
            }
          }
        }
        const me = 1e20;
        function _e(v, a, u, g, _, w, C, R, L) {
          for (let k = a; k < a + g; k++) Fe(v, u * w + k, w, _, C, R, L);
          for (let k = u; k < u + _; k++) Fe(v, k * w + a, 1, g, C, R, L);
        }
        function Fe(v, a, u, g, _, w, C) {
          w[0] = 0, C[0] = -1e20, C[1] = me, _[0] = v[a];
          for (let R = 1, L = 0, k = 0; R < g; R++) {
            _[R] = v[a + R * u];
            const V = R * R;
            do {
              const W = w[L];
              k = (_[R] - _[W] + V - W * W) / (R - W) / 2;
            } while (k <= C[L] && --L > -1);
            L++, w[L] = R, C[L] = k, C[L + 1] = me;
          }
          for (let R = 0, L = 0; R < g; R++) {
            for (; C[L + 1] < R; ) L++;
            const k = w[L], V = R - k;
            v[a + R * u] = _[k] + V * V;
          }
        }
        class Me {
          constructor(a, u) {
            this.requestManager = a, this.localIdeographFontFamily = u, this.entries = {};
          }
          setURL(a) {
            this.url = a;
          }
          getGlyphs(a) {
            return o._(this, void 0, void 0, function* () {
              const u = [];
              for (const w in a) for (const C of a[w]) u.push(this._getAndCacheGlyphsPromise(w, C));
              const g = yield Promise.all(u), _ = {};
              for (const { stack: w, id: C, glyph: R } of g) _[w] || (_[w] = {}), _[w][C] = R && { id: R.id, bitmap: R.bitmap.clone(), metrics: R.metrics };
              return _;
            });
          }
          _getAndCacheGlyphsPromise(a, u) {
            return o._(this, void 0, void 0, function* () {
              let g = this.entries[a];
              g || (g = this.entries[a] = { glyphs: {}, requests: {}, ranges: {} });
              let _ = g.glyphs[u];
              if (_ !== void 0) return { stack: a, id: u, glyph: _ };
              if (_ = this._tinySDF(g, a, u), _) return g.glyphs[u] = _, { stack: a, id: u, glyph: _ };
              const w = Math.floor(u / 256);
              if (256 * w > 65535) throw new Error("glyphs > 65535 not supported");
              if (g.ranges[w]) return { stack: a, id: u, glyph: _ };
              if (!this.url) throw new Error("glyphsUrl is not set");
              if (!g.requests[w]) {
                const R = Me.loadGlyphRange(a, w, this.url, this.requestManager);
                g.requests[w] = R;
              }
              const C = yield g.requests[w];
              for (const R in C) this._doesCharSupportLocalGlyph(+R) || (g.glyphs[+R] = C[+R]);
              return g.ranges[w] = !0, { stack: a, id: u, glyph: C[u] || null };
            });
          }
          _doesCharSupportLocalGlyph(a) {
            return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(a)) || o.u["CJK Unified Ideographs"](a) || o.u["Hangul Syllables"](a) || o.u.Hiragana(a) || o.u.Katakana(a) || o.u["CJK Symbols and Punctuation"](a) || o.u["Halfwidth and Fullwidth Forms"](a));
          }
          _tinySDF(a, u, g) {
            const _ = this.localIdeographFontFamily;
            if (!_ || !this._doesCharSupportLocalGlyph(g)) return;
            let w = a.tinySDF;
            if (!w) {
              let R = "400";
              /bold/i.test(u) ? R = "900" : /medium/i.test(u) ? R = "500" : /light/i.test(u) && (R = "200"), w = a.tinySDF = new Me.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: _, fontWeight: R });
            }
            const C = w.draw(String.fromCharCode(g));
            return { id: g, bitmap: new o.o({ width: C.width || 60, height: C.height || 60 }, C.data), metrics: { width: C.glyphWidth / 2 || 24, height: C.glyphHeight / 2 || 24, left: C.glyphLeft / 2 + 0.5 || 0, top: C.glyphTop / 2 - 27.5 || -8, advance: C.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
          }
        }
        Me.loadGlyphRange = function(v, a, u, g) {
          return o._(this, void 0, void 0, function* () {
            const _ = 256 * a, w = _ + 255, C = g.transformRequest(u.replace("{fontstack}", v).replace("{range}", `${_}-${w}`), "Glyphs"), R = yield o.l(C, new AbortController());
            if (!R || !R.data) throw new Error(`Could not load glyph range. range: ${a}, ${_}-${w}`);
            const L = {};
            for (const k of o.n(R.data)) L[k.id] = k;
            return L;
          });
        }, Me.TinySDF = class {
          constructor() {
            let { fontSize: v = 24, buffer: a = 3, radius: u = 8, cutoff: g = 0.25, fontFamily: _ = "sans-serif", fontWeight: w = "normal", fontStyle: C = "normal" } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this.buffer = a, this.cutoff = g, this.radius = u;
            const R = this.size = v + 4 * a, L = this._createCanvas(R), k = this.ctx = L.getContext("2d", { willReadFrequently: !0 });
            k.font = `${C} ${w} ${v}px ${_}`, k.textBaseline = "alphabetic", k.textAlign = "left", k.fillStyle = "black", this.gridOuter = new Float64Array(R * R), this.gridInner = new Float64Array(R * R), this.f = new Float64Array(R), this.z = new Float64Array(R + 1), this.v = new Uint16Array(R);
          }
          _createCanvas(v) {
            const a = document.createElement("canvas");
            return a.width = a.height = v, a;
          }
          draw(v) {
            const { width: a, actualBoundingBoxAscent: u, actualBoundingBoxDescent: g, actualBoundingBoxLeft: _, actualBoundingBoxRight: w } = this.ctx.measureText(v), C = Math.ceil(u), R = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(w - _))), L = Math.min(this.size - this.buffer, C + Math.ceil(g)), k = R + 2 * this.buffer, V = L + 2 * this.buffer, W = Math.max(k * V, 0), Z = new Uint8ClampedArray(W), ae = { data: Z, width: k, height: V, glyphWidth: R, glyphHeight: L, glyphTop: C, glyphLeft: 0, glyphAdvance: a };
            if (R === 0 || L === 0) return ae;
            const { ctx: ue, buffer: Ce, gridInner: Se, gridOuter: Ie } = this;
            ue.clearRect(Ce, Ce, R, L), ue.fillText(v, Ce, Ce + C);
            const Le = ue.getImageData(Ce, Ce, R, L);
            Ie.fill(me, 0, W), Se.fill(0, 0, W);
            for (let qe = 0; qe < L; qe++) for (let $e = 0; $e < R; $e++) {
              const He = Le.data[4 * (qe * R + $e) + 3] / 255;
              if (He === 0) continue;
              const Ze = (qe + Ce) * k + $e + Ce;
              if (He === 1) Ie[Ze] = 0, Se[Ze] = me;
              else {
                const Je = 0.5 - He;
                Ie[Ze] = Je > 0 ? Je * Je : 0, Se[Ze] = Je < 0 ? Je * Je : 0;
              }
            }
            _e(Ie, 0, 0, k, V, k, this.f, this.v, this.z), _e(Se, Ce, Ce, R, L, k, this.f, this.v, this.z);
            for (let qe = 0; qe < W; qe++) {
              const $e = Math.sqrt(Ie[qe]) - Math.sqrt(Se[qe]);
              Z[qe] = Math.round(255 - 255 * ($e / this.radius + this.cutoff));
            }
            return ae;
          }
        };
        class Ct {
          constructor() {
            this.specification = o.v.light.position;
          }
          possiblyEvaluate(a, u) {
            return o.y(a.expression.evaluate(u));
          }
          interpolate(a, u, g) {
            return { x: o.z.number(a.x, u.x, g), y: o.z.number(a.y, u.y, g), z: o.z.number(a.z, u.z, g) };
          }
        }
        let ht;
        class Pt extends o.E {
          constructor(a) {
            super(), ht = ht || new o.q({ anchor: new o.D(o.v.light.anchor), position: new Ct(), color: new o.D(o.v.light.color), intensity: new o.D(o.v.light.intensity) }), this._transitionable = new o.T(ht), this.setLight(a), this._transitioning = this._transitionable.untransitioned();
          }
          getLight() {
            return this._transitionable.serialize();
          }
          setLight(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!this._validate(o.r, a, u)) for (const g in a) {
              const _ = a[g];
              g.endsWith("-transition") ? this._transitionable.setTransition(g.slice(0, -11), _) : this._transitionable.setValue(g, _);
            }
          }
          updateTransitions(a) {
            this._transitioning = this._transitionable.transitioned(a, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(a) {
            this.properties = this._transitioning.possiblyEvaluate(a);
          }
          _validate(a, u, g) {
            return (!g || g.validate !== !1) && o.t(this, a.call(o.x, { value: u, style: { glyphs: !0, sprite: !0 }, styleSpec: o.v }));
          }
        }
        const bt = new o.q({ "sky-color": new o.D(o.v.sky["sky-color"]), "horizon-color": new o.D(o.v.sky["horizon-color"]), "fog-color": new o.D(o.v.sky["fog-color"]), "fog-ground-blend": new o.D(o.v.sky["fog-ground-blend"]), "horizon-fog-blend": new o.D(o.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new o.D(o.v.sky["sky-horizon-blend"]), "atmosphere-blend": new o.D(o.v.sky["atmosphere-blend"]) });
        class kt extends o.E {
          constructor(a) {
            super(), this._transitionable = new o.T(bt), this.setSky(a), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.B(0));
          }
          setSky(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            if (!this._validate(o.C, a, u)) {
              a || (a = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
              for (const g in a) {
                const _ = a[g];
                g.endsWith("-transition") ? this._transitionable.setTransition(g.slice(0, -11), _) : this._transitionable.setValue(g, _);
              }
            }
          }
          getSky() {
            return this._transitionable.serialize();
          }
          updateTransitions(a) {
            this._transitioning = this._transitionable.transitioned(a, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition();
          }
          recalculate(a) {
            this.properties = this._transitioning.possiblyEvaluate(a);
          }
          _validate(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return (g == null ? void 0 : g.validate) !== !1 && o.t(this, a.call(o.x, o.e({ value: u, style: { glyphs: !0, sprite: !0 }, styleSpec: o.v })));
          }
          calculateFogBlendOpacity(a) {
            return a < 60 ? 0 : a < 70 ? (a - 60) / 10 : 1;
          }
        }
        class Nt {
          constructor(a, u) {
            this.width = a, this.height = u, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          }
          getDash(a, u) {
            const g = a.join(",") + String(u);
            return this.dashEntry[g] || (this.dashEntry[g] = this.addDash(a, u)), this.dashEntry[g];
          }
          getDashRanges(a, u, g) {
            const _ = [];
            let w = a.length % 2 == 1 ? -a[a.length - 1] * g : 0, C = a[0] * g, R = !0;
            _.push({ left: w, right: C, isDash: R, zeroLength: a[0] === 0 });
            let L = a[0];
            for (let k = 1; k < a.length; k++) {
              R = !R;
              const V = a[k];
              w = L * g, L += V, C = L * g, _.push({ left: w, right: C, isDash: R, zeroLength: V === 0 });
            }
            return _;
          }
          addRoundDash(a, u, g) {
            const _ = u / 2;
            for (let w = -g; w <= g; w++) {
              const C = this.width * (this.nextRow + g + w);
              let R = 0, L = a[R];
              for (let k = 0; k < this.width; k++) {
                k / L.right > 1 && (L = a[++R]);
                const V = Math.abs(k - L.left), W = Math.abs(k - L.right), Z = Math.min(V, W);
                let ae;
                const ue = w / g * (_ + 1);
                if (L.isDash) {
                  const Ce = _ - Math.abs(ue);
                  ae = Math.sqrt(Z * Z + Ce * Ce);
                } else ae = _ - Math.sqrt(Z * Z + ue * ue);
                this.data[C + k] = Math.max(0, Math.min(255, ae + 128));
              }
            }
          }
          addRegularDash(a) {
            for (let R = a.length - 1; R >= 0; --R) {
              const L = a[R], k = a[R + 1];
              L.zeroLength ? a.splice(R, 1) : k && k.isDash === L.isDash && (k.left = L.left, a.splice(R, 1));
            }
            const u = a[0], g = a[a.length - 1];
            u.isDash === g.isDash && (u.left = g.left - this.width, g.right = u.right + this.width);
            const _ = this.width * this.nextRow;
            let w = 0, C = a[w];
            for (let R = 0; R < this.width; R++) {
              R / C.right > 1 && (C = a[++w]);
              const L = Math.abs(R - C.left), k = Math.abs(R - C.right), V = Math.min(L, k);
              this.data[_ + R] = Math.max(0, Math.min(255, (C.isDash ? V : -V) + 128));
            }
          }
          addDash(a, u) {
            const g = u ? 7 : 0, _ = 2 * g + 1;
            if (this.nextRow + _ > this.height) return o.w("LineAtlas out of space"), null;
            let w = 0;
            for (let R = 0; R < a.length; R++) w += a[R];
            if (w !== 0) {
              const R = this.width / w, L = this.getDashRanges(a, this.width, R);
              u ? this.addRoundDash(L, R, g) : this.addRegularDash(L);
            }
            const C = { y: (this.nextRow + g + 0.5) / this.height, height: 2 * g / this.height, width: w };
            return this.nextRow += _, this.dirty = !0, C;
          }
          bind(a) {
            const u = a.gl;
            this.texture ? (u.bindTexture(u.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, u.texSubImage2D(u.TEXTURE_2D, 0, 0, 0, this.width, this.height, u.ALPHA, u.UNSIGNED_BYTE, this.data))) : (this.texture = u.createTexture(), u.bindTexture(u.TEXTURE_2D, this.texture), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.REPEAT), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.REPEAT), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.LINEAR), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.LINEAR), u.texImage2D(u.TEXTURE_2D, 0, u.ALPHA, this.width, this.height, 0, u.ALPHA, u.UNSIGNED_BYTE, this.data));
          }
        }
        const mr = "maplibre_preloaded_worker_pool";
        class ce {
          constructor() {
            this.active = {};
          }
          acquire(a) {
            if (!this.workers) for (this.workers = []; this.workers.length < ce.workerCount; ) this.workers.push(new Worker(o.a.WORKER_URL));
            return this.active[a] = !0, this.workers.slice();
          }
          release(a) {
            delete this.active[a], this.numActive() === 0 && (this.workers.forEach((u) => {
              u.terminate();
            }), this.workers = null);
          }
          isPreloaded() {
            return !!this.active[mr];
          }
          numActive() {
            return Object.keys(this.active).length;
          }
        }
        const Be = Math.floor(M.hardwareConcurrency / 2);
        let Ue, Xe;
        function it() {
          return Ue || (Ue = new ce()), Ue;
        }
        ce.workerCount = o.F(globalThis) ? Math.max(Math.min(Be, 3), 1) : 1;
        class ft {
          constructor(a, u) {
            this.workerPool = a, this.actors = [], this.currentActor = 0, this.id = u;
            const g = this.workerPool.acquire(u);
            for (let _ = 0; _ < g.length; _++) {
              const w = new o.G(g[_], u);
              w.name = `Worker ${_}`, this.actors.push(w);
            }
            if (!this.actors.length) throw new Error("No actors found");
          }
          broadcast(a, u) {
            const g = [];
            for (const _ of this.actors) g.push(_.sendAsync({ type: a, data: u }));
            return Promise.all(g);
          }
          getActor() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }
          remove() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            this.actors.forEach((u) => {
              u.remove();
            }), this.actors = [], a && this.workerPool.release(this.id);
          }
          registerMessageHandler(a, u) {
            for (const g of this.actors) g.registerMessageHandler(a, u);
          }
        }
        function St() {
          return Xe || (Xe = new ft(it(), o.H), Xe.registerMessageHandler("GR", (v, a, u) => o.m(a, u))), Xe;
        }
        function wt(v, a) {
          const u = o.J();
          return o.K(u, u, [1, 1, 0]), o.L(u, u, [0.5 * v.width, 0.5 * v.height, 1]), v.calculatePosMatrix ? o.M(u, u, v.calculatePosMatrix(a.toUnwrapped())) : u;
        }
        function ar(v, a, u, g, _, w) {
          var C;
          const R = function(W, Z, ae) {
            if (W) for (const ue of W) {
              const Ce = Z[ue];
              if (Ce && Ce.source === ae && Ce.type === "fill-extrusion") return !0;
            }
            else for (const ue in Z) {
              const Ce = Z[ue];
              if (Ce.source === ae && Ce.type === "fill-extrusion") return !0;
            }
            return !1;
          }((C = _ == null ? void 0 : _.layers) !== null && C !== void 0 ? C : null, a, v.id), L = w.maxPitchScaleFactor(), k = v.tilesIn(g, L, R);
          k.sort(Yt);
          const V = [];
          for (const W of k) V.push({ wrappedTileID: W.tileID.wrapped().key, queryResults: W.tile.queryRenderedFeatures(a, u, v._state, W.queryGeometry, W.cameraQueryGeometry, W.scale, _, w, L, wt(v.transform, W.tileID)) });
          return function(W, Z) {
            for (const ae in W) for (const ue of W[ae]) cr(ue, Z);
            return W;
          }(function(W) {
            const Z = {}, ae = {};
            for (const ue of W) {
              const Ce = ue.queryResults, Se = ue.wrappedTileID, Ie = ae[Se] = ae[Se] || {};
              for (const Le in Ce) {
                const qe = Ce[Le], $e = Ie[Le] = Ie[Le] || {}, He = Z[Le] = Z[Le] || [];
                for (const Ze of qe) $e[Ze.featureIndex] || ($e[Ze.featureIndex] = !0, He.push(Ze));
              }
            }
            return Z;
          }(V), v);
        }
        function Yt(v, a) {
          const u = v.tileID, g = a.tileID;
          return u.overscaledZ - g.overscaledZ || u.canonical.y - g.canonical.y || u.wrap - g.wrap || u.canonical.x - g.canonical.x;
        }
        function cr(v, a) {
          const u = v.feature, g = a.getFeatureState(u.layer["source-layer"], u.id);
          u.source = u.layer.source, u.layer["source-layer"] && (u.sourceLayer = u.layer["source-layer"]), u.state = g;
        }
        function _r(v, a, u) {
          return o._(this, void 0, void 0, function* () {
            let g = v;
            if (v.url ? g = (yield o.h(a.transformRequest(v.url, "Source"), u)).data : yield M.frameAsync(u), !g) return null;
            const _ = o.N(o.e(g, v), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
            return "vector_layers" in g && g.vector_layers && (_.vectorLayerIds = g.vector_layers.map((w) => w.id)), _;
          });
        }
        class Cr {
          constructor(a, u) {
            a && (u ? this.setSouthWest(a).setNorthEast(u) : Array.isArray(a) && (a.length === 4 ? this.setSouthWest([a[0], a[1]]).setNorthEast([a[2], a[3]]) : this.setSouthWest(a[0]).setNorthEast(a[1])));
          }
          setNorthEast(a) {
            return this._ne = a instanceof o.O ? new o.O(a.lng, a.lat) : o.O.convert(a), this;
          }
          setSouthWest(a) {
            return this._sw = a instanceof o.O ? new o.O(a.lng, a.lat) : o.O.convert(a), this;
          }
          extend(a) {
            const u = this._sw, g = this._ne;
            let _, w;
            if (a instanceof o.O) _ = a, w = a;
            else {
              if (!(a instanceof Cr)) return Array.isArray(a) ? a.length === 4 || a.every(Array.isArray) ? this.extend(Cr.convert(a)) : this.extend(o.O.convert(a)) : a && ("lng" in a || "lon" in a) && "lat" in a ? this.extend(o.O.convert(a)) : this;
              if (_ = a._sw, w = a._ne, !_ || !w) return this;
            }
            return u || g ? (u.lng = Math.min(_.lng, u.lng), u.lat = Math.min(_.lat, u.lat), g.lng = Math.max(w.lng, g.lng), g.lat = Math.max(w.lat, g.lat)) : (this._sw = new o.O(_.lng, _.lat), this._ne = new o.O(w.lng, w.lat)), this;
          }
          getCenter() {
            return new o.O((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }
          getSouthWest() {
            return this._sw;
          }
          getNorthEast() {
            return this._ne;
          }
          getNorthWest() {
            return new o.O(this.getWest(), this.getNorth());
          }
          getSouthEast() {
            return new o.O(this.getEast(), this.getSouth());
          }
          getWest() {
            return this._sw.lng;
          }
          getSouth() {
            return this._sw.lat;
          }
          getEast() {
            return this._ne.lng;
          }
          getNorth() {
            return this._ne.lat;
          }
          toArray() {
            return [this._sw.toArray(), this._ne.toArray()];
          }
          toString() {
            return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
          }
          isEmpty() {
            return !(this._sw && this._ne);
          }
          contains(a) {
            const { lng: u, lat: g } = o.O.convert(a);
            let _ = this._sw.lng <= u && u <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (_ = this._sw.lng >= u && u >= this._ne.lng), this._sw.lat <= g && g <= this._ne.lat && _;
          }
          static convert(a) {
            return a instanceof Cr ? a : a && new Cr(a);
          }
          static fromLngLat(a) {
            const g = 360 * (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0) / 40075017, _ = g / Math.cos(Math.PI / 180 * a.lat);
            return new Cr(new o.O(a.lng - _, a.lat - g), new o.O(a.lng + _, a.lat + g));
          }
          adjustAntiMeridian() {
            const a = new o.O(this._sw.lng, this._sw.lat), u = new o.O(this._ne.lng, this._ne.lat);
            return new Cr(a, a.lng > u.lng ? new o.O(u.lng + 360, u.lat) : u);
          }
        }
        class Ut {
          constructor(a, u, g) {
            this.bounds = Cr.convert(this.validateBounds(a)), this.minzoom = u || 0, this.maxzoom = g || 24;
          }
          validateBounds(a) {
            return Array.isArray(a) && a.length === 4 ? [Math.max(-180, a[0]), Math.max(-90, a[1]), Math.min(180, a[2]), Math.min(90, a[3])] : [-180, -90, 180, 90];
          }
          contains(a) {
            const u = Math.pow(2, a.z), g = Math.floor(o.S(this.bounds.getWest()) * u), _ = Math.floor(o.Q(this.bounds.getNorth()) * u), w = Math.ceil(o.S(this.bounds.getEast()) * u), C = Math.ceil(o.Q(this.bounds.getSouth()) * u);
            return a.x >= g && a.x < w && a.y >= _ && a.y < C;
          }
        }
        class Ve extends o.E {
          constructor(a, u, g, _) {
            if (super(), this.id = a, this.dispatcher = g, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, o.e(this, o.N(u, ["url", "scheme", "tileSize", "promoteId"])), this._options = o.e({ type: "vector" }, u), this._collectResourceTiming = u.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
            this.setEventedParent(_);
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !1, this.fire(new o.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
              try {
                const a = yield _r(this._options, this.map._requestManager, this._tileJSONRequest);
                this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), a && (o.e(this, a), a.bounds && (this.tileBounds = new Ut(a.bounds, this.minzoom, this.maxzoom)), this.fire(new o.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new o.k("data", { dataType: "source", sourceDataType: "content" })));
              } catch (a) {
                this._tileJSONRequest = null, this.fire(new o.j(a));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          hasTile(a) {
            return !this.tileBounds || this.tileBounds.contains(a.canonical);
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          setSourceProperty(a) {
            this._tileJSONRequest && this._tileJSONRequest.abort(), a(), this.load();
          }
          setTiles(a) {
            return this.setSourceProperty(() => {
              this._options.tiles = a;
            }), this;
          }
          setUrl(a) {
            return this.setSourceProperty(() => {
              this.url = a, this._options.url = a;
            }), this;
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          serialize() {
            return o.e({}, this._options);
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const u = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), g = { request: this.map._requestManager.transformRequest(u, "Tile"), uid: a.uid, tileID: a.tileID, zoom: a.tileID.overscaledZ, tileSize: this.tileSize * a.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              g.request.collectResourceTiming = this._collectResourceTiming;
              let _ = "RT";
              if (a.actor && a.state !== "expired") {
                if (a.state === "loading") return new Promise((w, C) => {
                  a.reloadPromise = { resolve: w, reject: C };
                });
              } else a.actor = this.dispatcher.getActor(), _ = "LT";
              a.abortController = new AbortController();
              try {
                const w = yield a.actor.sendAsync({ type: _, data: g }, a.abortController);
                if (delete a.abortController, a.aborted) return;
                this._afterTileLoadWorkerResponse(a, w);
              } catch (w) {
                if (delete a.abortController, a.aborted) return;
                if (w && w.status !== 404) throw w;
                this._afterTileLoadWorkerResponse(a, null);
              }
            });
          }
          _afterTileLoadWorkerResponse(a, u) {
            if (u && u.resourceTiming && (a.resourceTiming = u.resourceTiming), u && this.map._refreshExpiredTiles && a.setExpiryData(u), a.loadVectorData(u, this.map.painter), a.reloadPromise) {
              const g = a.reloadPromise;
              a.reloadPromise = null, this.loadTile(a).then(g.resolve).catch(g.reject);
            }
          }
          abortTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.abortController && (a.abortController.abort(), delete a.abortController), a.actor && (yield a.actor.sendAsync({ type: "AT", data: { uid: a.uid, type: this.type, source: this.id } }));
            });
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.unloadVectorData(), a.actor && (yield a.actor.sendAsync({ type: "RMT", data: { uid: a.uid, type: this.type, source: this.id } }));
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class jr extends o.E {
          constructor(a, u, g, _) {
            super(), this.id = a, this.dispatcher = g, this.setEventedParent(_), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = o.e({ type: "raster" }, u), o.e(this, o.N(u, ["url", "scheme", "tileSize"]));
          }
          load() {
            return o._(this, arguments, void 0, function() {
              var a = this;
              let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              return function* () {
                a._loaded = !1, a.fire(new o.k("dataloading", { dataType: "source" })), a._tileJSONRequest = new AbortController();
                try {
                  const g = yield _r(a._options, a.map._requestManager, a._tileJSONRequest);
                  a._tileJSONRequest = null, a._loaded = !0, g && (o.e(a, g), g.bounds && (a.tileBounds = new Ut(g.bounds, a.minzoom, a.maxzoom)), a.fire(new o.k("data", { dataType: "source", sourceDataType: "metadata" })), a.fire(new o.k("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: u })));
                } catch (g) {
                  a._tileJSONRequest = null, a.fire(new o.j(g));
                }
              }();
            });
          }
          loaded() {
            return this._loaded;
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          onRemove() {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
          }
          setSourceProperty(a) {
            this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), a(), this.load(!0);
          }
          setTiles(a) {
            return this.setSourceProperty(() => {
              this._options.tiles = a;
            }), this;
          }
          setUrl(a) {
            return this.setSourceProperty(() => {
              this.url = a, this._options.url = a;
            }), this;
          }
          serialize() {
            return o.e({}, this._options);
          }
          hasTile(a) {
            return !this.tileBounds || this.tileBounds.contains(a.canonical);
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const u = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              a.abortController = new AbortController();
              try {
                const g = yield X.getImage(this.map._requestManager.transformRequest(u, "Tile"), a.abortController, this.map._refreshExpiredTiles);
                if (delete a.abortController, a.aborted) return void (a.state = "unloaded");
                if (g && g.data) {
                  this.map._refreshExpiredTiles && g.cacheControl && g.expires && a.setExpiryData({ cacheControl: g.cacheControl, expires: g.expires });
                  const _ = this.map.painter.context, w = _.gl, C = g.data;
                  a.texture = this.map.painter.getTileTexture(C.width), a.texture ? a.texture.update(C, { useMipmap: !0 }) : (a.texture = new oe(_, C, w.RGBA, { useMipmap: !0 }), a.texture.bind(w.LINEAR, w.CLAMP_TO_EDGE, w.LINEAR_MIPMAP_NEAREST)), a.state = "loaded";
                }
              } catch (g) {
                if (delete a.abortController, a.aborted) a.state = "unloaded";
                else if (g) throw a.state = "errored", g;
              }
            });
          }
          abortTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.abortController && (a.abortController.abort(), delete a.abortController);
            });
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.texture && this.map.painter.saveTileTexture(a.texture);
            });
          }
          hasTransition() {
            return !1;
          }
        }
        class Ir extends jr {
          constructor(a, u, g, _) {
            super(a, u, g, _), this.type = "raster-dem", this.maxzoom = 22, this._options = o.e({ type: "raster-dem" }, u), this.encoding = u.encoding || "mapbox", this.redFactor = u.redFactor, this.greenFactor = u.greenFactor, this.blueFactor = u.blueFactor, this.baseShift = u.baseShift;
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const u = a.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), g = this.map._requestManager.transformRequest(u, "Tile");
              a.neighboringTiles = this._getNeighboringTiles(a.tileID), a.abortController = new AbortController();
              try {
                const _ = yield X.getImage(g, a.abortController, this.map._refreshExpiredTiles);
                if (delete a.abortController, a.aborted) return void (a.state = "unloaded");
                if (_ && _.data) {
                  const w = _.data;
                  this.map._refreshExpiredTiles && _.cacheControl && _.expires && a.setExpiryData({ cacheControl: _.cacheControl, expires: _.expires });
                  const C = o.b(w) && o.U() ? w : yield this.readImageNow(w), R = { type: this.type, uid: a.uid, source: this.id, rawImageData: C, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  if (!a.actor || a.state === "expired") {
                    a.actor = this.dispatcher.getActor();
                    const L = yield a.actor.sendAsync({ type: "LDT", data: R });
                    a.dem = L, a.needsHillshadePrepare = !0, a.needsTerrainPrepare = !0, a.state = "loaded";
                  }
                }
              } catch (_) {
                if (delete a.abortController, a.aborted) a.state = "unloaded";
                else if (_) throw a.state = "errored", _;
              }
            });
          }
          readImageNow(a) {
            return o._(this, void 0, void 0, function* () {
              if (typeof VideoFrame < "u" && o.V()) {
                const u = a.width + 2, g = a.height + 2;
                try {
                  return new o.R({ width: u, height: g }, yield o.W(a, -1, -1, u, g));
                } catch {
                }
              }
              return M.getImageData(a, 1);
            });
          }
          _getNeighboringTiles(a) {
            const u = a.canonical, g = Math.pow(2, u.z), _ = (u.x - 1 + g) % g, w = u.x === 0 ? a.wrap - 1 : a.wrap, C = (u.x + 1 + g) % g, R = u.x + 1 === g ? a.wrap + 1 : a.wrap, L = {};
            return L[new o.X(a.overscaledZ, w, u.z, _, u.y).key] = { backfilled: !1 }, L[new o.X(a.overscaledZ, R, u.z, C, u.y).key] = { backfilled: !1 }, u.y > 0 && (L[new o.X(a.overscaledZ, w, u.z, _, u.y - 1).key] = { backfilled: !1 }, L[new o.X(a.overscaledZ, a.wrap, u.z, u.x, u.y - 1).key] = { backfilled: !1 }, L[new o.X(a.overscaledZ, R, u.z, C, u.y - 1).key] = { backfilled: !1 }), u.y + 1 < g && (L[new o.X(a.overscaledZ, w, u.z, _, u.y + 1).key] = { backfilled: !1 }, L[new o.X(a.overscaledZ, a.wrap, u.z, u.x, u.y + 1).key] = { backfilled: !1 }, L[new o.X(a.overscaledZ, R, u.z, C, u.y + 1).key] = { backfilled: !1 }), L;
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.demTexture && this.map.painter.saveTileTexture(a.demTexture), a.fbo && (a.fbo.destroy(), delete a.fbo), a.dem && delete a.dem, delete a.neighboringTiles, a.state = "unloaded", a.actor && (yield a.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: a.uid, source: this.id } }));
            });
          }
        }
        class rr extends o.E {
          constructor(a, u, g, _) {
            super(), this.id = a, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = g.getActor(), this.setEventedParent(_), this._data = u.data, this._options = o.e({}, u), this._collectResourceTiming = u.collectResourceTiming, u.maxzoom !== void 0 && (this.maxzoom = u.maxzoom), u.type && (this.type = u.type), u.attribution && (this.attribution = u.attribution), this.promoteId = u.promoteId, u.clusterMaxZoom !== void 0 && this.maxzoom <= u.clusterMaxZoom && o.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${u.clusterMaxZoom}".`), this.workerOptions = o.e({ source: this.id, cluster: u.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(u.buffer !== void 0 ? u.buffer : 128), tolerance: this._pixelsToTileUnits(u.tolerance !== void 0 ? u.tolerance : 0.375), extent: o.Y, maxZoom: this.maxzoom, lineMetrics: u.lineMetrics || !1, generateId: u.generateId || !1 }, superclusterOptions: { maxZoom: u.clusterMaxZoom !== void 0 ? u.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, u.clusterMinPoints || 2), extent: o.Y, radius: this._pixelsToTileUnits(u.clusterRadius || 50), log: !1, generateId: u.generateId || !1 }, clusterProperties: u.clusterProperties, filter: u.filter }, u.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
          }
          _pixelsToTileUnits(a) {
            return a * (o.Y / this.tileSize);
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              yield this._updateWorkerData();
            });
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          setData(a) {
            return this._data = a, this._updateWorkerData(), this;
          }
          updateData(a) {
            return this._updateWorkerData(a), this;
          }
          getData() {
            return o._(this, void 0, void 0, function* () {
              const a = o.e({ type: this.type }, this.workerOptions);
              return this.actor.sendAsync({ type: "GD", data: a });
            });
          }
          setClusterOptions(a) {
            return this.workerOptions.cluster = a.cluster, a && (a.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(a.clusterRadius)), a.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = a.clusterMaxZoom)), this._updateWorkerData(), this;
          }
          getClusterExpansionZoom(a) {
            return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: a, source: this.id } });
          }
          getClusterChildren(a) {
            return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: a, source: this.id } });
          }
          getClusterLeaves(a, u, g) {
            return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: a, limit: u, offset: g } });
          }
          _updateWorkerData(a) {
            return o._(this, void 0, void 0, function* () {
              const u = o.e({ type: this.type }, this.workerOptions);
              a ? u.dataDiff = a : typeof this._data == "string" ? (u.request = this.map._requestManager.transformRequest(M.resolveURL(this._data), "Source"), u.request.collectResourceTiming = this._collectResourceTiming) : u.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new o.k("dataloading", { dataType: "source" }));
              try {
                const g = yield this.actor.sendAsync({ type: "LD", data: u });
                if (this._pendingLoads--, this._removed || g.abandoned) return void this.fire(new o.k("dataabort", { dataType: "source" }));
                let _ = null;
                g.resourceTiming && g.resourceTiming[this.id] && (_ = g.resourceTiming[this.id].slice(0));
                const w = { dataType: "source" };
                this._collectResourceTiming && _ && _.length > 0 && o.e(w, { resourceTiming: _ }), this.fire(new o.k("data", Object.assign(Object.assign({}, w), { sourceDataType: "metadata" }))), this.fire(new o.k("data", Object.assign(Object.assign({}, w), { sourceDataType: "content" })));
              } catch (g) {
                if (this._pendingLoads--, this._removed) return void this.fire(new o.k("dataabort", { dataType: "source" }));
                this.fire(new o.j(g));
              }
            });
          }
          loaded() {
            return this._pendingLoads === 0;
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              const u = a.actor ? "RT" : "LT";
              a.actor = this.actor;
              const g = { type: this.type, uid: a.uid, tileID: a.tileID, zoom: a.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
              a.abortController = new AbortController();
              const _ = yield this.actor.sendAsync({ type: u, data: g }, a.abortController);
              delete a.abortController, a.unloadVectorData(), a.aborted || a.loadVectorData(_, this.map.painter, u === "RT");
            });
          }
          abortTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.abortController && (a.abortController.abort(), delete a.abortController), a.aborted = !0;
            });
          }
          unloadTile(a) {
            return o._(this, void 0, void 0, function* () {
              a.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: a.uid, type: this.type, source: this.id } });
            });
          }
          onRemove() {
            this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
          }
          serialize() {
            return o.e({}, this._options, { type: this.type, data: this._data });
          }
          hasTransition() {
            return !1;
          }
        }
        class hr extends o.E {
          constructor(a, u, g, _) {
            super(), this.flippedWindingOrder = !1, this.id = a, this.dispatcher = g, this.coordinates = u.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(_), this.options = u;
          }
          load(a) {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !1, this.fire(new o.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
              try {
                const u = yield X.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                this._request = null, this._loaded = !0, u && u.data && (this.image = u.data, a && (this.coordinates = a), this._finishLoading());
              } catch (u) {
                this._request = null, this._loaded = !0, this.fire(new o.j(u));
              }
            });
          }
          loaded() {
            return this._loaded;
          }
          updateImage(a) {
            return a.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = a.url, this.load(a.coordinates).finally(() => {
              this.texture = null;
            }), this) : this;
          }
          _finishLoading() {
            this.map && (this.setCoordinates(this.coordinates), this.fire(new o.k("data", { dataType: "source", sourceDataType: "metadata" })));
          }
          onAdd(a) {
            this.map = a, this.load();
          }
          onRemove() {
            this._request && (this._request.abort(), this._request = null);
          }
          setCoordinates(a) {
            this.coordinates = a;
            const u = a.map(o.Z.fromLngLat);
            var g;
            return this.tileID = function(_) {
              let w = 1 / 0, C = 1 / 0, R = -1 / 0, L = -1 / 0;
              for (const Z of _) w = Math.min(w, Z.x), C = Math.min(C, Z.y), R = Math.max(R, Z.x), L = Math.max(L, Z.y);
              const k = Math.max(R - w, L - C), V = Math.max(0, Math.floor(-Math.log(k) / Math.LN2)), W = Math.pow(2, V);
              return new o.$(V, Math.floor((w + R) / 2 * W), Math.floor((C + L) / 2 * W));
            }(u), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = u.map((_) => this.tileID.getTilePoint(_)._round()), this.flippedWindingOrder = ((g = this.tileCoords)[1].x - g[0].x) * (g[2].y - g[0].y) - (g[1].y - g[0].y) * (g[2].x - g[0].x) < 0, this.fire(new o.k("data", { dataType: "source", sourceDataType: "content" })), this;
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || !this.image) return;
            const a = this.map.painter.context, u = a.gl;
            this.texture || (this.texture = new oe(a, this.image, u.RGBA), this.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE));
            let g = !1;
            for (const _ in this.tiles) {
              const w = this.tiles[_];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, g = !0);
            }
            g && this.fire(new o.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          loadTile(a) {
            return o._(this, void 0, void 0, function* () {
              this.tileID && this.tileID.equals(a.tileID.canonical) ? (this.tiles[String(a.tileID.wrap)] = a, a.buckets = {}) : a.state = "errored";
            });
          }
          serialize() {
            return { type: "image", url: this.options.url, coordinates: this.coordinates };
          }
          hasTransition() {
            return !1;
          }
        }
        class wr extends hr {
          constructor(a, u, g, _) {
            super(a, u, g, _), this.roundZoom = !0, this.type = "video", this.options = u;
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !1;
              const a = this.options;
              this.urls = [];
              for (const u of a.urls) this.urls.push(this.map._requestManager.transformRequest(u, "Source").url);
              try {
                const u = yield o.a0(this.urls);
                if (this._loaded = !0, !u) return;
                this.video = u, this.video.loop = !0, this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading();
              } catch (u) {
                this.fire(new o.j(u));
              }
            });
          }
          pause() {
            this.video && this.video.pause();
          }
          play() {
            this.video && this.video.play();
          }
          seek(a) {
            if (this.video) {
              const u = this.video.seekable;
              a < u.start(0) || a > u.end(0) ? this.fire(new o.j(new o.a1(`sources.${this.id}`, null, `Playback for this video can be set only between the ${u.start(0)} and ${u.end(0)}-second mark.`))) : this.video.currentTime = a;
            }
          }
          getVideo() {
            return this.video;
          }
          onAdd(a) {
            this.map || (this.map = a, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
          }
          prepare() {
            if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
            const a = this.map.painter.context, u = a.gl;
            this.texture ? this.video.paused || (this.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE), u.texSubImage2D(u.TEXTURE_2D, 0, 0, 0, u.RGBA, u.UNSIGNED_BYTE, this.video)) : (this.texture = new oe(a, this.video, u.RGBA), this.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE));
            let g = !1;
            for (const _ in this.tiles) {
              const w = this.tiles[_];
              w.state !== "loaded" && (w.state = "loaded", w.texture = this.texture, g = !0);
            }
            g && this.fire(new o.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "video", urls: this.urls, coordinates: this.coordinates };
          }
          hasTransition() {
            return this.video && !this.video.paused;
          }
        }
        class br extends hr {
          constructor(a, u, g, _) {
            super(a, u, g, _), u.coordinates ? Array.isArray(u.coordinates) && u.coordinates.length === 4 && !u.coordinates.some((w) => !Array.isArray(w) || w.length !== 2 || w.some((C) => typeof C != "number")) || this.fire(new o.j(new o.a1(`sources.${a}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new o.j(new o.a1(`sources.${a}`, null, 'missing required property "coordinates"'))), u.animate && typeof u.animate != "boolean" && this.fire(new o.j(new o.a1(`sources.${a}`, null, 'optional "animate" property must be a boolean value'))), u.canvas ? typeof u.canvas == "string" || u.canvas instanceof HTMLCanvasElement || this.fire(new o.j(new o.a1(`sources.${a}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new o.j(new o.a1(`sources.${a}`, null, 'missing required property "canvas"'))), this.options = u, this.animate = u.animate === void 0 || u.animate;
          }
          load() {
            return o._(this, void 0, void 0, function* () {
              this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new o.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = !0, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = !1);
              }, this._finishLoading());
            });
          }
          getCanvas() {
            return this.canvas;
          }
          onAdd(a) {
            this.map = a, this.load(), this.canvas && this.animate && this.play();
          }
          onRemove() {
            this.pause();
          }
          prepare() {
            let a = !1;
            if (this.canvas.width !== this.width && (this.width = this.canvas.width, a = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, a = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
            const u = this.map.painter.context, g = u.gl;
            this.texture ? (a || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new oe(u, this.canvas, g.RGBA, { premultiply: !0 });
            let _ = !1;
            for (const w in this.tiles) {
              const C = this.tiles[w];
              C.state !== "loaded" && (C.state = "loaded", C.texture = this.texture, _ = !0);
            }
            _ && this.fire(new o.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
          }
          serialize() {
            return { type: "canvas", coordinates: this.coordinates };
          }
          hasTransition() {
            return this._playing;
          }
          _hasInvalidDimensions() {
            for (const a of [this.canvas.width, this.canvas.height]) if (isNaN(a) || a <= 0) return !0;
            return !1;
          }
        }
        const Rr = {}, $r = (v) => {
          switch (v) {
            case "geojson":
              return rr;
            case "image":
              return hr;
            case "raster":
              return jr;
            case "raster-dem":
              return Ir;
            case "vector":
              return Ve;
            case "video":
              return wr;
            case "canvas":
              return br;
          }
          return Rr[v];
        }, Wr = "RTLPluginLoaded";
        class Zr extends o.E {
          constructor() {
            super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = St();
          }
          _syncState(a) {
            return this.status = a, this.dispatcher.broadcast("SRPS", { pluginStatus: a, pluginURL: this.url }).catch((u) => {
              throw this.status = "error", u;
            });
          }
          getRTLTextPluginStatus() {
            return this.status;
          }
          clearRTLTextPlugin() {
            this.status = "unavailable", this.url = null;
          }
          setRTLTextPlugin(a) {
            return o._(this, arguments, void 0, function(u) {
              var g = this;
              let _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
              return function* () {
                if (g.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
                if (g.url = M.resolveURL(u), !g.url) throw new Error(`requested url ${u} is invalid`);
                if (g.status === "unavailable") {
                  if (!_) return g._requestImport();
                  g.status = "deferred", g._syncState(g.status);
                } else if (g.status === "requested") return g._requestImport();
              }();
            });
          }
          _requestImport() {
            return o._(this, void 0, void 0, function* () {
              yield this._syncState("loading"), this.status = "loaded", this.fire(new o.k(Wr));
            });
          }
          lazyLoad() {
            this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
          }
        }
        let hn = null;
        function yn() {
          return hn || (hn = new Zr()), hn;
        }
        class Vr {
          constructor(a, u) {
            this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = a, this.uid = o.a2(), this.uses = 0, this.tileSize = u, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
          }
          registerFadeDuration(a) {
            const u = a + this.timeAdded;
            u < this.fadeEndTime || (this.fadeEndTime = u);
          }
          wasRequested() {
            return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
          }
          clearTextures(a) {
            this.demTexture && a.saveTileTexture(this.demTexture), this.demTexture = null;
          }
          loadVectorData(a, u, g) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", a) {
              a.featureIndex && (this.latestFeatureIndex = a.featureIndex, a.rawTileData ? (this.latestRawTileData = a.rawTileData, this.latestFeatureIndex.rawTileData = a.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = a.collisionBoxArray, this.buckets = function(_, w) {
                const C = {};
                if (!w) return C;
                for (const R of _) {
                  const L = R.layerIds.map((k) => w.getLayer(k)).filter(Boolean);
                  if (L.length !== 0) {
                    R.layers = L, R.stateDependentLayerIds && (R.stateDependentLayers = R.stateDependentLayerIds.map((k) => L.filter((V) => V.id === k)[0]));
                    for (const k of L) C[k.id] = R;
                  }
                }
                return C;
              }(a.buckets, u == null ? void 0 : u.style), this.hasSymbolBuckets = !1;
              for (const _ in this.buckets) {
                const w = this.buckets[_];
                if (w instanceof o.a4) {
                  if (this.hasSymbolBuckets = !0, !g) break;
                  w.justReloaded = !0;
                }
              }
              if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const _ in this.buckets) {
                const w = this.buckets[_];
                if (w instanceof o.a4 && w.hasRTLText) {
                  this.hasRTLText = !0, yn().lazyLoad();
                  break;
                }
              }
              this.queryPadding = 0;
              for (const _ in this.buckets) {
                const w = this.buckets[_];
                this.queryPadding = Math.max(this.queryPadding, u.style.getLayer(_).queryRadius(w));
              }
              a.imageAtlas && (this.imageAtlas = a.imageAtlas), a.glyphAtlasImage && (this.glyphAtlasImage = a.glyphAtlasImage);
            } else this.collisionBoxArray = new o.a3();
          }
          unloadVectorData() {
            for (const a in this.buckets) this.buckets[a].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }
          getBucket(a) {
            return this.buckets[a.id];
          }
          upload(a) {
            for (const g in this.buckets) {
              const _ = this.buckets[g];
              _.uploadPending() && _.upload(a);
            }
            const u = a.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new oe(a, this.imageAtlas.image, u.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new oe(a, this.glyphAtlasImage, u.ALPHA), this.glyphAtlasImage = null);
          }
          prepare(a) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(a, this.imageAtlasTexture);
          }
          queryRenderedFeatures(a, u, g, _, w, C, R, L, k, V) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: _, cameraQueryGeometry: w, scale: C, tileSize: this.tileSize, pixelPosMatrix: V, transform: L, params: R, queryPadding: this.queryPadding * k }, a, u, g) : {};
          }
          querySourceFeatures(a, u) {
            const g = this.latestFeatureIndex;
            if (!g || !g.rawTileData) return;
            const _ = g.loadVTLayers(), w = u && u.sourceLayer ? u.sourceLayer : "", C = _._geojsonTileLayer || _[w];
            if (!C) return;
            const R = o.a5(u && u.filter), { z: L, x: k, y: V } = this.tileID.canonical, W = { z: L, x: k, y: V };
            for (let Z = 0; Z < C.length; Z++) {
              const ae = C.feature(Z);
              if (R.needGeometry) {
                const Se = o.a6(ae, !0);
                if (!R.filter(new o.B(this.tileID.overscaledZ), Se, this.tileID.canonical)) continue;
              } else if (!R.filter(new o.B(this.tileID.overscaledZ), ae)) continue;
              const ue = g.getId(ae, w), Ce = new o.a7(ae, L, k, V, ue);
              Ce.tile = W, a.push(Ce);
            }
          }
          hasData() {
            return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
          }
          patternsLoaded() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }
          setExpiryData(a) {
            const u = this.expirationTime;
            if (a.cacheControl) {
              const g = o.a8(a.cacheControl);
              g["max-age"] && (this.expirationTime = Date.now() + 1e3 * g["max-age"]);
            } else a.expires && (this.expirationTime = new Date(a.expires).getTime());
            if (this.expirationTime) {
              const g = Date.now();
              let _ = !1;
              if (this.expirationTime > g) _ = !1;
              else if (u)
                if (this.expirationTime < u) _ = !0;
                else {
                  const w = this.expirationTime - u;
                  w ? this.expirationTime = g + Math.max(w, 3e4) : _ = !0;
                }
              else _ = !0;
              _ ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }
          getExpiryTimeout() {
            if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
          }
          setFeatureState(a, u) {
            if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(a).length === 0) return;
            const g = this.latestFeatureIndex.loadVTLayers();
            for (const _ in this.buckets) {
              if (!u.style.hasLayer(_)) continue;
              const w = this.buckets[_], C = w.layers[0].sourceLayer || "_geojsonTileLayer", R = g[C], L = a[C];
              if (!R || !L || Object.keys(L).length === 0) continue;
              w.update(L, R, this.imageAtlas && this.imageAtlas.patternPositions || {});
              const k = u && u.style && u.style.getLayer(_);
              k && (this.queryPadding = Math.max(this.queryPadding, k.queryRadius(w)));
            }
          }
          holdingForFade() {
            return this.symbolFadeHoldUntil !== void 0;
          }
          symbolFadeFinished() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < M.now();
          }
          clearFadeHold() {
            this.symbolFadeHoldUntil = void 0;
          }
          setHoldDuration(a) {
            this.symbolFadeHoldUntil = M.now() + a;
          }
          setDependencies(a, u) {
            const g = {};
            for (const _ of u) g[_] = !0;
            this.dependencies[a] = g;
          }
          hasDependency(a, u) {
            for (const g of a) {
              const _ = this.dependencies[g];
              if (_) {
                for (const w of u) if (_[w]) return !0;
              }
            }
            return !1;
          }
        }
        class en {
          constructor(a, u) {
            this.max = a, this.onRemove = u, this.reset();
          }
          reset() {
            for (const a in this.data) for (const u of this.data[a]) u.timeout && clearTimeout(u.timeout), this.onRemove(u.value);
            return this.data = {}, this.order = [], this;
          }
          add(a, u, g) {
            const _ = a.wrapped().key;
            this.data[_] === void 0 && (this.data[_] = []);
            const w = { value: u, timeout: void 0 };
            if (g !== void 0 && (w.timeout = setTimeout(() => {
              this.remove(a, w);
            }, g)), this.data[_].push(w), this.order.push(_), this.order.length > this.max) {
              const C = this._getAndRemoveByKey(this.order[0]);
              C && this.onRemove(C);
            }
            return this;
          }
          has(a) {
            return a.wrapped().key in this.data;
          }
          getAndRemove(a) {
            return this.has(a) ? this._getAndRemoveByKey(a.wrapped().key) : null;
          }
          _getAndRemoveByKey(a) {
            const u = this.data[a].shift();
            return u.timeout && clearTimeout(u.timeout), this.data[a].length === 0 && delete this.data[a], this.order.splice(this.order.indexOf(a), 1), u.value;
          }
          getByKey(a) {
            const u = this.data[a];
            return u ? u[0].value : null;
          }
          get(a) {
            return this.has(a) ? this.data[a.wrapped().key][0].value : null;
          }
          remove(a, u) {
            if (!this.has(a)) return this;
            const g = a.wrapped().key, _ = u === void 0 ? 0 : this.data[g].indexOf(u), w = this.data[g][_];
            return this.data[g].splice(_, 1), w.timeout && clearTimeout(w.timeout), this.data[g].length === 0 && delete this.data[g], this.onRemove(w.value), this.order.splice(this.order.indexOf(g), 1), this;
          }
          setMaxSize(a) {
            for (this.max = a; this.order.length > this.max; ) {
              const u = this._getAndRemoveByKey(this.order[0]);
              u && this.onRemove(u);
            }
            return this;
          }
          filter(a) {
            const u = [];
            for (const g in this.data) for (const _ of this.data[g]) a(_.value) || u.push(_);
            for (const g of u) this.remove(g.value.tileID, g);
          }
        }
        class Ar {
          constructor() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          }
          updateState(a, u, g) {
            const _ = String(u);
            if (this.stateChanges[a] = this.stateChanges[a] || {}, this.stateChanges[a][_] = this.stateChanges[a][_] || {}, o.e(this.stateChanges[a][_], g), this.deletedStates[a] === null) {
              this.deletedStates[a] = {};
              for (const w in this.state[a]) w !== _ && (this.deletedStates[a][w] = null);
            } else if (this.deletedStates[a] && this.deletedStates[a][_] === null) {
              this.deletedStates[a][_] = {};
              for (const w in this.state[a][_]) g[w] || (this.deletedStates[a][_][w] = null);
            } else for (const w in g) this.deletedStates[a] && this.deletedStates[a][_] && this.deletedStates[a][_][w] === null && delete this.deletedStates[a][_][w];
          }
          removeFeatureState(a, u, g) {
            if (this.deletedStates[a] === null) return;
            const _ = String(u);
            if (this.deletedStates[a] = this.deletedStates[a] || {}, g && u !== void 0) this.deletedStates[a][_] !== null && (this.deletedStates[a][_] = this.deletedStates[a][_] || {}, this.deletedStates[a][_][g] = null);
            else if (u !== void 0)
              if (this.stateChanges[a] && this.stateChanges[a][_]) for (g in this.deletedStates[a][_] = {}, this.stateChanges[a][_]) this.deletedStates[a][_][g] = null;
              else this.deletedStates[a][_] = null;
            else this.deletedStates[a] = null;
          }
          getState(a, u) {
            const g = String(u), _ = o.e({}, (this.state[a] || {})[g], (this.stateChanges[a] || {})[g]);
            if (this.deletedStates[a] === null) return {};
            if (this.deletedStates[a]) {
              const w = this.deletedStates[a][u];
              if (w === null) return {};
              for (const C in w) delete _[C];
            }
            return _;
          }
          initializeTileState(a, u) {
            a.setFeatureState(this.state, u);
          }
          coalesceChanges(a, u) {
            const g = {};
            for (const _ in this.stateChanges) {
              this.state[_] = this.state[_] || {};
              const w = {};
              for (const C in this.stateChanges[_]) this.state[_][C] || (this.state[_][C] = {}), o.e(this.state[_][C], this.stateChanges[_][C]), w[C] = this.state[_][C];
              g[_] = w;
            }
            for (const _ in this.deletedStates) {
              this.state[_] = this.state[_] || {};
              const w = {};
              if (this.deletedStates[_] === null) for (const C in this.state[_]) w[C] = {}, this.state[_][C] = {};
              else for (const C in this.deletedStates[_]) {
                if (this.deletedStates[_][C] === null) this.state[_][C] = {};
                else for (const R of Object.keys(this.deletedStates[_][C])) delete this.state[_][C][R];
                w[C] = this.state[_][C];
              }
              g[_] = g[_] || {}, o.e(g[_], w);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(g).length !== 0) for (const _ in a) a[_].setFeatureState(g, u);
          }
        }
        function Ii(v, a, u) {
          const g = a.intersectsFrustum(v);
          if (!u) return g;
          const _ = a.intersectsPlane(u);
          return g === 0 || _ === 0 ? 0 : g === 2 && _ === 2 ? 2 : 1;
        }
        function bn(v, a, u, g, _) {
          let w = v;
          const C = Math.atan(a / u), R = Math.hypot(a, u);
          return w = v + o.a9(g / R / Math.max(0.5, Math.cos(o.ab(_ / 2)))), w += 1 * o.a9(Math.cos(C)) / 2, w += o.ac(v - w, -0, 0), w;
        }
        function Xi(v, a) {
          const u = (a.roundZoom ? Math.round : Math.floor)(v.zoom + o.a9(v.tileSize / a.tileSize));
          return Math.max(0, u);
        }
        function ve(v, a) {
          const u = v.getCameraFrustum(), g = v.getClippingPlane(), _ = v.screenPointToMercatorCoordinate(v.getCameraPoint()), w = o.Z.fromLngLat(v.center, v.elevation);
          _.z = w.z + Math.cos(v.pitchInRadians) * v.cameraToCenterDistance / v.worldSize;
          const C = v.getCoveringTilesDetailsProvider(), R = C.allowVariableZoom(v, a), L = Xi(v, a), k = a.minzoom || 0, V = a.maxzoom !== void 0 ? a.maxzoom : v.maxZoom, W = Math.min(Math.max(0, L), V), Z = Math.pow(2, W), ae = [Z * _.x, Z * _.y, 0], ue = [Z * w.x, Z * w.y, 0], Ce = Math.hypot(w.x - _.x, w.y - _.y), Se = Math.abs(w.z - _.z), Ie = Math.hypot(Ce, Se), Le = (He) => ({ zoom: 0, x: 0, y: 0, wrap: He, fullyVisible: !1 }), qe = [], $e = [];
          if (v.renderWorldCopies && C.allowWorldCopies()) for (let He = 1; He <= 3; He++) qe.push(Le(-He)), qe.push(Le(He));
          for (qe.push(Le(0)); qe.length > 0; ) {
            const He = qe.pop(), Ze = He.x, Je = He.y;
            let vt = He.fullyVisible;
            const _t = { x: Ze, y: Je, z: He.zoom }, Rt = C.getTileAABB(_t, He.wrap, v.elevation, a);
            if (!vt) {
              const nr = Ii(u, Rt, g);
              if (nr === 0) continue;
              vt = nr === 2;
            }
            const Ft = C.distanceToTile2d(_.x, _.y, _t, Rt);
            let Mt = L;
            R && (Mt = (a.calculateTileZoom || bn)(v.zoom + o.a9(v.tileSize / a.tileSize), Ft, Se, Ie, v.fov)), Mt = (a.roundZoom ? Math.round : Math.floor)(Mt), Mt = Math.max(0, Mt);
            const sr = Math.min(Mt, V);
            if (He.wrap = C.getWrap(w, _t, He.wrap), He.zoom >= sr) {
              if (He.zoom < k) continue;
              const nr = W - He.zoom, Gt = ae[0] - 0.5 - (Ze << nr), dr = ae[1] - 0.5 - (Je << nr), Gr = a.reparseOverscaled ? Math.max(He.zoom, Mt) : He.zoom;
              $e.push({ tileID: new o.X(He.zoom === V ? Gr : He.zoom, He.wrap, He.zoom, Ze, Je), distanceSq: o.aa([ue[0] - 0.5 - Ze, ue[1] - 0.5 - Je]), tileDistanceToCamera: Math.sqrt(Gt * Gt + dr * dr) });
            } else for (let nr = 0; nr < 4; nr++) qe.push({ zoom: He.zoom + 1, x: (Ze << 1) + nr % 2, y: (Je << 1) + (nr >> 1), wrap: He.wrap, fullyVisible: vt });
          }
          return $e.sort((He, Ze) => He.distanceSq - Ze.distanceSq).map((He) => He.tileID);
        }
        class se extends o.E {
          constructor(a, u, g) {
            super(), this.id = a, this.dispatcher = g, this.on("data", (_) => this._dataHandler(_)), this.on("dataloading", () => {
              this._sourceErrored = !1;
            }), this.on("error", () => {
              this._sourceErrored = this._source.loaded();
            }), this._source = ((_, w, C, R) => {
              const L = new ($r(w.type))(_, w, C, R);
              if (L.id !== _) throw new Error(`Expected Source id to be ${_} instead of ${L.id}`);
              return L;
            })(a, u, g, this), this._tiles = {}, this._cache = new en(0, (_) => this._unloadTile(_)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new Ar(), this._didEmitContent = !1, this._updated = !1;
          }
          onAdd(a) {
            this.map = a, this._maxTileCacheSize = a ? a._maxTileCacheSize : null, this._maxTileCacheZoomLevels = a ? a._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(a);
          }
          onRemove(a) {
            this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(a);
          }
          loaded() {
            if (this._sourceErrored) return !0;
            if (!this._sourceLoaded || !this._source.loaded()) return !1;
            if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
            if (!this._updated) return !1;
            for (const a in this._tiles) {
              const u = this._tiles[a];
              if (u.state !== "loaded" && u.state !== "errored") return !1;
            }
            return !0;
          }
          getSource() {
            return this._source;
          }
          pause() {
            this._paused = !0;
          }
          resume() {
            if (!this._paused) return;
            const a = this._shouldReloadOnResume;
            this._paused = !1, this._shouldReloadOnResume = !1, a && this.reload(), this.transform && this.update(this.transform, this.terrain);
          }
          _loadTile(a, u, g) {
            return o._(this, void 0, void 0, function* () {
              try {
                yield this._source.loadTile(a), this._tileLoaded(a, u, g);
              } catch (_) {
                a.state = "errored", _.status !== 404 ? this._source.fire(new o.j(_, { tile: a })) : this.update(this.transform, this.terrain);
              }
            });
          }
          _unloadTile(a) {
            this._source.unloadTile && this._source.unloadTile(a);
          }
          _abortTile(a) {
            this._source.abortTile && this._source.abortTile(a), this._source.fire(new o.k("dataabort", { tile: a, coord: a.tileID, dataType: "source" }));
          }
          serialize() {
            return this._source.serialize();
          }
          prepare(a) {
            this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
            for (const u in this._tiles) {
              const g = this._tiles[u];
              g.upload(a), g.prepare(this.map.style.imageManager);
            }
          }
          getIds() {
            return Object.values(this._tiles).map((a) => a.tileID).sort(de).map((a) => a.key);
          }
          getRenderableIds(a) {
            const u = [];
            for (const g in this._tiles) this._isIdRenderable(g, a) && u.push(this._tiles[g]);
            return a ? u.sort((g, _) => {
              const w = g.tileID, C = _.tileID, R = new o.P(w.canonical.x, w.canonical.y)._rotate(-this.transform.bearingInRadians), L = new o.P(C.canonical.x, C.canonical.y)._rotate(-this.transform.bearingInRadians);
              return w.overscaledZ - C.overscaledZ || L.y - R.y || L.x - R.x;
            }).map((g) => g.tileID.key) : u.map((g) => g.tileID).sort(de).map((g) => g.key);
          }
          hasRenderableParent(a) {
            const u = this.findLoadedParent(a, 0);
            return !!u && this._isIdRenderable(u.tileID.key);
          }
          _isIdRenderable(a, u) {
            return this._tiles[a] && this._tiles[a].hasData() && !this._coveredTiles[a] && (u || !this._tiles[a].holdingForFade());
          }
          reload(a) {
            if (this._paused) this._shouldReloadOnResume = !0;
            else {
              this._cache.reset();
              for (const u in this._tiles) (a || this._tiles[u].state !== "errored") && this._reloadTile(u, "reloading");
            }
          }
          _reloadTile(a, u) {
            return o._(this, void 0, void 0, function* () {
              const g = this._tiles[a];
              g && (g.state !== "loading" && (g.state = u), yield this._loadTile(g, a, u));
            });
          }
          _tileLoaded(a, u, g) {
            a.timeAdded = M.now(), g === "expired" && (a.refreshedUponExpiration = !0), this._setTileReloadTimer(u, a), this.getSource().type === "raster-dem" && a.dem && this._backfillDEM(a), this._state.initializeTileState(a, this.map ? this.map.painter : null), a.aborted || this._source.fire(new o.k("data", { dataType: "source", tile: a, coord: a.tileID }));
          }
          _backfillDEM(a) {
            const u = this.getRenderableIds();
            for (let _ = 0; _ < u.length; _++) {
              const w = u[_];
              if (a.neighboringTiles && a.neighboringTiles[w]) {
                const C = this.getTileByID(w);
                g(a, C), g(C, a);
              }
            }
            function g(_, w) {
              _.needsHillshadePrepare = !0, _.needsTerrainPrepare = !0;
              let C = w.tileID.canonical.x - _.tileID.canonical.x;
              const R = w.tileID.canonical.y - _.tileID.canonical.y, L = Math.pow(2, _.tileID.canonical.z), k = w.tileID.key;
              C === 0 && R === 0 || Math.abs(R) > 1 || (Math.abs(C) > 1 && (Math.abs(C + L) === 1 ? C += L : Math.abs(C - L) === 1 && (C -= L)), w.dem && _.dem && (_.dem.backfillBorder(w.dem, C, R), _.neighboringTiles && _.neighboringTiles[k] && (_.neighboringTiles[k].backfilled = !0)));
            }
          }
          getTile(a) {
            return this.getTileByID(a.key);
          }
          getTileByID(a) {
            return this._tiles[a];
          }
          _retainLoadedChildren(a, u, g, _) {
            for (const w in this._tiles) {
              let C = this._tiles[w];
              if (_[w] || !C.hasData() || C.tileID.overscaledZ <= u || C.tileID.overscaledZ > g) continue;
              let R = C.tileID;
              for (; C && C.tileID.overscaledZ > u + 1; ) {
                const k = C.tileID.scaledTo(C.tileID.overscaledZ - 1);
                C = this._tiles[k.key], C && C.hasData() && (R = k);
              }
              let L = R;
              for (; L.overscaledZ > u; ) if (L = L.scaledTo(L.overscaledZ - 1), a[L.key] || a[L.canonical.key]) {
                _[R.key] = R;
                break;
              }
            }
          }
          findLoadedParent(a, u) {
            if (a.key in this._loadedParentTiles) {
              const g = this._loadedParentTiles[a.key];
              return g && g.tileID.overscaledZ >= u ? g : null;
            }
            for (let g = a.overscaledZ - 1; g >= u; g--) {
              const _ = a.scaledTo(g), w = this._getLoadedTile(_);
              if (w) return w;
            }
          }
          findLoadedSibling(a) {
            return this._getLoadedTile(a);
          }
          _getLoadedTile(a) {
            const u = this._tiles[a.key];
            return u && u.hasData() ? u : this._cache.getByKey(a.wrapped().key);
          }
          updateCacheSize(a) {
            const u = Math.ceil(a.width / this._source.tileSize) + 1, g = Math.ceil(a.height / this._source.tileSize) + 1, _ = Math.floor(u * g * (this._maxTileCacheZoomLevels === null ? o.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), w = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, _) : _;
            this._cache.setMaxSize(w);
          }
          handleWrapJump(a) {
            const u = Math.round((a - (this._prevLng === void 0 ? a : this._prevLng)) / 360);
            if (this._prevLng = a, u) {
              const g = {};
              for (const _ in this._tiles) {
                const w = this._tiles[_];
                w.tileID = w.tileID.unwrapTo(w.tileID.wrap + u), g[w.tileID.key] = w;
              }
              this._tiles = g;
              for (const _ in this._timers) clearTimeout(this._timers[_]), delete this._timers[_];
              for (const _ in this._tiles) this._setTileReloadTimer(_, this._tiles[_]);
            }
          }
          _updateCoveredAndRetainedTiles(a, u, g, _, w, C) {
            const R = {}, L = {}, k = Object.keys(a), V = M.now();
            for (const W of k) {
              const Z = a[W], ae = this._tiles[W];
              if (!ae || ae.fadeEndTime !== 0 && ae.fadeEndTime <= V) continue;
              const ue = this.findLoadedParent(Z, u), Ce = this.findLoadedSibling(Z), Se = ue || Ce || null;
              Se && (this._addTile(Se.tileID), R[Se.tileID.key] = Se.tileID), L[W] = Z;
            }
            this._retainLoadedChildren(L, _, g, a);
            for (const W in R) a[W] || (this._coveredTiles[W] = !0, a[W] = R[W]);
            if (C) {
              const W = {}, Z = {};
              for (const ae of w) this._tiles[ae.key].hasData() ? W[ae.key] = ae : Z[ae.key] = ae;
              for (const ae in Z) {
                const ue = Z[ae].children(this._source.maxzoom);
                this._tiles[ue[0].key] && this._tiles[ue[1].key] && this._tiles[ue[2].key] && this._tiles[ue[3].key] && (W[ue[0].key] = a[ue[0].key] = ue[0], W[ue[1].key] = a[ue[1].key] = ue[1], W[ue[2].key] = a[ue[2].key] = ue[2], W[ue[3].key] = a[ue[3].key] = ue[3], delete Z[ae]);
              }
              for (const ae in Z) {
                const ue = Z[ae], Ce = this.findLoadedParent(ue, this._source.minzoom), Se = this.findLoadedSibling(ue), Ie = Ce || Se || null;
                if (Ie) {
                  W[Ie.tileID.key] = a[Ie.tileID.key] = Ie.tileID;
                  for (const Le in W) W[Le].isChildOf(Ie.tileID) && delete W[Le];
                }
              }
              for (const ae in this._tiles) W[ae] || (this._coveredTiles[ae] = !0);
            }
          }
          update(a, u) {
            if (!this._sourceLoaded || this._paused) return;
            let g;
            this.transform = a, this.terrain = u, this.updateCacheSize(a), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? g = a.getVisibleUnwrappedCoordinates(this._source.tileID).map((V) => new o.X(V.canonical.z, V.wrap, V.canonical.z, V.canonical.x, V.canonical.y)) : (g = ve(a, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: u, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (g = g.filter((V) => this._source.hasTile(V)))) : g = [];
            const _ = Xi(a, this._source), w = Math.max(_ - se.maxOverzooming, this._source.minzoom), C = Math.max(_ + se.maxUnderzooming, this._source.minzoom);
            if (this.usedForTerrain) {
              const V = {};
              for (const W of g) if (W.canonical.z > this._source.minzoom) {
                const Z = W.scaledTo(W.canonical.z - 1);
                V[Z.key] = Z;
                const ae = W.scaledTo(Math.max(this._source.minzoom, Math.min(W.canonical.z, 5)));
                V[ae.key] = ae;
              }
              g = g.concat(Object.values(V));
            }
            const R = g.length === 0 && !this._updated && this._didEmitContent;
            this._updated = !0, R && this.fire(new o.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
            const L = this._updateRetainedTiles(g, _);
            pe(this._source.type) && this._updateCoveredAndRetainedTiles(L, w, C, _, g, u);
            for (const V in L) this._tiles[V].clearFadeHold();
            const k = o.ad(this._tiles, L);
            for (const V of k) {
              const W = this._tiles[V];
              W.hasSymbolBuckets && !W.holdingForFade() ? W.setHoldDuration(this.map._fadeDuration) : W.hasSymbolBuckets && !W.symbolFadeFinished() || this._removeTile(V);
            }
            this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
          }
          releaseSymbolFadeTiles() {
            for (const a in this._tiles) this._tiles[a].holdingForFade() && this._removeTile(a);
          }
          _updateRetainedTiles(a, u) {
            var g;
            const _ = {}, w = {}, C = Math.max(u - se.maxOverzooming, this._source.minzoom), R = Math.max(u + se.maxUnderzooming, this._source.minzoom), L = {};
            for (const k of a) {
              const V = this._addTile(k);
              _[k.key] = k, V.hasData() || u < this._source.maxzoom && (L[k.key] = k);
            }
            this._retainLoadedChildren(L, u, R, _);
            for (const k of a) {
              let V = this._tiles[k.key];
              if (V.hasData()) continue;
              if (u + 1 > this._source.maxzoom) {
                const Z = k.children(this._source.maxzoom)[0], ae = this.getTile(Z);
                if (ae && ae.hasData()) {
                  _[Z.key] = Z;
                  continue;
                }
              } else {
                const Z = k.children(this._source.maxzoom);
                if (_[Z[0].key] && _[Z[1].key] && _[Z[2].key] && _[Z[3].key]) continue;
              }
              let W = V.wasRequested();
              for (let Z = k.overscaledZ - 1; Z >= C; --Z) {
                const ae = k.scaledTo(Z);
                if (w[ae.key]) break;
                if (w[ae.key] = !0, V = this.getTile(ae), !V && W && (V = this._addTile(ae)), V) {
                  const ue = V.hasData();
                  if ((ue || !(!((g = this.map) === null || g === void 0) && g.cancelPendingTileRequestsWhileZooming) || W) && (_[ae.key] = ae), W = V.wasRequested(), ue) break;
                }
              }
            }
            return _;
          }
          _updateLoadedParentTileCache() {
            this._loadedParentTiles = {};
            for (const a in this._tiles) {
              const u = [];
              let g, _ = this._tiles[a].tileID;
              for (; _.overscaledZ > 0; ) {
                if (_.key in this._loadedParentTiles) {
                  g = this._loadedParentTiles[_.key];
                  break;
                }
                u.push(_.key);
                const w = _.scaledTo(_.overscaledZ - 1);
                if (g = this._getLoadedTile(w), g) break;
                _ = w;
              }
              for (const w of u) this._loadedParentTiles[w] = g;
            }
          }
          _updateLoadedSiblingTileCache() {
            this._loadedSiblingTiles = {};
            for (const a in this._tiles) {
              const u = this._tiles[a].tileID, g = this._getLoadedTile(u);
              this._loadedSiblingTiles[u.key] = g;
            }
          }
          _addTile(a) {
            let u = this._tiles[a.key];
            if (u) return u;
            u = this._cache.getAndRemove(a), u && (this._setTileReloadTimer(a.key, u), u.tileID = a, this._state.initializeTileState(u, this.map ? this.map.painter : null), this._cacheTimers[a.key] && (clearTimeout(this._cacheTimers[a.key]), delete this._cacheTimers[a.key], this._setTileReloadTimer(a.key, u)));
            const g = u;
            return u || (u = new Vr(a, this._source.tileSize * a.overscaleFactor()), this._loadTile(u, a.key, u.state)), u.uses++, this._tiles[a.key] = u, g || this._source.fire(new o.k("dataloading", { tile: u, coord: u.tileID, dataType: "source" })), u;
          }
          _setTileReloadTimer(a, u) {
            a in this._timers && (clearTimeout(this._timers[a]), delete this._timers[a]);
            const g = u.getExpiryTimeout();
            g && (this._timers[a] = setTimeout(() => {
              this._reloadTile(a, "expired"), delete this._timers[a];
            }, g));
          }
          _removeTile(a) {
            const u = this._tiles[a];
            u && (u.uses--, delete this._tiles[a], this._timers[a] && (clearTimeout(this._timers[a]), delete this._timers[a]), u.uses > 0 || (u.hasData() && u.state !== "reloading" ? this._cache.add(u.tileID, u, u.getExpiryTimeout()) : (u.aborted = !0, this._abortTile(u), this._unloadTile(u))));
          }
          _dataHandler(a) {
            const u = a.sourceDataType;
            a.dataType === "source" && u === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && a.dataType === "source" && u === "content" && (this.reload(a.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
          }
          clearTiles() {
            this._shouldReloadOnResume = !1, this._paused = !1;
            for (const a in this._tiles) this._removeTile(a);
            this._cache.reset();
          }
          tilesIn(a, u, g) {
            const _ = [], w = this.transform;
            if (!w) return _;
            const C = g ? w.getCameraQueryGeometry(a) : a, R = a.map((ue) => w.screenPointToMercatorCoordinate(ue, this.terrain)), L = C.map((ue) => w.screenPointToMercatorCoordinate(ue, this.terrain)), k = this.getIds();
            let V = 1 / 0, W = 1 / 0, Z = -1 / 0, ae = -1 / 0;
            for (const ue of L) V = Math.min(V, ue.x), W = Math.min(W, ue.y), Z = Math.max(Z, ue.x), ae = Math.max(ae, ue.y);
            for (let ue = 0; ue < k.length; ue++) {
              const Ce = this._tiles[k[ue]];
              if (Ce.holdingForFade()) continue;
              const Se = Ce.tileID, Ie = Math.pow(2, w.zoom - Ce.tileID.overscaledZ), Le = u * Ce.queryPadding * o.Y / Ce.tileSize / Ie, qe = [Se.getTilePoint(new o.Z(V, W)), Se.getTilePoint(new o.Z(Z, ae))];
              if (qe[0].x - Le < o.Y && qe[0].y - Le < o.Y && qe[1].x + Le >= 0 && qe[1].y + Le >= 0) {
                const $e = R.map((Ze) => Se.getTilePoint(Ze)), He = L.map((Ze) => Se.getTilePoint(Ze));
                _.push({ tile: Ce, tileID: Se, queryGeometry: $e, cameraQueryGeometry: He, scale: Ie });
              }
            }
            return _;
          }
          getVisibleCoordinates(a) {
            const u = this.getRenderableIds(a).map((g) => this._tiles[g].tileID);
            return this.transform && this.transform.populateCache(u), u;
          }
          hasTransition() {
            if (this._source.hasTransition()) return !0;
            if (pe(this._source.type)) {
              const a = M.now();
              for (const u in this._tiles) if (this._tiles[u].fadeEndTime >= a) return !0;
            }
            return !1;
          }
          setFeatureState(a, u, g) {
            this._state.updateState(a = a || "_geojsonTileLayer", u, g);
          }
          removeFeatureState(a, u, g) {
            this._state.removeFeatureState(a = a || "_geojsonTileLayer", u, g);
          }
          getFeatureState(a, u) {
            return this._state.getState(a = a || "_geojsonTileLayer", u);
          }
          setDependencies(a, u, g) {
            const _ = this._tiles[a];
            _ && _.setDependencies(u, g);
          }
          reloadTilesForDependencies(a, u) {
            for (const g in this._tiles) this._tiles[g].hasDependency(a, u) && this._reloadTile(g, "reloading");
            this._cache.filter((g) => !g.hasDependency(a, u));
          }
        }
        function de(v, a) {
          const u = Math.abs(2 * v.wrap) - +(v.wrap < 0), g = Math.abs(2 * a.wrap) - +(a.wrap < 0);
          return v.overscaledZ - a.overscaledZ || g - u || a.canonical.y - v.canonical.y || a.canonical.x - v.canonical.x;
        }
        function pe(v) {
          return v === "raster" || v === "image" || v === "video";
        }
        se.maxOverzooming = 10, se.maxUnderzooming = 3;
        class Oe {
          constructor(a, u) {
            this.reset(a, u);
          }
          reset(a, u) {
            this.points = a || [], this._distances = [0];
            for (let g = 1; g < this.points.length; g++) this._distances[g] = this._distances[g - 1] + this.points[g].dist(this.points[g - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(u || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }
          lerp(a) {
            if (this.points.length === 1) return this.points[0];
            a = o.ac(a, 0, 1);
            let u = 1, g = this._distances[u];
            const _ = a * this.paddedLength + this.padding;
            for (; g < _ && u < this._distances.length; ) g = this._distances[++u];
            const w = u - 1, C = this._distances[w], R = g - C, L = R > 0 ? (_ - C) / R : 0;
            return this.points[w].mult(1 - L).add(this.points[u].mult(L));
          }
        }
        function Ge(v, a) {
          let u = !0;
          return v === "always" || v !== "never" && a !== "never" || (u = !1), u;
        }
        class rt {
          constructor(a, u, g) {
            const _ = this.boxCells = [], w = this.circleCells = [];
            this.xCellCount = Math.ceil(a / g), this.yCellCount = Math.ceil(u / g);
            for (let C = 0; C < this.xCellCount * this.yCellCount; C++) _.push([]), w.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = a, this.height = u, this.xScale = this.xCellCount / a, this.yScale = this.yCellCount / u, this.boxUid = 0, this.circleUid = 0;
          }
          keysLength() {
            return this.boxKeys.length + this.circleKeys.length;
          }
          insert(a, u, g, _, w) {
            this._forEachCell(u, g, _, w, this._insertBoxCell, this.boxUid++), this.boxKeys.push(a), this.bboxes.push(u), this.bboxes.push(g), this.bboxes.push(_), this.bboxes.push(w);
          }
          insertCircle(a, u, g, _) {
            this._forEachCell(u - _, g - _, u + _, g + _, this._insertCircleCell, this.circleUid++), this.circleKeys.push(a), this.circles.push(u), this.circles.push(g), this.circles.push(_);
          }
          _insertBoxCell(a, u, g, _, w, C) {
            this.boxCells[w].push(C);
          }
          _insertCircleCell(a, u, g, _, w, C) {
            this.circleCells[w].push(C);
          }
          _query(a, u, g, _, w, C, R) {
            if (g < 0 || a > this.width || _ < 0 || u > this.height) return [];
            const L = [];
            if (a <= 0 && u <= 0 && this.width <= g && this.height <= _) {
              if (w) return [{ key: null, x1: a, y1: u, x2: g, y2: _ }];
              for (let k = 0; k < this.boxKeys.length; k++) L.push({ key: this.boxKeys[k], x1: this.bboxes[4 * k], y1: this.bboxes[4 * k + 1], x2: this.bboxes[4 * k + 2], y2: this.bboxes[4 * k + 3] });
              for (let k = 0; k < this.circleKeys.length; k++) {
                const V = this.circles[3 * k], W = this.circles[3 * k + 1], Z = this.circles[3 * k + 2];
                L.push({ key: this.circleKeys[k], x1: V - Z, y1: W - Z, x2: V + Z, y2: W + Z });
              }
            } else this._forEachCell(a, u, g, _, this._queryCell, L, { hitTest: w, overlapMode: C, seenUids: { box: {}, circle: {} } }, R);
            return L;
          }
          query(a, u, g, _) {
            return this._query(a, u, g, _, !1, null);
          }
          hitTest(a, u, g, _, w, C) {
            return this._query(a, u, g, _, !0, w, C).length > 0;
          }
          hitTestCircle(a, u, g, _, w) {
            const C = a - g, R = a + g, L = u - g, k = u + g;
            if (R < 0 || C > this.width || k < 0 || L > this.height) return !1;
            const V = [];
            return this._forEachCell(C, L, R, k, this._queryCellCircle, V, { hitTest: !0, overlapMode: _, circle: { x: a, y: u, radius: g }, seenUids: { box: {}, circle: {} } }, w), V.length > 0;
          }
          _queryCell(a, u, g, _, w, C, R, L) {
            const { seenUids: k, hitTest: V, overlapMode: W } = R, Z = this.boxCells[w];
            if (Z !== null) {
              const ue = this.bboxes;
              for (const Ce of Z) if (!k.box[Ce]) {
                k.box[Ce] = !0;
                const Se = 4 * Ce, Ie = this.boxKeys[Ce];
                if (a <= ue[Se + 2] && u <= ue[Se + 3] && g >= ue[Se + 0] && _ >= ue[Se + 1] && (!L || L(Ie)) && (!V || !Ge(W, Ie.overlapMode)) && (C.push({ key: Ie, x1: ue[Se], y1: ue[Se + 1], x2: ue[Se + 2], y2: ue[Se + 3] }), V)) return !0;
              }
            }
            const ae = this.circleCells[w];
            if (ae !== null) {
              const ue = this.circles;
              for (const Ce of ae) if (!k.circle[Ce]) {
                k.circle[Ce] = !0;
                const Se = 3 * Ce, Ie = this.circleKeys[Ce];
                if (this._circleAndRectCollide(ue[Se], ue[Se + 1], ue[Se + 2], a, u, g, _) && (!L || L(Ie)) && (!V || !Ge(W, Ie.overlapMode))) {
                  const Le = ue[Se], qe = ue[Se + 1], $e = ue[Se + 2];
                  if (C.push({ key: Ie, x1: Le - $e, y1: qe - $e, x2: Le + $e, y2: qe + $e }), V) return !0;
                }
              }
            }
            return !1;
          }
          _queryCellCircle(a, u, g, _, w, C, R, L) {
            const { circle: k, seenUids: V, overlapMode: W } = R, Z = this.boxCells[w];
            if (Z !== null) {
              const ue = this.bboxes;
              for (const Ce of Z) if (!V.box[Ce]) {
                V.box[Ce] = !0;
                const Se = 4 * Ce, Ie = this.boxKeys[Ce];
                if (this._circleAndRectCollide(k.x, k.y, k.radius, ue[Se + 0], ue[Se + 1], ue[Se + 2], ue[Se + 3]) && (!L || L(Ie)) && !Ge(W, Ie.overlapMode)) return C.push(!0), !0;
              }
            }
            const ae = this.circleCells[w];
            if (ae !== null) {
              const ue = this.circles;
              for (const Ce of ae) if (!V.circle[Ce]) {
                V.circle[Ce] = !0;
                const Se = 3 * Ce, Ie = this.circleKeys[Ce];
                if (this._circlesCollide(ue[Se], ue[Se + 1], ue[Se + 2], k.x, k.y, k.radius) && (!L || L(Ie)) && !Ge(W, Ie.overlapMode)) return C.push(!0), !0;
              }
            }
          }
          _forEachCell(a, u, g, _, w, C, R, L) {
            const k = this._convertToXCellCoord(a), V = this._convertToYCellCoord(u), W = this._convertToXCellCoord(g), Z = this._convertToYCellCoord(_);
            for (let ae = k; ae <= W; ae++) for (let ue = V; ue <= Z; ue++) if (w.call(this, a, u, g, _, this.xCellCount * ue + ae, C, R, L)) return;
          }
          _convertToXCellCoord(a) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(a * this.xScale)));
          }
          _convertToYCellCoord(a) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(a * this.yScale)));
          }
          _circlesCollide(a, u, g, _, w, C) {
            const R = _ - a, L = w - u, k = g + C;
            return k * k > R * R + L * L;
          }
          _circleAndRectCollide(a, u, g, _, w, C, R) {
            const L = (C - _) / 2, k = Math.abs(a - (_ + L));
            if (k > L + g) return !1;
            const V = (R - w) / 2, W = Math.abs(u - (w + V));
            if (W > V + g) return !1;
            if (k <= L || W <= V) return !0;
            const Z = k - L, ae = W - V;
            return Z * Z + ae * ae <= g * g;
          }
        }
        function gt(v, a, u) {
          const g = o.J();
          if (!v) {
            const { vecSouth: W, vecEast: Z } = lt(a), ae = m();
            ae[0] = Z[0], ae[1] = Z[1], ae[2] = W[0], ae[3] = W[1], _ = ae, (V = (C = (w = ae)[0]) * (k = w[3]) - (L = w[2]) * (R = w[1])) && (_[0] = k * (V = 1 / V), _[1] = -R * V, _[2] = -L * V, _[3] = C * V), g[0] = ae[0], g[1] = ae[1], g[4] = ae[2], g[5] = ae[3];
          }
          var _, w, C, R, L, k, V;
          return o.L(g, g, [1 / u, 1 / u, 1]), g;
        }
        function Ye(v, a, u, g) {
          if (v) {
            const _ = o.J();
            if (!a) {
              const { vecSouth: w, vecEast: C } = lt(u);
              _[0] = C[0], _[1] = C[1], _[4] = w[0], _[5] = w[1];
            }
            return o.L(_, _, [g, g, 1]), _;
          }
          return u.pixelsToClipSpaceMatrix;
        }
        function lt(v) {
          const a = Math.cos(v.rollInRadians), u = Math.sin(v.rollInRadians), g = Math.cos(v.pitchInRadians), _ = Math.cos(v.bearingInRadians), w = Math.sin(v.bearingInRadians), C = o.ai();
          C[0] = -_ * g * u - w * a, C[1] = -w * g * u + _ * a;
          const R = o.aj(C);
          R < 1e-9 ? o.ak(C) : o.al(C, C, 1 / R);
          const L = o.ai();
          L[0] = _ * g * a - w * u, L[1] = w * g * a + _ * u;
          const k = o.aj(L);
          return k < 1e-9 ? o.ak(L) : o.al(L, L, 1 / k), { vecEast: L, vecSouth: C };
        }
        function pt(v, a, u, g) {
          let _;
          g ? (_ = [v, a, g(v, a), 1], o.an(_, _, u)) : (_ = [v, a, 0, 1], kn(_, _, u));
          const w = _[3];
          return { point: new o.P(_[0] / w, _[1] / w), signedDistanceFromCamera: w, isOccluded: !1 };
        }
        function ct(v, a) {
          return 0.5 + v / a * 0.5;
        }
        function We(v, a) {
          return v.x >= -a[0] && v.x <= a[0] && v.y >= -a[1] && v.y <= a[1];
        }
        function or(v, a, u, g, _, w, C, R, L, k, V, W, Z) {
          const ae = u ? v.textSizeData : v.iconSizeData, ue = o.ae(ae, a.transform.zoom), Ce = [256 / a.width * 2 + 1, 256 / a.height * 2 + 1], Se = u ? v.text.dynamicLayoutVertexArray : v.icon.dynamicLayoutVertexArray;
          Se.clear();
          const Ie = v.lineVertexArray, Le = u ? v.text.placedSymbolArray : v.icon.placedSymbolArray, qe = a.transform.width / a.transform.height;
          let $e = !1;
          for (let He = 0; He < Le.length; He++) {
            const Ze = Le.get(He);
            if (Ze.hidden || Ze.writingMode === o.af.vertical && !$e) {
              Dn(Ze.numGlyphs, Se);
              continue;
            }
            $e = !1;
            const Je = new o.P(Ze.anchorX, Ze.anchorY), vt = { getElevation: Z, pitchedLabelPlaneMatrix: g, lineVertexArray: Ie, pitchWithMap: w, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: a.transform, tileAnchorPoint: Je, unwrappedTileID: L, width: k, height: V, translation: W }, _t = Hr(Ze.anchorX, Ze.anchorY, vt);
            if (!We(_t.point, Ce)) {
              Dn(Ze.numGlyphs, Se);
              continue;
            }
            const Rt = ct(a.transform.cameraToCenterDistance, _t.signedDistanceFromCamera), Ft = o.ag(ae, ue, Ze), Mt = w ? Ft * a.transform.getPitchedTextCorrection(Ze.anchorX, Ze.anchorY, L) / Rt : Ft * Rt, sr = Mr({ projectionContext: vt, pitchedLabelPlaneMatrixInverse: _, symbol: Ze, fontSize: Mt, flip: !1, keepUpright: C, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: Se, aspectRatio: qe, rotateToLine: R });
            $e = sr.useVertical, (sr.notEnoughRoom || $e || sr.needsFlipping && Mr({ projectionContext: vt, pitchedLabelPlaneMatrixInverse: _, symbol: Ze, fontSize: Mt, flip: !0, keepUpright: C, glyphOffsetArray: v.glyphOffsetArray, dynamicLayoutVertexArray: Se, aspectRatio: qe, rotateToLine: R }).notEnoughRoom) && Dn(Ze.numGlyphs, Se);
          }
          u ? v.text.dynamicLayoutVertexBuffer.updateData(Se) : v.icon.dynamicLayoutVertexBuffer.updateData(Se);
        }
        function Jt(v, a, u, g, _, w, C, R) {
          const L = w.glyphStartIndex + w.numGlyphs, k = w.lineStartIndex, V = w.lineStartIndex + w.lineLength, W = a.getoffsetX(w.glyphStartIndex), Z = a.getoffsetX(L - 1), ae = Sn(v * W, u, g, _, w.segment, k, V, R, C);
          if (!ae) return null;
          const ue = Sn(v * Z, u, g, _, w.segment, k, V, R, C);
          return ue ? R.projectionCache.anyProjectionOccluded ? null : { first: ae, last: ue } : null;
        }
        function Kt(v, a, u, g) {
          return v === o.af.horizontal && Math.abs(u.y - a.y) > Math.abs(u.x - a.x) * g ? { useVertical: !0 } : (v === o.af.vertical ? a.y < u.y : a.x > u.x) ? { needsFlipping: !0 } : null;
        }
        function Mr(v) {
          const { projectionContext: a, pitchedLabelPlaneMatrixInverse: u, symbol: g, fontSize: _, flip: w, keepUpright: C, glyphOffsetArray: R, dynamicLayoutVertexArray: L, aspectRatio: k, rotateToLine: V } = v, W = _ / 24, Z = g.lineOffsetX * W, ae = g.lineOffsetY * W;
          let ue;
          if (g.numGlyphs > 1) {
            const Ce = g.glyphStartIndex + g.numGlyphs, Se = g.lineStartIndex, Ie = g.lineStartIndex + g.lineLength, Le = Jt(W, R, Z, ae, w, g, V, a);
            if (!Le) return { notEnoughRoom: !0 };
            const qe = Lr(Le.first.point.x, Le.first.point.y, a, u), $e = Lr(Le.last.point.x, Le.last.point.y, a, u);
            if (C && !w) {
              const He = Kt(g.writingMode, qe, $e, k);
              if (He) return He;
            }
            ue = [Le.first];
            for (let He = g.glyphStartIndex + 1; He < Ce - 1; He++) ue.push(Sn(W * R.getoffsetX(He), Z, ae, w, g.segment, Se, Ie, a, V));
            ue.push(Le.last);
          } else {
            if (C && !w) {
              const Se = fr(a.tileAnchorPoint.x, a.tileAnchorPoint.y, a).point, Ie = g.lineStartIndex + g.segment + 1, Le = new o.P(a.lineVertexArray.getx(Ie), a.lineVertexArray.gety(Ie)), qe = fr(Le.x, Le.y, a), $e = qe.signedDistanceFromCamera > 0 ? qe.point : Bt(a.tileAnchorPoint, Le, Se, 1, a), He = Lr(Se.x, Se.y, a, u), Ze = Lr($e.x, $e.y, a, u), Je = Kt(g.writingMode, He, Ze, k);
              if (Je) return Je;
            }
            const Ce = Sn(W * R.getoffsetX(g.glyphStartIndex), Z, ae, w, g.segment, g.lineStartIndex, g.lineStartIndex + g.lineLength, a, V);
            if (!Ce || a.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
            ue = [Ce];
          }
          for (const Ce of ue) o.am(L, Ce.point, Ce.angle);
          return {};
        }
        function Bt(v, a, u, g, _) {
          const w = v.add(v.sub(a)._unit()), C = fr(w.x, w.y, _).point, R = u.sub(C);
          return u.add(R._mult(g / R.mag()));
        }
        function Qt(v, a, u) {
          const g = a.projectionCache;
          if (g.projections[v]) return g.projections[v];
          const _ = new o.P(a.lineVertexArray.getx(v), a.lineVertexArray.gety(v)), w = fr(_.x, _.y, a);
          if (w.signedDistanceFromCamera > 0) return g.projections[v] = w.point, g.anyProjectionOccluded = g.anyProjectionOccluded || w.isOccluded, w.point;
          const C = v - u.direction;
          return Bt(u.distanceFromAnchor === 0 ? a.tileAnchorPoint : new o.P(a.lineVertexArray.getx(C), a.lineVertexArray.gety(C)), _, u.previousVertex, u.absOffsetX - u.distanceFromAnchor + 1, a);
        }
        function fr(v, a, u) {
          const g = v + u.translation[0], _ = a + u.translation[1];
          let w;
          return u.pitchWithMap ? (w = pt(g, _, u.pitchedLabelPlaneMatrix, u.getElevation), w.isOccluded = !1) : (w = u.transform.projectTileCoordinates(g, _, u.unwrappedTileID, u.getElevation), w.point.x = (0.5 * w.point.x + 0.5) * u.width, w.point.y = (0.5 * -w.point.y + 0.5) * u.height), w;
        }
        function Lr(v, a, u, g) {
          if (u.pitchWithMap) {
            const _ = [v, a, 0, 1];
            return o.an(_, _, g), u.transform.projectTileCoordinates(_[0] / _[3], _[1] / _[3], u.unwrappedTileID, u.getElevation).point;
          }
          return { x: v / u.width * 2 - 1, y: a / u.height * 2 - 1 };
        }
        function Hr(v, a, u) {
          return u.transform.projectTileCoordinates(v, a, u.unwrappedTileID, u.getElevation);
        }
        function Or(v, a, u) {
          return v._unit()._perp()._mult(a * u);
        }
        function gr(v, a, u, g, _, w, C, R, L) {
          if (R.projectionCache.offsets[v]) return R.projectionCache.offsets[v];
          const k = u.add(a);
          if (v + L.direction < g || v + L.direction >= _) return R.projectionCache.offsets[v] = k, k;
          const V = Qt(v + L.direction, R, L), W = Or(V.sub(u), C, L.direction), Z = u.add(W), ae = V.add(W);
          return R.projectionCache.offsets[v] = o.ao(w, k, Z, ae) || k, R.projectionCache.offsets[v];
        }
        function Sn(v, a, u, g, _, w, C, R, L) {
          const k = g ? v - a : v + a;
          let V = k > 0 ? 1 : -1, W = 0;
          g && (V *= -1, W = Math.PI), V < 0 && (W += Math.PI);
          let Z, ae = V > 0 ? w + _ : w + _ + 1;
          R.projectionCache.cachedAnchorPoint ? Z = R.projectionCache.cachedAnchorPoint : (Z = fr(R.tileAnchorPoint.x, R.tileAnchorPoint.y, R).point, R.projectionCache.cachedAnchorPoint = Z);
          let ue, Ce, Se = Z, Ie = Z, Le = 0, qe = 0;
          const $e = Math.abs(k), He = [];
          let Ze;
          for (; Le + qe <= $e; ) {
            if (ae += V, ae < w || ae >= C) return null;
            Le += qe, Ie = Se, Ce = ue;
            const _t = { absOffsetX: $e, direction: V, distanceFromAnchor: Le, previousVertex: Ie };
            if (Se = Qt(ae, R, _t), u === 0) He.push(Ie), Ze = Se.sub(Ie);
            else {
              let Rt;
              const Ft = Se.sub(Ie);
              Rt = Ft.mag() === 0 ? Or(Qt(ae + V, R, _t).sub(Se), u, V) : Or(Ft, u, V), Ce || (Ce = Ie.add(Rt)), ue = gr(ae, Rt, Se, w, C, Ce, u, R, _t), He.push(Ce), Ze = ue.sub(Ce);
            }
            qe = Ze.mag();
          }
          const Je = Ze._mult(($e - Le) / qe)._add(Ce || Ie), vt = W + Math.atan2(Se.y - Ie.y, Se.x - Ie.x);
          return He.push(Je), { point: Je, angle: L ? vt : 0, path: He };
        }
        const Zi = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
        function Dn(v, a) {
          for (let u = 0; u < v; u++) {
            const g = a.length;
            a.resize(g + 4), a.float32.set(Zi, 3 * g);
          }
        }
        function kn(v, a, u) {
          const g = a[0], _ = a[1];
          return v[0] = u[0] * g + u[4] * _ + u[12], v[1] = u[1] * g + u[5] * _ + u[13], v[3] = u[3] * g + u[7] * _ + u[15], v;
        }
        const vn = 100;
        class Ai {
          constructor(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new rt(a.width + 200, a.height + 200, 25), g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new rt(a.width + 200, a.height + 200, 25);
            this.transform = a, this.grid = u, this.ignoredGrid = g, this.pitchFactor = Math.cos(a.pitch * Math.PI / 180) * a.cameraToCenterDistance, this.screenRightBoundary = a.width + vn, this.screenBottomBoundary = a.height + vn, this.gridRightBoundary = a.width + 200, this.gridBottomBoundary = a.height + 200, this.perspectiveRatioCutoff = 0.6;
          }
          placeCollisionBox(a, u, g, _, w, C, R, L, k, V, W, Z) {
            const ae = this.projectAndGetPerspectiveRatio(a.anchorPointX + L[0], a.anchorPointY + L[1], w, V, Z), ue = g * ae.perspectiveRatio;
            let Ce;
            if (C || R) Ce = this._projectCollisionBox(a, ue, _, w, C, R, L, ae, V, W, Z);
            else {
              const Ze = ae.x + (W ? W.x * ue : 0), Je = ae.y + (W ? W.y * ue : 0);
              Ce = { allPointsOccluded: !1, box: [Ze + a.x1 * ue, Je + a.y1 * ue, Ze + a.x2 * ue, Je + a.y2 * ue] };
            }
            const [Se, Ie, Le, qe] = Ce.box, $e = C ? Ce.allPointsOccluded : ae.isOccluded;
            let He = $e;
            return He || (He = ae.perspectiveRatio < this.perspectiveRatioCutoff), He || (He = !this.isInsideGrid(Se, Ie, Le, qe)), He || u !== "always" && this.grid.hitTest(Se, Ie, Le, qe, u, k) ? { box: [Se, Ie, Le, qe], placeable: !1, offscreen: !1, occluded: $e } : { box: [Se, Ie, Le, qe], placeable: !0, offscreen: this.isOffscreen(Se, Ie, Le, qe), occluded: $e };
          }
          placeCollisionCircles(a, u, g, _, w, C, R, L, k, V, W, Z, ae, ue) {
            const Ce = [], Se = new o.P(u.anchorX, u.anchorY), Ie = this.getPerspectiveRatio(Se.x, Se.y, C, ue), Le = (k ? w * this.transform.getPitchedTextCorrection(u.anchorX, u.anchorY, C) / Ie : w * Ie) / o.at, qe = { getElevation: ue, pitchedLabelPlaneMatrix: R, lineVertexArray: g, pitchWithMap: k, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: Se, unwrappedTileID: C, width: this.transform.width, height: this.transform.height, translation: ae }, $e = Jt(Le, _, u.lineOffsetX * Le, u.lineOffsetY * Le, !1, u, !1, qe);
            let He = !1, Ze = !1, Je = !0;
            if ($e) {
              const vt = 0.5 * W * Ie + Z, _t = new o.P(-100, -100), Rt = new o.P(this.screenRightBoundary, this.screenBottomBoundary), Ft = new Oe(), Mt = $e.first, sr = $e.last;
              let nr = [];
              for (let Gr = Mt.path.length - 1; Gr >= 1; Gr--) nr.push(Mt.path[Gr]);
              for (let Gr = 1; Gr < sr.path.length; Gr++) nr.push(sr.path[Gr]);
              const Gt = 2.5 * vt;
              if (k) {
                const Gr = this.projectPathToScreenSpace(nr, qe);
                nr = Gr.some((mn) => mn.signedDistanceFromCamera <= 0) ? [] : Gr.map((mn) => mn.point);
              }
              let dr = [];
              if (nr.length > 0) {
                const Gr = nr[0].clone(), mn = nr[0].clone();
                for (let Jn = 1; Jn < nr.length; Jn++) Gr.x = Math.min(Gr.x, nr[Jn].x), Gr.y = Math.min(Gr.y, nr[Jn].y), mn.x = Math.max(mn.x, nr[Jn].x), mn.y = Math.max(mn.y, nr[Jn].y);
                dr = Gr.x >= _t.x && mn.x <= Rt.x && Gr.y >= _t.y && mn.y <= Rt.y ? [nr] : mn.x < _t.x || Gr.x > Rt.x || mn.y < _t.y || Gr.y > Rt.y ? [] : o.ap([nr], _t.x, _t.y, Rt.x, Rt.y);
              }
              for (const Gr of dr) {
                Ft.reset(Gr, 0.25 * vt);
                let mn = 0;
                mn = Ft.length <= 0.5 * vt ? 1 : Math.ceil(Ft.paddedLength / Gt) + 1;
                for (let Jn = 0; Jn < mn; Jn++) {
                  const zn = Jn / Math.max(mn - 1, 1), Qn = Ft.lerp(zn), Tn = Qn.x + vn, On = Qn.y + vn;
                  Ce.push(Tn, On, vt, 0);
                  const Nn = Tn - vt, ys = On - vt, Oi = Tn + vt, ji = On + vt;
                  if (Je = Je && this.isOffscreen(Nn, ys, Oi, ji), Ze = Ze || this.isInsideGrid(Nn, ys, Oi, ji), a !== "always" && this.grid.hitTestCircle(Tn, On, vt, a, V) && (He = !0, !L)) return { circles: [], offscreen: !1, collisionDetected: He };
                }
              }
            }
            return { circles: !L && He || !Ze || Ie < this.perspectiveRatioCutoff ? [] : Ce, offscreen: Je, collisionDetected: He };
          }
          projectPathToScreenSpace(a, u) {
            const g = function(_, w) {
              const C = o.J();
              return o.ah(C, w.pitchedLabelPlaneMatrix), _.map((R) => {
                const L = pt(R.x, R.y, C, w.getElevation), k = w.transform.projectTileCoordinates(L.point.x, L.point.y, w.unwrappedTileID, w.getElevation);
                return k.point.x = (0.5 * k.point.x + 0.5) * w.width, k.point.y = (0.5 * -k.point.y + 0.5) * w.height, k;
              });
            }(a, u);
            return function(_) {
              let w = 0, C = 0, R = 0, L = 0;
              for (let k = 0; k < _.length; k++) _[k].isOccluded ? (R = k + 1, L = 0) : (L++, L > C && (C = L, w = R));
              return _.slice(w, w + C);
            }(g);
          }
          queryRenderedSymbols(a) {
            if (a.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
            const u = [];
            let g = 1 / 0, _ = 1 / 0, w = -1 / 0, C = -1 / 0;
            for (const V of a) {
              const W = new o.P(V.x + vn, V.y + vn);
              g = Math.min(g, W.x), _ = Math.min(_, W.y), w = Math.max(w, W.x), C = Math.max(C, W.y), u.push(W);
            }
            const R = this.grid.query(g, _, w, C).concat(this.ignoredGrid.query(g, _, w, C)), L = {}, k = {};
            for (const V of R) {
              const W = V.key;
              if (L[W.bucketInstanceId] === void 0 && (L[W.bucketInstanceId] = {}), L[W.bucketInstanceId][W.featureIndex]) continue;
              const Z = [new o.P(V.x1, V.y1), new o.P(V.x2, V.y1), new o.P(V.x2, V.y2), new o.P(V.x1, V.y2)];
              o.aq(u, Z) && (L[W.bucketInstanceId][W.featureIndex] = !0, k[W.bucketInstanceId] === void 0 && (k[W.bucketInstanceId] = []), k[W.bucketInstanceId].push(W.featureIndex));
            }
            return k;
          }
          insertCollisionBox(a, u, g, _, w, C) {
            (g ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: _, featureIndex: w, collisionGroupID: C, overlapMode: u }, a[0], a[1], a[2], a[3]);
          }
          insertCollisionCircles(a, u, g, _, w, C) {
            const R = g ? this.ignoredGrid : this.grid, L = { bucketInstanceId: _, featureIndex: w, collisionGroupID: C, overlapMode: u };
            for (let k = 0; k < a.length; k += 4) R.insertCircle(L, a[k], a[k + 1], a[k + 2]);
          }
          projectAndGetPerspectiveRatio(a, u, g, _, w) {
            if (w) {
              let C;
              _ ? (C = [a, u, _(a, u), 1], o.an(C, C, w)) : (C = [a, u, 0, 1], kn(C, C, w));
              const R = C[3];
              return { x: (C[0] / R + 1) / 2 * this.transform.width + vn, y: (-C[1] / R + 1) / 2 * this.transform.height + vn, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / R * 0.5, isOccluded: !1, signedDistanceFromCamera: R };
            }
            {
              const C = this.transform.projectTileCoordinates(a, u, g, _);
              return { x: (C.point.x + 1) / 2 * this.transform.width + vn, y: (1 - C.point.y) / 2 * this.transform.height + vn, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / C.signedDistanceFromCamera * 0.5, isOccluded: C.isOccluded, signedDistanceFromCamera: C.signedDistanceFromCamera };
            }
          }
          getPerspectiveRatio(a, u, g, _) {
            const w = this.transform.projectTileCoordinates(a, u, g, _);
            return 0.5 + this.transform.cameraToCenterDistance / w.signedDistanceFromCamera * 0.5;
          }
          isOffscreen(a, u, g, _) {
            return g < vn || a >= this.screenRightBoundary || _ < vn || u > this.screenBottomBoundary;
          }
          isInsideGrid(a, u, g, _) {
            return g >= 0 && a < this.gridRightBoundary && _ >= 0 && u < this.gridBottomBoundary;
          }
          getViewportMatrix() {
            const a = o.ar([]);
            return o.K(a, a, [-100, -100, 0]), a;
          }
          _projectCollisionBox(a, u, g, _, w, C, R, L, k, V, W) {
            let Z = 1, ae = 0, ue = 0, Ce = 1;
            const Se = a.anchorPointX + R[0], Ie = a.anchorPointY + R[1];
            if (C && !w) {
              const nr = this.projectAndGetPerspectiveRatio(Se + 1, Ie, _, k, W), Gt = nr.x - L.x, dr = Math.atan((nr.y - L.y) / Gt) + (Gt < 0 ? Math.PI : 0), Gr = Math.sin(dr), mn = Math.cos(dr);
              Z = mn, ae = Gr, ue = -Gr, Ce = mn;
            } else if (!C && w) {
              const nr = lt(this.transform);
              Z = nr.vecEast[0], ae = nr.vecEast[1], ue = nr.vecSouth[0], Ce = nr.vecSouth[1];
            }
            let Le = L.x, qe = L.y, $e = u;
            w && (Le = Se, qe = Ie, $e = Math.pow(2, -(this.transform.zoom - g.overscaledZ)), $e *= this.transform.getPitchedTextCorrection(Se, Ie, _), V || ($e *= o.ac(0.5 + L.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), V && (Le += Z * V.x * $e + ue * V.y * $e, qe += ae * V.x * $e + Ce * V.y * $e);
            const He = a.x1 * $e, Ze = a.x2 * $e, Je = (He + Ze) / 2, vt = a.y1 * $e, _t = a.y2 * $e, Rt = (vt + _t) / 2, Ft = [{ offsetX: He, offsetY: vt }, { offsetX: Je, offsetY: vt }, { offsetX: Ze, offsetY: vt }, { offsetX: Ze, offsetY: Rt }, { offsetX: Ze, offsetY: _t }, { offsetX: Je, offsetY: _t }, { offsetX: He, offsetY: _t }, { offsetX: He, offsetY: Rt }];
            let Mt = [];
            for (const { offsetX: nr, offsetY: Gt } of Ft) Mt.push(new o.P(Le + Z * nr + ue * Gt, qe + ae * nr + Ce * Gt));
            let sr = !1;
            if (w) {
              const nr = Mt.map((Gt) => this.projectAndGetPerspectiveRatio(Gt.x, Gt.y, _, k, W));
              sr = nr.some((Gt) => !Gt.isOccluded), Mt = nr.map((Gt) => new o.P(Gt.x, Gt.y));
            } else sr = !0;
            return { box: o.as(Mt), allPointsOccluded: !sr };
          }
        }
        class In {
          constructor(a, u, g, _) {
            this.opacity = a ? Math.max(0, Math.min(1, a.opacity + (a.placed ? u : -u))) : _ && g ? 1 : 0, this.placed = g;
          }
          isHidden() {
            return this.opacity === 0 && !this.placed;
          }
        }
        class aa {
          constructor(a, u, g, _, w) {
            this.text = new In(a ? a.text : null, u, g, w), this.icon = new In(a ? a.icon : null, u, _, w);
          }
          isHidden() {
            return this.text.isHidden() && this.icon.isHidden();
          }
        }
        class Wo {
          constructor(a, u, g) {
            this.text = a, this.icon = u, this.skipFade = g;
          }
        }
        class tl {
          constructor(a, u, g, _, w) {
            this.bucketInstanceId = a, this.featureIndex = u, this.sourceLayerIndex = g, this.bucketIndex = _, this.tileID = w;
          }
        }
        class wo {
          constructor(a) {
            this.crossSourceCollisions = a, this.maxGroupID = 0, this.collisionGroups = {};
          }
          get(a) {
            if (this.crossSourceCollisions) return { ID: 0, predicate: null };
            if (!this.collisionGroups[a]) {
              const u = ++this.maxGroupID;
              this.collisionGroups[a] = { ID: u, predicate: (g) => g.collisionGroupID === u };
            }
            return this.collisionGroups[a];
          }
        }
        function la(v, a, u, g, _) {
          const { horizontalAlign: w, verticalAlign: C } = o.az(v);
          return new o.P(-(w - 0.5) * a + g[0] * _, -(C - 0.5) * u + g[1] * _);
        }
        class ju {
          constructor(a, u, g, _, w) {
            this.transform = a.clone(), this.terrain = u, this.collisionIndex = new Ai(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = g, this.retainedQueryData = {}, this.collisionGroups = new wo(_), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = w, w && (w.prevPlacement = void 0), this.placedOrientations = {};
          }
          _getTerrainElevationFunc(a) {
            const u = this.terrain;
            return u ? (g, _) => u.getElevation(a, g, _) : null;
          }
          getBucketParts(a, u, g, _) {
            const w = g.getBucket(u), C = g.latestFeatureIndex;
            if (!w || !C || u.id !== w.layerIds[0]) return;
            const R = g.collisionBoxArray, L = w.layers[0].layout, k = w.layers[0].paint, V = Math.pow(2, this.transform.zoom - g.tileID.overscaledZ), W = g.tileSize / o.Y, Z = g.tileID.toUnwrapped(), ae = L.get("text-rotation-alignment") === "map", ue = o.au(g, 1, this.transform.zoom), Ce = o.av(this.collisionIndex.transform, g, k.get("text-translate"), k.get("text-translate-anchor")), Se = o.av(this.collisionIndex.transform, g, k.get("icon-translate"), k.get("icon-translate-anchor")), Ie = gt(ae, this.transform, ue);
            this.retainedQueryData[w.bucketInstanceId] = new tl(w.bucketInstanceId, C, w.sourceLayerIndex, w.index, g.tileID);
            const Le = { bucket: w, layout: L, translationText: Ce, translationIcon: Se, unwrappedTileID: Z, pitchedLabelPlaneMatrix: Ie, scale: V, textPixelRatio: W, holdingForFade: g.holdingForFade(), collisionBoxArray: R, partiallyEvaluatedTextSize: o.ae(w.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(w.sourceID) };
            if (_) for (const qe of w.sortKeyRanges) {
              const { sortKey: $e, symbolInstanceStart: He, symbolInstanceEnd: Ze } = qe;
              a.push({ sortKey: $e, symbolInstanceStart: He, symbolInstanceEnd: Ze, parameters: Le });
            }
            else a.push({ symbolInstanceStart: 0, symbolInstanceEnd: w.symbolInstances.length, parameters: Le });
          }
          attemptAnchorPlacement(a, u, g, _, w, C, R, L, k, V, W, Z, ae, ue, Ce, Se, Ie, Le, qe, $e) {
            const He = o.aw[a.textAnchor], Ze = [a.textOffset0, a.textOffset1], Je = la(He, g, _, Ze, w), vt = this.collisionIndex.placeCollisionBox(u, Z, L, k, V, R, C, Se, W.predicate, qe, Je, $e);
            if ((!Le || this.collisionIndex.placeCollisionBox(Le, Z, L, k, V, R, C, Ie, W.predicate, qe, Je, $e).placeable) && vt.placeable) {
              let _t;
              if (this.prevPlacement && this.prevPlacement.variableOffsets[ae.crossTileID] && this.prevPlacement.placements[ae.crossTileID] && this.prevPlacement.placements[ae.crossTileID].text && (_t = this.prevPlacement.variableOffsets[ae.crossTileID].anchor), ae.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              return this.variableOffsets[ae.crossTileID] = { textOffset: Ze, width: g, height: _, anchor: He, textBoxScale: w, prevAnchor: _t }, this.markUsedJustification(ue, He, ae, Ce), ue.allowVerticalPlacement && (this.markUsedOrientation(ue, Ce, ae), this.placedOrientations[ae.crossTileID] = Ce), { shift: Je, placedGlyphBoxes: vt };
            }
          }
          placeLayerBucketPart(a, u, g) {
            const { bucket: _, layout: w, translationText: C, translationIcon: R, unwrappedTileID: L, pitchedLabelPlaneMatrix: k, textPixelRatio: V, holdingForFade: W, collisionBoxArray: Z, partiallyEvaluatedTextSize: ae, collisionGroup: ue } = a.parameters, Ce = w.get("text-optional"), Se = w.get("icon-optional"), Ie = o.ax(w, "text-overlap", "text-allow-overlap"), Le = Ie === "always", qe = o.ax(w, "icon-overlap", "icon-allow-overlap"), $e = qe === "always", He = w.get("text-rotation-alignment") === "map", Ze = w.get("text-pitch-alignment") === "map", Je = w.get("icon-text-fit") !== "none", vt = w.get("symbol-z-order") === "viewport-y", _t = Le && ($e || !_.hasIconData() || Se), Rt = $e && (Le || !_.hasTextData() || Ce);
            !_.collisionArrays && Z && _.deserializeCollisionBoxes(Z);
            const Ft = this.retainedQueryData[_.bucketInstanceId].tileID, Mt = this._getTerrainElevationFunc(Ft), sr = this.transform.getFastPathSimpleProjectionMatrix(Ft), nr = (Gt, dr, Gr) => {
              var mn, Jn;
              if (u[Gt.crossTileID]) return;
              if (W) return void (this.placements[Gt.crossTileID] = new Wo(!1, !1, !1));
              let zn = !1, Qn = !1, Tn = !0, On = null, Nn = { box: null, placeable: !1, offscreen: null, occluded: !1 }, ys = { placeable: !1 }, Oi = null, ji = null, $i = null, ta = 0, yo = 0, Ni = 0;
              dr.textFeatureIndex ? ta = dr.textFeatureIndex : Gt.useRuntimeCollisionCircles && (ta = Gt.featureIndex), dr.verticalTextFeatureIndex && (yo = dr.verticalTextFeatureIndex);
              const Rs = dr.textBox;
              if (Rs) {
                const qs = (Xn) => {
                  let yi = o.af.horizontal;
                  if (_.allowVerticalPlacement && !Xn && this.prevPlacement) {
                    const ra = this.prevPlacement.placedOrientations[Gt.crossTileID];
                    ra && (this.placedOrientations[Gt.crossTileID] = ra, yi = ra, this.markUsedOrientation(_, yi, Gt));
                  }
                  return yi;
                }, Bo = (Xn, yi) => {
                  if (_.allowVerticalPlacement && Gt.numVerticalGlyphVertices > 0 && dr.verticalTextBox) {
                    for (const ra of _.writingModes) if (ra === o.af.vertical ? (Nn = yi(), ys = Nn) : Nn = Xn(), Nn && Nn.placeable) break;
                  } else Nn = Xn();
                }, ro = Gt.textAnchorOffsetStartIndex, Gs = Gt.textAnchorOffsetEndIndex;
                if (Gs === ro) {
                  const Xn = (yi, ra) => {
                    const Ci = this.collisionIndex.placeCollisionBox(yi, Ie, V, Ft, L, Ze, He, C, ue.predicate, Mt, void 0, sr);
                    return Ci && Ci.placeable && (this.markUsedOrientation(_, ra, Gt), this.placedOrientations[Gt.crossTileID] = ra), Ci;
                  };
                  Bo(() => Xn(Rs, o.af.horizontal), () => {
                    const yi = dr.verticalTextBox;
                    return _.allowVerticalPlacement && Gt.numVerticalGlyphVertices > 0 && yi ? Xn(yi, o.af.vertical) : { box: null, offscreen: null };
                  }), qs(Nn && Nn.placeable);
                } else {
                  let Xn = o.aw[(Jn = (mn = this.prevPlacement) === null || mn === void 0 ? void 0 : mn.variableOffsets[Gt.crossTileID]) === null || Jn === void 0 ? void 0 : Jn.anchor];
                  const yi = (Ci, jy, Dg) => {
                    const ip = Ci.x2 - Ci.x1, kg = Ci.y2 - Ci.y1, Mu = Gt.textBoxScale, Pu = Je && qe === "never" ? jy : null;
                    let Yc = null, Fg = Ie === "never" ? 1 : 2, jf = "never";
                    Xn && Fg++;
                    for (let sp = 0; sp < Fg; sp++) {
                      for (let op = ro; op < Gs; op++) {
                        const ap = _.textAnchorOffsets.get(op);
                        if (Xn && ap.textAnchor !== Xn) continue;
                        const lp = this.attemptAnchorPlacement(ap, Ci, ip, kg, Mu, He, Ze, V, Ft, L, ue, jf, Gt, _, Dg, C, R, Pu, Mt);
                        if (lp && (Yc = lp.placedGlyphBoxes, Yc && Yc.placeable)) return zn = !0, On = lp.shift, Yc;
                      }
                      Xn ? Xn = null : jf = Ie;
                    }
                    return g && !Yc && (Yc = { box: this.collisionIndex.placeCollisionBox(Rs, "always", V, Ft, L, Ze, He, C, ue.predicate, Mt, void 0, sr).box, offscreen: !1, placeable: !1, occluded: !1 }), Yc;
                  };
                  Bo(() => yi(Rs, dr.iconBox, o.af.horizontal), () => {
                    const Ci = dr.verticalTextBox;
                    return _.allowVerticalPlacement && (!Nn || !Nn.placeable) && Gt.numVerticalGlyphVertices > 0 && Ci ? yi(Ci, dr.verticalIconBox, o.af.vertical) : { box: null, occluded: !0, offscreen: null };
                  }), Nn && (zn = Nn.placeable, Tn = Nn.offscreen);
                  const ra = qs(Nn && Nn.placeable);
                  if (!zn && this.prevPlacement) {
                    const Ci = this.prevPlacement.variableOffsets[Gt.crossTileID];
                    Ci && (this.variableOffsets[Gt.crossTileID] = Ci, this.markUsedJustification(_, Ci.anchor, Gt, ra));
                  }
                }
              }
              if (Oi = Nn, zn = Oi && Oi.placeable, Tn = Oi && Oi.offscreen, Gt.useRuntimeCollisionCircles) {
                const qs = _.text.placedSymbolArray.get(Gt.centerJustifiedTextSymbolIndex), Bo = o.ag(_.textSizeData, ae, qs), ro = w.get("text-padding");
                ji = this.collisionIndex.placeCollisionCircles(Ie, qs, _.lineVertexArray, _.glyphOffsetArray, Bo, L, k, g, Ze, ue.predicate, Gt.collisionCircleDiameter, ro, C, Mt), ji.circles.length && ji.collisionDetected && !g && o.w("Collisions detected, but collision boxes are not shown"), zn = Le || ji.circles.length > 0 && !ji.collisionDetected, Tn = Tn && ji.offscreen;
              }
              if (dr.iconFeatureIndex && (Ni = dr.iconFeatureIndex), dr.iconBox) {
                const qs = (Bo) => this.collisionIndex.placeCollisionBox(Bo, qe, V, Ft, L, Ze, He, R, ue.predicate, Mt, Je && On ? On : void 0, sr);
                ys && ys.placeable && dr.verticalIconBox ? ($i = qs(dr.verticalIconBox), Qn = $i.placeable) : ($i = qs(dr.iconBox), Qn = $i.placeable), Tn = Tn && $i.offscreen;
              }
              const Ro = Ce || Gt.numHorizontalGlyphVertices === 0 && Gt.numVerticalGlyphVertices === 0, vl = Se || Gt.numIconVertices === 0;
              Ro || vl ? vl ? Ro || (Qn = Qn && zn) : zn = Qn && zn : Qn = zn = Qn && zn;
              const xl = Qn && $i.placeable;
              if (zn && Oi.placeable && this.collisionIndex.insertCollisionBox(Oi.box, Ie, w.get("text-ignore-placement"), _.bucketInstanceId, ys && ys.placeable && yo ? yo : ta, ue.ID), xl && this.collisionIndex.insertCollisionBox($i.box, qe, w.get("icon-ignore-placement"), _.bucketInstanceId, Ni, ue.ID), ji && zn && this.collisionIndex.insertCollisionCircles(ji.circles, Ie, w.get("text-ignore-placement"), _.bucketInstanceId, ta, ue.ID), g && this.storeCollisionData(_.bucketInstanceId, Gr, dr, Oi, $i, ji), Gt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
              if (_.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
              this.placements[Gt.crossTileID] = new Wo((zn || _t) && !(Oi != null && Oi.occluded), (Qn || Rt) && !($i != null && $i.occluded), Tn || _.justReloaded), u[Gt.crossTileID] = !0;
            };
            if (vt) {
              if (a.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
              const Gt = _.getSortedSymbolIndexes(-this.transform.bearingInRadians);
              for (let dr = Gt.length - 1; dr >= 0; --dr) {
                const Gr = Gt[dr];
                nr(_.symbolInstances.get(Gr), _.collisionArrays[Gr], Gr);
              }
            } else for (let Gt = a.symbolInstanceStart; Gt < a.symbolInstanceEnd; Gt++) nr(_.symbolInstances.get(Gt), _.collisionArrays[Gt], Gt);
            _.justReloaded = !1;
          }
          storeCollisionData(a, u, g, _, w, C) {
            if (g.textBox || g.iconBox) {
              let R, L;
              this.collisionBoxArrays.has(a) ? R = this.collisionBoxArrays.get(a) : (R = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(a, R)), R.has(u) ? L = R.get(u) : (L = { text: null, icon: null }, R.set(u, L)), g.textBox && (L.text = _.box), g.iconBox && (L.icon = w.box);
            }
            if (C) {
              let R = this.collisionCircleArrays[a];
              R === void 0 && (R = this.collisionCircleArrays[a] = []);
              for (let L = 0; L < C.circles.length; L += 4) R.push(C.circles[L + 0] - vn), R.push(C.circles[L + 1] - vn), R.push(C.circles[L + 2]), R.push(C.collisionDetected ? 1 : 0);
            }
          }
          markUsedJustification(a, u, g, _) {
            let w;
            w = _ === o.af.vertical ? g.verticalPlacedTextSymbolIndex : { left: g.leftJustifiedTextSymbolIndex, center: g.centerJustifiedTextSymbolIndex, right: g.rightJustifiedTextSymbolIndex }[o.ay(u)];
            const C = [g.leftJustifiedTextSymbolIndex, g.centerJustifiedTextSymbolIndex, g.rightJustifiedTextSymbolIndex, g.verticalPlacedTextSymbolIndex];
            for (const R of C) R >= 0 && (a.text.placedSymbolArray.get(R).crossTileID = w >= 0 && R !== w ? 0 : g.crossTileID);
          }
          markUsedOrientation(a, u, g) {
            const _ = u === o.af.horizontal || u === o.af.horizontalOnly ? u : 0, w = u === o.af.vertical ? u : 0, C = [g.leftJustifiedTextSymbolIndex, g.centerJustifiedTextSymbolIndex, g.rightJustifiedTextSymbolIndex];
            for (const R of C) a.text.placedSymbolArray.get(R).placedOrientation = _;
            g.verticalPlacedTextSymbolIndex && (a.text.placedSymbolArray.get(g.verticalPlacedTextSymbolIndex).placedOrientation = w);
          }
          commit(a) {
            this.commitTime = a, this.zoomAtLastRecencyCheck = this.transform.zoom;
            const u = this.prevPlacement;
            let g = !1;
            this.prevZoomAdjustment = u ? u.zoomAdjustment(this.transform.zoom) : 0;
            const _ = u ? u.symbolFadeChange(a) : 1, w = u ? u.opacities : {}, C = u ? u.variableOffsets : {}, R = u ? u.placedOrientations : {};
            for (const L in this.placements) {
              const k = this.placements[L], V = w[L];
              V ? (this.opacities[L] = new aa(V, _, k.text, k.icon), g = g || k.text !== V.text.placed || k.icon !== V.icon.placed) : (this.opacities[L] = new aa(null, _, k.text, k.icon, k.skipFade), g = g || k.text || k.icon);
            }
            for (const L in w) {
              const k = w[L];
              if (!this.opacities[L]) {
                const V = new aa(k, _, !1, !1);
                V.isHidden() || (this.opacities[L] = V, g = g || k.text.placed || k.icon.placed);
              }
            }
            for (const L in C) this.variableOffsets[L] || !this.opacities[L] || this.opacities[L].isHidden() || (this.variableOffsets[L] = C[L]);
            for (const L in R) this.placedOrientations[L] || !this.opacities[L] || this.opacities[L].isHidden() || (this.placedOrientations[L] = R[L]);
            if (u && u.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
            g ? this.lastPlacementChangeTime = a : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = u ? u.lastPlacementChangeTime : a);
          }
          updateLayerOpacities(a, u) {
            const g = {};
            for (const _ of u) {
              const w = _.getBucket(a);
              w && _.latestFeatureIndex && a.id === w.layerIds[0] && this.updateBucketOpacities(w, _.tileID, g, _.collisionBoxArray);
            }
          }
          updateBucketOpacities(a, u, g, _) {
            a.hasTextData() && (a.text.opacityVertexArray.clear(), a.text.hasVisibleVertices = !1), a.hasIconData() && (a.icon.opacityVertexArray.clear(), a.icon.hasVisibleVertices = !1), a.hasIconCollisionBoxData() && a.iconCollisionBox.collisionVertexArray.clear(), a.hasTextCollisionBoxData() && a.textCollisionBox.collisionVertexArray.clear();
            const w = a.layers[0], C = w.layout, R = new aa(null, 0, !1, !1, !0), L = C.get("text-allow-overlap"), k = C.get("icon-allow-overlap"), V = w._unevaluatedLayout.hasValue("text-variable-anchor") || w._unevaluatedLayout.hasValue("text-variable-anchor-offset"), W = C.get("text-rotation-alignment") === "map", Z = C.get("text-pitch-alignment") === "map", ae = C.get("icon-text-fit") !== "none", ue = new aa(null, 0, L && (k || !a.hasIconData() || C.get("icon-optional")), k && (L || !a.hasTextData() || C.get("text-optional")), !0);
            !a.collisionArrays && _ && (a.hasIconCollisionBoxData() || a.hasTextCollisionBoxData()) && a.deserializeCollisionBoxes(_);
            const Ce = (Ie, Le, qe) => {
              for (let $e = 0; $e < Le / 4; $e++) Ie.opacityVertexArray.emplaceBack(qe);
              Ie.hasVisibleVertices = Ie.hasVisibleVertices || qe !== Ia;
            }, Se = this.collisionBoxArrays.get(a.bucketInstanceId);
            for (let Ie = 0; Ie < a.symbolInstances.length; Ie++) {
              const Le = a.symbolInstances.get(Ie), { numHorizontalGlyphVertices: qe, numVerticalGlyphVertices: $e, crossTileID: He } = Le;
              let Ze = this.opacities[He];
              g[He] ? Ze = R : Ze || (Ze = ue, this.opacities[He] = Ze), g[He] = !0;
              const Je = Le.numIconVertices > 0, vt = this.placedOrientations[Le.crossTileID], _t = vt === o.af.vertical, Rt = vt === o.af.horizontal || vt === o.af.horizontalOnly;
              if (qe > 0 || $e > 0) {
                const Mt = rl(Ze.text);
                Ce(a.text, qe, _t ? Ia : Mt), Ce(a.text, $e, Rt ? Ia : Mt);
                const sr = Ze.text.isHidden();
                [Le.rightJustifiedTextSymbolIndex, Le.centerJustifiedTextSymbolIndex, Le.leftJustifiedTextSymbolIndex].forEach((dr) => {
                  dr >= 0 && (a.text.placedSymbolArray.get(dr).hidden = sr || _t ? 1 : 0);
                }), Le.verticalPlacedTextSymbolIndex >= 0 && (a.text.placedSymbolArray.get(Le.verticalPlacedTextSymbolIndex).hidden = sr || Rt ? 1 : 0);
                const nr = this.variableOffsets[Le.crossTileID];
                nr && this.markUsedJustification(a, nr.anchor, Le, vt);
                const Gt = this.placedOrientations[Le.crossTileID];
                Gt && (this.markUsedJustification(a, "left", Le, Gt), this.markUsedOrientation(a, Gt, Le));
              }
              if (Je) {
                const Mt = rl(Ze.icon), sr = !(ae && Le.verticalPlacedIconSymbolIndex && _t);
                Le.placedIconSymbolIndex >= 0 && (Ce(a.icon, Le.numIconVertices, sr ? Mt : Ia), a.icon.placedSymbolArray.get(Le.placedIconSymbolIndex).hidden = Ze.icon.isHidden()), Le.verticalPlacedIconSymbolIndex >= 0 && (Ce(a.icon, Le.numVerticalIconVertices, sr ? Ia : Mt), a.icon.placedSymbolArray.get(Le.verticalPlacedIconSymbolIndex).hidden = Ze.icon.isHidden());
              }
              const Ft = Se && Se.has(Ie) ? Se.get(Ie) : { text: null, icon: null };
              if (a.hasIconCollisionBoxData() || a.hasTextCollisionBoxData()) {
                const Mt = a.collisionArrays[Ie];
                if (Mt) {
                  let sr = new o.P(0, 0);
                  if (Mt.textBox || Mt.verticalTextBox) {
                    let nr = !0;
                    if (V) {
                      const Gt = this.variableOffsets[He];
                      Gt ? (sr = la(Gt.anchor, Gt.width, Gt.height, Gt.textOffset, Gt.textBoxScale), W && sr._rotate(Z ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : nr = !1;
                    }
                    if (Mt.textBox || Mt.verticalTextBox) {
                      let Gt;
                      Mt.textBox && (Gt = _t), Mt.verticalTextBox && (Gt = Rt), hu(a.textCollisionBox.collisionVertexArray, Ze.text.placed, !nr || Gt, Ft.text, sr.x, sr.y);
                    }
                  }
                  if (Mt.iconBox || Mt.verticalIconBox) {
                    const nr = !!(!Rt && Mt.verticalIconBox);
                    let Gt;
                    Mt.iconBox && (Gt = nr), Mt.verticalIconBox && (Gt = !nr), hu(a.iconCollisionBox.collisionVertexArray, Ze.icon.placed, Gt, Ft.icon, ae ? sr.x : 0, ae ? sr.y : 0);
                  }
                }
              }
            }
            if (a.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[a.bucketInstanceId] && (this.retainedQueryData[a.bucketInstanceId].featureSortOrder = a.featureSortOrder), a.hasTextData() && a.text.opacityVertexBuffer && a.text.opacityVertexBuffer.updateData(a.text.opacityVertexArray), a.hasIconData() && a.icon.opacityVertexBuffer && a.icon.opacityVertexBuffer.updateData(a.icon.opacityVertexArray), a.hasIconCollisionBoxData() && a.iconCollisionBox.collisionVertexBuffer && a.iconCollisionBox.collisionVertexBuffer.updateData(a.iconCollisionBox.collisionVertexArray), a.hasTextCollisionBoxData() && a.textCollisionBox.collisionVertexBuffer && a.textCollisionBox.collisionVertexBuffer.updateData(a.textCollisionBox.collisionVertexArray), a.text.opacityVertexArray.length !== a.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${a.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${a.text.layoutVertexArray.length}) / 4`);
            if (a.icon.opacityVertexArray.length !== a.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${a.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${a.icon.layoutVertexArray.length}) / 4`);
            a.bucketInstanceId in this.collisionCircleArrays && (a.collisionCircleArray = this.collisionCircleArrays[a.bucketInstanceId], delete this.collisionCircleArrays[a.bucketInstanceId]);
          }
          symbolFadeChange(a) {
            return this.fadeDuration === 0 ? 1 : (a - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }
          zoomAdjustment(a) {
            return Math.max(0, (this.transform.zoom - a) / 1.5);
          }
          hasTransitions(a) {
            return this.stale || a - this.lastPlacementChangeTime < this.fadeDuration;
          }
          stillRecent(a, u) {
            const g = this.zoomAtLastRecencyCheck === u ? 1 - this.zoomAdjustment(u) : 1;
            return this.zoomAtLastRecencyCheck = u, this.commitTime + this.fadeDuration * g > a;
          }
          setStale() {
            this.stale = !0;
          }
        }
        function hu(v, a, u, g, _, w) {
          g && g.length !== 0 || (g = [0, 0, 0, 0]);
          const C = g[0] - vn, R = g[1] - vn, L = g[2] - vn, k = g[3] - vn;
          v.emplaceBack(a ? 1 : 0, u ? 1 : 0, _ || 0, w || 0, C, R), v.emplaceBack(a ? 1 : 0, u ? 1 : 0, _ || 0, w || 0, L, R), v.emplaceBack(a ? 1 : 0, u ? 1 : 0, _ || 0, w || 0, L, k), v.emplaceBack(a ? 1 : 0, u ? 1 : 0, _ || 0, w || 0, C, k);
        }
        const Pl = Math.pow(2, 25), Ca = Math.pow(2, 24), Vu = Math.pow(2, 17), fu = Math.pow(2, 16), kh = Math.pow(2, 9), qu = Math.pow(2, 8), Gu = Math.pow(2, 1);
        function rl(v) {
          if (v.opacity === 0 && !v.placed) return 0;
          if (v.opacity === 1 && v.placed) return 4294967295;
          const a = v.placed ? 1 : 0, u = Math.floor(127 * v.opacity);
          return u * Pl + a * Ca + u * Vu + a * fu + u * kh + a * qu + u * Gu + a;
        }
        const Ia = 0;
        class pi {
          constructor(a) {
            this._sortAcrossTiles = a.layout.get("symbol-z-order") !== "viewport-y" && !a.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          }
          continuePlacement(a, u, g, _, w) {
            const C = this._bucketParts;
            for (; this._currentTileIndex < a.length; ) if (u.getBucketParts(C, _, a[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, w()) return !0;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, C.sort((R, L) => R.sortKey - L.sortKey)); this._currentPartIndex < C.length; ) if (u.placeLayerBucketPart(C[this._currentPartIndex], this._seenCrossTileIDs, g), this._currentPartIndex++, w()) return !0;
            return !1;
          }
        }
        class du {
          constructor(a, u, g, _, w, C, R, L) {
            this.placement = new ju(a, u, C, R, L), this._currentPlacementIndex = g.length - 1, this._forceFullPlacement = _, this._showCollisionBoxes = w, this._done = !1;
          }
          isDone() {
            return this._done;
          }
          continuePlacement(a, u, g) {
            const _ = M.now(), w = () => !this._forceFullPlacement && M.now() - _ > 2;
            for (; this._currentPlacementIndex >= 0; ) {
              const C = u[a[this._currentPlacementIndex]], R = this.placement.collisionIndex.transform.zoom;
              if (C.type === "symbol" && (!C.minzoom || C.minzoom <= R) && (!C.maxzoom || C.maxzoom > R)) {
                if (this._inProgressLayer || (this._inProgressLayer = new pi(C)), this._inProgressLayer.continuePlacement(g[C.source], this.placement, this._showCollisionBoxes, C, w)) return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = !0;
          }
          commit(a) {
            return this.placement.commit(a), this.placement;
          }
        }
        const ca = 512 / o.Y / 2;
        class Nc {
          constructor(a, u, g) {
            this.tileID = a, this.bucketInstanceId = g, this._symbolsByKey = {};
            const _ = /* @__PURE__ */ new Map();
            for (let w = 0; w < u.length; w++) {
              const C = u.get(w), R = C.key, L = _.get(R);
              L ? L.push(C) : _.set(R, [C]);
            }
            for (const [w, C] of _) {
              const R = { positions: C.map((L) => ({ x: Math.floor(L.anchorX * ca), y: Math.floor(L.anchorY * ca) })), crossTileIDs: C.map((L) => L.crossTileID) };
              if (R.positions.length > 128) {
                const L = new o.aA(R.positions.length, 16, Uint16Array);
                for (const { x: k, y: V } of R.positions) L.add(k, V);
                L.finish(), delete R.positions, R.index = L;
              }
              this._symbolsByKey[w] = R;
            }
          }
          getScaledCoordinates(a, u) {
            const { x: g, y: _, z: w } = this.tileID.canonical, { x: C, y: R, z: L } = u.canonical, k = ca / Math.pow(2, L - w), V = (R * o.Y + a.anchorY) * k, W = _ * o.Y * ca;
            return { x: Math.floor((C * o.Y + a.anchorX) * k - g * o.Y * ca), y: Math.floor(V - W) };
          }
          findMatches(a, u, g) {
            const _ = this.tileID.canonical.z < u.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - u.canonical.z);
            for (let w = 0; w < a.length; w++) {
              const C = a.get(w);
              if (C.crossTileID) continue;
              const R = this._symbolsByKey[C.key];
              if (!R) continue;
              const L = this.getScaledCoordinates(C, u);
              if (R.index) {
                const k = R.index.range(L.x - _, L.y - _, L.x + _, L.y + _).sort();
                for (const V of k) {
                  const W = R.crossTileIDs[V];
                  if (!g[W]) {
                    g[W] = !0, C.crossTileID = W;
                    break;
                  }
                }
              } else if (R.positions) for (let k = 0; k < R.positions.length; k++) {
                const V = R.positions[k], W = R.crossTileIDs[k];
                if (Math.abs(V.x - L.x) <= _ && Math.abs(V.y - L.y) <= _ && !g[W]) {
                  g[W] = !0, C.crossTileID = W;
                  break;
                }
              }
            }
          }
          getCrossTileIDsLists() {
            return Object.values(this._symbolsByKey).map((a) => {
              let { crossTileIDs: u } = a;
              return u;
            });
          }
        }
        class nl {
          constructor() {
            this.maxCrossTileID = 0;
          }
          generate() {
            return ++this.maxCrossTileID;
          }
        }
        class $u {
          constructor() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          }
          handleWrapJump(a) {
            const u = Math.round((a - this.lng) / 360);
            if (u !== 0) for (const g in this.indexes) {
              const _ = this.indexes[g], w = {};
              for (const C in _) {
                const R = _[C];
                R.tileID = R.tileID.unwrapTo(R.tileID.wrap + u), w[R.tileID.key] = R;
              }
              this.indexes[g] = w;
            }
            this.lng = a;
          }
          addBucket(a, u, g) {
            if (this.indexes[a.overscaledZ] && this.indexes[a.overscaledZ][a.key]) {
              if (this.indexes[a.overscaledZ][a.key].bucketInstanceId === u.bucketInstanceId) return !1;
              this.removeBucketCrossTileIDs(a.overscaledZ, this.indexes[a.overscaledZ][a.key]);
            }
            for (let w = 0; w < u.symbolInstances.length; w++) u.symbolInstances.get(w).crossTileID = 0;
            this.usedCrossTileIDs[a.overscaledZ] || (this.usedCrossTileIDs[a.overscaledZ] = {});
            const _ = this.usedCrossTileIDs[a.overscaledZ];
            for (const w in this.indexes) {
              const C = this.indexes[w];
              if (Number(w) > a.overscaledZ) for (const R in C) {
                const L = C[R];
                L.tileID.isChildOf(a) && L.findMatches(u.symbolInstances, a, _);
              }
              else {
                const R = C[a.scaledTo(Number(w)).key];
                R && R.findMatches(u.symbolInstances, a, _);
              }
            }
            for (let w = 0; w < u.symbolInstances.length; w++) {
              const C = u.symbolInstances.get(w);
              C.crossTileID || (C.crossTileID = g.generate(), _[C.crossTileID] = !0);
            }
            return this.indexes[a.overscaledZ] === void 0 && (this.indexes[a.overscaledZ] = {}), this.indexes[a.overscaledZ][a.key] = new Nc(a, u.symbolInstances, u.bucketInstanceId), !0;
          }
          removeBucketCrossTileIDs(a, u) {
            for (const g of u.getCrossTileIDsLists()) for (const _ of g) delete this.usedCrossTileIDs[a][_];
          }
          removeStaleBuckets(a) {
            let u = !1;
            for (const g in this.indexes) {
              const _ = this.indexes[g];
              for (const w in _) a[_[w].bucketInstanceId] || (this.removeBucketCrossTileIDs(g, _[w]), delete _[w], u = !0);
            }
            return u;
          }
        }
        class hs {
          constructor() {
            this.layerIndexes = {}, this.crossTileIDs = new nl(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          }
          addLayer(a, u, g) {
            let _ = this.layerIndexes[a.id];
            _ === void 0 && (_ = this.layerIndexes[a.id] = new $u());
            let w = !1;
            const C = {};
            _.handleWrapJump(g);
            for (const R of u) {
              const L = R.getBucket(a);
              L && a.id === L.layerIds[0] && (L.bucketInstanceId || (L.bucketInstanceId = ++this.maxBucketInstanceId), _.addBucket(R.tileID, L, this.crossTileIDs) && (w = !0), C[L.bucketInstanceId] = !0);
            }
            return _.removeStaleBuckets(C) && (w = !0), w;
          }
          pruneUnusedLayers(a) {
            const u = {};
            a.forEach((g) => {
              u[g] = !0;
            });
            for (const g in this.layerIndexes) u[g] || delete this.layerIndexes[g];
          }
        }
        var il = "void main() {fragColor=vec4(1.0);}";
        const gi = { prelude: Yr(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Yr("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Yr("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Yr(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Yr(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Yr(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Yr(il, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Yr(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Yr(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Yr("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Yr("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Yr("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Yr(il, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Yr(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Yr(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Yr(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Yr(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Yr(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Yr(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Yr(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));fragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Yr(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Yr(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Yr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Yr(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Yr(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Yr(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Yr(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Yr(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Yr(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Yr("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Yr("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Yr("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Yr("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Yr(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Yr("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
        function Yr(v, a) {
          const u = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, g = a.match(/in ([\w]+) ([\w]+)/g), _ = v.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), w = a.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), C = w ? w.concat(_) : _, R = {};
          return { fragmentSource: v = v.replace(u, (L, k, V, W, Z) => (R[Z] = !0, k === "define" ? `
#ifndef HAS_UNIFORM_u_${Z}
in ${V} ${W} ${Z};
#else
uniform ${V} ${W} u_${Z};
#endif
` : `
#ifdef HAS_UNIFORM_u_${Z}
    ${V} ${W} ${Z} = u_${Z};
#endif
`)), vertexSource: a = a.replace(u, (L, k, V, W, Z) => {
            const ae = W === "float" ? "vec2" : "vec4", ue = Z.match(/color/) ? "color" : ae;
            return R[Z] ? k === "define" ? `
#ifndef HAS_UNIFORM_u_${Z}
uniform lowp float u_${Z}_t;
in ${V} ${ae} a_${Z};
out ${V} ${W} ${Z};
#else
uniform ${V} ${W} u_${Z};
#endif
` : ue === "vec4" ? `
#ifndef HAS_UNIFORM_u_${Z}
    ${Z} = a_${Z};
#else
    ${V} ${W} ${Z} = u_${Z};
#endif
` : `
#ifndef HAS_UNIFORM_u_${Z}
    ${Z} = unpack_mix_${ue}(a_${Z}, u_${Z}_t);
#else
    ${V} ${W} ${Z} = u_${Z};
#endif
` : k === "define" ? `
#ifndef HAS_UNIFORM_u_${Z}
uniform lowp float u_${Z}_t;
in ${V} ${ae} a_${Z};
#else
uniform ${V} ${W} u_${Z};
#endif
` : ue === "vec4" ? `
#ifndef HAS_UNIFORM_u_${Z}
    ${V} ${W} ${Z} = a_${Z};
#else
    ${V} ${W} ${Z} = u_${Z};
#endif
` : `
#ifndef HAS_UNIFORM_u_${Z}
    ${V} ${W} ${Z} = unpack_mix_${ue}(a_${Z}, u_${Z}_t);
#else
    ${V} ${W} ${Z} = u_${Z};
#endif
`;
          }), staticAttributes: g, staticUniforms: C };
        }
        class co {
          constructor(a, u, g) {
            this.vertexBuffer = a, this.indexBuffer = u, this.segments = g;
          }
          destroy() {
            this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
          }
        }
        var nn = o.aB([{ name: "a_pos", type: "Int16", components: 2 }]);
        const Rl = "#define PROJECTION_MERCATOR", Hu = "mercator";
        class sl {
          constructor() {
            this._cachedMesh = null;
          }
          get name() {
            return "mercator";
          }
          get useSubdivision() {
            return !1;
          }
          get shaderVariantName() {
            return Hu;
          }
          get shaderDefine() {
            return Rl;
          }
          get shaderPreludeCode() {
            return gi.projectionMercator;
          }
          get vertexShaderPreludeCode() {
            return gi.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return o.aC.noSubdivision;
          }
          get useGlobeControls() {
            return !1;
          }
          get transitionState() {
            return 0;
          }
          get latitudeErrorCorrectionRadians() {
            return 0;
          }
          destroy() {
          }
          updateGPUdependent(a) {
          }
          getMeshFromTileID(a, u, g, _, w) {
            if (this._cachedMesh) return this._cachedMesh;
            const C = new o.aD();
            C.emplaceBack(0, 0), C.emplaceBack(o.Y, 0), C.emplaceBack(0, o.Y), C.emplaceBack(o.Y, o.Y);
            const R = a.createVertexBuffer(C, nn.members), L = o.aE.simpleSegment(0, 0, 4, 2), k = new o.aF();
            k.emplaceBack(1, 0, 2), k.emplaceBack(1, 2, 3);
            const V = a.createIndexBuffer(k);
            return this._cachedMesh = new co(R, V, L), this._cachedMesh;
          }
          recalculate() {
          }
          hasTransition() {
            return !1;
          }
          setErrorQueryLatitudeDegrees(a) {
          }
        }
        function oi(v, a) {
          const u = o.ac(a.lat, -85.051129, o.aH);
          return new o.P(o.S(a.lng) * v, o.Q(u) * v);
        }
        function mi(v, a) {
          return new o.Z(a.x / v, a.y / v).toLngLat();
        }
        function Kn(v) {
          return v.cameraToCenterDistance * Math.min(0.85 * Math.tan(o.ab(90 - v.pitch)), Math.tan(o.ab(89.25 - v.pitch)));
        }
        function pu(v, a) {
          const u = v.canonical, g = a / o.aG(u.z), _ = u.x + Math.pow(2, u.z) * v.wrap, w = o.ar(new Float64Array(16));
          return o.K(w, w, [_ * g, u.y * g, 0]), o.L(w, w, [g / o.Y, g / o.Y, 1]), w;
        }
        function Yi(v, a, u, g, _) {
          const w = o.Z.fromLngLat(v, a), C = _ * o.aI(1, v.lat), R = C * Math.cos(o.ab(u)), L = Math.sqrt(C * C - R * R), k = L * Math.sin(o.ab(-g)), V = L * Math.cos(o.ab(-g));
          return new o.Z(w.x + k, w.y + V, w.z + R);
        }
        class ai {
          constructor() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            if (isNaN(a) || a < 0 || isNaN(u) || u < 0 || isNaN(g) || g < 0 || isNaN(_) || _ < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = a, this.bottom = u, this.left = g, this.right = _;
          }
          interpolate(a, u, g) {
            return u.top != null && a.top != null && (this.top = o.z.number(a.top, u.top, g)), u.bottom != null && a.bottom != null && (this.bottom = o.z.number(a.bottom, u.bottom, g)), u.left != null && a.left != null && (this.left = o.z.number(a.left, u.left, g)), u.right != null && a.right != null && (this.right = o.z.number(a.right, u.right, g)), this;
          }
          getCenter(a, u) {
            const g = o.ac((this.left + a - this.right) / 2, 0, a), _ = o.ac((this.top + u - this.bottom) / 2, 0, u);
            return new o.P(g, _);
          }
          equals(a) {
            return this.top === a.top && this.bottom === a.bottom && this.left === a.left && this.right === a.right;
          }
          clone() {
            return new ai(this.top, this.bottom, this.left, this.right);
          }
          toJSON() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          }
        }
        function Mi(v, a) {
          if (!v.renderWorldCopies || v.lngRange) return;
          const u = a.lng - v.center.lng;
          a.lng += u > 180 ? -360 : u < -180 ? 360 : 0;
        }
        function ol(v) {
          return Math.max(0, Math.floor(v));
        }
        class ua {
          constructor(a, u, g, _, w, C) {
            this._callbacks = a, this._tileSize = 512, this._renderWorldCopies = C === void 0 || !!C, this._minZoom = u || 0, this._maxZoom = g || 22, this._minPitch = _ ?? 0, this._maxPitch = w ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new o.O(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = ol(this._zoom), this._scale = o.aG(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new ai(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
          }
          apply(a, u, g) {
            this._latRange = a.latRange, this._lngRange = a.lngRange, this._width = a.width, this._height = a.height, this._center = a.center, this._elevation = a.elevation, this._minElevationForCurrentTile = a.minElevationForCurrentTile, this._zoom = a.zoom, this._tileZoom = ol(this._zoom), this._scale = o.aG(this._zoom), this._bearingInRadians = a.bearingInRadians, this._fovInRadians = a.fovInRadians, this._pitchInRadians = a.pitchInRadians, this._rollInRadians = a.rollInRadians, this._unmodified = a.unmodified, this._edgeInsets = new ai(a.padding.top, a.padding.bottom, a.padding.left, a.padding.right), this._minZoom = a.minZoom, this._maxZoom = a.maxZoom, this._minPitch = a.minPitch, this._maxPitch = a.maxPitch, this._renderWorldCopies = a.renderWorldCopies, this._cameraToCenterDistance = a.cameraToCenterDistance, this._nearZ = a.nearZ, this._farZ = a.farZ, this._autoCalculateNearFarZ = !g && a.autoCalculateNearFarZ, u && this._constrain(), this._calcMatrices();
          }
          get pixelsToClipSpaceMatrix() {
            return this._pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._clipSpaceToPixelsMatrix;
          }
          get minElevationForCurrentTile() {
            return this._minElevationForCurrentTile;
          }
          setMinElevationForCurrentTile(a) {
            this._minElevationForCurrentTile = a;
          }
          get tileSize() {
            return this._tileSize;
          }
          get tileZoom() {
            return this._tileZoom;
          }
          get scale() {
            return this._scale;
          }
          get width() {
            return this._width;
          }
          get height() {
            return this._height;
          }
          get bearingInRadians() {
            return this._bearingInRadians;
          }
          get lngRange() {
            return this._lngRange;
          }
          get latRange() {
            return this._latRange;
          }
          get pixelsToGLUnits() {
            return this._pixelsToGLUnits;
          }
          get minZoom() {
            return this._minZoom;
          }
          setMinZoom(a) {
            this._minZoom !== a && (this._minZoom = a, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get maxZoom() {
            return this._maxZoom;
          }
          setMaxZoom(a) {
            this._maxZoom !== a && (this._maxZoom = a, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
          }
          get minPitch() {
            return this._minPitch;
          }
          setMinPitch(a) {
            this._minPitch !== a && (this._minPitch = a, this.setPitch(Math.max(this.pitch, a)));
          }
          get maxPitch() {
            return this._maxPitch;
          }
          setMaxPitch(a) {
            this._maxPitch !== a && (this._maxPitch = a, this.setPitch(Math.min(this.pitch, a)));
          }
          get renderWorldCopies() {
            return this._renderWorldCopies;
          }
          setRenderWorldCopies(a) {
            a === void 0 ? a = !0 : a === null && (a = !1), this._renderWorldCopies = a;
          }
          get worldSize() {
            return this._tileSize * this._scale;
          }
          get centerOffset() {
            return this.centerPoint._sub(this.size._div(2));
          }
          get size() {
            return new o.P(this._width, this._height);
          }
          get bearing() {
            return this._bearingInRadians / Math.PI * 180;
          }
          setBearing(a) {
            const u = o.aJ(a, -180, 180) * Math.PI / 180;
            var g, _, w, C, R, L, k, V, W;
            this._bearingInRadians !== u && (this._unmodified = !1, this._bearingInRadians = u, this._calcMatrices(), this._rotationMatrix = m(), g = this._rotationMatrix, w = -this._bearingInRadians, C = (_ = this._rotationMatrix)[0], R = _[1], L = _[2], k = _[3], V = Math.sin(w), W = Math.cos(w), g[0] = C * W + L * V, g[1] = R * W + k * V, g[2] = C * -V + L * W, g[3] = R * -V + k * W);
          }
          get rotationMatrix() {
            return this._rotationMatrix;
          }
          get pitchInRadians() {
            return this._pitchInRadians;
          }
          get pitch() {
            return this._pitchInRadians / Math.PI * 180;
          }
          setPitch(a) {
            const u = o.ac(a, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitchInRadians !== u && (this._unmodified = !1, this._pitchInRadians = u, this._calcMatrices());
          }
          get rollInRadians() {
            return this._rollInRadians;
          }
          get roll() {
            return this._rollInRadians / Math.PI * 180;
          }
          setRoll(a) {
            const u = a / 180 * Math.PI;
            this._rollInRadians !== u && (this._unmodified = !1, this._rollInRadians = u, this._calcMatrices());
          }
          get fovInRadians() {
            return this._fovInRadians;
          }
          get fov() {
            return o.aK(this._fovInRadians);
          }
          setFov(a) {
            a = o.ac(a, 0.1, 150), this.fov !== a && (this._unmodified = !1, this._fovInRadians = o.ab(a), this._calcMatrices());
          }
          get zoom() {
            return this._zoom;
          }
          setZoom(a) {
            const u = this.getConstrained(this._center, a).zoom;
            this._zoom !== u && (this._unmodified = !1, this._zoom = u, this._tileZoom = Math.max(0, Math.floor(u)), this._scale = o.aG(u), this._constrain(), this._calcMatrices());
          }
          get center() {
            return this._center;
          }
          setCenter(a) {
            a.lat === this._center.lat && a.lng === this._center.lng || (this._unmodified = !1, this._center = a, this._constrain(), this._calcMatrices());
          }
          get elevation() {
            return this._elevation;
          }
          setElevation(a) {
            a !== this._elevation && (this._elevation = a, this._constrain(), this._calcMatrices());
          }
          get padding() {
            return this._edgeInsets.toJSON();
          }
          setPadding(a) {
            this._edgeInsets.equals(a) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, a, 1), this._calcMatrices());
          }
          get centerPoint() {
            return this._edgeInsets.getCenter(this._width, this._height);
          }
          get pixelsPerMeter() {
            return this._pixelPerMeter;
          }
          get unmodified() {
            return this._unmodified;
          }
          get cameraToCenterDistance() {
            return this._cameraToCenterDistance;
          }
          get nearZ() {
            return this._nearZ;
          }
          get farZ() {
            return this._farZ;
          }
          get autoCalculateNearFarZ() {
            return this._autoCalculateNearFarZ;
          }
          overrideNearFarZ(a, u) {
            this._autoCalculateNearFarZ = !1, this._nearZ = a, this._farZ = u, this._calcMatrices();
          }
          clearNearFarZOverride() {
            this._autoCalculateNearFarZ = !0, this._calcMatrices();
          }
          isPaddingEqual(a) {
            return this._edgeInsets.equals(a);
          }
          interpolatePadding(a, u, g) {
            this._unmodified = !1, this._edgeInsets.interpolate(a, u, g), this._constrain(), this._calcMatrices();
          }
          resize(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            this._width = a, this._height = u, g && this._constrain(), this._calcMatrices();
          }
          getMaxBounds() {
            return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new Cr([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
          }
          setMaxBounds(a) {
            a ? (this._lngRange = [a.getWest(), a.getEast()], this._latRange = [a.getSouth(), a.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-85.051129, o.aH]);
          }
          getConstrained(a, u) {
            return this._callbacks.getConstrained(a, u);
          }
          getCameraQueryGeometry(a, u) {
            if (u.length === 1) return [u[0], a];
            {
              let g = a.x, _ = a.y, w = a.x, C = a.y;
              for (const R of u) g = Math.min(g, R.x), _ = Math.min(_, R.y), w = Math.max(w, R.x), C = Math.max(C, R.y);
              return [new o.P(g, _), new o.P(w, _), new o.P(w, C), new o.P(g, C), new o.P(g, _)];
            }
          }
          _constrain() {
            if (!this.center || !this._width || !this._height || this._constraining) return;
            this._constraining = !0;
            const a = this._unmodified, { center: u, zoom: g } = this.getConstrained(this.center, this.zoom);
            this.setCenter(u), this.setZoom(g), this._unmodified = a, this._constraining = !1;
          }
          _calcMatrices() {
            if (this._width && this._height) {
              this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
              let a = o.ar(new Float64Array(16));
              o.L(a, a, [this._width / 2, -this._height / 2, 1]), o.K(a, a, [1, -1, 0]), this._clipSpaceToPixelsMatrix = a, a = o.ar(new Float64Array(16)), o.L(a, a, [1, -1, 1]), o.K(a, a, [-1, -1, 0]), o.L(a, a, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = a, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
            }
            this._callbacks.calcMatrices();
          }
          calculateCenterFromCameraLngLatAlt(a, u, g, _) {
            const w = g !== void 0 ? g : this.bearing, C = _ = _ !== void 0 ? _ : this.pitch, R = o.Z.fromLngLat(a, u), L = -Math.cos(o.ab(C)), k = Math.sin(o.ab(C)), V = k * Math.sin(o.ab(w)), W = -k * Math.cos(o.ab(w));
            let Z = this.elevation;
            const ae = u - Z;
            let ue;
            L * ae >= 0 || Math.abs(L) < 0.1 ? (ue = 1e4, Z = u + ue * L) : ue = -ae / L;
            let Ce, Se, Ie = o.aL(1, R.y), Le = 0;
            do {
              if (Le += 1, Le > 10) break;
              Se = ue / Ie, Ce = new o.Z(R.x + V * Se, R.y + W * Se), Ie = 1 / Ce.meterInMercatorCoordinateUnits();
            } while (Math.abs(ue - Se * Ie) > 1e-12);
            return { center: Ce.toLngLat(), elevation: Z, zoom: o.a9(this.height / 2 / Math.tan(this.fovInRadians / 2) / Se / this.tileSize) };
          }
          recalculateZoomAndCenter(a) {
            if (this.elevation - a == 0) return;
            const u = o.aI(1, this.center.lat) * this.worldSize, g = this.cameraToCenterDistance / u, _ = o.Z.fromLngLat(this.center, this.elevation), w = Yi(this.center, this.elevation, this.pitch, this.bearing, g);
            this._elevation = a;
            const C = this.calculateCenterFromCameraLngLatAlt(w.toLngLat(), o.aL(w.z, _.y), this.bearing, this.pitch);
            this._elevation = C.elevation, this._center = C.center, this.setZoom(C.zoom);
          }
          getCameraPoint() {
            const a = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new o.P(a * Math.sin(this.rollInRadians), a * Math.cos(this.rollInRadians)));
          }
          getCameraAltitude() {
            return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
          }
          getCameraLngLat() {
            const a = o.aI(1, this.center.lat) * this.worldSize;
            return Yi(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / a).toLngLat();
          }
          getMercatorTileCoordinates(a) {
            if (!a) return [0, 0, 1, 1];
            const u = a.canonical.z >= 0 ? 1 << a.canonical.z : Math.pow(2, a.canonical.z);
            return [a.canonical.x / u, a.canonical.y / u, 1 / u / o.Y, 1 / u / o.Y];
          }
        }
        class an {
          constructor(a, u) {
            this.min = a, this.max = u, this.center = o.aM([], o.aN([], this.min, this.max), 0.5);
          }
          quadrant(a) {
            const u = [a % 2 == 0, a < 2], g = o.aO(this.min), _ = o.aO(this.max);
            for (let w = 0; w < u.length; w++) g[w] = u[w] ? this.min[w] : this.center[w], _[w] = u[w] ? this.center[w] : this.max[w];
            return _[2] = this.max[2], new an(g, _);
          }
          distanceX(a) {
            return Math.max(Math.min(this.max[0], a[0]), this.min[0]) - a[0];
          }
          distanceY(a) {
            return Math.max(Math.min(this.max[1], a[1]), this.min[1]) - a[1];
          }
          intersectsFrustum(a) {
            let u = !0;
            for (let g = 0; g < a.planes.length; g++) {
              const _ = this.intersectsPlane(a.planes[g]);
              if (_ === 0) return 0;
              _ === 1 && (u = !1);
            }
            return u ? 2 : a.aabb.min[0] > this.max[0] || a.aabb.min[1] > this.max[1] || a.aabb.min[2] > this.max[2] || a.aabb.max[0] < this.min[0] || a.aabb.max[1] < this.min[1] || a.aabb.max[2] < this.min[2] ? 0 : 1;
          }
          intersectsPlane(a) {
            let u = a[3], g = a[3];
            for (let _ = 0; _ < 3; _++) a[_] > 0 ? (u += a[_] * this.min[_], g += a[_] * this.max[_]) : (g += a[_] * this.min[_], u += a[_] * this.max[_]);
            return u >= 0 ? 2 : g < 0 ? 0 : 1;
          }
        }
        class Bl {
          distanceToTile2d(a, u, g, _) {
            const w = _.distanceX([a, u]), C = _.distanceY([a, u]);
            return Math.hypot(w, C);
          }
          getWrap(a, u, g) {
            return g;
          }
          getTileAABB(a, u, g, _) {
            var w, C;
            let R = g, L = g;
            if (_.terrain) {
              const V = new o.X(a.z, u, a.z, a.x, a.y), W = _.terrain.getMinMaxElevation(V);
              R = (w = W.minElevation) !== null && w !== void 0 ? w : g, L = (C = W.maxElevation) !== null && C !== void 0 ? C : g;
            }
            const k = 1 << a.z;
            return new an([u + a.x / k, a.y / k, R], [u + (a.x + 1) / k, (a.y + 1) / k, L]);
          }
          allowVariableZoom(a, u) {
            const g = a.fov * (Math.abs(Math.cos(a.rollInRadians)) * a.height + Math.abs(Math.sin(a.rollInRadians)) * a.width) / a.height, _ = o.ac(78.5 - g / 2, 0, 60);
            return !!u.terrain || a.pitch > _;
          }
          allowWorldCopies() {
            return !0;
          }
          recalculateCache() {
          }
        }
        class uo {
          constructor(a, u, g) {
            this.points = a, this.planes = u, this.aabb = g;
          }
          static fromInvProjectionMatrix(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            const _ = Math.pow(2, g), w = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((k) => {
              const V = 1 / (k = o.an([], k, a))[3] / u * _;
              return o.aP(k, k, [V, V, 1 / k[3], V]);
            }), C = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((k) => {
              const V = o.aQ([], w[k[0]], w[k[1]]), W = o.aQ([], w[k[2]], w[k[1]]), Z = o.aR([], o.aS([], V, W)), ae = -o.aT(Z, w[k[1]]);
              return Z.concat(ae);
            }), R = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], L = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
            for (const k of w) for (let V = 0; V < 3; V++) R[V] = Math.min(R[V], k[V]), L[V] = Math.max(L[V], k[V]);
            return new uo(w, C, new an(R, L));
          }
        }
        class qr {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(a) {
            this._helper.setMinZoom(a);
          }
          setMaxZoom(a) {
            this._helper.setMaxZoom(a);
          }
          setMinPitch(a) {
            this._helper.setMinPitch(a);
          }
          setMaxPitch(a) {
            this._helper.setMaxPitch(a);
          }
          setRenderWorldCopies(a) {
            this._helper.setRenderWorldCopies(a);
          }
          setBearing(a) {
            this._helper.setBearing(a);
          }
          setPitch(a) {
            this._helper.setPitch(a);
          }
          setRoll(a) {
            this._helper.setRoll(a);
          }
          setFov(a) {
            this._helper.setFov(a);
          }
          setZoom(a) {
            this._helper.setZoom(a);
          }
          setCenter(a) {
            this._helper.setCenter(a);
          }
          setElevation(a) {
            this._helper.setElevation(a);
          }
          setMinElevationForCurrentTile(a) {
            this._helper.setMinElevationForCurrentTile(a);
          }
          setPadding(a) {
            this._helper.setPadding(a);
          }
          interpolatePadding(a, u, g) {
            return this._helper.interpolatePadding(a, u, g);
          }
          isPaddingEqual(a) {
            return this._helper.isPaddingEqual(a);
          }
          resize(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            this._helper.resize(a, u, g);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(a) {
            this._helper.setMaxBounds(a);
          }
          overrideNearFarZ(a, u) {
            this._helper.overrideNearFarZ(a, u);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(a) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), a);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(a, u) {
          }
          constructor(a, u, g, _, w) {
            this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new ua({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (C, R) => this.getConstrained(C, R) }, a, u, g, _, w), this._coveringTilesDetailsProvider = new Bl();
          }
          clone() {
            const a = new qr();
            return a.apply(this), a;
          }
          apply(a, u, g) {
            this._helper.apply(a, u, g);
          }
          get cameraPosition() {
            return this._cameraPosition;
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._viewProjMatrix;
          }
          get inverseProjectionMatrix() {
            return this._invProjMatrix;
          }
          get mercatorMatrix() {
            return this._mercatorMatrix;
          }
          getVisibleUnwrappedCoordinates(a) {
            const u = [new o.aU(0, a)];
            if (this._helper._renderWorldCopies) {
              const g = this.screenPointToMercatorCoordinate(new o.P(0, 0)), _ = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, 0)), w = this.screenPointToMercatorCoordinate(new o.P(this._helper._width, this._helper._height)), C = this.screenPointToMercatorCoordinate(new o.P(0, this._helper._height)), R = Math.floor(Math.min(g.x, _.x, w.x, C.x)), L = Math.floor(Math.max(g.x, _.x, w.x, C.x)), k = 1;
              for (let V = R - k; V <= L + k; V++) V !== 0 && u.push(new o.aU(V, a));
            }
            return u;
          }
          getCameraFrustum() {
            return uo.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
          }
          getClippingPlane() {
            return null;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(a) {
            const u = this.screenPointToLocation(this.centerPoint, a), g = a ? a.getElevationForLngLatZoom(u, this._helper._tileZoom) : 0;
            this._helper.recalculateZoomAndCenter(g);
          }
          setLocationAtPoint(a, u) {
            const g = o.aI(this.elevation, this.center.lat), _ = this.screenPointToMercatorCoordinateAtZ(u, g), w = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, g), C = o.Z.fromLngLat(a), R = new o.Z(C.x - (_.x - w.x), C.y - (_.y - w.y));
            this.setCenter(R == null ? void 0 : R.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
          }
          locationToScreenPoint(a, u) {
            return u ? this.coordinatePoint(o.Z.fromLngLat(a), u.getElevationForLngLatZoom(a, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(o.Z.fromLngLat(a));
          }
          screenPointToLocation(a, u) {
            var g;
            return (g = this.screenPointToMercatorCoordinate(a, u)) === null || g === void 0 ? void 0 : g.toLngLat();
          }
          screenPointToMercatorCoordinate(a, u) {
            if (u) {
              const g = u.pointCoordinate(a);
              if (g != null) return g;
            }
            return this.screenPointToMercatorCoordinateAtZ(a);
          }
          screenPointToMercatorCoordinateAtZ(a, u) {
            const g = u || 0, _ = [a.x, a.y, 0, 1], w = [a.x, a.y, 1, 1];
            o.an(_, _, this._pixelMatrixInverse), o.an(w, w, this._pixelMatrixInverse);
            const C = _[3], R = w[3], L = _[1] / C, k = w[1] / R, V = _[2] / C, W = w[2] / R, Z = V === W ? 0 : (g - V) / (W - V);
            return new o.Z(o.z.number(_[0] / C, w[0] / R, Z) / this.worldSize, o.z.number(L, k, Z) / this.worldSize, g);
          }
          coordinatePoint(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this._pixelMatrix;
            const _ = [a.x * this.worldSize, a.y * this.worldSize, u, 1];
            return o.an(_, _, g), new o.P(_[0] / _[3], _[1] / _[3]);
          }
          getBounds() {
            const a = Math.max(0, this._helper._height / 2 - Kn(this));
            return new Cr().extend(this.screenPointToLocation(new o.P(0, a))).extend(this.screenPointToLocation(new o.P(this._helper._width, a))).extend(this.screenPointToLocation(new o.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new o.P(0, this._helper._height)));
          }
          isPointOnMapSurface(a, u) {
            return u ? u.pointCoordinate(a) != null : a.y > this.height / 2 - Kn(this);
          }
          calculatePosMatrix(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, g = arguments.length > 2 ? arguments[2] : void 0;
            var _;
            const w = (_ = a.key) !== null && _ !== void 0 ? _ : o.aV(a.wrap, a.canonical.z, a.canonical.z, a.canonical.x, a.canonical.y), C = u ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (C.has(w)) {
              const k = C.get(w);
              return g ? k.f32 : k.f64;
            }
            const R = pu(a, this.worldSize);
            o.M(R, u ? this._alignedProjMatrix : this._viewProjMatrix, R);
            const L = { f64: R, f32: new Float32Array(R) };
            return C.set(w, L), g ? L.f32 : L.f64;
          }
          calculateFogMatrix(a) {
            const u = a.key, g = this._fogMatrixCacheF32;
            if (g.has(u)) return g.get(u);
            const _ = pu(a, this.worldSize);
            return o.M(_, this._fogMatrix, _), g.set(u, new Float32Array(_)), g.get(u);
          }
          getConstrained(a, u) {
            u = o.ac(+u, this.minZoom, this.maxZoom);
            const g = { center: new o.O(a.lng, a.lat), zoom: u };
            let _ = this._helper._lngRange;
            this._helper._renderWorldCopies || _ !== null || (_ = [-179.9999999999, 180 - 1e-10]);
            const w = this.tileSize * o.aG(g.zoom);
            let C = 0, R = w, L = 0, k = w, V = 0, W = 0;
            const { x: Z, y: ae } = this.size;
            if (this._helper._latRange) {
              const qe = this._helper._latRange;
              C = o.Q(qe[1]) * w, R = o.Q(qe[0]) * w, R - C < ae && (V = ae / (R - C));
            }
            _ && (L = o.aJ(o.S(_[0]) * w, 0, w), k = o.aJ(o.S(_[1]) * w, 0, w), k < L && (k += w), k - L < Z && (W = Z / (k - L)));
            const { x: ue, y: Ce } = oi(w, a);
            let Se, Ie;
            const Le = Math.max(W || 0, V || 0);
            if (Le) {
              const qe = new o.P(W ? (k + L) / 2 : ue, V ? (R + C) / 2 : Ce);
              return g.center = mi(w, qe).wrap(), g.zoom += o.a9(Le), g;
            }
            if (this._helper._latRange) {
              const qe = ae / 2;
              Ce - qe < C && (Ie = C + qe), Ce + qe > R && (Ie = R - qe);
            }
            if (_) {
              const qe = (L + k) / 2;
              let $e = ue;
              this._helper._renderWorldCopies && ($e = o.aJ(ue, qe - w / 2, qe + w / 2));
              const He = Z / 2;
              $e - He < L && (Se = L + He), $e + He > k && (Se = k - He);
            }
            if (Se !== void 0 || Ie !== void 0) {
              const qe = new o.P(Se ?? ue, Ie ?? Ce);
              g.center = mi(w, qe).wrap();
            }
            return g;
          }
          calculateCenterFromCameraLngLatAlt(a, u, g, _) {
            return this._helper.calculateCenterFromCameraLngLatAlt(a, u, g, _);
          }
          _calculateNearFarZIfNeeded(a, u, g) {
            if (!this._helper.autoCalculateNearFarZ) return;
            const _ = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), w = a - _ * this._helper._pixelPerMeter / Math.cos(u), C = _ < 0 ? w : a, R = Math.PI / 2 + this.pitchInRadians, L = o.ab(this.fov) * (Math.abs(Math.cos(o.ab(this.roll))) * this.height + Math.abs(Math.sin(o.ab(this.roll))) * this.width) / this.height * (0.5 + g.y / this.height), k = Math.sin(L) * C / Math.sin(o.ac(Math.PI - R - L, 0.01, Math.PI - 0.01)), V = Kn(this), W = Math.atan(V / this._helper.cameraToCenterDistance), Z = o.ab(0.75), ae = W > Z ? 2 * W * (0.5 + g.y / (2 * V)) : Z, ue = Math.sin(ae) * C / Math.sin(o.ac(Math.PI - R - ae, 0.01, Math.PI - 0.01)), Ce = Math.min(k, ue);
            this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - u) * Ce + C), this._helper._nearZ = this._helper._height / 50;
          }
          _calcMatrices() {
            if (!this._helper._height) return;
            const a = this.centerOffset, u = oi(this.worldSize, this.center), g = u.x, _ = u.y;
            this._helper._pixelPerMeter = o.aI(1, this.center.lat) * this.worldSize;
            const w = o.ab(Math.min(this.pitch, 89.25)), C = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(w));
            let R;
            this._calculateNearFarZIfNeeded(C, w, a), R = new Float64Array(16), o.aW(R, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), o.ah(this._invProjMatrix, R), R[8] = 2 * -a.x / this._helper._width, R[9] = 2 * a.y / this._helper._height, this._projectionMatrix = o.aX(R), o.L(R, R, [1, -1, 1]), o.K(R, R, [0, 0, -this._helper.cameraToCenterDistance]), o.aY(R, R, -this.rollInRadians), o.aZ(R, R, this.pitchInRadians), o.aY(R, R, -this.bearingInRadians), o.K(R, R, [-g, -_, 0]), this._mercatorMatrix = o.L([], R, [this.worldSize, this.worldSize, this.worldSize]), o.L(R, R, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = o.M(new Float64Array(16), this.clipSpaceToPixelsMatrix, R), o.K(R, R, [0, 0, -this.elevation]), this._viewProjMatrix = R, this._invViewProjMatrix = o.ah([], R);
            const L = [0, 0, -1, 1];
            o.an(L, L, this._invViewProjMatrix), this._cameraPosition = [L[0] / L[3], L[1] / L[3], L[2] / L[3]], this._fogMatrix = new Float64Array(16), o.aW(this._fogMatrix, this.fovInRadians, this.width / this.height, C, this._helper._farZ), this._fogMatrix[8] = 2 * -a.x / this.width, this._fogMatrix[9] = 2 * a.y / this.height, o.L(this._fogMatrix, this._fogMatrix, [1, -1, 1]), o.K(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), o.aY(this._fogMatrix, this._fogMatrix, -this.rollInRadians), o.aZ(this._fogMatrix, this._fogMatrix, this.pitchInRadians), o.aY(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), o.K(this._fogMatrix, this._fogMatrix, [-g, -_, 0]), o.L(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), o.K(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = o.M(new Float64Array(16), this.clipSpaceToPixelsMatrix, R);
            const k = this._helper._width % 2 / 2, V = this._helper._height % 2 / 2, W = Math.cos(this.bearingInRadians), Z = Math.sin(-this.bearingInRadians), ae = g - Math.round(g) + W * k + Z * V, ue = _ - Math.round(_) + W * V + Z * k, Ce = new Float64Array(R);
            if (o.K(Ce, Ce, [ae > 0.5 ? ae - 1 : ae, ue > 0.5 ? ue - 1 : ue, 0]), this._alignedProjMatrix = Ce, R = o.ah(new Float64Array(16), this._pixelMatrix), !R) throw new Error("failed to invert matrix");
            this._pixelMatrixInverse = R, this._clearMatrixCaches();
          }
          _clearMatrixCaches() {
            this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
          }
          maxPitchScaleFactor() {
            if (!this._pixelMatrixInverse) return 1;
            const a = this.screenPointToMercatorCoordinate(new o.P(0, 0)), u = [a.x * this.worldSize, a.y * this.worldSize, 0, 1];
            return o.an(u, u, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            const a = o.aI(1, this.center.lat) * this.worldSize;
            return Yi(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / a).toLngLat();
          }
          lngLatToCameraDepth(a, u) {
            const g = o.Z.fromLngLat(a), _ = [g.x * this.worldSize, g.y * this.worldSize, u, 1];
            return o.an(_, _, this._viewProjMatrix), _[2] / _[3];
          }
          getProjectionData(a) {
            const { overscaledTileID: u, aligned: g, applyTerrainMatrix: _ } = a, w = this._helper.getMercatorTileCoordinates(u), C = u ? this.calculatePosMatrix(u, g, !0) : null;
            let R;
            return R = u && u.terrainRttPosMatrix32f && _ ? u.terrainRttPosMatrix32f : C || o.a_(), { mainMatrix: R, tileMercatorCoords: w, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: R };
          }
          isLocationOccluded(a) {
            return !1;
          }
          getPixelScale() {
            return 1;
          }
          getCircleRadiusCorrection() {
            return 1;
          }
          getPitchedTextCorrection(a, u, g) {
            return 1;
          }
          transformLightDirection(a) {
            return o.aO(a);
          }
          getRayDirectionFromPixel(a) {
            throw new Error("Not implemented.");
          }
          projectTileCoordinates(a, u, g, _) {
            const w = this.calculatePosMatrix(g);
            let C;
            _ ? (C = [a, u, _(a, u), 1], o.an(C, C, w)) : (C = [a, u, 0, 1], kn(C, C, w));
            const R = C[3];
            return { point: new o.P(C[0] / R, C[1] / R), signedDistanceFromCamera: R, isOccluded: !1 };
          }
          populateCache(a) {
            for (const u of a) this.calculatePosMatrix(u);
          }
          getMatrixForModel(a, u) {
            const g = o.Z.fromLngLat(a, u), _ = g.meterInMercatorCoordinateUnits(), w = o.a$();
            return o.K(w, w, [g.x, g.y, g.z]), o.aY(w, w, Math.PI), o.aZ(w, w, Math.PI / 2), o.L(w, w, [-_, _, _]), w;
          }
          getProjectionDataForCustomLayer() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            const u = new o.X(0, 0, 0, 0, 0), g = this.getProjectionData({ overscaledTileID: u, applyGlobeMatrix: a }), _ = pu(u, this.worldSize);
            o.M(_, this._viewProjMatrix, _), g.tileMercatorCoords = [0, 0, 1, 1];
            const w = [o.Y, o.Y, this.worldSize / this._helper.pixelsPerMeter], C = o.b0();
            return o.L(C, _, w), g.fallbackMatrix = C, g.mainMatrix = C, g;
          }
          getFastPathSimpleProjectionMatrix(a) {
            return this.calculatePosMatrix(a);
          }
        }
        function Ys() {
          o.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
        }
        function gu(v) {
          if (v.useSlerp)
            if (v.k < 1) {
              const a = o.b1(v.startEulerAngles.roll, v.startEulerAngles.pitch, v.startEulerAngles.bearing), u = o.b1(v.endEulerAngles.roll, v.endEulerAngles.pitch, v.endEulerAngles.bearing), g = new Float64Array(4);
              o.b2(g, a, u, v.k);
              const _ = o.b3(g);
              v.tr.setRoll(_.roll), v.tr.setPitch(_.pitch), v.tr.setBearing(_.bearing);
            } else v.tr.setRoll(v.endEulerAngles.roll), v.tr.setPitch(v.endEulerAngles.pitch), v.tr.setBearing(v.endEulerAngles.bearing);
          else v.tr.setRoll(o.z.number(v.startEulerAngles.roll, v.endEulerAngles.roll, v.k)), v.tr.setPitch(o.z.number(v.startEulerAngles.pitch, v.endEulerAngles.pitch, v.k)), v.tr.setBearing(o.z.number(v.startEulerAngles.bearing, v.endEulerAngles.bearing, v.k));
        }
        function Ki(v, a, u, g, _) {
          const w = _.padding, C = oi(_.worldSize, u.getNorthWest()), R = oi(_.worldSize, u.getNorthEast()), L = oi(_.worldSize, u.getSouthEast()), k = oi(_.worldSize, u.getSouthWest()), V = o.ab(-g), W = C.rotate(V), Z = R.rotate(V), ae = L.rotate(V), ue = k.rotate(V), Ce = new o.P(Math.max(W.x, Z.x, ue.x, ae.x), Math.max(W.y, Z.y, ue.y, ae.y)), Se = new o.P(Math.min(W.x, Z.x, ue.x, ae.x), Math.min(W.y, Z.y, ue.y, ae.y)), Ie = Ce.sub(Se), Le = (_.width - (w.left + w.right + a.left + a.right)) / Ie.x, qe = (_.height - (w.top + w.bottom + a.top + a.bottom)) / Ie.y;
          if (qe < 0 || Le < 0) return void Ys();
          const $e = Math.min(o.a9(_.scale * Math.min(Le, qe)), v.maxZoom), He = o.P.convert(v.offset), Ze = new o.P((a.left - a.right) / 2, (a.top - a.bottom) / 2).rotate(o.ab(g)), Je = He.add(Ze).mult(_.scale / o.aG($e));
          return { center: mi(_.worldSize, C.add(L).div(2).sub(Je)), zoom: $e, bearing: g };
        }
        class Ll {
          get useGlobeControls() {
            return !1;
          }
          handlePanInertia(a, u) {
            return { easingOffset: a, easingCenter: u.center };
          }
          handleMapControlsRollPitchBearingZoom(a, u) {
            a.bearingDelta && u.setBearing(u.bearing + a.bearingDelta), a.pitchDelta && u.setPitch(u.pitch + a.pitchDelta), a.rollDelta && u.setRoll(u.roll + a.rollDelta), a.zoomDelta && u.setZoom(u.zoom + a.zoomDelta);
          }
          handleMapControlsPan(a, u, g) {
            a.around.distSqr(u.centerPoint) < 0.01 || u.setLocationAtPoint(g, a.around);
          }
          cameraForBoxAndBearing(a, u, g, _, w) {
            return Ki(a, u, g, _, w);
          }
          handleJumpToCenterZoom(a, u) {
            a.zoom !== (u.zoom !== void 0 ? +u.zoom : a.zoom) && a.setZoom(+u.zoom), u.center !== void 0 && a.setCenter(o.O.convert(u.center));
          }
          handleEaseTo(a, u) {
            const g = a.zoom, _ = a.padding, w = { roll: a.roll, pitch: a.pitch, bearing: a.bearing }, C = { roll: u.roll === void 0 ? a.roll : u.roll, pitch: u.pitch === void 0 ? a.pitch : u.pitch, bearing: u.bearing === void 0 ? a.bearing : u.bearing }, R = u.zoom !== void 0, L = !a.isPaddingEqual(u.padding);
            let k = !1;
            const V = R ? +u.zoom : a.zoom;
            let W = a.centerPoint.add(u.offsetAsPoint);
            const Z = a.screenPointToLocation(W), { center: ae, zoom: ue } = a.getConstrained(o.O.convert(u.center || Z), V ?? g);
            Mi(a, ae);
            const Ce = oi(a.worldSize, Z), Se = oi(a.worldSize, ae).sub(Ce), Ie = o.aG(ue - g);
            return k = ue !== g, { easeFunc: (Le) => {
              if (k && a.setZoom(o.z.number(g, ue, Le)), o.b4(w, C) || gu({ startEulerAngles: w, endEulerAngles: C, tr: a, k: Le, useSlerp: w.roll != C.roll }), L && (a.interpolatePadding(_, u.padding, Le), W = a.centerPoint.add(u.offsetAsPoint)), u.around) a.setLocationAtPoint(u.around, u.aroundPoint);
              else {
                const qe = o.aG(a.zoom - g), $e = ue > g ? Math.min(2, Ie) : Math.max(0.5, Ie), He = Math.pow($e, 1 - Le), Ze = mi(a.worldSize, Ce.add(Se.mult(Le * He)).mult(qe));
                a.setLocationAtPoint(a.renderWorldCopies ? Ze.wrap() : Ze, W);
              }
            }, isZooming: k, elevationCenter: ae };
          }
          handleFlyTo(a, u) {
            const g = u.zoom !== void 0, _ = a.zoom, w = a.getConstrained(o.O.convert(u.center || u.locationAtOffset), g ? +u.zoom : _), C = w.center, R = w.zoom;
            Mi(a, C);
            const L = oi(a.worldSize, u.locationAtOffset), k = oi(a.worldSize, C).sub(L), V = k.mag(), W = o.aG(R - _);
            let Z;
            if (u.minZoom !== void 0) {
              const ae = Math.min(+u.minZoom, _, R), ue = a.getConstrained(C, ae).zoom;
              Z = o.aG(ue - _);
            }
            return { easeFunc: (ae, ue, Ce, Se) => {
              a.setZoom(ae === 1 ? R : _ + o.a9(ue));
              const Ie = ae === 1 ? C : mi(a.worldSize, L.add(k.mult(Ce)).mult(ue));
              a.setLocationAtPoint(a.renderWorldCopies ? Ie.wrap() : Ie, Se);
            }, scaleOfZoom: W, targetCenter: C, scaleOfMinZoom: Z, pixelPathLength: V };
          }
        }
        class Fn {
          constructor(a, u, g) {
            this.blendFunction = a, this.blendColor = u, this.mask = g;
          }
        }
        Fn.Replace = [1, 0], Fn.disabled = new Fn(Fn.Replace, o.b5.transparent, [!1, !1, !1, !1]), Fn.unblended = new Fn(Fn.Replace, o.b5.transparent, [!0, !0, !0, !0]), Fn.alphaBlended = new Fn([1, 771], o.b5.transparent, [!0, !0, !0, !0]);
        const Xo = 2305;
        class ln {
          constructor(a, u, g) {
            this.enable = a, this.mode = u, this.frontFace = g;
          }
        }
        ln.disabled = new ln(!1, 1029, Xo), ln.backCCW = new ln(!0, 1029, Xo), ln.frontCCW = new ln(!0, 1028, Xo);
        class Xr {
          constructor(a, u, g) {
            this.func = a, this.mask = u, this.range = g;
          }
        }
        Xr.ReadOnly = !1, Xr.ReadWrite = !0, Xr.disabled = new Xr(519, Xr.ReadOnly, [0, 1]);
        const Ol = 7680;
        class dn {
          constructor(a, u, g, _, w, C) {
            this.test = a, this.ref = u, this.mask = g, this.fail = _, this.depthFail = w, this.pass = C;
          }
        }
        dn.disabled = new dn({ func: 519, mask: 0 }, 0, 0, Ol, Ol, Ol);
        const ha = /* @__PURE__ */ new WeakMap();
        function fs(v) {
          var a;
          if (ha.has(v)) return ha.get(v);
          {
            const u = (a = v.getParameter(v.VERSION)) === null || a === void 0 ? void 0 : a.startsWith("WebGL 2.0");
            return ha.set(v, u), u;
          }
        }
        class Ao {
          get awaitingQuery() {
            return !!this._readbackQueue;
          }
          constructor(a) {
            this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = a;
            const u = a.context, g = u.gl;
            this._texFormat = g.RGBA, this._texType = g.UNSIGNED_BYTE;
            const _ = new o.aD();
            _.emplaceBack(-1, -1), _.emplaceBack(2, -1), _.emplaceBack(-1, 2);
            const w = new o.aF();
            w.emplaceBack(0, 1, 2), this._fullscreenTriangle = new co(u.createVertexBuffer(_, nn.members), u.createIndexBuffer(w), o.aE.simpleSegment(0, 0, _.length, w.length)), this._resultBuffer = new Uint8Array(4), u.activeTexture.set(g.TEXTURE1);
            const C = g.createTexture();
            g.bindTexture(g.TEXTURE_2D, C), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MIN_FILTER, g.NEAREST), g.texParameteri(g.TEXTURE_2D, g.TEXTURE_MAG_FILTER, g.NEAREST), g.texImage2D(g.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = u.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(C), fs(g) && (this._pbo = g.createBuffer(), g.bindBuffer(g.PIXEL_PACK_BUFFER, this._pbo), g.bufferData(g.PIXEL_PACK_BUFFER, 4, g.STREAM_READ), g.bindBuffer(g.PIXEL_PACK_BUFFER, null));
          }
          destroy() {
            const a = this._cachedRenderContext.context.gl;
            this._fullscreenTriangle.destroy(), this._fbo.destroy(), a.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
          }
          updateErrorLoop(a, u) {
            const g = this._updateCount;
            return this._readbackQueue ? g >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : g >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(a, u), this._updateCount++, this._measuredError;
          }
          _bindFramebuffer() {
            const a = this._cachedRenderContext.context, u = a.gl;
            a.activeTexture.set(u.TEXTURE1), u.bindTexture(u.TEXTURE_2D, this._fbo.colorAttachment.get()), a.bindFramebuffer.set(this._fbo.framebuffer);
          }
          _renderErrorTexture(a, u) {
            const g = this._cachedRenderContext.context, _ = g.gl;
            if (this._bindFramebuffer(), g.viewport.set([0, 0, this._texWidth, this._texHeight]), g.clear({ color: o.b5.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(g, _.TRIANGLES, Xr.disabled, dn.disabled, Fn.unblended, ln.disabled, /* @__PURE__ */ ((w, C) => ({ u_input: w, u_output_expected: C }))(a, u), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && fs(_)) {
              _.bindBuffer(_.PIXEL_PACK_BUFFER, this._pbo), _.readBuffer(_.COLOR_ATTACHMENT0), _.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), _.bindBuffer(_.PIXEL_PACK_BUFFER, null);
              const w = _.fenceSync(_.SYNC_GPU_COMMANDS_COMPLETE, 0);
              _.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: w };
            } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
          }
          _tryReadback() {
            const a = this._cachedRenderContext.context.gl;
            if (this._pbo && this._readbackQueue && fs(a)) {
              const u = a.clientWaitSync(this._readbackQueue.sync, 0, 0);
              if (u === a.WAIT_FAILED) return o.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
              if (u === a.TIMEOUT_EXPIRED) return;
              a.bindBuffer(a.PIXEL_PACK_BUFFER, this._pbo), a.getBufferSubData(a.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), a.bindBuffer(a.PIXEL_PACK_BUFFER, null);
            } else this._bindFramebuffer(), a.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
            this._readbackQueue = null, this._measuredError = Ao._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
          }
          static _parseRGBA8float(a) {
            let u = 0;
            return u += a[0] / 256, u += a[1] / 65536, u += a[2] / 16777216, a[3] < 127 && (u = -u), u / 128;
          }
        }
        const Nl = o.Y / 128;
        function Zo(v, a) {
          const u = v.granularity !== void 0 ? Math.max(v.granularity, 1) : 1, g = u + (v.generateBorders ? 2 : 0), _ = u + (v.extendToNorthPole || v.generateBorders ? 1 : 0) + (v.extendToSouthPole || v.generateBorders ? 1 : 0), w = g + 1, C = _ + 1, R = v.generateBorders ? -1 : 0, L = v.generateBorders || v.extendToNorthPole ? -1 : 0, k = u + (v.generateBorders ? 1 : 0), V = u + (v.generateBorders || v.extendToSouthPole ? 1 : 0), W = w * C, Z = g * _ * 6, ae = w * C > 65536;
          if (ae && a === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
          const ue = ae || a === "32bit", Ce = new Int16Array(2 * W);
          let Se = 0;
          for (let qe = L; qe <= V; qe++) for (let $e = R; $e <= k; $e++) {
            let He = $e / u * o.Y;
            $e === -1 && (He = -64), $e === u + 1 && (He = o.Y + Nl);
            let Ze = qe / u * o.Y;
            qe === -1 && (Ze = v.extendToNorthPole ? o.b7 : -64), qe === u + 1 && (Ze = v.extendToSouthPole ? o.b8 : o.Y + Nl), Ce[Se++] = He, Ce[Se++] = Ze;
          }
          const Ie = ue ? new Uint32Array(Z) : new Uint16Array(Z);
          let Le = 0;
          for (let qe = 0; qe < _; qe++) for (let $e = 0; $e < g; $e++) {
            const He = $e + 1 + qe * w, Ze = $e + (qe + 1) * w, Je = $e + 1 + (qe + 1) * w;
            Ie[Le++] = $e + qe * w, Ie[Le++] = Ze, Ie[Le++] = He, Ie[Le++] = He, Ie[Le++] = Ze, Ie[Le++] = Je;
          }
          return { vertices: Ce.buffer.slice(0), indices: Ie.buffer.slice(0), uses32bitIndices: ue };
        }
        const Yo = new o.aC({ fill: new o.b9(128, 2), line: new o.b9(512, 0), tile: new o.b9(128, 32), stencil: new o.b9(128, 1), circle: 3 });
        class Dl {
          constructor() {
            this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
          }
          get name() {
            return "vertical-perspective";
          }
          get transitionState() {
            return 1;
          }
          get useSubdivision() {
            return !0;
          }
          get shaderVariantName() {
            return "globe";
          }
          get shaderDefine() {
            return "#define GLOBE";
          }
          get shaderPreludeCode() {
            return gi.projectionGlobe;
          }
          get vertexShaderPreludeCode() {
            return gi.projectionMercator.vertexSource;
          }
          get subdivisionGranularity() {
            return Yo;
          }
          get useGlobeControls() {
            return !0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._errorCorrectionUsable;
          }
          destroy() {
            this._errorMeasurement && this._errorMeasurement.destroy();
          }
          updateGPUdependent(a) {
            this._errorMeasurement || (this._errorMeasurement = new Ao(a));
            const u = o.Q(this._errorQueryLatitudeDegrees), g = 2 * Math.atan(Math.exp(Math.PI - u * Math.PI * 2)) - 0.5 * Math.PI, _ = this._errorMeasurement.updateErrorLoop(u, g), w = M.now();
            _ !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = _, this._errorMeasurementLastChangeTime = w);
            const C = Math.min(Math.max((w - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
            this._errorCorrectionUsable = o.ba(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, o.bb(C));
          }
          _getMeshKey(a) {
            return `${a.granularity.toString(36)}_${a.generateBorders ? "b" : ""}${a.extendToNorthPole ? "n" : ""}${a.extendToSouthPole ? "s" : ""}`;
          }
          getMeshFromTileID(a, u, g, _, w) {
            const C = (w === "stencil" ? Yo.stencil : Yo.tile).getGranularityForZoomLevel(u.z);
            return this._getMesh(a, { granularity: C, generateBorders: g, extendToNorthPole: u.y === 0 && _, extendToSouthPole: u.y === (1 << u.z) - 1 && _ });
          }
          _getMesh(a, u) {
            const g = this._getMeshKey(u);
            if (g in this._tileMeshCache) return this._tileMeshCache[g];
            const _ = function(w, C) {
              const R = Zo(C, "16bit"), L = o.aD.deserialize({ arrayBuffer: R.vertices, length: R.vertices.byteLength / 2 / 2 }), k = o.aF.deserialize({ arrayBuffer: R.indices, length: R.indices.byteLength / 2 / 3 });
              return new co(w.createVertexBuffer(L, nn.members), w.createIndexBuffer(k), o.aE.simpleSegment(0, 0, L.length, k.length));
            }(a, u);
            return this._tileMeshCache[g] = _, _;
          }
          recalculate(a) {
          }
          hasTransition() {
            const a = M.now();
            let u = !1;
            return u = u || (a - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, u = u || this._errorMeasurement && this._errorMeasurement.awaitingQuery, u;
          }
          setErrorQueryLatitudeDegrees(a) {
            this._errorQueryLatitudeDegrees = a;
          }
        }
        const Dc = new o.q({ type: new o.D(o.v.projection.type) });
        class kc extends o.E {
          constructor(a) {
            super(), this._transitionable = new o.T(Dc), this.setProjection(a), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new o.B(0)), this._mercatorProjection = new sl(), this._verticalPerspectiveProjection = new Dl();
          }
          get transitionState() {
            const a = this.properties.get("type");
            if (typeof a == "string" && a === "mercator") return 0;
            if (typeof a == "string" && a === "vertical-perspective") return 1;
            if (a instanceof o.bc) {
              if (a.from === "vertical-perspective" && a.to === "mercator") return 1 - a.transition;
              if (a.from === "mercator" && a.to === "vertical-perspective") return a.transition;
            }
            return 1;
          }
          get useGlobeRendering() {
            return this.transitionState > 0;
          }
          get latitudeErrorCorrectionRadians() {
            return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
          }
          get currentProjection() {
            return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
          }
          get name() {
            return "globe";
          }
          get useSubdivision() {
            return this.currentProjection.useSubdivision;
          }
          get shaderVariantName() {
            return this.currentProjection.shaderVariantName;
          }
          get shaderDefine() {
            return this.currentProjection.shaderDefine;
          }
          get shaderPreludeCode() {
            return this.currentProjection.shaderPreludeCode;
          }
          get vertexShaderPreludeCode() {
            return this.currentProjection.vertexShaderPreludeCode;
          }
          get subdivisionGranularity() {
            return this.currentProjection.subdivisionGranularity;
          }
          get useGlobeControls() {
            return this.transitionState > 0;
          }
          destroy() {
            this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
          }
          updateGPUdependent(a) {
            this._mercatorProjection.updateGPUdependent(a), this._verticalPerspectiveProjection.updateGPUdependent(a);
          }
          getMeshFromTileID(a, u, g, _, w) {
            return this.currentProjection.getMeshFromTileID(a, u, g, _, w);
          }
          setProjection(a) {
            this._transitionable.setValue("type", (a == null ? void 0 : a.type) || "mercator");
          }
          updateTransitions(a) {
            this._transitioning = this._transitionable.transitioned(a, this._transitioning);
          }
          hasTransition() {
            return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
          }
          recalculate(a) {
            this.properties = this._transitioning.possiblyEvaluate(a);
          }
          setErrorQueryLatitudeDegrees(a) {
            this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(a), this._mercatorProjection.setErrorQueryLatitudeDegrees(a);
          }
        }
        function mu(v) {
          const a = Ks(v.worldSize, v.center.lat);
          return 2 * Math.PI * a;
        }
        function al(v, a, u, g, _) {
          const w = 1 / (1 << _), C = a / o.Y * w + g * w, R = o.be((v / o.Y * w + u * w) * Math.PI * 2 + Math.PI, 2 * Math.PI), L = 2 * Math.atan(Math.exp(Math.PI - C * Math.PI * 2)) - 0.5 * Math.PI, k = Math.cos(L), V = new Float64Array(3);
          return V[0] = Math.sin(R) * k, V[1] = Math.sin(L), V[2] = Math.cos(R) * k, V;
        }
        function gn(v) {
          return function(a, u) {
            const g = Math.cos(u), _ = new Float64Array(3);
            return _[0] = Math.sin(a) * g, _[1] = Math.sin(u), _[2] = Math.cos(a) * g, _;
          }(v.lng * Math.PI / 180, v.lat * Math.PI / 180);
        }
        function Ks(v, a) {
          return v / (2 * Math.PI) / Math.cos(a * Math.PI / 180);
        }
        function ho(v) {
          const a = Math.asin(v[1]) / Math.PI * 180, u = Math.sqrt(v[0] * v[0] + v[2] * v[2]);
          if (u > 1e-6) {
            const g = v[0] / u, _ = Math.acos(v[2] / u), w = (g > 0 ? _ : -_) / Math.PI * 180;
            return new o.O(o.aJ(w, -180, 180), a);
          }
          return new o.O(0, a);
        }
        function Js(v) {
          return Math.cos(v * Math.PI / 180);
        }
        function Un(v, a) {
          const u = Js(v), g = Js(a);
          return o.a9(g / u);
        }
        function kl(v, a) {
          const u = v.rotate(a.bearingInRadians), g = a.zoom + Un(a.center.lat, 0), _ = o.ba(1 / Js(a.center.lat), 1 / Js(Math.min(Math.abs(a.center.lat), 60)), o.bd(g, 7, 3, 0, 1)), w = 360 / mu({ worldSize: a.worldSize, center: { lat: a.center.lat } });
          return new o.O(a.center.lng - u.x * w * _, o.ac(a.center.lat + u.y * w, -85.051129, o.aH));
        }
        function Qs(v) {
          const a = 0.5 * v, u = Math.sin(a), g = Math.cos(a);
          return Math.log(u + g) - Math.log(g - u);
        }
        function Wu(v, a, u, g) {
          const _ = v.lat + u * g;
          if (Math.abs(u) > 1) {
            const w = (Math.sign(v.lat + u) !== Math.sign(v.lat) ? -Math.abs(v.lat) : Math.abs(v.lat)) * Math.PI / 180, C = Math.abs(v.lat + u) * Math.PI / 180, R = Qs(w + g * (C - w)), L = Qs(w), k = Qs(C);
            return new o.O(v.lng + a * ((R - L) / (k - L)), _);
          }
          return new o.O(v.lng + a * g, _);
        }
        class Fc {
          constructor(a) {
            this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._aabbFactory = a;
          }
          recalculateCache() {
            if (!this._hadAnyChanges) return;
            const a = this._cachePrevious;
            this._cachePrevious = this._cache, this._cache = a, this._cache.clear(), this._hadAnyChanges = !1;
          }
          getTileAABB(a, u, g, _) {
            const w = `${a.z}_${a.x}_${a.y}`, C = this._cache.get(w);
            if (C) return C;
            const R = this._cachePrevious.get(w);
            if (R) return this._cache.set(w, R), R;
            const L = this._aabbFactory(a, u, g, _);
            return this._cache.set(w, L), this._hadAnyChanges = !0, L;
          }
        }
        function Uc(v, a, u) {
          const g = v - a;
          return g < 0 ? -g : Math.max(0, g - u);
        }
        function Fl(v, a, u, g, _) {
          const w = v - u;
          let C;
          return C = w < 0 ? Math.min(-w, 1 + w - _) : w > 1 ? Math.min(Math.max(w - _, 0), 1 - w) : 0, Math.max(C, Uc(a, g, _));
        }
        class _u {
          constructor() {
            this._aabbCache = new Fc(this._computeTileAABB);
          }
          recalculateCache() {
            this._aabbCache.recalculateCache();
          }
          distanceToTile2d(a, u, g, _) {
            const w = 1 << g.z, C = 1 / w, R = g.x / w, L = g.y / w;
            let k = 2;
            return k = Math.min(k, Fl(a, u, R, L, C)), k = Math.min(k, Fl(a, u, R + 0.5, -L - C, C)), k = Math.min(k, Fl(a, u, R + 0.5, 2 - L - C, C)), k;
          }
          getWrap(a, u, g) {
            const _ = 1 << u.z, w = 1 / _, C = u.x / _, R = Uc(a.x, C, w), L = Uc(a.x, C - 1, w), k = Uc(a.x, C + 1, w), V = Math.min(R, L, k);
            return V === k ? 1 : V === L ? -1 : 0;
          }
          allowVariableZoom(a, u) {
            return Xi(a, u) > 4;
          }
          allowWorldCopies() {
            return !1;
          }
          getTileAABB(a, u, g, _) {
            return this._aabbCache.getTileAABB(a, u, g, _);
          }
          _computeTileAABB(a, u, g, _) {
            if (a.z <= 0) return new an([-1, -1, -1], [1, 1, 1]);
            if (a.z === 1) return new an([a.x === 0 ? -1 : 0, a.y === 0 ? 0 : -1, -1], [a.x === 0 ? 0 : 1, a.y === 0 ? 1 : 0, 1]);
            {
              const w = [al(0, 0, a.x, a.y, a.z), al(o.Y, 0, a.x, a.y, a.z), al(o.Y, o.Y, a.x, a.y, a.z), al(0, o.Y, a.x, a.y, a.z)], C = [1, 1, 1], R = [-1, -1, -1];
              for (const L of w) for (let k = 0; k < 3; k++) C[k] = Math.min(C[k], L[k]), R[k] = Math.max(R[k], L[k]);
              if (a.y === 0 || a.y === (1 << a.z) - 1) {
                const L = [0, a.y === 0 ? 1 : -1, 0];
                for (let k = 0; k < 3; k++) C[k] = Math.min(C[k], L[k]), R[k] = Math.max(R[k], L[k]);
              }
              return new an(C, R);
            }
          }
        }
        class Ul {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(a) {
            this._helper.setMinZoom(a);
          }
          setMaxZoom(a) {
            this._helper.setMaxZoom(a);
          }
          setMinPitch(a) {
            this._helper.setMinPitch(a);
          }
          setMaxPitch(a) {
            this._helper.setMaxPitch(a);
          }
          setRenderWorldCopies(a) {
            this._helper.setRenderWorldCopies(a);
          }
          setBearing(a) {
            this._helper.setBearing(a);
          }
          setPitch(a) {
            this._helper.setPitch(a);
          }
          setRoll(a) {
            this._helper.setRoll(a);
          }
          setFov(a) {
            this._helper.setFov(a);
          }
          setZoom(a) {
            this._helper.setZoom(a);
          }
          setCenter(a) {
            this._helper.setCenter(a);
          }
          setElevation(a) {
            this._helper.setElevation(a);
          }
          setMinElevationForCurrentTile(a) {
            this._helper.setMinElevationForCurrentTile(a);
          }
          setPadding(a) {
            this._helper.setPadding(a);
          }
          interpolatePadding(a, u, g) {
            return this._helper.interpolatePadding(a, u, g);
          }
          isPaddingEqual(a) {
            return this._helper.isPaddingEqual(a);
          }
          resize(a, u) {
            this._helper.resize(a, u);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(a) {
            this._helper.setMaxBounds(a);
          }
          overrideNearFarZ(a, u) {
            this._helper.overrideNearFarZ(a, u);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(a) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), a);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          setTransitionState(a) {
          }
          constructor() {
            this._cachedClippingPlane = o.bf(), this._projectionMatrix = o.a$(), this._globeViewProjMatrix32f = o.a_(), this._globeViewProjMatrixNoCorrection = o.a$(), this._globeViewProjMatrixNoCorrectionInverted = o.a$(), this._globeProjMatrixInverted = o.a$(), this._cameraPosition = o.bg(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new ua({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (a, u) => this.getConstrained(a, u) }), this._coveringTilesDetailsProvider = new _u();
          }
          clone() {
            const a = new Ul();
            return a.apply(this), a;
          }
          apply(a, u) {
            this._globeLatitudeErrorCorrectionRadians = u || 0, this._helper.apply(a);
          }
          get projectionMatrix() {
            return this._projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this._globeViewProjMatrixNoCorrection;
          }
          get inverseProjectionMatrix() {
            return this._globeProjMatrixInverted;
          }
          get cameraPosition() {
            const a = o.bg();
            return a[0] = this._cameraPosition[0], a[1] = this._cameraPosition[1], a[2] = this._cameraPosition[2], a;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          getProjectionData(a) {
            const { overscaledTileID: u, applyGlobeMatrix: g } = a, _ = this._helper.getMercatorTileCoordinates(u);
            return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: _, clippingPlane: this._cachedClippingPlane, projectionTransition: g ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
          }
          _computeClippingPlane(a) {
            const u = this.pitchInRadians, g = this.cameraToCenterDistance / a, _ = Math.sin(u) * g, w = Math.cos(u) * g + 1, C = 1 / Math.sqrt(_ * _ + w * w) * 1;
            let R = -_, L = w;
            const k = Math.sqrt(R * R + L * L);
            R /= k, L /= k;
            const V = [0, R, L];
            return o.bh(V, V, [0, 0, 0], -this.bearingInRadians), o.bi(V, V, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), o.bj(V, V, [0, 0, 0], this.center.lng * Math.PI / 180), o.aM(V, V, 0.25), [...V, 0.25 * -C];
          }
          isLocationOccluded(a) {
            return !this.isSurfacePointVisible(gn(a));
          }
          transformLightDirection(a) {
            const u = this._helper._center.lng * Math.PI / 180, g = this._helper._center.lat * Math.PI / 180, _ = Math.cos(g), w = [Math.sin(u) * _, Math.sin(g), Math.cos(u) * _], C = [w[2], 0, -w[0]], R = [0, 0, 0];
            o.aS(R, C, w), o.aR(C, C), o.aR(R, R);
            const L = [0, 0, 0];
            return o.aR(L, [C[0] * a[0] + R[0] * a[1] + w[0] * a[2], C[1] * a[0] + R[1] * a[1] + w[1] * a[2], C[2] * a[0] + R[2] * a[1] + w[2] * a[2]]), L;
          }
          getPixelScale() {
            return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getCircleRadiusCorrection() {
            return Math.cos(this._helper._center.lat * Math.PI / 180);
          }
          getPitchedTextCorrection(a, u, g) {
            const _ = function(R, L, k) {
              const V = 1 / (1 << k.z);
              return new o.Z(R / o.Y * V + k.x * V, L / o.Y * V + k.y * V);
            }(a, u, g.canonical), w = (C = _.y, [o.be(_.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - C * Math.PI * 2)) - 0.5 * Math.PI]);
            var C;
            return this.getCircleRadiusCorrection() / Math.cos(w[1]);
          }
          projectTileCoordinates(a, u, g, _) {
            const w = g.canonical, C = al(a, u, w.x, w.y, w.z), R = 1 + (_ ? _(a, u) : 0) / o.bp, L = [C[0] * R, C[1] * R, C[2] * R, 1];
            o.an(L, L, this._globeViewProjMatrixNoCorrection);
            const k = this._cachedClippingPlane, V = k[0] * C[0] + k[1] * C[1] + k[2] * C[2] + k[3] < 0;
            return { point: new o.P(L[0] / L[3], L[1] / L[3]), signedDistanceFromCamera: L[3], isOccluded: V };
          }
          _calcMatrices() {
            if (!this._helper._width || !this._helper._height) return;
            const a = Ks(this.worldSize, this.center.lat), u = o.b0(), g = o.b0();
            this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * a), o.aW(u, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
            const _ = this.centerOffset;
            u[8] = 2 * -_.x / this._helper._width, u[9] = 2 * _.y / this._helper._height, this._projectionMatrix = o.aX(u), this._globeProjMatrixInverted = o.b0(), o.ah(this._globeProjMatrixInverted, u), o.K(u, u, [0, 0, -this.cameraToCenterDistance]), o.aY(u, u, this.rollInRadians), o.aZ(u, u, -this.pitchInRadians), o.aY(u, u, this.bearingInRadians), o.K(u, u, [0, 0, -a]);
            const w = o.bg();
            w[0] = a, w[1] = a, w[2] = a, o.aZ(g, u, this.center.lat * Math.PI / 180), o.bk(g, g, -this.center.lng * Math.PI / 180), o.L(g, g, w), this._globeViewProjMatrixNoCorrection = g, o.aZ(u, u, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), o.bk(u, u, -this.center.lng * Math.PI / 180), o.L(u, u, w), this._globeViewProjMatrix32f = new Float32Array(u), this._globeViewProjMatrixNoCorrectionInverted = o.b0(), o.ah(this._globeViewProjMatrixNoCorrectionInverted, g);
            const C = o.bg();
            this._cameraPosition = o.bg(), this._cameraPosition[2] = this.cameraToCenterDistance / a, o.bh(this._cameraPosition, this._cameraPosition, C, -this.rollInRadians), o.bi(this._cameraPosition, this._cameraPosition, C, this.pitchInRadians), o.bh(this._cameraPosition, this._cameraPosition, C, -this.bearingInRadians), o.aN(this._cameraPosition, this._cameraPosition, [0, 0, 1]), o.bi(this._cameraPosition, this._cameraPosition, C, -this.center.lat * Math.PI / 180), o.bj(this._cameraPosition, this._cameraPosition, C, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(a);
            const R = o.aX(this._globeViewProjMatrixNoCorrectionInverted);
            o.L(R, R, [1, 1, -1]), this._cachedFrustum = uo.fromInvProjectionMatrix(R);
          }
          calculateFogMatrix(a) {
            o.w("calculateFogMatrix is not supported on globe projection.");
            const u = o.b0();
            return o.ar(u), u;
          }
          getVisibleUnwrappedCoordinates(a) {
            return [new o.aU(0, a)];
          }
          getCameraFrustum() {
            return this._cachedFrustum;
          }
          getClippingPlane() {
            return this._cachedClippingPlane;
          }
          getCoveringTilesDetailsProvider() {
            return this._coveringTilesDetailsProvider;
          }
          recalculateZoomAndCenter(a) {
            a && o.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
          }
          maxPitchScaleFactor() {
            return 1;
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(a, u) {
            if (!this._globeViewProjMatrixNoCorrection) return 1;
            const g = gn(a);
            o.aM(g, g, 1 + u / o.bp);
            const _ = o.bf();
            return o.an(_, [g[0], g[1], g[2], 1], this._globeViewProjMatrixNoCorrection), _[2] / _[3];
          }
          populateCache(a) {
          }
          getBounds() {
            const a = 0.5 * this.width, u = 0.5 * this.height, g = [new o.P(0, 0), new o.P(a, 0), new o.P(this.width, 0), new o.P(this.width, u), new o.P(this.width, this.height), new o.P(a, this.height), new o.P(0, this.height), new o.P(0, u)], _ = [];
            for (const W of g) _.push(this.unprojectScreenPoint(W));
            let w = 0, C = 0, R = 0, L = 0;
            const k = this.center;
            for (const W of _) {
              const Z = o.bl(k.lng, W.lng), ae = o.bl(k.lat, W.lat);
              Z < C && (C = Z), Z > w && (w = Z), ae < L && (L = ae), ae > R && (R = ae);
            }
            const V = [k.lng + C, k.lat + L, k.lng + w, k.lat + R];
            return this.isSurfacePointOnScreen([0, 1, 0]) && (V[3] = 90, V[0] = -180, V[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (V[1] = -90, V[0] = -180, V[2] = 180), new Cr(V);
          }
          getConstrained(a, u) {
            const g = o.ac(a.lat, -85.051129, o.aH), _ = o.ac(+u, this.minZoom + Un(0, g), this.maxZoom);
            return { center: new o.O(a.lng, g), zoom: _ };
          }
          calculateCenterFromCameraLngLatAlt(a, u, g, _) {
            return this._helper.calculateCenterFromCameraLngLatAlt(a, u, g, _);
          }
          setLocationAtPoint(a, u) {
            const g = gn(this.unprojectScreenPoint(u)), _ = gn(a), w = o.bg();
            o.bm(w);
            const C = o.bg();
            o.bj(C, g, w, -this.center.lng * Math.PI / 180), o.bi(C, C, w, this.center.lat * Math.PI / 180);
            const R = _[0] * _[0] + _[2] * _[2], L = C[0] * C[0];
            if (R < L) return;
            const k = Math.sqrt(R - L), V = -k, W = o.bn(_[0], _[2], C[0], k), Z = o.bn(_[0], _[2], C[0], V), ae = o.bg();
            o.bj(ae, _, w, -W);
            const ue = o.bn(ae[1], ae[2], C[1], C[2]), Ce = o.bg();
            o.bj(Ce, _, w, -Z);
            const Se = o.bn(Ce[1], Ce[2], C[1], C[2]), Ie = 0.5 * Math.PI, Le = ue >= -Ie && ue <= Ie, qe = Se >= -Ie && Se <= Ie;
            let $e, He;
            if (Le && qe) {
              const _t = this.center.lng * Math.PI / 180, Rt = this.center.lat * Math.PI / 180;
              o.bq(W, _t) + o.bq(ue, Rt) < o.bq(Z, _t) + o.bq(Se, Rt) ? ($e = W, He = ue) : ($e = Z, He = Se);
            } else if (Le) $e = W, He = ue;
            else {
              if (!qe) return;
              $e = Z, He = Se;
            }
            const Ze = $e / Math.PI * 180, Je = He / Math.PI * 180, vt = this.center.lat;
            this.setCenter(new o.O(Ze, o.ac(Je, -90, 90))), this.setZoom(this.zoom + Un(vt, this.center.lat));
          }
          locationToScreenPoint(a, u) {
            const g = gn(a);
            if (u) {
              const _ = u.getElevationForLngLatZoom(a, this._helper._tileZoom);
              o.aM(g, g, 1 + _ / o.bp);
            }
            return this._projectSurfacePointToScreen(g);
          }
          _projectSurfacePointToScreen(a) {
            const u = o.bf();
            return o.an(u, [...a, 1], this._globeViewProjMatrixNoCorrection), u[0] /= u[3], u[1] /= u[3], new o.P((0.5 * u[0] + 0.5) * this.width, (0.5 * -u[1] + 0.5) * this.height);
          }
          screenPointToMercatorCoordinate(a, u) {
            if (u) {
              const g = u.pointCoordinate(a);
              if (g) return g;
            }
            return o.Z.fromLngLat(this.unprojectScreenPoint(a));
          }
          screenPointToLocation(a, u) {
            var g;
            return (g = this.screenPointToMercatorCoordinate(a, u)) === null || g === void 0 ? void 0 : g.toLngLat();
          }
          isPointOnMapSurface(a, u) {
            const g = this._cameraPosition, _ = this.getRayDirectionFromPixel(a);
            return !!this.rayPlanetIntersection(g, _);
          }
          getRayDirectionFromPixel(a) {
            const u = o.bf();
            u[0] = a.x / this.width * 2 - 1, u[1] = -1 * (a.y / this.height * 2 - 1), u[2] = 1, u[3] = 1, o.an(u, u, this._globeViewProjMatrixNoCorrectionInverted), u[0] /= u[3], u[1] /= u[3], u[2] /= u[3];
            const g = o.bg();
            g[0] = u[0] - this._cameraPosition[0], g[1] = u[1] - this._cameraPosition[1], g[2] = u[2] - this._cameraPosition[2];
            const _ = o.bg();
            return o.aR(_, g), _;
          }
          isSurfacePointVisible(a) {
            const u = this._cachedClippingPlane;
            return u[0] * a[0] + u[1] * a[1] + u[2] * a[2] + u[3] >= 0;
          }
          isSurfacePointOnScreen(a) {
            if (!this.isSurfacePointVisible(a)) return !1;
            const u = o.bf();
            return o.an(u, [...a, 1], this._globeViewProjMatrixNoCorrection), u[0] /= u[3], u[1] /= u[3], u[2] /= u[3], u[0] > -1 && u[0] < 1 && u[1] > -1 && u[1] < 1 && u[2] > -1 && u[2] < 1;
          }
          rayPlanetIntersection(a, u) {
            const g = o.aT(a, u), _ = o.bg(), w = o.bg();
            o.aM(w, u, g), o.aQ(_, a, w);
            const C = 1 - o.aT(_, _);
            if (C < 0) return null;
            const R = o.aT(a, a) - 1, L = -g + (g < 0 ? 1 : -1) * Math.sqrt(C), k = R / L, V = L;
            return { tMin: Math.min(k, V), tMax: Math.max(k, V) };
          }
          unprojectScreenPoint(a) {
            const u = this._cameraPosition, g = this.getRayDirectionFromPixel(a), _ = this.rayPlanetIntersection(u, g);
            if (_) {
              const k = o.bg();
              o.aN(k, u, [g[0] * _.tMin, g[1] * _.tMin, g[2] * _.tMin]);
              const V = o.bg();
              return o.aR(V, k), ho(V);
            }
            const w = this._cachedClippingPlane[0] * g[0] + this._cachedClippingPlane[1] * g[1] + this._cachedClippingPlane[2] * g[2], C = -o.bo(this._cachedClippingPlane, u) / w, R = o.bg();
            if (C > 0) o.aN(R, u, [g[0] * C, g[1] * C, g[2] * C]);
            else {
              const k = o.bg();
              o.aN(k, u, [2 * g[0], 2 * g[1], 2 * g[2]]);
              const V = o.bo(this._cachedClippingPlane, k);
              o.aQ(R, k, [this._cachedClippingPlane[0] * V, this._cachedClippingPlane[1] * V, this._cachedClippingPlane[2] * V]);
            }
            const L = o.bg();
            return o.aR(L, R), ho(L);
          }
          getMatrixForModel(a, u) {
            const g = o.O.convert(a), _ = 1 / o.bp, w = o.a$();
            return o.bk(w, w, g.lng / 180 * Math.PI), o.aZ(w, w, -g.lat / 180 * Math.PI), o.K(w, w, [0, 0, 1 + u / o.bp]), o.aZ(w, w, 0.5 * Math.PI), o.L(w, w, [_, _, _]), w;
          }
          getProjectionDataForCustomLayer() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            const u = this.getProjectionData({ overscaledTileID: new o.X(0, 0, 0, 0, 0), applyGlobeMatrix: a });
            return u.tileMercatorCoords = [0, 0, 1, 1], u;
          }
          getFastPathSimpleProjectionMatrix(a) {
          }
        }
        class To {
          get pixelsToClipSpaceMatrix() {
            return this._helper.pixelsToClipSpaceMatrix;
          }
          get clipSpaceToPixelsMatrix() {
            return this._helper.clipSpaceToPixelsMatrix;
          }
          get pixelsToGLUnits() {
            return this._helper.pixelsToGLUnits;
          }
          get centerOffset() {
            return this._helper.centerOffset;
          }
          get size() {
            return this._helper.size;
          }
          get rotationMatrix() {
            return this._helper.rotationMatrix;
          }
          get centerPoint() {
            return this._helper.centerPoint;
          }
          get pixelsPerMeter() {
            return this._helper.pixelsPerMeter;
          }
          setMinZoom(a) {
            this._helper.setMinZoom(a);
          }
          setMaxZoom(a) {
            this._helper.setMaxZoom(a);
          }
          setMinPitch(a) {
            this._helper.setMinPitch(a);
          }
          setMaxPitch(a) {
            this._helper.setMaxPitch(a);
          }
          setRenderWorldCopies(a) {
            this._helper.setRenderWorldCopies(a);
          }
          setBearing(a) {
            this._helper.setBearing(a);
          }
          setPitch(a) {
            this._helper.setPitch(a);
          }
          setRoll(a) {
            this._helper.setRoll(a);
          }
          setFov(a) {
            this._helper.setFov(a);
          }
          setZoom(a) {
            this._helper.setZoom(a);
          }
          setCenter(a) {
            this._helper.setCenter(a);
          }
          setElevation(a) {
            this._helper.setElevation(a);
          }
          setMinElevationForCurrentTile(a) {
            this._helper.setMinElevationForCurrentTile(a);
          }
          setPadding(a) {
            this._helper.setPadding(a);
          }
          interpolatePadding(a, u, g) {
            return this._helper.interpolatePadding(a, u, g);
          }
          isPaddingEqual(a) {
            return this._helper.isPaddingEqual(a);
          }
          resize(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
            this._helper.resize(a, u, g);
          }
          getMaxBounds() {
            return this._helper.getMaxBounds();
          }
          setMaxBounds(a) {
            this._helper.setMaxBounds(a);
          }
          overrideNearFarZ(a, u) {
            this._helper.overrideNearFarZ(a, u);
          }
          clearNearFarZOverride() {
            this._helper.clearNearFarZOverride();
          }
          getCameraQueryGeometry(a) {
            return this._helper.getCameraQueryGeometry(this.getCameraPoint(), a);
          }
          get tileSize() {
            return this._helper.tileSize;
          }
          get tileZoom() {
            return this._helper.tileZoom;
          }
          get scale() {
            return this._helper.scale;
          }
          get worldSize() {
            return this._helper.worldSize;
          }
          get width() {
            return this._helper.width;
          }
          get height() {
            return this._helper.height;
          }
          get lngRange() {
            return this._helper.lngRange;
          }
          get latRange() {
            return this._helper.latRange;
          }
          get minZoom() {
            return this._helper.minZoom;
          }
          get maxZoom() {
            return this._helper.maxZoom;
          }
          get zoom() {
            return this._helper.zoom;
          }
          get center() {
            return this._helper.center;
          }
          get minPitch() {
            return this._helper.minPitch;
          }
          get maxPitch() {
            return this._helper.maxPitch;
          }
          get pitch() {
            return this._helper.pitch;
          }
          get pitchInRadians() {
            return this._helper.pitchInRadians;
          }
          get roll() {
            return this._helper.roll;
          }
          get rollInRadians() {
            return this._helper.rollInRadians;
          }
          get bearing() {
            return this._helper.bearing;
          }
          get bearingInRadians() {
            return this._helper.bearingInRadians;
          }
          get fov() {
            return this._helper.fov;
          }
          get fovInRadians() {
            return this._helper.fovInRadians;
          }
          get elevation() {
            return this._helper.elevation;
          }
          get minElevationForCurrentTile() {
            return this._helper.minElevationForCurrentTile;
          }
          get padding() {
            return this._helper.padding;
          }
          get unmodified() {
            return this._helper.unmodified;
          }
          get renderWorldCopies() {
            return this._helper.renderWorldCopies;
          }
          get cameraToCenterDistance() {
            return this._helper.cameraToCenterDistance;
          }
          get nearZ() {
            return this._helper.nearZ;
          }
          get farZ() {
            return this._helper.farZ;
          }
          get autoCalculateNearFarZ() {
            return this._helper.autoCalculateNearFarZ;
          }
          get isGlobeRendering() {
            return this._globeness > 0;
          }
          setTransitionState(a, u) {
            this._globeness = a, this._globeLatitudeErrorCorrectionRadians = u, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().recalculateCache(), this._mercatorTransform.getCoveringTilesDetailsProvider().recalculateCache();
          }
          get currentTransform() {
            return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
          }
          constructor() {
            this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new ua({ calcMatrices: () => {
              this._calcMatrices();
            }, getConstrained: (a, u) => this.getConstrained(a, u) }), this._globeness = 1, this._mercatorTransform = new qr(), this._verticalPerspectiveTransform = new Ul();
          }
          clone() {
            const a = new To();
            return a._globeness = this._globeness, a._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, a.apply(this), a;
          }
          apply(a) {
            this._helper.apply(a), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
          }
          get projectionMatrix() {
            return this.currentTransform.projectionMatrix;
          }
          get modelViewProjectionMatrix() {
            return this.currentTransform.modelViewProjectionMatrix;
          }
          get inverseProjectionMatrix() {
            return this.currentTransform.inverseProjectionMatrix;
          }
          get cameraPosition() {
            return this.currentTransform.cameraPosition;
          }
          getProjectionData(a) {
            const u = this._mercatorTransform.getProjectionData(a), g = this._verticalPerspectiveTransform.getProjectionData(a);
            return { mainMatrix: this.isGlobeRendering ? g.mainMatrix : u.mainMatrix, clippingPlane: g.clippingPlane, tileMercatorCoords: g.tileMercatorCoords, projectionTransition: a.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: u.fallbackMatrix };
          }
          isLocationOccluded(a) {
            return this.currentTransform.isLocationOccluded(a);
          }
          transformLightDirection(a) {
            return this.currentTransform.transformLightDirection(a);
          }
          getPixelScale() {
            return o.ba(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
          }
          getCircleRadiusCorrection() {
            return o.ba(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
          }
          getPitchedTextCorrection(a, u, g) {
            const _ = this._mercatorTransform.getPitchedTextCorrection(a, u, g), w = this._verticalPerspectiveTransform.getPitchedTextCorrection(a, u, g);
            return o.ba(_, w, this._globeness);
          }
          projectTileCoordinates(a, u, g, _) {
            return this.currentTransform.projectTileCoordinates(a, u, g, _);
          }
          _calcMatrices() {
            this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
          }
          calculateFogMatrix(a) {
            return this.currentTransform.calculateFogMatrix(a);
          }
          getVisibleUnwrappedCoordinates(a) {
            return this.currentTransform.getVisibleUnwrappedCoordinates(a);
          }
          getCameraFrustum() {
            return this.currentTransform.getCameraFrustum();
          }
          getClippingPlane() {
            return this.currentTransform.getClippingPlane();
          }
          getCoveringTilesDetailsProvider() {
            return this.currentTransform.getCoveringTilesDetailsProvider();
          }
          recalculateZoomAndCenter(a) {
            this._mercatorTransform.recalculateZoomAndCenter(a), this._verticalPerspectiveTransform.recalculateZoomAndCenter(a);
          }
          maxPitchScaleFactor() {
            return this._mercatorTransform.maxPitchScaleFactor();
          }
          getCameraPoint() {
            return this._helper.getCameraPoint();
          }
          getCameraAltitude() {
            return this._helper.getCameraAltitude();
          }
          getCameraLngLat() {
            return this._helper.getCameraLngLat();
          }
          lngLatToCameraDepth(a, u) {
            return this.currentTransform.lngLatToCameraDepth(a, u);
          }
          populateCache(a) {
            this._mercatorTransform.populateCache(a), this._verticalPerspectiveTransform.populateCache(a);
          }
          getBounds() {
            return this.currentTransform.getBounds();
          }
          getConstrained(a, u) {
            return this.currentTransform.getConstrained(a, u);
          }
          calculateCenterFromCameraLngLatAlt(a, u, g, _) {
            return this._helper.calculateCenterFromCameraLngLatAlt(a, u, g, _);
          }
          setLocationAtPoint(a, u) {
            if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(a, u), void this.apply(this._mercatorTransform);
            this._verticalPerspectiveTransform.setLocationAtPoint(a, u), this.apply(this._verticalPerspectiveTransform);
          }
          locationToScreenPoint(a, u) {
            return this.currentTransform.locationToScreenPoint(a, u);
          }
          screenPointToMercatorCoordinate(a, u) {
            return this.currentTransform.screenPointToMercatorCoordinate(a, u);
          }
          screenPointToLocation(a, u) {
            return this.currentTransform.screenPointToLocation(a, u);
          }
          isPointOnMapSurface(a, u) {
            return this.currentTransform.isPointOnMapSurface(a, u);
          }
          getRayDirectionFromPixel(a) {
            return this._verticalPerspectiveTransform.getRayDirectionFromPixel(a);
          }
          getMatrixForModel(a, u) {
            return this.currentTransform.getMatrixForModel(a, u);
          }
          getProjectionDataForCustomLayer() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            const u = this._mercatorTransform.getProjectionDataForCustomLayer(a);
            if (!this.isGlobeRendering) return u;
            const g = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(a);
            return g.fallbackMatrix = u.mainMatrix, g;
          }
          getFastPathSimpleProjectionMatrix(a) {
            return this.currentTransform.getFastPathSimpleProjectionMatrix(a);
          }
        }
        class ds {
          get useGlobeControls() {
            return !0;
          }
          handlePanInertia(a, u) {
            const g = kl(a, u);
            return Math.abs(g.lng - u.center.lng) > 180 && (g.lng = u.center.lng + 179.5 * Math.sign(g.lng - u.center.lng)), { easingCenter: g, easingOffset: new o.P(0, 0) };
          }
          handleMapControlsRollPitchBearingZoom(a, u) {
            const g = a.around, _ = u.screenPointToLocation(g);
            a.bearingDelta && u.setBearing(u.bearing + a.bearingDelta), a.pitchDelta && u.setPitch(u.pitch + a.pitchDelta), a.rollDelta && u.setRoll(u.roll + a.rollDelta);
            const w = u.zoom;
            a.zoomDelta && u.setZoom(u.zoom + a.zoomDelta);
            const C = u.zoom - w;
            if (C === 0) return;
            const R = o.bl(u.center.lng, _.lng), L = R / (Math.abs(R / 180) + 1), k = o.bl(u.center.lat, _.lat), V = u.getRayDirectionFromPixel(g), W = u.cameraPosition, Z = -1 * o.aT(W, V), ae = o.bg();
            o.aN(ae, W, [V[0] * Z, V[1] * Z, V[2] * Z]);
            const ue = o.br(ae) - 1, Ce = Math.exp(0.5 * -Math.max(ue - 0.3, 0)), Se = Ks(u.worldSize, u.center.lat) / Math.min(u.width, u.height), Ie = o.bd(Se, 0.9, 0.5, 1, 0.25), Le = (1 - o.aG(-C)) * Math.min(Ce, Ie), qe = u.center.lat, $e = u.zoom, He = new o.O(u.center.lng + L * Le, o.ac(u.center.lat + k * Le, -85.051129, o.aH));
            u.setLocationAtPoint(_, g);
            const Ze = u.center, Je = o.bd(Math.abs(R), 45, 85, 0, 1), vt = o.bd(Se, 0.75, 0.35, 0, 1), _t = Math.pow(Math.max(Je, vt), 0.25), Rt = o.bl(Ze.lng, He.lng), Ft = o.bl(Ze.lat, He.lat);
            u.setCenter(new o.O(Ze.lng + Rt * _t, Ze.lat + Ft * _t).wrap()), u.setZoom($e + Un(qe, u.center.lat));
          }
          handleMapControlsPan(a, u, g) {
            if (!a.panDelta) return;
            const _ = u.center.lat, w = u.zoom;
            u.setCenter(kl(a.panDelta, u).wrap()), u.setZoom(w + Un(_, u.center.lat));
          }
          cameraForBoxAndBearing(a, u, g, _, w) {
            const C = Ki(a, u, g, _, w), R = u.left / w.width * 2 - 1, L = (w.width - u.right) / w.width * 2 - 1, k = u.top / w.height * -2 + 1, V = (w.height - u.bottom) / w.height * -2 + 1, W = o.bl(g.getWest(), g.getEast()) < 0, Z = W ? g.getEast() : g.getWest(), ae = W ? g.getWest() : g.getEast(), ue = Math.max(g.getNorth(), g.getSouth()), Ce = Math.min(g.getNorth(), g.getSouth()), Se = Z + 0.5 * o.bl(Z, ae), Ie = ue + 0.5 * o.bl(ue, Ce), Le = w.clone();
            Le.setCenter(C.center), Le.setBearing(C.bearing), Le.setPitch(0), Le.setRoll(0), Le.setZoom(C.zoom);
            const qe = Le.modelViewProjectionMatrix, $e = [gn(g.getNorthWest()), gn(g.getNorthEast()), gn(g.getSouthWest()), gn(g.getSouthEast()), gn(new o.O(ae, Ie)), gn(new o.O(Z, Ie)), gn(new o.O(Se, ue)), gn(new o.O(Se, Ce))], He = gn(C.center);
            let Ze = Number.POSITIVE_INFINITY;
            for (const Je of $e) R < 0 && (Ze = ds.getLesserNonNegativeNonNull(Ze, ds.solveVectorScale(Je, He, qe, "x", R))), L > 0 && (Ze = ds.getLesserNonNegativeNonNull(Ze, ds.solveVectorScale(Je, He, qe, "x", L))), k > 0 && (Ze = ds.getLesserNonNegativeNonNull(Ze, ds.solveVectorScale(Je, He, qe, "y", k))), V < 0 && (Ze = ds.getLesserNonNegativeNonNull(Ze, ds.solveVectorScale(Je, He, qe, "y", V)));
            if (Number.isFinite(Ze) && Ze !== 0) return C.zoom = Le.zoom + o.a9(Ze), C;
            Ys();
          }
          handleJumpToCenterZoom(a, u) {
            const g = a.center.lat, _ = a.getConstrained(u.center ? o.O.convert(u.center) : a.center, a.zoom).center;
            a.setCenter(_.wrap());
            const w = u.zoom !== void 0 ? +u.zoom : a.zoom + Un(g, _.lat);
            a.zoom !== w && a.setZoom(w);
          }
          handleEaseTo(a, u) {
            const g = a.zoom, _ = a.center, w = a.padding, C = { roll: a.roll, pitch: a.pitch, bearing: a.bearing }, R = { roll: u.roll === void 0 ? a.roll : u.roll, pitch: u.pitch === void 0 ? a.pitch : u.pitch, bearing: u.bearing === void 0 ? a.bearing : u.bearing }, L = u.zoom !== void 0, k = !a.isPaddingEqual(u.padding);
            let V = !1;
            const W = u.center ? o.O.convert(u.center) : _, Z = a.getConstrained(W, g).center;
            Mi(a, Z);
            const ae = a.clone();
            ae.setCenter(Z), ae.setZoom(L ? +u.zoom : g + Un(_.lat, W.lat)), ae.setBearing(u.bearing);
            const ue = new o.P(o.ac(a.centerPoint.x + u.offsetAsPoint.x, 0, a.width), o.ac(a.centerPoint.y + u.offsetAsPoint.y, 0, a.height));
            ae.setLocationAtPoint(Z, ue);
            const Ce = (u.offset && u.offsetAsPoint.mag()) > 0 ? ae.center : Z, Se = L ? +u.zoom : g + Un(_.lat, Ce.lat), Ie = g + Un(_.lat, 0), Le = Se + Un(Ce.lat, 0), qe = o.bl(_.lng, Ce.lng), $e = o.bl(_.lat, Ce.lat), He = o.aG(Le - Ie);
            return V = Se !== g, { easeFunc: (Ze) => {
              if (o.b4(C, R) || gu({ startEulerAngles: C, endEulerAngles: R, tr: a, k: Ze, useSlerp: C.roll != R.roll }), k && a.interpolatePadding(w, u.padding, Ze), u.around) o.w("Easing around a point is not supported under globe projection."), a.setLocationAtPoint(u.around, u.aroundPoint);
              else {
                const Je = Le > Ie ? Math.min(2, He) : Math.max(0.5, He), vt = Math.pow(Je, 1 - Ze), _t = Wu(_, qe, $e, Ze * vt);
                a.setCenter(_t.wrap());
              }
              if (V) {
                const Je = o.z.number(Ie, Le, Ze) + Un(0, a.center.lat);
                a.setZoom(Je);
              }
            }, isZooming: V, elevationCenter: Ce };
          }
          handleFlyTo(a, u) {
            const g = u.zoom !== void 0, _ = a.center, w = a.zoom, C = a.padding, R = !a.isPaddingEqual(u.padding), L = a.getConstrained(o.O.convert(u.center || u.locationAtOffset), w).center, k = g ? +u.zoom : a.zoom + Un(a.center.lat, L.lat), V = a.clone();
            V.setCenter(L), V.setZoom(k), V.setBearing(u.bearing);
            const W = new o.P(o.ac(a.centerPoint.x + u.offsetAsPoint.x, 0, a.width), o.ac(a.centerPoint.y + u.offsetAsPoint.y, 0, a.height));
            V.setLocationAtPoint(L, W);
            const Z = V.center;
            Mi(a, Z);
            const ae = function($e, He, Ze) {
              const Je = gn(He), vt = gn(Ze), _t = o.aT(Je, vt), Rt = Math.acos(_t), Ft = mu($e);
              return Rt / (2 * Math.PI) * Ft;
            }(a, _, Z), ue = w + Un(_.lat, 0), Ce = k + Un(Z.lat, 0), Se = o.aG(Ce - ue);
            let Ie;
            if (typeof u.minZoom == "number") {
              const $e = +u.minZoom + Un(Z.lat, 0), He = Math.min($e, ue, Ce) + Un(0, Z.lat), Ze = a.getConstrained(Z, He).zoom + Un(Z.lat, 0);
              Ie = o.aG(Ze - ue);
            }
            const Le = o.bl(_.lng, Z.lng), qe = o.bl(_.lat, Z.lat);
            return { easeFunc: ($e, He, Ze, Je) => {
              const vt = Wu(_, Le, qe, Ze);
              R && a.interpolatePadding(C, u.padding, $e);
              const _t = $e === 1 ? Z : vt;
              a.setCenter(_t.wrap());
              const Rt = ue + o.a9(He);
              a.setZoom($e === 1 ? k : Rt + Un(0, _t.lat));
            }, scaleOfZoom: Se, targetCenter: Z, scaleOfMinZoom: Ie, pixelPathLength: ae };
          }
          static solveVectorScale(a, u, g, _, w) {
            const C = _ === "x" ? [g[0], g[4], g[8], g[12]] : [g[1], g[5], g[9], g[13]], R = [g[3], g[7], g[11], g[15]], L = a[0] * C[0] + a[1] * C[1] + a[2] * C[2], k = a[0] * R[0] + a[1] * R[1] + a[2] * R[2], V = u[0] * C[0] + u[1] * C[1] + u[2] * C[2], W = u[0] * R[0] + u[1] * R[1] + u[2] * R[2];
            return V + w * k === L + w * W || R[3] * (L - V) + C[3] * (W - k) + L * W == V * k ? null : (V + C[3] - w * W - w * R[3]) / (V - L - w * W + w * k);
          }
          static getLesserNonNegativeNonNull(a, u) {
            return u !== null && u >= 0 && u < a ? u : a;
          }
        }
        class Ma {
          constructor(a) {
            this._globe = a, this._mercatorCameraHelper = new Ll(), this._verticalPerspectiveCameraHelper = new ds();
          }
          get useGlobeControls() {
            return this._globe.useGlobeRendering;
          }
          get currentHelper() {
            return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
          }
          handlePanInertia(a, u) {
            return this.currentHelper.handlePanInertia(a, u);
          }
          handleMapControlsRollPitchBearingZoom(a, u) {
            return this.currentHelper.handleMapControlsRollPitchBearingZoom(a, u);
          }
          handleMapControlsPan(a, u, g) {
            this.currentHelper.handleMapControlsPan(a, u, g);
          }
          cameraForBoxAndBearing(a, u, g, _, w) {
            return this.currentHelper.cameraForBoxAndBearing(a, u, g, _, w);
          }
          handleJumpToCenterZoom(a, u) {
            this.currentHelper.handleJumpToCenterZoom(a, u);
          }
          handleEaseTo(a, u) {
            return this.currentHelper.handleEaseTo(a, u);
          }
          handleFlyTo(a, u) {
            return this.currentHelper.handleFlyTo(a, u);
          }
        }
        const Pa = (v, a) => o.t(v, a && a.filter((u) => u.identifier !== "source.canvas")), yu = o.bs();
        class ps extends o.E {
          constructor(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            super(), this._rtlPluginLoaded = () => {
              for (const g in this.sourceCaches) {
                const _ = this.sourceCaches[g].getSource().type;
                _ !== "vector" && _ !== "geojson" || this.sourceCaches[g].reload();
              }
            }, this.map = a, this.dispatcher = new ft(it(), a._getMapId()), this.dispatcher.registerMessageHandler("GG", (g, _) => this.getGlyphs(g, _)), this.dispatcher.registerMessageHandler("GI", (g, _) => this.getImages(g, _)), this.imageManager = new Ne(), this.imageManager.setEventedParent(this), this.glyphManager = new Me(a._requestManager, u.localIdeographFontFamily), this.lineAtlas = new Nt(256, 512), this.crossTileSymbolIndex = new hs(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new o.bt(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", o.bu()), yn().on(Wr, this._rtlPluginLoaded), this.on("data", (g) => {
              if (g.dataType !== "source" || g.sourceDataType !== "metadata") return;
              const _ = this.sourceCaches[g.sourceId];
              if (!_) return;
              const w = _.getSource();
              if (w && w.vectorLayerIds) for (const C in this._layers) {
                const R = this._layers[C];
                R.source === w.id && this._validateLayer(R);
              }
            });
          }
          loadURL(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = arguments.length > 2 ? arguments[2] : void 0;
            this.fire(new o.k("dataloading", { dataType: "style" })), u.validate = typeof u.validate != "boolean" || u.validate;
            const _ = this.map._requestManager.transformRequest(a, "Style");
            this._loadStyleRequest = new AbortController();
            const w = this._loadStyleRequest;
            o.h(_, this._loadStyleRequest).then((C) => {
              this._loadStyleRequest = null, this._load(C.data, u, g);
            }).catch((C) => {
              this._loadStyleRequest = null, C && !w.signal.aborted && this.fire(new o.j(C));
            });
          }
          loadJSON(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = arguments.length > 2 ? arguments[2] : void 0;
            this.fire(new o.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), M.frameAsync(this._frameRequest).then(() => {
              this._frameRequest = null, u.validate = u.validate !== !1, this._load(a, u, g);
            }).catch(() => {
            });
          }
          loadEmpty() {
            this.fire(new o.k("dataloading", { dataType: "style" })), this._load(yu, { validate: !1 });
          }
          _load(a, u, g) {
            var _, w;
            const C = u.transformStyle ? u.transformStyle(g, a) : a;
            if (!u.validate || !Pa(this, o.x(C))) {
              this._loaded = !0, this.stylesheet = C;
              for (const R in C.sources) this.addSource(R, C.sources[R], { validate: !1 });
              C.sprite ? this._loadSprite(C.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(C.glyphs), this._createLayers(), this.light = new Pt(this.stylesheet.light), this._setProjectionInternal(((_ = this.stylesheet.projection) === null || _ === void 0 ? void 0 : _.type) || "mercator"), this.sky = new kt(this.stylesheet.sky), this.map.setTerrain((w = this.stylesheet.terrain) !== null && w !== void 0 ? w : null), this.fire(new o.k("data", { dataType: "style" })), this.fire(new o.k("style.load"));
            }
          }
          _createLayers() {
            const a = o.bv(this.stylesheet.layers);
            this.dispatcher.broadcast("SL", a), this._order = a.map((u) => u.id), this._layers = {}, this._serializedLayers = null;
            for (const u of a) {
              const g = o.bw(u);
              g.setEventedParent(this, { layer: { id: u.id } }), this._layers[u.id] = g;
            }
          }
          _loadSprite(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, _;
            this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(w, C, R, L) {
              return o._(this, void 0, void 0, function* () {
                const k = ie(w), V = R > 1 ? "@2x" : "", W = {}, Z = {};
                for (const { id: ae, url: ue } of k) {
                  const Ce = C.transformRequest(ye(ue, V, ".json"), "SpriteJSON");
                  W[ae] = o.h(Ce, L);
                  const Se = C.transformRequest(ye(ue, V, ".png"), "SpriteImage");
                  Z[ae] = X.getImage(Se, L);
                }
                return yield Promise.all([...Object.values(W), ...Object.values(Z)]), function(ae, ue) {
                  return o._(this, void 0, void 0, function* () {
                    const Ce = {};
                    for (const Se in ae) {
                      Ce[Se] = {};
                      const Ie = M.getImageCanvasContext((yield ue[Se]).data), Le = (yield ae[Se]).data;
                      for (const qe in Le) {
                        const { width: $e, height: He, x: Ze, y: Je, sdf: vt, pixelRatio: _t, stretchX: Rt, stretchY: Ft, content: Mt, textFitWidth: sr, textFitHeight: nr } = Le[qe];
                        Ce[Se][qe] = { data: null, pixelRatio: _t, sdf: vt, stretchX: Rt, stretchY: Ft, content: Mt, textFitWidth: sr, textFitHeight: nr, spriteData: { width: $e, height: He, x: Ze, y: Je, context: Ie } };
                      }
                    }
                    return Ce;
                  });
                }(W, Z);
              });
            }(a, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((w) => {
              if (this._spriteRequest = null, w) for (const C in w) {
                this._spritesImagesIds[C] = [];
                const R = this._spritesImagesIds[C] ? this._spritesImagesIds[C].filter((L) => !(L in w)) : [];
                for (const L of R) this.imageManager.removeImage(L), this._changedImages[L] = !0;
                for (const L in w[C]) {
                  const k = C === "default" ? L : `${C}:${L}`;
                  this._spritesImagesIds[C].push(k), k in this.imageManager.images ? this.imageManager.updateImage(k, w[C][L], !1) : this.imageManager.addImage(k, w[C][L]), u && (this._changedImages[k] = !0);
                }
              }
            }).catch((w) => {
              this._spriteRequest = null, _ = w, this.fire(new o.j(_));
            }).finally(() => {
              this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), u && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" })), g && g(_);
            });
          }
          _unloadSprite() {
            for (const a of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(a), this._changedImages[a] = !0;
            this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" }));
          }
          _validateLayer(a) {
            const u = this.sourceCaches[a.source];
            if (!u) return;
            const g = a.sourceLayer;
            if (!g) return;
            const _ = u.getSource();
            (_.type === "geojson" || _.vectorLayerIds && _.vectorLayerIds.indexOf(g) === -1) && this.fire(new o.j(new Error(`Source layer "${g}" does not exist on source "${_.id}" as specified by style layer "${a.id}".`)));
          }
          loaded() {
            if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
            for (const a in this.sourceCaches) if (!this.sourceCaches[a].loaded()) return !1;
            return !!this.imageManager.isLoaded();
          }
          _serializeByIds(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            const g = this._serializedAllLayers();
            if (!a || a.length === 0) return Object.values(u ? o.bx(g) : g);
            const _ = [];
            for (const w of a) if (g[w]) {
              const C = u ? o.bx(g[w]) : g[w];
              _.push(C);
            }
            return _;
          }
          _serializedAllLayers() {
            let a = this._serializedLayers;
            if (a) return a;
            a = this._serializedLayers = {};
            const u = Object.keys(this._layers);
            for (const g of u) {
              const _ = this._layers[g];
              _.type !== "custom" && (a[g] = _.serialize());
            }
            return a;
          }
          hasTransitions() {
            var a, u, g;
            if (!((a = this.light) === null || a === void 0) && a.hasTransition() || !((u = this.sky) === null || u === void 0) && u.hasTransition() || !((g = this.projection) === null || g === void 0) && g.hasTransition()) return !0;
            for (const _ in this.sourceCaches) if (this.sourceCaches[_].hasTransition()) return !0;
            for (const _ in this._layers) if (this._layers[_].hasTransition()) return !0;
            return !1;
          }
          _checkLoaded() {
            if (!this._loaded) throw new Error("Style is not done loading.");
          }
          update(a) {
            if (!this._loaded) return;
            const u = this._changed;
            if (u) {
              const _ = Object.keys(this._updatedLayers), w = Object.keys(this._removedLayers);
              (_.length || w.length) && this._updateWorkerLayers(_, w);
              for (const C in this._updatedSources) {
                const R = this._updatedSources[C];
                if (R === "reload") this._reloadSource(C);
                else {
                  if (R !== "clear") throw new Error(`Invalid action ${R}`);
                  this._clearSource(C);
                }
              }
              this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
              for (const C in this._updatedPaintProps) this._layers[C].updateTransitions(a);
              this.light.updateTransitions(a), this.sky.updateTransitions(a), this._resetUpdates();
            }
            const g = {};
            for (const _ in this.sourceCaches) {
              const w = this.sourceCaches[_];
              g[_] = w.used, w.used = !1;
            }
            for (const _ of this._order) {
              const w = this._layers[_];
              w.recalculate(a, this._availableImages), !w.isHidden(a.zoom) && w.source && (this.sourceCaches[w.source].used = !0);
            }
            for (const _ in g) {
              const w = this.sourceCaches[_];
              !!g[_] != !!w.used && w.fire(new o.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: _ }));
            }
            this.light.recalculate(a), this.sky.recalculate(a), this.projection.recalculate(a), this.z = a.zoom, u && this.fire(new o.k("data", { dataType: "style" }));
          }
          _updateTilesForChangedImages() {
            const a = Object.keys(this._changedImages);
            if (a.length) {
              for (const u in this.sourceCaches) this.sourceCaches[u].reloadTilesForDependencies(["icons", "patterns"], a);
              this._changedImages = {};
            }
          }
          _updateTilesForChangedGlyphs() {
            if (this._glyphsDidChange) {
              for (const a in this.sourceCaches) this.sourceCaches[a].reloadTilesForDependencies(["glyphs"], [""]);
              this._glyphsDidChange = !1;
            }
          }
          _updateWorkerLayers(a, u) {
            this.dispatcher.broadcast("UL", { layers: this._serializeByIds(a, !1), removedIds: u });
          }
          _resetUpdates() {
            this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
          }
          setState(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            var g;
            this._checkLoaded();
            const _ = this.serialize();
            if (a = u.transformStyle ? u.transformStyle(_, a) : a, ((g = u.validate) === null || g === void 0 || g) && Pa(this, o.x(a))) return !1;
            (a = o.bx(a)).layers = o.bv(a.layers);
            const w = o.by(_, a), C = this._getOperationsToPerform(w);
            if (C.unimplemented.length > 0) throw new Error(`Unimplemented: ${C.unimplemented.join(", ")}.`);
            if (C.operations.length === 0) return !1;
            for (const R of C.operations) R();
            return this.stylesheet = a, this._serializedLayers = null, !0;
          }
          _getOperationsToPerform(a) {
            const u = [], g = [];
            for (const _ of a) switch (_.command) {
              case "setCenter":
              case "setZoom":
              case "setBearing":
              case "setPitch":
              case "setRoll":
                continue;
              case "addLayer":
                u.push(() => this.addLayer.apply(this, _.args));
                break;
              case "removeLayer":
                u.push(() => this.removeLayer.apply(this, _.args));
                break;
              case "setPaintProperty":
                u.push(() => this.setPaintProperty.apply(this, _.args));
                break;
              case "setLayoutProperty":
                u.push(() => this.setLayoutProperty.apply(this, _.args));
                break;
              case "setFilter":
                u.push(() => this.setFilter.apply(this, _.args));
                break;
              case "addSource":
                u.push(() => this.addSource.apply(this, _.args));
                break;
              case "removeSource":
                u.push(() => this.removeSource.apply(this, _.args));
                break;
              case "setLayerZoomRange":
                u.push(() => this.setLayerZoomRange.apply(this, _.args));
                break;
              case "setLight":
                u.push(() => this.setLight.apply(this, _.args));
                break;
              case "setGeoJSONSourceData":
                u.push(() => this.setGeoJSONSourceData.apply(this, _.args));
                break;
              case "setGlyphs":
                u.push(() => this.setGlyphs.apply(this, _.args));
                break;
              case "setSprite":
                u.push(() => this.setSprite.apply(this, _.args));
                break;
              case "setTerrain":
                u.push(() => this.map.setTerrain.apply(this, _.args));
                break;
              case "setSky":
                u.push(() => this.setSky.apply(this, _.args));
                break;
              case "setProjection":
                this.setProjection.apply(this, _.args);
                break;
              case "setTransition":
                u.push(() => {
                });
                break;
              default:
                g.push(_.command);
            }
            return { operations: u, unimplemented: g };
          }
          addImage(a, u) {
            if (this.getImage(a)) return this.fire(new o.j(new Error(`An image named "${a}" already exists.`)));
            this.imageManager.addImage(a, u), this._afterImageUpdated(a);
          }
          updateImage(a, u) {
            this.imageManager.updateImage(a, u);
          }
          getImage(a) {
            return this.imageManager.getImage(a);
          }
          removeImage(a) {
            if (!this.getImage(a)) return this.fire(new o.j(new Error(`An image named "${a}" does not exist.`)));
            this.imageManager.removeImage(a), this._afterImageUpdated(a);
          }
          _afterImageUpdated(a) {
            this._availableImages = this.imageManager.listImages(), this._changedImages[a] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" }));
          }
          listImages() {
            return this._checkLoaded(), this.imageManager.listImages();
          }
          addSource(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            if (this._checkLoaded(), this.sourceCaches[a] !== void 0) throw new Error(`Source "${a}" already exists.`);
            if (!u.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(u).join(", ")}.`);
            if (["vector", "raster", "geojson", "video", "image"].indexOf(u.type) >= 0 && this._validate(o.x.source, `sources.${a}`, u, null, g)) return;
            this.map && this.map._collectResourceTiming && (u.collectResourceTiming = !0);
            const _ = this.sourceCaches[a] = new se(a, u, this.dispatcher);
            _.style = this, _.setEventedParent(this, () => ({ isSourceLoaded: _.loaded(), source: _.serialize(), sourceId: a })), _.onAdd(this.map), this._changed = !0;
          }
          removeSource(a) {
            if (this._checkLoaded(), this.sourceCaches[a] === void 0) throw new Error("There is no source with this ID");
            for (const g in this._layers) if (this._layers[g].source === a) return this.fire(new o.j(new Error(`Source "${a}" cannot be removed while layer "${g}" is using it.`)));
            const u = this.sourceCaches[a];
            delete this.sourceCaches[a], delete this._updatedSources[a], u.fire(new o.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: a })), u.setEventedParent(null), u.onRemove(this.map), this._changed = !0;
          }
          setGeoJSONSourceData(a, u) {
            if (this._checkLoaded(), this.sourceCaches[a] === void 0) throw new Error(`There is no source with this ID=${a}`);
            const g = this.sourceCaches[a].getSource();
            if (g.type !== "geojson") throw new Error(`geojsonSource.type is ${g.type}, which is !== 'geojson`);
            g.setData(u), this._changed = !0;
          }
          getSource(a) {
            return this.sourceCaches[a] && this.sourceCaches[a].getSource();
          }
          addLayer(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            this._checkLoaded();
            const _ = a.id;
            if (this.getLayer(_)) return void this.fire(new o.j(new Error(`Layer "${_}" already exists on this map.`)));
            let w;
            if (a.type === "custom") {
              if (Pa(this, o.bz(a))) return;
              w = o.bw(a);
            } else {
              if ("source" in a && typeof a.source == "object" && (this.addSource(_, a.source), a = o.bx(a), a = o.e(a, { source: _ })), this._validate(o.x.layer, `layers.${_}`, a, { arrayIndex: -1 }, g)) return;
              w = o.bw(a), this._validateLayer(w), w.setEventedParent(this, { layer: { id: _ } });
            }
            const C = u ? this._order.indexOf(u) : this._order.length;
            if (u && C === -1) this.fire(new o.j(new Error(`Cannot add layer "${_}" before non-existing layer "${u}".`)));
            else {
              if (this._order.splice(C, 0, _), this._layerOrderChanged = !0, this._layers[_] = w, this._removedLayers[_] && w.source && w.type !== "custom") {
                const R = this._removedLayers[_];
                delete this._removedLayers[_], R.type !== w.type ? this._updatedSources[w.source] = "clear" : (this._updatedSources[w.source] = "reload", this.sourceCaches[w.source].pause());
              }
              this._updateLayer(w), w.onAdd && w.onAdd(this.map);
            }
          }
          moveLayer(a, u) {
            if (this._checkLoaded(), this._changed = !0, !this._layers[a]) return void this.fire(new o.j(new Error(`The layer '${a}' does not exist in the map's style and cannot be moved.`)));
            if (a === u) return;
            const g = this._order.indexOf(a);
            this._order.splice(g, 1);
            const _ = u ? this._order.indexOf(u) : this._order.length;
            u && _ === -1 ? this.fire(new o.j(new Error(`Cannot move layer "${a}" before non-existing layer "${u}".`))) : (this._order.splice(_, 0, a), this._layerOrderChanged = !0);
          }
          removeLayer(a) {
            this._checkLoaded();
            const u = this._layers[a];
            if (!u) return void this.fire(new o.j(new Error(`Cannot remove non-existing layer "${a}".`)));
            u.setEventedParent(null);
            const g = this._order.indexOf(a);
            this._order.splice(g, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[a] = u, delete this._layers[a], this._serializedLayers && delete this._serializedLayers[a], delete this._updatedLayers[a], delete this._updatedPaintProps[a], u.onRemove && u.onRemove(this.map);
          }
          getLayer(a) {
            return this._layers[a];
          }
          getLayersOrder() {
            return [...this._order];
          }
          hasLayer(a) {
            return a in this._layers;
          }
          setLayerZoomRange(a, u, g) {
            this._checkLoaded();
            const _ = this.getLayer(a);
            _ ? _.minzoom === u && _.maxzoom === g || (u != null && (_.minzoom = u), g != null && (_.maxzoom = g), this._updateLayer(_)) : this.fire(new o.j(new Error(`Cannot set the zoom range of non-existing layer "${a}".`)));
          }
          setFilter(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            this._checkLoaded();
            const _ = this.getLayer(a);
            if (_) {
              if (!o.bA(_.filter, u)) return u == null ? (_.filter = void 0, void this._updateLayer(_)) : void (this._validate(o.x.filter, `layers.${_.id}.filter`, u, null, g) || (_.filter = o.bx(u), this._updateLayer(_)));
            } else this.fire(new o.j(new Error(`Cannot filter non-existing layer "${a}".`)));
          }
          getFilter(a) {
            return o.bx(this.getLayer(a).filter);
          }
          setLayoutProperty(a, u, g) {
            let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            this._checkLoaded();
            const w = this.getLayer(a);
            w ? o.bA(w.getLayoutProperty(u), g) || (w.setLayoutProperty(u, g, _), this._updateLayer(w)) : this.fire(new o.j(new Error(`Cannot style non-existing layer "${a}".`)));
          }
          getLayoutProperty(a, u) {
            const g = this.getLayer(a);
            if (g) return g.getLayoutProperty(u);
            this.fire(new o.j(new Error(`Cannot get style of non-existing layer "${a}".`)));
          }
          setPaintProperty(a, u, g) {
            let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            this._checkLoaded();
            const w = this.getLayer(a);
            w ? o.bA(w.getPaintProperty(u), g) || (w.setPaintProperty(u, g, _) && this._updateLayer(w), this._changed = !0, this._updatedPaintProps[a] = !0, this._serializedLayers = null) : this.fire(new o.j(new Error(`Cannot style non-existing layer "${a}".`)));
          }
          getPaintProperty(a, u) {
            return this.getLayer(a).getPaintProperty(u);
          }
          setFeatureState(a, u) {
            this._checkLoaded();
            const g = a.source, _ = a.sourceLayer, w = this.sourceCaches[g];
            if (w === void 0) return void this.fire(new o.j(new Error(`The source '${g}' does not exist in the map's style.`)));
            const C = w.getSource().type;
            C === "geojson" && _ ? this.fire(new o.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : C !== "vector" || _ ? (a.id === void 0 && this.fire(new o.j(new Error("The feature id parameter must be provided."))), w.setFeatureState(_, a.id, u)) : this.fire(new o.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          removeFeatureState(a, u) {
            this._checkLoaded();
            const g = a.source, _ = this.sourceCaches[g];
            if (_ === void 0) return void this.fire(new o.j(new Error(`The source '${g}' does not exist in the map's style.`)));
            const w = _.getSource().type, C = w === "vector" ? a.sourceLayer : void 0;
            w !== "vector" || C ? u && typeof a.id != "string" && typeof a.id != "number" ? this.fire(new o.j(new Error("A feature id is required to remove its specific state property."))) : _.removeFeatureState(C, a.id, u) : this.fire(new o.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          }
          getFeatureState(a) {
            this._checkLoaded();
            const u = a.source, g = a.sourceLayer, _ = this.sourceCaches[u];
            if (_ !== void 0) return _.getSource().type !== "vector" || g ? (a.id === void 0 && this.fire(new o.j(new Error("The feature id parameter must be provided."))), _.getFeatureState(g, a.id)) : void this.fire(new o.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
            this.fire(new o.j(new Error(`The source '${u}' does not exist in the map's style.`)));
          }
          getTransition() {
            return o.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
          }
          serialize() {
            if (!this._loaded) return;
            const a = o.bB(this.sourceCaches, (w) => w.serialize()), u = this._serializeByIds(this._order, !0), g = this.map.getTerrain() || void 0, _ = this.stylesheet;
            return o.bC({ version: _.version, name: _.name, metadata: _.metadata, light: _.light, sky: _.sky, center: _.center, zoom: _.zoom, bearing: _.bearing, pitch: _.pitch, sprite: _.sprite, glyphs: _.glyphs, transition: _.transition, projection: _.projection, sources: a, layers: u, terrain: g }, (w) => w !== void 0);
          }
          _updateLayer(a) {
            this._updatedLayers[a.id] = !0, a.source && !this._updatedSources[a.source] && this.sourceCaches[a.source].getSource().type !== "raster" && (this._updatedSources[a.source] = "reload", this.sourceCaches[a.source].pause()), this._serializedLayers = null, this._changed = !0;
          }
          _flattenAndSortRenderedFeatures(a) {
            const u = (C) => this._layers[C].type === "fill-extrusion", g = {}, _ = [];
            for (let C = this._order.length - 1; C >= 0; C--) {
              const R = this._order[C];
              if (u(R)) {
                g[R] = C;
                for (const L of a) {
                  const k = L[R];
                  if (k) for (const V of k) _.push(V);
                }
              }
            }
            _.sort((C, R) => R.intersectionZ - C.intersectionZ);
            const w = [];
            for (let C = this._order.length - 1; C >= 0; C--) {
              const R = this._order[C];
              if (u(R)) for (let L = _.length - 1; L >= 0; L--) {
                const k = _[L].feature;
                if (g[k.layer.id] < C) break;
                w.push(k), _.pop();
              }
              else for (const L of a) {
                const k = L[R];
                if (k) for (const V of k) w.push(V.feature);
              }
            }
            return w;
          }
          queryRenderedFeatures(a, u, g) {
            u && u.filter && this._validate(o.x.filter, "queryRenderedFeatures.filter", u.filter, null, u);
            const _ = {};
            if (u && u.layers) {
              if (!(Array.isArray(u.layers) || u.layers instanceof Set)) return this.fire(new o.j(new Error("parameters.layers must be an Array or a Set of strings"))), [];
              for (const k of u.layers) {
                const V = this._layers[k];
                if (!V) return this.fire(new o.j(new Error(`The layer '${k}' does not exist in the map's style and cannot be queried for features.`))), [];
                _[V.source] = !0;
              }
            }
            const w = [];
            u.availableImages = this._availableImages;
            const C = this._serializedAllLayers(), R = u.layers instanceof Set ? u.layers : Array.isArray(u.layers) ? new Set(u.layers) : null, L = Object.assign(Object.assign({}, u), { layers: R });
            for (const k in this.sourceCaches) u.layers && !_[k] || w.push(ar(this.sourceCaches[k], this._layers, C, a, L, g));
            return this.placement && w.push(function(k, V, W, Z, ae, ue, Ce) {
              const Se = {}, Ie = ue.queryRenderedSymbols(Z), Le = [];
              for (const qe of Object.keys(Ie).map(Number)) Le.push(Ce[qe]);
              Le.sort(Yt);
              for (const qe of Le) {
                const $e = qe.featureIndex.lookupSymbolFeatures(Ie[qe.bucketInstanceId], V, qe.bucketIndex, qe.sourceLayerIndex, ae.filter, ae.layers, ae.availableImages, k);
                for (const He in $e) {
                  const Ze = Se[He] = Se[He] || [], Je = $e[He];
                  Je.sort((vt, _t) => {
                    const Rt = qe.featureSortOrder;
                    if (Rt) {
                      const Ft = Rt.indexOf(vt.featureIndex);
                      return Rt.indexOf(_t.featureIndex) - Ft;
                    }
                    return _t.featureIndex - vt.featureIndex;
                  });
                  for (const vt of Je) Ze.push(vt);
                }
              }
              return function(qe, $e, He) {
                for (const Ze in qe) for (const Je of qe[Ze]) cr(Je, He[$e[Ze].source]);
                return qe;
              }(Se, k, W);
            }(this._layers, C, this.sourceCaches, a, L, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(w);
          }
          querySourceFeatures(a, u) {
            u && u.filter && this._validate(o.x.filter, "querySourceFeatures.filter", u.filter, null, u);
            const g = this.sourceCaches[a];
            return g ? function(_, w) {
              const C = _.getRenderableIds().map((k) => _.getTileByID(k)), R = [], L = {};
              for (let k = 0; k < C.length; k++) {
                const V = C[k], W = V.tileID.canonical.key;
                L[W] || (L[W] = !0, V.querySourceFeatures(R, w));
              }
              return R;
            }(g, u) : [];
          }
          getLight() {
            return this.light.getLight();
          }
          setLight(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this._checkLoaded();
            const g = this.light.getLight();
            let _ = !1;
            for (const C in a) if (!o.bA(a[C], g[C])) {
              _ = !0;
              break;
            }
            if (!_) return;
            const w = { now: M.now(), transition: o.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.light.setLight(a, u), this.light.updateTransitions(w);
          }
          getProjection() {
            var a;
            return (a = this.stylesheet) === null || a === void 0 ? void 0 : a.projection;
          }
          setProjection(a) {
            if (this._checkLoaded(), this.projection) {
              if (this.projection.name === a.type) return;
              this.projection.destroy(), delete this.projection;
            }
            this.stylesheet.projection = a, this._setProjectionInternal(a.type);
          }
          getSky() {
            var a;
            return (a = this.stylesheet) === null || a === void 0 ? void 0 : a.sky;
          }
          setSky(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this._checkLoaded();
            const g = this.getSky();
            let _ = !1;
            if (!a && !g) return;
            if (a && !g) _ = !0;
            else if (!a && g) _ = !0;
            else for (const C in a) if (!o.bA(a[C], g[C])) {
              _ = !0;
              break;
            }
            if (!_) return;
            const w = { now: M.now(), transition: o.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
            this.stylesheet.sky = a, this.sky.setSky(a, u), this.sky.updateTransitions(w);
          }
          _setProjectionInternal(a) {
            const u = function(g) {
              if (Array.isArray(g)) {
                const _ = new kc({ type: g });
                return { projection: _, transform: new To(), cameraHelper: new Ma(_) };
              }
              switch (g) {
                case "mercator":
                  return { projection: new sl(), transform: new qr(), cameraHelper: new Ll() };
                case "globe": {
                  const _ = new kc({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                  return { projection: _, transform: new To(), cameraHelper: new Ma(_) };
                }
                case "vertical-perspective":
                  return { projection: new Dl(), transform: new Ul(), cameraHelper: new ds() };
                default:
                  return o.w(`Unknown projection name: ${g}. Falling back to mercator projection.`), { projection: new sl(), transform: new qr(), cameraHelper: new Ll() };
              }
            }(a);
            this.projection = u.projection, this.map.migrateProjection(u.transform, u.cameraHelper);
            for (const g in this.sourceCaches) this.sourceCaches[g].reload();
          }
          _validate(a, u, g, _) {
            let w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
            return (!w || w.validate !== !1) && Pa(this, a.call(o.x, o.e({ key: u, style: this.serialize(), value: g, styleSpec: o.v }, _)));
          }
          _remove() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), yn().off(Wr, this._rtlPluginLoaded);
            for (const u in this._layers) this._layers[u].setEventedParent(null);
            for (const u in this.sourceCaches) {
              const g = this.sourceCaches[u];
              g.setEventedParent(null), g.onRemove(this.map);
            }
            this.imageManager.setEventedParent(null), this.setEventedParent(null), a && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(a);
          }
          _clearSource(a) {
            this.sourceCaches[a].clearTiles();
          }
          _reloadSource(a) {
            this.sourceCaches[a].resume(), this.sourceCaches[a].reload();
          }
          _updateSources(a) {
            for (const u in this.sourceCaches) this.sourceCaches[u].update(a, this.map.terrain);
          }
          _generateCollisionBoxes() {
            for (const a in this.sourceCaches) this._reloadSource(a);
          }
          _updatePlacement(a, u, g, _) {
            let w = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, C = !1, R = !1;
            const L = {};
            for (const k of this._order) {
              const V = this._layers[k];
              if (V.type !== "symbol") continue;
              if (!L[V.source]) {
                const Z = this.sourceCaches[V.source];
                L[V.source] = Z.getRenderableIds(!0).map((ae) => Z.getTileByID(ae)).sort((ae, ue) => ue.tileID.overscaledZ - ae.tileID.overscaledZ || (ae.tileID.isLessThan(ue.tileID) ? -1 : 1));
              }
              const W = this.crossTileSymbolIndex.addLayer(V, L[V.source], a.center.lng);
              C = C || W;
            }
            if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((w = w || this._layerOrderChanged || g === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(M.now(), a.zoom)) && (this.pauseablePlacement = new du(a, this.map.terrain, this._order, w, u, g, _, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, L), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(M.now()), R = !0), C && this.pauseablePlacement.placement.setStale()), R || C) for (const k of this._order) {
              const V = this._layers[k];
              V.type === "symbol" && this.placement.updateLayerOpacities(V, L[V.source]);
            }
            return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(M.now());
          }
          _releaseSymbolFadeTiles() {
            for (const a in this.sourceCaches) this.sourceCaches[a].releaseSymbolFadeTiles();
          }
          getImages(a, u) {
            return o._(this, void 0, void 0, function* () {
              const g = yield this.imageManager.getImages(u.icons);
              this._updateTilesForChangedImages();
              const _ = this.sourceCaches[u.source];
              return _ && _.setDependencies(u.tileID.key, u.type, u.icons), g;
            });
          }
          getGlyphs(a, u) {
            return o._(this, void 0, void 0, function* () {
              const g = yield this.glyphManager.getGlyphs(u.stacks), _ = this.sourceCaches[u.source];
              return _ && _.setDependencies(u.tileID.key, u.type, [""]), g;
            });
          }
          getGlyphsUrl() {
            return this.stylesheet.glyphs || null;
          }
          setGlyphs(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            this._checkLoaded(), a && this._validate(o.x.glyphs, "glyphs", a, null, u) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = a, this.glyphManager.entries = {}, this.glyphManager.setURL(a));
          }
          addSprite(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ = arguments.length > 3 ? arguments[3] : void 0;
            this._checkLoaded();
            const w = [{ id: a, url: u }], C = [...ie(this.stylesheet.sprite), ...w];
            this._validate(o.x.sprite, "sprite", C, null, g) || (this.stylesheet.sprite = C, this._loadSprite(w, !0, _));
          }
          removeSprite(a) {
            this._checkLoaded();
            const u = ie(this.stylesheet.sprite);
            if (u.find((g) => g.id === a)) {
              if (this._spritesImagesIds[a]) for (const g of this._spritesImagesIds[a]) this.imageManager.removeImage(g), this._changedImages[g] = !0;
              u.splice(u.findIndex((g) => g.id === a), 1), this.stylesheet.sprite = u.length > 0 ? u : void 0, delete this._spritesImagesIds[a], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new o.k("data", { dataType: "style" }));
            } else this.fire(new o.j(new Error(`Sprite "${a}" doesn't exists on this map.`)));
          }
          getSprite() {
            return ie(this.stylesheet.sprite);
          }
          setSprite(a) {
            let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = arguments.length > 2 ? arguments[2] : void 0;
            this._checkLoaded(), a && this._validate(o.x.sprite, "sprite", a, null, u) || (this.stylesheet.sprite = a, a ? this._loadSprite(a, !0, g) : (this._unloadSprite(), g && g(null)));
          }
        }
        var zl = o.aB([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
        class jl {
          constructor() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          }
          bind(a, u, g, _, w, C, R, L, k) {
            this.context = a;
            let V = this.boundPaintVertexBuffers.length !== _.length;
            for (let W = 0; !V && W < _.length; W++) this.boundPaintVertexBuffers[W] !== _[W] && (V = !0);
            !this.vao || this.boundProgram !== u || this.boundLayoutVertexBuffer !== g || V || this.boundIndexBuffer !== w || this.boundVertexOffset !== C || this.boundDynamicVertexBuffer !== R || this.boundDynamicVertexBuffer2 !== L || this.boundDynamicVertexBuffer3 !== k ? this.freshBind(u, g, _, w, C, R, L, k) : (a.bindVertexArray.set(this.vao), R && R.bind(), w && w.dynamicDraw && w.bind(), L && L.bind(), k && k.bind());
          }
          freshBind(a, u, g, _, w, C, R, L) {
            const k = a.numAttributes, V = this.context, W = V.gl;
            this.vao && this.destroy(), this.vao = V.createVertexArray(), V.bindVertexArray.set(this.vao), this.boundProgram = a, this.boundLayoutVertexBuffer = u, this.boundPaintVertexBuffers = g, this.boundIndexBuffer = _, this.boundVertexOffset = w, this.boundDynamicVertexBuffer = C, this.boundDynamicVertexBuffer2 = R, this.boundDynamicVertexBuffer3 = L, u.enableAttributes(W, a);
            for (const Z of g) Z.enableAttributes(W, a);
            C && C.enableAttributes(W, a), R && R.enableAttributes(W, a), L && L.enableAttributes(W, a), u.bind(), u.setVertexAttribPointers(W, a, w);
            for (const Z of g) Z.bind(), Z.setVertexAttribPointers(W, a, w);
            C && (C.bind(), C.setVertexAttribPointers(W, a, w)), _ && _.bind(), R && (R.bind(), R.setVertexAttribPointers(W, a, w)), L && (L.bind(), L.setVertexAttribPointers(W, a, w)), V.currentNumAttributes = k;
          }
          destroy() {
            this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
          }
        }
        const So = (v, a, u, g, _) => ({ u_texture: 0, u_ele_delta: v, u_fog_matrix: a, u_fog_color: u ? u.properties.get("fog-color") : o.b5.white, u_fog_ground_blend: u ? u.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: _ ? 0 : u ? u.calculateFogBlendOpacity(g) : 0, u_horizon_color: u ? u.properties.get("horizon-color") : o.b5.white, u_horizon_fog_blend: u ? u.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: _ ? 1 : 0 }), Ra = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
        function O(v) {
          const a = [];
          for (let u = 0; u < v.length; u++) {
            if (v[u] === null) continue;
            const g = v[u].split(" ");
            a.push(g.pop());
          }
          return a;
        }
        class ne {
          constructor(a, u, g, _, w, C, R, L) {
            const k = a.gl;
            this.program = k.createProgram();
            const V = O(u.staticAttributes), W = g ? g.getBinderAttributes() : [], Z = V.concat(W), ae = gi.prelude.staticUniforms ? O(gi.prelude.staticUniforms) : [], ue = R.staticUniforms ? O(R.staticUniforms) : [], Ce = u.staticUniforms ? O(u.staticUniforms) : [], Se = g ? g.getBinderUniforms() : [], Ie = ae.concat(ue).concat(Ce).concat(Se), Le = [];
            for (const _t of Ie) Le.indexOf(_t) < 0 && Le.push(_t);
            const qe = g ? g.defines() : [];
            fs(k) && qe.unshift("#version 300 es"), w && qe.push("#define OVERDRAW_INSPECTOR;"), C && qe.push("#define TERRAIN3D;"), L && qe.push(L);
            let $e = qe.concat(gi.prelude.fragmentSource, R.fragmentSource, u.fragmentSource).join(`
`), He = qe.concat(gi.prelude.vertexSource, R.vertexSource, u.vertexSource).join(`
`);
            fs(k) || ($e = function(_t) {
              return _t.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
            }($e), He = function(_t) {
              return _t.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
            }(He));
            const Ze = k.createShader(k.FRAGMENT_SHADER);
            if (k.isContextLost()) return void (this.failedToCreate = !0);
            if (k.shaderSource(Ze, $e), k.compileShader(Ze), !k.getShaderParameter(Ze, k.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${k.getShaderInfoLog(Ze)}`);
            k.attachShader(this.program, Ze);
            const Je = k.createShader(k.VERTEX_SHADER);
            if (k.isContextLost()) return void (this.failedToCreate = !0);
            if (k.shaderSource(Je, He), k.compileShader(Je), !k.getShaderParameter(Je, k.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${k.getShaderInfoLog(Je)}`);
            k.attachShader(this.program, Je), this.attributes = {};
            const vt = {};
            this.numAttributes = Z.length;
            for (let _t = 0; _t < this.numAttributes; _t++) Z[_t] && (k.bindAttribLocation(this.program, _t, Z[_t]), this.attributes[Z[_t]] = _t);
            if (k.linkProgram(this.program), !k.getProgramParameter(this.program, k.LINK_STATUS)) throw new Error(`Program failed to link: ${k.getProgramInfoLog(this.program)}`);
            k.deleteShader(Je), k.deleteShader(Ze);
            for (let _t = 0; _t < Le.length; _t++) {
              const Rt = Le[_t];
              if (Rt && !vt[Rt]) {
                const Ft = k.getUniformLocation(this.program, Rt);
                Ft && (vt[Rt] = Ft);
              }
            }
            this.fixedUniforms = _(a, vt), this.terrainUniforms = ((_t, Rt) => ({ u_depth: new o.bD(_t, Rt.u_depth), u_terrain: new o.bD(_t, Rt.u_terrain), u_terrain_dim: new o.b6(_t, Rt.u_terrain_dim), u_terrain_matrix: new o.bF(_t, Rt.u_terrain_matrix), u_terrain_unpack: new o.bG(_t, Rt.u_terrain_unpack), u_terrain_exaggeration: new o.b6(_t, Rt.u_terrain_exaggeration) }))(a, vt), this.projectionUniforms = ((_t, Rt) => ({ u_projection_matrix: new o.bF(_t, Rt.u_projection_matrix), u_projection_tile_mercator_coords: new o.bG(_t, Rt.u_projection_tile_mercator_coords), u_projection_clipping_plane: new o.bG(_t, Rt.u_projection_clipping_plane), u_projection_transition: new o.b6(_t, Rt.u_projection_transition), u_projection_fallback_matrix: new o.bF(_t, Rt.u_projection_fallback_matrix) }))(a, vt), this.binderUniforms = g ? g.getUniforms(a, vt) : [];
          }
          draw(a, u, g, _, w, C, R, L, k, V, W, Z, ae, ue, Ce, Se, Ie, Le, qe) {
            const $e = a.gl;
            if (this.failedToCreate) return;
            if (a.program.set(this.program), a.setDepthMode(g), a.setStencilMode(_), a.setColorMode(w), a.setCullFace(C), L) {
              a.activeTexture.set($e.TEXTURE2), $e.bindTexture($e.TEXTURE_2D, L.depthTexture), a.activeTexture.set($e.TEXTURE3), $e.bindTexture($e.TEXTURE_2D, L.texture);
              for (const Ze in this.terrainUniforms) this.terrainUniforms[Ze].set(L[Ze]);
            }
            if (k) for (const Ze in k) this.projectionUniforms[Ra[Ze]].set(k[Ze]);
            if (R) for (const Ze in this.fixedUniforms) this.fixedUniforms[Ze].set(R[Ze]);
            Se && Se.setUniforms(a, this.binderUniforms, ue, { zoom: Ce });
            let He = 0;
            switch (u) {
              case $e.LINES:
                He = 2;
                break;
              case $e.TRIANGLES:
                He = 3;
                break;
              case $e.LINE_STRIP:
                He = 1;
            }
            for (const Ze of ae.get()) {
              const Je = Ze.vaos || (Ze.vaos = {});
              (Je[V] || (Je[V] = new jl())).bind(a, this, W, Se ? Se.getPaintVertexBuffers() : [], Z, Ze.vertexOffset, Ie, Le, qe), $e.drawElements(u, Ze.primitiveLength * He, $e.UNSIGNED_SHORT, Ze.primitiveOffset * He * 2);
            }
          }
        }
        function De(v, a, u) {
          const g = 1 / o.au(u, 1, a.transform.tileZoom), _ = Math.pow(2, u.tileID.overscaledZ), w = u.tileSize * Math.pow(2, a.transform.tileZoom) / _, C = w * (u.tileID.canonical.x + u.tileID.wrap * _), R = w * u.tileID.canonical.y;
          return { u_image: 0, u_texsize: u.imageAtlasTexture.size, u_scale: [g, v.fromScale, v.toScale], u_fade: v.t, u_pixel_coord_upper: [C >> 16, R >> 16], u_pixel_coord_lower: [65535 & C, 65535 & R] };
        }
        const Ke = (v, a, u, g) => {
          const _ = v.style.light, w = _.properties.get("position"), C = [w.x, w.y, w.z], R = o.bJ();
          _.properties.get("anchor") === "viewport" && o.bK(R, v.transform.bearingInRadians), o.bL(C, C, R);
          const L = v.transform.transformLightDirection(C), k = _.properties.get("color");
          return { u_lightpos: C, u_lightpos_globe: L, u_lightintensity: _.properties.get("intensity"), u_lightcolor: [k.r, k.g, k.b], u_vertical_gradient: +a, u_opacity: u, u_fill_translate: g };
        }, mt = (v, a, u, g, _, w, C) => o.e(Ke(v, a, u, g), De(w, v, C), { u_height_factor: -Math.pow(2, _.overscaledZ) / C.tileSize / 8 }), zt = (v, a, u, g) => o.e(De(a, v, u), { u_fill_translate: g }), tr = (v, a) => ({ u_world: v, u_fill_translate: a }), Tr = (v, a, u, g, _) => o.e(zt(v, a, u, _), { u_world: g }), kr = (v, a, u, g, _) => {
          const w = v.transform;
          let C, R, L = 0;
          if (u.paint.get("circle-pitch-alignment") === "map") {
            const k = o.au(a, 1, w.zoom);
            C = !0, R = [k, k], L = k / (o.Y * Math.pow(2, a.tileID.overscaledZ)) * 2 * Math.PI * _;
          } else C = !1, R = w.pixelsToGLUnits;
          return { u_camera_to_center_distance: w.cameraToCenterDistance, u_scale_with_map: +(u.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +C, u_device_pixel_ratio: v.pixelRatio, u_extrude_scale: R, u_globe_extrude_scale: L, u_translate: g };
        }, tn = (v) => ({ u_pixel_extrude_scale: [1 / v.width, 1 / v.height] }), Kr = (v) => ({ u_viewport_size: [v.width, v.height] }), xn = function(v) {
          let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
          return { u_color: v, u_overlay: 0, u_overlay_scale: a };
        }, ti = (v, a, u, g) => {
          const _ = o.au(v, 1, a) / (o.Y * Math.pow(2, v.tileID.overscaledZ)) * 2 * Math.PI * g;
          return { u_extrude_scale: o.au(v, 1, a), u_intensity: u, u_globe_extrude_scale: _ };
        }, Gn = (v, a, u, g) => {
          const _ = o.J();
          o.bM(_, 0, v.width, v.height, 0, 0, 1);
          const w = v.context.gl;
          return { u_matrix: _, u_world: [w.drawingBufferWidth, w.drawingBufferHeight], u_image: u, u_color_ramp: g, u_opacity: a.paint.get("heatmap-opacity") };
        }, Pi = (v, a, u) => {
          const g = u.paint.get("hillshade-shadow-color"), _ = u.paint.get("hillshade-highlight-color"), w = u.paint.get("hillshade-accent-color");
          let C = u.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
          return u.paint.get("hillshade-illumination-anchor") === "viewport" && (C += v.transform.bearingInRadians), { u_image: 0, u_latrange: Ti(0, a.tileID), u_light: [u.paint.get("hillshade-exaggeration"), C], u_shadow: g, u_highlight: _, u_accent: w };
        }, gs = (v, a) => {
          const u = a.stride, g = o.J();
          return o.bM(g, 0, o.Y, -8192, 0, 0, 1), o.K(g, g, [0, -8192, 0]), { u_matrix: g, u_image: 1, u_dimension: [u, u], u_zoom: v.overscaledZ, u_unpack: a.getUnpackVector() };
        };
        function Ti(v, a) {
          const u = Math.pow(2, a.canonical.z), g = a.canonical.y;
          return [new o.Z(0, g / u).toLngLat().lat, new o.Z(0, (g + 1) / u).toLngLat().lat];
        }
        const fo = (v, a, u, g) => {
          const _ = v.transform;
          return { u_translation: ql(v, a, u), u_ratio: g / o.au(a, 1, _.zoom), u_device_pixel_ratio: v.pixelRatio, u_units_to_pixels: [1 / _.pixelsToGLUnits[0], 1 / _.pixelsToGLUnits[1]] };
        }, Us = (v, a, u, g, _) => o.e(fo(v, a, u, g), { u_image: 0, u_image_height: _ }), fa = (v, a, u, g, _) => {
          const w = v.transform, C = Vl(a, w);
          return { u_translation: ql(v, a, u), u_texsize: a.imageAtlasTexture.size, u_ratio: g / o.au(a, 1, w.zoom), u_device_pixel_ratio: v.pixelRatio, u_image: 0, u_scale: [C, _.fromScale, _.toScale], u_fade: _.t, u_units_to_pixels: [1 / w.pixelsToGLUnits[0], 1 / w.pixelsToGLUnits[1]] };
        }, Xu = (v, a, u, g, _, w) => {
          const C = v.lineAtlas, R = Vl(a, v.transform), L = u.layout.get("line-cap") === "round", k = C.getDash(_.from, L), V = C.getDash(_.to, L), W = k.width * w.fromScale, Z = V.width * w.toScale;
          return o.e(fo(v, a, u, g), { u_patternscale_a: [R / W, -k.height / 2], u_patternscale_b: [R / Z, -V.height / 2], u_sdfgamma: C.width / (256 * Math.min(W, Z) * v.pixelRatio) / 2, u_image: 0, u_tex_y_a: k.y, u_tex_y_b: V.y, u_mix: w.t });
        };
        function Vl(v, a) {
          return 1 / o.au(v, 1, a.tileZoom);
        }
        function ql(v, a, u) {
          return o.av(v.transform, a, u.paint.get("line-translate"), u.paint.get("line-translate-anchor"));
        }
        const Gl = (v, a, u, g, _) => {
          return { u_tl_parent: v, u_scale_parent: a, u_buffer_scale: 1, u_fade_t: u.mix, u_opacity: u.opacity * g.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: g.paint.get("raster-brightness-min"), u_brightness_high: g.paint.get("raster-brightness-max"), u_saturation_factor: (C = g.paint.get("raster-saturation"), C > 0 ? 1 - 1 / (1.001 - C) : -C), u_contrast_factor: (w = g.paint.get("raster-contrast"), w > 0 ? 1 / (1 - w) : 1 + w), u_spin_weights: $l(g.paint.get("raster-hue-rotate")), u_coords_top: [_[0].x, _[0].y, _[1].x, _[1].y], u_coords_bottom: [_[3].x, _[3].y, _[2].x, _[2].y] };
          var w, C;
        };
        function $l(v) {
          v *= Math.PI / 180;
          const a = Math.sin(v), u = Math.cos(v);
          return [(2 * u + 1) / 3, (-Math.sqrt(3) * a - u + 1) / 3, (Math.sqrt(3) * a - u + 1) / 3];
        }
        const Hl = (v, a, u, g, _, w, C, R, L, k, V, W, Z) => {
          const ae = C.transform;
          return { u_is_size_zoom_constant: +(v === "constant" || v === "source"), u_is_size_feature_constant: +(v === "constant" || v === "camera"), u_size_t: a ? a.uSizeT : 0, u_size: a ? a.uSize : 0, u_camera_to_center_distance: ae.cameraToCenterDistance, u_pitch: ae.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +u, u_aspect_ratio: ae.width / ae.height, u_fade_change: C.options.fadeDuration ? C.symbolFadeChange : 1, u_label_plane_matrix: R, u_coord_matrix: L, u_is_text: +V, u_pitch_with_map: +g, u_is_along_line: _, u_is_variable_anchor: w, u_texsize: W, u_texture: 0, u_translation: k, u_pitched_scale: Z };
        }, da = (v, a, u, g, _, w, C, R, L, k, V, W, Z, ae) => {
          const ue = C.transform;
          return o.e(Hl(v, a, u, g, _, w, C, R, L, k, V, W, ae), { u_gamma_scale: g ? Math.cos(ue.pitch * Math.PI / 180) * ue.cameraToCenterDistance : 1, u_device_pixel_ratio: C.pixelRatio, u_is_halo: 1 });
        }, ri = (v, a, u, g, _, w, C, R, L, k, V, W, Z) => o.e(da(v, a, u, g, _, w, C, R, L, k, !0, V, 0, Z), { u_texsize_icon: W, u_texture_icon: 1 }), ll = (v, a) => ({ u_opacity: v, u_color: a }), cl = (v, a, u, g, _) => o.e(function(w, C, R, L) {
          const k = R.imageManager.getPattern(w.from.toString()), V = R.imageManager.getPattern(w.to.toString()), { width: W, height: Z } = R.imageManager.getPixelSize(), ae = Math.pow(2, L.tileID.overscaledZ), ue = L.tileSize * Math.pow(2, R.transform.tileZoom) / ae, Ce = ue * (L.tileID.canonical.x + L.tileID.wrap * ae), Se = ue * L.tileID.canonical.y;
          return { u_image: 0, u_pattern_tl_a: k.tl, u_pattern_br_a: k.br, u_pattern_tl_b: V.tl, u_pattern_br_b: V.br, u_texsize: [W, Z], u_mix: C.t, u_pattern_size_a: k.displaySize, u_pattern_size_b: V.displaySize, u_scale_a: C.fromScale, u_scale_b: C.toScale, u_tile_units_to_pixels: 1 / o.au(L, 1, R.transform.tileZoom), u_pixel_coord_upper: [Ce >> 16, Se >> 16], u_pixel_coord_lower: [65535 & Ce, 65535 & Se] };
        }(u, _, a, g), { u_opacity: v }), Ba = (v, a) => {
        }, zc = { fillExtrusion: (v, a) => ({ u_lightpos: new o.bH(v, a.u_lightpos), u_lightpos_globe: new o.bH(v, a.u_lightpos_globe), u_lightintensity: new o.b6(v, a.u_lightintensity), u_lightcolor: new o.bH(v, a.u_lightcolor), u_vertical_gradient: new o.b6(v, a.u_vertical_gradient), u_opacity: new o.b6(v, a.u_opacity), u_fill_translate: new o.bI(v, a.u_fill_translate) }), fillExtrusionPattern: (v, a) => ({ u_lightpos: new o.bH(v, a.u_lightpos), u_lightpos_globe: new o.bH(v, a.u_lightpos_globe), u_lightintensity: new o.b6(v, a.u_lightintensity), u_lightcolor: new o.bH(v, a.u_lightcolor), u_vertical_gradient: new o.b6(v, a.u_vertical_gradient), u_height_factor: new o.b6(v, a.u_height_factor), u_opacity: new o.b6(v, a.u_opacity), u_fill_translate: new o.bI(v, a.u_fill_translate), u_image: new o.bD(v, a.u_image), u_texsize: new o.bI(v, a.u_texsize), u_pixel_coord_upper: new o.bI(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bI(v, a.u_pixel_coord_lower), u_scale: new o.bH(v, a.u_scale), u_fade: new o.b6(v, a.u_fade) }), fill: (v, a) => ({ u_fill_translate: new o.bI(v, a.u_fill_translate) }), fillPattern: (v, a) => ({ u_image: new o.bD(v, a.u_image), u_texsize: new o.bI(v, a.u_texsize), u_pixel_coord_upper: new o.bI(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bI(v, a.u_pixel_coord_lower), u_scale: new o.bH(v, a.u_scale), u_fade: new o.b6(v, a.u_fade), u_fill_translate: new o.bI(v, a.u_fill_translate) }), fillOutline: (v, a) => ({ u_world: new o.bI(v, a.u_world), u_fill_translate: new o.bI(v, a.u_fill_translate) }), fillOutlinePattern: (v, a) => ({ u_world: new o.bI(v, a.u_world), u_image: new o.bD(v, a.u_image), u_texsize: new o.bI(v, a.u_texsize), u_pixel_coord_upper: new o.bI(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bI(v, a.u_pixel_coord_lower), u_scale: new o.bH(v, a.u_scale), u_fade: new o.b6(v, a.u_fade), u_fill_translate: new o.bI(v, a.u_fill_translate) }), circle: (v, a) => ({ u_camera_to_center_distance: new o.b6(v, a.u_camera_to_center_distance), u_scale_with_map: new o.bD(v, a.u_scale_with_map), u_pitch_with_map: new o.bD(v, a.u_pitch_with_map), u_extrude_scale: new o.bI(v, a.u_extrude_scale), u_device_pixel_ratio: new o.b6(v, a.u_device_pixel_ratio), u_globe_extrude_scale: new o.b6(v, a.u_globe_extrude_scale), u_translate: new o.bI(v, a.u_translate) }), collisionBox: (v, a) => ({ u_pixel_extrude_scale: new o.bI(v, a.u_pixel_extrude_scale) }), collisionCircle: (v, a) => ({ u_viewport_size: new o.bI(v, a.u_viewport_size) }), debug: (v, a) => ({ u_color: new o.bE(v, a.u_color), u_overlay: new o.bD(v, a.u_overlay), u_overlay_scale: new o.b6(v, a.u_overlay_scale) }), depth: Ba, clippingMask: Ba, heatmap: (v, a) => ({ u_extrude_scale: new o.b6(v, a.u_extrude_scale), u_intensity: new o.b6(v, a.u_intensity), u_globe_extrude_scale: new o.b6(v, a.u_globe_extrude_scale) }), heatmapTexture: (v, a) => ({ u_matrix: new o.bF(v, a.u_matrix), u_world: new o.bI(v, a.u_world), u_image: new o.bD(v, a.u_image), u_color_ramp: new o.bD(v, a.u_color_ramp), u_opacity: new o.b6(v, a.u_opacity) }), hillshade: (v, a) => ({ u_image: new o.bD(v, a.u_image), u_latrange: new o.bI(v, a.u_latrange), u_light: new o.bI(v, a.u_light), u_shadow: new o.bE(v, a.u_shadow), u_highlight: new o.bE(v, a.u_highlight), u_accent: new o.bE(v, a.u_accent) }), hillshadePrepare: (v, a) => ({ u_matrix: new o.bF(v, a.u_matrix), u_image: new o.bD(v, a.u_image), u_dimension: new o.bI(v, a.u_dimension), u_zoom: new o.b6(v, a.u_zoom), u_unpack: new o.bG(v, a.u_unpack) }), line: (v, a) => ({ u_translation: new o.bI(v, a.u_translation), u_ratio: new o.b6(v, a.u_ratio), u_device_pixel_ratio: new o.b6(v, a.u_device_pixel_ratio), u_units_to_pixels: new o.bI(v, a.u_units_to_pixels) }), lineGradient: (v, a) => ({ u_translation: new o.bI(v, a.u_translation), u_ratio: new o.b6(v, a.u_ratio), u_device_pixel_ratio: new o.b6(v, a.u_device_pixel_ratio), u_units_to_pixels: new o.bI(v, a.u_units_to_pixels), u_image: new o.bD(v, a.u_image), u_image_height: new o.b6(v, a.u_image_height) }), linePattern: (v, a) => ({ u_translation: new o.bI(v, a.u_translation), u_texsize: new o.bI(v, a.u_texsize), u_ratio: new o.b6(v, a.u_ratio), u_device_pixel_ratio: new o.b6(v, a.u_device_pixel_ratio), u_image: new o.bD(v, a.u_image), u_units_to_pixels: new o.bI(v, a.u_units_to_pixels), u_scale: new o.bH(v, a.u_scale), u_fade: new o.b6(v, a.u_fade) }), lineSDF: (v, a) => ({ u_translation: new o.bI(v, a.u_translation), u_ratio: new o.b6(v, a.u_ratio), u_device_pixel_ratio: new o.b6(v, a.u_device_pixel_ratio), u_units_to_pixels: new o.bI(v, a.u_units_to_pixels), u_patternscale_a: new o.bI(v, a.u_patternscale_a), u_patternscale_b: new o.bI(v, a.u_patternscale_b), u_sdfgamma: new o.b6(v, a.u_sdfgamma), u_image: new o.bD(v, a.u_image), u_tex_y_a: new o.b6(v, a.u_tex_y_a), u_tex_y_b: new o.b6(v, a.u_tex_y_b), u_mix: new o.b6(v, a.u_mix) }), raster: (v, a) => ({ u_tl_parent: new o.bI(v, a.u_tl_parent), u_scale_parent: new o.b6(v, a.u_scale_parent), u_buffer_scale: new o.b6(v, a.u_buffer_scale), u_fade_t: new o.b6(v, a.u_fade_t), u_opacity: new o.b6(v, a.u_opacity), u_image0: new o.bD(v, a.u_image0), u_image1: new o.bD(v, a.u_image1), u_brightness_low: new o.b6(v, a.u_brightness_low), u_brightness_high: new o.b6(v, a.u_brightness_high), u_saturation_factor: new o.b6(v, a.u_saturation_factor), u_contrast_factor: new o.b6(v, a.u_contrast_factor), u_spin_weights: new o.bH(v, a.u_spin_weights), u_coords_top: new o.bG(v, a.u_coords_top), u_coords_bottom: new o.bG(v, a.u_coords_bottom) }), symbolIcon: (v, a) => ({ u_is_size_zoom_constant: new o.bD(v, a.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bD(v, a.u_is_size_feature_constant), u_size_t: new o.b6(v, a.u_size_t), u_size: new o.b6(v, a.u_size), u_camera_to_center_distance: new o.b6(v, a.u_camera_to_center_distance), u_pitch: new o.b6(v, a.u_pitch), u_rotate_symbol: new o.bD(v, a.u_rotate_symbol), u_aspect_ratio: new o.b6(v, a.u_aspect_ratio), u_fade_change: new o.b6(v, a.u_fade_change), u_label_plane_matrix: new o.bF(v, a.u_label_plane_matrix), u_coord_matrix: new o.bF(v, a.u_coord_matrix), u_is_text: new o.bD(v, a.u_is_text), u_pitch_with_map: new o.bD(v, a.u_pitch_with_map), u_is_along_line: new o.bD(v, a.u_is_along_line), u_is_variable_anchor: new o.bD(v, a.u_is_variable_anchor), u_texsize: new o.bI(v, a.u_texsize), u_texture: new o.bD(v, a.u_texture), u_translation: new o.bI(v, a.u_translation), u_pitched_scale: new o.b6(v, a.u_pitched_scale) }), symbolSDF: (v, a) => ({ u_is_size_zoom_constant: new o.bD(v, a.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bD(v, a.u_is_size_feature_constant), u_size_t: new o.b6(v, a.u_size_t), u_size: new o.b6(v, a.u_size), u_camera_to_center_distance: new o.b6(v, a.u_camera_to_center_distance), u_pitch: new o.b6(v, a.u_pitch), u_rotate_symbol: new o.bD(v, a.u_rotate_symbol), u_aspect_ratio: new o.b6(v, a.u_aspect_ratio), u_fade_change: new o.b6(v, a.u_fade_change), u_label_plane_matrix: new o.bF(v, a.u_label_plane_matrix), u_coord_matrix: new o.bF(v, a.u_coord_matrix), u_is_text: new o.bD(v, a.u_is_text), u_pitch_with_map: new o.bD(v, a.u_pitch_with_map), u_is_along_line: new o.bD(v, a.u_is_along_line), u_is_variable_anchor: new o.bD(v, a.u_is_variable_anchor), u_texsize: new o.bI(v, a.u_texsize), u_texture: new o.bD(v, a.u_texture), u_gamma_scale: new o.b6(v, a.u_gamma_scale), u_device_pixel_ratio: new o.b6(v, a.u_device_pixel_ratio), u_is_halo: new o.bD(v, a.u_is_halo), u_translation: new o.bI(v, a.u_translation), u_pitched_scale: new o.b6(v, a.u_pitched_scale) }), symbolTextAndIcon: (v, a) => ({ u_is_size_zoom_constant: new o.bD(v, a.u_is_size_zoom_constant), u_is_size_feature_constant: new o.bD(v, a.u_is_size_feature_constant), u_size_t: new o.b6(v, a.u_size_t), u_size: new o.b6(v, a.u_size), u_camera_to_center_distance: new o.b6(v, a.u_camera_to_center_distance), u_pitch: new o.b6(v, a.u_pitch), u_rotate_symbol: new o.bD(v, a.u_rotate_symbol), u_aspect_ratio: new o.b6(v, a.u_aspect_ratio), u_fade_change: new o.b6(v, a.u_fade_change), u_label_plane_matrix: new o.bF(v, a.u_label_plane_matrix), u_coord_matrix: new o.bF(v, a.u_coord_matrix), u_is_text: new o.bD(v, a.u_is_text), u_pitch_with_map: new o.bD(v, a.u_pitch_with_map), u_is_along_line: new o.bD(v, a.u_is_along_line), u_is_variable_anchor: new o.bD(v, a.u_is_variable_anchor), u_texsize: new o.bI(v, a.u_texsize), u_texsize_icon: new o.bI(v, a.u_texsize_icon), u_texture: new o.bD(v, a.u_texture), u_texture_icon: new o.bD(v, a.u_texture_icon), u_gamma_scale: new o.b6(v, a.u_gamma_scale), u_device_pixel_ratio: new o.b6(v, a.u_device_pixel_ratio), u_is_halo: new o.bD(v, a.u_is_halo), u_translation: new o.bI(v, a.u_translation), u_pitched_scale: new o.b6(v, a.u_pitched_scale) }), background: (v, a) => ({ u_opacity: new o.b6(v, a.u_opacity), u_color: new o.bE(v, a.u_color) }), backgroundPattern: (v, a) => ({ u_opacity: new o.b6(v, a.u_opacity), u_image: new o.bD(v, a.u_image), u_pattern_tl_a: new o.bI(v, a.u_pattern_tl_a), u_pattern_br_a: new o.bI(v, a.u_pattern_br_a), u_pattern_tl_b: new o.bI(v, a.u_pattern_tl_b), u_pattern_br_b: new o.bI(v, a.u_pattern_br_b), u_texsize: new o.bI(v, a.u_texsize), u_mix: new o.b6(v, a.u_mix), u_pattern_size_a: new o.bI(v, a.u_pattern_size_a), u_pattern_size_b: new o.bI(v, a.u_pattern_size_b), u_scale_a: new o.b6(v, a.u_scale_a), u_scale_b: new o.b6(v, a.u_scale_b), u_pixel_coord_upper: new o.bI(v, a.u_pixel_coord_upper), u_pixel_coord_lower: new o.bI(v, a.u_pixel_coord_lower), u_tile_units_to_pixels: new o.b6(v, a.u_tile_units_to_pixels) }), terrain: (v, a) => ({ u_texture: new o.bD(v, a.u_texture), u_ele_delta: new o.b6(v, a.u_ele_delta), u_fog_matrix: new o.bF(v, a.u_fog_matrix), u_fog_color: new o.bE(v, a.u_fog_color), u_fog_ground_blend: new o.b6(v, a.u_fog_ground_blend), u_fog_ground_blend_opacity: new o.b6(v, a.u_fog_ground_blend_opacity), u_horizon_color: new o.bE(v, a.u_horizon_color), u_horizon_fog_blend: new o.b6(v, a.u_horizon_fog_blend), u_is_globe_mode: new o.b6(v, a.u_is_globe_mode) }), terrainDepth: (v, a) => ({ u_ele_delta: new o.b6(v, a.u_ele_delta) }), terrainCoords: (v, a) => ({ u_texture: new o.bD(v, a.u_texture), u_terrain_coords_id: new o.b6(v, a.u_terrain_coords_id), u_ele_delta: new o.b6(v, a.u_ele_delta) }), projectionErrorMeasurement: (v, a) => ({ u_input: new o.b6(v, a.u_input), u_output_expected: new o.b6(v, a.u_output_expected) }), atmosphere: (v, a) => ({ u_sun_pos: new o.bH(v, a.u_sun_pos), u_atmosphere_blend: new o.b6(v, a.u_atmosphere_blend), u_globe_position: new o.bH(v, a.u_globe_position), u_globe_radius: new o.b6(v, a.u_globe_radius), u_inv_proj_matrix: new o.bF(v, a.u_inv_proj_matrix) }), sky: (v, a) => ({ u_sky_color: new o.bE(v, a.u_sky_color), u_horizon_color: new o.bE(v, a.u_horizon_color), u_horizon: new o.bI(v, a.u_horizon), u_horizon_normal: new o.bI(v, a.u_horizon_normal), u_sky_horizon_blend: new o.b6(v, a.u_sky_horizon_blend), u_sky_blend: new o.b6(v, a.u_sky_blend) }) };
        class Cs {
          constructor(a, u, g) {
            this.context = a;
            const _ = a.gl;
            this.buffer = _.createBuffer(), this.dynamicDraw = !!g, this.context.unbindVAO(), a.bindElementBuffer.set(this.buffer), _.bufferData(_.ELEMENT_ARRAY_BUFFER, u.arrayBuffer, this.dynamicDraw ? _.DYNAMIC_DRAW : _.STATIC_DRAW), this.dynamicDraw || delete u.arrayBuffer;
          }
          bind() {
            this.context.bindElementBuffer.set(this.buffer);
          }
          updateData(a) {
            const u = this.context.gl;
            if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
            this.context.unbindVAO(), this.bind(), u.bufferSubData(u.ELEMENT_ARRAY_BUFFER, 0, a.arrayBuffer);
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        const La = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
        class Wl {
          constructor(a, u, g, _) {
            this.length = u.length, this.attributes = g, this.itemSize = u.bytesPerElement, this.dynamicDraw = _, this.context = a;
            const w = a.gl;
            this.buffer = w.createBuffer(), a.bindVertexBuffer.set(this.buffer), w.bufferData(w.ARRAY_BUFFER, u.arrayBuffer, this.dynamicDraw ? w.DYNAMIC_DRAW : w.STATIC_DRAW), this.dynamicDraw || delete u.arrayBuffer;
          }
          bind() {
            this.context.bindVertexBuffer.set(this.buffer);
          }
          updateData(a) {
            if (a.length !== this.length) throw new Error(`Length of new data is ${a.length}, which doesn't match current length of ${this.length}`);
            const u = this.context.gl;
            this.bind(), u.bufferSubData(u.ARRAY_BUFFER, 0, a.arrayBuffer);
          }
          enableAttributes(a, u) {
            for (let g = 0; g < this.attributes.length; g++) {
              const _ = u.attributes[this.attributes[g].name];
              _ !== void 0 && a.enableVertexAttribArray(_);
            }
          }
          setVertexAttribPointers(a, u, g) {
            for (let _ = 0; _ < this.attributes.length; _++) {
              const w = this.attributes[_], C = u.attributes[w.name];
              C !== void 0 && a.vertexAttribPointer(C, w.components, a[La[w.type]], !1, this.itemSize, w.offset + this.itemSize * (g || 0));
            }
          }
          destroy() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          }
        }
        class An {
          constructor(a) {
            this.gl = a.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
          }
          get() {
            return this.current;
          }
          set(a) {
          }
          getDefault() {
            return this.default;
          }
          setDefault() {
            this.set(this.default);
          }
        }
        class Eo extends An {
          getDefault() {
            return o.b5.transparent;
          }
          set(a) {
            const u = this.current;
            (a.r !== u.r || a.g !== u.g || a.b !== u.b || a.a !== u.a || this.dirty) && (this.gl.clearColor(a.r, a.g, a.b, a.a), this.current = a, this.dirty = !1);
          }
        }
        class jc extends An {
          getDefault() {
            return 1;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.clearDepth(a), this.current = a, this.dirty = !1);
          }
        }
        class Zu extends An {
          getDefault() {
            return 0;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.clearStencil(a), this.current = a, this.dirty = !1);
          }
        }
        class bu extends An {
          getDefault() {
            return [!0, !0, !0, !0];
          }
          set(a) {
            const u = this.current;
            (a[0] !== u[0] || a[1] !== u[1] || a[2] !== u[2] || a[3] !== u[3] || this.dirty) && (this.gl.colorMask(a[0], a[1], a[2], a[3]), this.current = a, this.dirty = !1);
          }
        }
        class ul extends An {
          getDefault() {
            return !0;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.depthMask(a), this.current = a, this.dirty = !1);
          }
        }
        class hl extends An {
          getDefault() {
            return 255;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.stencilMask(a), this.current = a, this.dirty = !1);
          }
        }
        class ms extends An {
          getDefault() {
            return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
          }
          set(a) {
            const u = this.current;
            (a.func !== u.func || a.ref !== u.ref || a.mask !== u.mask || this.dirty) && (this.gl.stencilFunc(a.func, a.ref, a.mask), this.current = a, this.dirty = !1);
          }
        }
        class Ji extends An {
          getDefault() {
            const a = this.gl;
            return [a.KEEP, a.KEEP, a.KEEP];
          }
          set(a) {
            const u = this.current;
            (a[0] !== u[0] || a[1] !== u[1] || a[2] !== u[2] || this.dirty) && (this.gl.stencilOp(a[0], a[1], a[2]), this.current = a, this.dirty = !1);
          }
        }
        class Ko extends An {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const u = this.gl;
            a ? u.enable(u.STENCIL_TEST) : u.disable(u.STENCIL_TEST), this.current = a, this.dirty = !1;
          }
        }
        class Jo extends An {
          getDefault() {
            return [0, 1];
          }
          set(a) {
            const u = this.current;
            (a[0] !== u[0] || a[1] !== u[1] || this.dirty) && (this.gl.depthRange(a[0], a[1]), this.current = a, this.dirty = !1);
          }
        }
        class zs extends An {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const u = this.gl;
            a ? u.enable(u.DEPTH_TEST) : u.disable(u.DEPTH_TEST), this.current = a, this.dirty = !1;
          }
        }
        class Qo extends An {
          getDefault() {
            return this.gl.LESS;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.depthFunc(a), this.current = a, this.dirty = !1);
          }
        }
        class Fi extends An {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const u = this.gl;
            a ? u.enable(u.BLEND) : u.disable(u.BLEND), this.current = a, this.dirty = !1;
          }
        }
        class Si extends An {
          getDefault() {
            const a = this.gl;
            return [a.ONE, a.ZERO];
          }
          set(a) {
            const u = this.current;
            (a[0] !== u[0] || a[1] !== u[1] || this.dirty) && (this.gl.blendFunc(a[0], a[1]), this.current = a, this.dirty = !1);
          }
        }
        class Vc extends An {
          getDefault() {
            return o.b5.transparent;
          }
          set(a) {
            const u = this.current;
            (a.r !== u.r || a.g !== u.g || a.b !== u.b || a.a !== u.a || this.dirty) && (this.gl.blendColor(a.r, a.g, a.b, a.a), this.current = a, this.dirty = !1);
          }
        }
        class _s extends An {
          getDefault() {
            return this.gl.FUNC_ADD;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.blendEquation(a), this.current = a, this.dirty = !1);
          }
        }
        class Qi extends An {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const u = this.gl;
            a ? u.enable(u.CULL_FACE) : u.disable(u.CULL_FACE), this.current = a, this.dirty = !1;
          }
        }
        class Oa extends An {
          getDefault() {
            return this.gl.BACK;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.cullFace(a), this.current = a, this.dirty = !1);
          }
        }
        class Xl extends An {
          getDefault() {
            return this.gl.CCW;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.frontFace(a), this.current = a, this.dirty = !1);
          }
        }
        class Na extends An {
          getDefault() {
            return null;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.useProgram(a), this.current = a, this.dirty = !1);
          }
        }
        class pa extends An {
          getDefault() {
            return this.gl.TEXTURE0;
          }
          set(a) {
            (a !== this.current || this.dirty) && (this.gl.activeTexture(a), this.current = a, this.dirty = !1);
          }
        }
        class fl extends An {
          getDefault() {
            const a = this.gl;
            return [0, 0, a.drawingBufferWidth, a.drawingBufferHeight];
          }
          set(a) {
            const u = this.current;
            (a[0] !== u[0] || a[1] !== u[1] || a[2] !== u[2] || a[3] !== u[3] || this.dirty) && (this.gl.viewport(a[0], a[1], a[2], a[3]), this.current = a, this.dirty = !1);
          }
        }
        class po extends An {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const u = this.gl;
            u.bindFramebuffer(u.FRAMEBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class Co extends An {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const u = this.gl;
            u.bindRenderbuffer(u.RENDERBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class Zl extends An {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const u = this.gl;
            u.bindTexture(u.TEXTURE_2D, a), this.current = a, this.dirty = !1;
          }
        }
        class Da extends An {
          getDefault() {
            return null;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const u = this.gl;
            u.bindBuffer(u.ARRAY_BUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class sn extends An {
          getDefault() {
            return null;
          }
          set(a) {
            const u = this.gl;
            u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class dl extends An {
          getDefault() {
            return null;
          }
          set(a) {
            var u;
            if (a === this.current && !this.dirty) return;
            const g = this.gl;
            fs(g) ? g.bindVertexArray(a) : (u = g.getExtension("OES_vertex_array_object")) === null || u === void 0 || u.bindVertexArrayOES(a), this.current = a, this.dirty = !1;
          }
        }
        class Io extends An {
          getDefault() {
            return 4;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const u = this.gl;
            u.pixelStorei(u.UNPACK_ALIGNMENT, a), this.current = a, this.dirty = !1;
          }
        }
        class go extends An {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const u = this.gl;
            u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a), this.current = a, this.dirty = !1;
          }
        }
        class Bn extends An {
          getDefault() {
            return !1;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            const u = this.gl;
            u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL, a), this.current = a, this.dirty = !1;
          }
        }
        class $n extends An {
          constructor(a, u) {
            super(a), this.context = a, this.parent = u;
          }
          getDefault() {
            return null;
          }
        }
        class Ri extends $n {
          setDirty() {
            this.dirty = !0;
          }
          set(a) {
            if (a === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const u = this.gl;
            u.framebufferTexture2D(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.TEXTURE_2D, a, 0), this.current = a, this.dirty = !1;
          }
        }
        class Ui extends $n {
          set(a) {
            if (a === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const u = this.gl;
            u.framebufferRenderbuffer(u.FRAMEBUFFER, u.DEPTH_ATTACHMENT, u.RENDERBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        class ka extends $n {
          set(a) {
            if (a === this.current && !this.dirty) return;
            this.context.bindFramebuffer.set(this.parent);
            const u = this.gl;
            u.framebufferRenderbuffer(u.FRAMEBUFFER, u.DEPTH_STENCIL_ATTACHMENT, u.RENDERBUFFER, a), this.current = a, this.dirty = !1;
          }
        }
        const pl = "Framebuffer is not complete";
        class Fa {
          constructor(a, u, g, _, w) {
            this.context = a, this.width = u, this.height = g;
            const C = a.gl, R = this.framebuffer = C.createFramebuffer();
            if (this.colorAttachment = new Ri(a, R), _) this.depthAttachment = w ? new ka(a, R) : new Ui(a, R);
            else if (w) throw new Error("Stencil cannot be set without depth");
            if (C.checkFramebufferStatus(C.FRAMEBUFFER) !== C.FRAMEBUFFER_COMPLETE) throw new Error(pl);
          }
          destroy() {
            const a = this.context.gl, u = this.colorAttachment.get();
            if (u && a.deleteTexture(u), this.depthAttachment) {
              const g = this.depthAttachment.get();
              g && a.deleteRenderbuffer(g);
            }
            a.deleteFramebuffer(this.framebuffer);
          }
        }
        class Yl {
          constructor(a) {
            var u, g;
            if (this.gl = a, this.clearColor = new Eo(this), this.clearDepth = new jc(this), this.clearStencil = new Zu(this), this.colorMask = new bu(this), this.depthMask = new ul(this), this.stencilMask = new hl(this), this.stencilFunc = new ms(this), this.stencilOp = new Ji(this), this.stencilTest = new Ko(this), this.depthRange = new Jo(this), this.depthTest = new zs(this), this.depthFunc = new Qo(this), this.blend = new Fi(this), this.blendFunc = new Si(this), this.blendColor = new Vc(this), this.blendEquation = new _s(this), this.cullFace = new Qi(this), this.cullFaceSide = new Oa(this), this.frontFace = new Xl(this), this.program = new Na(this), this.activeTexture = new pa(this), this.viewport = new fl(this), this.bindFramebuffer = new po(this), this.bindRenderbuffer = new Co(this), this.bindTexture = new Zl(this), this.bindVertexBuffer = new Da(this), this.bindElementBuffer = new sn(this), this.bindVertexArray = new dl(this), this.pixelStoreUnpack = new Io(this), this.pixelStoreUnpackPremultiplyAlpha = new go(this), this.pixelStoreUnpackFlipY = new Bn(this), this.extTextureFilterAnisotropic = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension("MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = a.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE), fs(a)) {
              this.HALF_FLOAT = a.HALF_FLOAT;
              const _ = a.getExtension("EXT_color_buffer_half_float");
              this.RGBA16F = (u = a.RGBA16F) !== null && u !== void 0 ? u : _ == null ? void 0 : _.RGBA16F_EXT, this.RGB16F = (g = a.RGB16F) !== null && g !== void 0 ? g : _ == null ? void 0 : _.RGB16F_EXT, a.getExtension("EXT_color_buffer_float");
            } else {
              a.getExtension("EXT_color_buffer_half_float"), a.getExtension("OES_texture_half_float_linear");
              const _ = a.getExtension("OES_texture_half_float");
              this.HALF_FLOAT = _ == null ? void 0 : _.HALF_FLOAT_OES;
            }
          }
          setDefault() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }
          setDirty() {
            this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
          }
          createIndexBuffer(a, u) {
            return new Cs(this, a, u);
          }
          createVertexBuffer(a, u, g) {
            return new Wl(this, a, u, g);
          }
          createRenderbuffer(a, u, g) {
            const _ = this.gl, w = _.createRenderbuffer();
            return this.bindRenderbuffer.set(w), _.renderbufferStorage(_.RENDERBUFFER, a, u, g), this.bindRenderbuffer.set(null), w;
          }
          createFramebuffer(a, u, g, _) {
            return new Fa(this, a, u, g, _);
          }
          clear(a) {
            let { color: u, depth: g, stencil: _ } = a;
            const w = this.gl;
            let C = 0;
            u && (C |= w.COLOR_BUFFER_BIT, this.clearColor.set(u), this.colorMask.set([!0, !0, !0, !0])), g !== void 0 && (C |= w.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(g), this.depthMask.set(!0)), _ !== void 0 && (C |= w.STENCIL_BUFFER_BIT, this.clearStencil.set(_), this.stencilMask.set(255)), w.clear(C);
          }
          setCullFace(a) {
            a.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(a.mode), this.frontFace.set(a.frontFace));
          }
          setDepthMode(a) {
            a.func !== this.gl.ALWAYS || a.mask ? (this.depthTest.set(!0), this.depthFunc.set(a.func), this.depthMask.set(a.mask), this.depthRange.set(a.range)) : this.depthTest.set(!1);
          }
          setStencilMode(a) {
            a.test.func !== this.gl.ALWAYS || a.mask ? (this.stencilTest.set(!0), this.stencilMask.set(a.mask), this.stencilOp.set([a.fail, a.depthFail, a.pass]), this.stencilFunc.set({ func: a.test.func, ref: a.ref, mask: a.test.mask })) : this.stencilTest.set(!1);
          }
          setColorMode(a) {
            o.bA(a.blendFunction, Fn.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(a.blendFunction), this.blendColor.set(a.blendColor)), this.colorMask.set(a.mask);
          }
          createVertexArray() {
            var a;
            return fs(this.gl) ? this.gl.createVertexArray() : (a = this.gl.getExtension("OES_vertex_array_object")) === null || a === void 0 ? void 0 : a.createVertexArrayOES();
          }
          deleteVertexArray(a) {
            var u;
            return fs(this.gl) ? this.gl.deleteVertexArray(a) : (u = this.gl.getExtension("OES_vertex_array_object")) === null || u === void 0 ? void 0 : u.deleteVertexArrayOES(a);
          }
          unbindVAO() {
            this.bindVertexArray.set(null);
          }
        }
        let gl;
        function Kl(v, a, u, g, _) {
          const w = v.context, C = v.transform, R = w.gl, L = v.useProgram("collisionBox"), k = [];
          let V = 0, W = 0;
          for (let Ie = 0; Ie < g.length; Ie++) {
            const Le = g[Ie], qe = a.getTile(Le).getBucket(u);
            if (!qe) continue;
            const $e = _ ? qe.textCollisionBox : qe.iconCollisionBox, He = qe.collisionCircleArray;
            He.length > 0 && (k.push({ circleArray: He, circleOffset: W, coord: Le }), V += He.length / 4, W = V), $e && L.draw(w, R.LINES, Xr.disabled, dn.disabled, v.colorModeForRenderPass(), ln.disabled, tn(v.transform), v.style.map.terrain && v.style.map.terrain.getTerrainData(Le), C.getProjectionData({ overscaledTileID: Le, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), u.id, $e.layoutVertexBuffer, $e.indexBuffer, $e.segments, null, v.transform.zoom, null, null, $e.collisionVertexBuffer);
          }
          if (!_ || !k.length) return;
          const Z = v.useProgram("collisionCircle"), ae = new o.bN();
          ae.resize(4 * V), ae._trim();
          let ue = 0;
          for (const Ie of k) for (let Le = 0; Le < Ie.circleArray.length / 4; Le++) {
            const qe = 4 * Le, $e = Ie.circleArray[qe + 0], He = Ie.circleArray[qe + 1], Ze = Ie.circleArray[qe + 2], Je = Ie.circleArray[qe + 3];
            ae.emplace(ue++, $e, He, Ze, Je, 0), ae.emplace(ue++, $e, He, Ze, Je, 1), ae.emplace(ue++, $e, He, Ze, Je, 2), ae.emplace(ue++, $e, He, Ze, Je, 3);
          }
          (!gl || gl.length < 2 * V) && (gl = function(Ie) {
            const Le = 2 * Ie, qe = new o.bP();
            qe.resize(Le), qe._trim();
            for (let $e = 0; $e < Le; $e++) {
              const He = 6 * $e;
              qe.uint16[He + 0] = 4 * $e + 0, qe.uint16[He + 1] = 4 * $e + 1, qe.uint16[He + 2] = 4 * $e + 2, qe.uint16[He + 3] = 4 * $e + 2, qe.uint16[He + 4] = 4 * $e + 3, qe.uint16[He + 5] = 4 * $e + 0;
            }
            return qe;
          }(V));
          const Ce = w.createIndexBuffer(gl, !0), Se = w.createVertexBuffer(ae, o.bO.members, !0);
          for (const Ie of k) {
            const Le = Kr(v.transform);
            Z.draw(w, R.TRIANGLES, Xr.disabled, dn.disabled, v.colorModeForRenderPass(), ln.disabled, Le, v.style.map.terrain && v.style.map.terrain.getTerrainData(Ie.coord), null, u.id, Se, Ce, o.aE.simpleSegment(0, 2 * Ie.circleOffset, Ie.circleArray.length, Ie.circleArray.length / 2), null, v.transform.zoom, null, null, null);
          }
          Se.destroy(), Ce.destroy();
        }
        const eo = o.ar(new Float32Array(16));
        function js(v, a, u, g, _, w) {
          const { horizontalAlign: C, verticalAlign: R } = o.az(v);
          return new o.P((-(C - 0.5) * a / _ + g[0]) * w, (-(R - 0.5) * u / _ + g[1]) * w);
        }
        function Jl(v, a, u, g, _, w) {
          const C = a.tileAnchorPoint.add(new o.P(a.translation[0], a.translation[1]));
          if (a.pitchWithMap) {
            let R = g.mult(w);
            u || (R = R.rotate(-_));
            const L = C.add(R);
            return pt(L.x, L.y, a.pitchedLabelPlaneMatrix, a.getElevation).point;
          }
          if (u) {
            const R = fr(a.tileAnchorPoint.x + 1, a.tileAnchorPoint.y, a).point.sub(v), L = Math.atan(R.y / R.x) + (R.x < 0 ? Math.PI : 0);
            return v.add(g.rotate(L));
          }
          return v.add(g);
        }
        function qc(v, a, u, g, _, w, C, R, L, k, V, W) {
          const Z = v.text.placedSymbolArray, ae = v.text.dynamicLayoutVertexArray, ue = v.icon.dynamicLayoutVertexArray, Ce = {};
          ae.clear();
          for (let Se = 0; Se < Z.length; Se++) {
            const Ie = Z.get(Se), Le = Ie.hidden || !Ie.crossTileID || v.allowVerticalPlacement && !Ie.placedOrientation ? null : g[Ie.crossTileID];
            if (Le) {
              const qe = new o.P(Ie.anchorX, Ie.anchorY), $e = { getElevation: W, width: _.width, height: _.height, pitchedLabelPlaneMatrix: w, pitchWithMap: u, transform: _, tileAnchorPoint: qe, translation: k, unwrappedTileID: V }, He = u ? Hr(qe.x, qe.y, $e) : fr(qe.x, qe.y, $e), Ze = ct(_.cameraToCenterDistance, He.signedDistanceFromCamera);
              let Je = o.ag(v.textSizeData, R, Ie) * Ze / o.at;
              u && (Je *= v.tilePixelRatio / C);
              const { width: vt, height: _t, anchor: Rt, textOffset: Ft, textBoxScale: Mt } = Le, sr = js(Rt, vt, _t, Ft, Mt, Je), nr = _.getPitchedTextCorrection(qe.x + k[0], qe.y + k[1], V), Gt = Jl(He.point, $e, a, sr, -_.bearingInRadians, nr), dr = v.allowVerticalPlacement && Ie.placedOrientation === o.af.vertical ? Math.PI / 2 : 0;
              for (let Gr = 0; Gr < Ie.numGlyphs; Gr++) o.am(ae, Gt, dr);
              L && Ie.associatedIconIndex >= 0 && (Ce[Ie.associatedIconIndex] = { shiftedAnchor: Gt, angle: dr });
            } else Dn(Ie.numGlyphs, ae);
          }
          if (L) {
            ue.clear();
            const Se = v.icon.placedSymbolArray;
            for (let Ie = 0; Ie < Se.length; Ie++) {
              const Le = Se.get(Ie);
              if (Le.hidden) Dn(Le.numGlyphs, ue);
              else {
                const qe = Ce[Ie];
                if (qe) for (let $e = 0; $e < Le.numGlyphs; $e++) o.am(ue, qe.shiftedAnchor, qe.angle);
                else Dn(Le.numGlyphs, ue);
              }
            }
            v.icon.dynamicLayoutVertexBuffer.updateData(ue);
          }
          v.text.dynamicLayoutVertexBuffer.updateData(ae);
        }
        function Nf(v, a, u) {
          return u.iconsInText && a ? "symbolTextAndIcon" : v ? "symbolSDF" : "symbolIcon";
        }
        function Ql(v, a, u, g, _, w, C, R, L, k, V, W, Z) {
          const ae = v.context, ue = ae.gl, Ce = v.transform, Se = R === "map", Ie = L === "map", Le = R !== "viewport" && u.layout.get("symbol-placement") !== "point", qe = Se && !Ie && !Le, $e = !u.layout.get("symbol-sort-key").isConstant();
          let He = !1;
          const Ze = v.getDepthModeForSublayer(0, Xr.ReadOnly), Je = u._unevaluatedLayout.hasValue("text-variable-anchor") || u._unevaluatedLayout.hasValue("text-variable-anchor-offset"), vt = [], _t = Ce.getCircleRadiusCorrection();
          for (const Rt of g) {
            const Ft = a.getTile(Rt), Mt = Ft.getBucket(u);
            if (!Mt) continue;
            const sr = _ ? Mt.text : Mt.icon;
            if (!sr || !sr.segments.get().length || !sr.hasVisibleVertices) continue;
            const nr = sr.programConfigurations.get(u.id), Gt = _ || Mt.sdfIcons, dr = _ ? Mt.textSizeData : Mt.iconSizeData, Gr = Ie || Ce.pitch !== 0, mn = v.useProgram(Nf(Gt, _, Mt), nr), Jn = o.ae(dr, Ce.zoom), zn = v.style.map.terrain && v.style.map.terrain.getTerrainData(Rt);
            let Qn, Tn, On, Nn, ys = [0, 0], Oi = null;
            if (_) Tn = Ft.glyphAtlasTexture, On = ue.LINEAR, Qn = Ft.glyphAtlasTexture.size, Mt.iconsInText && (ys = Ft.imageAtlasTexture.size, Oi = Ft.imageAtlasTexture, Nn = Gr || v.options.rotating || v.options.zooming || dr.kind === "composite" || dr.kind === "camera" ? ue.LINEAR : ue.NEAREST);
            else {
              const Xn = u.layout.get("icon-size").constantOr(0) !== 1 || Mt.iconsNeedLinear;
              Tn = Ft.imageAtlasTexture, On = Gt || v.options.rotating || v.options.zooming || Xn || Gr ? ue.LINEAR : ue.NEAREST, Qn = Ft.imageAtlasTexture.size;
            }
            const ji = o.au(Ft, 1, v.transform.zoom), $i = gt(Se, v.transform, ji), ta = o.J();
            o.ah(ta, $i);
            const yo = Ye(Ie, Se, v.transform, ji), Ni = o.av(Ce, Ft, w, C), Rs = Ce.getProjectionData({ overscaledTileID: Rt, applyGlobeMatrix: !Z, applyTerrainMatrix: !0 }), Ro = Je && Mt.hasTextData(), vl = u.layout.get("icon-text-fit") !== "none" && Ro && Mt.hasIconData();
            if (Le) {
              const Xn = v.style.map.terrain ? (ra, Ci) => v.style.map.terrain.getElevation(Rt, ra, Ci) : null, yi = u.layout.get("text-rotation-alignment") === "map";
              or(Mt, v, _, $i, ta, Ie, k, yi, Rt.toUnwrapped(), Ce.width, Ce.height, Ni, Xn);
            }
            const xl = _ && Je || vl, qs = Le || xl ? eo : Ie ? $i : v.transform.clipSpaceToPixelsMatrix, Bo = Gt && u.paint.get(_ ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
            let ro;
            ro = Gt ? Mt.iconsInText ? ri(dr.kind, Jn, qe, Ie, Le, xl, v, qs, yo, Ni, Qn, ys, _t) : da(dr.kind, Jn, qe, Ie, Le, xl, v, qs, yo, Ni, _, Qn, 0, _t) : Hl(dr.kind, Jn, qe, Ie, Le, xl, v, qs, yo, Ni, _, Qn, _t);
            const Gs = { program: mn, buffers: sr, uniformValues: ro, projectionData: Rs, atlasTexture: Tn, atlasTextureIcon: Oi, atlasInterpolation: On, atlasInterpolationIcon: Nn, isSDF: Gt, hasHalo: Bo };
            if ($e && Mt.canOverlap) {
              He = !0;
              const Xn = sr.segments.get();
              for (const yi of Xn) vt.push({ segments: new o.aE([yi]), sortKey: yi.sortKey, state: Gs, terrainData: zn });
            } else vt.push({ segments: sr.segments, sortKey: 0, state: Gs, terrainData: zn });
          }
          He && vt.sort((Rt, Ft) => Rt.sortKey - Ft.sortKey);
          for (const Rt of vt) {
            const Ft = Rt.state;
            if (ae.activeTexture.set(ue.TEXTURE0), Ft.atlasTexture.bind(Ft.atlasInterpolation, ue.CLAMP_TO_EDGE), Ft.atlasTextureIcon && (ae.activeTexture.set(ue.TEXTURE1), Ft.atlasTextureIcon && Ft.atlasTextureIcon.bind(Ft.atlasInterpolationIcon, ue.CLAMP_TO_EDGE)), Ft.isSDF) {
              const Mt = Ft.uniformValues;
              Ft.hasHalo && (Mt.u_is_halo = 1, vu(Ft.buffers, Rt.segments, u, v, Ft.program, Ze, V, W, Mt, Ft.projectionData, Rt.terrainData)), Mt.u_is_halo = 0;
            }
            vu(Ft.buffers, Rt.segments, u, v, Ft.program, Ze, V, W, Ft.uniformValues, Ft.projectionData, Rt.terrainData);
          }
        }
        function vu(v, a, u, g, _, w, C, R, L, k, V) {
          const W = g.context;
          _.draw(W, W.gl.TRIANGLES, w, C, R, ln.backCCW, L, V, k, u.id, v.layoutVertexBuffer, v.indexBuffer, a, u.paint, g.transform.zoom, v.programConfigurations.get(u.id), v.dynamicLayoutVertexBuffer, v.opacityVertexBuffer);
        }
        function Yu(v, a, u, g, _) {
          const w = v.context, C = w.gl, R = dn.disabled, L = new Fn([C.ONE, C.ONE], o.b5.transparent, [!0, !0, !0, !0]), k = a.getBucket(u);
          if (!k) return;
          const V = g.key;
          let W = u.heatmapFbos.get(V);
          W || (W = Gc(w, a.tileSize, a.tileSize), u.heatmapFbos.set(V, W)), w.bindFramebuffer.set(W.framebuffer), w.viewport.set([0, 0, a.tileSize, a.tileSize]), w.clear({ color: o.b5.transparent });
          const Z = k.programConfigurations.get(u.id), ae = v.useProgram("heatmap", Z, !_), ue = v.transform.getProjectionData({ overscaledTileID: a.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), Ce = v.style.map.terrain.getTerrainData(g);
          ae.draw(w, C.TRIANGLES, Xr.disabled, R, L, ln.disabled, ti(a, v.transform.zoom, u.paint.get("heatmap-intensity"), 1), Ce, ue, u.id, k.layoutVertexBuffer, k.indexBuffer, k.segments, u.paint, v.transform.zoom, Z);
        }
        function xu(v, a, u, g, _) {
          const w = v.context, C = w.gl, R = v.transform;
          w.setColorMode(v.colorModeForRenderPass());
          const L = wu(w, a), k = u.key, V = a.heatmapFbos.get(k);
          if (!V) return;
          w.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, V.colorAttachment.get()), w.activeTexture.set(C.TEXTURE1), L.bind(C.LINEAR, C.CLAMP_TO_EDGE);
          const W = R.getProjectionData({ overscaledTileID: u, applyTerrainMatrix: _, applyGlobeMatrix: !g });
          v.useProgram("heatmapTexture").draw(w, C.TRIANGLES, Xr.disabled, dn.disabled, v.colorModeForRenderPass(), ln.disabled, Gn(v, a, 0, 1), null, W, a.id, v.rasterBoundsBuffer, v.quadTriangleIndexBuffer, v.rasterBoundsSegments, a.paint, R.zoom), V.destroy(), a.heatmapFbos.delete(k);
        }
        function Gc(v, a, u) {
          var g, _;
          const w = v.gl, C = w.createTexture();
          w.bindTexture(w.TEXTURE_2D, C), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_S, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_WRAP_T, w.CLAMP_TO_EDGE), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MIN_FILTER, w.LINEAR), w.texParameteri(w.TEXTURE_2D, w.TEXTURE_MAG_FILTER, w.LINEAR);
          const R = (g = v.HALF_FLOAT) !== null && g !== void 0 ? g : w.UNSIGNED_BYTE, L = (_ = v.RGBA16F) !== null && _ !== void 0 ? _ : w.RGBA;
          w.texImage2D(w.TEXTURE_2D, 0, L, a, u, 0, w.RGBA, R, null);
          const k = v.createFramebuffer(a, u, !1, !1);
          return k.colorAttachment.set(C), k;
        }
        function wu(v, a) {
          return a.colorRampTexture || (a.colorRampTexture = new oe(v, a.colorRamp, v.gl.RGBA)), a.colorRampTexture;
        }
        function $c(v, a, u, g, _) {
          if (!u || !g || !g.imageAtlas) return;
          const w = g.imageAtlas.patternPositions;
          let C = w[u.to.toString()], R = w[u.from.toString()];
          if (!C && R && (C = R), !R && C && (R = C), !C || !R) {
            const L = _.getPaintProperty(a);
            C = w[L], R = w[L];
          }
          C && R && v.setConstantPatternPositions(C, R);
        }
        function ec(v, a, u, g, _, w, C, R) {
          const L = v.context.gl, k = "fill-pattern", V = u.paint.get(k), W = V && V.constantOr(1), Z = u.getCrossfadeParameters();
          let ae, ue, Ce, Se, Ie;
          const Le = v.transform, qe = u.paint.get("fill-translate"), $e = u.paint.get("fill-translate-anchor");
          C ? (ue = W && !u.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", ae = L.LINES) : (ue = W ? "fillPattern" : "fill", ae = L.TRIANGLES);
          const He = V.constantOr(null);
          for (const Ze of g) {
            const Je = a.getTile(Ze);
            if (W && !Je.patternsLoaded()) continue;
            const vt = Je.getBucket(u);
            if (!vt) continue;
            const _t = vt.programConfigurations.get(u.id), Rt = v.useProgram(ue, _t), Ft = v.style.map.terrain && v.style.map.terrain.getTerrainData(Ze);
            W && (v.context.activeTexture.set(L.TEXTURE0), Je.imageAtlasTexture.bind(L.LINEAR, L.CLAMP_TO_EDGE), _t.updatePaintBuffers(Z)), $c(_t, k, He, Je, u);
            const Mt = Le.getProjectionData({ overscaledTileID: Ze, applyGlobeMatrix: !R, applyTerrainMatrix: !0 }), sr = o.av(Le, Je, qe, $e);
            if (C) {
              Se = vt.indexBuffer2, Ie = vt.segments2;
              const Gt = [L.drawingBufferWidth, L.drawingBufferHeight];
              Ce = ue === "fillOutlinePattern" && W ? Tr(v, Z, Je, Gt, sr) : tr(Gt, sr);
            } else Se = vt.indexBuffer, Ie = vt.segments, Ce = W ? zt(v, Z, Je, sr) : { u_fill_translate: sr };
            let nr;
            if (v.renderPass === "translucent" && R) {
              const [Gt] = v.getStencilConfigForOverlapAndUpdateStencilID(g);
              nr = Gt[Ze.overscaledZ];
            } else nr = v.stencilModeForClipping(Ze);
            Rt.draw(v.context, ae, _, nr, w, ln.backCCW, Ce, Ft, Mt, u.id, vt.layoutVertexBuffer, Se, Ie, u.paint, v.transform.zoom, _t);
          }
        }
        function Au(v, a, u, g, _, w, C, R) {
          const L = v.context, k = L.gl, V = "fill-extrusion-pattern", W = u.paint.get(V), Z = W.constantOr(1), ae = u.getCrossfadeParameters(), ue = u.paint.get("fill-extrusion-opacity"), Ce = W.constantOr(null), Se = v.transform;
          for (const Ie of g) {
            const Le = a.getTile(Ie), qe = Le.getBucket(u);
            if (!qe) continue;
            const $e = v.style.map.terrain && v.style.map.terrain.getTerrainData(Ie), He = qe.programConfigurations.get(u.id), Ze = v.useProgram(Z ? "fillExtrusionPattern" : "fillExtrusion", He);
            Z && (v.context.activeTexture.set(k.TEXTURE0), Le.imageAtlasTexture.bind(k.LINEAR, k.CLAMP_TO_EDGE), He.updatePaintBuffers(ae));
            const Je = Se.getProjectionData({ overscaledTileID: Ie, applyGlobeMatrix: !R, applyTerrainMatrix: !0 });
            $c(He, V, Ce, Le, u);
            const vt = o.av(Se, Le, u.paint.get("fill-extrusion-translate"), u.paint.get("fill-extrusion-translate-anchor")), _t = u.paint.get("fill-extrusion-vertical-gradient"), Rt = Z ? mt(v, _t, ue, vt, Ie, ae, Le) : Ke(v, _t, ue, vt);
            Ze.draw(L, L.gl.TRIANGLES, _, w, C, ln.backCCW, Rt, $e, Je, u.id, qe.layoutVertexBuffer, qe.indexBuffer, qe.segments, u.paint, v.transform.zoom, He, v.style.map.terrain && qe.centroidVertexBuffer);
          }
        }
        function Fh(v, a, u, g, _, w, C, R, L) {
          var k;
          const V = v.style.projection, W = v.context, Z = v.transform, ae = W.gl, ue = v.useProgram("hillshade"), Ce = !v.options.moving;
          for (const Se of g) {
            const Ie = a.getTile(Se), Le = Ie.fbo;
            if (!Le) continue;
            const qe = V.getMeshFromTileID(W, Se.canonical, R, !0, "raster"), $e = (k = v.style.map.terrain) === null || k === void 0 ? void 0 : k.getTerrainData(Se);
            W.activeTexture.set(ae.TEXTURE0), ae.bindTexture(ae.TEXTURE_2D, Le.colorAttachment.get());
            const He = Z.getProjectionData({ overscaledTileID: Se, aligned: Ce, applyGlobeMatrix: !L, applyTerrainMatrix: !0 });
            ue.draw(W, ae.TRIANGLES, w, _[Se.overscaledZ], C, ln.backCCW, Pi(v, Ie, u), $e, He, u.id, qe.vertexBuffer, qe.indexBuffer, qe.segments);
          }
        }
        const Tu = [new o.P(0, 0), new o.P(o.Y, 0), new o.P(o.Y, o.Y), new o.P(0, o.Y)];
        function ni(v, a, u, g, _, w, C, R) {
          let L = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : !1, k = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : !1;
          const V = g[g.length - 1].overscaledZ, W = v.context, Z = W.gl, ae = v.useProgram("raster"), ue = v.transform, Ce = v.style.projection, Se = v.colorModeForRenderPass(), Ie = !v.options.moving;
          for (const Le of g) {
            const qe = v.getDepthModeForSublayer(Le.overscaledZ - V, u.paint.get("raster-opacity") === 1 ? Xr.ReadWrite : Xr.ReadOnly, Z.LESS), $e = a.getTile(Le);
            $e.registerFadeDuration(u.paint.get("raster-fade-duration"));
            const He = a.findLoadedParent(Le, 0), Ze = a.findLoadedSibling(Le), Je = tc($e, He || Ze || null, a, u, v.transform, v.style.map.terrain);
            let vt, _t;
            const Rt = u.paint.get("raster-resampling") === "nearest" ? Z.NEAREST : Z.LINEAR;
            W.activeTexture.set(Z.TEXTURE0), $e.texture.bind(Rt, Z.CLAMP_TO_EDGE, Z.LINEAR_MIPMAP_NEAREST), W.activeTexture.set(Z.TEXTURE1), He ? (He.texture.bind(Rt, Z.CLAMP_TO_EDGE, Z.LINEAR_MIPMAP_NEAREST), vt = Math.pow(2, He.tileID.overscaledZ - $e.tileID.overscaledZ), _t = [$e.tileID.canonical.x * vt % 1, $e.tileID.canonical.y * vt % 1]) : $e.texture.bind(Rt, Z.CLAMP_TO_EDGE, Z.LINEAR_MIPMAP_NEAREST), $e.texture.useMipmap && W.extTextureFilterAnisotropic && v.transform.pitch > 20 && Z.texParameterf(Z.TEXTURE_2D, W.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, W.extTextureFilterAnisotropicMax);
            const Ft = v.style.map.terrain && v.style.map.terrain.getTerrainData(Le), Mt = ue.getProjectionData({ overscaledTileID: Le, aligned: Ie, applyGlobeMatrix: !k, applyTerrainMatrix: !0 }), sr = Gl(_t || [0, 0], vt || 1, Je, u, R), nr = Ce.getMeshFromTileID(W, Le.canonical, w, C, "raster");
            ae.draw(W, Z.TRIANGLES, qe, _ ? _[Le.overscaledZ] : dn.disabled, Se, L ? ln.frontCCW : ln.backCCW, sr, Ft, Mt, u.id, nr.vertexBuffer, nr.indexBuffer, nr.segments);
          }
        }
        function tc(v, a, u, g, _, w) {
          const C = g.paint.get("raster-fade-duration");
          if (!w && C > 0) {
            const R = M.now(), L = (R - v.timeAdded) / C, k = a ? (R - a.timeAdded) / C : -1, V = u.getSource(), W = Xi(_, { tileSize: V.tileSize, roundZoom: V.roundZoom }), Z = !a || Math.abs(a.tileID.overscaledZ - W) > Math.abs(v.tileID.overscaledZ - W), ae = Z && v.refreshedUponExpiration ? 1 : o.ac(Z ? L : 1 - k, 0, 1);
            return v.refreshedUponExpiration && L >= 1 && (v.refreshedUponExpiration = !1), a ? { opacity: 1, mix: 1 - ae } : { opacity: ae, mix: 0 };
          }
          return { opacity: 1, mix: 0 };
        }
        const Mo = new o.b5(1, 0, 0, 1), Uh = new o.b5(0, 1, 0, 1), zh = new o.b5(0, 0, 1, 1), Ku = new o.b5(1, 0, 1, 1), ml = new o.b5(0, 1, 1, 1);
        function ga(v, a, u, g) {
          Su(v, 0, a + u / 2, v.transform.width, u, g);
        }
        function Ju(v, a, u, g) {
          Su(v, a - u / 2, 0, u, v.transform.height, g);
        }
        function Su(v, a, u, g, _, w) {
          const C = v.context, R = C.gl;
          R.enable(R.SCISSOR_TEST), R.scissor(a * v.pixelRatio, u * v.pixelRatio, g * v.pixelRatio, _ * v.pixelRatio), C.clear({ color: w }), R.disable(R.SCISSOR_TEST);
        }
        function jh(v, a, u) {
          const g = v.context, _ = g.gl, w = v.useProgram("debug"), C = Xr.disabled, R = dn.disabled, L = v.colorModeForRenderPass(), k = "$debug", V = v.style.map.terrain && v.style.map.terrain.getTerrainData(u);
          g.activeTexture.set(_.TEXTURE0);
          const W = a.getTileByID(u.key).latestRawTileData, Z = Math.floor((W && W.byteLength || 0) / 1024), ae = a.getTile(u).tileSize, ue = 512 / Math.min(ae, 512) * (u.overscaledZ / v.transform.zoom) * 0.5;
          let Ce = u.canonical.toString();
          u.overscaledZ !== u.canonical.z && (Ce += ` => ${u.overscaledZ}`), function(Ie, Le) {
            Ie.initDebugOverlayCanvas();
            const qe = Ie.debugOverlayCanvas, $e = Ie.context.gl, He = Ie.debugOverlayCanvas.getContext("2d");
            He.clearRect(0, 0, qe.width, qe.height), He.shadowColor = "white", He.shadowBlur = 2, He.lineWidth = 1.5, He.strokeStyle = "white", He.textBaseline = "top", He.font = "bold 36px Open Sans, sans-serif", He.fillText(Le, 5, 5), He.strokeText(Le, 5, 5), Ie.debugOverlayTexture.update(qe), Ie.debugOverlayTexture.bind($e.LINEAR, $e.CLAMP_TO_EDGE);
          }(v, `${Ce} ${Z}kB`);
          const Se = v.transform.getProjectionData({ overscaledTileID: u, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
          w.draw(g, _.TRIANGLES, C, R, Fn.alphaBlended, ln.disabled, xn(o.b5.transparent, ue), null, Se, k, v.debugBuffer, v.quadTriangleIndexBuffer, v.debugSegments), w.draw(g, _.LINE_STRIP, C, R, L, ln.disabled, xn(o.b5.red), V, Se, k, v.debugBuffer, v.tileBorderIndexBuffer, v.debugSegments);
        }
        function Vh(v, a, u, g) {
          const { isRenderingGlobe: _ } = g, w = v.context, C = w.gl, R = v.transform, L = v.colorModeForRenderPass(), k = v.getDepthModeFor3D(), V = v.useProgram("terrain");
          w.bindFramebuffer.set(null), w.viewport.set([0, 0, v.width, v.height]);
          for (const W of u) {
            const Z = a.getTerrainMesh(W.tileID), ae = v.renderToTexture.getTexture(W), ue = a.getTerrainData(W.tileID);
            w.activeTexture.set(C.TEXTURE0), C.bindTexture(C.TEXTURE_2D, ae.texture);
            const Ce = a.getMeshFrameDelta(R.zoom), Se = R.calculateFogMatrix(W.tileID.toUnwrapped()), Ie = So(Ce, Se, v.style.sky, R.pitch, _), Le = R.getProjectionData({ overscaledTileID: W.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
            V.draw(w, C.TRIANGLES, k, dn.disabled, L, ln.backCCW, Ie, ue, Le, "terrain", Z.vertexBuffer, Z.indexBuffer, Z.segments);
          }
        }
        function qh(v, a) {
          if (!a.mesh) {
            const u = new o.aD();
            u.emplaceBack(-1, -1), u.emplaceBack(1, -1), u.emplaceBack(1, 1), u.emplaceBack(-1, 1);
            const g = new o.aF();
            g.emplaceBack(0, 1, 2), g.emplaceBack(0, 2, 3), a.mesh = new co(v.createVertexBuffer(u, nn.members), v.createIndexBuffer(g), o.aE.simpleSegment(0, 0, u.length, g.length));
          }
          return a.mesh;
        }
        class Df {
          constructor(a, u) {
            this.context = new Yl(a), this.transform = u, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: o.ar(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = se.maxUnderzooming + se.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new hs();
          }
          resize(a, u, g) {
            if (this.width = Math.floor(a * g), this.height = Math.floor(u * g), this.pixelRatio = g, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const _ of this.style._order) this.style._layers[_].resize();
          }
          setup() {
            const a = this.context, u = new o.aD();
            u.emplaceBack(0, 0), u.emplaceBack(o.Y, 0), u.emplaceBack(0, o.Y), u.emplaceBack(o.Y, o.Y), this.tileExtentBuffer = a.createVertexBuffer(u, nn.members), this.tileExtentSegments = o.aE.simpleSegment(0, 0, 4, 2);
            const g = new o.aD();
            g.emplaceBack(0, 0), g.emplaceBack(o.Y, 0), g.emplaceBack(0, o.Y), g.emplaceBack(o.Y, o.Y), this.debugBuffer = a.createVertexBuffer(g, nn.members), this.debugSegments = o.aE.simpleSegment(0, 0, 4, 5);
            const _ = new o.bU();
            _.emplaceBack(0, 0, 0, 0), _.emplaceBack(o.Y, 0, o.Y, 0), _.emplaceBack(0, o.Y, 0, o.Y), _.emplaceBack(o.Y, o.Y, o.Y, o.Y), this.rasterBoundsBuffer = a.createVertexBuffer(_, zl.members), this.rasterBoundsSegments = o.aE.simpleSegment(0, 0, 4, 2);
            const w = new o.aD();
            w.emplaceBack(0, 0), w.emplaceBack(o.Y, 0), w.emplaceBack(0, o.Y), w.emplaceBack(o.Y, o.Y), this.rasterBoundsBufferPosOnly = a.createVertexBuffer(w, nn.members), this.rasterBoundsSegmentsPosOnly = o.aE.simpleSegment(0, 0, 4, 5);
            const C = new o.aD();
            C.emplaceBack(0, 0), C.emplaceBack(1, 0), C.emplaceBack(0, 1), C.emplaceBack(1, 1), this.viewportBuffer = a.createVertexBuffer(C, nn.members), this.viewportSegments = o.aE.simpleSegment(0, 0, 4, 2);
            const R = new o.bV();
            R.emplaceBack(0), R.emplaceBack(1), R.emplaceBack(3), R.emplaceBack(2), R.emplaceBack(0), this.tileBorderIndexBuffer = a.createIndexBuffer(R);
            const L = new o.aF();
            L.emplaceBack(1, 0, 2), L.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = a.createIndexBuffer(L);
            const k = this.context.gl;
            this.stencilClearMode = new dn({ func: k.ALWAYS, mask: 0 }, 0, 255, k.ZERO, k.ZERO, k.ZERO), this.tileExtentMesh = new co(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
          }
          clearStencil() {
            const a = this.context, u = a.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            const g = o.J();
            o.bM(g, 0, this.width, this.height, 0, 0, 1), o.L(g, g, [u.drawingBufferWidth, u.drawingBufferHeight, 0]);
            const _ = { mainMatrix: g, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: g };
            this.useProgram("clippingMask", null, !0).draw(a, u.TRIANGLES, Xr.disabled, this.stencilClearMode, Fn.disabled, ln.disabled, null, null, _, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }
          _renderTileClippingMasks(a, u, g) {
            if (this.currentStencilSource === a.source || !a.isTileClipped() || !u || !u.length) return;
            this.currentStencilSource = a.source, this.nextStencilID + u.length > 256 && this.clearStencil();
            const _ = this.context;
            _.setColorMode(Fn.disabled), _.setDepthMode(Xr.disabled);
            const w = {};
            for (const C of u) w[C.key] = this.nextStencilID++;
            this._renderTileMasks(w, u, g, !0), this._renderTileMasks(w, u, g, !1), this._tileClippingMaskIDs = w;
          }
          _renderTileMasks(a, u, g, _) {
            const w = this.context, C = w.gl, R = this.style.projection, L = this.transform, k = this.useProgram("clippingMask");
            for (const V of u) {
              const W = a[V.key], Z = this.style.map.terrain && this.style.map.terrain.getTerrainData(V), ae = R.getMeshFromTileID(this.context, V.canonical, _, !0, "stencil"), ue = L.getProjectionData({ overscaledTileID: V, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              k.draw(w, C.TRIANGLES, Xr.disabled, new dn({ func: C.ALWAYS, mask: 0 }, W, 255, C.KEEP, C.KEEP, C.REPLACE), Fn.disabled, g ? ln.disabled : ln.backCCW, null, Z, ue, "$clipping", ae.vertexBuffer, ae.indexBuffer, ae.segments);
            }
          }
          _renderTilesDepthBuffer() {
            const a = this.context, u = a.gl, g = this.style.projection, _ = this.transform, w = this.useProgram("depth"), C = this.getDepthModeFor3D(), R = ve(_, { tileSize: _.tileSize });
            for (const L of R) {
              const k = this.style.map.terrain && this.style.map.terrain.getTerrainData(L), V = g.getMeshFromTileID(this.context, L.canonical, !0, !0, "raster"), W = _.getProjectionData({ overscaledTileID: L, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
              w.draw(a, u.TRIANGLES, C, dn.disabled, Fn.disabled, ln.backCCW, null, k, W, "$clipping", V.vertexBuffer, V.indexBuffer, V.segments);
            }
          }
          stencilModeFor3D() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            const a = this.nextStencilID++, u = this.context.gl;
            return new dn({ func: u.NOTEQUAL, mask: 255 }, a, 255, u.KEEP, u.KEEP, u.REPLACE);
          }
          stencilModeForClipping(a) {
            const u = this.context.gl;
            return new dn({ func: u.EQUAL, mask: 255 }, this._tileClippingMaskIDs[a.key], 0, u.KEEP, u.KEEP, u.REPLACE);
          }
          getStencilConfigForOverlapAndUpdateStencilID(a) {
            const u = this.context.gl, g = a.sort((C, R) => R.overscaledZ - C.overscaledZ), _ = g[g.length - 1].overscaledZ, w = g[0].overscaledZ - _ + 1;
            if (w > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + w > 256 && this.clearStencil();
              const C = {};
              for (let R = 0; R < w; R++) C[R + _] = new dn({ func: u.GEQUAL, mask: 255 }, R + this.nextStencilID, 255, u.KEEP, u.KEEP, u.REPLACE);
              return this.nextStencilID += w, [C, g];
            }
            return [{ [_]: dn.disabled }, g];
          }
          stencilConfigForOverlapTwoPass(a) {
            const u = this.context.gl, g = a.sort((C, R) => R.overscaledZ - C.overscaledZ), _ = g[g.length - 1].overscaledZ, w = g[0].overscaledZ - _ + 1;
            if (this.clearStencil(), w > 1) {
              const C = {}, R = {};
              for (let L = 0; L < w; L++) C[L + _] = new dn({ func: u.GREATER, mask: 255 }, w + 1 + L, 255, u.KEEP, u.KEEP, u.REPLACE), R[L + _] = new dn({ func: u.GREATER, mask: 255 }, 1 + L, 255, u.KEEP, u.KEEP, u.REPLACE);
              return this.nextStencilID = 2 * w + 1, [C, R, g];
            }
            return this.nextStencilID = 3, [{ [_]: new dn({ func: u.GREATER, mask: 255 }, 2, 255, u.KEEP, u.KEEP, u.REPLACE) }, { [_]: new dn({ func: u.GREATER, mask: 255 }, 1, 255, u.KEEP, u.KEEP, u.REPLACE) }, g];
          }
          colorModeForRenderPass() {
            const a = this.context.gl;
            return this._showOverdrawInspector ? new Fn([a.CONSTANT_COLOR, a.ONE], new o.b5(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Fn.unblended : Fn.alphaBlended;
          }
          getDepthModeForSublayer(a, u, g) {
            if (!this.opaquePassEnabledForLayer()) return Xr.disabled;
            const _ = 1 - ((1 + this.currentLayer) * this.numSublayers + a) * this.depthEpsilon;
            return new Xr(g || this.context.gl.LEQUAL, u, [_, _]);
          }
          getDepthModeFor3D() {
            return new Xr(this.context.gl.LEQUAL, Xr.ReadWrite, this.depthRangeFor3D);
          }
          opaquePassEnabledForLayer() {
            return this.currentLayer < this.opaquePassCutoff;
          }
          render(a, u) {
            var g, _;
            this.style = a, this.options = u, this.lineAtlas = a.lineAtlas, this.imageManager = a.imageManager, this.glyphManager = a.glyphManager, this.symbolFadeChange = a.placement.symbolFadeChange(M.now()), this.imageManager.beginFrame();
            const w = this.style._order, C = this.style.sourceCaches, R = {}, L = {}, k = {}, V = { isRenderingToTexture: !1, isRenderingGlobe: ((g = a.projection) === null || g === void 0 ? void 0 : g.transitionState) > 0 };
            for (const Z in C) {
              const ae = C[Z];
              ae.used && ae.prepare(this.context), R[Z] = ae.getVisibleCoordinates(!1), L[Z] = R[Z].slice().reverse(), k[Z] = ae.getVisibleCoordinates(!0).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (let Z = 0; Z < w.length; Z++) if (this.style._layers[w[Z]].is3D()) {
              this.opaquePassCutoff = Z;
              break;
            }
            this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
            for (const Z of w) {
              const ae = this.style._layers[Z];
              if (!ae.hasOffscreenPass() || ae.isHidden(this.transform.zoom)) continue;
              const ue = L[ae.source];
              (ae.type === "custom" || ue.length) && this.renderLayer(this, C[ae.source], ae, ue, V);
            }
            if ((_ = this.style.projection) === null || _ === void 0 || _.updateGPUdependent({ context: this.context, useProgram: (Z) => this.useProgram(Z) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: u.showOverdrawInspector ? o.b5.black : o.b5.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function(Z, ae) {
              const ue = Z.context, Ce = ue.gl, Se = ((Ze, Je, vt) => {
                const _t = Math.cos(Je.rollInRadians), Rt = Math.sin(Je.rollInRadians), Ft = Kn(Je), Mt = Je.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
                return { u_sky_color: Ze.properties.get("sky-color"), u_horizon_color: Ze.properties.get("horizon-color"), u_horizon: [(Je.width / 2 - Ft * Rt) * vt, (Je.height / 2 + Ft * _t) * vt], u_horizon_normal: [-Rt, _t], u_sky_horizon_blend: Ze.properties.get("sky-horizon-blend") * Je.height / 2 * vt, u_sky_blend: Mt };
              })(ae, Z.style.map.transform, Z.pixelRatio), Ie = new Xr(Ce.LEQUAL, Xr.ReadWrite, [0, 1]), Le = dn.disabled, qe = Z.colorModeForRenderPass(), $e = Z.useProgram("sky"), He = qh(ue, ae);
              $e.draw(ue, Ce.TRIANGLES, Ie, Le, qe, ln.disabled, Se, null, void 0, "sky", He.vertexBuffer, He.indexBuffer, He.segments);
            }(this, this.style.sky), this._showOverdrawInspector = u.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (a._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = w.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              const Z = this.style._layers[w[this.currentLayer]], ae = C[Z.source], ue = R[Z.source];
              this._renderTileClippingMasks(Z, ue, !1), this.renderLayer(this, ae, Z, ue, V);
            }
            this.renderPass = "translucent";
            let W = !1;
            for (this.currentLayer = 0; this.currentLayer < w.length; this.currentLayer++) {
              const Z = this.style._layers[w[this.currentLayer]], ae = C[Z.source];
              if (this.renderToTexture && this.renderToTexture.renderLayer(Z, V)) continue;
              this.opaquePassEnabledForLayer() || W || (W = !0, V.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
              const ue = (Z.type === "symbol" ? k : L)[Z.source];
              this._renderTileClippingMasks(Z, R[Z.source], !1), this.renderLayer(this, ae, Z, ue, V);
            }
            if (V.isRenderingGlobe && function(Z, ae, ue) {
              const Ce = Z.context, Se = Ce.gl, Ie = Z.useProgram("atmosphere"), Le = new Xr(Se.LEQUAL, Xr.ReadOnly, [0, 1]), qe = Z.transform, $e = function(Mt, sr) {
                const nr = Mt.properties.get("position"), Gt = [-nr.x, -nr.y, -nr.z], dr = o.ar(new Float64Array(16));
                return Mt.properties.get("anchor") === "map" && (o.aY(dr, dr, sr.rollInRadians), o.aZ(dr, dr, -sr.pitchInRadians), o.aY(dr, dr, sr.bearingInRadians), o.aZ(dr, dr, sr.center.lat * Math.PI / 180), o.bk(dr, dr, -sr.center.lng * Math.PI / 180)), o.bT(Gt, Gt, dr), Gt;
              }(ue, Z.transform), He = qe.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), Ze = ae.properties.get("atmosphere-blend") * He.projectionTransition;
              if (Ze === 0) return;
              const Je = Ks(qe.worldSize, qe.center.lat), vt = qe.inverseProjectionMatrix, _t = new Float64Array(4);
              _t[3] = 1, o.an(_t, _t, qe.modelViewProjectionMatrix), _t[0] /= _t[3], _t[1] /= _t[3], _t[2] /= _t[3], _t[3] = 1, o.an(_t, _t, vt), _t[0] /= _t[3], _t[1] /= _t[3], _t[2] /= _t[3], _t[3] = 1;
              const Rt = /* @__PURE__ */ ((Mt, sr, nr, Gt, dr) => ({ u_sun_pos: Mt, u_atmosphere_blend: sr, u_globe_position: nr, u_globe_radius: Gt, u_inv_proj_matrix: dr }))($e, Ze, [_t[0], _t[1], _t[2]], Je, vt), Ft = qh(Ce, ae);
              Ie.draw(Ce, Se.TRIANGLES, Le, dn.disabled, Fn.alphaBlended, ln.disabled, Rt, null, null, "atmosphere", Ft.vertexBuffer, Ft.indexBuffer, Ft.segments);
            }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
              const Z = function(ae, ue) {
                let Ce = null;
                const Se = Object.values(ae._layers).flatMap(($e) => $e.source && !$e.isHidden(ue) ? [ae.sourceCaches[$e.source]] : []), Ie = Se.filter(($e) => $e.getSource().type === "vector"), Le = Se.filter(($e) => $e.getSource().type !== "vector"), qe = ($e) => {
                  (!Ce || Ce.getSource().maxzoom < $e.getSource().maxzoom) && (Ce = $e);
                };
                return Ie.forEach(($e) => qe($e)), Ce || Le.forEach(($e) => qe($e)), Ce;
              }(this.style, this.transform.zoom);
              Z && function(ae, ue, Ce) {
                for (let Se = 0; Se < Ce.length; Se++) jh(ae, ue, Ce[Se]);
              }(this, Z, Z.getVisibleCoordinates());
            }
            this.options.showPadding && function(Z) {
              const ae = Z.transform.padding;
              ga(Z, Z.transform.height - (ae.top || 0), 3, Mo), ga(Z, ae.bottom || 0, 3, Uh), Ju(Z, ae.left || 0, 3, zh), Ju(Z, Z.transform.width - (ae.right || 0), 3, Ku);
              const ue = Z.transform.centerPoint;
              (function(Ce, Se, Ie, Le) {
                Su(Ce, Se - 1, Ie - 10, 2, 20, Le), Su(Ce, Se - 10, Ie - 1, 20, 2, Le);
              })(Z, ue.x, Z.transform.height - ue.y, ml);
            }(this), this.context.setDefault();
          }
          maybeDrawDepthAndCoords(a) {
            if (!this.style || !this.style.map || !this.style.map.terrain) return;
            const u = this.terrainFacilitator.matrix, g = this.transform.modelViewProjectionMatrix;
            let _ = this.terrainFacilitator.dirty;
            _ || (_ = a ? !o.bW(u, g) : !o.bX(u, g)), _ || (_ = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), _ && (o.bY(u, g), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(w, C) {
              const R = w.context, L = R.gl, k = w.transform, V = Fn.unblended, W = new Xr(L.LEQUAL, Xr.ReadWrite, [0, 1]), Z = C.sourceCache.getRenderableTiles(), ae = w.useProgram("terrainDepth");
              R.bindFramebuffer.set(C.getFramebuffer("depth").framebuffer), R.viewport.set([0, 0, w.width / devicePixelRatio, w.height / devicePixelRatio]), R.clear({ color: o.b5.transparent, depth: 1 });
              for (const ue of Z) {
                const Ce = C.getTerrainMesh(ue.tileID), Se = C.getTerrainData(ue.tileID), Ie = k.getProjectionData({ overscaledTileID: ue.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), Le = { u_ele_delta: C.getMeshFrameDelta(k.zoom) };
                ae.draw(R, L.TRIANGLES, W, dn.disabled, V, ln.backCCW, Le, Se, Ie, "terrain", Ce.vertexBuffer, Ce.indexBuffer, Ce.segments);
              }
              R.bindFramebuffer.set(null), R.viewport.set([0, 0, w.width, w.height]);
            }(this, this.style.map.terrain), function(w, C) {
              const R = w.context, L = R.gl, k = w.transform, V = Fn.unblended, W = new Xr(L.LEQUAL, Xr.ReadWrite, [0, 1]), Z = C.getCoordsTexture(), ae = C.sourceCache.getRenderableTiles(), ue = w.useProgram("terrainCoords");
              R.bindFramebuffer.set(C.getFramebuffer("coords").framebuffer), R.viewport.set([0, 0, w.width / devicePixelRatio, w.height / devicePixelRatio]), R.clear({ color: o.b5.transparent, depth: 1 }), C.coordsIndex = [];
              for (const Ce of ae) {
                const Se = C.getTerrainMesh(Ce.tileID), Ie = C.getTerrainData(Ce.tileID);
                R.activeTexture.set(L.TEXTURE0), L.bindTexture(L.TEXTURE_2D, Z.texture);
                const Le = { u_terrain_coords_id: (255 - C.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: C.getMeshFrameDelta(k.zoom) }, qe = k.getProjectionData({ overscaledTileID: Ce.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
                ue.draw(R, L.TRIANGLES, W, dn.disabled, V, ln.backCCW, Le, Ie, qe, "terrain", Se.vertexBuffer, Se.indexBuffer, Se.segments), C.coordsIndex.push(Ce.tileID.key);
              }
              R.bindFramebuffer.set(null), R.viewport.set([0, 0, w.width, w.height]);
            }(this, this.style.map.terrain));
          }
          renderLayer(a, u, g, _, w) {
            g.isHidden(this.transform.zoom) || (g.type === "background" || g.type === "custom" || (_ || []).length) && (this.id = g.id, o.bZ(g) ? function(C, R, L, k, V, W) {
              if (C.renderPass !== "translucent") return;
              const { isRenderingToTexture: Z } = W, ae = dn.disabled, ue = C.colorModeForRenderPass();
              (L._unevaluatedLayout.hasValue("text-variable-anchor") || L._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(Ce, Se, Ie, Le, qe, $e, He, Ze, Je) {
                const vt = Se.transform, _t = Se.style.map.terrain, Rt = qe === "map", Ft = $e === "map";
                for (const Mt of Ce) {
                  const sr = Le.getTile(Mt), nr = sr.getBucket(Ie);
                  if (!nr || !nr.text || !nr.text.segments.get().length) continue;
                  const Gt = o.ae(nr.textSizeData, vt.zoom), dr = o.au(sr, 1, Se.transform.zoom), Gr = gt(Rt, Se.transform, dr), mn = Ie.layout.get("icon-text-fit") !== "none" && nr.hasIconData();
                  if (Gt) {
                    const Jn = Math.pow(2, vt.zoom - sr.tileID.overscaledZ), zn = _t ? (Qn, Tn) => _t.getElevation(Mt, Qn, Tn) : null;
                    qc(nr, Rt, Ft, Je, vt, Gr, Jn, Gt, mn, o.av(vt, sr, He, Ze), Mt.toUnwrapped(), zn);
                  }
                }
              }(k, C, L, R, L.layout.get("text-rotation-alignment"), L.layout.get("text-pitch-alignment"), L.paint.get("text-translate"), L.paint.get("text-translate-anchor"), V), L.paint.get("icon-opacity").constantOr(1) !== 0 && Ql(C, R, L, k, !1, L.paint.get("icon-translate"), L.paint.get("icon-translate-anchor"), L.layout.get("icon-rotation-alignment"), L.layout.get("icon-pitch-alignment"), L.layout.get("icon-keep-upright"), ae, ue, Z), L.paint.get("text-opacity").constantOr(1) !== 0 && Ql(C, R, L, k, !0, L.paint.get("text-translate"), L.paint.get("text-translate-anchor"), L.layout.get("text-rotation-alignment"), L.layout.get("text-pitch-alignment"), L.layout.get("text-keep-upright"), ae, ue, Z), R.map.showCollisionBoxes && (Kl(C, R, L, k, !0), Kl(C, R, L, k, !1));
            }(a, u, g, _, this.style.placement.variableOffsets, w) : o.b_(g) ? function(C, R, L, k, V) {
              if (C.renderPass !== "translucent") return;
              const { isRenderingToTexture: W } = V, Z = L.paint.get("circle-opacity"), ae = L.paint.get("circle-stroke-width"), ue = L.paint.get("circle-stroke-opacity"), Ce = !L.layout.get("circle-sort-key").isConstant();
              if (Z.constantOr(1) === 0 && (ae.constantOr(1) === 0 || ue.constantOr(1) === 0)) return;
              const Se = C.context, Ie = Se.gl, Le = C.transform, qe = C.getDepthModeForSublayer(0, Xr.ReadOnly), $e = dn.disabled, He = C.colorModeForRenderPass(), Ze = [], Je = Le.getCircleRadiusCorrection();
              for (let vt = 0; vt < k.length; vt++) {
                const _t = k[vt], Rt = R.getTile(_t), Ft = Rt.getBucket(L);
                if (!Ft) continue;
                const Mt = L.paint.get("circle-translate"), sr = L.paint.get("circle-translate-anchor"), nr = o.av(Le, Rt, Mt, sr), Gt = Ft.programConfigurations.get(L.id), dr = C.useProgram("circle", Gt), Gr = Ft.layoutVertexBuffer, mn = Ft.indexBuffer, Jn = C.style.map.terrain && C.style.map.terrain.getTerrainData(_t), zn = { programConfiguration: Gt, program: dr, layoutVertexBuffer: Gr, indexBuffer: mn, uniformValues: kr(C, Rt, L, nr, Je), terrainData: Jn, projectionData: Le.getProjectionData({ overscaledTileID: _t, applyGlobeMatrix: !W, applyTerrainMatrix: !0 }) };
                if (Ce) {
                  const Qn = Ft.segments.get();
                  for (const Tn of Qn) Ze.push({ segments: new o.aE([Tn]), sortKey: Tn.sortKey, state: zn });
                } else Ze.push({ segments: Ft.segments, sortKey: 0, state: zn });
              }
              Ce && Ze.sort((vt, _t) => vt.sortKey - _t.sortKey);
              for (const vt of Ze) {
                const { programConfiguration: _t, program: Rt, layoutVertexBuffer: Ft, indexBuffer: Mt, uniformValues: sr, terrainData: nr, projectionData: Gt } = vt.state;
                Rt.draw(Se, Ie.TRIANGLES, qe, $e, He, ln.backCCW, sr, nr, Gt, L.id, Ft, Mt, vt.segments, L.paint, C.transform.zoom, _t);
              }
            }(a, u, g, _, w) : o.b$(g) ? function(C, R, L, k, V) {
              if (L.paint.get("heatmap-opacity") === 0) return;
              const W = C.context, { isRenderingToTexture: Z, isRenderingGlobe: ae } = V;
              if (C.style.map.terrain) {
                for (const ue of k) {
                  const Ce = R.getTile(ue);
                  R.hasRenderableParent(ue) || (C.renderPass === "offscreen" ? Yu(C, Ce, L, ue, ae) : C.renderPass === "translucent" && xu(C, L, ue, Z, ae));
                }
                W.viewport.set([0, 0, C.width, C.height]);
              } else C.renderPass === "offscreen" ? function(ue, Ce, Se, Ie) {
                const Le = ue.context, qe = Le.gl, $e = ue.transform, He = dn.disabled, Ze = new Fn([qe.ONE, qe.ONE], o.b5.transparent, [!0, !0, !0, !0]);
                (function(Je, vt, _t) {
                  const Rt = Je.gl;
                  Je.activeTexture.set(Rt.TEXTURE1), Je.viewport.set([0, 0, vt.width / 4, vt.height / 4]);
                  let Ft = _t.heatmapFbos.get(o.bQ);
                  Ft ? (Rt.bindTexture(Rt.TEXTURE_2D, Ft.colorAttachment.get()), Je.bindFramebuffer.set(Ft.framebuffer)) : (Ft = Gc(Je, vt.width / 4, vt.height / 4), _t.heatmapFbos.set(o.bQ, Ft));
                })(Le, ue, Se), Le.clear({ color: o.b5.transparent });
                for (let Je = 0; Je < Ie.length; Je++) {
                  const vt = Ie[Je];
                  if (Ce.hasRenderableParent(vt)) continue;
                  const _t = Ce.getTile(vt), Rt = _t.getBucket(Se);
                  if (!Rt) continue;
                  const Ft = Rt.programConfigurations.get(Se.id), Mt = ue.useProgram("heatmap", Ft), sr = $e.getProjectionData({ overscaledTileID: vt, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), nr = $e.getCircleRadiusCorrection();
                  Mt.draw(Le, qe.TRIANGLES, Xr.disabled, He, Ze, ln.backCCW, ti(_t, $e.zoom, Se.paint.get("heatmap-intensity"), nr), null, sr, Se.id, Rt.layoutVertexBuffer, Rt.indexBuffer, Rt.segments, Se.paint, $e.zoom, Ft);
                }
                Le.viewport.set([0, 0, ue.width, ue.height]);
              }(C, R, L, k) : C.renderPass === "translucent" && function(ue, Ce) {
                const Se = ue.context, Ie = Se.gl;
                Se.setColorMode(ue.colorModeForRenderPass());
                const Le = Ce.heatmapFbos.get(o.bQ);
                Le && (Se.activeTexture.set(Ie.TEXTURE0), Ie.bindTexture(Ie.TEXTURE_2D, Le.colorAttachment.get()), Se.activeTexture.set(Ie.TEXTURE1), wu(Se, Ce).bind(Ie.LINEAR, Ie.CLAMP_TO_EDGE), ue.useProgram("heatmapTexture").draw(Se, Ie.TRIANGLES, Xr.disabled, dn.disabled, ue.colorModeForRenderPass(), ln.disabled, Gn(ue, Ce, 0, 1), null, null, Ce.id, ue.viewportBuffer, ue.quadTriangleIndexBuffer, ue.viewportSegments, Ce.paint, ue.transform.zoom));
              }(C, L);
            }(a, u, g, _, w) : o.c0(g) ? function(C, R, L, k, V) {
              if (C.renderPass !== "translucent") return;
              const { isRenderingToTexture: W } = V, Z = L.paint.get("line-opacity"), ae = L.paint.get("line-width");
              if (Z.constantOr(1) === 0 || ae.constantOr(1) === 0) return;
              const ue = C.getDepthModeForSublayer(0, Xr.ReadOnly), Ce = C.colorModeForRenderPass(), Se = L.paint.get("line-dasharray"), Ie = L.paint.get("line-pattern"), Le = Ie.constantOr(1), qe = L.paint.get("line-gradient"), $e = L.getCrossfadeParameters(), He = Le ? "linePattern" : Se ? "lineSDF" : qe ? "lineGradient" : "line", Ze = C.context, Je = Ze.gl, vt = C.transform;
              let _t = !0;
              for (const Rt of k) {
                const Ft = R.getTile(Rt);
                if (Le && !Ft.patternsLoaded()) continue;
                const Mt = Ft.getBucket(L);
                if (!Mt) continue;
                const sr = Mt.programConfigurations.get(L.id), nr = C.context.program.get(), Gt = C.useProgram(He, sr), dr = _t || Gt.program !== nr, Gr = C.style.map.terrain && C.style.map.terrain.getTerrainData(Rt), mn = Ie.constantOr(null);
                if (mn && Ft.imageAtlas) {
                  const On = Ft.imageAtlas, Nn = On.patternPositions[mn.to.toString()], ys = On.patternPositions[mn.from.toString()];
                  Nn && ys && sr.setConstantPatternPositions(Nn, ys);
                }
                const Jn = vt.getProjectionData({ overscaledTileID: Rt, applyGlobeMatrix: !W, applyTerrainMatrix: !0 }), zn = vt.getPixelScale(), Qn = Le ? fa(C, Ft, L, zn, $e) : Se ? Xu(C, Ft, L, zn, Se, $e) : qe ? Us(C, Ft, L, zn, Mt.lineClipsArray.length) : fo(C, Ft, L, zn);
                if (Le) Ze.activeTexture.set(Je.TEXTURE0), Ft.imageAtlasTexture.bind(Je.LINEAR, Je.CLAMP_TO_EDGE), sr.updatePaintBuffers($e);
                else if (Se && (dr || C.lineAtlas.dirty)) Ze.activeTexture.set(Je.TEXTURE0), C.lineAtlas.bind(Ze);
                else if (qe) {
                  const On = Mt.gradients[L.id];
                  let Nn = On.texture;
                  if (L.gradientVersion !== On.version) {
                    let ys = 256;
                    if (L.stepInterpolant) {
                      const Oi = R.getSource().maxzoom, ji = Rt.canonical.z === Oi ? Math.ceil(1 << C.transform.maxZoom - Rt.canonical.z) : 1;
                      ys = o.ac(o.bR(Mt.maxLineLength / o.Y * 1024 * ji), 256, Ze.maxTextureSize);
                    }
                    On.gradient = o.bS({ expression: L.gradientExpression(), evaluationKey: "lineProgress", resolution: ys, image: On.gradient || void 0, clips: Mt.lineClipsArray }), On.texture ? On.texture.update(On.gradient) : On.texture = new oe(Ze, On.gradient, Je.RGBA), On.version = L.gradientVersion, Nn = On.texture;
                  }
                  Ze.activeTexture.set(Je.TEXTURE0), Nn.bind(L.stepInterpolant ? Je.NEAREST : Je.LINEAR, Je.CLAMP_TO_EDGE);
                }
                let Tn;
                if (W) {
                  const [On] = C.getStencilConfigForOverlapAndUpdateStencilID(k);
                  Tn = On[Rt.overscaledZ];
                } else Tn = C.stencilModeForClipping(Rt);
                Gt.draw(Ze, Je.TRIANGLES, ue, Tn, Ce, ln.disabled, Qn, Gr, Jn, L.id, Mt.layoutVertexBuffer, Mt.indexBuffer, Mt.segments, L.paint, C.transform.zoom, sr, Mt.layoutVertexBuffer2), _t = !1;
              }
            }(a, u, g, _, w) : o.c1(g) ? function(C, R, L, k, V) {
              const W = L.paint.get("fill-color"), Z = L.paint.get("fill-opacity");
              if (Z.constantOr(1) === 0) return;
              const { isRenderingToTexture: ae } = V, ue = C.colorModeForRenderPass(), Ce = L.paint.get("fill-pattern"), Se = C.opaquePassEnabledForLayer() && !Ce.constantOr(1) && W.constantOr(o.b5.transparent).a === 1 && Z.constantOr(0) === 1 ? "opaque" : "translucent";
              if (C.renderPass === Se) {
                const Ie = C.getDepthModeForSublayer(1, C.renderPass === "opaque" ? Xr.ReadWrite : Xr.ReadOnly);
                ec(C, R, L, k, Ie, ue, !1, ae);
              }
              if (C.renderPass === "translucent" && L.paint.get("fill-antialias")) {
                const Ie = C.getDepthModeForSublayer(L.getPaintProperty("fill-outline-color") ? 2 : 0, Xr.ReadOnly);
                ec(C, R, L, k, Ie, ue, !0, ae);
              }
            }(a, u, g, _, w) : o.c2(g) ? function(C, R, L, k, V) {
              const W = L.paint.get("fill-extrusion-opacity");
              if (W === 0) return;
              const { isRenderingToTexture: Z } = V;
              if (C.renderPass === "translucent") {
                const ae = new Xr(C.context.gl.LEQUAL, Xr.ReadWrite, C.depthRangeFor3D);
                if (W !== 1 || L.paint.get("fill-extrusion-pattern").constantOr(1)) Au(C, R, L, k, ae, dn.disabled, Fn.disabled, Z), Au(C, R, L, k, ae, C.stencilModeFor3D(), C.colorModeForRenderPass(), Z);
                else {
                  const ue = C.colorModeForRenderPass();
                  Au(C, R, L, k, ae, dn.disabled, ue, Z);
                }
              }
            }(a, u, g, _, w) : o.c3(g) ? function(C, R, L, k, V) {
              if (C.renderPass !== "offscreen" && C.renderPass !== "translucent") return;
              const { isRenderingToTexture: W } = V, Z = C.context, ae = C.style.projection.useSubdivision, ue = C.getDepthModeForSublayer(0, Xr.ReadOnly), Ce = C.colorModeForRenderPass();
              if (C.renderPass === "offscreen") (function(Se, Ie, Le, qe, $e, He, Ze) {
                const Je = Se.context, vt = Je.gl;
                for (const _t of Le) {
                  const Rt = Ie.getTile(_t), Ft = Rt.dem;
                  if (!Ft || !Ft.data || !Rt.needsHillshadePrepare) continue;
                  const Mt = Ft.dim, sr = Ft.stride, nr = Ft.getPixels();
                  if (Je.activeTexture.set(vt.TEXTURE1), Je.pixelStoreUnpackPremultiplyAlpha.set(!1), Rt.demTexture = Rt.demTexture || Se.getTileTexture(sr), Rt.demTexture) {
                    const dr = Rt.demTexture;
                    dr.update(nr, { premultiply: !1 }), dr.bind(vt.NEAREST, vt.CLAMP_TO_EDGE);
                  } else Rt.demTexture = new oe(Je, nr, vt.RGBA, { premultiply: !1 }), Rt.demTexture.bind(vt.NEAREST, vt.CLAMP_TO_EDGE);
                  Je.activeTexture.set(vt.TEXTURE0);
                  let Gt = Rt.fbo;
                  if (!Gt) {
                    const dr = new oe(Je, { width: Mt, height: Mt, data: null }, vt.RGBA);
                    dr.bind(vt.LINEAR, vt.CLAMP_TO_EDGE), Gt = Rt.fbo = Je.createFramebuffer(Mt, Mt, !0, !1), Gt.colorAttachment.set(dr.texture);
                  }
                  Je.bindFramebuffer.set(Gt.framebuffer), Je.viewport.set([0, 0, Mt, Mt]), Se.useProgram("hillshadePrepare").draw(Je, vt.TRIANGLES, $e, He, Ze, ln.disabled, gs(Rt.tileID, Ft), null, null, qe.id, Se.rasterBoundsBuffer, Se.quadTriangleIndexBuffer, Se.rasterBoundsSegments), Rt.needsHillshadePrepare = !1;
                }
              })(C, R, k, L, ue, dn.disabled, Ce), Z.viewport.set([0, 0, C.width, C.height]);
              else if (C.renderPass === "translucent") if (ae) {
                const [Se, Ie, Le] = C.stencilConfigForOverlapTwoPass(k);
                Fh(C, R, L, Le, Se, ue, Ce, !1, W), Fh(C, R, L, Le, Ie, ue, Ce, !0, W);
              } else {
                const [Se, Ie] = C.getStencilConfigForOverlapAndUpdateStencilID(k);
                Fh(C, R, L, Ie, Se, ue, Ce, !1, W);
              }
            }(a, u, g, _, w) : o.c4(g) ? function(C, R, L, k, V) {
              if (C.renderPass !== "translucent" || L.paint.get("raster-opacity") === 0 || !k.length) return;
              const { isRenderingToTexture: W } = V, Z = R.getSource(), ae = C.style.projection.useSubdivision;
              if (Z instanceof hr) ni(C, R, L, k, null, !1, !1, Z.tileCoords, Z.flippedWindingOrder, W);
              else if (ae) {
                const [ue, Ce, Se] = C.stencilConfigForOverlapTwoPass(k);
                ni(C, R, L, Se, ue, !1, !0, Tu, !1, W), ni(C, R, L, Se, Ce, !0, !0, Tu, !1, W);
              } else {
                const [ue, Ce] = C.getStencilConfigForOverlapAndUpdateStencilID(k);
                ni(C, R, L, Ce, ue, !1, !0, Tu, !1, W);
              }
            }(a, u, g, _, w) : o.c5(g) ? function(C, R, L, k, V) {
              const W = L.paint.get("background-color"), Z = L.paint.get("background-opacity");
              if (Z === 0) return;
              const { isRenderingToTexture: ae } = V, ue = C.context, Ce = ue.gl, Se = C.style.projection, Ie = C.transform, Le = Ie.tileSize, qe = L.paint.get("background-pattern");
              if (C.isPatternMissing(qe)) return;
              const $e = !qe && W.a === 1 && Z === 1 && C.opaquePassEnabledForLayer() ? "opaque" : "translucent";
              if (C.renderPass !== $e) return;
              const He = dn.disabled, Ze = C.getDepthModeForSublayer(0, $e === "opaque" ? Xr.ReadWrite : Xr.ReadOnly), Je = C.colorModeForRenderPass(), vt = C.useProgram(qe ? "backgroundPattern" : "background"), _t = k || ve(Ie, { tileSize: Le, terrain: C.style.map.terrain });
              qe && (ue.activeTexture.set(Ce.TEXTURE0), C.imageManager.bind(C.context));
              const Rt = L.getCrossfadeParameters();
              for (const Ft of _t) {
                const Mt = Ie.getProjectionData({ overscaledTileID: Ft, applyGlobeMatrix: !ae, applyTerrainMatrix: !0 }), sr = qe ? cl(Z, C, qe, { tileID: Ft, tileSize: Le }, Rt) : ll(Z, W), nr = C.style.map.terrain && C.style.map.terrain.getTerrainData(Ft), Gt = Se.getMeshFromTileID(ue, Ft.canonical, !1, !0, "raster");
                vt.draw(ue, Ce.TRIANGLES, Ze, He, Je, ln.backCCW, sr, nr, Mt, L.id, Gt.vertexBuffer, Gt.indexBuffer, Gt.segments);
              }
            }(a, 0, g, _, w) : o.c6(g) && function(C, R, L, k) {
              const { isRenderingGlobe: V } = k, W = C.context, Z = L.implementation, ae = C.style.projection, ue = C.transform, Ce = ue.getProjectionDataForCustomLayer(V), Se = { farZ: ue.farZ, nearZ: ue.nearZ, fov: ue.fov * Math.PI / 180, modelViewProjectionMatrix: ue.modelViewProjectionMatrix, projectionMatrix: ue.projectionMatrix, shaderData: { variantName: ae.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${ae.shaderPreludeCode.vertexSource}`, define: ae.shaderDefine }, defaultProjectionData: Ce }, Ie = Z.renderingMode ? Z.renderingMode : "2d";
              if (C.renderPass === "offscreen") {
                const Le = Z.prerender;
                Le && (C.setCustomLayerDefaults(), W.setColorMode(C.colorModeForRenderPass()), Le.call(Z, W.gl, Se), W.setDirty(), C.setBaseState());
              } else if (C.renderPass === "translucent") {
                C.setCustomLayerDefaults(), W.setColorMode(C.colorModeForRenderPass()), W.setStencilMode(dn.disabled);
                const Le = Ie === "3d" ? C.getDepthModeFor3D() : C.getDepthModeForSublayer(0, Xr.ReadOnly);
                W.setDepthMode(Le), Z.render(W.gl, Se), W.setDirty(), C.setBaseState(), W.bindFramebuffer.set(null);
              }
            }(a, 0, g, w));
          }
          saveTileTexture(a) {
            const u = this._tileTextures[a.size[0]];
            u ? u.push(a) : this._tileTextures[a.size[0]] = [a];
          }
          getTileTexture(a) {
            const u = this._tileTextures[a];
            return u && u.length > 0 ? u.pop() : null;
          }
          isPatternMissing(a) {
            if (!a) return !1;
            if (!a.from || !a.to) return !0;
            const u = this.imageManager.getPattern(a.from.toString()), g = this.imageManager.getPattern(a.to.toString());
            return !u || !g;
          }
          useProgram(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
            this.cache = this.cache || {};
            const _ = !!this.style.map.terrain, w = this.style.projection, C = a + (u ? u.cacheKey : "") + `/${g ? Hu : w.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (_ ? "/terrain" : "");
            return this.cache[C] || (this.cache[C] = new ne(this.context, gi[a], u, zc[a], this._showOverdrawInspector, _, g ? gi.projectionMercator : w.shaderPreludeCode, g ? Rl : w.shaderDefine)), this.cache[C];
          }
          setCustomLayerDefaults() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }
          setBaseState() {
            const a = this.context.gl;
            this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(a.FUNC_ADD);
          }
          initDebugOverlayCanvas() {
            this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new oe(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }
          destroy() {
            this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          }
          overLimit() {
            const { drawingBufferWidth: a, drawingBufferHeight: u } = this.context.gl;
            return this.width !== a || this.height !== u;
          }
        }
        function _l(v, a) {
          var u = this;
          let g, _ = !1, w = null, C = null;
          const R = () => {
            w = null, _ && (v.apply(C, g), w = setTimeout(R, a), _ = !1);
          };
          return function() {
            for (var L = arguments.length, k = new Array(L), V = 0; V < L; V++)
              k[V] = arguments[V];
            return _ = !0, C = u, g = k, w || R(), w;
          };
        }
        class ma {
          constructor(a) {
            this._getCurrentHash = () => {
              const u = window.location.hash.replace("#", "");
              if (this._hashName) {
                let g;
                return u.split("&").map((_) => _.split("=")).forEach((_) => {
                  _[0] === this._hashName && (g = _);
                }), (g && g[1] || "").split("/");
              }
              return u.split("/");
            }, this._onHashChange = () => {
              const u = this._getCurrentHash();
              if (!this._isValidHash(u)) return !1;
              const g = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(u[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+u[2], +u[1]], zoom: +u[0], bearing: g, pitch: +(u[4] || 0) }), !0;
            }, this._updateHashUnthrottled = () => {
              const u = window.location.href.replace(/(#.*)?$/, this.getHashString());
              window.history.replaceState(window.history.state, null, u);
            }, this._removeHash = () => {
              const u = this._getCurrentHash();
              if (u.length === 0) return;
              const g = u.join("/");
              let _ = g;
              _.split("&").length > 0 && (_ = _.split("&")[0]), this._hashName && (_ = `${this._hashName}=${g}`);
              let w = window.location.hash.replace(_, "");
              w.startsWith("#&") ? w = w.slice(0, 1) + w.slice(2) : w === "#" && (w = "");
              let C = window.location.href.replace(/(#.+)?$/, w);
              C = C.replace("&&", "&"), window.history.replaceState(window.history.state, null, C);
            }, this._updateHash = _l(this._updateHashUnthrottled, 300), this._hashName = a && encodeURIComponent(a);
          }
          addTo(a) {
            return this._map = a, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
          }
          remove() {
            return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
          }
          getHashString(a) {
            const u = this._map.getCenter(), g = Math.round(100 * this._map.getZoom()) / 100, _ = Math.ceil((g * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), w = Math.pow(10, _), C = Math.round(u.lng * w) / w, R = Math.round(u.lat * w) / w, L = this._map.getBearing(), k = this._map.getPitch();
            let V = "";
            if (V += a ? `/${C}/${R}/${g}` : `${g}/${R}/${C}`, (L || k) && (V += "/" + Math.round(10 * L) / 10), k && (V += `/${Math.round(k)}`), this._hashName) {
              const W = this._hashName;
              let Z = !1;
              const ae = window.location.hash.slice(1).split("&").map((ue) => {
                const Ce = ue.split("=")[0];
                return Ce === W ? (Z = !0, `${Ce}=${V}`) : ue;
              }).filter((ue) => ue);
              return Z || ae.push(`${W}=${V}`), `#${ae.join("&")}`;
            }
            return `#${V}`;
          }
          _isValidHash(a) {
            if (a.length < 3 || a.some(isNaN)) return !1;
            try {
              new o.O(+a[2], +a[1]);
            } catch {
              return !1;
            }
            const u = +a[0], g = +(a[3] || 0), _ = +(a[4] || 0);
            return u >= this._map.getMinZoom() && u <= this._map.getMaxZoom() && g >= -180 && g <= 180 && _ >= this._map.getMinPitch() && _ <= this._map.getMaxPitch();
          }
        }
        const Is = { linearity: 0.3, easing: o.c7(0, 0, 0.3, 1) }, _a = o.e({ deceleration: 2500, maxSpeed: 1400 }, Is), kf = o.e({ deceleration: 20, maxSpeed: 1400 }, Is), Gh = o.e({ deceleration: 1e3, maxSpeed: 360 }, Is), Ua = o.e({ deceleration: 1e3, maxSpeed: 90 }, Is), mo = o.e({ deceleration: 1e3, maxSpeed: 360 }, Is);
        class Qu {
          constructor(a) {
            this._map = a, this.clear();
          }
          clear() {
            this._inertiaBuffer = [];
          }
          record(a) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: M.now(), settings: a });
          }
          _drainInertiaBuffer() {
            const a = this._inertiaBuffer, u = M.now();
            for (; a.length > 0 && u - a[0].time > 160; ) a.shift();
          }
          _onMoveEnd(a) {
            if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
            const u = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new o.P(0, 0), pinchAround: void 0, around: void 0 };
            for (const { settings: w } of this._inertiaBuffer) u.zoom += w.zoomDelta || 0, u.bearing += w.bearingDelta || 0, u.pitch += w.pitchDelta || 0, u.roll += w.rollDelta || 0, w.panDelta && u.pan._add(w.panDelta), w.around && (u.around = w.around), w.pinchAround && (u.pinchAround = w.pinchAround);
            const g = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, _ = {};
            if (u.pan.mag()) {
              const w = Ms(u.pan.mag(), g, o.e({}, _a, a || {})), C = u.pan.mult(w.amount / u.pan.mag()), R = this._map.cameraHelper.handlePanInertia(C, this._map.transform);
              _.center = R.easingCenter, _.offset = R.easingOffset, Hc(_, w);
            }
            if (u.zoom) {
              const w = Ms(u.zoom, g, kf);
              _.zoom = this._map.transform.zoom + w.amount, Hc(_, w);
            }
            if (u.bearing) {
              const w = Ms(u.bearing, g, Gh);
              _.bearing = this._map.transform.bearing + o.ac(w.amount, -179, 179), Hc(_, w);
            }
            if (u.pitch) {
              const w = Ms(u.pitch, g, Ua);
              _.pitch = this._map.transform.pitch + w.amount, Hc(_, w);
            }
            if (u.roll) {
              const w = Ms(u.roll, g, mo);
              _.roll = this._map.transform.roll + o.ac(w.amount, -179, 179), Hc(_, w);
            }
            if (_.zoom || _.bearing) {
              const w = u.pinchAround === void 0 ? u.around : u.pinchAround;
              _.around = w ? this._map.unproject(w) : this._map.getCenter();
            }
            return this.clear(), o.e(_, { noMoveStart: !0 });
          }
        }
        function Hc(v, a) {
          (!v.duration || v.duration < a.duration) && (v.duration = a.duration, v.easing = a.easing);
        }
        function Ms(v, a, u) {
          const { maxSpeed: g, linearity: _, deceleration: w } = u, C = o.ac(v * _ / (a / 1e3), -g, g), R = Math.abs(C) / (w * _);
          return { easing: u.easing, duration: 1e3 * R, amount: C * (R / 2) };
        }
        class _i extends o.k {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(a, u, g) {
            let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            const w = E.mousePos(u.getCanvas(), g), C = u.unproject(w);
            super(a, o.e({ point: w, lngLat: C, originalEvent: g }, _)), this._defaultPrevented = !1, this.target = u;
          }
        }
        class rc extends o.k {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(a, u, g) {
            const _ = a === "touchend" ? g.changedTouches : g.touches, w = E.touchPos(u.getCanvasContainer(), _), C = w.map((L) => u.unproject(L)), R = w.reduce((L, k, V, W) => L.add(k.div(W.length)), new o.P(0, 0));
            super(a, { points: w, point: R, lngLats: C, lngLat: u.unproject(R), originalEvent: g }), this._defaultPrevented = !1;
          }
        }
        class Po extends o.k {
          preventDefault() {
            this._defaultPrevented = !0;
          }
          get defaultPrevented() {
            return this._defaultPrevented;
          }
          constructor(a, u, g) {
            super(a, { originalEvent: g }), this._defaultPrevented = !1;
          }
        }
        class Wc {
          constructor(a, u) {
            this._map = a, this._clickTolerance = u.clickTolerance;
          }
          reset() {
            delete this._mousedownPos;
          }
          wheel(a) {
            return this._firePreventable(new Po(a.type, this._map, a));
          }
          mousedown(a, u) {
            return this._mousedownPos = u, this._firePreventable(new _i(a.type, this._map, a));
          }
          mouseup(a) {
            this._map.fire(new _i(a.type, this._map, a));
          }
          click(a, u) {
            this._mousedownPos && this._mousedownPos.dist(u) >= this._clickTolerance || this._map.fire(new _i(a.type, this._map, a));
          }
          dblclick(a) {
            return this._firePreventable(new _i(a.type, this._map, a));
          }
          mouseover(a) {
            this._map.fire(new _i(a.type, this._map, a));
          }
          mouseout(a) {
            this._map.fire(new _i(a.type, this._map, a));
          }
          touchstart(a) {
            return this._firePreventable(new rc(a.type, this._map, a));
          }
          touchmove(a) {
            this._map.fire(new rc(a.type, this._map, a));
          }
          touchend(a) {
            this._map.fire(new rc(a.type, this._map, a));
          }
          touchcancel(a) {
            this._map.fire(new rc(a.type, this._map, a));
          }
          _firePreventable(a) {
            if (this._map.fire(a), a.defaultPrevented) return {};
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class eh {
          constructor(a) {
            this._map = a;
          }
          reset() {
            this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
          }
          mousemove(a) {
            this._map.fire(new _i(a.type, this._map, a));
          }
          mousedown() {
            this._delayContextMenu = !0, this._ignoreContextMenu = !1;
          }
          mouseup() {
            this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new _i("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }
          contextmenu(a) {
            this._delayContextMenu ? this._contextMenuEvent = a : this._ignoreContextMenu || this._map.fire(new _i(a.type, this._map, a)), this._map.listens("contextmenu") && a.preventDefault();
          }
          isEnabled() {
            return !0;
          }
          isActive() {
            return !1;
          }
          enable() {
          }
          disable() {
          }
        }
        class yl {
          constructor(a) {
            this._map = a;
          }
          get transform() {
            return this._map._requestedCameraState || this._map.transform;
          }
          get center() {
            return { lng: this.transform.center.lng, lat: this.transform.center.lat };
          }
          get zoom() {
            return this.transform.zoom;
          }
          get pitch() {
            return this.transform.pitch;
          }
          get bearing() {
            return this.transform.bearing;
          }
          unproject(a) {
            return this.transform.screenPointToLocation(o.P.convert(a), this._map.terrain);
          }
        }
        class Xc {
          constructor(a, u) {
            this._map = a, this._tr = new yl(a), this._el = a.getCanvasContainer(), this._container = a.getContainer(), this._clickTolerance = u.clickTolerance || 1;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
          enable() {
            this.isEnabled() || (this._enabled = !0);
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          mousedown(a, u) {
            this.isEnabled() && a.shiftKey && a.button === 0 && (E.disableDrag(), this._startPos = this._lastPos = u, this._active = !0);
          }
          mousemoveWindow(a, u) {
            if (!this._active) return;
            const g = u;
            if (this._lastPos.equals(g) || !this._box && g.dist(this._startPos) < this._clickTolerance) return;
            const _ = this._startPos;
            this._lastPos = g, this._box || (this._box = E.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", a));
            const w = Math.min(_.x, g.x), C = Math.max(_.x, g.x), R = Math.min(_.y, g.y), L = Math.max(_.y, g.y);
            E.setTransform(this._box, `translate(${w}px,${R}px)`), this._box.style.width = C - w + "px", this._box.style.height = L - R + "px";
          }
          mouseupWindow(a, u) {
            if (!this._active || a.button !== 0) return;
            const g = this._startPos, _ = u;
            if (this.reset(), E.suppressClick(), g.x !== _.x || g.y !== _.y) return this._map.fire(new o.k("boxzoomend", { originalEvent: a })), { cameraAnimation: (w) => w.fitScreenCoordinates(g, _, this._tr.bearing, { linear: !0 }) };
            this._fireEvent("boxzoomcancel", a);
          }
          keydown(a) {
            this._active && a.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", a));
          }
          reset() {
            this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (E.remove(this._box), this._box = null), E.enableDrag(), delete this._startPos, delete this._lastPos;
          }
          _fireEvent(a, u) {
            return this._map.fire(new o.k(a, { originalEvent: u }));
          }
        }
        function Eu(v, a) {
          if (v.length !== a.length) throw new Error(`The number of touches and points are not equal - touches ${v.length}, points ${a.length}`);
          const u = {};
          for (let g = 0; g < v.length; g++) u[v[g].identifier] = a[g];
          return u;
        }
        class Ff {
          constructor(a) {
            this.reset(), this.numTouches = a.numTouches;
          }
          reset() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
          }
          touchstart(a, u, g) {
            (this.centroid || g.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = a.timeStamp), g.length === this.numTouches && (this.centroid = function(_) {
              const w = new o.P(0, 0);
              for (const C of _) w._add(C);
              return w.div(_.length);
            }(u), this.touches = Eu(g, u)));
          }
          touchmove(a, u, g) {
            if (this.aborted || !this.centroid) return;
            const _ = Eu(g, u);
            for (const w in this.touches) {
              const C = _[w];
              (!C || C.dist(this.touches[w]) > 30) && (this.aborted = !0);
            }
          }
          touchend(a, u, g) {
            if ((!this.centroid || a.timeStamp - this.startTime > 500) && (this.aborted = !0), g.length === 0) {
              const _ = !this.aborted && this.centroid;
              if (this.reset(), _) return _;
            }
          }
        }
        class bl {
          constructor(a) {
            this.singleTap = new Ff(a), this.numTaps = a.numTaps, this.reset();
          }
          reset() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }
          touchstart(a, u, g) {
            this.singleTap.touchstart(a, u, g);
          }
          touchmove(a, u, g) {
            this.singleTap.touchmove(a, u, g);
          }
          touchend(a, u, g) {
            const _ = this.singleTap.touchend(a, u, g);
            if (_) {
              const w = a.timeStamp - this.lastTime < 500, C = !this.lastTap || this.lastTap.dist(_) < 30;
              if (w && C || this.reset(), this.count++, this.lastTime = a.timeStamp, this.lastTap = _, this.count === this.numTaps) return this.reset(), _;
            }
          }
        }
        class za {
          constructor(a) {
            this._tr = new yl(a), this._zoomIn = new bl({ numTouches: 1, numTaps: 2 }), this._zoomOut = new bl({ numTouches: 2, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
          }
          touchstart(a, u, g) {
            this._zoomIn.touchstart(a, u, g), this._zoomOut.touchstart(a, u, g);
          }
          touchmove(a, u, g) {
            this._zoomIn.touchmove(a, u, g), this._zoomOut.touchmove(a, u, g);
          }
          touchend(a, u, g) {
            const _ = this._zoomIn.touchend(a, u, g), w = this._zoomOut.touchend(a, u, g), C = this._tr;
            return _ ? (this._active = !0, a.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (R) => R.easeTo({ duration: 300, zoom: C.zoom + 1, around: C.unproject(_) }, { originalEvent: a }) }) : w ? (this._active = !0, a.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (R) => R.easeTo({ duration: 300, zoom: C.zoom - 1, around: C.unproject(w) }, { originalEvent: a }) }) : void 0;
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class vr {
          constructor(a) {
            this._enabled = !!a.enable, this._moveStateManager = a.moveStateManager, this._clickTolerance = a.clickTolerance || 1, this._moveFunction = a.move, this._activateOnStart = !!a.activateOnStart, a.assignEvents(this), this.reset();
          }
          reset(a) {
            this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(a);
          }
          _move() {
            const a = this._moveFunction(...arguments);
            if (a.bearingDelta || a.pitchDelta || a.rollDelta || a.around || a.panDelta) return this._active = !0, a;
          }
          dragStart(a, u) {
            this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(a) && (this._moveStateManager.startMove(a), this._lastPoint = Array.isArray(u) ? u[0] : u, this._activateOnStart && this._lastPoint && (this._active = !0));
          }
          dragMove(a, u) {
            if (!this.isEnabled()) return;
            const g = this._lastPoint;
            if (!g) return;
            if (a.preventDefault(), !this._moveStateManager.isValidMoveEvent(a)) return void this.reset(a);
            const _ = Array.isArray(u) ? u[0] : u;
            return !this._moved && _.dist(g) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = _, this._move(g, _));
          }
          dragEnd(a) {
            this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(a) && (this._moved && E.suppressClick(), this.reset(a));
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          getClickTolerance() {
            return this._clickTolerance;
          }
        }
        const Uf = { 0: 1, 2: 2 };
        class nc {
          constructor(a) {
            this._correctEvent = a.checkCorrectEvent;
          }
          startMove(a) {
            const u = E.mouseButton(a);
            this._eventButton = u;
          }
          endMove(a) {
            delete this._eventButton;
          }
          isValidStartEvent(a) {
            return this._correctEvent(a);
          }
          isValidMoveEvent(a) {
            return !function(u, g) {
              const _ = Uf[g];
              return u.buttons === void 0 || (u.buttons & _) !== _;
            }(a, this._eventButton);
          }
          isValidEndEvent(a) {
            return E.mouseButton(a) === this._eventButton;
          }
        }
        class zf {
          constructor() {
            this._firstTouch = void 0;
          }
          _isOneFingerTouch(a) {
            return a.targetTouches.length === 1;
          }
          _isSameTouchEvent(a) {
            return a.targetTouches[0].identifier === this._firstTouch;
          }
          startMove(a) {
            this._firstTouch = a.targetTouches[0].identifier;
          }
          endMove(a) {
            delete this._firstTouch;
          }
          isValidStartEvent(a) {
            return this._isOneFingerTouch(a);
          }
          isValidMoveEvent(a) {
            return this._isOneFingerTouch(a) && this._isSameTouchEvent(a);
          }
          isValidEndEvent(a) {
            return this._isOneFingerTouch(a) && this._isSameTouchEvent(a);
          }
        }
        class Cu {
          constructor() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new nc({ checkCorrectEvent: () => !0 }), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new zf();
            this.mouseMoveStateManager = a, this.oneFingerTouchMoveStateManager = u;
          }
          _executeRelevantHandler(a, u, g) {
            return a instanceof MouseEvent ? u(a) : typeof TouchEvent < "u" && a instanceof TouchEvent ? g(a) : void 0;
          }
          startMove(a) {
            this._executeRelevantHandler(a, (u) => this.mouseMoveStateManager.startMove(u), (u) => this.oneFingerTouchMoveStateManager.startMove(u));
          }
          endMove(a) {
            this._executeRelevantHandler(a, (u) => this.mouseMoveStateManager.endMove(u), (u) => this.oneFingerTouchMoveStateManager.endMove(u));
          }
          isValidStartEvent(a) {
            return this._executeRelevantHandler(a, (u) => this.mouseMoveStateManager.isValidStartEvent(u), (u) => this.oneFingerTouchMoveStateManager.isValidStartEvent(u));
          }
          isValidMoveEvent(a) {
            return this._executeRelevantHandler(a, (u) => this.mouseMoveStateManager.isValidMoveEvent(u), (u) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(u));
          }
          isValidEndEvent(a) {
            return this._executeRelevantHandler(a, (u) => this.mouseMoveStateManager.isValidEndEvent(u), (u) => this.oneFingerTouchMoveStateManager.isValidEndEvent(u));
          }
        }
        const ja = (v) => {
          v.mousedown = v.dragStart, v.mousemoveWindow = v.dragMove, v.mouseup = v.dragEnd, v.contextmenu = (a) => {
            a.preventDefault();
          };
        };
        class Iu {
          constructor(a, u) {
            this._clickTolerance = a.clickTolerance || 1, this._map = u, this.reset();
          }
          reset() {
            this._active = !1, this._touches = {}, this._sum = new o.P(0, 0);
          }
          _shouldBePrevented(a) {
            return a < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
          }
          touchstart(a, u, g) {
            return this._calculateTransform(a, u, g);
          }
          touchmove(a, u, g) {
            if (this._active) {
              if (!this._shouldBePrevented(g.length)) return a.preventDefault(), this._calculateTransform(a, u, g);
              this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", a);
            }
          }
          touchend(a, u, g) {
            this._calculateTransform(a, u, g), this._active && this._shouldBePrevented(g.length) && this.reset();
          }
          touchcancel() {
            this.reset();
          }
          _calculateTransform(a, u, g) {
            g.length > 0 && (this._active = !0);
            const _ = Eu(g, u), w = new o.P(0, 0), C = new o.P(0, 0);
            let R = 0;
            for (const k in _) {
              const V = _[k], W = this._touches[k];
              W && (w._add(V), C._add(V.sub(W)), R++, _[k] = V);
            }
            if (this._touches = _, this._shouldBePrevented(R) || !C.mag()) return;
            const L = C.div(R);
            return this._sum._add(L), this._sum.mag() < this._clickTolerance ? void 0 : { around: w.div(R), panDelta: L };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class cn {
          constructor() {
            this.reset();
          }
          reset() {
            this._active = !1, delete this._firstTwoTouches;
          }
          touchstart(a, u, g) {
            this._firstTwoTouches || g.length < 2 || (this._firstTwoTouches = [g[0].identifier, g[1].identifier], this._start([u[0], u[1]]));
          }
          touchmove(a, u, g) {
            if (!this._firstTwoTouches) return;
            a.preventDefault();
            const [_, w] = this._firstTwoTouches, C = Zc(g, u, _), R = Zc(g, u, w);
            if (!C || !R) return;
            const L = this._aroundCenter ? null : C.add(R).div(2);
            return this._move([C, R], L, a);
          }
          touchend(a, u, g) {
            if (!this._firstTwoTouches) return;
            const [_, w] = this._firstTwoTouches, C = Zc(g, u, _), R = Zc(g, u, w);
            C && R || (this._active && E.suppressClick(), this.reset());
          }
          touchcancel() {
            this.reset();
          }
          enable(a) {
            this._enabled = !0, this._aroundCenter = !!a && a.around === "center";
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active;
          }
        }
        function Zc(v, a, u) {
          for (let g = 0; g < v.length; g++) if (v[g].identifier === u) return a[g];
        }
        function $h(v, a) {
          return Math.log(v / a) / Math.LN2;
        }
        class S extends cn {
          reset() {
            super.reset(), delete this._distance, delete this._startDistance;
          }
          _start(a) {
            this._startDistance = this._distance = a[0].dist(a[1]);
          }
          _move(a, u) {
            const g = this._distance;
            if (this._distance = a[0].dist(a[1]), this._active || !(Math.abs($h(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: $h(this._distance, g), pinchAround: u };
          }
        }
        function P(v, a) {
          return 180 * v.angleWith(a) / Math.PI;
        }
        class F extends cn {
          reset() {
            super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
          }
          _start(a) {
            this._startVector = this._vector = a[0].sub(a[1]), this._minDiameter = a[0].dist(a[1]);
          }
          _move(a, u, g) {
            const _ = this._vector;
            if (this._vector = a[0].sub(a[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: P(this._vector, _), pinchAround: u };
          }
          _isBelowThreshold(a) {
            this._minDiameter = Math.min(this._minDiameter, a.mag());
            const u = 25 / (Math.PI * this._minDiameter) * 360, g = P(a, this._startVector);
            return Math.abs(g) < u;
          }
        }
        function $(v) {
          return Math.abs(v.y) > Math.abs(v.x);
        }
        class re extends cn {
          constructor(a) {
            super(), this._currentTouchCount = 0, this._map = a;
          }
          reset() {
            super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
          }
          touchstart(a, u, g) {
            super.touchstart(a, u, g), this._currentTouchCount = g.length;
          }
          _start(a) {
            this._lastPoints = a, $(a[0].sub(a[1])) && (this._valid = !1);
          }
          _move(a, u, g) {
            if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
            const _ = a[0].sub(this._lastPoints[0]), w = a[1].sub(this._lastPoints[1]);
            return this._valid = this.gestureBeginsVertically(_, w, g.timeStamp), this._valid ? (this._lastPoints = a, this._active = !0, { pitchDelta: (_.y + w.y) / 2 * -0.5 }) : void 0;
          }
          gestureBeginsVertically(a, u, g) {
            if (this._valid !== void 0) return this._valid;
            const _ = a.mag() >= 2, w = u.mag() >= 2;
            if (!_ && !w) return;
            if (!_ || !w) return this._firstMove === void 0 && (this._firstMove = g), g - this._firstMove < 100 && void 0;
            const C = a.y > 0 == u.y > 0;
            return $(a) && $(u) && C;
          }
        }
        const fe = { panStep: 100, bearingStep: 15, pitchStep: 10 };
        class ge {
          constructor(a) {
            this._tr = new yl(a);
            const u = fe;
            this._panStep = u.panStep, this._bearingStep = u.bearingStep, this._pitchStep = u.pitchStep, this._rotationDisabled = !1;
          }
          reset() {
            this._active = !1;
          }
          keydown(a) {
            if (a.altKey || a.ctrlKey || a.metaKey) return;
            let u = 0, g = 0, _ = 0, w = 0, C = 0;
            switch (a.keyCode) {
              case 61:
              case 107:
              case 171:
              case 187:
                u = 1;
                break;
              case 189:
              case 109:
              case 173:
                u = -1;
                break;
              case 37:
                a.shiftKey ? g = -1 : (a.preventDefault(), w = -1);
                break;
              case 39:
                a.shiftKey ? g = 1 : (a.preventDefault(), w = 1);
                break;
              case 38:
                a.shiftKey ? _ = 1 : (a.preventDefault(), C = -1);
                break;
              case 40:
                a.shiftKey ? _ = -1 : (a.preventDefault(), C = 1);
                break;
              default:
                return;
            }
            return this._rotationDisabled && (g = 0, _ = 0), { cameraAnimation: (R) => {
              const L = this._tr;
              R.easeTo({ duration: 300, easeId: "keyboardHandler", easing: be, zoom: u ? Math.round(L.zoom) + u * (a.shiftKey ? 2 : 1) : L.zoom, bearing: L.bearing + g * this._bearingStep, pitch: L.pitch + _ * this._pitchStep, offset: [-w * this._panStep, -C * this._panStep], center: L.center }, { originalEvent: a });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
          disableRotation() {
            this._rotationDisabled = !0;
          }
          enableRotation() {
            this._rotationDisabled = !1;
          }
        }
        function be(v) {
          return v * (2 - v);
        }
        const we = 4.000244140625;
        class Pe {
          constructor(a, u) {
            this._onTimeout = (g) => {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(g);
            }, this._map = a, this._tr = new yl(a), this._triggerRenderFrame = u, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
          }
          setZoomRate(a) {
            this._defaultZoomRate = a;
          }
          setWheelZoomRate(a) {
            this._wheelZoomRate = a;
          }
          isEnabled() {
            return !!this._enabled;
          }
          isActive() {
            return !!this._active || this._finishTimeout !== void 0;
          }
          isZooming() {
            return !!this._zooming;
          }
          enable(a) {
            this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!a && a.around === "center");
          }
          disable() {
            this.isEnabled() && (this._enabled = !1);
          }
          _shouldBePrevented(a) {
            return !!this._map.cooperativeGestures.isEnabled() && !(a.ctrlKey || this._map.cooperativeGestures.isBypassed(a));
          }
          wheel(a) {
            if (!this.isEnabled()) return;
            if (this._shouldBePrevented(a)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", a);
            let u = a.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * a.deltaY : a.deltaY;
            const g = M.now(), _ = g - (this._lastWheelEventTime || 0);
            this._lastWheelEventTime = g, u !== 0 && u % we == 0 ? this._type = "wheel" : u !== 0 && Math.abs(u) < 4 ? this._type = "trackpad" : _ > 400 ? (this._type = null, this._lastValue = u, this._timeout = setTimeout(this._onTimeout, 40, a)) : this._type || (this._type = Math.abs(_ * u) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, u += this._lastValue)), a.shiftKey && u && (u /= 4), this._type && (this._lastWheelEvent = a, this._delta -= u, this._active || this._start(a)), a.preventDefault();
          }
          _start(a) {
            if (!this._delta) return;
            this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            const u = E.mousePos(this._map.getCanvas(), a), g = this._tr;
            this._aroundPoint = this._aroundCenter ? g.transform.locationToScreenPoint(o.O.convert(g.center)) : u, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
          }
          renderFrame() {
            if (!this._frameId || (this._frameId = null, !this.isActive())) return;
            const a = this._tr.transform;
            if (typeof this._lastExpectedZoom == "number") {
              const R = a.zoom - this._lastExpectedZoom;
              typeof this._startZoom == "number" && (this._startZoom += R), typeof this._targetZoom == "number" && (this._targetZoom += R);
            }
            if (this._delta !== 0) {
              const R = this._type === "wheel" && Math.abs(this._delta) > we ? this._wheelZoomRate : this._defaultZoomRate;
              let L = 2 / (1 + Math.exp(-Math.abs(this._delta * R)));
              this._delta < 0 && L !== 0 && (L = 1 / L);
              const k = typeof this._targetZoom != "number" ? a.scale : o.aG(this._targetZoom);
              this._targetZoom = Math.min(a.maxZoom, Math.max(a.minZoom, o.a9(k * L))), this._type === "wheel" && (this._startZoom = a.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
            }
            const u = typeof this._targetZoom != "number" ? a.zoom : this._targetZoom, g = this._startZoom, _ = this._easing;
            let w, C = !1;
            if (this._type === "wheel" && g && _) {
              const R = M.now() - this._lastWheelEventTime, L = Math.min((R + 5) / 200, 1), k = _(L);
              w = o.z.number(g, u, k), L < 1 ? this._frameId || (this._frameId = !0) : C = !0;
            } else w = u, C = !0;
            return this._active = !0, C && (this._active = !1, this._finishTimeout = setTimeout(() => {
              this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
            }, 200)), this._lastExpectedZoom = w, { noInertia: !0, needsRenderFrame: !C, zoomDelta: w - a.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
          }
          _smoothOutEasing(a) {
            let u = o.c9;
            if (this._prevEase) {
              const g = this._prevEase, _ = (M.now() - g.start) / g.duration, w = g.easing(_ + 0.01) - g.easing(_), C = 0.27 / Math.sqrt(w * w + 1e-4) * 0.01, R = Math.sqrt(0.0729 - C * C);
              u = o.c7(C, R, 0.25, 1);
            }
            return this._prevEase = { start: M.now(), duration: a, easing: u }, u;
          }
          reset() {
            this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          }
        }
        class et {
          constructor(a, u) {
            this._clickZoom = a, this._tapZoom = u;
          }
          enable() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }
          disable() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }
          isEnabled() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }
          isActive() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          }
        }
        class ot {
          constructor(a) {
            this._tr = new yl(a), this.reset();
          }
          reset() {
            this._active = !1;
          }
          dblclick(a, u) {
            return a.preventDefault(), { cameraAnimation: (g) => {
              g.easeTo({ duration: 300, zoom: this._tr.zoom + (a.shiftKey ? -1 : 1), around: this._tr.unproject(u) }, { originalEvent: a });
            } };
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class xt {
          constructor() {
            this._tap = new bl({ numTouches: 1, numTaps: 1 }), this.reset();
          }
          reset() {
            this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
          }
          touchstart(a, u, g) {
            if (!this._swipePoint) if (this._tapTime) {
              const _ = u[0], w = a.timeStamp - this._tapTime < 500, C = this._tapPoint.dist(_) < 30;
              w && C ? g.length > 0 && (this._swipePoint = _, this._swipeTouch = g[0].identifier) : this.reset();
            } else this._tap.touchstart(a, u, g);
          }
          touchmove(a, u, g) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (g[0].identifier !== this._swipeTouch) return;
                const _ = u[0], w = _.y - this._swipePoint.y;
                return this._swipePoint = _, a.preventDefault(), this._active = !0, { zoomDelta: w / 128 };
              }
            } else this._tap.touchmove(a, u, g);
          }
          touchend(a, u, g) {
            if (this._tapTime) this._swipePoint && g.length === 0 && this.reset();
            else {
              const _ = this._tap.touchend(a, u, g);
              _ && (this._tapTime = a.timeStamp, this._tapPoint = _);
            }
          }
          touchcancel() {
            this.reset();
          }
          enable() {
            this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this.reset();
          }
          isEnabled() {
            return this._enabled;
          }
          isActive() {
            return this._active;
          }
        }
        class st {
          constructor(a, u, g) {
            this._el = a, this._mousePan = u, this._touchPan = g;
          }
          enable(a) {
            this._inertiaOptions = a || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
          }
          disable() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
          }
          isEnabled() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }
          isActive() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          }
        }
        class Wt {
          constructor(a, u, g, _) {
            this._pitchWithRotate = a.pitchWithRotate, this._rollEnabled = a.rollEnabled, this._mouseRotate = u, this._mousePitch = g, this._mouseRoll = _;
          }
          enable() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
          }
          disable() {
            this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
          }
          isEnabled() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
          }
          isActive() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
          }
        }
        class Ot {
          constructor(a, u, g, _) {
            this._el = a, this._touchZoom = u, this._touchRotate = g, this._tapDragZoom = _, this._rotationDisabled = !1, this._enabled = !0;
          }
          enable(a) {
            this._touchZoom.enable(a), this._rotationDisabled || this._touchRotate.enable(a), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
          }
          disable() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
          }
          isEnabled() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }
          isActive() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }
          disableRotation() {
            this._rotationDisabled = !0, this._touchRotate.disable();
          }
          enableRotation() {
            this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
          }
        }
        class tt {
          constructor(a, u) {
            this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = a, this._options = u, this._enabled = !1;
          }
          isActive() {
            return !1;
          }
          reset() {
          }
          _setupUI() {
            if (this._container) return;
            const a = this._map.getCanvasContainer();
            a.classList.add("maplibregl-cooperative-gestures"), this._container = E.create("div", "maplibregl-cooperative-gesture-screen", a);
            let u = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
            this._bypassKey === "metaKey" && (u = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
            const g = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), _ = document.createElement("div");
            _.className = "maplibregl-desktop-message", _.textContent = u, this._container.appendChild(_);
            const w = document.createElement("div");
            w.className = "maplibregl-mobile-message", w.textContent = g, this._container.appendChild(w), this._container.setAttribute("aria-hidden", "true");
          }
          _destroyUI() {
            this._container && (E.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
          }
          enable() {
            this._setupUI(), this._enabled = !0;
          }
          disable() {
            this._enabled = !1, this._destroyUI();
          }
          isEnabled() {
            return this._enabled;
          }
          isBypassed(a) {
            return a[this._bypassKey];
          }
          notifyGestureBlocked(a, u) {
            this._enabled && (this._map.fire(new o.k("cooperativegestureprevented", { gestureType: a, originalEvent: u })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
              this._container.classList.remove("maplibregl-show");
            }, 100));
          }
        }
        const nt = (v) => v.zoom || v.drag || v.roll || v.pitch || v.rotate;
        class qt extends o.k {
        }
        function Zt(v) {
          return v.panDelta && v.panDelta.mag() || v.zoomDelta || v.bearingDelta || v.pitchDelta || v.rollDelta;
        }
        class dt {
          constructor(a, u) {
            this.handleWindowEvent = (_) => {
              this.handleEvent(_, `${_.type}Window`);
            }, this.handleEvent = (_, w) => {
              if (_.type === "blur") return void this.stop(!0);
              this._updatingCamera = !0;
              const C = _.type === "renderFrame" ? void 0 : _, R = { needsRenderFrame: !1 }, L = {}, k = {}, V = _.touches, W = V ? this._getMapTouches(V) : void 0, Z = W ? E.touchPos(this._map.getCanvas(), W) : E.mousePos(this._map.getCanvas(), _);
              for (const { handlerName: Ce, handler: Se, allowed: Ie } of this._handlers) {
                if (!Se.isEnabled()) continue;
                let Le;
                this._blockedByActive(k, Ie, Ce) ? Se.reset() : Se[w || _.type] && (Le = Se[w || _.type](_, Z, W), this.mergeHandlerResult(R, L, Le, Ce, C), Le && Le.needsRenderFrame && this._triggerRenderFrame()), (Le || Se.isActive()) && (k[Ce] = Se);
              }
              const ae = {};
              for (const Ce in this._previousActiveHandlers) k[Ce] || (ae[Ce] = C);
              this._previousActiveHandlers = k, (Object.keys(ae).length || Zt(R)) && (this._changes.push([R, L, ae]), this._triggerRenderFrame()), (Object.keys(k).length || Zt(R)) && this._map._stop(!0), this._updatingCamera = !1;
              const { cameraAnimation: ue } = R;
              ue && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], ue(this._map));
            }, this._map = a, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Qu(a), this._bearingSnap = u.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(u);
            const g = this._el;
            this._listeners = [[g, "touchstart", { passive: !0 }], [g, "touchmove", { passive: !1 }], [g, "touchend", void 0], [g, "touchcancel", void 0], [g, "mousedown", void 0], [g, "mousemove", void 0], [g, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [g, "mouseover", void 0], [g, "mouseout", void 0], [g, "dblclick", void 0], [g, "click", void 0], [g, "keydown", { capture: !1 }], [g, "keyup", void 0], [g, "wheel", { passive: !1 }], [g, "contextmenu", void 0], [window, "blur", void 0]];
            for (const [_, w, C] of this._listeners) E.addEventListener(_, w, _ === document ? this.handleWindowEvent : this.handleEvent, C);
          }
          destroy() {
            for (const [a, u, g] of this._listeners) E.removeEventListener(a, u, a === document ? this.handleWindowEvent : this.handleEvent, g);
          }
          _addDefaultHandlers(a) {
            const u = this._map, g = u.getCanvasContainer();
            this._add("mapEvent", new Wc(u, a));
            const _ = u.boxZoom = new Xc(u, a);
            this._add("boxZoom", _), a.interactive && a.boxZoom && _.enable();
            const w = u.cooperativeGestures = new tt(u, a.cooperativeGestures);
            this._add("cooperativeGestures", w), a.cooperativeGestures && w.enable();
            const C = new za(u), R = new ot(u);
            u.doubleClickZoom = new et(R, C), this._add("tapZoom", C), this._add("clickZoom", R), a.interactive && a.doubleClickZoom && u.doubleClickZoom.enable();
            const L = new xt();
            this._add("tapDragZoom", L);
            const k = u.touchPitch = new re(u);
            this._add("touchPitch", k), a.interactive && a.touchPitch && u.touchPitch.enable(a.touchPitch);
            const V = () => u.project(u.getCenter()), W = function($e, He) {
              let { enable: Ze, clickTolerance: Je, aroundCenter: vt = !0, minPixelCenterThreshold: _t = 100, rotateDegreesPerPixelMoved: Rt = 0.8 } = $e;
              const Ft = new nc({ checkCorrectEvent: (Mt) => E.mouseButton(Mt) === 0 && Mt.ctrlKey || E.mouseButton(Mt) === 2 && !Mt.ctrlKey });
              return new vr({ clickTolerance: Je, move: (Mt, sr) => {
                const nr = He();
                if (vt && Math.abs(nr.y - Mt.y) > _t) return { bearingDelta: o.c8(new o.P(Mt.x, sr.y), sr, nr) };
                let Gt = (sr.x - Mt.x) * Rt;
                return vt && sr.y < nr.y && (Gt = -Gt), { bearingDelta: Gt };
              }, moveStateManager: Ft, enable: Ze, assignEvents: ja });
            }(a, V), Z = function($e) {
              let { enable: He, clickTolerance: Ze, pitchDegreesPerPixelMoved: Je = -0.5 } = $e;
              const vt = new nc({ checkCorrectEvent: (_t) => E.mouseButton(_t) === 0 && _t.ctrlKey || E.mouseButton(_t) === 2 });
              return new vr({ clickTolerance: Ze, move: (_t, Rt) => ({ pitchDelta: (Rt.y - _t.y) * Je }), moveStateManager: vt, enable: He, assignEvents: ja });
            }(a), ae = function($e, He) {
              let { enable: Ze, clickTolerance: Je, rollDegreesPerPixelMoved: vt = 0.3 } = $e;
              const _t = new nc({ checkCorrectEvent: (Rt) => E.mouseButton(Rt) === 2 && Rt.ctrlKey });
              return new vr({ clickTolerance: Je, move: (Rt, Ft) => {
                const Mt = He();
                let sr = (Ft.x - Rt.x) * vt;
                return Ft.y < Mt.y && (sr = -sr), { rollDelta: sr };
              }, moveStateManager: _t, enable: Ze, assignEvents: ja });
            }(a, V);
            u.dragRotate = new Wt(a, W, Z, ae), this._add("mouseRotate", W, ["mousePitch"]), this._add("mousePitch", Z, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", ae, ["mousePitch"]), a.interactive && a.dragRotate && u.dragRotate.enable();
            const ue = function($e) {
              let { enable: He, clickTolerance: Ze } = $e;
              const Je = new nc({ checkCorrectEvent: (vt) => E.mouseButton(vt) === 0 && !vt.ctrlKey });
              return new vr({ clickTolerance: Ze, move: (vt, _t) => ({ around: _t, panDelta: _t.sub(vt) }), activateOnStart: !0, moveStateManager: Je, enable: He, assignEvents: ja });
            }(a), Ce = new Iu(a, u);
            u.dragPan = new st(g, ue, Ce), this._add("mousePan", ue), this._add("touchPan", Ce, ["touchZoom", "touchRotate"]), a.interactive && a.dragPan && u.dragPan.enable(a.dragPan);
            const Se = new F(), Ie = new S();
            u.touchZoomRotate = new Ot(g, Ie, Se, L), this._add("touchRotate", Se, ["touchPan", "touchZoom"]), this._add("touchZoom", Ie, ["touchPan", "touchRotate"]), a.interactive && a.touchZoomRotate && u.touchZoomRotate.enable(a.touchZoomRotate);
            const Le = u.scrollZoom = new Pe(u, () => this._triggerRenderFrame());
            this._add("scrollZoom", Le, ["mousePan"]), a.interactive && a.scrollZoom && u.scrollZoom.enable(a.scrollZoom);
            const qe = u.keyboard = new ge(u);
            this._add("keyboard", qe), a.interactive && a.keyboard && u.keyboard.enable(), this._add("blockableMapEvent", new eh(u));
          }
          _add(a, u, g) {
            this._handlers.push({ handlerName: a, handler: u, allowed: g }), this._handlersById[a] = u;
          }
          stop(a) {
            if (!this._updatingCamera) {
              for (const { handler: u } of this._handlers) u.reset();
              this._inertia.clear(), this._fireEvents({}, {}, a), this._changes = [];
            }
          }
          isActive() {
            for (const { handler: a } of this._handlers) if (a.isActive()) return !0;
            return !1;
          }
          isZooming() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }
          isRotating() {
            return !!this._eventsInProgress.rotate;
          }
          isMoving() {
            return !!nt(this._eventsInProgress) || this.isZooming();
          }
          _blockedByActive(a, u, g) {
            for (const _ in a) if (_ !== g && (!u || u.indexOf(_) < 0)) return !0;
            return !1;
          }
          _getMapTouches(a) {
            const u = [];
            for (const g of a) this._el.contains(g.target) && u.push(g);
            return u;
          }
          mergeHandlerResult(a, u, g, _, w) {
            if (!g) return;
            o.e(a, g);
            const C = { handlerName: _, originalEvent: g.originalEvent || w };
            g.zoomDelta !== void 0 && (u.zoom = C), g.panDelta !== void 0 && (u.drag = C), g.rollDelta !== void 0 && (u.roll = C), g.pitchDelta !== void 0 && (u.pitch = C), g.bearingDelta !== void 0 && (u.rotate = C);
          }
          _applyChanges() {
            const a = {}, u = {}, g = {};
            for (const [_, w, C] of this._changes) _.panDelta && (a.panDelta = (a.panDelta || new o.P(0, 0))._add(_.panDelta)), _.zoomDelta && (a.zoomDelta = (a.zoomDelta || 0) + _.zoomDelta), _.bearingDelta && (a.bearingDelta = (a.bearingDelta || 0) + _.bearingDelta), _.pitchDelta && (a.pitchDelta = (a.pitchDelta || 0) + _.pitchDelta), _.rollDelta && (a.rollDelta = (a.rollDelta || 0) + _.rollDelta), _.around !== void 0 && (a.around = _.around), _.pinchAround !== void 0 && (a.pinchAround = _.pinchAround), _.noInertia && (a.noInertia = _.noInertia), o.e(u, w), o.e(g, C);
            this._updateMapTransform(a, u, g), this._changes = [];
          }
          _updateMapTransform(a, u, g) {
            const _ = this._map, w = _._getTransformForUpdate(), C = _.terrain;
            if (!(Zt(a) || C && this._terrainMovement)) return this._fireEvents(u, g, !0);
            _._stop(!0);
            let { panDelta: R, zoomDelta: L, bearingDelta: k, pitchDelta: V, rollDelta: W, around: Z, pinchAround: ae } = a;
            ae !== void 0 && (Z = ae), Z = Z || _.transform.centerPoint, C && !w.isPointOnMapSurface(Z) && (Z = w.centerPoint);
            const ue = { panDelta: R, zoomDelta: L, rollDelta: W, pitchDelta: V, bearingDelta: k, around: Z };
            this._map.cameraHelper.useGlobeControls && !w.isPointOnMapSurface(Z) && (Z = w.centerPoint);
            const Ce = Z.distSqr(w.centerPoint) < 0.01 ? w.center : w.screenPointToLocation(R ? Z.sub(R) : Z);
            C ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(ue, w), this._terrainMovement || !u.drag && !u.zoom ? u.drag && this._terrainMovement ? w.setCenter(w.screenPointToLocation(w.centerPoint.sub(R))) : this._map.cameraHelper.handleMapControlsPan(ue, w, Ce) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(ue, w, Ce))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(ue, w), this._map.cameraHelper.handleMapControlsPan(ue, w, Ce)), _._applyUpdatedTransform(w), this._map._update(), a.noInertia || this._inertia.record(a), this._fireEvents(u, g, !0);
          }
          _fireEvents(a, u, g) {
            const _ = nt(this._eventsInProgress), w = nt(a), C = {};
            for (const W in a) {
              const { originalEvent: Z } = a[W];
              this._eventsInProgress[W] || (C[`${W}start`] = Z), this._eventsInProgress[W] = a[W];
            }
            !_ && w && this._fireEvent("movestart", w.originalEvent);
            for (const W in C) this._fireEvent(W, C[W]);
            w && this._fireEvent("move", w.originalEvent);
            for (const W in a) {
              const { originalEvent: Z } = a[W];
              this._fireEvent(W, Z);
            }
            const R = {};
            let L;
            for (const W in this._eventsInProgress) {
              const { handlerName: Z, originalEvent: ae } = this._eventsInProgress[W];
              this._handlersById[Z].isActive() || (delete this._eventsInProgress[W], L = u[Z] || ae, R[`${W}end`] = L);
            }
            for (const W in R) this._fireEvent(W, R[W]);
            const k = nt(this._eventsInProgress), V = (_ || w) && !k;
            if (V && this._terrainMovement) {
              this._map._elevationFreeze = !1, this._terrainMovement = !1;
              const W = this._map._getTransformForUpdate();
              this._map.getCenterClampedToGround() && W.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(W);
            }
            if (g && V) {
              this._updatingCamera = !0;
              const W = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), Z = (ae) => ae !== 0 && -this._bearingSnap < ae && ae < this._bearingSnap;
              !W || !W.essential && M.prefersReducedMotion ? (this._map.fire(new o.k("moveend", { originalEvent: L })), Z(this._map.getBearing()) && this._map.resetNorth()) : (Z(W.bearing || this._map.getBearing()) && (W.bearing = 0), W.freezeElevation = !0, this._map.easeTo(W, { originalEvent: L })), this._updatingCamera = !1;
            }
          }
          _fireEvent(a, u) {
            this._map.fire(new o.k(a, u ? { originalEvent: u } : {}));
          }
          _requestFrame() {
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add((a) => {
              delete this._frameId, this.handleEvent(new qt("renderFrame", { timeStamp: a })), this._applyChanges();
            });
          }
          _triggerRenderFrame() {
            this._frameId === void 0 && (this._frameId = this._requestFrame());
          }
        }
        class Vt extends o.E {
          constructor(a, u, g) {
            super(), this._renderFrameCallback = () => {
              const _ = Math.min((M.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(_)), _ < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, this._moving = !1, this._zooming = !1, this.transform = a, this._bearingSnap = g.bearingSnap, this.cameraHelper = u, this.on("moveend", () => {
              delete this._requestedCameraState;
            });
          }
          migrateProjection(a, u) {
            a.apply(this.transform), this.transform = a, this.cameraHelper = u;
          }
          getCenter() {
            return new o.O(this.transform.center.lng, this.transform.center.lat);
          }
          setCenter(a, u) {
            return this.jumpTo({ center: a }, u);
          }
          getCenterElevation() {
            return this.transform.elevation;
          }
          setCenterElevation(a, u) {
            return this.jumpTo({ elevation: a }, u), this;
          }
          getCenterClampedToGround() {
            return this._centerClampedToGround;
          }
          setCenterClampedToGround(a) {
            this._centerClampedToGround = a;
          }
          panBy(a, u, g) {
            return a = o.P.convert(a).mult(-1), this.panTo(this.transform.center, o.e({ offset: a }, u), g);
          }
          panTo(a, u, g) {
            return this.easeTo(o.e({ center: a }, u), g);
          }
          getZoom() {
            return this.transform.zoom;
          }
          setZoom(a, u) {
            return this.jumpTo({ zoom: a }, u), this;
          }
          zoomTo(a, u, g) {
            return this.easeTo(o.e({ zoom: a }, u), g);
          }
          zoomIn(a, u) {
            return this.zoomTo(this.getZoom() + 1, a, u), this;
          }
          zoomOut(a, u) {
            return this.zoomTo(this.getZoom() - 1, a, u), this;
          }
          getVerticalFieldOfView() {
            return this.transform.fov;
          }
          setVerticalFieldOfView(a, u) {
            return a != this.transform.fov && (this.transform.setFov(a), this.fire(new o.k("movestart", u)).fire(new o.k("move", u)).fire(new o.k("moveend", u))), this;
          }
          getBearing() {
            return this.transform.bearing;
          }
          setBearing(a, u) {
            return this.jumpTo({ bearing: a }, u), this;
          }
          getPadding() {
            return this.transform.padding;
          }
          setPadding(a, u) {
            return this.jumpTo({ padding: a }, u), this;
          }
          rotateTo(a, u, g) {
            return this.easeTo(o.e({ bearing: a }, u), g);
          }
          resetNorth(a, u) {
            return this.rotateTo(0, o.e({ duration: 1e3 }, a), u), this;
          }
          resetNorthPitch(a, u) {
            return this.easeTo(o.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, a), u), this;
          }
          snapToNorth(a, u) {
            return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(a, u) : this;
          }
          getPitch() {
            return this.transform.pitch;
          }
          setPitch(a, u) {
            return this.jumpTo({ pitch: a }, u), this;
          }
          getRoll() {
            return this.transform.roll;
          }
          setRoll(a, u) {
            return this.jumpTo({ roll: a }, u), this;
          }
          cameraForBounds(a, u) {
            a = Cr.convert(a).adjustAntiMeridian();
            const g = u && u.bearing || 0;
            return this._cameraForBoxAndBearing(a.getNorthWest(), a.getSouthEast(), g, u);
          }
          _cameraForBoxAndBearing(a, u, g, _) {
            const w = { top: 0, bottom: 0, right: 0, left: 0 };
            if (typeof (_ = o.e({ padding: w, offset: [0, 0], maxZoom: this.transform.maxZoom }, _)).padding == "number") {
              const k = _.padding;
              _.padding = { top: k, bottom: k, right: k, left: k };
            }
            const C = o.e(w, _.padding);
            _.padding = C;
            const R = this.transform, L = new Cr(a, u);
            return this.cameraHelper.cameraForBoxAndBearing(_, C, L, g, R);
          }
          fitBounds(a, u, g) {
            return this._fitInternal(this.cameraForBounds(a, u), u, g);
          }
          fitScreenCoordinates(a, u, g, _, w) {
            return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(o.P.convert(a)), this.transform.screenPointToLocation(o.P.convert(u)), g, _), _, w);
          }
          _fitInternal(a, u, g) {
            return a ? (delete (u = o.e(a, u)).padding, u.linear ? this.easeTo(u, g) : this.flyTo(u, g)) : this;
          }
          jumpTo(a, u) {
            this.stop();
            const g = this._getTransformForUpdate();
            let _ = !1, w = !1, C = !1;
            const R = g.zoom;
            this.cameraHelper.handleJumpToCenterZoom(g, a);
            const L = g.zoom !== R;
            return "elevation" in a && g.elevation !== +a.elevation && g.setElevation(+a.elevation), "bearing" in a && g.bearing !== +a.bearing && (_ = !0, g.setBearing(+a.bearing)), "pitch" in a && g.pitch !== +a.pitch && (w = !0, g.setPitch(+a.pitch)), "roll" in a && g.roll !== +a.roll && (C = !0, g.setRoll(+a.roll)), a.padding == null || g.isPaddingEqual(a.padding) || g.setPadding(a.padding), this._applyUpdatedTransform(g), this.fire(new o.k("movestart", u)).fire(new o.k("move", u)), L && this.fire(new o.k("zoomstart", u)).fire(new o.k("zoom", u)).fire(new o.k("zoomend", u)), _ && this.fire(new o.k("rotatestart", u)).fire(new o.k("rotate", u)).fire(new o.k("rotateend", u)), w && this.fire(new o.k("pitchstart", u)).fire(new o.k("pitch", u)).fire(new o.k("pitchend", u)), C && this.fire(new o.k("rollstart", u)).fire(new o.k("roll", u)).fire(new o.k("rollend", u)), this.fire(new o.k("moveend", u));
          }
          calculateCameraOptionsFromTo(a, u, g) {
            let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            const w = o.Z.fromLngLat(a, u), C = o.Z.fromLngLat(g, _), R = C.x - w.x, L = C.y - w.y, k = C.z - w.z, V = Math.hypot(R, L, k);
            if (V === 0) throw new Error("Can't calculate camera options with same From and To");
            const W = Math.hypot(R, L), Z = o.a9(this.transform.cameraToCenterDistance / V / this.transform.tileSize), ae = 180 * Math.atan2(R, -L) / Math.PI;
            let ue = 180 * Math.acos(W / V) / Math.PI;
            return ue = k < 0 ? 90 - ue : 90 + ue, { center: C.toLngLat(), elevation: _, zoom: Z, pitch: ue, bearing: ae };
          }
          calculateCameraOptionsFromCameraLngLatAltRotation(a, u, g, _, w) {
            const C = this.transform.calculateCenterFromCameraLngLatAlt(a, u, g, _);
            return { center: C.center, elevation: C.elevation, zoom: C.zoom, bearing: g, pitch: _, roll: w };
          }
          easeTo(a, u) {
            this._stop(!1, a.easeId), ((a = o.e({ offset: [0, 0], duration: 500, easing: o.c9 }, a)).animate === !1 || !a.essential && M.prefersReducedMotion) && (a.duration = 0);
            const g = this._getTransformForUpdate(), _ = this.getBearing(), w = g.pitch, C = g.roll, R = "bearing" in a ? this._normalizeBearing(a.bearing, _) : _, L = "pitch" in a ? +a.pitch : w, k = "roll" in a ? this._normalizeBearing(a.roll, C) : C, V = "padding" in a ? a.padding : g.padding, W = o.P.convert(a.offset);
            let Z, ae;
            a.around && (Z = o.O.convert(a.around), ae = g.locationToScreenPoint(Z));
            const ue = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, Ce = this.cameraHelper.handleEaseTo(g, { bearing: R, pitch: L, roll: k, padding: V, around: Z, aroundPoint: ae, offsetAsPoint: W, offset: a.offset, zoom: a.zoom, center: a.center });
            return this._rotating = this._rotating || _ !== R, this._pitching = this._pitching || L !== w, this._rolling = this._rolling || k !== C, this._padding = !g.isPaddingEqual(V), this._zooming = this._zooming || Ce.isZooming, this._easeId = a.easeId, this._prepareEase(u, a.noMoveStart, ue), this.terrain && this._prepareElevation(Ce.elevationCenter), this._ease((Se) => {
              Ce.easeFunc(Se), this.terrain && !a.freezeElevation && this._updateElevation(Se), this._applyUpdatedTransform(g), this._fireMoveEvents(u);
            }, (Se) => {
              this.terrain && a.freezeElevation && this._finalizeElevation(), this._afterEase(u, Se);
            }, a), this;
          }
          _prepareEase(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            this._moving = !0, u || g.moving || this.fire(new o.k("movestart", a)), this._zooming && !g.zooming && this.fire(new o.k("zoomstart", a)), this._rotating && !g.rotating && this.fire(new o.k("rotatestart", a)), this._pitching && !g.pitching && this.fire(new o.k("pitchstart", a)), this._rolling && !g.rolling && this.fire(new o.k("rollstart", a));
          }
          _prepareElevation(a) {
            this._elevationCenter = a, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(a, this.transform.tileZoom), this._elevationFreeze = !0;
          }
          _updateElevation(a) {
            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
            const u = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
            if (a < 1 && u !== this._elevationTarget) {
              const g = this._elevationTarget - this._elevationStart;
              this._elevationStart += a * (g - (u - (g * a + this._elevationStart)) / (1 - a)), this._elevationTarget = u;
            }
            this.transform.setElevation(o.z.number(this._elevationStart, this._elevationTarget, a));
          }
          _finalizeElevation() {
            this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
          }
          _getTransformForUpdate() {
            return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
          }
          _elevateCameraIfInsideTerrain(a) {
            if (!this.terrain && a.elevation >= 0 && a.pitch <= 90) return {};
            const u = a.getCameraLngLat(), g = a.getCameraAltitude(), _ = this.terrain ? this.terrain.getElevationForLngLatZoom(u, a.zoom) : 0;
            if (g < _) {
              const w = this.calculateCameraOptionsFromTo(u, _, a.center, a.elevation);
              return { pitch: w.pitch, zoom: w.zoom };
            }
            return {};
          }
          _applyUpdatedTransform(a) {
            const u = [];
            if (u.push((_) => this._elevateCameraIfInsideTerrain(_)), this.transformCameraUpdate && u.push((_) => this.transformCameraUpdate(_)), !u.length) return;
            const g = a.clone();
            for (const _ of u) {
              const w = g.clone(), { center: C, zoom: R, roll: L, pitch: k, bearing: V, elevation: W } = _(w);
              C && w.setCenter(C), W !== void 0 && w.setElevation(W), R !== void 0 && w.setZoom(R), L !== void 0 && w.setRoll(L), k !== void 0 && w.setPitch(k), V !== void 0 && w.setBearing(V), g.apply(w);
            }
            this.transform.apply(g);
          }
          _fireMoveEvents(a) {
            this.fire(new o.k("move", a)), this._zooming && this.fire(new o.k("zoom", a)), this._rotating && this.fire(new o.k("rotate", a)), this._pitching && this.fire(new o.k("pitch", a)), this._rolling && this.fire(new o.k("roll", a));
          }
          _afterEase(a, u) {
            if (this._easeId && u && this._easeId === u) return;
            delete this._easeId;
            const g = this._zooming, _ = this._rotating, w = this._pitching, C = this._rolling;
            this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, g && this.fire(new o.k("zoomend", a)), _ && this.fire(new o.k("rotateend", a)), w && this.fire(new o.k("pitchend", a)), C && this.fire(new o.k("rollend", a)), this.fire(new o.k("moveend", a));
          }
          flyTo(a, u) {
            if (!a.essential && M.prefersReducedMotion) {
              const Mt = o.N(a, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
              return this.jumpTo(Mt, u);
            }
            this.stop(), a = o.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: o.c9 }, a);
            const g = this._getTransformForUpdate(), _ = g.bearing, w = g.pitch, C = g.roll, R = g.padding, L = "bearing" in a ? this._normalizeBearing(a.bearing, _) : _, k = "pitch" in a ? +a.pitch : w, V = "roll" in a ? this._normalizeBearing(a.roll, C) : C, W = "padding" in a ? a.padding : g.padding, Z = o.P.convert(a.offset);
            let ae = g.centerPoint.add(Z);
            const ue = g.screenPointToLocation(ae), Ce = this.cameraHelper.handleFlyTo(g, { bearing: L, pitch: k, roll: V, padding: W, locationAtOffset: ue, offsetAsPoint: Z, center: a.center, minZoom: a.minZoom, zoom: a.zoom });
            let Se = a.curve;
            const Ie = Math.max(g.width, g.height), Le = Ie / Ce.scaleOfZoom, qe = Ce.pixelPathLength;
            typeof Ce.scaleOfMinZoom == "number" && (Se = Math.sqrt(Ie / Ce.scaleOfMinZoom / qe * 2));
            const $e = Se * Se;
            function He(Mt) {
              const sr = (Le * Le - Ie * Ie + (Mt ? -1 : 1) * $e * $e * qe * qe) / (2 * (Mt ? Le : Ie) * $e * qe);
              return Math.log(Math.sqrt(sr * sr + 1) - sr);
            }
            function Ze(Mt) {
              return (Math.exp(Mt) - Math.exp(-Mt)) / 2;
            }
            function Je(Mt) {
              return (Math.exp(Mt) + Math.exp(-Mt)) / 2;
            }
            const vt = He(!1);
            let _t = function(Mt) {
              return Je(vt) / Je(vt + Se * Mt);
            }, Rt = function(Mt) {
              return Ie * ((Je(vt) * (Ze(sr = vt + Se * Mt) / Je(sr)) - Ze(vt)) / $e) / qe;
              var sr;
            }, Ft = (He(!0) - vt) / Se;
            if (Math.abs(qe) < 2e-6 || !isFinite(Ft)) {
              if (Math.abs(Ie - Le) < 1e-6) return this.easeTo(a, u);
              const Mt = Le < Ie ? -1 : 1;
              Ft = Math.abs(Math.log(Le / Ie)) / Se, Rt = () => 0, _t = (sr) => Math.exp(Mt * Se * sr);
            }
            return a.duration = "duration" in a ? +a.duration : 1e3 * Ft / ("screenSpeed" in a ? +a.screenSpeed / Se : +a.speed), a.maxDuration && a.duration > a.maxDuration && (a.duration = 0), this._zooming = !0, this._rotating = _ !== L, this._pitching = k !== w, this._rolling = V !== C, this._padding = !g.isPaddingEqual(W), this._prepareEase(u, !1), this.terrain && this._prepareElevation(Ce.targetCenter), this._ease((Mt) => {
              const sr = Mt * Ft, nr = 1 / _t(sr), Gt = Rt(sr);
              this._rotating && g.setBearing(o.z.number(_, L, Mt)), this._pitching && g.setPitch(o.z.number(w, k, Mt)), this._rolling && g.setRoll(o.z.number(C, V, Mt)), this._padding && (g.interpolatePadding(R, W, Mt), ae = g.centerPoint.add(Z)), Ce.easeFunc(Mt, nr, Gt, ae), this.terrain && !a.freezeElevation && this._updateElevation(Mt), this._applyUpdatedTransform(g), this._fireMoveEvents(u);
            }, () => {
              this.terrain && a.freezeElevation && this._finalizeElevation(), this._afterEase(u);
            }, a), this;
          }
          isEasing() {
            return !!this._easeFrameId;
          }
          stop() {
            return this._stop();
          }
          _stop(a, u) {
            var g;
            if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
              const _ = this._onEaseEnd;
              delete this._onEaseEnd, _.call(this, u);
            }
            return a || (g = this.handlers) === null || g === void 0 || g.stop(!1), this;
          }
          _ease(a, u, g) {
            g.animate === !1 || g.duration === 0 ? (a(1), u()) : (this._easeStart = M.now(), this._easeOptions = g, this._onEaseFrame = a, this._onEaseEnd = u, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
          }
          _normalizeBearing(a, u) {
            a = o.aJ(a, -180, 180);
            const g = Math.abs(a - u);
            return Math.abs(a - 360 - u) < g && (a -= 360), Math.abs(a + 360 - u) < g && (a += 360), a;
          }
          queryTerrainElevation(a) {
            return this.terrain ? this.terrain.getElevationForLngLatZoom(o.O.convert(a), this.transform.tileZoom) : null;
          }
        }
        const yr = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
        class Ur {
          constructor() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : yr;
            this._toggleAttribution = () => {
              this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
            }, this._updateData = (u) => {
              !u || u.sourceDataType !== "metadata" && u.sourceDataType !== "visibility" && u.dataType !== "style" && u.type !== "terrain" || this._updateAttributions();
            }, this._updateCompact = () => {
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
            }, this._updateCompactMinimize = () => {
              this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
            }, this.options = a;
          }
          getDefaultPosition() {
            return "bottom-right";
          }
          onAdd(a) {
            return this._map = a, this._compact = this.options.compact, this._container = E.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = E.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = E.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
          }
          onRemove() {
            E.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._sanitizedAttributionHTML = void 0;
          }
          _setElementTitle(a, u) {
            const g = this._map._getUIString(`AttributionControl.${u}`);
            a.title = g, a.setAttribute("aria-label", g);
          }
          _updateAttributions() {
            if (!this._map.style) return;
            let a = [];
            if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? a = a.concat(this.options.customAttribution.map((_) => typeof _ != "string" ? "" : _)) : typeof this.options.customAttribution == "string" && a.push(this.options.customAttribution)), this._map.style.stylesheet) {
              const _ = this._map.style.stylesheet;
              this.styleOwner = _.owner, this.styleId = _.id;
            }
            const u = this._map.style.sourceCaches;
            for (const _ in u) {
              const w = u[_];
              if (w.used || w.usedForTerrain) {
                const C = w.getSource();
                C.attribution && a.indexOf(C.attribution) < 0 && a.push(C.attribution);
              }
            }
            a = a.filter((_) => String(_).trim()), a.sort((_, w) => _.length - w.length), a = a.filter((_, w) => {
              for (let C = w + 1; C < a.length; C++) if (a[C].indexOf(_) >= 0) return !1;
              return !0;
            });
            const g = a.join(" | ");
            g !== this._sanitizedAttributionHTML && (this._sanitizedAttributionHTML = E.sanitize(g), a.length ? (this._innerContainer.innerHTML = this._sanitizedAttributionHTML, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
          }
        }
        class xr {
          constructor() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            this._updateCompact = () => {
              const u = this._container.children;
              if (u.length) {
                const g = u[0];
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && g.classList.add("maplibregl-compact") : g.classList.remove("maplibregl-compact");
              }
            }, this.options = a;
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(a) {
            this._map = a, this._compact = this.options && this.options.compact, this._container = E.create("div", "maplibregl-ctrl");
            const u = E.create("a", "maplibregl-ctrl-logo");
            return u.target = "_blank", u.rel = "noopener nofollow", u.href = "https://maplibre.org/", u.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), u.setAttribute("rel", "noopener nofollow"), this._container.appendChild(u), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }
          onRemove() {
            E.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
          }
        }
        class rn {
          constructor() {
            this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
          }
          add(a) {
            const u = ++this._id;
            return this._queue.push({ callback: a, id: u, cancelled: !1 }), u;
          }
          remove(a) {
            const u = this._currentlyRunning, g = u ? this._queue.concat(u) : this._queue;
            for (const _ of g) if (_.id === a) return void (_.cancelled = !0);
          }
          run() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
            if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
            const u = this._currentlyRunning = this._queue;
            this._queue = [];
            for (const g of u) if (!g.cancelled && (g.callback(a), this._cleared)) break;
            this._cleared = !1, this._currentlyRunning = !1;
          }
          clear() {
            this._currentlyRunning && (this._cleared = !0), this._queue = [];
          }
        }
        var Ln = o.aB([{ name: "a_pos3d", type: "Int16", components: 3 }]);
        class on extends o.E {
          constructor(a) {
            super(), this._lastTilesetChange = M.now(), this.sourceCache = a, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = a._source.tileSize * 2 ** this.deltaZoom, a.usedForTerrain = !0, a.tileSize = this.tileSize;
          }
          destruct() {
            this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
          }
          update(a, u) {
            this.sourceCache.update(a, u), this._renderableTilesKeys = [];
            const g = {};
            for (const _ of ve(a, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: u, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) g[_.key] = !0, this._renderableTilesKeys.push(_.key), this._tiles[_.key] || (_.terrainRttPosMatrix32f = new Float64Array(16), o.bM(_.terrainRttPosMatrix32f, 0, o.Y, o.Y, 0, 0, 1), this._tiles[_.key] = new Vr(_, this.tileSize), this._lastTilesetChange = M.now());
            for (const _ in this._tiles) g[_] || delete this._tiles[_];
          }
          freeRtt(a) {
            for (const u in this._tiles) {
              const g = this._tiles[u];
              (!a || g.tileID.equals(a) || g.tileID.isChildOf(a) || a.isChildOf(g.tileID)) && (g.rtt = []);
            }
          }
          getRenderableTiles() {
            return this._renderableTilesKeys.map((a) => this.getTileByID(a));
          }
          getTileByID(a) {
            return this._tiles[a];
          }
          getTerrainCoords(a) {
            const u = {};
            for (const g of this._renderableTilesKeys) {
              const _ = this._tiles[g].tileID, w = a.clone(), C = o.b0();
              if (_.canonical.equals(a.canonical)) o.bM(C, 0, o.Y, o.Y, 0, 0, 1);
              else if (_.canonical.isChildOf(a.canonical)) {
                const R = _.canonical.z - a.canonical.z, L = _.canonical.x - (_.canonical.x >> R << R), k = _.canonical.y - (_.canonical.y >> R << R), V = o.Y >> R;
                o.bM(C, 0, V, V, 0, 0, 1), o.K(C, C, [-L * V, -k * V, 0]);
              } else {
                if (!a.canonical.isChildOf(_.canonical)) continue;
                {
                  const R = a.canonical.z - _.canonical.z, L = a.canonical.x - (a.canonical.x >> R << R), k = a.canonical.y - (a.canonical.y >> R << R), V = o.Y >> R;
                  o.bM(C, 0, o.Y, o.Y, 0, 0, 1), o.K(C, C, [L * V, k * V, 0]), o.L(C, C, [1 / 2 ** R, 1 / 2 ** R, 0]);
                }
              }
              w.terrainRttPosMatrix32f = new Float32Array(C), u[g] = w;
            }
            return u;
          }
          getSourceTile(a, u) {
            const g = this.sourceCache._source;
            let _ = a.overscaledZ - this.deltaZoom;
            if (_ > g.maxzoom && (_ = g.maxzoom), _ < g.minzoom) return null;
            this._sourceTileCache[a.key] || (this._sourceTileCache[a.key] = a.scaledTo(_).key);
            let w = this.sourceCache.getTileByID(this._sourceTileCache[a.key]);
            if ((!w || !w.dem) && u) for (; _ >= g.minzoom && (!w || !w.dem); ) w = this.sourceCache.getTileByID(a.scaledTo(_--).key);
            return w;
          }
          anyTilesAfterTime() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Date.now();
            return this._lastTilesetChange >= a;
          }
        }
        class wn {
          constructor(a, u, g) {
            this._meshCache = {}, this.painter = a, this.sourceCache = new on(u), this.options = g, this.exaggeration = typeof g.exaggeration == "number" ? g.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
          }
          getDEMElevation(a, u, g) {
            let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : o.Y;
            var w;
            if (!(u >= 0 && u < _ && g >= 0 && g < _)) return 0;
            const C = this.getTerrainData(a), R = (w = C.tile) === null || w === void 0 ? void 0 : w.dem;
            if (!R) return 0;
            const L = o.ca([], [u / _ * o.Y, g / _ * o.Y], C.u_terrain_matrix), k = [L[0] * R.dim, L[1] * R.dim], V = Math.floor(k[0]), W = Math.floor(k[1]), Z = k[0] - V, ae = k[1] - W;
            return R.get(V, W) * (1 - Z) * (1 - ae) + R.get(V + 1, W) * Z * (1 - ae) + R.get(V, W + 1) * (1 - Z) * ae + R.get(V + 1, W + 1) * Z * ae;
          }
          getElevationForLngLatZoom(a, u) {
            if (!o.cb(u, a.wrap())) return 0;
            const { tileID: g, mercatorX: _, mercatorY: w } = this._getOverscaledTileIDFromLngLatZoom(a, u);
            return this.getElevation(g, _ % o.Y, w % o.Y, o.Y);
          }
          getElevation(a, u, g) {
            let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : o.Y;
            return this.getDEMElevation(a, u, g, _) * this.exaggeration;
          }
          getTerrainData(a) {
            if (!this._emptyDemTexture) {
              const _ = this.painter.context, w = new o.R({ width: 1, height: 1 }, new Uint8Array(4));
              this._emptyDepthTexture = new oe(_, w, _.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new oe(_, new o.R({ width: 1, height: 1 }), _.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(_.gl.NEAREST, _.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = o.ar([]);
            }
            const u = this.sourceCache.getSourceTile(a, !0);
            if (u && u.dem && (!u.demTexture || u.needsTerrainPrepare)) {
              const _ = this.painter.context;
              u.demTexture = this.painter.getTileTexture(u.dem.stride), u.demTexture ? u.demTexture.update(u.dem.getPixels(), { premultiply: !1 }) : u.demTexture = new oe(_, u.dem.getPixels(), _.gl.RGBA, { premultiply: !1 }), u.demTexture.bind(_.gl.NEAREST, _.gl.CLAMP_TO_EDGE), u.needsTerrainPrepare = !1;
            }
            const g = u && u + u.tileID.key + a.key;
            if (g && !this._demMatrixCache[g]) {
              const _ = this.sourceCache.sourceCache._source.maxzoom;
              let w = a.canonical.z - u.tileID.canonical.z;
              a.overscaledZ > a.canonical.z && (a.canonical.z >= _ ? w = a.canonical.z - _ : o.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
              const C = a.canonical.x - (a.canonical.x >> w << w), R = a.canonical.y - (a.canonical.y >> w << w), L = o.cc(new Float64Array(16), [1 / (o.Y << w), 1 / (o.Y << w), 0]);
              o.K(L, L, [C * o.Y, R * o.Y, 0]), this._demMatrixCache[a.key] = { matrix: L, coord: a };
            }
            return { u_depth: 2, u_terrain: 3, u_terrain_dim: u && u.dem && u.dem.dim || 1, u_terrain_matrix: g ? this._demMatrixCache[a.key].matrix : this._emptyDemMatrix, u_terrain_unpack: u && u.dem && u.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (u && u.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: u };
          }
          getFramebuffer(a) {
            const u = this.painter, g = u.width / devicePixelRatio, _ = u.height / devicePixelRatio;
            return !this._fbo || this._fbo.width === g && this._fbo.height === _ || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new oe(u.context, { width: g, height: _, data: null }, u.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(u.context.gl.NEAREST, u.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new oe(u.context, { width: g, height: _, data: null }, u.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(u.context.gl.NEAREST, u.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = u.context.createFramebuffer(g, _, !0, !1), this._fbo.depthAttachment.set(u.context.createRenderbuffer(u.context.gl.DEPTH_COMPONENT16, g, _))), this._fbo.colorAttachment.set(a === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
          }
          getCoordsTexture() {
            const a = this.painter.context;
            if (this._coordsTexture) return this._coordsTexture;
            const u = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
            for (let w = 0, C = 0; w < this._coordsTextureSize; w++) for (let R = 0; R < this._coordsTextureSize; R++, C += 4) u[C + 0] = 255 & R, u[C + 1] = 255 & w, u[C + 2] = R >> 8 << 4 | w >> 8, u[C + 3] = 0;
            const g = new o.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(u.buffer)), _ = new oe(a, g, a.gl.RGBA, { premultiply: !1 });
            return _.bind(a.gl.NEAREST, a.gl.CLAMP_TO_EDGE), this._coordsTexture = _, _;
          }
          pointCoordinate(a) {
            this.painter.maybeDrawDepthAndCoords(!0);
            const u = new Uint8Array(4), g = this.painter.context, _ = g.gl, w = Math.round(a.x * this.painter.pixelRatio / devicePixelRatio), C = Math.round(a.y * this.painter.pixelRatio / devicePixelRatio), R = Math.round(this.painter.height / devicePixelRatio);
            g.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), _.readPixels(w, R - C - 1, 1, 1, _.RGBA, _.UNSIGNED_BYTE, u), g.bindFramebuffer.set(null);
            const L = u[0] + (u[2] >> 4 << 8), k = u[1] + ((15 & u[2]) << 8), V = this.coordsIndex[255 - u[3]], W = V && this.sourceCache.getTileByID(V);
            if (!W) return null;
            const Z = this._coordsTextureSize, ae = (1 << W.tileID.canonical.z) * Z;
            return new o.Z((W.tileID.canonical.x * Z + L) / ae + W.tileID.wrap, (W.tileID.canonical.y * Z + k) / ae, this.getElevation(W.tileID, L, k, Z));
          }
          depthAtPoint(a) {
            const u = new Uint8Array(4), g = this.painter.context, _ = g.gl;
            return g.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), _.readPixels(a.x, this.painter.height / devicePixelRatio - a.y - 1, 1, 1, _.RGBA, _.UNSIGNED_BYTE, u), g.bindFramebuffer.set(null), (u[0] / 16777216 + u[1] / 65536 + u[2] / 256 + u[3]) / 256;
          }
          getTerrainMesh(a) {
            var u;
            const g = ((u = this.painter.style.projection) === null || u === void 0 ? void 0 : u.transitionState) > 0, _ = g && a.canonical.y === 0, w = g && a.canonical.y === (1 << a.canonical.z) - 1, C = `m_${_ ? "n" : ""}_${w ? "s" : ""}`;
            if (this._meshCache[C]) return this._meshCache[C];
            const R = this.painter.context, L = new o.cd(), k = new o.aF(), V = this.meshSize, W = o.Y / V, Z = V * V;
            for (let Je = 0; Je <= V; Je++) for (let vt = 0; vt <= V; vt++) L.emplaceBack(vt * W, Je * W, 0);
            for (let Je = 0; Je < Z; Je += V + 1) for (let vt = 0; vt < V; vt++) k.emplaceBack(vt + Je, V + vt + Je + 1, V + vt + Je + 2), k.emplaceBack(vt + Je, V + vt + Je + 2, vt + Je + 1);
            const ae = L.length, ue = ae + (V + 1), Ce = (V + 1) * V, Se = _ ? o.b7 : 0, Ie = _ ? 0 : 1, Le = w ? o.b8 : o.Y, qe = w ? 0 : 1;
            for (let Je = 0; Je <= V; Je++) L.emplaceBack(Je * W, Se, Ie);
            for (let Je = 0; Je <= V; Je++) L.emplaceBack(Je * W, Le, qe);
            for (let Je = 0; Je < V; Je++) k.emplaceBack(Ce + Je, ue + Je, ue + Je + 1), k.emplaceBack(Ce + Je, ue + Je + 1, Ce + Je + 1), k.emplaceBack(0 + Je, ae + Je + 1, ae + Je), k.emplaceBack(0 + Je, 0 + Je + 1, ae + Je + 1);
            const $e = L.length, He = $e + 2 * (V + 1);
            for (const Je of [0, 1]) for (let vt = 0; vt <= V; vt++) for (const _t of [0, 1]) L.emplaceBack(Je * o.Y, vt * W, _t);
            for (let Je = 0; Je < 2 * V; Je += 2) k.emplaceBack($e + Je, $e + Je + 1, $e + Je + 3), k.emplaceBack($e + Je, $e + Je + 3, $e + Je + 2), k.emplaceBack(He + Je, He + Je + 3, He + Je + 1), k.emplaceBack(He + Je, He + Je + 2, He + Je + 3);
            const Ze = new co(R.createVertexBuffer(L, Ln.members), R.createIndexBuffer(k), o.aE.simpleSegment(0, 0, L.length, k.length));
            return this._meshCache[C] = Ze, Ze;
          }
          getMeshFrameDelta(a) {
            return 2 * Math.PI * o.bp / Math.pow(2, Math.max(a, 0)) / 5;
          }
          getMinTileElevationForLngLatZoom(a, u) {
            var g;
            const { tileID: _ } = this._getOverscaledTileIDFromLngLatZoom(a, u);
            return (g = this.getMinMaxElevation(_).minElevation) !== null && g !== void 0 ? g : 0;
          }
          getMinMaxElevation(a) {
            const u = this.getTerrainData(a).tile, g = { minElevation: null, maxElevation: null };
            return u && u.dem && (g.minElevation = u.dem.min * this.exaggeration, g.maxElevation = u.dem.max * this.exaggeration), g;
          }
          _getOverscaledTileIDFromLngLatZoom(a, u) {
            const g = o.Z.fromLngLat(a.wrap()), _ = (1 << u) * o.Y, w = g.x * _, C = g.y * _, R = Math.floor(w / o.Y), L = Math.floor(C / o.Y);
            return { tileID: new o.X(u, 0, u, R, L), mercatorX: w, mercatorY: C };
          }
        }
        class Mn {
          constructor(a, u, g) {
            this._context = a, this._size = u, this._tileSize = g, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
          }
          destruct() {
            for (const a of this._objects) a.texture.destroy(), a.fbo.destroy();
          }
          _createObject(a) {
            const u = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), g = new oe(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
            return g.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), u.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), u.colorAttachment.set(g.texture), { id: a, fbo: u, texture: g, stamp: -1, inUse: !1 };
          }
          getObjectForId(a) {
            return this._objects[a];
          }
          useObject(a) {
            a.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((u) => a.id !== u), this._recentlyUsed.push(a.id);
          }
          stampObject(a) {
            a.stamp = ++this._stamp;
          }
          getOrCreateFreeObject() {
            for (const u of this._recentlyUsed) if (!this._objects[u].inUse) return this._objects[u];
            if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
            const a = this._createObject(this._objects.length);
            return this._objects.push(a), a;
          }
          freeObject(a) {
            a.inUse = !1;
          }
          freeAllObjects() {
            for (const a of this._objects) this.freeObject(a);
          }
          isFull() {
            return !(this._objects.length < this._size) && this._objects.some((a) => !a.inUse) === !1;
          }
        }
        const zr = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
        class Br {
          constructor(a, u) {
            this.painter = a, this.terrain = u, this.pool = new Mn(a.context, 30, u.sourceCache.tileSize * u.qualityFactor);
          }
          destruct() {
            this.pool.destruct();
          }
          getTexture(a) {
            return this.pool.getObjectForId(a.rtt[this._stacks.length - 1].id).texture;
          }
          prepareForRender(a, u) {
            this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = a._order.filter((g) => !a._layers[g].isHidden(u)), this._coordsAscending = {};
            for (const g in a.sourceCaches) {
              this._coordsAscending[g] = {};
              const _ = a.sourceCaches[g].getVisibleCoordinates();
              for (const w of _) {
                const C = this.terrain.sourceCache.getTerrainCoords(w);
                for (const R in C) this._coordsAscending[g][R] || (this._coordsAscending[g][R] = []), this._coordsAscending[g][R].push(C[R]);
              }
            }
            this._coordsAscendingStr = {};
            for (const g of a._order) {
              const _ = a._layers[g], w = _.source;
              if (zr[_.type] && !this._coordsAscendingStr[w]) {
                this._coordsAscendingStr[w] = {};
                for (const C in this._coordsAscending[w]) this._coordsAscendingStr[w][C] = this._coordsAscending[w][C].map((R) => R.key).sort().join();
              }
            }
            for (const g of this._renderableTiles) for (const _ in this._coordsAscendingStr) {
              const w = this._coordsAscendingStr[_][g.tileID.key];
              w && w !== g.rttCoords[_] && (g.rtt = []);
            }
          }
          renderLayer(a, u) {
            if (a.isHidden(this.painter.transform.zoom)) return !1;
            const g = Object.assign(Object.assign({}, u), { isRenderingToTexture: !0 }), _ = a.type, w = this.painter, C = this._renderableLayerIds[this._renderableLayerIds.length - 1] === a.id;
            if (zr[_] && (this._prevType && zr[this._prevType] || this._stacks.push([]), this._prevType = _, this._stacks[this._stacks.length - 1].push(a.id), !C)) return !0;
            if (zr[this._prevType] || zr[_] && C) {
              this._prevType = _;
              const R = this._stacks.length - 1, L = this._stacks[R] || [];
              for (const k of this._renderableTiles) {
                if (this.pool.isFull() && (Vh(this.painter, this.terrain, this._rttTiles, g), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(k), k.rtt[R]) {
                  const W = this.pool.getObjectForId(k.rtt[R].id);
                  if (W.stamp === k.rtt[R].stamp) {
                    this.pool.useObject(W);
                    continue;
                  }
                }
                const V = this.pool.getOrCreateFreeObject();
                this.pool.useObject(V), this.pool.stampObject(V), k.rtt[R] = { id: V.id, stamp: V.stamp }, w.context.bindFramebuffer.set(V.fbo.framebuffer), w.context.clear({ color: o.b5.transparent, stencil: 0 }), w.currentStencilSource = void 0;
                for (let W = 0; W < L.length; W++) {
                  const Z = w.style._layers[L[W]], ae = Z.source ? this._coordsAscending[Z.source][k.tileID.key] : [k.tileID];
                  w.context.viewport.set([0, 0, V.fbo.width, V.fbo.height]), w._renderTileClippingMasks(Z, ae, !0), w.renderLayer(w, w.style.sourceCaches[Z.source], Z, ae, g), Z.source && (k.rttCoords[Z.source] = this._coordsAscendingStr[Z.source][k.tileID.key]);
                }
              }
              return Vh(this.painter, this.terrain, this._rttTiles, g), this._rttTiles = [], this.pool.freeAllObjects(), zr[_];
            }
            return !1;
          }
        }
        const Bi = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use  + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, es = d, li = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: yr, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: o.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0 }, Ps = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
        class Pn {
          constructor(a, u) {
            let g = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
            this.mousedown = (w) => {
              this.startMove(w, E.mousePos(this.element, w)), E.addEventListener(window, "mousemove", this.mousemove), E.addEventListener(window, "mouseup", this.mouseup);
            }, this.mousemove = (w) => {
              this.move(w, E.mousePos(this.element, w));
            }, this.mouseup = (w) => {
              this._rotatePitchHanlder.dragEnd(w), this.offTemp();
            }, this.touchstart = (w) => {
              w.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = E.touchPos(this.element, w.targetTouches)[0], this.startMove(w, this._startPos), E.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), E.addEventListener(window, "touchend", this.touchend));
            }, this.touchmove = (w) => {
              w.targetTouches.length !== 1 ? this.reset() : (this._lastPos = E.touchPos(this.element, w.targetTouches)[0], this.move(w, this._lastPos));
            }, this.touchend = (w) => {
              w.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this.reset = () => {
              this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }, this._clickTolerance = 10, this.element = u;
            const _ = new Cu();
            this._rotatePitchHanlder = new vr({ clickTolerance: 3, move: (w, C) => {
              const R = u.getBoundingClientRect(), L = new o.P((R.bottom - R.top) / 2, (R.right - R.left) / 2);
              return { bearingDelta: o.c8(new o.P(w.x, C.y), C, L), pitchDelta: g ? -0.5 * (C.y - w.y) : void 0 };
            }, moveStateManager: _, enable: !0, assignEvents: () => {
            } }), this.map = a, E.addEventListener(u, "mousedown", this.mousedown), E.addEventListener(u, "touchstart", this.touchstart, { passive: !1 }), E.addEventListener(u, "touchcancel", this.reset);
          }
          startMove(a, u) {
            this._rotatePitchHanlder.dragStart(a, u), E.disableDrag();
          }
          move(a, u) {
            const g = this.map, { bearingDelta: _, pitchDelta: w } = this._rotatePitchHanlder.dragMove(a, u) || {};
            _ && g.setBearing(g.getBearing() + _), w && g.setPitch(g.getPitch() + w);
          }
          off() {
            const a = this.element;
            E.removeEventListener(a, "mousedown", this.mousedown), E.removeEventListener(a, "touchstart", this.touchstart, { passive: !1 }), E.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), E.removeEventListener(window, "touchend", this.touchend), E.removeEventListener(a, "touchcancel", this.reset), this.offTemp();
          }
          offTemp() {
            E.enableDrag(), E.removeEventListener(window, "mousemove", this.mousemove), E.removeEventListener(window, "mouseup", this.mouseup), E.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), E.removeEventListener(window, "touchend", this.touchend);
          }
        }
        let Li;
        function ts(v, a, u) {
          const g = new o.O(v.lng, v.lat);
          if (v = new o.O(v.lng, v.lat), a) {
            const _ = new o.O(v.lng - 360, v.lat), w = new o.O(v.lng + 360, v.lat), C = u.locationToScreenPoint(v).distSqr(a);
            u.locationToScreenPoint(_).distSqr(a) < C ? v = _ : u.locationToScreenPoint(w).distSqr(a) < C && (v = w);
          }
          for (; Math.abs(v.lng - u.center.lng) > 180; ) {
            const _ = u.locationToScreenPoint(v);
            if (_.x >= 0 && _.y >= 0 && _.x <= u.width && _.y <= u.height) break;
            v.lng > u.center.lng ? v.lng -= 360 : v.lng += 360;
          }
          return v.lng !== g.lng && u.isPointOnMapSurface(u.locationToScreenPoint(v)) ? v : g;
        }
        const Ei = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
        function zi(v, a, u) {
          const g = v.classList;
          for (const _ in Ei) g.remove(`maplibregl-${u}-anchor-${_}`);
          g.add(`maplibregl-${u}-anchor-${a}`);
        }
        class Gi extends o.E {
          constructor(a) {
            if (super(), this._onKeyPress = (u) => {
              const g = u.code, _ = u.charCode || u.keyCode;
              g !== "Space" && g !== "Enter" && _ !== 32 && _ !== 13 || this.togglePopup();
            }, this._onMapClick = (u) => {
              const g = u.originalEvent.target, _ = this._element;
              this._popup && (g === _ || _.contains(g)) && this.togglePopup();
            }, this._update = (u) => {
              var g;
              if (!this._map) return;
              const _ = this._map.loaded() && !this._map.isMoving();
              ((u == null ? void 0 : u.type) === "terrain" || (u == null ? void 0 : u.type) === "render" && !_) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? ts(this._lngLat, this._flatPos, this._map.transform) : (g = this._lngLat) === null || g === void 0 ? void 0 : g.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
              let w = "";
              this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? w = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (w = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
              let C = "";
              this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? C = "rotateX(0deg)" : this._pitchAlignment === "map" && (C = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || u && u.type !== "moveend" || (this._pos = this._pos.round()), E.setTransform(this._element, `${Ei[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${C} ${w}`), M.frameAsync(new AbortController()).then(() => {
                this._updateOpacity(u && u.type === "moveend");
              }).catch(() => {
              });
            }, this._onMove = (u) => {
              if (!this._isDragging) {
                const g = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = u.point.dist(this._pointerdownPos) >= g;
              }
              this._isDragging && (this._pos = u.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new o.k("dragstart"))), this.fire(new o.k("drag")));
            }, this._onUp = () => {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new o.k("dragend")), this._state = "inactive";
            }, this._addDragHandler = (u) => {
              this._element.contains(u.originalEvent.target) && (u.preventDefault(), this._positionDelta = u.point.sub(this._pos).add(this._offset), this._pointerdownPos = u.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, this._anchor = a && a.anchor || "center", this._color = a && a.color || "#3FB1CE", this._scale = a && a.scale || 1, this._draggable = a && a.draggable || !1, this._clickTolerance = a && a.clickTolerance || 0, this._subpixelPositioning = a && a.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = a && a.rotation || 0, this._rotationAlignment = a && a.rotationAlignment || "auto", this._pitchAlignment = a && a.pitchAlignment && a.pitchAlignment !== "auto" ? a.pitchAlignment : this._rotationAlignment, this.setOpacity(a == null ? void 0 : a.opacity, a == null ? void 0 : a.opacityWhenCovered), a && a.element) this._element = a.element, this._offset = o.P.convert(a && a.offset || [0, 0]);
            else {
              this._defaultMarker = !0, this._element = E.create("div");
              const u = E.createNS("http://www.w3.org/2000/svg", "svg"), g = 41, _ = 27;
              u.setAttributeNS(null, "display", "block"), u.setAttributeNS(null, "height", `${g}px`), u.setAttributeNS(null, "width", `${_}px`), u.setAttributeNS(null, "viewBox", `0 0 ${_} ${g}`);
              const w = E.createNS("http://www.w3.org/2000/svg", "g");
              w.setAttributeNS(null, "stroke", "none"), w.setAttributeNS(null, "stroke-width", "1"), w.setAttributeNS(null, "fill", "none"), w.setAttributeNS(null, "fill-rule", "evenodd");
              const C = E.createNS("http://www.w3.org/2000/svg", "g");
              C.setAttributeNS(null, "fill-rule", "nonzero");
              const R = E.createNS("http://www.w3.org/2000/svg", "g");
              R.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), R.setAttributeNS(null, "fill", "#000000");
              const L = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
              for (const Ie of L) {
                const Le = E.createNS("http://www.w3.org/2000/svg", "ellipse");
                Le.setAttributeNS(null, "opacity", "0.04"), Le.setAttributeNS(null, "cx", "10.5"), Le.setAttributeNS(null, "cy", "5.80029008"), Le.setAttributeNS(null, "rx", Ie.rx), Le.setAttributeNS(null, "ry", Ie.ry), R.appendChild(Le);
              }
              const k = E.createNS("http://www.w3.org/2000/svg", "g");
              k.setAttributeNS(null, "fill", this._color);
              const V = E.createNS("http://www.w3.org/2000/svg", "path");
              V.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), k.appendChild(V);
              const W = E.createNS("http://www.w3.org/2000/svg", "g");
              W.setAttributeNS(null, "opacity", "0.25"), W.setAttributeNS(null, "fill", "#000000");
              const Z = E.createNS("http://www.w3.org/2000/svg", "path");
              Z.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), W.appendChild(Z);
              const ae = E.createNS("http://www.w3.org/2000/svg", "g");
              ae.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), ae.setAttributeNS(null, "fill", "#FFFFFF");
              const ue = E.createNS("http://www.w3.org/2000/svg", "g");
              ue.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
              const Ce = E.createNS("http://www.w3.org/2000/svg", "circle");
              Ce.setAttributeNS(null, "fill", "#000000"), Ce.setAttributeNS(null, "opacity", "0.25"), Ce.setAttributeNS(null, "cx", "5.5"), Ce.setAttributeNS(null, "cy", "5.5"), Ce.setAttributeNS(null, "r", "5.4999962");
              const Se = E.createNS("http://www.w3.org/2000/svg", "circle");
              Se.setAttributeNS(null, "fill", "#FFFFFF"), Se.setAttributeNS(null, "cx", "5.5"), Se.setAttributeNS(null, "cy", "5.5"), Se.setAttributeNS(null, "r", "5.4999962"), ue.appendChild(Ce), ue.appendChild(Se), C.appendChild(R), C.appendChild(k), C.appendChild(W), C.appendChild(ae), C.appendChild(ue), u.appendChild(C), u.setAttributeNS(null, "height", g * this._scale + "px"), u.setAttributeNS(null, "width", _ * this._scale + "px"), this._element.appendChild(u), this._offset = o.P.convert(a && a.offset || [0, -14]);
            }
            if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (u) => {
              u.preventDefault();
            }), this._element.addEventListener("mousedown", (u) => {
              u.preventDefault();
            }), zi(this._element, this._anchor, "marker"), a && a.className) for (const u of a.className.split(" ")) this._element.classList.add(u);
            this._popup = null;
          }
          addTo(a) {
            return this.remove(), this._map = a, this._element.setAttribute("aria-label", a._getUIString("Marker.Title")), a.getCanvasContainer().appendChild(this._element), a.on("move", this._update), a.on("moveend", this._update), a.on("terrain", this._update), a.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
          }
          remove() {
            return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), E.remove(this._element), this._popup && this._popup.remove(), this;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(a) {
            return this._lngLat = o.O.convert(a), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
          }
          getElement() {
            return this._element;
          }
          setPopup(a) {
            if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), a) {
              if (!("offset" in a.options)) {
                const _ = Math.abs(13.5) / Math.SQRT2;
                a.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [_, -1 * (38.1 - 13.5 + _)], "bottom-right": [-_, -1 * (38.1 - 13.5 + _)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
              }
              this._popup = a, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
            }
            return this;
          }
          setSubpixelPositioning(a) {
            return this._subpixelPositioning = a, this;
          }
          getPopup() {
            return this._popup;
          }
          togglePopup() {
            const a = this._popup;
            return this._element.style.opacity === this._opacityWhenCovered ? this : a ? (a.isOpen() ? a.remove() : (a.setLngLat(this._lngLat), a.addTo(this._map)), this) : this;
          }
          _updateOpacity() {
            let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
            var u, g;
            if (!(!((u = this._map) === null || u === void 0) && u.terrain)) {
              const W = this._map.transform.isLocationOccluded(this._lngLat) ? this._opacityWhenCovered : this._opacity;
              return void (this._element.style.opacity !== W && (this._element.style.opacity = W));
            }
            if (a) this._opacityTimeout = null;
            else {
              if (this._opacityTimeout) return;
              this._opacityTimeout = setTimeout(() => {
                this._opacityTimeout = null;
              }, 100);
            }
            const _ = this._map, w = _.terrain.depthAtPoint(this._pos), C = _.terrain.getElevationForLngLatZoom(this._lngLat, _.transform.tileZoom);
            if (_.transform.lngLatToCameraDepth(this._lngLat, C) - w < 6e-3) return void (this._element.style.opacity = this._opacity);
            const R = -this._offset.y / _.transform.pixelsPerMeter, L = Math.sin(_.getPitch() * Math.PI / 180) * R, k = _.terrain.depthAtPoint(new o.P(this._pos.x, this._pos.y - this._offset.y)), V = _.transform.lngLatToCameraDepth(this._lngLat, C + L) - k > 6e-3;
            !((g = this._popup) === null || g === void 0) && g.isOpen() && V && this._popup.remove(), this._element.style.opacity = V ? this._opacityWhenCovered : this._opacity;
          }
          getOffset() {
            return this._offset;
          }
          setOffset(a) {
            return this._offset = o.P.convert(a), this._update(), this;
          }
          addClassName(a) {
            this._element.classList.add(a);
          }
          removeClassName(a) {
            this._element.classList.remove(a);
          }
          toggleClassName(a) {
            return this._element.classList.toggle(a);
          }
          setDraggable(a) {
            return this._draggable = !!a, this._map && (a ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
          }
          isDraggable() {
            return this._draggable;
          }
          setRotation(a) {
            return this._rotation = a || 0, this._update(), this;
          }
          getRotation() {
            return this._rotation;
          }
          setRotationAlignment(a) {
            return this._rotationAlignment = a || "auto", this._update(), this;
          }
          getRotationAlignment() {
            return this._rotationAlignment;
          }
          setPitchAlignment(a) {
            return this._pitchAlignment = a && a !== "auto" ? a : this._rotationAlignment, this._update(), this;
          }
          getPitchAlignment() {
            return this._pitchAlignment;
          }
          setOpacity(a, u) {
            return (this._opacity === void 0 || a === void 0 && u === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), a !== void 0 && (this._opacity = a), u !== void 0 && (this._opacityWhenCovered = u), this._map && this._updateOpacity(!0), this;
          }
        }
        const to = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
        let Vs = 0, ci = !1;
        const ea = { maxWidth: 100, unit: "metric" };
        function ya(v, a, u) {
          const g = u && u.maxWidth || 100, _ = v._container.clientHeight / 2, w = v._container.clientWidth / 2, C = v.unproject([w - g / 2, _]), R = v.unproject([w + g / 2, _]), L = Math.round(v.project(R).x - v.project(C).x), k = Math.min(g, L, v._container.clientWidth), V = C.distanceTo(R);
          if (u && u.unit === "imperial") {
            const W = 3.2808 * V;
            W > 5280 ? _o(a, k, W / 5280, v._getUIString("ScaleControl.Miles")) : _o(a, k, W, v._getUIString("ScaleControl.Feet"));
          } else u && u.unit === "nautical" ? _o(a, k, V / 1852, v._getUIString("ScaleControl.NauticalMiles")) : V >= 1e3 ? _o(a, k, V / 1e3, v._getUIString("ScaleControl.Kilometers")) : _o(a, k, V, v._getUIString("ScaleControl.Meters"));
        }
        function _o(v, a, u, g) {
          const _ = function(w) {
            const C = Math.pow(10, `${Math.floor(w)}`.length - 1);
            let R = w / C;
            return R = R >= 10 ? 10 : R >= 5 ? 5 : R >= 3 ? 3 : R >= 2 ? 2 : R >= 1 ? 1 : function(L) {
              const k = Math.pow(10, Math.ceil(-Math.log(L) / Math.LN10));
              return Math.round(L * k) / k;
            }(R), C * R;
          }(u);
          v.style.width = a * (_ / u) + "px", v.innerHTML = `${_}&nbsp;${g}`;
        }
        const ba = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, ui = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
        function ic(v) {
          if (v) {
            if (typeof v == "number") {
              const a = Math.round(Math.abs(v) / Math.SQRT2);
              return { center: new o.P(0, 0), top: new o.P(0, v), "top-left": new o.P(a, a), "top-right": new o.P(-a, a), bottom: new o.P(0, -v), "bottom-left": new o.P(a, -a), "bottom-right": new o.P(-a, -a), left: new o.P(v, 0), right: new o.P(-v, 0) };
            }
            if (v instanceof o.P || Array.isArray(v)) {
              const a = o.P.convert(v);
              return { center: a, top: a, "top-left": a, "top-right": a, bottom: a, "bottom-left": a, "bottom-right": a, left: a, right: a };
            }
            return { center: o.P.convert(v.center || [0, 0]), top: o.P.convert(v.top || [0, 0]), "top-left": o.P.convert(v["top-left"] || [0, 0]), "top-right": o.P.convert(v["top-right"] || [0, 0]), bottom: o.P.convert(v.bottom || [0, 0]), "bottom-left": o.P.convert(v["bottom-left"] || [0, 0]), "bottom-right": o.P.convert(v["bottom-right"] || [0, 0]), left: o.P.convert(v.left || [0, 0]), right: o.P.convert(v.right || [0, 0]) };
          }
          return ic(new o.P(0, 0));
        }
        const th = d;
        l.AJAXError = o.ch, l.Event = o.k, l.Evented = o.E, l.LngLat = o.O, l.MercatorCoordinate = o.Z, l.Point = o.P, l.addProtocol = o.ci, l.config = o.a, l.removeProtocol = o.cj, l.AttributionControl = Ur, l.BoxZoomHandler = Xc, l.CanvasSource = br, l.CooperativeGesturesHandler = tt, l.DoubleClickZoomHandler = et, l.DragPanHandler = st, l.DragRotateHandler = Wt, l.EdgeInsets = ai, l.FullscreenControl = class extends o.E {
          constructor() {
            let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            super(), this._onFullscreenChange = () => {
              var a;
              let u = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
              for (; !((a = u == null ? void 0 : u.shadowRoot) === null || a === void 0) && a.fullscreenElement; ) u = u.shadowRoot.fullscreenElement;
              u === this._container !== this._fullscreen && this._handleFullscreenChange();
            }, this._onClickFullscreen = () => {
              this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
            }, this._fullscreen = !1, v && v.container && (v.container instanceof HTMLElement ? this._container = v.container : o.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
          }
          onAdd(v) {
            return this._map = v, this._container || (this._container = this._map.getContainer()), this._controlContainer = E.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
          }
          onRemove() {
            E.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _setupUI() {
            const v = this._fullscreenButton = E.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
            E.create("span", "maplibregl-ctrl-icon", v).setAttribute("aria-hidden", "true"), v.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
          }
          _updateTitle() {
            const v = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", v), this._fullscreenButton.title = v;
          }
          _getTitle() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }
          _isFullscreen() {
            return this._fullscreen;
          }
          _handleFullscreenChange() {
            this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new o.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new o.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
          }
          _exitFullscreen() {
            window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
          }
          _requestFullscreen() {
            this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
          }
          _togglePseudoFullScreen() {
            this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
          }
        }, l.GeoJSONSource = rr, l.GeolocateControl = class extends o.E {
          constructor(v) {
            super(), this._onSuccess = (a) => {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(a)) return this._setErrorState(), this.fire(new o.k("outofmaxbounds", a)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = a, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(a), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(a), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new o.k("geolocate", a)), this._finish();
              }
            }, this._updateCamera = (a) => {
              const u = new o.O(a.coords.longitude, a.coords.latitude), g = a.coords.accuracy, _ = this._map.getBearing(), w = o.e({ bearing: _ }, this.options.fitBoundsOptions), C = Cr.fromLngLat(u, g);
              this._map.fitBounds(C, w, { geolocateSource: !0 });
            }, this._updateMarker = (a) => {
              if (a) {
                const u = new o.O(a.coords.longitude, a.coords.latitude);
                this._accuracyCircleMarker.setLngLat(u).addTo(this._map), this._userLocationDotMarker.setLngLat(u).addTo(this._map), this._accuracy = a.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, this._onZoom = () => {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, this._onError = (a) => {
              if (this._map) {
                if (this.options.trackUserLocation) if (a.code === 1) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                  const u = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.title = u, this._geolocateButton.setAttribute("aria-label", u), this._geolocationWatchID !== void 0 && this._clearWatch();
                } else {
                  if (a.code === 3 && ci) return;
                  this._setErrorState();
                }
                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new o.k("error", a)), this._finish();
              }
            }, this._finish = () => {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, this._setupUI = () => {
              this._map && (this._container.addEventListener("contextmenu", (a) => a.preventDefault()), this._geolocateButton = E.create("button", "maplibregl-ctrl-geolocate", this._container), E.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
            }, this._finishSetupUI = (a) => {
              if (this._map) {
                if (a === !1) {
                  o.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const u = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = !0, this._geolocateButton.title = u, this._geolocateButton.setAttribute("aria-label", u);
                } else {
                  const u = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.disabled = !1, this._geolocateButton.title = u, this._geolocateButton.setAttribute("aria-label", u);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = E.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Gi({ element: this._dotElement }), this._circleElement = E.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Gi({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (u) => {
                  u.geolocateSource || this._watchState !== "ACTIVE_LOCK" || u.originalEvent && u.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new o.k("trackuserlocationend")), this.fire(new o.k("userlocationlostfocus")));
                });
              }
            }, this.options = o.e({}, to, v);
          }
          onAdd(v) {
            return this._map = v, this._container = E.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
              return o._(this, arguments, void 0, function() {
                let a = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
                return function* () {
                  if (Li !== void 0 && !a) return Li;
                  if (window.navigator.permissions === void 0) return Li = !!window.navigator.geolocation, Li;
                  try {
                    Li = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                  } catch {
                    Li = !!window.navigator.geolocation;
                  }
                  return Li;
                }();
              });
            }().then((a) => this._finishSetupUI(a)), this._container;
          }
          onRemove() {
            this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), E.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Vs = 0, ci = !1;
          }
          _isOutOfMapMaxBounds(v) {
            const a = this._map.getMaxBounds(), u = v.coords;
            return a && (u.longitude < a.getWest() || u.longitude > a.getEast() || u.latitude < a.getSouth() || u.latitude > a.getNorth());
          }
          _setErrorState() {
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                break;
              case "ACTIVE_LOCK":
                this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "BACKGROUND":
                this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                break;
              case "ACTIVE_ERROR":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
          }
          _updateCircleRadius() {
            const v = this._map.getBounds(), a = v.getSouthEast(), u = v.getNorthEast(), g = a.distanceTo(u), _ = Math.ceil(this._accuracy / (g / this._map._container.clientHeight) * 2);
            this._circleElement.style.width = `${_}px`, this._circleElement.style.height = `${_}px`;
          }
          trigger() {
            if (!this._setup) return o.w("Geolocate control triggered before added to a map"), !1;
            if (this.options.trackUserLocation) {
              switch (this._watchState) {
                case "OFF":
                  this._watchState = "WAITING_ACTIVE", this.fire(new o.k("trackuserlocationstart"));
                  break;
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                case "BACKGROUND_ERROR":
                  Vs--, ci = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new o.k("trackuserlocationend"));
                  break;
                case "BACKGROUND":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new o.k("trackuserlocationstart")), this.fire(new o.k("userlocationfocus"));
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "ACTIVE_LOCK":
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "OFF":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
              else if (this._geolocationWatchID === void 0) {
                let v;
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Vs++, Vs > 1 ? (v = { maximumAge: 6e5, timeout: 0 }, ci = !0) : (v = this.options.positionOptions, ci = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, v);
              }
            } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
            return !0;
          }
          _clearWatch() {
            window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
          }
        }, l.GlobeControl = class {
          constructor() {
            this._toggleProjection = () => {
              var v;
              const a = (v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type;
              this._map.setProjection(a !== "mercator" && a ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
            }, this._updateGlobeIcon = () => {
              var v;
              this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((v = this._map.getProjection()) === null || v === void 0 ? void 0 : v.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
            };
          }
          onAdd(v) {
            return this._map = v, this._container = E.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = E.create("button", "maplibregl-ctrl-globe", this._container), E.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
          }
          onRemove() {
            E.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
          }
        }, l.Hash = ma, l.ImageSource = hr, l.KeyboardHandler = ge, l.LngLatBounds = Cr, l.LogoControl = xr, l.Map = class extends Vt {
          constructor(v) {
            var a, u;
            o.ce.mark(o.cf.create);
            const g = Object.assign(Object.assign(Object.assign({}, li), v), { canvasContextAttributes: Object.assign(Object.assign({}, li.canvasContextAttributes), v.canvasContextAttributes) });
            if (g.minZoom != null && g.maxZoom != null && g.minZoom > g.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
            if (g.minPitch != null && g.maxPitch != null && g.minPitch > g.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
            if (g.minPitch != null && g.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (g.maxPitch != null && g.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
            const _ = new qr(), w = new Ll();
            if (g.minZoom !== void 0 && _.setMinZoom(g.minZoom), g.maxZoom !== void 0 && _.setMaxZoom(g.maxZoom), g.minPitch !== void 0 && _.setMinPitch(g.minPitch), g.maxPitch !== void 0 && _.setMaxPitch(g.maxPitch), g.renderWorldCopies !== void 0 && _.setRenderWorldCopies(g.renderWorldCopies), super(_, w, { bearingSnap: g.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new rn(), this._controls = [], this._mapId = o.a2(), this._contextLost = (R) => {
              R.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new o.k("webglcontextlost", { originalEvent: R }));
            }, this._contextRestored = (R) => {
              this._setupPainter(), this.resize(), this._update(), this.fire(new o.k("webglcontextrestored", { originalEvent: R }));
            }, this._onMapScroll = (R) => {
              if (R.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
            }, this._onWindowOnline = () => {
              this._update();
            }, this._interactive = g.interactive, this._maxTileCacheSize = g.maxTileCacheSize, this._maxTileCacheZoomLevels = g.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, g.canvasContextAttributes), this._trackResize = g.trackResize === !0, this._bearingSnap = g.bearingSnap, this._centerClampedToGround = g.centerClampedToGround, this._refreshExpiredTiles = g.refreshExpiredTiles === !0, this._fadeDuration = g.fadeDuration, this._crossSourceCollisions = g.crossSourceCollisions === !0, this._collectResourceTiming = g.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Bi), g.locale), this._clickTolerance = g.clickTolerance, this._overridePixelRatio = g.pixelRatio, this._maxCanvasSize = g.maxCanvasSize, this.transformCameraUpdate = g.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = g.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = X.addThrottleControl(() => this.isMoving()), this._requestManager = new J(g.transformRequest), typeof g.container == "string") {
              if (this._container = document.getElementById(g.container), !this._container) throw new Error(`Container '${g.container}' not found.`);
            } else {
              if (!(g.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
              this._container = g.container;
            }
            if (g.maxBounds && this.setMaxBounds(g.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => {
              this.painter.terrainFacilitator.dirty = !0, this._update(!0);
            }), this.once("idle", () => {
              this._idleTriggered = !0;
            }), typeof window < "u") {
              addEventListener("online", this._onWindowOnline, !1);
              let R = !1;
              const L = _l((k) => {
                this._trackResize && !this._removed && (this.resize(k), this.redraw());
              }, 50);
              this._resizeObserver = new ResizeObserver((k) => {
                R ? L(k) : R = !0;
              }), this._resizeObserver.observe(this._container);
            }
            this.handlers = new dt(this, g), this._hash = g.hash && new ma(typeof g.hash == "string" && g.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: g.center, elevation: g.elevation, zoom: g.zoom, bearing: g.bearing, pitch: g.pitch, roll: g.roll }), g.bounds && (this.resize(), this.fitBounds(g.bounds, o.e({}, g.fitBoundsOptions, { duration: 0 }))));
            const C = typeof g.style == "string" || ((u = (a = g.style) === null || a === void 0 ? void 0 : a.projection) === null || u === void 0 ? void 0 : u.type) !== "globe";
            this.resize(null, C), this._localIdeographFontFamily = g.localIdeographFontFamily, this._validateStyle = g.validateStyle, g.style && this.setStyle(g.style, { localIdeographFontFamily: g.localIdeographFontFamily }), g.attributionControl && this.addControl(new Ur(typeof g.attributionControl == "boolean" ? void 0 : g.attributionControl)), g.maplibreLogo && this.addControl(new xr(), g.logoPosition), this.on("style.load", () => {
              if (C || this._resizeTransform(), this.transform.unmodified) {
                const R = o.N(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                this.jumpTo(R);
              }
            }), this.on("data", (R) => {
              this._update(R.dataType === "style"), this.fire(new o.k(`${R.dataType}data`, R));
            }), this.on("dataloading", (R) => {
              this.fire(new o.k(`${R.dataType}dataloading`, R));
            }), this.on("dataabort", (R) => {
              this.fire(new o.k("sourcedataabort", R));
            });
          }
          _getMapId() {
            return this._mapId;
          }
          addControl(v, a) {
            if (a === void 0 && (a = v.getDefaultPosition ? v.getDefaultPosition() : "top-right"), !v || !v.onAdd) return this.fire(new o.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
            const u = v.onAdd(this);
            this._controls.push(v);
            const g = this._controlPositions[a];
            return a.indexOf("bottom") !== -1 ? g.insertBefore(u, g.firstChild) : g.appendChild(u), this;
          }
          removeControl(v) {
            if (!v || !v.onRemove) return this.fire(new o.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
            const a = this._controls.indexOf(v);
            return a > -1 && this._controls.splice(a, 1), v.onRemove(this), this;
          }
          hasControl(v) {
            return this._controls.indexOf(v) > -1;
          }
          calculateCameraOptionsFromTo(v, a, u, g) {
            return g == null && this.terrain && (g = this.terrain.getElevationForLngLatZoom(u, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(v, a, u, g);
          }
          resize(v) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
            const [u, g] = this._containerDimensions(), _ = this._getClampedPixelRatio(u, g);
            if (this._resizeCanvas(u, g, _), this.painter.resize(u, g, _), this.painter.overLimit()) {
              const C = this.painter.context.gl;
              this._maxCanvasSize = [C.drawingBufferWidth, C.drawingBufferHeight];
              const R = this._getClampedPixelRatio(u, g);
              this._resizeCanvas(u, g, R), this.painter.resize(u, g, R);
            }
            this._resizeTransform(a);
            const w = !this._moving;
            return w && (this.stop(), this.fire(new o.k("movestart", v)).fire(new o.k("move", v))), this.fire(new o.k("resize", v)), w && this.fire(new o.k("moveend", v)), this;
          }
          _resizeTransform() {
            let v = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
            var a;
            const [u, g] = this._containerDimensions();
            this.transform.resize(u, g, v), (a = this._requestedCameraState) === null || a === void 0 || a.resize(u, g, v);
          }
          _getClampedPixelRatio(v, a) {
            const { 0: u, 1: g } = this._maxCanvasSize, _ = this.getPixelRatio(), w = v * _, C = a * _;
            return Math.min(w > u ? u / w : 1, C > g ? g / C : 1) * _;
          }
          getPixelRatio() {
            var v;
            return (v = this._overridePixelRatio) !== null && v !== void 0 ? v : devicePixelRatio;
          }
          setPixelRatio(v) {
            this._overridePixelRatio = v, this.resize();
          }
          getBounds() {
            return this.transform.getBounds();
          }
          getMaxBounds() {
            return this.transform.getMaxBounds();
          }
          setMaxBounds(v) {
            return this.transform.setMaxBounds(Cr.convert(v)), this._update();
          }
          setMinZoom(v) {
            if ((v = v ?? -2) >= -2 && v <= this.transform.maxZoom) return this.transform.setMinZoom(v), this._update(), this.getZoom() < v && this.setZoom(v), this;
            throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
          }
          getMinZoom() {
            return this.transform.minZoom;
          }
          setMaxZoom(v) {
            if ((v = v ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(v), this._update(), this.getZoom() > v && this.setZoom(v), this;
            throw new Error("maxZoom must be greater than the current minZoom");
          }
          getMaxZoom() {
            return this.transform.maxZoom;
          }
          setMinPitch(v) {
            if ((v = v ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
            if (v >= 0 && v <= this.transform.maxPitch) return this.transform.setMinPitch(v), this._update(), this.getPitch() < v && this.setPitch(v), this;
            throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
          }
          getMinPitch() {
            return this.transform.minPitch;
          }
          setMaxPitch(v) {
            if ((v = v ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
            if (v >= this.transform.minPitch) return this.transform.setMaxPitch(v), this._update(), this.getPitch() > v && this.setPitch(v), this;
            throw new Error("maxPitch must be greater than the current minPitch");
          }
          getMaxPitch() {
            return this.transform.maxPitch;
          }
          getRenderWorldCopies() {
            return this.transform.renderWorldCopies;
          }
          setRenderWorldCopies(v) {
            return this.transform.setRenderWorldCopies(v), this._update();
          }
          project(v) {
            return this.transform.locationToScreenPoint(o.O.convert(v), this.style && this.terrain);
          }
          unproject(v) {
            return this.transform.screenPointToLocation(o.P.convert(v), this.terrain);
          }
          isMoving() {
            var v;
            return this._moving || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isMoving());
          }
          isZooming() {
            var v;
            return this._zooming || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isZooming());
          }
          isRotating() {
            var v;
            return this._rotating || ((v = this.handlers) === null || v === void 0 ? void 0 : v.isRotating());
          }
          _createDelegatedListener(v, a, u) {
            if (v === "mouseenter" || v === "mouseover") {
              let g = !1;
              return { layers: a, listener: u, delegates: { mousemove: (w) => {
                const C = a.filter((L) => this.getLayer(L)), R = C.length !== 0 ? this.queryRenderedFeatures(w.point, { layers: C }) : [];
                R.length ? g || (g = !0, u.call(this, new _i(v, this, w.originalEvent, { features: R }))) : g = !1;
              }, mouseout: () => {
                g = !1;
              } } };
            }
            if (v === "mouseleave" || v === "mouseout") {
              let g = !1;
              return { layers: a, listener: u, delegates: { mousemove: (C) => {
                const R = a.filter((L) => this.getLayer(L));
                (R.length !== 0 ? this.queryRenderedFeatures(C.point, { layers: R }) : []).length ? g = !0 : g && (g = !1, u.call(this, new _i(v, this, C.originalEvent)));
              }, mouseout: (C) => {
                g && (g = !1, u.call(this, new _i(v, this, C.originalEvent)));
              } } };
            }
            {
              const g = (_) => {
                const w = a.filter((R) => this.getLayer(R)), C = w.length !== 0 ? this.queryRenderedFeatures(_.point, { layers: w }) : [];
                C.length && (_.features = C, u.call(this, _), delete _.features);
              };
              return { layers: a, listener: u, delegates: { [v]: g } };
            }
          }
          _saveDelegatedListener(v, a) {
            this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[v] = this._delegatedListeners[v] || [], this._delegatedListeners[v].push(a);
          }
          _removeDelegatedListener(v, a, u) {
            if (!this._delegatedListeners || !this._delegatedListeners[v]) return;
            const g = this._delegatedListeners[v];
            for (let _ = 0; _ < g.length; _++) {
              const w = g[_];
              if (w.listener === u && w.layers.length === a.length && w.layers.every((C) => a.includes(C))) {
                for (const C in w.delegates) this.off(C, w.delegates[C]);
                return void g.splice(_, 1);
              }
            }
          }
          on(v, a, u) {
            if (u === void 0) return super.on(v, a);
            const g = typeof a == "string" ? [a] : a, _ = this._createDelegatedListener(v, g, u);
            this._saveDelegatedListener(v, _);
            for (const w in _.delegates) this.on(w, _.delegates[w]);
            return { unsubscribe: () => {
              this._removeDelegatedListener(v, g, u);
            } };
          }
          once(v, a, u) {
            var g = this;
            if (u === void 0) return super.once(v, a);
            const _ = typeof a == "string" ? [a] : a, w = this._createDelegatedListener(v, _, u);
            for (const C in w.delegates) {
              const R = w.delegates[C];
              w.delegates[C] = function() {
                g._removeDelegatedListener(v, _, u), R(...arguments);
              };
            }
            this._saveDelegatedListener(v, w);
            for (const C in w.delegates) this.once(C, w.delegates[C]);
            return this;
          }
          off(v, a, u) {
            return u === void 0 ? super.off(v, a) : (this._removeDelegatedListener(v, typeof a == "string" ? [a] : a, u), this);
          }
          queryRenderedFeatures(v, a) {
            if (!this.style) return [];
            let u;
            const g = v instanceof o.P || Array.isArray(v), _ = g ? v : [[0, 0], [this.transform.width, this.transform.height]];
            if (a = a || (g ? {} : v) || {}, _ instanceof o.P || typeof _[0] == "number") u = [o.P.convert(_)];
            else {
              const w = o.P.convert(_[0]), C = o.P.convert(_[1]);
              u = [w, new o.P(C.x, w.y), C, new o.P(w.x, C.y), w];
            }
            return this.style.queryRenderedFeatures(u, a, this.transform);
          }
          querySourceFeatures(v, a) {
            return this.style.querySourceFeatures(v, a);
          }
          setStyle(v, a) {
            return (a = o.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, a)).diff !== !1 && a.localIdeographFontFamily === this._localIdeographFontFamily && this.style && v ? (this._diffStyle(v, a), this) : (this._localIdeographFontFamily = a.localIdeographFontFamily, this._updateStyle(v, a));
          }
          setTransformRequest(v) {
            return this._requestManager.setTransformRequest(v), this;
          }
          _getUIString(v) {
            const a = this._locale[v];
            if (a == null) throw new Error(`Missing UI string '${v}'`);
            return a;
          }
          _updateStyle(v, a) {
            var u, g;
            if (a.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(v, a));
            const _ = this.style && a.transformStyle ? this.style.serialize() : void 0;
            return this.style && (this.style.setEventedParent(null), this.style._remove(!v)), v ? (this.style = new ps(this, a || {}), this.style.setEventedParent(this, { style: this.style }), typeof v == "string" ? this.style.loadURL(v, a, _) : this.style.loadJSON(v, a, _), this) : ((g = (u = this.style) === null || u === void 0 ? void 0 : u.projection) === null || g === void 0 || g.destroy(), delete this.style, this);
          }
          _lazyInitEmptyStyle() {
            this.style || (this.style = new ps(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
          }
          _diffStyle(v, a) {
            if (typeof v == "string") {
              const u = this._requestManager.transformRequest(v, "Style");
              o.h(u, new AbortController()).then((g) => {
                this._updateDiff(g.data, a);
              }).catch((g) => {
                g && this.fire(new o.j(g));
              });
            } else typeof v == "object" && this._updateDiff(v, a);
          }
          _updateDiff(v, a) {
            try {
              this.style.setState(v, a) && this._update(!0);
            } catch (u) {
              o.w(`Unable to perform style diff: ${u.message || u.error || u}.  Rebuilding the style from scratch.`), this._updateStyle(v, a);
            }
          }
          getStyle() {
            if (this.style) return this.style.serialize();
          }
          isStyleLoaded() {
            return this.style ? this.style.loaded() : o.w("There is no style added to the map.");
          }
          addSource(v, a) {
            return this._lazyInitEmptyStyle(), this.style.addSource(v, a), this._update(!0);
          }
          isSourceLoaded(v) {
            const a = this.style && this.style.sourceCaches[v];
            if (a !== void 0) return a.loaded();
            this.fire(new o.j(new Error(`There is no source with ID '${v}'`)));
          }
          setTerrain(v) {
            if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), v) {
              const a = this.style.sourceCaches[v.source];
              if (!a) throw new Error(`cannot load terrain, because there exists no source with ID: ${v.source}`);
              this.terrain === null && a.reload();
              for (const u in this.style._layers) {
                const g = this.style._layers[u];
                g.type === "hillshade" && g.source === v.source && o.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
              }
              this.terrain = new wn(this.painter, a, v), this.painter.renderToTexture = new Br(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (u) => {
                u.dataType === "style" ? this.terrain.sourceCache.freeRtt() : u.dataType === "source" && u.tile && (u.sourceId !== v.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), this.terrain.sourceCache.freeRtt(u.tile.tileID));
              }, this.style.on("data", this._terrainDataCallback);
            } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
            return this.fire(new o.k("terrain", { terrain: v })), this;
          }
          getTerrain() {
            var v, a;
            return (a = (v = this.terrain) === null || v === void 0 ? void 0 : v.options) !== null && a !== void 0 ? a : null;
          }
          areTilesLoaded() {
            const v = this.style && this.style.sourceCaches;
            for (const a in v) {
              const u = v[a]._tiles;
              for (const g in u) {
                const _ = u[g];
                if (_.state !== "loaded" && _.state !== "errored") return !1;
              }
            }
            return !0;
          }
          removeSource(v) {
            return this.style.removeSource(v), this._update(!0);
          }
          getSource(v) {
            return this.style.getSource(v);
          }
          addImage(v, a) {
            let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            const { pixelRatio: g = 1, sdf: _ = !1, stretchX: w, stretchY: C, content: R, textFitWidth: L, textFitHeight: k } = u;
            if (this._lazyInitEmptyStyle(), !(a instanceof HTMLImageElement || o.b(a))) {
              if (a.width === void 0 || a.height === void 0) return this.fire(new o.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              {
                const { width: V, height: W, data: Z } = a, ae = a;
                return this.style.addImage(v, { data: new o.R({ width: V, height: W }, new Uint8Array(Z)), pixelRatio: g, stretchX: w, stretchY: C, content: R, textFitWidth: L, textFitHeight: k, sdf: _, version: 0, userImage: ae }), ae.onAdd && ae.onAdd(this, v), this;
              }
            }
            {
              const { width: V, height: W, data: Z } = M.getImageData(a);
              this.style.addImage(v, { data: new o.R({ width: V, height: W }, Z), pixelRatio: g, stretchX: w, stretchY: C, content: R, textFitWidth: L, textFitHeight: k, sdf: _, version: 0 });
            }
          }
          updateImage(v, a) {
            const u = this.style.getImage(v);
            if (!u) return this.fire(new o.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
            const g = a instanceof HTMLImageElement || o.b(a) ? M.getImageData(a) : a, { width: _, height: w, data: C } = g;
            if (_ === void 0 || w === void 0) return this.fire(new o.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            if (_ !== u.data.width || w !== u.data.height) return this.fire(new o.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
            const R = !(a instanceof HTMLImageElement || o.b(a));
            return u.data.replace(C, R), this.style.updateImage(v, u), this;
          }
          getImage(v) {
            return this.style.getImage(v);
          }
          hasImage(v) {
            return v ? !!this.style.getImage(v) : (this.fire(new o.j(new Error("Missing required image id"))), !1);
          }
          removeImage(v) {
            this.style.removeImage(v);
          }
          loadImage(v) {
            return X.getImage(this._requestManager.transformRequest(v, "Image"), new AbortController());
          }
          listImages() {
            return this.style.listImages();
          }
          addLayer(v, a) {
            return this._lazyInitEmptyStyle(), this.style.addLayer(v, a), this._update(!0);
          }
          moveLayer(v, a) {
            return this.style.moveLayer(v, a), this._update(!0);
          }
          removeLayer(v) {
            return this.style.removeLayer(v), this._update(!0);
          }
          getLayer(v) {
            return this.style.getLayer(v);
          }
          getLayersOrder() {
            return this.style.getLayersOrder();
          }
          setLayerZoomRange(v, a, u) {
            return this.style.setLayerZoomRange(v, a, u), this._update(!0);
          }
          setFilter(v, a) {
            let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return this.style.setFilter(v, a, u), this._update(!0);
          }
          getFilter(v) {
            return this.style.getFilter(v);
          }
          setPaintProperty(v, a, u) {
            let g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return this.style.setPaintProperty(v, a, u, g), this._update(!0);
          }
          getPaintProperty(v, a) {
            return this.style.getPaintProperty(v, a);
          }
          setLayoutProperty(v, a, u) {
            let g = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
            return this.style.setLayoutProperty(v, a, u, g), this._update(!0);
          }
          getLayoutProperty(v, a) {
            return this.style.getLayoutProperty(v, a);
          }
          setGlyphs(v) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this._lazyInitEmptyStyle(), this.style.setGlyphs(v, a), this._update(!0);
          }
          getGlyphs() {
            return this.style.getGlyphsUrl();
          }
          addSprite(v, a) {
            let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            return this._lazyInitEmptyStyle(), this.style.addSprite(v, a, u, (g) => {
              g || this._update(!0);
            }), this;
          }
          removeSprite(v) {
            return this._lazyInitEmptyStyle(), this.style.removeSprite(v), this._update(!0);
          }
          getSprite() {
            return this.style.getSprite();
          }
          setSprite(v) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this._lazyInitEmptyStyle(), this.style.setSprite(v, a, (u) => {
              u || this._update(!0);
            }), this;
          }
          setLight(v) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this._lazyInitEmptyStyle(), this.style.setLight(v, a), this._update(!0);
          }
          getLight() {
            return this.style.getLight();
          }
          setSky(v) {
            let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            return this._lazyInitEmptyStyle(), this.style.setSky(v, a), this._update(!0);
          }
          getSky() {
            return this.style.getSky();
          }
          setFeatureState(v, a) {
            return this.style.setFeatureState(v, a), this._update();
          }
          removeFeatureState(v, a) {
            return this.style.removeFeatureState(v, a), this._update();
          }
          getFeatureState(v) {
            return this.style.getFeatureState(v);
          }
          getContainer() {
            return this._container;
          }
          getCanvasContainer() {
            return this._canvasContainer;
          }
          getCanvas() {
            return this._canvas;
          }
          _containerDimensions() {
            let v = 0, a = 0;
            return this._container && (v = this._container.clientWidth || 400, a = this._container.clientHeight || 300), [v, a];
          }
          _setupContainer() {
            const v = this._container;
            v.classList.add("maplibregl-map");
            const a = this._canvasContainer = E.create("div", "maplibregl-canvas-container", v);
            this._interactive && a.classList.add("maplibregl-interactive"), this._canvas = E.create("canvas", "maplibregl-canvas", a), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
            const u = this._containerDimensions(), g = this._getClampedPixelRatio(u[0], u[1]);
            this._resizeCanvas(u[0], u[1], g);
            const _ = this._controlContainer = E.create("div", "maplibregl-control-container", v), w = this._controlPositions = {};
            ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((C) => {
              w[C] = E.create("div", `maplibregl-ctrl-${C} `, _);
            }), this._container.addEventListener("scroll", this._onMapScroll, !1);
          }
          _resizeCanvas(v, a, u) {
            this._canvas.width = Math.floor(u * v), this._canvas.height = Math.floor(u * a), this._canvas.style.width = `${v}px`, this._canvas.style.height = `${a}px`;
          }
          _setupPainter() {
            const v = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
            let a = null;
            this._canvas.addEventListener("webglcontextcreationerror", (g) => {
              a = { requestedAttributes: v }, g && (a.statusMessage = g.statusMessage, a.type = g.type);
            }, { once: !0 });
            let u = null;
            if (u = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, v) : this._canvas.getContext("webgl2", v) || this._canvas.getContext("webgl", v), !u) {
              const g = "Failed to initialize WebGL";
              throw a ? (a.message = g, new Error(JSON.stringify(a))) : new Error(g);
            }
            this.painter = new Df(u, this.transform), D.testSupport(u);
          }
          migrateProjection(v, a) {
            super.migrateProjection(v, a), this.painter.transform = v, this.fire(new o.k("projectiontransition", { newProjection: this.style.projection.name }));
          }
          loaded() {
            return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
          }
          _update(v) {
            return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || v, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
          }
          _requestRenderFrame(v) {
            return this._update(), this._renderTaskQueue.add(v);
          }
          _cancelRenderFrame(v) {
            this._renderTaskQueue.remove(v);
          }
          _render(v) {
            var a, u, g, _, w;
            const C = this._idleTriggered ? this._fadeDuration : 0, R = ((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState) > 0;
            if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(v), this._removed) return;
            let L = !1;
            if (this.style && this._styleDirty) {
              this._styleDirty = !1;
              const W = this.transform.zoom, Z = M.now();
              this.style.zoomHistory.update(W, Z);
              const ae = new o.B(W, { now: Z, fadeDuration: C, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), ue = ae.crossFadingFactor();
              ue === 1 && ue === this._crossFadingFactor || (L = !0, this._crossFadingFactor = ue), this.style.update(ae);
            }
            const k = ((u = this.style.projection) === null || u === void 0 ? void 0 : u.transitionState) > 0 !== R;
            (g = this.style.projection) === null || g === void 0 || g.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((_ = this.style.projection) === null || _ === void 0 ? void 0 : _.transitionState, (w = this.style.projection) === null || w === void 0 ? void 0 : w.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || k) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, C, this._crossSourceCollisions, k), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: C, showPadding: this.showPadding }), this.fire(new o.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, o.ce.mark(o.cf.load), this.fire(new o.k("load"))), this.style && (this.style.hasTransitions() || L) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
            const V = this._sourcesDirty || this._styleDirty || this._placementDirty;
            return V || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new o.k("idle")), !this._loaded || this._fullyLoaded || V || (this._fullyLoaded = !0, o.ce.mark(o.cf.fullLoad)), this;
          }
          redraw() {
            return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
          }
          remove() {
            var v;
            this._hash && this._hash.remove();
            for (const u of this._controls) u.onRemove(this);
            this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), X.removeThrottleControl(this._imageQueueHandle), (v = this._resizeObserver) === null || v === void 0 || v.disconnect();
            const a = this.painter.context.gl.getExtension("WEBGL_lose_context");
            a != null && a.loseContext && a.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), E.remove(this._canvasContainer), E.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), o.ce.clearMetrics(), this._removed = !0, this.fire(new o.k("remove"));
          }
          triggerRepaint() {
            this.style && !this._frameRequest && (this._frameRequest = new AbortController(), M.frame(this._frameRequest, (v) => {
              o.ce.frame(v), this._frameRequest = null;
              try {
                this._render(v);
              } catch (a) {
                if (!o.cg(a) && !function(u) {
                  return u.message === pl;
                }(a)) throw a;
              }
            }, () => {
            }));
          }
          get showTileBoundaries() {
            return !!this._showTileBoundaries;
          }
          set showTileBoundaries(v) {
            this._showTileBoundaries !== v && (this._showTileBoundaries = v, this._update());
          }
          get showPadding() {
            return !!this._showPadding;
          }
          set showPadding(v) {
            this._showPadding !== v && (this._showPadding = v, this._update());
          }
          get showCollisionBoxes() {
            return !!this._showCollisionBoxes;
          }
          set showCollisionBoxes(v) {
            this._showCollisionBoxes !== v && (this._showCollisionBoxes = v, v ? this.style._generateCollisionBoxes() : this._update());
          }
          get showOverdrawInspector() {
            return !!this._showOverdrawInspector;
          }
          set showOverdrawInspector(v) {
            this._showOverdrawInspector !== v && (this._showOverdrawInspector = v, this._update());
          }
          get repaint() {
            return !!this._repaint;
          }
          set repaint(v) {
            this._repaint !== v && (this._repaint = v, this.triggerRepaint());
          }
          get vertices() {
            return !!this._vertices;
          }
          set vertices(v) {
            this._vertices = v, this._update();
          }
          get version() {
            return es;
          }
          getCameraTargetElevation() {
            return this.transform.elevation;
          }
          getProjection() {
            return this.style.getProjection();
          }
          setProjection(v) {
            return this._lazyInitEmptyStyle(), this.style.setProjection(v), this._update(!0);
          }
        }, l.MapMouseEvent = _i, l.MapTouchEvent = rc, l.MapWheelEvent = Po, l.Marker = Gi, l.NavigationControl = class {
          constructor(v) {
            this._updateZoomButtons = () => {
              const a = this._map.getZoom(), u = a === this._map.getMaxZoom(), g = a === this._map.getMinZoom();
              this._zoomInButton.disabled = u, this._zoomOutButton.disabled = g, this._zoomInButton.setAttribute("aria-disabled", u.toString()), this._zoomOutButton.setAttribute("aria-disabled", g.toString());
            }, this._rotateCompassArrow = () => {
              this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
            }, this._setButtonTitle = (a, u) => {
              const g = this._map._getUIString(`NavigationControl.${u}`);
              a.title = g, a.setAttribute("aria-label", g);
            }, this.options = o.e({}, Ps, v), this._container = E.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (a) => a.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (a) => this._map.zoomIn({}, { originalEvent: a })), E.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (a) => this._map.zoomOut({}, { originalEvent: a })), E.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (a) => {
              this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: a }) : this._map.resetNorth({}, { originalEvent: a });
            }), this._compassIcon = E.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
          }
          onAdd(v) {
            return this._map = v, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Pn(this._map, this._compass, this.options.visualizePitch)), this._container;
          }
          onRemove() {
            E.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }
          _createButton(v, a) {
            const u = E.create("button", v, this._container);
            return u.type = "button", u.addEventListener("click", a), u;
          }
        }, l.Popup = class extends o.E {
          constructor(v) {
            super(), this.remove = () => (this._content && E.remove(this._content), this._container && (E.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new o.k("close"))), this), this._onMouseUp = (a) => {
              this._update(a.point);
            }, this._onMouseMove = (a) => {
              this._update(a.point);
            }, this._onDrag = (a) => {
              this._update(a.point);
            }, this._update = (a) => {
              var u;
              if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
              if (!this._container) {
                if (this._container = E.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = E.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const R of this.options.className.split(" ")) this._container.classList.add(R);
                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
              }
              if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? ts(this._lngLat, this._flatPos, this._map.transform) : (u = this._lngLat) === null || u === void 0 ? void 0 : u.wrap(), this._trackPointer && !a) return;
              const g = this._flatPos = this._pos = this._trackPointer && a ? a : this._map.project(this._lngLat);
              this._map.terrain && (this._flatPos = this._trackPointer && a ? a : this._map.transform.locationToScreenPoint(this._lngLat));
              let _ = this.options.anchor;
              const w = ic(this.options.offset);
              if (!_) {
                const R = this._container.offsetWidth, L = this._container.offsetHeight;
                let k;
                k = g.y + w.bottom.y < L ? ["top"] : g.y > this._map.transform.height - L ? ["bottom"] : [], g.x < R / 2 ? k.push("left") : g.x > this._map.transform.width - R / 2 && k.push("right"), _ = k.length === 0 ? "bottom" : k.join("-");
              }
              let C = g.add(w[_]);
              this.options.subpixelPositioning || (C = C.round()), E.setTransform(this._container, `${Ei[_]} translate(${C.x}px,${C.y}px)`), zi(this._container, _, "popup");
            }, this._onClose = () => {
              this.remove();
            }, this.options = o.e(Object.create(ba), v);
          }
          addTo(v) {
            return this._map && this.remove(), this._map = v, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new o.k("open")), this;
          }
          isOpen() {
            return !!this._map;
          }
          getLngLat() {
            return this._lngLat;
          }
          setLngLat(v) {
            return this._lngLat = o.O.convert(v), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
          }
          trackPointer() {
            return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
          }
          getElement() {
            return this._container;
          }
          setText(v) {
            return this.setDOMContent(document.createTextNode(v));
          }
          setHTML(v) {
            const a = document.createDocumentFragment(), u = document.createElement("body");
            let g;
            for (u.innerHTML = v; g = u.firstChild, g; ) a.appendChild(g);
            return this.setDOMContent(a);
          }
          getMaxWidth() {
            var v;
            return (v = this._container) === null || v === void 0 ? void 0 : v.style.maxWidth;
          }
          setMaxWidth(v) {
            return this.options.maxWidth = v, this._update(), this;
          }
          setDOMContent(v) {
            if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
            else this._content = E.create("div", "maplibregl-popup-content", this._container);
            return this._content.appendChild(v), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
          }
          addClassName(v) {
            return this._container && this._container.classList.add(v), this;
          }
          removeClassName(v) {
            return this._container && this._container.classList.remove(v), this;
          }
          setOffset(v) {
            return this.options.offset = v, this._update(), this;
          }
          toggleClassName(v) {
            if (this._container) return this._container.classList.toggle(v);
          }
          setSubpixelPositioning(v) {
            this.options.subpixelPositioning = v;
          }
          _createCloseButton() {
            this.options.closeButton && (this._closeButton = E.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
          }
          _focusFirstElement() {
            if (!this.options.focusAfterOpen || !this._container) return;
            const v = this._container.querySelector(ui);
            v && v.focus();
          }
        }, l.RasterDEMTileSource = Ir, l.RasterTileSource = jr, l.ScaleControl = class {
          constructor(v) {
            this._onMove = () => {
              ya(this._map, this._container, this.options);
            }, this.setUnit = (a) => {
              this.options.unit = a, ya(this._map, this._container, this.options);
            }, this.options = Object.assign(Object.assign({}, ea), v);
          }
          getDefaultPosition() {
            return "bottom-left";
          }
          onAdd(v) {
            return this._map = v, this._container = E.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", v.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }
          onRemove() {
            E.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }
        }, l.ScrollZoomHandler = Pe, l.Style = ps, l.TerrainControl = class {
          constructor(v) {
            this._toggleTerrain = () => {
              this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
            }, this._updateTerrainIcon = () => {
              this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
            }, this.options = v;
          }
          onAdd(v) {
            return this._map = v, this._container = E.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = E.create("button", "maplibregl-ctrl-terrain", this._container), E.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
          }
          onRemove() {
            E.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
          }
        }, l.TwoFingersTouchPitchHandler = re, l.TwoFingersTouchRotateHandler = F, l.TwoFingersTouchZoomHandler = S, l.TwoFingersTouchZoomRotateHandler = Ot, l.VectorTileSource = Ve, l.VideoSource = wr, l.addSourceType = (v, a) => o._(void 0, void 0, void 0, function* () {
          if ($r(v)) throw new Error(`A source type called "${v}" already exists.`);
          ((u, g) => {
            Rr[u] = g;
          })(v, a);
        }), l.clearPrewarmedResources = function() {
          const v = Ue;
          v && (v.isPreloaded() && v.numActive() === 1 ? (v.release(mr), Ue = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
        }, l.createTileMesh = Zo, l.getMaxParallelImageRequests = function() {
          return o.a.MAX_PARALLEL_IMAGE_REQUESTS;
        }, l.getRTLTextPluginStatus = function() {
          return yn().getRTLTextPluginStatus();
        }, l.getVersion = function() {
          return th;
        }, l.getWorkerCount = function() {
          return ce.workerCount;
        }, l.getWorkerUrl = function() {
          return o.a.WORKER_URL;
        }, l.importScriptInWorkers = function(v) {
          return St().broadcast("IS", v);
        }, l.prewarm = function() {
          it().acquire(mr);
        }, l.setMaxParallelImageRequests = function(v) {
          o.a.MAX_PARALLEL_IMAGE_REQUESTS = v;
        }, l.setRTLTextPlugin = function(v, a) {
          return yn().setRTLTextPlugin(v, a);
        }, l.setWorkerCount = function(v) {
          ce.workerCount = v;
        }, l.setWorkerUrl = function(v) {
          o.a.WORKER_URL = v;
        };
      });
      var s = t;
      return s;
    });
  }(Gm)), Gm.exports;
}
var oE = MR();
const io = /* @__PURE__ */ Dv(oE), cf = new Uint8Array([102, 103, 98, 3, 102, 103, 98, 0]), Nu = 4, Cp = 4, Ip = 4, Tg = 4, mh = new Int32Array(2), qw = new Float32Array(mh.buffer), Gw = new Float64Array(mh.buffer), nm = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var u1;
(function(r) {
  r[r.UTF8_BYTES = 1] = "UTF8_BYTES", r[r.UTF16_STRING = 2] = "UTF16_STRING";
})(u1 || (u1 = {}));
class Fu {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(e) {
    this.bytes_ = e, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(e) {
    return new Fu(new Uint8Array(e));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(e) {
    this.position_ = e;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(e) {
    return this.readUint8(e) << 24 >> 24;
  }
  readUint8(e) {
    return this.bytes_[e];
  }
  readInt16(e) {
    return this.readUint16(e) << 16 >> 16;
  }
  readUint16(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8;
  }
  readInt32(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8 | this.bytes_[e + 2] << 16 | this.bytes_[e + 3] << 24;
  }
  readUint32(e) {
    return this.readInt32(e) >>> 0;
  }
  readInt64(e) {
    return BigInt.asIntN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readUint64(e) {
    return BigInt.asUintN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readFloat32(e) {
    return mh[0] = this.readInt32(e), qw[0];
  }
  readFloat64(e) {
    return mh[nm ? 0 : 1] = this.readInt32(e), mh[nm ? 1 : 0] = this.readInt32(e + 4), Gw[0];
  }
  writeInt8(e, t) {
    this.bytes_[e] = t;
  }
  writeUint8(e, t) {
    this.bytes_[e] = t;
  }
  writeInt16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeUint16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeInt32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeUint32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeInt64(e, t) {
    this.writeInt32(e, Number(BigInt.asIntN(32, t))), this.writeInt32(e + 4, Number(BigInt.asIntN(32, t >> BigInt(32))));
  }
  writeUint64(e, t) {
    this.writeUint32(e, Number(BigInt.asUintN(32, t))), this.writeUint32(e + 4, Number(BigInt.asUintN(32, t >> BigInt(32))));
  }
  writeFloat32(e, t) {
    qw[0] = t, this.writeInt32(e, mh[0]);
  }
  writeFloat64(e, t) {
    Gw[0] = t, this.writeInt32(e, mh[nm ? 0 : 1]), this.writeInt32(e + 4, mh[nm ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + Cp + Ip)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let e = "";
    for (let t = 0; t < Ip; t++)
      e += String.fromCharCode(this.readInt8(this.position_ + Cp + t));
    return e;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(e, t) {
    const n = e - this.readInt32(e);
    return t < this.readInt16(n) ? this.readInt16(n + t) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(e, t) {
    return e.bb_pos = t + this.readInt32(t), e.bb = this, e;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(e, t) {
    e += this.readInt32(e);
    const n = this.readInt32(e);
    e += Cp;
    const i = this.bytes_.subarray(e, e + n);
    return t === u1.UTF8_BYTES ? i : this.text_decoder_.decode(i);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(e, t) {
    return typeof e == "string" ? this.__string(t) : this.__union(e, t);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(e) {
    return e + this.readInt32(e);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(e) {
    return e + this.readInt32(e) + Cp;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(e) {
    return this.readInt32(e + this.readInt32(e));
  }
  __has_identifier(e) {
    if (e.length != Ip)
      throw new Error("FlatBuffers: file identifier must be length " + Ip);
    for (let t = 0; t < Ip; t++)
      if (e.charCodeAt(t) != this.readInt8(this.position() + Cp + t))
        return !1;
    return !0;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(e, t) {
    const n = [];
    for (let i = 0; i < t; ++i) {
      const s = e(i);
      s !== null && n.push(s);
    }
    return n;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(e, t) {
    const n = [];
    for (let i = 0; i < t; ++i) {
      const s = e(i);
      s !== null && n.push(s.unpack());
    }
    return n;
  }
}
var Zn, vo = ((Zn = {})[Zn.Byte = 0] = "Byte", Zn[Zn.UByte = 1] = "UByte", Zn[Zn.Bool = 2] = "Bool", Zn[Zn.Short = 3] = "Short", Zn[Zn.UShort = 4] = "UShort", Zn[Zn.Int = 5] = "Int", Zn[Zn.UInt = 6] = "UInt", Zn[Zn.Long = 7] = "Long", Zn[Zn.ULong = 8] = "ULong", Zn[Zn.Float = 9] = "Float", Zn[Zn.Double = 10] = "Double", Zn[Zn.String = 11] = "String", Zn[Zn.Json = 12] = "Json", Zn[Zn.DateTime = 13] = "DateTime", Zn[Zn.Binary = 14] = "Binary", Zn);
class oo {
  constructor() {
    H(this, "bb", null);
    H(this, "bb_pos", 0);
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsColumn(e, t) {
    return (t || new oo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsColumn(e, t) {
    return e.setPosition(e.position() + Tg), (t || new oo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  type() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readUint8(this.bb_pos + e) : vo.Byte;
  }
  title(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  width() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  precision() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  scale() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  nullable() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return !e || !!this.bb.readInt8(this.bb_pos + e);
  }
  unique() {
    let e = this.bb.__offset(this.bb_pos, 20);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  primaryKey() {
    let e = this.bb.__offset(this.bb_pos, 22);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  metadata(e) {
    let t = this.bb.__offset(this.bb_pos, 24);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startColumn(e) {
    e.startObject(11);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addType(e, t) {
    e.addFieldInt8(1, t, vo.Byte);
  }
  static addTitle(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWidth(e, t) {
    e.addFieldInt32(4, t, -1);
  }
  static addPrecision(e, t) {
    e.addFieldInt32(5, t, -1);
  }
  static addScale(e, t) {
    e.addFieldInt32(6, t, -1);
  }
  static addNullable(e, t) {
    e.addFieldInt8(7, +t, 1);
  }
  static addUnique(e, t) {
    e.addFieldInt8(8, +t, 0);
  }
  static addPrimaryKey(e, t) {
    e.addFieldInt8(9, +t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static endColumn(e) {
    let t = e.endObject();
    return e.requiredField(t, 4), t;
  }
  static createColumn(e, t, n, i, s, l, o, d, m, b, T, M) {
    return oo.startColumn(e), oo.addName(e, t), oo.addType(e, n), oo.addTitle(e, i), oo.addDescription(e, s), oo.addWidth(e, l), oo.addPrecision(e, o), oo.addScale(e, d), oo.addNullable(e, m), oo.addUnique(e, b), oo.addPrimaryKey(e, T), oo.addMetadata(e, M), oo.endColumn(e);
  }
}
var En, zo = ((En = {})[En.Unknown = 0] = "Unknown", En[En.Point = 1] = "Point", En[En.LineString = 2] = "LineString", En[En.Polygon = 3] = "Polygon", En[En.MultiPoint = 4] = "MultiPoint", En[En.MultiLineString = 5] = "MultiLineString", En[En.MultiPolygon = 6] = "MultiPolygon", En[En.GeometryCollection = 7] = "GeometryCollection", En[En.CircularString = 8] = "CircularString", En[En.CompoundCurve = 9] = "CompoundCurve", En[En.CurvePolygon = 10] = "CurvePolygon", En[En.MultiCurve = 11] = "MultiCurve", En[En.MultiSurface = 12] = "MultiSurface", En[En.Curve = 13] = "Curve", En[En.Surface = 14] = "Surface", En[En.PolyhedralSurface = 15] = "PolyhedralSurface", En[En.TIN = 16] = "TIN", En[En.Triangle = 17] = "Triangle", En);
let PR = class xa {
  constructor() {
    H(this, "bb", null);
    H(this, "bb_pos", 0);
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsGeometry(e, t) {
    return (t || new xa()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsGeometry(e, t) {
    return e.setPosition(e.position() + Tg), (t || new xa()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  ends(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t) + 4 * e) : 0;
  }
  endsLength() {
    let e = this.bb.__offset(this.bb_pos, 4);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  endsArray() {
    let e = this.bb.__offset(this.bb_pos, 4);
    return e ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  xy(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  xyLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  xyArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  z(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  zLength() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  zArray() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  m(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  mLength() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  mArray() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  t(e) {
    let t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  tLength() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  tArray() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  tm(e) {
    let t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t) + 8 * e) : BigInt(0);
  }
  tmLength() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  type() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readUint8(this.bb_pos + e) : zo.Unknown;
  }
  parts(e, t) {
    let n = this.bb.__offset(this.bb_pos, 18);
    return n ? (t || new xa()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * e), this.bb) : null;
  }
  partsLength() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startGeometry(e) {
    e.startObject(8);
  }
  static addEnds(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static createEndsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addInt32(t[n]);
    return e.endVector();
  }
  static startEndsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addXy(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createXyVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startXyVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addZ(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createZVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startZVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addM(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static createMVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startMVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addT(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static createTVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startTVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addTm(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static createTmVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addInt64(t[n]);
    return e.endVector();
  }
  static startTmVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addType(e, t) {
    e.addFieldInt8(6, t, zo.Unknown);
  }
  static addParts(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createPartsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);
    return e.endVector();
  }
  static startPartsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endGeometry(e) {
    return e.endObject();
  }
  static createGeometry(e, t, n, i, s, l, o, d, m) {
    return xa.startGeometry(e), xa.addEnds(e, t), xa.addXy(e, n), xa.addZ(e, i), xa.addM(e, s), xa.addT(e, l), xa.addTm(e, o), xa.addType(e, d), xa.addParts(e, m), xa.endGeometry(e);
  }
};
class _c {
  constructor() {
    H(this, "bb", null);
    H(this, "bb_pos", 0);
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsFeature(e, t) {
    return (t || new _c()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsFeature(e, t) {
    return e.setPosition(e.position() + Tg), (t || new _c()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  geometry(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? (e || new PR()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  properties(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t) + e) : 0;
  }
  propertiesLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  propertiesArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  columns(e, t) {
    let n = this.bb.__offset(this.bb_pos, 8);
    return n ? (t || new oo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * e), this.bb) : null;
  }
  columnsLength() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startFeature(e) {
    e.startObject(3);
  }
  static addGeometry(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addProperties(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createPropertiesVector(e, t) {
    e.startVector(1, t.length, 1);
    for (let n = t.length - 1; n >= 0; n--) e.addInt8(t[n]);
    return e.endVector();
  }
  static startPropertiesVector(e, t) {
    e.startVector(1, t, 1);
  }
  static addColumns(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endFeature(e) {
    return e.endObject();
  }
  static finishFeatureBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedFeatureBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
  static createFeature(e, t, n, i) {
    return _c.startFeature(e), _c.addGeometry(e, t), _c.addProperties(e, n), _c.addColumns(e, i), _c.endFeature(e);
  }
}
function P0(r, e) {
  let t = [];
  for (let n = 0; n < r.length; n += 2) {
    let i = [r[n], r[n + 1]];
    e && i.push(e[n >> 1]), t.push(i);
  }
  return t;
}
new TextEncoder();
let $w = new TextDecoder();
function RR(r, e) {
  let t = {};
  if (!e || e.length === 0) return t;
  let n = r.propertiesArray();
  if (!n) return t;
  let i = new DataView(n.buffer, n.byteOffset), s = r.propertiesLength(), l = 0;
  for (; l < s; ) {
    let o = i.getUint16(l, !0);
    l += 2;
    let d = e[o], m = d.name;
    switch (d.type) {
      case vo.Bool:
        t[m] = !!i.getUint8(l), l += 1;
        break;
      case vo.Byte:
        t[m] = i.getInt8(l), l += 1;
        break;
      case vo.UByte:
        t[m] = i.getUint8(l), l += 1;
        break;
      case vo.Short:
        t[m] = i.getInt16(l, !0), l += 2;
        break;
      case vo.UShort:
        t[m] = i.getUint16(l, !0), l += 2;
        break;
      case vo.Int:
        t[m] = i.getInt32(l, !0), l += 4;
        break;
      case vo.UInt:
        t[m] = i.getUint32(l, !0), l += 4;
        break;
      case vo.Long:
        t[m] = Number(i.getBigInt64(l, !0)), l += 8;
        break;
      case vo.ULong:
        t[m] = Number(i.getBigUint64(l, !0)), l += 8;
        break;
      case vo.Float:
        t[m] = i.getFloat32(l, !0), l += 4;
        break;
      case vo.Double:
        t[m] = i.getFloat64(l, !0), l += 8;
        break;
      case vo.DateTime:
      case vo.String: {
        let b = i.getUint32(l, !0);
        l += 4, t[m] = $w.decode(n.subarray(l, l + b)), l += b;
        break;
      }
      case vo.Json: {
        let b = i.getUint32(l, !0);
        l += 4;
        let T = $w.decode(n.subarray(l, l + b));
        t[m] = JSON.parse(T), l += b;
        break;
      }
      case vo.Binary: {
        let b = i.getUint32(l, !0);
        l += 4, t[m] = n.subarray(l, l + b), l += b;
        break;
      }
      default:
        throw Error(`Unknown type ${d.type}`);
    }
  }
  return t;
}
const kv = new Uint8Array(0);
function BR() {
  return this._source.cancel();
}
function LR(r, e) {
  if (!r.length) return e;
  if (!e.length) return r;
  var t = new Uint8Array(r.length + e.length);
  return t.set(r), t.set(e, r.length), t;
}
function OR() {
  var r = this, e = r._array.subarray(r._index);
  return r._source.read().then(function(t) {
    return r._array = kv, r._index = 0, t.done ? e.length > 0 ? {
      done: !1,
      value: e
    } : {
      done: !0,
      value: void 0
    } : {
      done: !1,
      value: LR(e, t.value)
    };
  });
}
function NR(r) {
  if ((r |= 0) < 0) throw new Error("invalid length");
  var e = this, t = this._array.length - this._index;
  if (this._index + r <= this._array.length)
    return Promise.resolve(this._array.subarray(this._index, this._index += r));
  var n = new Uint8Array(r);
  return n.set(this._array.subarray(this._index)), function i() {
    return e._source.read().then(function(s) {
      return s.done ? (e._array = kv, e._index = 0, t > 0 ? n.subarray(0, t) : null) : t + s.value.length >= r ? (e._array = s.value, e._index = r - t, n.set(s.value.subarray(0, r - t), t), n) : (n.set(s.value, t), t += s.value.length, i());
    });
  }();
}
function DR(r) {
  return typeof r.slice == "function" ? r : new my(typeof r.read == "function" ? r : r.getReader());
}
function my(r) {
  this._source = r, this._array = kv, this._index = 0;
}
my.prototype.read = OR;
my.prototype.slice = NR;
my.prototype.cancel = BR;
class wl {
  constructor() {
    H(this, "bb", null);
    H(this, "bb_pos", 0);
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsCrs(e, t) {
    return (t || new wl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsCrs(e, t) {
    return e.setPosition(e.position() + Tg), (t || new wl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  org(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  code() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readInt32(this.bb_pos + e) : 0;
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  wkt(e) {
    let t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  codeString(e) {
    let t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startCrs(e) {
    e.startObject(6);
  }
  static addOrg(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addCode(e, t) {
    e.addFieldInt32(1, t, 0);
  }
  static addName(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWkt(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static addCodeString(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static endCrs(e) {
    return e.endObject();
  }
  static createCrs(e, t, n, i, s, l, o) {
    return wl.startCrs(e), wl.addOrg(e, t), wl.addCode(e, n), wl.addName(e, i), wl.addDescription(e, s), wl.addWkt(e, l), wl.addCodeString(e, o), wl.endCrs(e);
  }
}
class h_ {
  constructor() {
    H(this, "bb", null);
    H(this, "bb_pos", 0);
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsHeader(e, t) {
    return (t || new h_()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsHeader(e, t) {
    return e.setPosition(e.position() + Tg), (t || new h_()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    let t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  envelope(e) {
    let t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + 8 * e) : 0;
  }
  envelopeLength() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  envelopeArray() {
    let e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  geometryType() {
    let e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.readUint8(this.bb_pos + e) : zo.Unknown;
  }
  hasZ() {
    let e = this.bb.__offset(this.bb_pos, 10);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasM() {
    let e = this.bb.__offset(this.bb_pos, 12);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasT() {
    let e = this.bb.__offset(this.bb_pos, 14);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  hasTm() {
    let e = this.bb.__offset(this.bb_pos, 16);
    return !!e && !!this.bb.readInt8(this.bb_pos + e);
  }
  columns(e, t) {
    let n = this.bb.__offset(this.bb_pos, 18);
    return n ? (t || new oo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + n) + 4 * e), this.bb) : null;
  }
  columnsLength() {
    let e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  featuresCount() {
    let e = this.bb.__offset(this.bb_pos, 20);
    return e ? this.bb.readUint64(this.bb_pos + e) : BigInt("0");
  }
  indexNodeSize() {
    let e = this.bb.__offset(this.bb_pos, 22);
    return e ? this.bb.readUint16(this.bb_pos + e) : 16;
  }
  crs(e) {
    let t = this.bb.__offset(this.bb_pos, 24);
    return t ? (e || new wl()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  title(e) {
    let t = this.bb.__offset(this.bb_pos, 26);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    let t = this.bb.__offset(this.bb_pos, 28);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  metadata(e) {
    let t = this.bb.__offset(this.bb_pos, 30);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startHeader(e) {
    e.startObject(14);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addEnvelope(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createEnvelopeVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let n = t.length - 1; n >= 0; n--) e.addFloat64(t[n]);
    return e.endVector();
  }
  static startEnvelopeVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addGeometryType(e, t) {
    e.addFieldInt8(2, t, zo.Unknown);
  }
  static addHasZ(e, t) {
    e.addFieldInt8(3, +t, 0);
  }
  static addHasM(e, t) {
    e.addFieldInt8(4, +t, 0);
  }
  static addHasT(e, t) {
    e.addFieldInt8(5, +t, 0);
  }
  static addHasTm(e, t) {
    e.addFieldInt8(6, +t, 0);
  }
  static addColumns(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let n = t.length - 1; n >= 0; n--) e.addOffset(t[n]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addFeaturesCount(e, t) {
    e.addFieldInt64(8, t, BigInt("0"));
  }
  static addIndexNodeSize(e, t) {
    e.addFieldInt16(9, t, 16);
  }
  static addCrs(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static addTitle(e, t) {
    e.addFieldOffset(11, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(12, t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(13, t, 0);
  }
  static endHeader(e) {
    return e.endObject();
  }
  static finishHeaderBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedHeaderBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
}
function Fv(r) {
  let e = h_.getRootAsHeader(r), t = e.featuresCount(), n = e.indexNodeSize(), i = [];
  for (let o = 0; o < e.columnsLength(); o++) {
    let d = e.columns(o);
    if (!d) throw Error("Column unexpectedly missing");
    if (!d.name()) throw Error("Column name unexpectedly missing");
    i.push({
      name: d.name(),
      type: d.type(),
      title: d.title(),
      description: d.description(),
      width: d.width(),
      precision: d.precision(),
      scale: d.scale(),
      nullable: d.nullable(),
      unique: d.unique(),
      primary_key: d.primaryKey()
    });
  }
  let s = e.crs(), l = s ? {
    org: s.org(),
    code: s.code(),
    name: s.name(),
    description: s.description(),
    wkt: s.wkt(),
    code_string: s.codeString()
  } : null;
  return {
    geometryType: e.geometryType(),
    columns: i,
    envelope: null,
    featuresCount: Number(t),
    indexNodeSize: n,
    crs: l,
    title: e.title(),
    description: e.description(),
    metadata: e.metadata()
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var h1 = function(r, e) {
  return h1 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) n.hasOwnProperty(i) && (t[i] = n[i]);
  }, h1(r, e);
};
function kR(r, e) {
  h1(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function Dd(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(l) {
      l(s);
    });
  }
  return new (t || (t = Promise))(function(s, l) {
    function o(b) {
      try {
        m(n.next(b));
      } catch (T) {
        l(T);
      }
    }
    function d(b) {
      try {
        m(n.throw(b));
      } catch (T) {
        l(T);
      }
    }
    function m(b) {
      b.done ? s(b.value) : i(b.value).then(o, d);
    }
    m((n = n.apply(r, [])).next());
  });
}
function Mh(r, e) {
  var t = {
    label: 0,
    sent: function() {
      if (s[0] & 1) throw s[1];
      return s[1];
    },
    trys: [],
    ops: []
  }, n, i, s, l;
  return l = {
    next: o(0),
    throw: o(1),
    return: o(2)
  }, typeof Symbol == "function" && (l[Symbol.iterator] = function() {
    return this;
  }), l;
  function o(m) {
    return function(b) {
      return d([m, b]);
    };
  }
  function d(m) {
    if (n) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (n = 1, i && (s = m[0] & 2 ? i.return : m[0] ? i.throw || ((s = i.return) && s.call(i), 0) : i.next) && !(s = s.call(i, m[1])).done) return s;
      switch (i = 0, s && (m = [m[0] & 2, s.value]), m[0]) {
        case 0:
        case 1:
          s = m;
          break;
        case 4:
          return t.label++, {
            value: m[1],
            done: !1
          };
        case 5:
          t.label++, i = m[1], m = [0];
          continue;
        case 7:
          m = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (s = t.trys, !(s = s.length > 0 && s[s.length - 1]) && (m[0] === 6 || m[0] === 2)) {
            t = 0;
            continue;
          }
          if (m[0] === 3 && (!s || m[1] > s[0] && m[1] < s[3])) {
            t.label = m[1];
            break;
          }
          if (m[0] === 6 && t.label < s[1]) {
            t.label = s[1], s = m;
            break;
          }
          if (s && t.label < s[2]) {
            t.label = s[2], t.ops.push(m);
            break;
          }
          s[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      m = e.call(r, t);
    } catch (b) {
      m = [6, b], i = 0;
    } finally {
      n = s = 0;
    }
    if (m[0] & 5) throw m[1];
    return {
      value: m[0] ? m[1] : void 0,
      done: !0
    };
  }
}
function Xd(r) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && r[e], n = 0;
  if (t) return t.call(r);
  if (r && typeof r.length == "number") return {
    next: function() {
      return r && n >= r.length && (r = void 0), {
        value: r && r[n++],
        done: !r
      };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function hg(r) {
  return this instanceof hg ? (this.v = r, this) : new hg(r);
}
function FR(r, e, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var n = t.apply(r, e || []), i, s = [];
  return i = {}, l("next"), l("throw"), l("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function l(M) {
    n[M] && (i[M] = function(E) {
      return new Promise(function(D, U) {
        s.push([M, E, D, U]) > 1 || o(M, E);
      });
    });
  }
  function o(M, E) {
    try {
      d(n[M](E));
    } catch (D) {
      T(s[0][3], D);
    }
  }
  function d(M) {
    M.value instanceof hg ? Promise.resolve(M.value.v).then(m, b) : T(s[0][2], M);
  }
  function m(M) {
    o("next", M);
  }
  function b(M) {
    o("throw", M);
  }
  function T(M, E) {
    M(E), s.shift(), s.length && o(s[0][0], s[0][1]);
  }
}
var aE = (
  /** @class */
  function(r) {
    kR(e, r);
    function e(t) {
      var n = r.call(this, t) || this;
      return Object.defineProperty(n, "name", {
        value: "RepeaterOverflowError",
        enumerable: !1
      }), typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf(n, n.constructor.prototype) : n.__proto__ = n.constructor.prototype, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(n, n.constructor), n;
    }
    return e;
  }(Error)
);
(function() {
  function r(e) {
    if (e < 0)
      throw new RangeError("Capacity may not be less than 0");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(r.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(r.prototype, "full", {
    get: function() {
      return this._q.length >= this._c;
    },
    enumerable: !1,
    configurable: !0
  }), r.prototype.add = function(e) {
    if (this.full)
      throw new Error("Buffer full");
    this._q.push(e);
  }, r.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, r;
})();
(function() {
  function r(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(r.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(r.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), r.prototype.add = function(e) {
    for (; this._q.length >= this._c; )
      this._q.shift();
    this._q.push(e);
  }, r.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, r;
})();
(function() {
  function r(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(r.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(r.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), r.prototype.add = function(e) {
    this._q.length < this._c && this._q.push(e);
  }, r.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, r;
})();
function f1(r) {
  r != null && typeof r.then == "function" && r.then(p_, p_);
}
var R0 = 0, Hw = 1, Tf = 2, f_ = 3, d1 = 4, d_ = 1024, p_ = function() {
};
function Sd(r) {
  var e = r.err, t = Promise.resolve(r.execution).then(function(n) {
    if (e != null)
      throw e;
    return n;
  });
  return r.err = void 0, r.execution = t.then(function() {
  }, function() {
  }), r.pending === void 0 ? t : r.pending.then(function() {
    return t;
  });
}
function sf(r, e) {
  var t = r.state >= f_;
  return Promise.resolve(e).then(function(n) {
    return !t && r.state >= d1 ? Sd(r).then(function(i) {
      return {
        value: i,
        done: !0
      };
    }) : {
      value: n,
      done: t
    };
  });
}
function Uv(r, e) {
  var t, n;
  if (!(r.state >= Tf))
    if (r.state = Tf, r.onnext(), r.onstop(), r.err == null && (r.err = e), r.pushes.length === 0 && (typeof r.buffer > "u" || r.buffer.empty))
      Jp(r);
    else
      try {
        for (var i = Xd(r.pushes), s = i.next(); !s.done; s = i.next()) {
          var l = s.value;
          l.resolve();
        }
      } catch (o) {
        t = {
          error: o
        };
      } finally {
        try {
          s && !s.done && (n = i.return) && n.call(i);
        } finally {
          if (t) throw t.error;
        }
      }
}
function Jp(r) {
  var e, t;
  if (!(r.state >= f_)) {
    r.state < Tf && Uv(r), r.state = f_, r.buffer = void 0;
    try {
      for (var n = Xd(r.nexts), i = n.next(); !i.done; i = n.next()) {
        var s = i.value, l = r.pending === void 0 ? Sd(r) : r.pending.then(function() {
          return Sd(r);
        });
        s.resolve(sf(r, l));
      }
    } catch (o) {
      e = {
        error: o
      };
    } finally {
      try {
        i && !i.done && (t = n.return) && t.call(n);
      } finally {
        if (e) throw e.error;
      }
    }
    r.pushes = [], r.nexts = [];
  }
}
function Ww(r) {
  r.state >= d1 || (r.state < f_ && Jp(r), r.state = d1);
}
function UR(r, e) {
  if (f1(e), r.pushes.length >= d_)
    throw new aE("No more than " + d_ + " pending calls to push are allowed on a single repeater.");
  if (r.state >= Tf)
    return Promise.resolve(void 0);
  var t = r.pending === void 0 ? Promise.resolve(e) : r.pending.then(function() {
    return e;
  });
  t = t.catch(function(d) {
    r.state < Tf && (r.err = d), Ww(r);
  });
  var n;
  if (r.nexts.length) {
    var i = r.nexts.shift();
    i.resolve(sf(r, t)), r.nexts.length ? n = Promise.resolve(r.nexts[0].value) : typeof r.buffer < "u" && !r.buffer.full ? n = Promise.resolve(void 0) : n = new Promise(function(d) {
      return r.onnext = d;
    });
  } else typeof r.buffer < "u" && !r.buffer.full ? (r.buffer.add(t), n = Promise.resolve(void 0)) : n = new Promise(function(d) {
    return r.pushes.push({
      resolve: d,
      value: t
    });
  });
  var s = !0, l = {}, o = n.catch(function(d) {
    if (s)
      throw d;
  });
  return l.then = function(d, m) {
    return s = !1, Promise.prototype.then.call(n, d, m);
  }, l.catch = function(d) {
    return s = !1, Promise.prototype.catch.call(n, d);
  }, l.finally = n.finally.bind(n), r.pending = t.then(function() {
    return o;
  }).catch(function(d) {
    r.err = d, Ww(r);
  }), l;
}
function zR(r) {
  var e = Uv.bind(null, r), t = new Promise(function(n) {
    return r.onstop = n;
  });
  return e.then = t.then.bind(t), e.catch = t.catch.bind(t), e.finally = t.finally.bind(t), e;
}
function jR(r) {
  if (!(r.state >= Hw)) {
    r.state = Hw;
    var e = UR.bind(null, r), t = zR(r);
    r.execution = new Promise(function(n) {
      return n(r.executor(e, t));
    }), r.execution.catch(function() {
      return Uv(r);
    });
  }
}
var im = /* @__PURE__ */ new WeakMap(), Sg = (
  /** @class */
  function() {
    function r(e, t) {
      im.set(this, {
        executor: e,
        buffer: t,
        err: void 0,
        state: R0,
        pushes: [],
        nexts: [],
        pending: void 0,
        execution: void 0,
        onnext: p_,
        onstop: p_
      });
    }
    return r.prototype.next = function(e) {
      f1(e);
      var t = im.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      if (t.nexts.length >= d_)
        throw new aE("No more than " + d_ + " pending calls to next are allowed on a single repeater.");
      if (t.state <= R0 && jR(t), t.onnext(e), typeof t.buffer < "u" && !t.buffer.empty) {
        var n = sf(t, t.buffer.remove());
        if (t.pushes.length) {
          var i = t.pushes.shift();
          t.buffer.add(i.value), t.onnext = i.resolve;
        }
        return n;
      } else if (t.pushes.length) {
        var s = t.pushes.shift();
        return t.onnext = s.resolve, sf(t, s.value);
      } else if (t.state >= Tf)
        return Jp(t), sf(t, Sd(t));
      return new Promise(function(l) {
        return t.nexts.push({
          resolve: l,
          value: e
        });
      });
    }, r.prototype.return = function(e) {
      f1(e);
      var t = im.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return Jp(t), t.execution = Promise.resolve(t.execution).then(function() {
        return e;
      }), sf(t, Sd(t));
    }, r.prototype.throw = function(e) {
      var t = im.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return t.state <= R0 || t.state >= Tf || typeof t.buffer < "u" && !t.buffer.empty ? (Jp(t), t.err == null && (t.err = e), sf(t, Sd(t))) : this.next(Promise.reject(e));
    }, r.prototype[Symbol.asyncIterator] = function() {
      return this;
    }, r.race = VR, r.merge = qR, r.zip = GR, r.latest = $R, r;
  }()
);
function _y(r, e) {
  var t, n, i = [], s = function(m) {
    m != null && typeof m[Symbol.asyncIterator] == "function" ? i.push(m[Symbol.asyncIterator]()) : m != null && typeof m[Symbol.iterator] == "function" ? i.push(m[Symbol.iterator]()) : i.push(function() {
      return FR(this, arguments, function() {
        return Mh(this, function(M) {
          switch (M.label) {
            case 0:
              return e.yieldValues ? [4, hg(m)] : [3, 3];
            case 1:
              return [4, M.sent()];
            case 2:
              M.sent(), M.label = 3;
            case 3:
              return e.returnValues ? [4, hg(m)] : [3, 5];
            case 4:
              return [2, M.sent()];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }());
  };
  try {
    for (var l = Xd(r), o = l.next(); !o.done; o = l.next()) {
      var d = o.value;
      s(d);
    }
  } catch (m) {
    t = {
      error: m
    };
  } finally {
    try {
      o && !o.done && (n = l.return) && n.call(l);
    } finally {
      if (t) throw t.error;
    }
  }
  return i;
}
function VR(r) {
  var e = this, t = _y(r, {
    returnValues: !0
  });
  return new Sg(function(n, i) {
    return Dd(e, void 0, void 0, function() {
      var s, l, o, d, m, b;
      return Mh(this, function(T) {
        switch (T.label) {
          case 0:
            if (!t.length)
              return i(), [
                2
                /*return*/
              ];
            l = !1, i.then(function() {
              s(), l = !0;
            }), T.label = 1;
          case 1:
            T.trys.push([1, , 5, 7]), d = void 0, m = 0, b = function() {
              var M, E, D, U, q, G;
              return Mh(this, function(Y) {
                switch (Y.label) {
                  case 0:
                    M = m;
                    try {
                      for (E = (q = void 0, Xd(t)), D = E.next(); !D.done; D = E.next())
                        U = D.value, Promise.resolve(U.next()).then(function(he) {
                          he.done ? (i(), o === void 0 && (o = he)) : m === M && (m++, s(he));
                        }, function(he) {
                          return i(he);
                        });
                    } catch (he) {
                      q = {
                        error: he
                      };
                    } finally {
                      try {
                        D && !D.done && (G = E.return) && G.call(E);
                      } finally {
                        if (q) throw q.error;
                      }
                    }
                    return [4, new Promise(function(he) {
                      return s = he;
                    })];
                  case 1:
                    return d = Y.sent(), d === void 0 ? [3, 3] : [4, n(d.value)];
                  case 2:
                    Y.sent(), Y.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            }, T.label = 2;
          case 2:
            return l ? [3, 4] : [5, b()];
          case 3:
            return T.sent(), [3, 2];
          case 4:
            return [2, o && o.value];
          case 5:
            return i(), [4, Promise.race(t.map(function(M) {
              return M.return && M.return();
            }))];
          case 6:
            return T.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function qR(r) {
  var e = this, t = _y(r, {
    yieldValues: !0
  });
  return new Sg(function(n, i) {
    return Dd(e, void 0, void 0, function() {
      var s, l, o, d = this;
      return Mh(this, function(m) {
        switch (m.label) {
          case 0:
            if (!t.length)
              return i(), [
                2
                /*return*/
              ];
            s = [], l = !1, i.then(function() {
              var b, T;
              l = !0;
              try {
                for (var M = Xd(s), E = M.next(); !E.done; E = M.next()) {
                  var D = E.value;
                  D();
                }
              } catch (U) {
                b = {
                  error: U
                };
              } finally {
                try {
                  E && !E.done && (T = M.return) && T.call(M);
                } finally {
                  if (b) throw b.error;
                }
              }
            }), m.label = 1;
          case 1:
            return m.trys.push([1, , 3, 4]), [4, Promise.all(t.map(function(b, T) {
              return Dd(d, void 0, void 0, function() {
                var M, E;
                return Mh(this, function(D) {
                  switch (D.label) {
                    case 0:
                      D.trys.push([0, , 6, 9]), D.label = 1;
                    case 1:
                      return l ? [3, 5] : (Promise.resolve(b.next()).then(function(U) {
                        return s[T](U);
                      }, function(U) {
                        return i(U);
                      }), [4, new Promise(function(U) {
                        s[T] = U;
                      })]);
                    case 2:
                      return M = D.sent(), M === void 0 ? [3, 4] : M.done ? (o = M, [
                        2
                        /*return*/
                      ]) : [4, n(M.value)];
                    case 3:
                      D.sent(), D.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      return E = b.return, E ? [4, b.return()] : [3, 8];
                    case 7:
                      E = D.sent(), D.label = 8;
                    case 8:
                      return [
                        7
                        /*endfinally*/
                      ];
                    case 9:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 2:
            return m.sent(), [2, o && o.value];
          case 3:
            return i(), [
              7
              /*endfinally*/
            ];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function GR(r) {
  var e = this, t = _y(r, {
    returnValues: !0
  });
  return new Sg(function(n, i) {
    return Dd(e, void 0, void 0, function() {
      var s, l, o, d;
      return Mh(this, function(m) {
        switch (m.label) {
          case 0:
            if (!t.length)
              return i(), [2, []];
            l = !1, i.then(function() {
              s(), l = !0;
            }), m.label = 1;
          case 1:
            m.trys.push([1, , 6, 8]), m.label = 2;
          case 2:
            return l ? [3, 5] : (Promise.all(t.map(function(b) {
              return b.next();
            })).then(function(b) {
              return s(b);
            }, function(b) {
              return i(b);
            }), [4, new Promise(function(b) {
              return s = b;
            })]);
          case 3:
            return o = m.sent(), o === void 0 ? [
              2
              /*return*/
            ] : (d = o.map(function(b) {
              return b.value;
            }), o.some(function(b) {
              return b.done;
            }) ? [2, d] : [4, n(d)]);
          case 4:
            return m.sent(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return i(), [4, Promise.all(t.map(function(b) {
              return b.return && b.return();
            }))];
          case 7:
            return m.sent(), [
              7
              /*endfinally*/
            ];
          case 8:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function $R(r) {
  var e = this, t = _y(r, {
    yieldValues: !0,
    returnValues: !0
  });
  return new Sg(function(n, i) {
    return Dd(e, void 0, void 0, function() {
      var s, l, o, d, m, b = this;
      return Mh(this, function(T) {
        switch (T.label) {
          case 0:
            if (!t.length)
              return i(), [2, []];
            l = [], o = !1, i.then(function() {
              var M, E;
              s();
              try {
                for (var D = Xd(l), U = D.next(); !U.done; U = D.next()) {
                  var q = U.value;
                  q();
                }
              } catch (G) {
                M = {
                  error: G
                };
              } finally {
                try {
                  U && !U.done && (E = D.return) && E.call(D);
                } finally {
                  if (M) throw M.error;
                }
              }
              o = !0;
            }), T.label = 1;
          case 1:
            return T.trys.push([1, , 5, 7]), Promise.all(t.map(function(M) {
              return M.next();
            })).then(function(M) {
              return s(M);
            }, function(M) {
              return i(M);
            }), [4, new Promise(function(M) {
              return s = M;
            })];
          case 2:
            return d = T.sent(), d === void 0 ? [
              2
              /*return*/
            ] : (m = d.map(function(M) {
              return M.value;
            }), d.every(function(M) {
              return M.done;
            }) ? [2, m] : [4, n(m.slice())]);
          case 3:
            return T.sent(), [4, Promise.all(t.map(function(M, E) {
              return Dd(b, void 0, void 0, function() {
                var D;
                return Mh(this, function(U) {
                  switch (U.label) {
                    case 0:
                      if (d[E].done)
                        return [2, d[E].value];
                      U.label = 1;
                    case 1:
                      return o ? [3, 4] : (Promise.resolve(M.next()).then(function(q) {
                        return l[E](q);
                      }, function(q) {
                        return i(q);
                      }), [4, new Promise(function(q) {
                        return l[E] = q;
                      })]);
                    case 2:
                      return D = U.sent(), D === void 0 ? [2, d[E].value] : D.done ? [2, D.value] : (m[E] = D.value, [4, n(m.slice())]);
                    case 3:
                      return U.sent(), [3, 1];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 4:
            return [2, T.sent()];
          case 5:
            return i(), [4, Promise.all(t.map(function(M) {
              return M.return && M.return();
            }))];
          case 6:
            return T.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
var gf;
let lE = (gf = class {
  constructor() {
    H(this, "_extraRequestThreshold", 262144);
  }
  extraRequestThreshold() {
    return this._extraRequestThreshold;
  }
  setExtraRequestThreshold(e) {
    if (e < 0) throw Error("extraRequestThreshold cannot be negative");
    this._extraRequestThreshold = e;
  }
}, H(gf, "global", new gf()), gf);
const HR = 40, WR = 16;
function zv(r, e) {
  e = Math.min(Math.max(+e, 2), 65535);
  let t = r, n = t;
  do
    n += t = Math.ceil(t / e);
  while (t !== 1);
  return 40 * n;
}
function XR(r, e) {
  if (e < 2) throw Error("Node size must be at least 2");
  if (r === 0) throw Error("Number of items must be greater than 0");
  let t = r, n = t, i = [t];
  do
    n += t = Math.ceil(t / e), i.push(t);
  while (t !== 1);
  let s = [];
  for (let o of (t = n, i)) s.push(t - o), t -= o;
  let l = [];
  for (let o = 0; o < i.length; o++) l.push([s[o], s[o] + i[o]]);
  return l;
}
async function* ZR(r, e, t, n) {
  class i {
    constructor(E, D) {
      H(this, "_level");
      H(this, "nodes");
      this._level = D, this.nodes = E;
    }
    level() {
      return this._level;
    }
    startNodeIdx() {
      return this.nodes[0];
    }
    endNodeIdx() {
      return this.nodes[1];
    }
    extendEndNodeIdx(E) {
      this.nodes[1] = E;
    }
    toString() {
      return `[NodeRange level: ${this._level}, nodes: ${this.nodes[0]}-${this.nodes[1]}]`;
    }
  }
  let {
    minX: s,
    minY: l,
    maxX: o,
    maxY: d
  } = t, m = XR(r, e), b = m[0][0], T = [new i([0, 1], m.length - 1)];
  for (; T.length !== 0; ) {
    let M = T.shift(), E = M.startNodeIdx(), D = E >= b, U = (() => {
      let [, Y] = m[M.level()], he = Math.min(M.endNodeIdx() + e, Y);
      return D && he < Y ? he + 1 : he;
    })(), q = U - E, G = new DataView(await n(40 * E, 40 * q));
    for (let Y = E; Y < U; Y++) {
      let he = Y - E, X = 40 * he;
      if (o < G.getFloat64(X + 0, !0) || d < G.getFloat64(X + 8, !0) || s > G.getFloat64(X + 16, !0) || l > G.getFloat64(X + 24, !0)) continue;
      let J = G.getBigUint64(X + 32, !0);
      if (D) {
        let Re = (() => {
          if (Y < r - 1) {
            let me = (he + 1) * 40;
            return G.getBigUint64(me + 32, !0) - J;
          }
          return null;
        })(), Ne = Y - b;
        yield [Number(J), Ne, Number(Re)];
        continue;
      }
      let ie = lE.global.extraRequestThreshold() / 40, ye = T[T.length - 1];
      if (ye !== void 0 && ye.level() === M.level() - 1 && J < ye.endNodeIdx() + ie) {
        ye.extendEndNodeIdx(Number(J));
        continue;
      }
      let oe = (() => {
        let Re = M.level() - 1;
        return new i([Number(J), Number(J) + 1], Re);
      })();
      ye !== void 0 && (ye.level(), oe.level()), T.push(oe);
    }
  }
}
class jv {
  constructor(e, t, n, i, s) {
    H(this, "headerClient");
    H(this, "header");
    H(this, "headerLength");
    H(this, "indexLength");
    H(this, "nocache");
    this.headerClient = e, this.header = t, this.headerLength = n, this.indexLength = i, this.nocache = s;
  }
  static async open(e, t) {
    let n, i = new Xw(e, t), s = 2024 + (() => {
      let m, b = 0;
      for (m = 0; m < 3; m++) b += WR ** m * HR;
      return b;
    })();
    if (!new Uint8Array(await i.getRange(0, 8, s, "header")).subarray(0, 3).every((m, b) => cf[b] === m)) throw Error("Not a FlatGeobuf file");
    if ((n = new DataView(await i.getRange(8, 4, s, "header")).getUint32(0, !0)) > 10485760 || n < 8) throw Error("Invalid header size");
    let l = await i.getRange(12, n, s, "header"), o = Fv(new Fu(new Uint8Array(l))), d = zv(o.featuresCount, o.indexNodeSize);
    return new jv(i, o, n, d, t);
  }
  async *selectBbox(e) {
    let t = this.lengthBeforeTree(), n = this.headerClient, i = async (d, m) => n.getRange(t + d, m, 0, "index"), s = [], l = [];
    for await (let d of ZR(this.header.featuresCount, this.header.indexNodeSize, e, i)) {
      let [m, b] = d, [, , T] = d;
      if (T || (T = 4), l.length === 0) {
        l.push([m, T, b]);
        continue;
      }
      let M = l[l.length - 1];
      m - (M[0] + M[1]) > lE.global.extraRequestThreshold() && (s.push(l), l = []), l.push([m, T, b]);
    }
    this.headerClient.logUsage("header+index"), l.length > 0 && s.push(l);
    let o = s.flatMap((d) => this.readFeatureBatch(d, this.nocache));
    yield* Sg.merge(o);
  }
  lengthBeforeTree() {
    return cf.length + Nu + this.headerLength;
  }
  lengthBeforeFeatures() {
    return this.lengthBeforeTree() + this.indexLength;
  }
  buildFeatureClient(e) {
    return new Xw(this.headerClient.httpClient, e);
  }
  async *readFeatureBatch(e, t) {
    let [n] = e[0], [i, s] = e[e.length - 1], l = this.buildFeatureClient(t), o = i + s - n;
    for (let [d, , m] of e) {
      let b = await this.readFeature(l, d, o);
      yield {
        id: m,
        feature: b
      }, o = 0;
    }
    l.logUsage("feature");
  }
  async readFeature(e, t, n) {
    let i, s = t + this.lengthBeforeFeatures();
    i = new DataView(await e.getRange(s, 4, n, "feature length")).getUint32(0, !0);
    let l = new Uint8Array(await e.getRange(s + 4, i, n, "feature data")), o = new Uint8Array(i + Nu);
    o.set(l, Nu);
    let d = new Fu(o);
    return d.setPosition(Nu), _c.getRootAsFeature(d);
  }
}
let Xw = class {
  constructor(e, t) {
    H(this, "httpClient");
    H(this, "bytesEverUsed", 0);
    H(this, "bytesEverFetched", 0);
    H(this, "buffer", new ArrayBuffer(0));
    H(this, "head", 0);
    if (typeof e == "string") this.httpClient = new Zw(e, t);
    else if (e instanceof Zw) this.httpClient = e;
    else throw Error("Unknown source ");
  }
  async getRange(e, t, n, i) {
    this.bytesEverUsed += t;
    let s = e - this.head, l = s + t;
    if (s >= 0 && l <= this.buffer.byteLength) return this.buffer.slice(s, l);
    let o = Math.max(t, n);
    return this.bytesEverFetched += o, this.buffer = await this.httpClient.getRange(e, o, i), this.head = e, this.buffer.slice(0, t);
  }
  logUsage(e) {
    e.split(" ")[0], (100 * this.bytesEverUsed / this.bytesEverFetched).toFixed(2);
  }
}, Zw = class {
  constructor(e, t) {
    H(this, "url");
    H(this, "nocache");
    H(this, "requestsEverMade", 0);
    H(this, "bytesEverRequested", 0);
    this.url = e, this.nocache = t;
  }
  async getRange(e, t, n) {
    this.requestsEverMade += 1, this.bytesEverRequested += t;
    let i = {
      Range: `bytes=${e}-${e + t - 1}`
    };
    return this.nocache && (i["Cache-Control"] = "no-cache, no-store"), await (await fetch(this.url, {
      headers: i
    })).arrayBuffer();
  }
};
function YR(r, e, t) {
  if (!r.subarray(0, 3).every((b, T) => cf[T] === b)) throw Error("Not a FlatGeobuf file");
  let n = new Fu(r), i = n.readUint32(cf.length);
  n.setPosition(cf.length + Nu);
  let s = Fv(n), l = cf.length + Nu + i, {
    indexNodeSize: o,
    featuresCount: d
  } = s;
  o > 0 && (l += zv(d, o));
  let m = [];
  for (; l < n.capacity(); ) {
    let b = n.readUint32(l);
    n.setPosition(l + Nu);
    let T = _c.getRootAsFeature(n);
    m.push(e(m.length, T, s)), l += Nu + b;
  }
  return m;
}
async function* KR(r, e, t) {
  let n, i = DR(r), s = async (E) => await i.slice(E), l = new Uint8Array(await s(8));
  if (!l.subarray(0, 3).every((E, D) => cf[D] === E)) throw Error("Not a FlatGeobuf file");
  l = new Uint8Array(await s(4));
  let o = new Fu(l), d = o.readUint32(0);
  l = new Uint8Array(await s(d));
  let m = Fv(o = new Fu(l)), {
    indexNodeSize: b,
    featuresCount: T
  } = m;
  if (b > 0) {
    let E = zv(T, b);
    await s(E);
  }
  let M = 0;
  for (; n = await QR(s, m, e, M++); ) yield n;
}
function JR(r, e, t, n) {
  try {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    return async function* () {
      let s = await jv.open(r, i);
      for await (let l of (n && n(s.header), s.selectBbox(e))) yield t(l.id, l.feature, s.header);
    }();
  } catch (i) {
    return Promise.reject(i);
  }
}
async function QR(r, e, t, n) {
  let i = new Uint8Array(await r(4, "feature length"));
  if (i.byteLength === 0) return;
  let s = new Fu(i), l = s.readUint32(0);
  i = new Uint8Array(await r(l, "feature data"));
  let o = new Uint8Array(l + 4);
  return o.set(i, 4), (s = new Fu(o)).setPosition(Nu), t(n, _c.getRootAsFeature(s), e);
}
function p1(r, e) {
  let t = e;
  if (t === zo.Unknown && (t = r.type()), t === zo.GeometryCollection) {
    let i = [];
    for (let s = 0; s < r.partsLength(); s++) {
      let l = r.parts(s), o = l.type();
      i.push(p1(l, o));
    }
    return {
      type: zo[t],
      geometries: i
    };
  }
  if (t === zo.MultiPolygon) {
    let i = [];
    for (let s = 0; s < r.partsLength(); s++) i.push(p1(r.parts(s), zo.Polygon));
    return {
      type: zo[t],
      coordinates: i.map((s) => s.coordinates)
    };
  }
  let n = function(i, s) {
    let l = i.xyArray(), o = i.zArray();
    switch (s) {
      case zo.Point: {
        let d = Array.from(l);
        return o && d.push(o[0]), d;
      }
      case zo.MultiPoint:
      case zo.LineString:
        return P0(l, o);
      case zo.MultiLineString:
      case zo.Polygon:
        return function(d, m, b) {
          let T;
          if (!b || b.length === 0) return [P0(d, m)];
          let M = 0, E = Array.from(b).map((D) => d.slice(M, M = D << 1));
          return m && (M = 0, T = Array.from(b).map((D) => m.slice(M, M = D))), E.map((D, U) => P0(D, T ? T[U] : void 0));
        }(l, o, i.endsArray());
    }
  }(r, t);
  return {
    type: zo[t],
    coordinates: n
  };
}
function Vv(r, e, t) {
  let n = t.columns;
  return {
    type: "Feature",
    id: r,
    geometry: p1(e.geometry(), t.geometryType),
    properties: RR(e, n)
  };
}
function e4(r, e) {
  return {
    type: "FeatureCollection",
    features: YR(r, Vv)
  };
}
function t4(r, e) {
  return KR(r, Vv);
}
function r4(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return JR(r, e, Vv, t, n);
}
function Yw(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return r instanceof Uint8Array ? e4(r) : r instanceof ReadableStream ? t4(r) : r4(r, e, t, n);
}
class n4 {
  constructor() {
    this._bearing = 0, this._pitch = 60, this._minpitchzoom = null;
  }
  onAdd(e) {
    this._map = e;
    let t = this;
    return this._btn = document.createElement("button"), this._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-2d", this._btn.id = "bt3D", this._btn.type = "button", this._btn["aria-label"] = "Vista 3D", this._btn.onclick = function() {
      if (t._btn.className.indexOf("3d") != -1) {
        let m = {
          pitch: t._pitch,
          bearing: t._bearing
        };
        t._minpitchzoom && e.getZoom() > t._minpitchzoom && (m.zoom = t._minpitchzoom);
        var n = 0, i = 38.5, s = 6, l = 62.33, {
          longitude: o,
          latitude: d
        } = e.getCenter();
        e.getZoom() < 10 ? e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.5
        }) : o >= n && o <= s && d >= i && d <= l ? e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.2
        }) : e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.5
        }), e.easeTo(m), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-2d";
      } else
        e.setTerrain(null), e.easeTo({
          pitch: 0,
          bearing: 0
        }), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-3d";
    }, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl maplibregl-ctrl-group", this._container.title = "Vista 3D", this._container.appendChild(this._btn), this._container;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
async function Eg(r, e, t, n) {
  return n._parse(r, e, t, n);
}
function xi(r, e) {
  if (!r)
    throw new Error(e || "loader assertion failed.");
}
const yy = (
  // @ts-ignore process does not exist on browser
  !!(typeof process != "object" || String(process) !== "[object process]" || process.browser)
), Kw = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
Kw && parseFloat(Kw[1]);
const sm = globalThis, td = globalThis.process || {}, i4 = globalThis.navigator || {};
function cE(r) {
  var n, i;
  if (typeof window < "u" && ((n = window.process) == null ? void 0 : n.type) === "renderer" || typeof process < "u" && ((i = process.versions) != null && i.electron))
    return !0;
  const t = typeof navigator < "u" && navigator.userAgent;
  return !!(t && t.indexOf("Electron") >= 0);
}
function Pf() {
  return !// @ts-expect-error
  (typeof process == "object" && String(process) === "[object process]" && !(process != null && process.browser)) || cE();
}
function s4(r) {
  return Pf() ? cE() ? "Electron" : (i4.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown" : "Node";
}
const uE = "4.1.0";
function o4(r) {
  try {
    const e = window[r], t = "__storage_test__";
    return e.setItem(t, t), e.removeItem(t), e;
  } catch {
    return null;
  }
}
class a4 {
  constructor(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
    this.storage = o4(n), this.id = e, this.config = t, this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(e) {
    if (Object.assign(this.config, e), this.storage) {
      const t = JSON.stringify(this.config);
      this.storage.setItem(this.id, t);
    }
  }
  // Get config from persistent store, if available
  _loadConfiguration() {
    let e = {};
    if (this.storage) {
      const t = this.storage.getItem(this.id);
      e = t ? JSON.parse(t) : {};
    }
    return Object.assign(this.config, e), this;
  }
}
function l4(r) {
  let e;
  return r < 10 ? e = `${r.toFixed(2)}ms` : r < 100 ? e = `${r.toFixed(1)}ms` : r < 1e3 ? e = `${r.toFixed(0)}ms` : e = `${(r / 1e3).toFixed(2)}s`, e;
}
function c4(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
  const t = Math.max(e - r.length, 0);
  return `${" ".repeat(t)}${r}`;
}
var g_;
(function(r) {
  r[r.BLACK = 30] = "BLACK", r[r.RED = 31] = "RED", r[r.GREEN = 32] = "GREEN", r[r.YELLOW = 33] = "YELLOW", r[r.BLUE = 34] = "BLUE", r[r.MAGENTA = 35] = "MAGENTA", r[r.CYAN = 36] = "CYAN", r[r.WHITE = 37] = "WHITE", r[r.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", r[r.BRIGHT_RED = 91] = "BRIGHT_RED", r[r.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", r[r.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", r[r.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", r[r.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", r[r.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", r[r.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
})(g_ || (g_ = {}));
const u4 = 10;
function Jw(r) {
  return typeof r != "string" ? r : (r = r.toUpperCase(), g_[r] || g_.WHITE);
}
function h4(r, e, t) {
  return !Pf && typeof r == "string" && (e && (r = `\x1B[${Jw(e)}m${r}\x1B[39m`), t && (r = `\x1B[${Jw(t) + u4}m${r}\x1B[49m`)), r;
}
function f4(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
  const t = Object.getPrototypeOf(r), n = Object.getOwnPropertyNames(t), i = r;
  for (const s of n) {
    const l = i[s];
    typeof l == "function" && (e.find((o) => s === o) || (i[s] = l.bind(r)));
  }
}
function qv(r, e) {
  if (!r)
    throw new Error("Assertion failed");
}
function rd() {
  var e, t, n;
  let r;
  if (Pf() && sm.performance)
    r = (t = (e = sm == null ? void 0 : sm.performance) == null ? void 0 : e.now) == null ? void 0 : t.call(e);
  else if ("hrtime" in td) {
    const i = (n = td == null ? void 0 : td.hrtime) == null ? void 0 : n.call(td);
    r = i[0] * 1e3 + i[1] / 1e6;
  } else
    r = Date.now();
  return r;
}
const nd = {
  debug: Pf() && console.debug || console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
}, d4 = {
  enabled: !0,
  level: 0
};
function id() {
}
const Qw = {}, eA = {
  once: !0
};
class Zd {
  constructor() {
    let {
      id: e
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      id: ""
    };
    this.VERSION = uE, this._startTs = rd(), this._deltaTs = rd(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = e, this.userData = {}, this._storage = new a4(`__probe-${this.id}__`, d4), this.timeStamp(`${this.id} started`), f4(this), Object.seal(this);
  }
  set level(e) {
    this.setLevel(e);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  /** @return milliseconds, with fractions */
  getTotal() {
    return Number((rd() - this._startTs).toPrecision(10));
  }
  /** @return milliseconds, with fractions */
  getDelta() {
    return Number((rd() - this._deltaTs).toPrecision(10));
  }
  /** @deprecated use logLevel */
  set priority(e) {
    this.level = e;
  }
  /** @deprecated use logLevel */
  get priority() {
    return this.level;
  }
  /** @deprecated use logLevel */
  getPriority() {
    return this.level;
  }
  // Configure
  enable() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    return this._storage.setConfiguration({
      enabled: e
    }), this;
  }
  setLevel(e) {
    return this._storage.setConfiguration({
      level: e
    }), this;
  }
  /** return the current status of the setting */
  get(e) {
    return this._storage.config[e];
  }
  // update the status of the setting
  set(e, t) {
    this._storage.setConfiguration({
      [e]: t
    });
  }
  /** Logs the current settings as a table */
  settings() {
    console.table ? console.table(this._storage.config) : console.log(this._storage.config);
  }
  // Unconditional logging
  assert(e, t) {
    if (!e)
      throw new Error(t || "Assertion failed");
  }
  warn(e) {
    return this._getLogFunction(0, e, nd.warn, arguments, eA);
  }
  error(e) {
    return this._getLogFunction(0, e, nd.error, arguments);
  }
  /** Print a deprecation warning */
  deprecated(e, t) {
    return this.warn(`\`${e}\` is deprecated and will be removed in a later version. Use \`${t}\` instead`);
  }
  /** Print a removal warning */
  removed(e, t) {
    return this.error(`\`${e}\` has been removed. Use \`${t}\` instead`);
  }
  probe(e, t) {
    return this._getLogFunction(e, t, nd.log, arguments, {
      time: !0,
      once: !0
    });
  }
  log(e, t) {
    return this._getLogFunction(e, t, nd.debug, arguments);
  }
  info(e, t) {
    return this._getLogFunction(e, t, console.info, arguments);
  }
  once(e, t) {
    return this._getLogFunction(e, t, nd.debug || nd.info, arguments, eA);
  }
  /** Logs an object as a table */
  table(e, t, n) {
    return t ? this._getLogFunction(e, t, console.table || id, n && [n], {
      tag: g4(t)
    }) : id;
  }
  time(e, t) {
    return this._getLogFunction(e, t, console.time ? console.time : console.info);
  }
  timeEnd(e, t) {
    return this._getLogFunction(e, t, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(e, t) {
    return this._getLogFunction(e, t, console.timeStamp || id);
  }
  group(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      collapsed: !1
    };
    const i = tA({
      logLevel: e,
      message: t,
      opts: n
    }), {
      collapsed: s
    } = n;
    return i.method = (s ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(i);
  }
  groupCollapsed(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.group(e, t, Object.assign({}, n, {
      collapsed: !0
    }));
  }
  groupEnd(e) {
    return this._getLogFunction(e, "", console.groupEnd || id);
  }
  // EXPERIMENTAL
  withGroup(e, t, n) {
    this.group(e, t)();
    try {
      n();
    } finally {
      this.groupEnd(e)();
    }
  }
  trace() {
    console.trace && console.trace();
  }
  // PRIVATE METHODS
  /** Deduces log level from a variety of arguments */
  _shouldLog(e) {
    return this.isEnabled() && this.getLevel() >= hE(e);
  }
  _getLogFunction(e, t, n, i, s) {
    if (this._shouldLog(e)) {
      s = tA({
        logLevel: e,
        message: t,
        args: i,
        opts: s
      }), n = n || s.method, qv(n), s.total = this.getTotal(), s.delta = this.getDelta(), this._deltaTs = rd();
      const l = s.tag || s.message;
      if (s.once && l)
        if (!Qw[l])
          Qw[l] = rd();
        else
          return id;
      return t = p4(this.id, s.message, s), n.bind(console, t, ...s.args);
    }
    return id;
  }
}
Zd.VERSION = uE;
function hE(r) {
  if (!r)
    return 0;
  let e;
  switch (typeof r) {
    case "number":
      e = r;
      break;
    case "object":
      e = r.logLevel || r.priority || 0;
      break;
    default:
      return 0;
  }
  return qv(Number.isFinite(e) && e >= 0), e;
}
function tA(r) {
  const {
    logLevel: e,
    message: t
  } = r;
  r.logLevel = hE(e);
  const n = r.args ? Array.from(r.args) : [];
  for (; n.length && n.shift() !== t; )
    ;
  switch (typeof e) {
    case "string":
    case "function":
      t !== void 0 && n.unshift(t), r.message = e;
      break;
    case "object":
      Object.assign(r, e);
      break;
  }
  typeof r.message == "function" && (r.message = r.message());
  const i = typeof r.message;
  return qv(i === "string" || i === "object"), Object.assign(r, {
    args: n
  }, r.opts);
}
function p4(r, e, t) {
  if (typeof e == "string") {
    const n = t.time ? c4(l4(t.total)) : "";
    e = t.time ? `${r}: ${n}  ${e}` : `${r}: ${e}`, e = h4(e, t.color, t.background);
  }
  return e;
}
function g4(r) {
  for (const e in r)
    for (const t in r[e])
      return t || "untitled";
  return "empty";
}
globalThis.probe = {};
const fE = new Zd({
  id: "@probe.gl/log"
}), B0 = "4.3.2", m4 = B0[0] >= "0" && B0[0] <= "9" ? `v${B0}` : "";
function _4() {
  const r = new Zd({
    id: "loaders.gl"
  });
  return globalThis.loaders = globalThis.loaders || {}, globalThis.loaders.log = r, globalThis.loaders.version = m4, globalThis.probe = globalThis.probe || {}, globalThis.probe.loaders = r, r;
}
const y4 = _4();
function b4(r, e) {
  return dE(r || {}, e);
}
function dE(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  if (t > 3)
    return e;
  const n = {
    ...r
  };
  for (const [i, s] of Object.entries(e))
    s && typeof s == "object" && !Array.isArray(s) ? n[i] = dE(n[i] || {}, e[i], t + 1) : n[i] = e[i];
  return n;
}
function v4(r) {
  var e;
  globalThis.loaders || (globalThis.loaders = {}), (e = globalThis.loaders).modules || (e.modules = {}), Object.assign(globalThis.loaders.modules, r);
}
function x4(r) {
  var t, n;
  return ((n = (t = globalThis.loaders) == null ? void 0 : t.modules) == null ? void 0 : n[r]) || null;
}
const w4 = "latest";
function A4() {
  var r;
  return (r = globalThis._loadersgl_) != null && r.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.2"), globalThis._loadersgl_.version;
}
const pE = A4();
function Uu(r, e) {
  if (!r)
    throw new Error(e || "loaders.gl assertion failed.");
}
const Cl = (
  // @ts-ignore process.browser
  typeof process != "object" || String(process) !== "[object process]" || process.browser
), Gv = typeof importScripts == "function", T4 = typeof window < "u" && typeof window.orientation < "u", rA = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
rA && parseFloat(rA[1]);
class S4 {
  constructor(e, t) {
    H(this, "name");
    H(this, "workerThread");
    H(this, "isRunning", !0);
    /** Promise that resolves when Job is done */
    H(this, "result");
    H(this, "_resolve", () => {
    });
    H(this, "_reject", () => {
    });
    this.name = e, this.workerThread = t, this.result = new Promise((n, i) => {
      this._resolve = n, this._reject = i;
    });
  }
  /**
   * Send a message to the job's worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   */
  postMessage(e, t) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      // Lets worker ignore unrelated messages
      type: e,
      payload: t
    });
  }
  /**
   * Call to resolve the `result` Promise with the supplied value
   */
  done(e) {
    Uu(this.isRunning), this.isRunning = !1, this._resolve(e);
  }
  /**
   * Call to reject the `result` Promise with the supplied error
   */
  error(e) {
    Uu(this.isRunning), this.isRunning = !1, this._reject(e);
  }
}
class L0 {
  terminate() {
  }
}
const O0 = /* @__PURE__ */ new Map();
function E4(r) {
  Uu(r.source && !r.url || !r.source && r.url);
  let e = O0.get(r.source || r.url);
  return e || (r.url && (e = C4(r.url), O0.set(r.url, e)), r.source && (e = gE(r.source), O0.set(r.source, e))), Uu(e), e;
}
function C4(r) {
  if (!r.startsWith("http"))
    return r;
  const e = I4(r);
  return gE(e);
}
function gE(r) {
  const e = new Blob([r], {
    type: "application/javascript"
  });
  return URL.createObjectURL(e);
}
function I4(r) {
  return `try {
  importScripts('${r}');
} catch (error) {
  console.error(error);
  throw error;
}`;
}
function mE(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, t = arguments.length > 2 ? arguments[2] : void 0;
  const n = t || /* @__PURE__ */ new Set();
  if (r) {
    if (nA(r))
      n.add(r);
    else if (nA(r.buffer))
      n.add(r.buffer);
    else if (!ArrayBuffer.isView(r)) {
      if (e && typeof r == "object")
        for (const i in r)
          mE(r[i], e, n);
    }
  }
  return t === void 0 ? Array.from(n) : [];
}
function nA(r) {
  return r ? r instanceof ArrayBuffer || typeof MessagePort < "u" && r instanceof MessagePort || typeof ImageBitmap < "u" && r instanceof ImageBitmap || typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas : !1;
}
const N0 = () => {
};
class g1 {
  constructor(e) {
    H(this, "name");
    H(this, "source");
    H(this, "url");
    H(this, "terminated", !1);
    H(this, "worker");
    H(this, "onMessage");
    H(this, "onError");
    H(this, "_loadableURL", "");
    const {
      name: t,
      source: n,
      url: i
    } = e;
    Uu(n || i), this.name = t, this.source = n, this.url = i, this.onMessage = N0, this.onError = (s) => console.log(s), this.worker = Cl ? this._createBrowserWorker() : this._createNodeWorker();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return typeof Worker < "u" && Cl || typeof L0 < "u" && !Cl;
  }
  /**
   * Terminate this worker thread
   * @note Can free up significant memory
   */
  destroy() {
    this.onMessage = N0, this.onError = N0, this.worker.terminate(), this.terminated = !0;
  }
  get isRunning() {
    return !!this.onMessage;
  }
  /**
   * Send a message to this worker thread
   * @param data any data structure, ideally consisting mostly of transferrable objects
   * @param transferList If not supplied, calculated automatically by traversing data
   */
  postMessage(e, t) {
    t = t || mE(e), this.worker.postMessage(e, t);
  }
  // PRIVATE
  /**
   * Generate a standard Error from an ErrorEvent
   * @param event
   */
  _getErrorFromErrorEvent(e) {
    let t = "Failed to load ";
    return t += `worker ${this.name} from ${this.url}. `, e.message && (t += `${e.message} in `), e.lineno && (t += `:${e.lineno}:${e.colno}`), new Error(t);
  }
  /**
   * Creates a worker thread on the browser
   */
  _createBrowserWorker() {
    this._loadableURL = E4({
      source: this.source,
      url: this.url
    });
    const e = new Worker(this._loadableURL, {
      name: this.name
    });
    return e.onmessage = (t) => {
      t.data ? this.onMessage(t.data) : this.onError(new Error("No data received"));
    }, e.onerror = (t) => {
      this.onError(this._getErrorFromErrorEvent(t)), this.terminated = !0;
    }, e.onmessageerror = (t) => console.error(t), e;
  }
  /**
   * Creates a worker thread in node.js
   * @todo https://nodejs.org/api/async_hooks.html#async-resource-worker-pool
   */
  _createNodeWorker() {
    let e;
    if (this.url) {
      const n = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
      e = new L0(n, {
        eval: !1
      });
    } else if (this.source)
      e = new L0(this.source, {
        eval: !0
      });
    else
      throw new Error("no worker");
    return e.on("message", (t) => {
      this.onMessage(t);
    }), e.on("error", (t) => {
      this.onError(t);
    }), e.on("exit", (t) => {
    }), e;
  }
}
class M4 {
  /**
   * @param processor - worker function
   * @param maxConcurrency - max count of workers
   */
  constructor(e) {
    H(this, "name", "unnamed");
    H(this, "source");
    // | Function;
    H(this, "url");
    H(this, "maxConcurrency", 1);
    H(this, "maxMobileConcurrency", 1);
    H(this, "onDebug", () => {
    });
    H(this, "reuseWorkers", !0);
    H(this, "props", {});
    H(this, "jobQueue", []);
    H(this, "idleQueue", []);
    H(this, "count", 0);
    H(this, "isDestroyed", !1);
    this.source = e.source, this.url = e.url, this.setProps(e);
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return g1.isSupported();
  }
  /**
   * Terminates all workers in the pool
   * @note Can free up significant memory
   */
  destroy() {
    this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = !0;
  }
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
  }
  async startJob(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (s, l, o) => s.done(o), n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (s, l) => s.error(l);
    const i = new Promise((s) => (this.jobQueue.push({
      name: e,
      onMessage: t,
      onError: n,
      onStart: s
    }), this));
    return this._startQueuedJob(), await i;
  }
  // PRIVATE
  /**
   * Starts first queued job if worker is available or can be created
   * Called when job is started and whenever a worker returns to the idleQueue
   */
  async _startQueuedJob() {
    if (!this.jobQueue.length)
      return;
    const e = this._getAvailableWorker();
    if (!e)
      return;
    const t = this.jobQueue.shift();
    if (t) {
      this.onDebug({
        message: "Starting job",
        name: t.name,
        workerThread: e,
        backlog: this.jobQueue.length
      });
      const n = new S4(t.name, e);
      e.onMessage = (i) => t.onMessage(n, i.type, i.payload), e.onError = (i) => t.onError(n, i), t.onStart(n);
      try {
        await n.result;
      } catch (i) {
        console.error(`Worker exception: ${i}`);
      } finally {
        this.returnWorkerToQueue(e);
      }
    }
  }
  /**
   * Returns a worker to the idle queue
   * Destroys the worker if
   *  - pool is destroyed
   *  - if this pool doesn't reuse workers
   *  - if maxConcurrency has been lowered
   * @param worker
   */
  returnWorkerToQueue(e) {
    // Workers on Node.js prevent the process from exiting.
    // Until we figure out how to close them before exit, we always destroy them
    !Cl || // If the pool is destroyed, there is no reason to keep the worker around
    this.isDestroyed || // If the app has disabled worker reuse, any completed workers should be destroyed
    !this.reuseWorkers || // If concurrency has been lowered, this worker might be surplus to requirements
    this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
  }
  /**
   * Returns idle worker or creates new worker if maxConcurrency has not been reached
   */
  _getAvailableWorker() {
    if (this.idleQueue.length > 0)
      return this.idleQueue.shift() || null;
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new g1({
        name: e,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return T4 ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const P4 = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: !0,
  onDebug: () => {
  }
}, bh = class bh {
  /** get global instance with WorkerFarm.getWorkerFarm() */
  constructor(e) {
    H(this, "props");
    H(this, "workerPools", /* @__PURE__ */ new Map());
    this.props = {
      ...P4
    }, this.setProps(e), this.workerPools = /* @__PURE__ */ new Map();
  }
  /** Checks if workers are supported on this platform */
  static isSupported() {
    return g1.isSupported();
  }
  /** Get the singleton instance of the global worker farm */
  static getWorkerFarm() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return bh._workerFarm = bh._workerFarm || new bh({}), bh._workerFarm.setProps(e), bh._workerFarm;
  }
  /**
   * Terminate all workers in the farm
   * @note Can free up significant memory
   */
  destroy() {
    for (const e of this.workerPools.values())
      e.destroy();
    this.workerPools = /* @__PURE__ */ new Map();
  }
  /**
   * Set props used when initializing worker pools
   * @param props
   */
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    };
    for (const t of this.workerPools.values())
      t.setProps(this._getWorkerPoolProps());
  }
  /**
   * Returns a worker pool for the specified worker
   * @param options - only used first time for a specific worker name
   * @param options.name - the name of the worker - used to identify worker pool
   * @param options.url -
   * @param options.source -
   * @example
   *   const job = WorkerFarm.getWorkerFarm().getWorkerPool({name, url}).startJob(...);
   */
  getWorkerPool(e) {
    const {
      name: t,
      source: n,
      url: i
    } = e;
    let s = this.workerPools.get(t);
    return s || (s = new M4({
      name: t,
      source: n,
      url: i
    }), s.setProps(this._getWorkerPoolProps()), this.workerPools.set(t, s)), s;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
};
// singleton
H(bh, "_workerFarm");
let m_ = bh;
function R4(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = e[r.id] || {}, n = Cl ? `${r.id}-worker.js` : `${r.id}-worker-node.js`;
  let i = t.workerUrl;
  if (!i && r.id === "compression" && (i = e.workerUrl), e._workerType === "test" && (Cl ? i = `modules/${r.module}/dist/${n}` : i = `modules/${r.module}/src/workers/${r.id}-worker-node.ts`), !i) {
    let s = r.version;
    s === "latest" && (s = w4);
    const l = s ? `@${s}` : "";
    i = `https://unpkg.com/@loaders.gl/${r.module}${l}/dist/${n}`;
  }
  return Uu(i), i;
}
function B4(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pE;
  Uu(r, "no worker provided");
  const t = r.version;
  return !(!e || !t);
}
const D0 = {};
async function mf(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  return e && (r = L4(r, e, t, n)), D0[r] = // eslint-disable-next-line @typescript-eslint/no-misused-promises
  D0[r] || O4(r), await D0[r];
}
function L4(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  if (!t.useLocalLibraries && r.startsWith("http"))
    return r;
  n = n || r;
  const i = t.modules || {};
  return i[n] ? i[n] : Cl ? t.CDN ? (Uu(t.CDN.startsWith("http")), `${t.CDN}/${e}@${pE}/dist/libs/${n}`) : Gv ? `../src/libs/${n}` : `modules/${e}/src/libs/${n}` : `modules/${e}/dist/libs/${n}`;
}
async function O4(r) {
  if (r.endsWith("wasm"))
    return await D4(r);
  if (!Cl)
    try {
      const {
        requireFromFile: t
      } = globalThis.loaders || {};
      return await (t == null ? void 0 : t(r));
    } catch (t) {
      return console.error(t), null;
    }
  if (Gv)
    return importScripts(r);
  const e = await k4(r);
  return N4(e, r);
}
function N4(r, e) {
  if (!Cl) {
    const {
      requireFromString: n
    } = globalThis.loaders || {};
    return n == null ? void 0 : n(r, e);
  }
  if (Gv)
    return eval.call(globalThis, r), null;
  const t = document.createElement("script");
  t.id = e;
  try {
    t.appendChild(document.createTextNode(r));
  } catch {
    t.text = r;
  }
  return document.body.appendChild(t), null;
}
async function D4(r) {
  const {
    readFileAsArrayBuffer: e
  } = globalThis.loaders || {};
  return Cl || !e || r.startsWith("http") ? await (await fetch(r)).arrayBuffer() : await e(r);
}
async function k4(r) {
  const {
    readFileAsText: e
  } = globalThis.loaders || {};
  return Cl || !e || r.startsWith("http") ? await (await fetch(r)).text() : await e(r);
}
function F4(r, e) {
  return !m_.isSupported() || !Cl && !(e != null && e._nodeWorkers) ? !1 : r.worker && (e == null ? void 0 : e.worker);
}
async function U4(r, e, t, n, i) {
  const s = r.id, l = R4(r, t), d = m_.getWorkerFarm(t).getWorkerPool({
    name: s,
    url: l
  });
  t = JSON.parse(JSON.stringify(t)), n = JSON.parse(JSON.stringify(n || {}));
  const m = await d.startJob(
    "process-on-worker",
    // @ts-expect-error
    z4.bind(null, i)
    // eslint-disable-line @typescript-eslint/no-misused-promises
  );
  return m.postMessage("process", {
    // @ts-ignore
    input: e,
    options: t,
    context: n
  }), await (await m.result).result;
}
async function z4(r, e, t, n) {
  switch (t) {
    case "done":
      e.done(n);
      break;
    case "error":
      e.error(new Error(n.error));
      break;
    case "process":
      const {
        id: i,
        input: s,
        options: l
      } = n;
      try {
        const o = await r(s, l);
        e.postMessage("done", {
          id: i,
          result: o
        });
      } catch (o) {
        const d = o instanceof Error ? o.message : "unknown error";
        e.postMessage("error", {
          id: i,
          error: d
        });
      }
      break;
    default:
      console.warn(`parse-with-worker unknown message ${t}`);
  }
}
function j4(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  return typeof r == "string" ? r.slice(0, e) : ArrayBuffer.isView(r) ? iA(r.buffer, r.byteOffset, e) : r instanceof ArrayBuffer ? iA(r, 0, e) : "";
}
function iA(r, e, t) {
  if (r.byteLength <= e + t)
    return "";
  const n = new DataView(r);
  let i = "";
  for (let s = 0; s < t; s++)
    i += String.fromCharCode(n.getUint8(e + s));
  return i;
}
function V4(r) {
  try {
    return JSON.parse(r);
  } catch {
    throw new Error(`Failed to parse JSON from data starting with "${j4(r)}"`);
  }
}
function q4(r, e, t) {
  if (t = t || r.byteLength, r.byteLength < t || e.byteLength < t)
    return !1;
  const n = new Uint8Array(r), i = new Uint8Array(e);
  for (let s = 0; s < n.length; ++s)
    if (n[s] !== i[s])
      return !1;
  return !0;
}
function G4() {
  for (var r = arguments.length, e = new Array(r), t = 0; t < r; t++)
    e[t] = arguments[t];
  return $4(e);
}
function $4(r) {
  const e = r.map((s) => s instanceof ArrayBuffer ? new Uint8Array(s) : s), t = e.reduce((s, l) => s + l.byteLength, 0), n = new Uint8Array(t);
  let i = 0;
  for (const s of e)
    n.set(s, i), i += s.byteLength;
  return n.buffer;
}
function $v(r, e, t) {
  const n = t !== void 0 ? new Uint8Array(r).subarray(e, e + t) : new Uint8Array(r).subarray(e);
  return new Uint8Array(n).buffer;
}
function Cg(r, e) {
  return xi(r >= 0), xi(e > 0), r + (e - 1) & -4;
}
function H4(r, e, t) {
  let n;
  if (r instanceof ArrayBuffer)
    n = new Uint8Array(r);
  else {
    const i = r.byteOffset, s = r.byteLength;
    n = new Uint8Array(r.buffer || r.arrayBuffer, i, s);
  }
  return e.set(n, t), t + Cg(n.byteLength, 4);
}
async function W4(r) {
  const e = [];
  for await (const t of r)
    e.push(t);
  return G4(...e);
}
function sA() {
  let r;
  if (typeof window < "u" && window.performance)
    r = window.performance.now();
  else if (typeof process < "u" && process.hrtime) {
    const e = process.hrtime();
    r = e[0] * 1e3 + e[1] / 1e6;
  } else
    r = Date.now();
  return r;
}
class oA {
  constructor(e, t) {
    this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = e, this.type = t, this.reset();
  }
  reset() {
    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
  }
  setSampleSize(e) {
    return this.sampleSize = e, this;
  }
  /** Call to increment count (+1) */
  incrementCount() {
    return this.addCount(1), this;
  }
  /** Call to decrement count (-1) */
  decrementCount() {
    return this.subtractCount(1), this;
  }
  /** Increase count */
  addCount(e) {
    return this._count += e, this._samples++, this._checkSampling(), this;
  }
  /** Decrease count */
  subtractCount(e) {
    return this._count -= e, this._samples++, this._checkSampling(), this;
  }
  /** Add an arbitrary timing and bump the count */
  addTime(e) {
    return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
  }
  /** Start a timer */
  timeStart() {
    return this._startTime = sA(), this._timerPending = !0, this;
  }
  /** End a timer. Adds to time and bumps the timing count. */
  timeEnd() {
    return this._timerPending ? (this.addTime(sA() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  /** Calculate average time / count for the previous window */
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  /** Calculate counts per second for the previous window */
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  /** Calculate average time / count */
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  /** Calculate counts per second */
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  _checkSampling() {
    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
  }
}
class Yd {
  constructor(e) {
    this.stats = {}, this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
  }
  /** Acquire a stat. Create if it doesn't exist. */
  get(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
    return this._getOrCreate({
      name: e,
      type: t
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  /** Reset all stats */
  reset() {
    for (const e of Object.values(this.stats))
      e.reset();
    return this;
  }
  forEach(e) {
    for (const t of Object.values(this.stats))
      e(t);
  }
  getTable() {
    const e = {};
    return this.forEach((t) => {
      e[t.name] = {
        time: t.time || 0,
        count: t.count || 0,
        average: t.getAverageTime() || 0,
        hz: t.getHz() || 0
      };
    }), e;
  }
  _initializeStats() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((t) => this._getOrCreate(t));
  }
  _getOrCreate(e) {
    const {
      name: t,
      type: n
    } = e;
    let i = this.stats[t];
    return i || (e instanceof oA ? i = e : i = new oA(t, n), this.stats[t] = i), i;
  }
}
const X4 = "Queued Requests", Z4 = "Active Requests", Y4 = "Cancelled Requests", K4 = "Queued Requests Ever", J4 = "Active Requests Ever", Q4 = {
  id: "request-scheduler",
  /** Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing. */
  throttleRequests: !0,
  /** The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit. */
  maxRequests: 6,
  /**
   * Specifies a debounce time, in milliseconds. All requests are queued, until no new requests have
   * been added to the queue for this amount of time.
   */
  debounceTime: 0
};
class eB {
  constructor() {
    H(this, "props");
    H(this, "stats");
    H(this, "activeRequestCount", 0);
    /** Tracks the number of active requests and prioritizes/cancels queued requests. */
    H(this, "requestQueue", []);
    H(this, "requestMap", /* @__PURE__ */ new Map());
    H(this, "updateTimer", null);
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.props = {
      ...Q4,
      ...e
    }, this.stats = new Yd({
      id: this.props.id
    }), this.stats.get(X4), this.stats.get(Z4), this.stats.get(Y4), this.stats.get(K4), this.stats.get(J4);
  }
  /**
   * Called by an application that wants to issue a request, without having it deeply queued by the browser
   *
   * When the returned promise resolved, it is OK for the application to issue a request.
   * The promise resolves to an object that contains a `done` method.
   * When the application's request has completed (or failed), the application must call the `done` function
   *
   * @param handle
   * @param getPriority will be called when request "slots" open up,
   *    allowing the caller to update priority or cancel the request
   *    Highest priority executes first, priority < 0 cancels the request
   * @returns a promise
   *   - resolves to a object (with a `done` field) when the request can be issued without queueing,
   *   - resolves to `null` if the request has been cancelled (by the callback return < 0).
   *     In this case the application should not issue the request
   */
  scheduleRequest(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;
    if (!this.props.throttleRequests)
      return Promise.resolve({
        done: () => {
        }
      });
    if (this.requestMap.has(e))
      return this.requestMap.get(e);
    const n = {
      handle: e,
      priority: 0,
      getPriority: t
    }, i = new Promise((s) => (n.resolve = s, n));
    return this.requestQueue.push(n), this.requestMap.set(e, i), this._issueNewRequests(), i;
  }
  // PRIVATE
  _issueRequest(e) {
    const {
      handle: t,
      resolve: n
    } = e;
    let i = !1;
    const s = () => {
      i || (i = !0, this.requestMap.delete(t), this.activeRequestCount--, this._issueNewRequests());
    };
    return this.activeRequestCount++, n ? n({
      done: s
    }) : Promise.resolve({
      done: s
    });
  }
  /** We check requests asynchronously, to prevent multiple updates */
  _issueNewRequests() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = setTimeout(() => this._issueNewRequestsAsync(), this.props.debounceTime);
  }
  /** Refresh all requests  */
  _issueNewRequestsAsync() {
    this.updateTimer !== null && clearTimeout(this.updateTimer), this.updateTimer = null;
    const e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (e !== 0) {
      this._updateAllRequests();
      for (let t = 0; t < e; ++t) {
        const n = this.requestQueue.shift();
        n && this._issueRequest(n);
      }
    }
  }
  /** Ensure all requests have updated priorities, and that no longer valid requests are cancelled */
  _updateAllRequests() {
    const e = this.requestQueue;
    for (let t = 0; t < e.length; ++t) {
      const n = e[t];
      this._updateRequest(n) || (e.splice(t, 1), this.requestMap.delete(n.handle), t--);
    }
    e.sort((t, n) => t.priority - n.priority);
  }
  /** Update a single request by calling the callback */
  _updateRequest(e) {
    return e.priority = e.getPriority(e.handle), e.priority < 0 ? (e.resolve(null), !1) : !0;
  }
}
let tB = "";
const aA = {};
function rB(r) {
  for (const e in aA)
    if (r.startsWith(e)) {
      const t = aA[e];
      r = r.replace(e, t);
    }
  return !r.startsWith("http://") && !r.startsWith("https://") && (r = `${tB}${r}`), r;
}
function nB(r) {
  return r && typeof r == "object" && r.isBuffer;
}
function _E(r) {
  if (nB(r))
    return r;
  if (r instanceof ArrayBuffer)
    return r;
  if (ArrayBuffer.isView(r))
    return r.byteOffset === 0 && r.byteLength === r.buffer.byteLength ? r.buffer : r.buffer.slice(r.byteOffset, r.byteOffset + r.byteLength);
  if (typeof r == "string") {
    const e = r;
    return new TextEncoder().encode(e).buffer;
  }
  if (r && typeof r == "object" && r._toArrayBuffer)
    return r._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function iB() {
  var e;
  if (typeof process < "u" && typeof process.cwd < "u")
    return process.cwd();
  const r = (e = window.location) == null ? void 0 : e.pathname;
  return (r == null ? void 0 : r.slice(0, r.lastIndexOf("/") + 1)) || "";
}
function yE(r) {
  const e = r ? r.lastIndexOf("/") : -1;
  return e >= 0 ? r.substr(e + 1) : "";
}
function Hv(r) {
  const e = r ? r.lastIndexOf("/") : -1;
  return e >= 0 ? r.substr(0, e) : "";
}
function sB() {
  const r = [];
  for (let i = 0; i < arguments.length; i++)
    r[i] = i < 0 || arguments.length <= i ? void 0 : arguments[i];
  let e = "", t = !1, n;
  for (let i = r.length - 1; i >= -1 && !t; i--) {
    let s;
    i >= 0 ? s = r[i] : (n === void 0 && (n = iB()), s = n), s.length !== 0 && (e = `${s}/${e}`, t = s.charCodeAt(0) === qp);
  }
  return e = oB(e, !t), t ? `/${e}` : e.length > 0 ? e : ".";
}
const qp = 47, k0 = 46;
function oB(r, e) {
  let t = "", n = -1, i = 0, s, l = !1;
  for (let o = 0; o <= r.length; ++o) {
    if (o < r.length)
      s = r.charCodeAt(o);
    else {
      if (s === qp)
        break;
      s = qp;
    }
    if (s === qp) {
      if (!(n === o - 1 || i === 1)) if (n !== o - 1 && i === 2) {
        if (t.length < 2 || !l || t.charCodeAt(t.length - 1) !== k0 || t.charCodeAt(t.length - 2) !== k0) {
          if (t.length > 2) {
            const d = t.length - 1;
            let m = d;
            for (; m >= 0 && t.charCodeAt(m) !== qp; --m)
              ;
            if (m !== d) {
              t = m === -1 ? "" : t.slice(0, m), n = o, i = 0, l = !1;
              continue;
            }
          } else if (t.length === 2 || t.length === 1) {
            t = "", n = o, i = 0, l = !1;
            continue;
          }
        }
        e && (t.length > 0 ? t += "/.." : t = "..", l = !0);
      } else {
        const d = r.slice(n + 1, o);
        t.length > 0 ? t += `/${d}` : t = d, l = !1;
      }
      n = o, i = 0;
    } else s === k0 && i !== -1 ? ++i : i = -1;
  }
  return t;
}
const aB = (r) => typeof r == "boolean", Qp = (r) => typeof r == "function", Ig = (r) => r !== null && typeof r == "object", lA = (r) => Ig(r) && r.constructor === {}.constructor, lB = (r) => !!r && typeof r[Symbol.iterator] == "function", cB = (r) => r && typeof r[Symbol.asyncIterator] == "function", Rf = (r) => typeof Response < "u" && r instanceof Response || r && r.arrayBuffer && r.text && r.json, Bf = (r) => typeof Blob < "u" && r instanceof Blob, uB = (r) => r && typeof r == "object" && r.isBuffer, hB = (r) => typeof ReadableStream < "u" && r instanceof ReadableStream || Ig(r) && Qp(r.tee) && Qp(r.cancel) && Qp(r.getReader), fB = (r) => Ig(r) && Qp(r.read) && Qp(r.pipe) && aB(r.readable), bE = (r) => hB(r) || fB(r);
class dB extends Error {
  constructor(t, n) {
    super(t);
    /** A best effort reason for why the fetch failed */
    H(this, "reason");
    /** The URL that failed to load. Empty string if not available. */
    H(this, "url");
    /** The Response object, if any. */
    H(this, "response");
    this.reason = n.reason, this.url = n.url, this.response = n.response;
  }
}
const pB = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, gB = /^([-\w.]+\/[-\w.+]+)/;
function cA(r, e) {
  return r.toLowerCase() === e.toLowerCase();
}
function mB(r) {
  const e = gB.exec(r);
  return e ? e[1] : r;
}
function uA(r) {
  const e = pB.exec(r);
  return e ? e[1] : "";
}
const vE = /\?.*/;
function _B(r) {
  const e = r.match(vE);
  return e && e[0];
}
function Wv(r) {
  return r.replace(vE, "");
}
function yB(r) {
  if (r.length < 50)
    return r;
  const e = r.slice(r.length - 15);
  return `${r.substr(0, 32)}...${e}`;
}
function by(r) {
  return Rf(r) ? r.url : Bf(r) ? r.name || "" : typeof r == "string" ? r : "";
}
function Xv(r) {
  if (Rf(r)) {
    const e = r, t = e.headers.get("content-type") || "", n = Wv(e.url);
    return mB(t) || uA(n);
  }
  return Bf(r) ? r.type || "" : typeof r == "string" ? uA(r) : "";
}
function bB(r) {
  return Rf(r) ? r.headers["content-length"] || -1 : Bf(r) ? r.size : typeof r == "string" ? r.length : r instanceof ArrayBuffer || ArrayBuffer.isView(r) ? r.byteLength : -1;
}
async function xE(r) {
  if (Rf(r))
    return r;
  const e = {}, t = bB(r);
  t >= 0 && (e["content-length"] = String(t));
  const n = by(r), i = Xv(r);
  i && (e["content-type"] = i);
  const s = await wB(r);
  s && (e["x-first-bytes"] = s), typeof r == "string" && (r = new TextEncoder().encode(r));
  const l = new Response(r, {
    headers: e
  });
  return Object.defineProperty(l, "url", {
    value: n
  }), l;
}
async function vB(r) {
  if (!r.ok)
    throw await xB(r);
}
async function xB(r) {
  const e = yB(r.url);
  let t = `Failed to fetch resource (${r.status}) ${r.statusText}: ${e}`;
  t = t.length > 100 ? `${t.slice(0, 100)}...` : t;
  const n = {
    reason: r.statusText,
    url: r.url,
    response: r
  };
  try {
    const i = r.headers.get("Content-Type");
    n.reason = !r.bodyUsed && (i != null && i.includes("application/json")) ? await r.json() : await r.text();
  } catch {
  }
  return new dB(t, n);
}
async function wB(r) {
  if (typeof r == "string")
    return `data:,${r.slice(0, 5)}`;
  if (r instanceof Blob) {
    const t = r.slice(0, 5);
    return await new Promise((n) => {
      const i = new FileReader();
      i.onload = (s) => {
        var l;
        return n((l = s == null ? void 0 : s.target) == null ? void 0 : l.result);
      }, i.readAsDataURL(t);
    });
  }
  if (r instanceof ArrayBuffer) {
    const t = r.slice(0, 5);
    return `data:base64,${AB(t)}`;
  }
  return null;
}
function AB(r) {
  let e = "";
  const t = new Uint8Array(r);
  for (let n = 0; n < t.byteLength; n++)
    e += String.fromCharCode(t[n]);
  return btoa(e);
}
function TB(r) {
  return !SB(r) && !EB(r);
}
function SB(r) {
  return r.startsWith("http:") || r.startsWith("https:");
}
function EB(r) {
  return r.startsWith("data:");
}
async function hA(r, e) {
  var t, n;
  if (typeof r == "string") {
    const i = rB(r);
    return TB(i) && (t = globalThis.loaders) != null && t.fetchNode ? (n = globalThis.loaders) == null ? void 0 : n.fetchNode(i, e) : await fetch(i, e);
  }
  return await xE(r);
}
const fA = new Zd({
  id: "loaders.gl"
});
class CB {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class IB {
  constructor() {
    H(this, "console");
    this.console = console;
  }
  log() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.console.log.bind(this.console, ...t);
  }
  info() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.console.info.bind(this.console, ...t);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.console.warn.bind(this.console, ...t);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.console.error.bind(this.console, ...t);
  }
}
const wE = {
  // baseUri
  fetch: null,
  mimeType: void 0,
  nothrow: !1,
  log: new IB(),
  // A probe.gl compatible (`log.log()()` syntax) that just logs to console
  useLocalLibraries: !1,
  CDN: "https://unpkg.com/@loaders.gl",
  worker: !0,
  // By default, use worker if provided by loader.
  maxConcurrency: 3,
  // How many worker instances should be created for each loader.
  maxMobileConcurrency: 1,
  // How many worker instances should be created for each loader on mobile devices.
  reuseWorkers: yy,
  // By default reuse workers in browser (Node.js refuses to terminate if browsers are running)
  _nodeWorkers: !1,
  // By default do not support node workers
  _workerType: "",
  // 'test' to use locally generated workers
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: !1,
  // TODO - currently only implemented for parseInBatches, adds initial metadata batch,
  transforms: []
}, MB = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  // Warn if fetch options are used on top-level
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function AE() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders: r
  } = globalThis;
  return r._state || (r._state = {}), r._state;
}
function TE() {
  const r = AE();
  return r.globalOptions = r.globalOptions || {
    ...wE
  }, r.globalOptions;
}
function PB(r, e, t, n) {
  return t = t || [], t = Array.isArray(t) ? t : [t], RB(r, t), LB(e, r, n);
}
function RB(r, e) {
  dA(r, null, wE, MB, e);
  for (const t of e) {
    const n = r && r[t.id] || {}, i = t.options && t.options[t.id] || {}, s = t.deprecatedOptions && t.deprecatedOptions[t.id] || {};
    dA(n, t.id, i, s, e);
  }
}
function dA(r, e, t, n, i) {
  const s = e || "Top level", l = e ? `${e}.` : "";
  for (const o in r) {
    const d = !e && Ig(r[o]), m = o === "baseUri" && !e, b = o === "workerUrl" && e;
    if (!(o in t) && !m && !b) {
      if (o in n)
        fA.warn(`${s} loader option '${l}${o}' no longer supported, use '${n[o]}'`)();
      else if (!d) {
        const T = BB(o, i);
        fA.warn(`${s} loader option '${l}${o}' not recognized. ${T}`)();
      }
    }
  }
}
function BB(r, e) {
  const t = r.toLowerCase();
  let n = "";
  for (const i of e)
    for (const s in i.options) {
      if (r === s)
        return `Did you mean '${i.id}.${s}'?`;
      const l = s.toLowerCase();
      (t.startsWith(l) || l.startsWith(t)) && (n = n || `Did you mean '${i.id}.${s}'?`);
    }
  return n;
}
function LB(r, e, t) {
  const i = {
    ...r.options || {}
  };
  return OB(i, t), i.log === null && (i.log = new CB()), pA(i, TE()), pA(i, e), i;
}
function pA(r, e) {
  for (const t in e)
    if (t in e) {
      const n = e[t];
      lA(n) && lA(r[t]) ? r[t] = {
        ...r[t],
        ...e[t]
      } : r[t] = e[t];
    }
}
function OB(r, e) {
  e && !("baseUri" in r) && (r.baseUri = e);
}
function Zv(r) {
  return r ? (Array.isArray(r) && (r = r[0]), Array.isArray(r == null ? void 0 : r.extensions)) : !1;
}
function Yv(r) {
  xi(r, "null loader"), xi(Zv(r), "invalid loader");
  let e;
  return Array.isArray(r) && (e = r[1], r = r[0], r = {
    ...r,
    options: {
      ...r.options,
      ...e
    }
  }), (r != null && r.parseTextSync || r != null && r.parseText) && (r.text = !0), r.text || (r.binary = !0), r;
}
const SE = () => {
  const r = AE();
  return r.loaderRegistry = r.loaderRegistry || [], r.loaderRegistry;
};
function NB(r) {
  const e = SE();
  r = Array.isArray(r) ? r : [r];
  for (const t of r) {
    const n = Yv(t);
    e.find((i) => n === i) || e.unshift(n);
  }
}
function DB() {
  return SE();
}
const kB = /\.([^.]+)$/;
async function FB(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0;
  if (!EE(r))
    return null;
  let i = gA(r, e, {
    ...t,
    nothrow: !0
  }, n);
  if (i)
    return i;
  if (Bf(r) && (r = await r.slice(0, 10).arrayBuffer(), i = gA(r, e, t, n)), !i && !(t != null && t.nothrow))
    throw new Error(CE(r));
  return i;
}
function gA(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0;
  if (!EE(r))
    return null;
  if (e && !Array.isArray(e))
    return Yv(e);
  let i = [];
  e && (i = i.concat(e)), t != null && t.ignoreRegisteredLoaders || i.push(...DB()), zB(i);
  const s = UB(r, i, t, n);
  if (!s && !(t != null && t.nothrow))
    throw new Error(CE(r));
  return s;
}
function UB(r, e, t, n) {
  const i = by(r), s = Xv(r), l = Wv(i) || (n == null ? void 0 : n.url);
  let o = null, d = "";
  return t != null && t.mimeType && (o = F0(e, t == null ? void 0 : t.mimeType), d = `match forced by supplied MIME type ${t == null ? void 0 : t.mimeType}`), o = o || jB(e, l), d = d || (o ? `matched url ${l}` : ""), o = o || F0(e, s), d = d || (o ? `matched MIME type ${s}` : ""), o = o || qB(e, r), d = d || (o ? `matched initial data ${IE(r)}` : ""), t != null && t.fallbackMimeType && (o = o || F0(e, t == null ? void 0 : t.fallbackMimeType), d = d || (o ? `matched fallback MIME type ${s}` : "")), d && y4.log(1, `selectLoader selected ${o == null ? void 0 : o.name}: ${d}.`), o;
}
function EE(r) {
  return !(r instanceof Response && r.status === 204);
}
function CE(r) {
  const e = by(r), t = Xv(r);
  let n = "No valid loader found (";
  n += e ? `${yE(e)}, ` : "no url provided, ", n += `MIME type: ${t ? `"${t}"` : "not provided"}, `;
  const i = r ? IE(r) : "";
  return n += i ? ` first bytes: "${i}"` : "first bytes: not available", n += ")", n;
}
function zB(r) {
  for (const e of r)
    Yv(e);
}
function jB(r, e) {
  const t = e && kB.exec(e), n = t && t[1];
  return n ? VB(r, n) : null;
}
function VB(r, e) {
  e = e.toLowerCase();
  for (const t of r)
    for (const n of t.extensions)
      if (n.toLowerCase() === e)
        return t;
  return null;
}
function F0(r, e) {
  var t;
  for (const n of r)
    if ((t = n.mimeTypes) != null && t.some((i) => cA(e, i)) || cA(e, `application/x.${n.id}`))
      return n;
  return null;
}
function qB(r, e) {
  if (!e)
    return null;
  for (const t of r)
    if (typeof e == "string") {
      if (GB(e, t))
        return t;
    } else if (ArrayBuffer.isView(e)) {
      if (mA(e.buffer, e.byteOffset, t))
        return t;
    } else if (e instanceof ArrayBuffer && mA(e, 0, t))
      return t;
  return null;
}
function GB(r, e) {
  return e.testText ? e.testText(r) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((n) => r.startsWith(n));
}
function mA(r, e, t) {
  return (Array.isArray(t.tests) ? t.tests : [t.tests]).some((i) => $B(r, e, t, i));
}
function $B(r, e, t, n) {
  if (n instanceof ArrayBuffer)
    return q4(n, r, n.byteLength);
  switch (typeof n) {
    case "function":
      return n(r);
    case "string":
      const i = m1(r, e, n.length);
      return n === i;
    default:
      return !1;
  }
}
function IE(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  return typeof r == "string" ? r.slice(0, e) : ArrayBuffer.isView(r) ? m1(r.buffer, r.byteOffset, e) : r instanceof ArrayBuffer ? m1(r, 0, e) : "";
}
function m1(r, e, t) {
  if (r.byteLength < e + t)
    return "";
  const n = new DataView(r);
  let i = "";
  for (let s = 0; s < t; s++)
    i += String.fromCharCode(n.getUint8(e + s));
  return i;
}
const HB = 256 * 1024;
function* WB(r, e) {
  const t = (e == null ? void 0 : e.chunkSize) || HB;
  let n = 0;
  const i = new TextEncoder();
  for (; n < r.length; ) {
    const s = Math.min(r.length - n, t), l = r.slice(n, n + s);
    n += s, yield i.encode(l);
  }
}
const XB = 256 * 1024;
function ZB(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    const {
      chunkSize: t = XB
    } = e;
    let n = 0;
    for (; n < r.byteLength; ) {
      const i = Math.min(r.byteLength - n, t), s = new ArrayBuffer(i), l = new Uint8Array(r, n, i);
      new Uint8Array(s).set(l), n += i, yield s;
    }
  }();
}
const YB = 1024 * 1024;
async function* KB(r, e) {
  const t = (e == null ? void 0 : e.chunkSize) || YB;
  let n = 0;
  for (; n < r.size; ) {
    const i = n + t, s = await r.slice(n, i).arrayBuffer();
    n = i, yield s;
  }
}
function _A(r, e) {
  return yy ? JB(r, e) : QB(r);
}
async function* JB(r, e) {
  const t = r.getReader();
  let n;
  try {
    for (; ; ) {
      const i = n || t.read();
      e != null && e._streamReadAhead && (n = t.read());
      const {
        done: s,
        value: l
      } = await i;
      if (s)
        return;
      yield _E(l);
    }
  } catch {
    t.releaseLock();
  }
}
async function* QB(r, e) {
  for await (const t of r)
    yield _E(t);
}
function eL(r, e) {
  if (typeof r == "string")
    return WB(r, e);
  if (r instanceof ArrayBuffer)
    return ZB(r, e);
  if (Bf(r))
    return KB(r, e);
  if (bE(r))
    return _A(r, e);
  if (Rf(r))
    return _A(r.body, e);
  throw new Error("makeIterator");
}
const ME = "Cannot convert supplied data type";
function tL(r, e, t) {
  if (e.text && typeof r == "string")
    return r;
  if (uB(r) && (r = r.buffer), r instanceof ArrayBuffer) {
    const n = r;
    return e.text && !e.binary ? new TextDecoder("utf8").decode(n) : n;
  }
  if (ArrayBuffer.isView(r)) {
    if (e.text && !e.binary)
      return new TextDecoder("utf8").decode(r);
    let n = r.buffer;
    const i = r.byteLength || r.length;
    return (r.byteOffset !== 0 || i !== n.byteLength) && (n = n.slice(r.byteOffset, r.byteOffset + i)), n;
  }
  throw new Error(ME);
}
async function rL(r, e, t) {
  const n = r instanceof ArrayBuffer || ArrayBuffer.isView(r);
  if (typeof r == "string" || n)
    return tL(r, e);
  if (Bf(r) && (r = await xE(r)), Rf(r)) {
    const i = r;
    return await vB(i), e.binary ? await i.arrayBuffer() : await i.text();
  }
  if (bE(r) && (r = eL(r, t)), lB(r) || cB(r))
    return W4(r);
  throw new Error(ME);
}
function PE(r, e) {
  const t = TE(), n = r || t;
  return typeof n.fetch == "function" ? n.fetch : Ig(n.fetch) ? (i) => hA(i, n.fetch) : e != null && e.fetch ? e == null ? void 0 : e.fetch : hA;
}
function nL(r, e, t) {
  if (t)
    return t;
  const n = {
    fetch: PE(e, r),
    ...r
  };
  if (n.url) {
    const i = Wv(n.url);
    n.baseUrl = i, n.queryString = _B(n.url), n.filename = yE(i), n.baseUrl = Hv(i);
  }
  return Array.isArray(n.loaders) || (n.loaders = null), n;
}
function iL(r, e) {
  if (r && !Array.isArray(r))
    return r;
  let t;
  if (r && (t = Array.isArray(r) ? r : [r]), e && e.loaders) {
    const n = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
    t = t ? [...t, ...n] : n;
  }
  return t && t.length ? t : void 0;
}
async function __(r, e, t, n) {
  e && !Array.isArray(e) && !Zv(e) && (n = void 0, t = e, e = void 0), r = await r, t = t || {};
  const i = by(r), l = iL(e, n), o = await FB(r, l, t);
  return o ? (t = PB(t, o, l, i), n = nL(
    // @ts-expect-error
    {
      url: i,
      _parse: __,
      loaders: l
    },
    t,
    n || null
  ), await sL(o, r, t, n)) : null;
}
async function sL(r, e, t, n) {
  if (B4(r), t = b4(r.options, t), Rf(e)) {
    const s = e, {
      ok: l,
      redirected: o,
      status: d,
      statusText: m,
      type: b,
      url: T
    } = s, M = Object.fromEntries(s.headers.entries());
    n.response = {
      headers: M,
      ok: l,
      redirected: o,
      status: d,
      statusText: m,
      type: b,
      url: T
    };
  }
  e = await rL(e, r, t);
  const i = r;
  if (i.parseTextSync && typeof e == "string")
    return i.parseTextSync(e, t, n);
  if (F4(r, t))
    return await U4(r, e, t, n, __);
  if (i.parseText && typeof e == "string")
    return await i.parseText(e, t, n);
  if (i.parse)
    return await i.parse(e, t, n);
  throw Uu(!i.parseSync), new Error(`${r.id} loader - no parser found and worker is disabled`);
}
function oL(r) {
  switch (r.constructor) {
    case Int8Array:
      return "int8";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int16Array:
      return "int16";
    case Uint16Array:
      return "uint16";
    case Int32Array:
      return "int32";
    case Uint32Array:
      return "uint32";
    case Float32Array:
      return "float32";
    case Float64Array:
      return "float64";
    default:
      return "null";
  }
}
function RE(r) {
  let e = 1 / 0, t = 1 / 0, n = 1 / 0, i = -1 / 0, s = -1 / 0, l = -1 / 0;
  const o = r.POSITION ? r.POSITION.value : [], d = o && o.length;
  for (let m = 0; m < d; m += 3) {
    const b = o[m], T = o[m + 1], M = o[m + 2];
    e = b < e ? b : e, t = T < t ? T : t, n = M < n ? M : n, i = b > i ? b : i, s = T > s ? T : s, l = M > l ? M : l;
  }
  return [[e, t, n], [i, s, l]];
}
function aL(r, e, t) {
  const n = oL(e.value), i = t || lL(e);
  return {
    name: r,
    type: {
      type: "fixed-size-list",
      listSize: e.size,
      children: [{
        name: "value",
        type: n
      }]
    },
    nullable: !1,
    metadata: i
  };
}
function lL(r) {
  const e = {};
  return "byteOffset" in r && (e.byteOffset = r.byteOffset.toString(10)), "byteStride" in r && (e.byteStride = r.byteStride.toString(10)), "normalized" in r && (e.normalized = r.normalized.toString()), e;
}
async function Ph(r, e, t, n) {
  let i, s;
  !Array.isArray(e) && !Zv(e) ? (i = [], s = e) : (i = e, s = t);
  const l = PE(s);
  let o = r;
  return typeof r == "string" && (o = await l(r)), Bf(r) && (o = await l(r)), Array.isArray(i) ? await __(o, i, s) : await __(o, i, s);
}
const cL = "4.3.2";
var iE;
const uL = (iE = globalThis.loaders) == null ? void 0 : iE.parseImageNode, _1 = typeof Image < "u", y1 = typeof ImageBitmap < "u", hL = !!uL, b1 = yy ? !0 : hL;
function fL(r) {
  switch (r) {
    case "auto":
      return y1 || _1 || b1;
    case "imagebitmap":
      return y1;
    case "image":
      return _1;
    case "data":
      return b1;
    default:
      throw new Error(`@loaders.gl/images: image ${r} not supported in this environment`);
  }
}
function dL() {
  if (y1)
    return "imagebitmap";
  if (_1)
    return "image";
  if (b1)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function pL(r) {
  const e = gL(r);
  if (!e)
    throw new Error("Not an image");
  return e;
}
function BE(r) {
  switch (pL(r)) {
    case "data":
      return r;
    case "image":
    case "imagebitmap":
      const e = document.createElement("canvas"), t = e.getContext("2d");
      if (!t)
        throw new Error("getImageData");
      return e.width = r.width, e.height = r.height, t.drawImage(r, 0, 0), t.getImageData(0, 0, r.width, r.height);
    default:
      throw new Error("getImageData");
  }
}
function gL(r) {
  return typeof ImageBitmap < "u" && r instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && r instanceof Image ? "image" : r && typeof r == "object" && r.data && r.width && r.height ? "data" : null;
}
const mL = /^data:image\/svg\+xml/, _L = /\.svg((\?|#).*)?$/;
function Kv(r) {
  return r && (mL.test(r) || _L.test(r));
}
function yL(r, e) {
  if (Kv(e)) {
    let n = new TextDecoder().decode(r);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (n = unescape(encodeURIComponent(n)));
    } catch (s) {
      throw new Error(s.message);
    }
    return `data:image/svg+xml;base64,${btoa(n)}`;
  }
  return LE(r, e);
}
function LE(r, e) {
  if (Kv(e))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(r)]);
}
async function OE(r, e, t) {
  const n = yL(r, t), i = self.URL || self.webkitURL, s = typeof n != "string" && i.createObjectURL(n);
  try {
    return await bL(s || n, e);
  } finally {
    s && i.revokeObjectURL(s);
  }
}
async function bL(r, e) {
  const t = new Image();
  return t.src = r, e.image && e.image.decode && t.decode ? (await t.decode(), t) : await new Promise((n, i) => {
    try {
      t.onload = () => n(t), t.onerror = (s) => {
        const l = s instanceof Error ? s.message : "error";
        i(new Error(l));
      };
    } catch (s) {
      i(s);
    }
  });
}
const vL = {};
let yA = !0;
async function xL(r, e, t) {
  let n;
  Kv(t) ? n = await OE(r, e, t) : n = LE(r, t);
  const i = e && e.imagebitmap;
  return await wL(n, i);
}
async function wL(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if ((AL(e) || !yA) && (e = null), e)
    try {
      return await createImageBitmap(r, e);
    } catch (t) {
      console.warn(t), yA = !1;
    }
  return await createImageBitmap(r);
}
function AL(r) {
  for (const e in r || vL)
    return !1;
  return !0;
}
function TL(r) {
  return !IL(r, "ftyp", 4) || (r[8] & 96) === 0 ? null : SL(r);
}
function SL(r) {
  switch (EL(r, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return {
        extension: "avif",
        mimeType: "image/avif"
      };
    default:
      return null;
  }
}
function EL(r, e, t) {
  return String.fromCharCode(...r.slice(e, t));
}
function CL(r) {
  return [...r].map((e) => e.charCodeAt(0));
}
function IL(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const n = CL(e);
  for (let i = 0; i < n.length; ++i)
    if (n[i] !== r[i + t])
      return !1;
  return !0;
}
const su = !1, eg = !0;
function Jv(r) {
  const e = Mg(r);
  return PL(e) || LL(e) || RL(e) || BL(e) || ML(e);
}
function ML(r) {
  const e = new Uint8Array(r instanceof DataView ? r.buffer : r), t = TL(e);
  return t ? {
    mimeType: t.mimeType,
    // TODO - decode width and height
    width: 0,
    height: 0
  } : null;
}
function PL(r) {
  const e = Mg(r);
  return e.byteLength >= 24 && e.getUint32(0, su) === 2303741511 ? {
    mimeType: "image/png",
    width: e.getUint32(16, su),
    height: e.getUint32(20, su)
  } : null;
}
function RL(r) {
  const e = Mg(r);
  return e.byteLength >= 10 && e.getUint32(0, su) === 1195984440 ? {
    mimeType: "image/gif",
    width: e.getUint16(6, eg),
    height: e.getUint16(8, eg)
  } : null;
}
function BL(r) {
  const e = Mg(r);
  return e.byteLength >= 14 && e.getUint16(0, su) === 16973 && e.getUint32(2, eg) === e.byteLength ? {
    mimeType: "image/bmp",
    width: e.getUint32(18, eg),
    height: e.getUint32(22, eg)
  } : null;
}
function LL(r) {
  const e = Mg(r);
  if (!(e.byteLength >= 3 && e.getUint16(0, su) === 65496 && e.getUint8(2) === 255))
    return null;
  const {
    tableMarkers: n,
    sofMarkers: i
  } = OL();
  let s = 2;
  for (; s + 9 < e.byteLength; ) {
    const l = e.getUint16(s, su);
    if (i.has(l))
      return {
        mimeType: "image/jpeg",
        height: e.getUint16(s + 5, su),
        // Number of lines
        width: e.getUint16(s + 7, su)
        // Number of pixels per line
      };
    if (!n.has(l))
      return null;
    s += 2, s += e.getUint16(s, su);
  }
  return null;
}
function OL() {
  const r = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let t = 65504; t < 65520; ++t)
    r.add(t);
  return {
    tableMarkers: r,
    sofMarkers: /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])
  };
}
function Mg(r) {
  if (r instanceof DataView)
    return r;
  if (ArrayBuffer.isView(r))
    return new DataView(r.buffer);
  if (r instanceof ArrayBuffer)
    return new DataView(r);
  throw new Error("toDataView");
}
async function NL(r, e) {
  var i;
  const {
    mimeType: t
  } = Jv(r) || {}, n = (i = globalThis.loaders) == null ? void 0 : i.parseImageNode;
  return xi(n), await n(r, t);
}
async function DL(r, e, t) {
  e = e || {};
  const i = (e.image || {}).type || "auto", {
    url: s
  } = t || {}, l = kL(i);
  let o;
  switch (l) {
    case "imagebitmap":
      o = await xL(r, e, s);
      break;
    case "image":
      o = await OE(r, e, s);
      break;
    case "data":
      o = await NL(r);
      break;
    default:
      xi(!1);
  }
  return i === "data" && (o = BE(o)), o;
}
function kL(r) {
  switch (r) {
    case "auto":
    case "data":
      return dL();
    default:
      return fL(r), r;
  }
}
const FL = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], UL = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"], zL = {
  image: {
    type: "auto",
    decode: !0
    // if format is HTML
  }
  // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
}, NE = {
  dataType: null,
  batchType: null,
  id: "image",
  module: "images",
  name: "Images",
  version: cL,
  mimeTypes: UL,
  extensions: FL,
  parse: DL,
  // TODO: byteOffset, byteLength;
  tests: [(r) => !!Jv(new DataView(r))],
  options: zL
}, U0 = {};
function jL(r) {
  if (U0[r] === void 0) {
    const e = yy ? qL(r) : VL(r);
    U0[r] = e;
  }
  return U0[r];
}
function VL(r) {
  var i, s;
  const e = ["image/png", "image/jpeg", "image/gif"], t = ((i = globalThis.loaders) == null ? void 0 : i.imageFormatsNode) || e;
  return !!((s = globalThis.loaders) == null ? void 0 : s.parseImageNode) && t.includes(r);
}
function qL(r) {
  switch (r) {
    case "image/avif":
    // Will fail
    case "image/webp":
      return $L(r);
    default:
      return !0;
  }
}
function $L(r) {
  try {
    return document.createElement("canvas").toDataURL(r).indexOf(`data:${r}`) === 0;
  } catch {
    return !1;
  }
}
const qn = new Zd({
  id: "deck"
}), ah = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
}, z0 = 1, Mp = 2, j0 = 3, V0 = 4, HL = 2, WL = (r) => ({
  /* Layer events */
  "layer.changeFlag": (e, t, n) => {
    r.log(j0, `${e.id} ${t}: `, n[t])();
  },
  "layer.initialize": (e) => {
    r.log(z0, `Initializing ${e}`)();
  },
  "layer.update": (e, t) => {
    if (t) {
      const n = e.getChangeFlags();
      r.log(Mp, `Updating ${e} because: ${Object.keys(n).filter((i) => n[i]).join(", ")}`)();
    } else
      r.log(V0, `${e} does not need update`)();
  },
  "layer.matched": (e, t) => {
    t && r.log(V0, `Matched ${e}, state transfered`)();
  },
  "layer.finalize": (e) => {
    r.log(z0, `Finalizing ${e}`)();
  },
  /* CompositeLayer events */
  "compositeLayer.renderLayers": (e, t, n) => {
    t ? r.log(Mp, `Composite layer rendered new subLayers ${e}`, n)() : r.log(V0, `Composite layer reused subLayers ${e}`, n)();
  },
  /* LayerManager events */
  "layerManager.setLayers": (e, t, n) => {
    t && r.log(Mp, `Updating ${n.length} deck layers`)();
  },
  "layerManager.activateViewport": (e, t) => {
    r.log(j0, "Viewport changed", t)();
  },
  /* AttributeManager events */
  "attributeManager.invalidate": (e, t, n) => {
    r.log(z0, n ? `invalidated attributes ${n} (${t}) for ${e.id}` : `invalidated all attributes for ${e.id}`)();
  },
  "attributeManager.updateStart": (e) => {
    ah.attributeUpdateMessages.length = 0, ah.attributeManagerUpdateStart = Date.now();
  },
  "attributeManager.updateEnd": (e, t) => {
    const n = Math.round(Date.now() - ah.attributeManagerUpdateStart);
    r.groupCollapsed(Mp, `Updated attributes for ${t} instances in ${e.id} in ${n}ms`)();
    for (const i of ah.attributeUpdateMessages)
      r.log(j0, i)();
    r.groupEnd(Mp)();
  },
  /* Attribute events */
  "attribute.updateStart": (e) => {
    ah.attributeUpdateStart = Date.now();
  },
  "attribute.allocate": (e, t) => {
    const n = `${e.id} allocated ${t}`;
    ah.attributeUpdateMessages.push(n);
  },
  "attribute.updateEnd": (e, t) => {
    const n = Math.round(Date.now() - ah.attributeUpdateStart), i = `${e.id} updated ${t} in ${n}ms`;
    ah.attributeUpdateMessages.push(i);
  },
  /* Render events */
  "deckRenderer.renderLayers": (e, t, n) => {
    const {
      pass: i,
      redrawReason: s,
      stats: l
    } = n;
    for (const o of t) {
      const {
        totalCount: d,
        visibleCount: m,
        compositeCount: b,
        pickableCount: T
      } = o, E = d - b - m;
      r.log(HL, `RENDER #${e.renderCount}   ${m} (of ${d} layers) to ${i} because ${s}   (${E} hidden, ${b} composite ${T} pickable)`)(), l && l.get("Redraw Layers").add(m);
    }
  }
});
var XL = {};
let y_ = {};
XL.NODE_ENV !== "production" && (y_ = WL(qn));
function ZL(r) {
  y_ = r;
}
function Vo(r, e, t, n) {
  qn.level > 0 && y_[r] && y_[r].call(null, e, t, n);
}
function YL(r) {
  const e = r[0], t = r[r.length - 1];
  return e === "{" && t === "}" || e === "[" && t === "]";
}
const KL = {
  dataType: null,
  batchType: null,
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: YL,
  parseTextSync: JSON.parse
};
function JL() {
  const r = "9.1.4", e = globalThis.deck && globalThis.deck.VERSION;
  if (e && e !== r)
    throw new Error(`deck.gl - multiple versions detected: ${e} vs ${r}`);
  return e || (qn.log(1, `deck.gl ${r}`)(), globalThis.deck = {
    ...globalThis.deck,
    VERSION: r,
    version: r,
    log: qn,
    // experimental
    _registerLoggers: ZL
  }, NB([
    KL,
    // @ts-expect-error non-standard Loader format
    [NE, {
      imagebitmap: {
        premultiplyAlpha: "none"
      }
    }]
  ])), r;
}
const QL = JL();
function Qv(r, e) {
  if (!r)
    throw new Error(e || "shadertools: assertion failed.");
}
const q0 = {
  number: {
    type: "number",
    validate(r, e) {
      return Number.isFinite(r) && typeof e == "object" && (e.max === void 0 || r <= e.max) && (e.min === void 0 || r >= e.min);
    }
  },
  array: {
    type: "array",
    validate(r, e) {
      return Array.isArray(r) || ArrayBuffer.isView(r);
    }
  }
};
function eO(r) {
  const e = {};
  for (const [t, n] of Object.entries(r))
    e[t] = tO(n);
  return e;
}
function tO(r) {
  let e = bA(r);
  if (e !== "object")
    return {
      value: r,
      ...q0[e],
      type: e
    };
  if (typeof r == "object")
    return r ? r.type !== void 0 ? {
      ...r,
      ...q0[r.type],
      type: r.type
    } : r.value === void 0 ? {
      type: "object",
      value: r
    } : (e = bA(r.value), {
      ...r,
      ...q0[e],
      type: e
    }) : {
      type: "object",
      value: null
    };
  throw new Error("props");
}
function bA(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) ? "array" : typeof r;
}
const rO = (
  /* glsl */
  `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`
), nO = (
  /* glsl */
  `#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`
), iO = {
  vertex: rO,
  fragment: nO
}, vA = /void\s+main\s*\([^)]*\)\s*\{\n?/, xA = /}\n?[^{}]*$/, G0 = [], $m = "__LUMA_INJECT_DECLARATIONS__";
function sO(r) {
  const e = {
    vertex: {},
    fragment: {}
  };
  for (const t in r) {
    let n = r[t];
    const i = oO(t);
    typeof n == "string" && (n = {
      order: 0,
      injection: n
    }), e[i][t] = n;
  }
  return e;
}
function oO(r) {
  const e = r.slice(0, 2);
  switch (e) {
    case "vs":
      return "vertex";
    case "fs":
      return "fragment";
    default:
      throw new Error(e);
  }
}
function b_(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const i = e === "vertex";
  for (const s in t) {
    const l = t[s];
    l.sort((d, m) => d.order - m.order), G0.length = l.length;
    for (let d = 0, m = l.length; d < m; ++d)
      G0[d] = l[d].injection;
    const o = `${G0.join(`
`)}
`;
    switch (s) {
      // declarations are injected before the main function
      case "vs:#decl":
        i && (r = r.replace($m, o));
        break;
      // inject code at the beginning of the main function
      case "vs:#main-start":
        i && (r = r.replace(vA, (d) => d + o));
        break;
      // inject code at the end of main function
      case "vs:#main-end":
        i && (r = r.replace(xA, (d) => o + d));
        break;
      // declarations are injected before the main function
      case "fs:#decl":
        i || (r = r.replace($m, o));
        break;
      // inject code at the beginning of the main function
      case "fs:#main-start":
        i || (r = r.replace(vA, (d) => d + o));
        break;
      // inject code at the end of main function
      case "fs:#main-end":
        i || (r = r.replace(xA, (d) => o + d));
        break;
      default:
        r = r.replace(s, (d) => d + o);
    }
  }
  return r = r.replace($m, ""), n && (r = r.replace(/\}\s*$/, (s) => s + iO[e])), r;
}
function v_(r) {
  r.map((e) => aO(e));
}
function aO(r) {
  if (r.instance)
    return;
  v_(r.dependencies || []);
  const {
    propTypes: e = {},
    deprecations: t = [],
    // defines = {},
    inject: n = {}
  } = r, i = {
    normalizedInjections: sO(n),
    parsedDeprecations: lO(t)
  };
  e && (i.propValidators = eO(e)), r.instance = i;
  let s = {};
  e && (s = Object.entries(e).reduce((l, o) => {
    let [d, m] = o;
    const b = m == null ? void 0 : m.value;
    return b && (l[d] = b), l;
  }, {})), r.defaultUniforms = {
    ...r.defaultUniforms,
    ...s
  };
}
function DE(r, e, t) {
  var n;
  (n = r.deprecations) == null || n.forEach((i) => {
    var s;
    (s = i.regex) != null && s.test(e) && (i.deprecated ? t.deprecated(i.old, i.new)() : t.removed(i.old, i.new)());
  });
}
function lO(r) {
  return r.forEach((e) => {
    switch (e.type) {
      case "function":
        e.regex = new RegExp(`\\b${e.old}\\(`);
        break;
      default:
        e.regex = new RegExp(`${e.type} ${e.old};`);
    }
  }), r;
}
function e2(r) {
  v_(r);
  const e = {}, t = {};
  kE({
    modules: r,
    level: 0,
    moduleMap: e,
    moduleDepth: t
  });
  const n = Object.keys(t).sort((i, s) => t[s] - t[i]).map((i) => e[i]);
  return v_(n), n;
}
function kE(r) {
  const {
    modules: e,
    level: t,
    moduleMap: n,
    moduleDepth: i
  } = r;
  if (t >= 5)
    throw new Error("Possible loop in shader dependency graph");
  for (const s of e)
    n[s.name] = s, (i[s.name] === void 0 || i[s.name] < t) && (i[s.name] = t);
  for (const s of e)
    s.dependencies && kE({
      modules: s.dependencies,
      level: t + 1,
      moduleMap: n,
      moduleDepth: i
    });
}
function cO(r) {
  switch (r == null ? void 0 : r.gpu.toLowerCase()) {
    case "apple":
      return (
        /* glsl */
        `#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "nvidia":
      return (
        /* glsl */
        `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`
      );
    case "intel":
      return (
        /* glsl */
        `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
    case "amd":
      return (
        /* glsl */
        `#define AMD_GPU
`
      );
    default:
      return (
        /* glsl */
        `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`
      );
  }
}
function uO(r, e) {
  var n;
  if (Number(((n = r.match(/^#version[ \t]+(\d+)/m)) == null ? void 0 : n[1]) || 100) !== 300)
    throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
  switch (e) {
    case "vertex":
      return r = wA(r, hO), r;
    case "fragment":
      return r = wA(r, fO), r;
    default:
      throw new Error(e);
  }
}
const FE = [
  // Fix poorly formatted version directive
  [/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`],
  // The individual `texture...()` functions were replaced with `texture()` overloads
  [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("],
  [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]
], hO = [
  ...FE,
  // `attribute` keyword replaced with `in`
  [v1("attribute"), "in $1"],
  // `varying` keyword replaced with `out`
  [v1("varying"), "out $1"]
], fO = [
  ...FE,
  // `varying` keyword replaced with `in`
  [v1("varying"), "in $1"]
];
function wA(r, e) {
  for (const [t, n] of e)
    r = r.replace(t, n);
  return r;
}
function v1(r) {
  return new RegExp(`\\b${r}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
}
function UE(r, e) {
  let t = "";
  for (const n in r) {
    const i = r[n];
    if (t += `void ${i.signature} {
`, i.header && (t += `  ${i.header}`), e[n]) {
      const s = e[n];
      s.sort((l, o) => l.order - o.order);
      for (const l of s)
        t += `  ${l.injection}
`;
    }
    i.footer && (t += `  ${i.footer}`), t += `}
`;
  }
  return t;
}
function zE(r) {
  const e = {
    vertex: {},
    fragment: {}
  };
  for (const t of r) {
    let n, i;
    typeof t != "string" ? (n = t, i = n.hook) : (n = {}, i = t), i = i.trim();
    const [s, l] = i.split(":"), o = i.replace(/\(.+/, ""), d = Object.assign(n, {
      signature: l
    });
    switch (s) {
      case "vs":
        e.vertex[o] = d;
        break;
      case "fs":
        e.fragment[o] = d;
        break;
      default:
        throw new Error(s);
    }
  }
  return e;
}
function dO(r, e) {
  return {
    name: pO(r, e),
    language: "glsl",
    version: gO(r)
  };
}
function pO(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
  const n = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(r);
  return n ? n[1] : e;
}
function gO(r) {
  let e = 100;
  const t = r.match(/[^\s]+/g);
  if (t && t.length >= 2 && t[0] === "#version") {
    const n = parseInt(t[1], 10);
    Number.isFinite(n) && (e = n);
  }
  if (e !== 100 && e !== 300)
    throw new Error(`Invalid GLSL version ${e}`);
  return e;
}
const jE = `

${$m}
`, mO = (
  /* glsl */
  `precision highp float;
`
);
function _O(r) {
  const e = e2(r.modules || []);
  return {
    source: bO(r.platformInfo, {
      ...r,
      source: r.source,
      stage: "vertex",
      modules: e
    }),
    getUniforms: VE(e)
  };
}
function yO(r) {
  const {
    vs: e,
    fs: t
  } = r, n = e2(r.modules || []);
  return {
    vs: AA(r.platformInfo, {
      ...r,
      source: e,
      stage: "vertex",
      modules: n
    }),
    fs: AA(r.platformInfo, {
      ...r,
      // @ts-expect-error
      source: t,
      stage: "fragment",
      modules: n
    }),
    getUniforms: VE(n)
  };
}
function bO(r, e) {
  var U;
  const {
    // id,
    source: t,
    stage: n,
    modules: i,
    // defines = {},
    hookFunctions: s = [],
    inject: l = {},
    log: o
  } = e;
  Qv(typeof t == "string", "shader source must be a string");
  const d = t;
  let m = "";
  const b = zE(s), T = {}, M = {}, E = {};
  for (const q in l) {
    const G = typeof l[q] == "string" ? {
      injection: l[q],
      order: 0
    } : l[q], Y = /^(v|f)s:(#)?([\w-]+)$/.exec(q);
    if (Y) {
      const he = Y[2], X = Y[3];
      he ? X === "decl" ? M[q] = [G] : E[q] = [G] : T[q] = [G];
    } else
      E[q] = [G];
  }
  const D = i;
  for (const q of D) {
    o && DE(q, d, o);
    const G = qE(q, "wgsl");
    m += G;
    const Y = ((U = q.injections) == null ? void 0 : U[n]) || {};
    for (const he in Y) {
      const X = /^(v|f)s:#([\w-]+)$/.exec(he);
      if (X) {
        const ie = X[2] === "decl" ? M : E;
        ie[he] = ie[he] || [], ie[he].push(Y[he]);
      } else
        T[he] = T[he] || [], T[he].push(Y[he]);
    }
  }
  return m += jE, m = b_(m, n, M), m += UE(b[n], T), m += d, m = b_(m, n, E), m;
}
function AA(r, e) {
  var ye;
  const {
    id: t,
    source: n,
    stage: i,
    language: s = "glsl",
    modules: l,
    defines: o = {},
    hookFunctions: d = [],
    inject: m = {},
    prologue: b = !0,
    log: T
  } = e;
  Qv(typeof n == "string", "shader source must be a string");
  const M = s === "glsl" ? dO(n).version : -1, E = r.shaderLanguageVersion, D = M === 100 ? "#version 100" : "#version 300 es", q = n.split(`
`).slice(1).join(`
`), G = {};
  l.forEach((oe) => {
    Object.assign(G, oe.defines);
  }), Object.assign(G, o);
  let Y = "";
  switch (s) {
    case "wgsl":
      break;
    case "glsl":
      Y = b ? `${D}

// ----- PROLOGUE -------------------------
${vO({
        id: t,
        source: n,
        stage: i
      })}
${`#define SHADER_TYPE_${i.toUpperCase()}`}

${cO(r)}
${i === "fragment" ? mO : ""}

// ----- APPLICATION DEFINES -------------------------

${xO(G)}

` : `${D}
`;
      break;
  }
  const he = zE(d), X = {}, J = {}, ie = {};
  for (const oe in m) {
    const Re = typeof m[oe] == "string" ? {
      injection: m[oe],
      order: 0
    } : m[oe], Ne = /^(v|f)s:(#)?([\w-]+)$/.exec(oe);
    if (Ne) {
      const me = Ne[2], _e = Ne[3];
      me ? _e === "decl" ? J[oe] = [Re] : ie[oe] = [Re] : X[oe] = [Re];
    } else
      ie[oe] = [Re];
  }
  for (const oe of l) {
    T && DE(oe, q, T);
    const Re = qE(oe, i);
    Y += Re;
    const Ne = ((ye = oe.instance) == null ? void 0 : ye.normalizedInjections[i]) || {};
    for (const me in Ne) {
      const _e = /^(v|f)s:#([\w-]+)$/.exec(me);
      if (_e) {
        const Me = _e[2] === "decl" ? J : ie;
        Me[me] = Me[me] || [], Me[me].push(Ne[me]);
      } else
        X[me] = X[me] || [], X[me].push(Ne[me]);
    }
  }
  return Y += "// ----- MAIN SHADER SOURCE -------------------------", Y += jE, Y = b_(Y, i, J), Y += UE(he[i], X), Y += q, Y = b_(Y, i, ie), s === "glsl" && M !== E && (Y = uO(Y, i)), Y.trim();
}
function VE(r) {
  return function(t) {
    var i;
    const n = {};
    for (const s of r) {
      const l = (i = s.getUniforms) == null ? void 0 : i.call(s, t, n);
      Object.assign(n, l);
    }
    return n;
  };
}
function vO(r) {
  const {
    id: e,
    source: t,
    stage: n
  } = r;
  return e && t.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME ${e}_${n}` : "";
}
function xO() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = "";
  for (const t in r) {
    const n = r[t];
    (n || Number.isFinite(n)) && (e += `#define ${t.toUpperCase()} ${r[t]}
`);
  }
  return e;
}
function qE(r, e) {
  let t;
  switch (e) {
    case "vertex":
      t = r.vs || "";
      break;
    case "fragment":
      t = r.fs || "";
      break;
    case "wgsl":
      t = r.source || "";
      break;
    default:
      Qv(!1);
  }
  if (!r.name)
    throw new Error("Shader module must have a name");
  const n = r.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
  let i = `// ----- MODULE ${r.name} ---------------

`;
  return e !== "wgsl" && (i += `#define MODULE_${n}
`), i += `${t}
`, i;
}
const wO = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/, AO = /^\s*\#\s*endif\s*$/;
function TO(r, e) {
  var l;
  const t = r.split(`
`), n = [];
  let i = !0, s = null;
  for (const o of t) {
    const d = o.match(wO), m = o.match(AO);
    d ? (s = d[1], i = !!((l = e == null ? void 0 : e.defines) != null && l[s])) : m ? i = !0 : i && n.push(o);
  }
  return n.join(`
`);
}
const lf = class lf {
  constructor() {
    /** Hook functions */
    H(this, "_hookFunctions", []);
    /** Shader modules */
    H(this, "_defaultModules", []);
  }
  /**
   * A default shader assembler instance - the natural place to register default modules and hooks
   * @returns
   */
  static getDefaultShaderAssembler() {
    return lf.defaultShaderAssembler = lf.defaultShaderAssembler || new lf(), lf.defaultShaderAssembler;
  }
  /**
   * Add a default module that does not have to be provided with every call to assembleShaders()
   */
  addDefaultModule(e) {
    this._defaultModules.find((t) => t.name === (typeof e == "string" ? e : e.name)) || this._defaultModules.push(e);
  }
  /**
   * Remove a default module
   */
  removeDefaultModule(e) {
    const t = typeof e == "string" ? e : e.name;
    this._defaultModules = this._defaultModules.filter((n) => n.name !== t);
  }
  /**
   * Register a shader hook
   * @param hook
   * @param opts
   */
  addShaderHook(e, t) {
    t && (e = Object.assign(t, {
      hook: e
    })), this._hookFunctions.push(e);
  }
  /**
   * Assemble a WGSL unified shader
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleWGSLShader(e) {
    const t = this._getModuleList(e.modules), n = this._hookFunctions, {
      source: i,
      getUniforms: s
    } = _O({
      ...e,
      // @ts-expect-error
      source: e.source,
      modules: t,
      hookFunctions: n
    });
    return {
      source: e.platformInfo.shaderLanguage === "wgsl" ? TO(i) : i,
      getUniforms: s,
      modules: t
    };
  }
  /**
   * Assemble a pair of shaders into a single shader program
   * @param platformInfo
   * @param props
   * @returns
   */
  assembleGLSLShaderPair(e) {
    const t = this._getModuleList(e.modules), n = this._hookFunctions;
    return {
      ...yO({
        ...e,
        // @ts-expect-error
        vs: e.vs,
        // @ts-expect-error
        fs: e.fs,
        modules: t,
        hookFunctions: n
      }),
      modules: t
    };
  }
  /**
   * Dedupe and combine with default modules
   */
  _getModuleList() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = new Array(this._defaultModules.length + e.length), n = {};
    let i = 0;
    for (let s = 0, l = this._defaultModules.length; s < l; ++s) {
      const o = this._defaultModules[s], d = o.name;
      t[i++] = o, n[d] = !0;
    }
    for (let s = 0, l = e.length; s < l; ++s) {
      const o = e[s], d = o.name;
      n[d] || (t[i++] = o, n[d] = !0);
    }
    return t.length = i, v_(t), t;
  }
};
/** Default ShaderAssembler instance */
H(lf, "defaultShaderAssembler");
let x_ = lf;
const SO = (
  /* glsl */
  `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`
), EO = `#version 300 es
${SO}`;
function CO(r) {
  const {
    input: e,
    inputChannels: t,
    output: n
  } = {};
  if (!e)
    return EO;
  if (!t)
    throw new Error("inputChannels");
  const i = IO(t), s = MO(e, t);
  return `#version 300 es
in ${i} ${e};
out vec4 ${n};
void main() {
  ${n} = ${s};
}`;
}
function IO(r) {
  switch (r) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`invalid channels: ${r}`);
  }
}
function MO(r, e) {
  switch (e) {
    case 1:
      return `vec4(${r}, 0.0, 0.0, 1.0)`;
    case 2:
      return `vec4(${r}, 0.0, 1.0)`;
    case 3:
      return `vec4(${r}, 1.0)`;
    case 4:
      return r;
    default:
      throw new Error(`invalid channels: ${e}`);
  }
}
class PO {
  constructor() {
    H(this, "stats", /* @__PURE__ */ new Map());
  }
  getStats(e) {
    return this.get(e);
  }
  get(e) {
    return this.stats.has(e) || this.stats.set(e, new Yd({
      id: e
    })), this.stats.get(e);
  }
}
const GE = new PO(), lr = new Zd({
  id: "luma.gl"
}), $0 = {};
function vy() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  $0[r] = $0[r] || 1;
  const e = $0[r]++;
  return `${r}-${e}`;
}
var c1;
let di = (c1 = class {
  /**
   * Create a new Resource. Called from Subclass
   */
  constructor(e, t, n) {
    /** props.id, for debugging. */
    H(this, "id");
    H(this, "props");
    H(this, "userData", {});
    H(this, "_device");
    /** Whether this resource has been destroyed */
    H(this, "destroyed", !1);
    /** For resources that allocate GPU memory */
    H(this, "allocatedBytes", 0);
    /** Attached resources will be destroyed when this resource is destroyed. Tracks auto-created "sub" resources. */
    H(this, "_attachedResources", /* @__PURE__ */ new Set());
    if (!e)
      throw new Error("no device");
    this._device = e, this.props = RO(t, n);
    const i = this.props.id !== "undefined" ? this.props.id : vy(this[Symbol.toStringTag]);
    this.props.id = i, this.id = i, this.userData = this.props.userData || {}, this.addStats();
  }
  toString() {
    return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
  }
  /**
   * destroy can be called on any resource to release it before it is garbage collected.
   */
  destroy() {
    this.destroyResource();
  }
  /** @deprecated Use destroy() */
  delete() {
    return this.destroy(), this;
  }
  /**
   * Combines a map of user props and default props, only including props from defaultProps
   * @returns returns a map of overridden default props
   */
  getProps() {
    return this.props;
  }
  // ATTACHED RESOURCES
  /**
   * Attaches a resource. Attached resources are auto destroyed when this resource is destroyed
   * Called automatically when sub resources are auto created but can be called by application
   */
  attachResource(e) {
    this._attachedResources.add(e);
  }
  /**
   * Detach an attached resource. The resource will no longer be auto-destroyed when this resource is destroyed.
   */
  detachResource(e) {
    this._attachedResources.delete(e);
  }
  /**
   * Destroys a resource (only if owned), and removes from the owned (auto-destroy) list for this resource.
   */
  destroyAttachedResource(e) {
    this._attachedResources.delete(e) && e.destroy();
  }
  /** Destroy all owned resources. Make sure the resources are no longer needed before calling. */
  destroyAttachedResources() {
    for (const e of Object.values(this._attachedResources))
      e.destroy();
    this._attachedResources = /* @__PURE__ */ new Set();
  }
  // PROTECTED METHODS
  /** Perform all destroy steps. Can be called by derived resources when overriding destroy() */
  destroyResource() {
    this.destroyAttachedResources(), this.removeStats(), this.destroyed = !0;
  }
  /** Called by .destroy() to track object destruction. Subclass must call if overriding destroy() */
  removeStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
    e.get(`${t}s Active`).decrementCount();
  }
  /** Called by subclass to track memory allocations */
  trackAllocatedMemory(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
    const n = this._device.statsManager.getStats("Resource Counts");
    n.get("GPU Memory").addCount(e), n.get(`${t} Memory`).addCount(e), this.allocatedBytes = e;
  }
  /** Called by subclass to track memory deallocations */
  trackDeallocatedMemory() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
    const t = this._device.statsManager.getStats("Resource Counts");
    t.get("GPU Memory").subtractCount(this.allocatedBytes), t.get(`${e} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0;
  }
  /** Called by resource constructor to track object creation */
  addStats() {
    const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
    e.get("Resources Created").incrementCount(), e.get(`${t}s Created`).incrementCount(), e.get(`${t}s Active`).incrementCount();
  }
}, /** Default properties for resource */
H(c1, "defaultProps", {
  id: "undefined",
  handle: void 0,
  userData: void 0
}), c1);
function RO(r, e) {
  const t = {
    ...e
  };
  for (const n in r)
    r[n] !== void 0 && (t[n] = r[n]);
  return t;
}
var Ds;
let Ss = (Ds = class extends di {
  constructor(t, n) {
    const i = {
      ...n
    };
    (n.usage || 0) & Ds.INDEX && !n.indexType && (n.data instanceof Uint32Array ? i.indexType = "uint32" : n.data instanceof Uint16Array && (i.indexType = "uint16")), delete i.data;
    super(t, i, Ds.defaultProps);
    /** The usage with which this buffer was created */
    H(this, "usage");
    /** For index buffers, whether indices are 16 or 32 bit */
    H(this, "indexType");
    /** "Time" of last update, can be used to check if redraw is needed */
    H(this, "updateTimestamp");
    /** A partial CPU-side copy of the data in this buffer, for debugging purposes */
    H(this, "debugData", new ArrayBuffer(0));
    this.usage = i.usage || 0, this.indexType = i.indexType, this.updateTimestamp = t.incrementTimestamp();
  }
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  /**
   * Create a copy of this Buffer with new byteLength, with same props but of the specified size.
   * @note Does not copy contents of the cloned Buffer.
   */
  clone(t) {
    return this.device.createBuffer({
      ...this.props,
      ...t
    });
  }
  /** Read data synchronously. @note WebGL2 only */
  readSyncWebGL(t, n) {
    throw new Error("not implemented");
  }
  /** This doesn't handle partial non-zero offset updates correctly */
  _setDebugData(t, n, i) {
    const s = ArrayBuffer.isView(t) ? t.buffer : t, l = Math.min(t ? t.byteLength : i, Ds.DEBUG_DATA_MAX_LENGTH);
    s === null ? this.debugData = new ArrayBuffer(l) : n === 0 && i === s.byteLength ? this.debugData = s.slice(0, l) : this.debugData = s.slice(n, n + l);
  }
}, H(Ds, "defaultProps", {
  ...di.defaultProps,
  usage: 0,
  // Buffer.COPY_DST | Buffer.COPY_SRC
  byteLength: 0,
  byteOffset: 0,
  data: null,
  indexType: "uint16",
  mappedAtCreation: !1
}), // Usage Flags
H(Ds, "MAP_READ", 1), H(Ds, "MAP_WRITE", 2), H(Ds, "COPY_SRC", 4), H(Ds, "COPY_DST", 8), /** Index buffer */
H(Ds, "INDEX", 16), /** Vertex buffer */
H(Ds, "VERTEX", 32), /** Uniform buffer */
H(Ds, "UNIFORM", 64), /** Storage buffer */
H(Ds, "STORAGE", 128), H(Ds, "INDIRECT", 256), H(Ds, "QUERY_RESOLVE", 512), // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)
/** Max amount of debug data saved. Two vec4's */
H(Ds, "DEBUG_DATA_MAX_LENGTH", 32), Ds);
function $E(r) {
  const e = TA[r], t = BO(e), n = r.includes("norm"), i = !n && !r.startsWith("float"), s = r.startsWith("s");
  return {
    dataType: TA[r],
    byteLength: t,
    integer: i,
    signed: s,
    normalized: n
  };
}
function BO(r) {
  return LO[r];
}
const TA = {
  uint8: "uint8",
  sint8: "sint8",
  unorm8: "uint8",
  snorm8: "sint8",
  uint16: "uint16",
  sint16: "sint16",
  unorm16: "uint16",
  snorm16: "sint16",
  float16: "float16",
  float32: "float32",
  uint32: "uint32",
  sint32: "sint32"
}, LO = {
  uint8: 1,
  sint8: 1,
  uint16: 2,
  sint16: 2,
  float16: 2,
  float32: 4,
  uint32: 4,
  sint32: 4
}, No = "texture-compression-bc", fi = "texture-compression-astc", Qc = "texture-compression-etc2", OO = "texture-compression-etc1-webgl", om = "texture-compression-pvrtc-webgl", H0 = "texture-compression-atc-webgl", am = "float32-renderable-webgl", W0 = "float16-renderable-webgl", NO = "rgb9e5ufloat-renderable-webgl", X0 = "snorm8-renderable-webgl", Pp = "norm16-renderable-webgl", Z0 = "snorm16-renderable-webgl", lm = "float32-filterable", SA = "float16-filterable-webgl";
function HE(r) {
  const e = DO[r];
  if (!e)
    throw new Error(`Unsupported texture format ${r}`);
  return e;
}
const DO = {
  // 8-bit formats
  r8unorm: {},
  r8snorm: {
    render: X0
  },
  r8uint: {},
  r8sint: {},
  // 16-bit formats
  rg8unorm: {},
  rg8snorm: {
    render: X0
  },
  rg8uint: {},
  rg8sint: {},
  r16uint: {},
  r16sint: {},
  r16float: {
    render: W0,
    filter: "float16-filterable-webgl"
  },
  "r16unorm-webgl": {
    f: Pp
  },
  "r16snorm-webgl": {
    f: Z0
  },
  // Packed 16-bit formats
  "rgba4unorm-webgl": {
    channels: "rgba",
    bitsPerChannel: [4, 4, 4, 4],
    packed: !0
  },
  "rgb565unorm-webgl": {
    channels: "rgb",
    bitsPerChannel: [5, 6, 5, 0],
    packed: !0
  },
  "rgb5a1unorm-webgl": {
    channels: "rgba",
    bitsPerChannel: [5, 5, 5, 1],
    packed: !0
  },
  // 24-bit formats
  "rgb8unorm-webgl": {},
  "rgb8snorm-webgl": {},
  // 32-bit formats  
  rgba8unorm: {},
  "rgba8unorm-srgb": {},
  rgba8snorm: {
    render: X0
  },
  rgba8uint: {},
  rgba8sint: {},
  // 32-bit, reverse colors, webgpu only
  bgra8unorm: {},
  "bgra8unorm-srgb": {},
  rg16uint: {},
  rg16sint: {},
  rg16float: {
    render: W0,
    filter: SA
  },
  "rg16unorm-webgl": {
    render: Pp
  },
  "rg16snorm-webgl": {
    render: Z0
  },
  r32uint: {},
  r32sint: {},
  r32float: {
    render: am,
    filter: lm
  },
  // Packed 32 bit formats
  rgb9e5ufloat: {
    channels: "rgb",
    packed: !0,
    render: NO
  },
  // , filter: true},
  rg11b10ufloat: {
    channels: "rgb",
    bitsPerChannel: [11, 11, 10, 0],
    packed: !0,
    p: 1,
    render: am
  },
  rgb10a2unorm: {
    channels: "rgba",
    bitsPerChannel: [10, 10, 10, 2],
    packed: !0,
    p: 1
  },
  "rgb10a2uint-webgl": {
    channels: "rgba",
    bitsPerChannel: [10, 10, 10, 2],
    packed: !0,
    p: 1,
    wgpu: !1
  },
  // 48-bit formats
  "rgb16unorm-webgl": {
    f: Pp
  },
  // rgb not renderable
  "rgb16snorm-webgl": {
    f: Pp
  },
  // rgb not renderable
  // 64-bit formats
  rg32uint: {},
  rg32sint: {},
  rg32float: {
    render: !1,
    filter: lm
  },
  rgba16uint: {},
  rgba16sint: {},
  rgba16float: {
    render: W0,
    filter: SA
  },
  "rgba16unorm-webgl": {
    render: Pp
  },
  "rgba16snorm-webgl": {
    render: Z0
  },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": {
    render: am,
    filter: lm
  },
  // 128-bit formats
  rgba32uint: {},
  rgba32sint: {},
  rgba32float: {
    render: am,
    filter: lm
  },
  // Depth/stencil
  // Depth and stencil formats
  stencil8: {
    attachment: "stencil",
    bitsPerChannel: [8, 0, 0, 0],
    dataType: "uint8"
  },
  depth16unorm: {
    attachment: "depth",
    bitsPerChannel: [16, 0, 0, 0],
    dataType: "uint16"
  },
  depth24plus: {
    attachment: "depth",
    bitsPerChannel: [24, 0, 0, 0],
    dataType: "uint32"
  },
  depth32float: {
    attachment: "depth",
    bitsPerChannel: [32, 0, 0, 0],
    dataType: "float32"
  },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": {
    attachment: "depth-stencil",
    bitsPerChannel: [24, 8, 0, 0],
    packed: !0
  },
  // "depth32float-stencil8" feature
  "depth32float-stencil8": {
    attachment: "depth-stencil",
    bitsPerChannel: [32, 8, 0, 0],
    packed: !0
  },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": {
    f: No
  },
  "bc1-rgb-unorm-srgb-webgl": {
    f: No
  },
  "bc1-rgba-unorm": {
    f: No
  },
  "bc1-rgba-unorm-srgb": {
    f: No
  },
  "bc2-rgba-unorm": {
    f: No
  },
  "bc2-rgba-unorm-srgb": {
    f: No
  },
  "bc3-rgba-unorm": {
    f: No
  },
  "bc3-rgba-unorm-srgb": {
    f: No
  },
  "bc4-r-unorm": {
    f: No
  },
  "bc4-r-snorm": {
    f: No
  },
  "bc5-rg-unorm": {
    f: No
  },
  "bc5-rg-snorm": {
    f: No
  },
  "bc6h-rgb-ufloat": {
    f: No
  },
  "bc6h-rgb-float": {
    f: No
  },
  "bc7-rgba-unorm": {
    f: No
  },
  "bc7-rgba-unorm-srgb": {
    f: No
  },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": {
    f: Qc
  },
  "etc2-rgb8unorm-srgb": {
    f: Qc
  },
  "etc2-rgb8a1unorm": {
    f: Qc
  },
  "etc2-rgb8a1unorm-srgb": {
    f: Qc
  },
  "etc2-rgba8unorm": {
    f: Qc
  },
  "etc2-rgba8unorm-srgb": {
    f: Qc
  },
  "eac-r11unorm": {
    f: Qc
  },
  "eac-r11snorm": {
    f: Qc
  },
  "eac-rg11unorm": {
    f: Qc
  },
  "eac-rg11snorm": {
    f: Qc
  },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": {
    f: fi
  },
  "astc-4x4-unorm-srgb": {
    f: fi
  },
  "astc-5x4-unorm": {
    f: fi
  },
  "astc-5x4-unorm-srgb": {
    f: fi
  },
  "astc-5x5-unorm": {
    f: fi
  },
  "astc-5x5-unorm-srgb": {
    f: fi
  },
  "astc-6x5-unorm": {
    f: fi
  },
  "astc-6x5-unorm-srgb": {
    f: fi
  },
  "astc-6x6-unorm": {
    f: fi
  },
  "astc-6x6-unorm-srgb": {
    f: fi
  },
  "astc-8x5-unorm": {
    f: fi
  },
  "astc-8x5-unorm-srgb": {
    f: fi
  },
  "astc-8x6-unorm": {
    f: fi
  },
  "astc-8x6-unorm-srgb": {
    f: fi
  },
  "astc-8x8-unorm": {
    f: fi
  },
  "astc-8x8-unorm-srgb": {
    f: fi
  },
  "astc-10x5-unorm": {
    f: fi
  },
  "astc-10x5-unorm-srgb": {
    f: fi
  },
  "astc-10x6-unorm": {
    f: fi
  },
  "astc-10x6-unorm-srgb": {
    f: fi
  },
  "astc-10x8-unorm": {
    f: fi
  },
  "astc-10x8-unorm-srgb": {
    f: fi
  },
  "astc-10x10-unorm": {
    f: fi
  },
  "astc-10x10-unorm-srgb": {
    f: fi
  },
  "astc-12x10-unorm": {
    f: fi
  },
  "astc-12x10-unorm-srgb": {
    f: fi
  },
  "astc-12x12-unorm": {
    f: fi
  },
  "astc-12x12-unorm-srgb": {
    f: fi
  },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": {
    f: om
  },
  "pvrtc-rgba4unorm-webgl": {
    f: om
  },
  "pvrtc-rbg2unorm-webgl": {
    f: om
  },
  "pvrtc-rgba2unorm-webgl": {
    f: om
  },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": {
    f: OO
  },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": {
    f: H0
  },
  "atc-rgba-unorm-webgl": {
    f: H0
  },
  "atc-rgbai-unorm-webgl": {
    f: H0
  }
}, kO = ["bc1", "bc2", "bc3", "bc4", "bc5", "bc6", "bc7", "etc1", "etc2", "eac", "atc", "astc", "pvrtc"], FO = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
function WE(r) {
  return kO.some((e) => r.startsWith(e));
}
function t2(r) {
  let e = UO(r);
  if (WE(r)) {
    e.channels = "rgb", e.components = 3, e.bytesPerPixel = 1, e.srgb = !1, e.compressed = !0;
    const n = zO(r);
    n && (e.blockWidth = n.blockWidth, e.blockHeight = n.blockHeight);
  }
  const t = FO.exec(r);
  if (t) {
    const [, n, i, s, l, o] = t, d = `${s}${i}`, m = $E(d), b = m.byteLength * 8, T = n.length, M = [b, T >= 2 ? b : 0, T >= 3 ? b : 0, T >= 4 ? b : 0];
    e = {
      format: r,
      attachment: e.attachment,
      dataType: m.dataType,
      components: T,
      channels: n,
      integer: m.integer,
      signed: m.signed,
      normalized: m.normalized,
      bitsPerChannel: M,
      bytesPerPixel: m.byteLength * n.length,
      packed: e.packed,
      srgb: e.srgb
    }, o === "-webgl" && (e.webgl = !0), l === "-srgb" && (e.srgb = !0);
  }
  return r.endsWith("-webgl") && (e.webgl = !0), r.endsWith("-srgb") && (e.srgb = !0), e;
}
function UO(r) {
  var s;
  const e = HE(r), t = e.bytesPerPixel || 1, n = e.bitsPerChannel || [8, 8, 8, 8];
  return delete e.bitsPerChannel, delete e.bytesPerPixel, delete e.f, delete e.render, delete e.filter, delete e.blend, delete e.store, {
    ...e,
    format: r,
    attachment: e.attachment || "color",
    channels: e.channels || "r",
    components: e.components || ((s = e.channels) == null ? void 0 : s.length) || 1,
    bytesPerPixel: t,
    bitsPerChannel: n,
    dataType: e.dataType || "uint8",
    srgb: e.srgb ?? !1,
    packed: e.packed ?? !1,
    webgl: e.webgl ?? !1,
    integer: e.integer ?? !1,
    signed: e.signed ?? !1,
    normalized: e.normalized ?? !1,
    compressed: e.compressed ?? !1
  };
}
function zO(r) {
  const t = /.*-(\d+)x(\d+)-.*/.exec(r);
  if (t) {
    const [, n, i] = t;
    return {
      blockWidth: Number(n),
      blockHeight: Number(i)
    };
  }
  return null;
}
function jO(r) {
  const e = HE(r), t = {
    format: r,
    create: e.f ?? !0,
    render: e.render ?? !0,
    filter: e.filter ?? !0,
    blend: e.blend ?? !0,
    store: e.store ?? !0
  }, n = t2(r), i = r.startsWith("depth") || r.startsWith("stencil"), s = n == null ? void 0 : n.signed, l = n == null ? void 0 : n.integer, o = n == null ? void 0 : n.webgl;
  return t.render && (t.render = !s), t.filter && (t.filter = !i && !s && !l && !o), t;
}
class VO {
}
class qO {
  constructor() {
    H(this, "features");
    H(this, "disabledFeatures");
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 ? arguments[1] : void 0;
    this.features = new Set(e), this.disabledFeatures = t || {};
  }
  *[Symbol.iterator]() {
    yield* this.features;
  }
  has(e) {
    var t;
    return !((t = this.disabledFeatures) != null && t[e]) && this.features.has(e);
  }
}
const ty = class ty {
  constructor(e) {
    /** id of this device, primarily for debugging */
    H(this, "id");
    /** A copy of the device props  */
    H(this, "props");
    /** Available for the application to store data on the device */
    H(this, "userData", {});
    /** stats */
    H(this, "statsManager", GE);
    /** An abstract timestamp used for change tracking */
    H(this, "timestamp", 0);
    /** True if this device has been reused during device creation (app has multiple references) */
    H(this, "_reused", !1);
    /** Used by other luma.gl modules to store data on the device */
    H(this, "_lumaData", {});
    this.props = {
      ...ty.defaultProps,
      ...e
    }, this.id = this.props.id || vy(this[Symbol.toStringTag].toLowerCase());
  }
  get [Symbol.toStringTag]() {
    return "Device";
  }
  /** Determines what operations are supported on a texture format, checking against supported device features */
  getTextureFormatCapabilities(e) {
    const t = jO(e), n = (l) => (typeof l == "string" ? this.features.has(l) : l) ?? !0, i = n(t.create), s = {
      format: e,
      create: i,
      render: i && n(t.render),
      filter: i && n(t.filter),
      blend: i && n(t.blend),
      store: i && n(t.store)
    };
    return this._getDeviceSpecificTextureFormatCapabilities(s);
  }
  /** Check if device supports a specific texture format (creation and `nearest` sampling) */
  isTextureFormatSupported(e, t) {
    return this.getTextureFormatCapabilities(e).create;
  }
  /** Check if linear filtering (sampler interpolation) is supported for a specific texture format */
  isTextureFormatFilterable(e) {
    return this.getTextureFormatCapabilities(e).filter;
  }
  /** Check if device supports rendering to a framebuffer color attachment of a specific texture format */
  isTextureFormatRenderable(e) {
    return this.getTextureFormatCapabilities(e).render;
  }
  /** Check if a specific texture format is GPU compressed */
  isTextureFormatCompressed(e) {
    return WE(e);
  }
  /**
   * Trigger device loss.
   * @returns `true` if context loss could actually be triggered.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    return !1;
  }
  /** Report error (normally called for unhandled device errors) */
  reportError(e) {
    this.props.onError(e);
  }
  /** Returns the default / primary canvas context. Throws an error if no canvas context is available (a WebGPU compute device) */
  getDefaultCanvasContext() {
    if (!this.canvasContext)
      throw new Error("Device has no default CanvasContext. See props.createCanvasContext");
    return this.canvasContext;
  }
  createCommandEncoder() {
    throw new Error("not implemented");
  }
  /** A monotonic counter for tracking buffer and texture updates */
  incrementTimestamp() {
    return this.timestamp++;
  }
  // Error Handling
  /** Report unhandled device errors */
  onError(e) {
    this.props.onError(e);
  }
  // DEPRECATED METHODS
  /** @deprecated Use getDefaultCanvasContext() */
  getCanvasContext() {
    return this.getDefaultCanvasContext();
  }
  // WebGL specific HACKS - enables app to remove webgl import
  // Use until we have a better way to handle these
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToArrayWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use command encoder */
  readPixelsToBufferWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  setParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  getParametersWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use WebGPU parameters (pipeline) */
  withParametersWebGL(e, t) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use clear arguments in RenderPass */
  clearWebGL(e) {
    throw new Error("not implemented");
  }
  /** @deprecated - will be removed - should use for debugging only */
  resetWebGL() {
    throw new Error("not implemented");
  }
  // IMPLEMENTATION
  /** Helper to get the canvas context props */
  static _getCanvasContextProps(e) {
    return e.createCanvasContext === !0 ? {} : e.createCanvasContext;
  }
  /** Subclasses use this to support .createBuffer() overloads */
  _normalizeBufferProps(e) {
    (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) && (e = {
      data: e
    });
    const t = {
      ...e
    };
    return (e.usage || 0) & Ss.INDEX && !e.indexType && (e.data instanceof Uint32Array ? t.indexType = "uint32" : e.data instanceof Uint16Array ? t.indexType = "uint16" : lr.warn("indices buffer content must be of integer type")()), t;
  }
};
H(ty, "defaultProps", {
  id: null,
  powerPreference: "high-performance",
  failIfMajorPerformanceCaveat: !1,
  createCanvasContext: void 0,
  // Callbacks
  onError: (e) => lr.error(e.message)(),
  // Experimental
  _reuseDevices: !1,
  _requestMaxLimits: !0,
  _factoryDestroyPolicy: "unused",
  // TODO - Change these after confirming things work as expected
  _initializeFeatures: !0,
  _disabledFeatures: {
    "compilation-status-async-webgl": !0
  },
  _resourceDefaults: {},
  // WebGL specific
  webgl: {},
  debug: lr.get("debug") || void 0,
  debugShaders: lr.get("debug-shaders") || void 0,
  debugFramebuffers: !!lr.get("debug-framebuffers"),
  debugWebGL: !!lr.get("debug-webgl"),
  debugSpectorJS: void 0,
  // Note: log setting is queried by the spector.js code
  debugSpectorJSUrl: void 0,
  // INTERNAL
  _handle: void 0
});
let Eh = ty;
const GO = Pf() && typeof document < "u", $O = () => GO && document.readyState === "complete", HO = "set luma.log.level=1 (or higher) to trace rendering", EA = "No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.", vh = class vh {
  constructor() {
    /** Global stats for all devices */
    H(this, "stats", GE);
    /**
     * Global log
     *
     * Assign luma.log.level in console to control logging: \
     * 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
     * luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;
     */
    H(this, "log", lr);
    /** Version of luma.gl */
    H(this, "VERSION", // Version detection using build plugin
    // @ts-expect-error no-undef
    "9.1.4");
    H(this, "spector");
    H(this, "preregisteredAdapters", /* @__PURE__ */ new Map());
    if (globalThis.luma) {
      if (globalThis.luma.VERSION !== this.VERSION)
        throw lr.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)(), lr.error("'yarn why @luma.gl/core' can help identify the source of the conflict")(), new Error("luma.gl - multiple versions detected: see console log");
      lr.error("This version of luma.gl has already been initialized")();
    }
    lr.log(1, `${this.VERSION} - ${HO}`)(), globalThis.luma = this;
  }
  registerAdapters(e) {
    for (const t of e)
      this.preregisteredAdapters.set(t.type, t);
  }
  /** Get type strings for supported Devices */
  getSupportedAdapters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this.getAdapterMap(e);
    return Array.from(t).map((n) => {
      let [, i] = n;
      return i;
    }).filter((n) => {
      var i;
      return (i = n.isSupported) == null ? void 0 : i.call(n);
    }).map((n) => n.type);
  }
  /** Get type strings for best available Device */
  getBestAvailableAdapter() {
    var n, i, s, l;
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this.getAdapterMap(e);
    return (i = (n = t.get("webgpu")) == null ? void 0 : n.isSupported) != null && i.call(n) ? "webgpu" : (l = (s = t.get("webgl")) == null ? void 0 : s.isSupported) != null && l.call(s) ? "webgl" : null;
  }
  setDefaultDeviceProps(e) {
    Object.assign(vh.defaultProps, e);
  }
  /** Creates a device. Asynchronously. */
  async createDevice() {
    var o;
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e = {
      ...vh.defaultProps,
      ...e
    }, e.waitForPageLoad && await vh.pageLoaded;
    const t = this.getAdapterMap(e.adapters);
    let n = e.type || "";
    n === "best-available" && (n = this.getBestAvailableAdapter(e.adapters) || n);
    const s = (this.getAdapterMap(e.adapters) || t).get(n), l = await ((o = s == null ? void 0 : s.create) == null ? void 0 : o.call(s, e));
    if (l)
      return l;
    throw new Error(EA);
  }
  /** Attach to an existing GPU API handle (WebGL2RenderingContext or GPUDevice). */
  async attachDevice(e) {
    var l;
    const t = this.getAdapterMap(e.adapters);
    let n = "";
    e.handle instanceof WebGL2RenderingContext && (n = "webgl"), e.createCanvasContext && await vh.pageLoaded, e.handle === null && (n = "unknown");
    const i = t.get(n), s = await ((l = i == null ? void 0 : i.attach) == null ? void 0 : l.call(i, null));
    if (s)
      return s;
    throw new Error(EA);
  }
  /**
   * Override `HTMLCanvasContext.getCanvas()` to always create WebGL2 contexts with additional WebGL1 compatibility.
   * Useful when attaching luma to a context from an external library does not support creating WebGL2 contexts.
   */
  enforceWebGL2() {
    var s;
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const i = this.getAdapterMap(t).get("webgl");
    i || lr.warn("enforceWebGL2: webgl adapter not found")(), (s = i == null ? void 0 : i.enforceWebGL2) == null || s.call(i, e);
  }
  /** Convert a list of adapters to a map */
  getAdapterMap() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = new Map(this.preregisteredAdapters);
    for (const n of e)
      t.set(n.type, n);
    return t;
  }
  // DEPRECATED
  /** @deprecated Use registerAdapters */
  registerDevices(e) {
    lr.warn("luma.registerDevices() is deprecated, use luma.registerAdapters() instead");
    for (const t of e) {
      const n = t.adapter;
      n && this.preregisteredAdapters.set(n.type, n);
    }
  }
};
H(vh, "defaultProps", {
  ...Eh.defaultProps,
  type: "best-available",
  adapters: void 0,
  waitForPageLoad: !0
}), /**
 * Page load promise
 * Get a 'lazy' promise that resolves when the DOM is loaded.
 * @note Since there may be limitations on number of `load` event listeners,
 * it is recommended avoid calling this function until actually needed.
 * I.e. don't call it until you know that you will be looking up a string in the DOM.
 */
H(vh, "pageLoaded", WO().then(() => {
  lr.probe(2, "DOM is loaded")();
}));
let x1 = vh;
const w1 = new x1();
function WO() {
  return $O() || typeof window > "u" ? Promise.resolve() : new Promise((r) => {
    window.addEventListener("load", () => r());
  });
}
class XO {
}
const ry = class ry {
  constructor(e) {
    H(this, "id");
    H(this, "props");
    H(this, "canvas");
    H(this, "htmlCanvas");
    H(this, "offscreenCanvas");
    H(this, "type");
    H(this, "width", 1);
    H(this, "height", 1);
    H(this, "resizeObserver");
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    H(this, "_canvasSizeInfo", {
      clientWidth: 0,
      clientHeight: 0,
      devicePixelRatio: 1
    });
    if (this.props = {
      ...ry.defaultProps,
      ...e
    }, e = this.props, !Pf()) {
      this.id = "node-canvas-context", this.type = "node", this.width = this.props.width, this.height = this.props.height, this.canvas = null;
      return;
    }
    if (e.canvas)
      typeof e.canvas == "string" ? this.canvas = YO(e.canvas) : this.canvas = e.canvas;
    else {
      const t = KO(e), n = ZO((e == null ? void 0 : e.container) || null);
      n.insertBefore(t, n.firstChild), this.canvas = t, e != null && e.visible || (this.canvas.style.visibility = "hidden");
    }
    this.canvas instanceof HTMLCanvasElement ? (this.id = this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : (this.id = "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas), this.canvas instanceof HTMLCanvasElement && e.autoResize && (this.resizeObserver = new ResizeObserver((t) => {
      for (const n of t)
        n.target === this.canvas && this.update();
    }), this.resizeObserver.observe(this.canvas));
  }
  toString() {
    return `${this[Symbol.toStringTag]}(${this.id})`;
  }
  /**
   * Returns the current DPR, if props.useDevicePixels is true
   * Device refers to physical
   */
  getDevicePixelRatio(e) {
    return typeof OffscreenCanvas < "u" && this.canvas instanceof OffscreenCanvas || (e = e === void 0 ? this.props.useDevicePixels : e, !e || e <= 0) ? 1 : e === !0 ? typeof window < "u" && window.devicePixelRatio || 1 : e;
  }
  /**
   * Returns the size of drawing buffer in device pixels.
   * @note This can be different from the 'CSS' size of a canvas, and also from the
   * canvas' internal drawing buffer size (.width, .height).
   * This is the size required to cover the canvas, adjusted for DPR
   */
  getPixelSize() {
    switch (this.type) {
      case "node":
        return [this.width, this.height];
      case "offscreen-canvas":
        return [this.canvas.width, this.canvas.height];
      case "html-canvas":
        const e = this.getDevicePixelRatio(), t = this.canvas;
        return t.parentElement ? [t.clientWidth * e, t.clientHeight * e] : [this.canvas.width, this.canvas.height];
      default:
        throw new Error(this.type);
    }
  }
  getAspect() {
    const [e, t] = this.getPixelSize();
    return e / t;
  }
  /**
   * Returns multiplier need to convert CSS size to Device size
   */
  cssToDeviceRatio() {
    var e;
    try {
      const [t] = this.getDrawingBufferSize(), n = this._canvasSizeInfo.clientWidth || ((e = this.htmlCanvas) == null ? void 0 : e.clientWidth);
      return n ? t / n : 1;
    } catch {
      return 1;
    }
  }
  /**
   * Maps CSS pixel position to device pixel position
   */
  cssToDevicePixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const n = this.cssToDeviceRatio(), [i, s] = this.getDrawingBufferSize();
    return JO(e, n, i, s, t);
  }
  /**
   * Use devicePixelRatio to set canvas width and height
   * @note this is a raw port of luma.gl v8 code. Might be worth a review
   */
  setDevicePixelRatio(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.htmlCanvas)
      return;
    let n = "width" in t ? t.width : this.htmlCanvas.clientWidth, i = "height" in t ? t.height : this.htmlCanvas.clientHeight;
    (!n || !i) && (lr.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, n = this.htmlCanvas.width || 1, i = this.htmlCanvas.height || 1);
    const s = this._canvasSizeInfo;
    if (s.clientWidth !== n || s.clientHeight !== i || s.devicePixelRatio !== e) {
      let l = e;
      const o = Math.floor(n * l), d = Math.floor(i * l);
      if (this.htmlCanvas.width = o, this.htmlCanvas.height = d, this.device.gl) {
        const [b, T] = this.getDrawingBufferSize();
        (b !== o || T !== d) && (l = Math.min(b / n, T / i), this.htmlCanvas.width = Math.floor(n * l), this.htmlCanvas.height = Math.floor(i * l), lr.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = n, this._canvasSizeInfo.clientHeight = i, this._canvasSizeInfo.devicePixelRatio = e;
      }
    }
  }
  // PRIVATE
  /** @todo Major hack done to port the CSS methods above, base canvas context should not depend on WebGL */
  getDrawingBufferSize() {
    const e = this.device.gl;
    return e ? [e.drawingBufferWidth, e.drawingBufferHeight] : this.getPixelSize();
  }
  /**
   * Allows subclass constructor to override the canvas id for auto created canvases.
   * This can really help when debugging DOM in apps that create multiple devices
   */
  _setAutoCreatedCanvasId(e) {
    var t;
    ((t = this.htmlCanvas) == null ? void 0 : t.id) === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = e);
  }
};
H(ry, "defaultProps", {
  canvas: null,
  width: 800,
  // width are height are only used by headless gl
  height: 600,
  useDevicePixels: !0,
  autoResize: !0,
  container: null,
  visible: !0,
  alphaMode: "opaque",
  colorSpace: "srgb"
});
let A1 = ry;
function ZO(r) {
  if (typeof r == "string") {
    const e = document.getElementById(r);
    if (!e)
      throw new Error(`${r} is not an HTML element`);
    return e;
  } else if (r)
    return r;
  return document.body;
}
function YO(r) {
  const e = document.getElementById(r);
  if (!(e instanceof HTMLCanvasElement))
    throw new Error("Object is not a canvas element");
  return e;
}
function KO(r) {
  const {
    width: e,
    height: t
  } = r, n = document.createElement("canvas");
  return n.id = vy("lumagl-auto-created-canvas"), n.width = e || 1, n.height = t || 1, n.style.width = Number.isFinite(e) ? `${e}px` : "100%", n.style.height = Number.isFinite(t) ? `${t}px` : "100%", n;
}
function JO(r, e, t, n, i) {
  const s = r, l = CA(s[0], e, t);
  let o = IA(s[1], e, n, i), d = CA(s[0] + 1, e, t);
  const m = d === t - 1 ? d : d - 1;
  d = IA(s[1] + 1, e, n, i);
  let b;
  return i ? (d = d === 0 ? d : d + 1, b = o, o = d) : b = d === n - 1 ? d : d - 1, {
    x: l,
    y: o,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(m - l + 1, 1),
    height: Math.max(b - o + 1, 1)
  };
}
function CA(r, e, t) {
  return Math.min(Math.round(r * e), t - 1);
}
function IA(r, e, t, n) {
  return n ? Math.max(0, t - 1 - Math.round(r * e)) : Math.min(Math.round(r * e), t - 1);
}
const xo = class xo extends di {
  /** Do not use directly. Create with device.createTexture() */
  constructor(t, n) {
    n = xo.normalizeProps(t, n);
    super(t, n, xo.defaultProps);
    /** dimension of this texture */
    H(this, "dimension");
    /** format of this texture */
    H(this, "format");
    /** width in pixels of this texture */
    H(this, "width");
    /** height in pixels of this texture */
    H(this, "height");
    /** depth of this texture */
    H(this, "depth");
    /** mip levels in this texture */
    H(this, "mipLevels");
    /** "Time" of last update. Monotonically increasing timestamp. TODO move to AsyncTexture? */
    H(this, "updateTimestamp");
    if (this.dimension = this.props.dimension, this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.props.width === void 0 || this.props.height === void 0) {
      const i = xo.getTextureDataSize(this.props.data);
      this.width = (i == null ? void 0 : i.width) || 1, this.height = (i == null ? void 0 : i.height) || 1;
    }
    this.props.mipmaps && this.props.mipLevels === void 0 && (this.props.mipLevels = "pyramid"), this.mipLevels = this.props.mipLevels === "pyramid" ? xo.getMipLevelCount(this.width, this.height) : this.props.mipLevels || 1, this.updateTimestamp = t.incrementTimestamp();
  }
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  toString() {
    return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
  }
  /**
   * Create a new texture with the same parameters and optionally, a different size
   * @note Textures are immutable and cannot be resized after creation, but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   */
  clone(t) {
    return this.device.createTexture({
      ...this.props,
      ...t
    });
  }
  /** Check if data is an external image */
  static isExternalImage(t) {
    return typeof ImageData < "u" && t instanceof ImageData || typeof ImageBitmap < "u" && t instanceof ImageBitmap || typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement || typeof VideoFrame < "u" && t instanceof VideoFrame || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas;
  }
  /** Determine size (width and height) of provided image data */
  static getExternalImageSize(t) {
    if (typeof ImageData < "u" && t instanceof ImageData || typeof ImageBitmap < "u" && t instanceof ImageBitmap || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && t instanceof OffscreenCanvas)
      return {
        width: t.width,
        height: t.height
      };
    if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement)
      return {
        width: t.naturalWidth,
        height: t.naturalHeight
      };
    if (typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement)
      return {
        width: t.videoWidth,
        height: t.videoHeight
      };
    if (typeof VideoFrame < "u" && t instanceof VideoFrame)
      return {
        width: t.displayWidth,
        height: t.displayHeight
      };
    throw new Error("Unknown image type");
  }
  /** Check if texture data is a typed array */
  static isTextureLevelData(t) {
    const n = t == null ? void 0 : t.data;
    return ArrayBuffer.isView(n);
  }
  /** Get the size of the texture described by the provided TextureData */
  static getTextureDataSize(t) {
    if (!t || ArrayBuffer.isView(t))
      return null;
    if (Array.isArray(t))
      return xo.getTextureDataSize(t[0]);
    if (xo.isExternalImage(t))
      return xo.getExternalImageSize(t);
    if (t && typeof t == "object" && t.constructor === Object) {
      const i = Object.values(t)[0];
      return {
        width: i.width,
        height: i.height
      };
    }
    throw new Error("texture size deduction failed");
  }
  /**
   * Normalize TextureData to an array of TextureLevelData / ExternalImages
   * @param data
   * @param options
   * @returns array of TextureLevelData / ExternalImages
   */
  static normalizeTextureData(t, n) {
    let i;
    return ArrayBuffer.isView(t) ? i = [{
      // ts-expect-error does data really need to be Uint8ClampedArray?
      data: t,
      width: n.width,
      height: n.height
      // depth: options.depth
    }] : Array.isArray(t) ? i = t : i = [t], i;
  }
  /** Calculate the number of mip levels for a texture of width and height */
  static getMipLevelCount(t, n) {
    return Math.floor(Math.log2(Math.max(t, n))) + 1;
  }
  /** Convert luma.gl cubemap face constants to depth index */
  static getCubeFaceDepth(t) {
    switch (t) {
      case "+X":
        return 0;
      case "-X":
        return 1;
      case "+Y":
        return 2;
      case "-Y":
        return 3;
      case "+Z":
        return 4;
      case "-Z":
        return 5;
      default:
        throw new Error(t);
    }
  }
  /** Ensure we have integer coordinates */
  static normalizeProps(t, n) {
    var d, m;
    const i = {
      ...n
    }, s = ((m = (d = t == null ? void 0 : t.props) == null ? void 0 : d._resourceDefaults) == null ? void 0 : m.texture) || {};
    Object.assign(i, s);
    const {
      width: l,
      height: o
    } = i;
    return typeof l == "number" && (i.width = Math.max(1, Math.ceil(l))), typeof o == "number" && (i.height = Math.max(1, Math.ceil(o))), i;
  }
};
H(xo, "COPY_SRC", 1), H(xo, "COPY_DST", 2), H(xo, "TEXTURE", 4), H(xo, "STORAGE", 8), H(xo, "RENDER_ATTACHMENT", 16), H(xo, "CubeFaces", ["+X", "-X", "+Y", "-Y", "+Z", "-Z"]), H(xo, "defaultProps", {
  ...di.defaultProps,
  data: null,
  dimension: "2d",
  format: "rgba8unorm",
  width: void 0,
  height: void 0,
  depth: 1,
  mipmaps: !1,
  compressed: !1,
  usage: 0,
  mipLevels: void 0,
  samples: void 0,
  sampler: {},
  view: void 0,
  flipY: void 0
}), /** Default options */
H(xo, "defaultCopyExternalImageOptions", {
  image: void 0,
  sourceX: 0,
  sourceY: 0,
  width: void 0,
  height: void 0,
  depth: 1,
  mipLevel: 0,
  x: 0,
  y: 0,
  z: 0,
  aspect: "all",
  colorSpace: "srgb",
  premultipliedAlpha: !1,
  flipY: !1
});
let Wi = xo;
const ny = class ny extends di {
  get [Symbol.toStringTag]() {
    return "TextureView";
  }
  /** Should not be constructed directly. Use `texture.createView(props)` */
  constructor(e, t) {
    super(e, t, ny.defaultProps);
  }
};
H(ny, "defaultProps", {
  ...di.defaultProps,
  format: void 0,
  dimension: void 0,
  aspect: "all",
  baseMipLevel: 0,
  mipLevelCount: void 0,
  baseArrayLayer: 0,
  arrayLayerCount: void 0
});
let w_ = ny;
function QO(r, e, t) {
  let n = "";
  const i = e.split(/\r?\n/), s = r.slice().sort((l, o) => l.lineNum - o.lineNum);
  switch ((t == null ? void 0 : t.showSourceCode) || "no") {
    case "all":
      let l = 0;
      for (let o = 1; o <= i.length; o++)
        for (n += XE(i[o - 1], o, t); s.length > l && s[l].lineNum === o; ) {
          const d = s[l++];
          n += MA(d, i, d.lineNum, {
            ...t,
            inlineSource: !1
          });
        }
      return n;
    case "issues":
    case "no":
      for (const o of r)
        n += MA(o, i, o.lineNum, {
          inlineSource: (t == null ? void 0 : t.showSourceCode) !== "no"
        });
      return n;
  }
}
function MA(r, e, t, n) {
  if (n != null && n.inlineSource) {
    const s = e6(e, t), l = r.linePos > 0 ? `${" ".repeat(r.linePos + 5)}^^^
` : "";
    return `
${s}${l}${r.type.toUpperCase()}: ${r.message}

`;
  }
  const i = r.type === "error" ? "red" : "#8B4000";
  return n != null && n.html ? `<div class='luma-compiler-log-error' style="color:${i};"><b> ${r.type.toUpperCase()}: ${r.message}</b></div>` : `${r.type.toUpperCase()}: ${r.message}`;
}
function e6(r, e, t) {
  let n = "";
  for (let i = e - 2; i <= e; i++) {
    const s = r[i - 1];
    s !== void 0 && (n += XE(s, e, t));
  }
  return n;
}
function XE(r, e, t) {
  const n = t != null && t.html ? r6(r) : r;
  return `${t6(String(e), 4)}: ${n}${t != null && t.html ? "<br/>" : `
`}`;
}
function t6(r, e) {
  let t = "";
  for (let n = r.length; n < e; ++n)
    t += " ";
  return t + r;
}
function r6(r) {
  return r.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
}
const iy = class iy extends di {
  /** Create a new Shader instance */
  constructor(t, n) {
    n = {
      ...n,
      debugShaders: n.debugShaders || t.props.debugShaders || "errors"
    };
    super(t, {
      id: n6(n),
      ...n
    }, iy.defaultProps);
    /** The stage of this shader */
    H(this, "stage");
    /** The source code of this shader */
    H(this, "source");
    /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */
    H(this, "compilationStatus", "pending");
    this.stage = this.props.stage, this.source = this.props.source;
  }
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  /** Get compiler log synchronously (WebGL only) */
  getCompilationInfoSync() {
    return null;
  }
  /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */
  getTranslatedSource() {
    return null;
  }
  // PORTABLE HELPERS
  /** In browser logging of errors */
  async debugShader() {
    const t = this.props.debugShaders;
    switch (t) {
      case "never":
        return;
      case "errors":
        if (this.compilationStatus === "success")
          return;
        break;
    }
    const n = await this.getCompilationInfo();
    t === "warnings" && (n == null ? void 0 : n.length) === 0 || this._displayShaderLog(n);
  }
  // PRIVATE
  /**
   * In-browser UI logging of errors
   * TODO - this HTML formatting code should not be in Device, should be pluggable
   */
  _displayShaderLog(t) {
    var m;
    if (typeof document > "u" || !(document != null && document.createElement))
      return;
    const n = ZE(this.source), i = `${this.stage} ${n}`;
    let s = QO(t, this.source, {
      showSourceCode: "all",
      html: !0
    });
    const l = this.getTranslatedSource();
    l && (s += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${l}</pre></code>`);
    const o = document.createElement("Button");
    o.innerHTML = `
<h1>Shader Compilation Error in ${i}</h1><br /><br />
<code style="user-select:text;"><pre>
${s}
</pre></code>`, o.style.top = "10px", o.style.left = "10px", o.style.position = "absolute", o.style.zIndex = "9999", o.style.width = "100%", o.style.textAlign = "left", document.body.appendChild(o), (m = document.getElementsByClassName("luma-compiler-log-error")[0]) == null || m.scrollIntoView(), o.onclick = () => {
      const b = `data:text/plain,${encodeURIComponent(this.source)}`;
      navigator.clipboard.writeText(b);
    };
  }
};
H(iy, "defaultProps", {
  ...di.defaultProps,
  language: "auto",
  stage: void 0,
  source: "",
  sourceMap: null,
  entryPoint: "main",
  debugShaders: void 0
});
let A_ = iy;
function n6(r) {
  return ZE(r.source) || r.id || vy(`unnamed ${r.stage}-shader`);
}
function ZE(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
  const n = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(r);
  return n ? n[1] : e;
}
const cg = class cg extends di {
  get [Symbol.toStringTag]() {
    return "Sampler";
  }
  constructor(e, t) {
    t = cg.normalizeProps(e, t), super(e, t, cg.defaultProps);
  }
  static normalizeProps(e, t) {
    var s, l;
    const n = ((l = (s = e == null ? void 0 : e.props) == null ? void 0 : s._resourceDefaults) == null ? void 0 : l.sampler) || {};
    return {
      ...t,
      ...n
    };
  }
};
H(cg, "defaultProps", {
  ...di.defaultProps,
  type: "color-sampler",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge",
  addressModeW: "clamp-to-edge",
  magFilter: "nearest",
  minFilter: "nearest",
  mipmapFilter: "none",
  lodMinClamp: 0,
  lodMaxClamp: 32,
  // Per WebGPU spec
  compare: "less-equal",
  maxAnisotropy: 1
});
let T_ = cg;
const sy = class sy extends di {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(t, n, sy.defaultProps);
    /** Width of all attachments in this framebuffer */
    H(this, "width");
    /** Height of all attachments in this framebuffer */
    H(this, "height");
    this.width = this.props.width, this.height = this.props.height;
  }
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  /**
   * Create a copy of this framebuffer with new attached textures, with same props but of the specified size.
   * @note Does not copy contents of the attached textures.
   */
  clone(t) {
    const n = this.colorAttachments.map((s) => s.texture.clone(t)), i = this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(t);
    return this.device.createFramebuffer({
      ...this.props,
      colorAttachments: n,
      depthStencilAttachment: i
    });
  }
  resize(t) {
    let n = !t;
    if (t) {
      const [i, s] = Array.isArray(t) ? t : [t.width, t.height];
      n = n || s !== this.height || i !== this.width, this.width = i, this.height = s;
    }
    n && (lr.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height));
  }
  /** Auto creates any textures */
  autoCreateAttachmentTextures() {
    if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment)
      throw new Error("Framebuffer has noattachments");
    this.colorAttachments = this.props.colorAttachments.map((n, i) => {
      if (typeof n == "string") {
        const s = this.createColorTexture(n, i);
        return this.attachResource(s), s.view;
      }
      return n instanceof Wi ? n.view : n;
    });
    const t = this.props.depthStencilAttachment;
    if (t)
      if (typeof t == "string") {
        const n = this.createDepthStencilTexture(t);
        this.attachResource(n), this.depthStencilAttachment = n.view;
      } else t instanceof Wi ? this.depthStencilAttachment = t.view : this.depthStencilAttachment = t;
  }
  /** Create a color texture */
  createColorTexture(t, n) {
    return this.device.createTexture({
      id: `${this.id}-color-attachment-${n}`,
      usage: Wi.RENDER_ATTACHMENT,
      format: t,
      width: this.width,
      height: this.height,
      // TODO deprecated? - luma.gl v8 compatibility
      sampler: {
        magFilter: "linear",
        minFilter: "linear"
      }
    });
  }
  /** Create depth stencil texture */
  createDepthStencilTexture(t) {
    return this.device.createTexture({
      id: `${this.id}-depth-stencil-attachment`,
      usage: Wi.RENDER_ATTACHMENT,
      format: t,
      width: this.width,
      height: this.height,
      mipmaps: !1
    });
  }
  /**
   * Default implementation of resize
   * Creates new textures with correct size for all attachments.
   * and destroys existing textures if owned
   */
  resizeAttachments(t, n) {
    for (let i = 0; i < this.colorAttachments.length; ++i)
      if (this.colorAttachments[i]) {
        const s = this.colorAttachments[i].texture.clone({
          width: t,
          height: n
        });
        this.destroyAttachedResource(this.colorAttachments[i]), this.colorAttachments[i] = s.view, this.attachResource(s.view);
      }
    if (this.depthStencilAttachment) {
      const i = this.depthStencilAttachment.texture.clone({
        width: t,
        height: n
      });
      this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = i.view, this.attachResource(i);
    }
    this.updateAttachments();
  }
};
H(sy, "defaultProps", {
  ...di.defaultProps,
  width: 1,
  height: 1,
  colorAttachments: [],
  // ['rgba8unorm'],
  depthStencilAttachment: null
  // 'depth24plus-stencil8'
});
let S_ = sy;
const oy = class oy extends di {
  constructor(t, n) {
    super(t, n, oy.defaultProps);
    /** The merged layout */
    H(this, "shaderLayout");
    /** Buffer map describing buffer interleaving etc */
    H(this, "bufferLayout");
    /** The linking status of the pipeline. 'pending' if linking is asynchronous, and on production */
    H(this, "linkStatus", "pending");
    /** The hash of the pipeline */
    H(this, "hash", "");
    this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || [];
  }
  get [Symbol.toStringTag]() {
    return "RenderPipeline";
  }
  // DEPRECATED METHODS
  /**
   * Uniforms
   * @deprecated Use uniforms buffers
   * @note textures, samplers and uniform buffers should be set via `setBindings()`, these are not considered uniforms.
   * @note In WebGL uniforms have a performance penalty, they are reset before each call to enable pipeline sharing.
   */
  setUniformsWebGL(t) {
    throw new Error("Use uniform blocks");
  }
};
H(oy, "defaultProps", {
  ...di.defaultProps,
  vs: null,
  vertexEntryPoint: "vertexMain",
  vsConstants: {},
  fs: null,
  fragmentEntryPoint: "fragmentMain",
  fsConstants: {},
  shaderLayout: null,
  bufferLayout: [],
  topology: "triangle-list",
  parameters: {},
  // isInstanced: false,
  // instanceCount: 0,
  // vertexCount: 0,
  bindings: {},
  uniforms: {}
});
let kd = oy;
const gc = class gc extends di {
  get [Symbol.toStringTag]() {
    return "RenderPass";
  }
  constructor(e, t) {
    t = gc.normalizeProps(e, t), super(e, t, gc.defaultProps);
  }
  static normalizeProps(e, t) {
    var s;
    return {
      ...(s = e.props._resourceDefaults) == null ? void 0 : s.renderPass,
      ...t
    };
  }
};
/** TODO - should be [0, 0, 0, 0], update once deck.gl tests run clean */
H(gc, "defaultClearColor", [0, 0, 0, 1]), /** Depth 1.0 represents the far plance */
H(gc, "defaultClearDepth", 1), /** Clears all stencil bits */
H(gc, "defaultClearStencil", 0), /** Default properties for RenderPass */
H(gc, "defaultProps", {
  ...di.defaultProps,
  framebuffer: null,
  parameters: void 0,
  clearColor: gc.defaultClearColor,
  clearColors: void 0,
  clearDepth: gc.defaultClearDepth,
  clearStencil: gc.defaultClearStencil,
  depthReadOnly: !1,
  stencilReadOnly: !1,
  discard: !1,
  occlusionQuerySet: void 0,
  timestampQuerySet: void 0,
  beginTimestampIndex: void 0,
  endTimestampIndex: void 0
});
let T1 = gc;
const ay = class ay extends di {
  constructor(t, n) {
    super(t, n, ay.defaultProps);
    H(this, "hash", "");
    /** The merged shader layout */
    H(this, "shaderLayout");
    this.shaderLayout = n.shaderLayout;
  }
  get [Symbol.toStringTag]() {
    return "ComputePipeline";
  }
};
H(ay, "defaultProps", {
  ...di.defaultProps,
  shader: void 0,
  entryPoint: void 0,
  constants: {},
  shaderLayout: void 0
});
let E_ = ay;
const ly = class ly extends di {
  get [Symbol.toStringTag]() {
    return "CommandEncoder";
  }
  constructor(e, t) {
    super(e, t, ly.defaultProps);
  }
};
H(ly, "defaultProps", {
  ...di.defaultProps,
  measureExecutionTime: void 0
});
let S1 = ly;
const cy = class cy extends di {
  get [Symbol.toStringTag]() {
    return "CommandBuffer";
  }
  constructor(e, t) {
    super(e, t, cy.defaultProps);
  }
};
H(cy, "defaultProps", {
  ...di.defaultProps
});
let E1 = cy;
function i6(r) {
  const [e, t] = o6[r], n = e === "i32" || e === "u32", i = e !== "u32", s = a6[e] * t, l = s6(e, t);
  return {
    dataType: e,
    components: t,
    defaultVertexFormat: l,
    byteLength: s,
    integer: n,
    signed: i
  };
}
function s6(r, e) {
  let t;
  switch (r) {
    case "f32":
      t = "float32";
      break;
    case "i32":
      t = "sint32";
      break;
    case "u32":
      t = "uint32";
      break;
    case "f16":
      return e <= 2 ? "float16x2" : "float16x4";
  }
  return e === 1 ? t : `${t}x${e}`;
}
const o6 = {
  f32: ["f32", 1],
  "vec2<f32>": ["f32", 2],
  "vec3<f32>": ["f32", 3],
  "vec4<f32>": ["f32", 4],
  f16: ["f16", 1],
  "vec2<f16>": ["f16", 2],
  "vec3<f16>": ["f16", 3],
  "vec4<f16>": ["f16", 4],
  i32: ["i32", 1],
  "vec2<i32>": ["i32", 2],
  "vec3<i32>": ["i32", 3],
  "vec4<i32>": ["i32", 4],
  u32: ["u32", 1],
  "vec2<u32>": ["u32", 2],
  "vec3<u32>": ["u32", 3],
  "vec4<u32>": ["u32", 4]
}, a6 = {
  f32: 4,
  f16: 2,
  i32: 4,
  u32: 4
  // 'bool-webgl': 4,
};
function YE(r) {
  let e;
  r.endsWith("-webgl") && (r.replace("-webgl", ""), e = !0);
  const [t, n] = r.split("x"), i = t, s = n ? parseInt(n) : 1, l = $E(i), o = {
    type: i,
    components: s,
    byteLength: l.byteLength * s,
    integer: l.integer,
    signed: l.signed,
    normalized: l.normalized
  };
  return e && (o.webglOnly = !0), o;
}
function KE(r, e) {
  const t = {};
  for (const n of r.attributes) {
    const i = c6(r, e, n.name);
    i && (t[n.name] = i);
  }
  return t;
}
function l6(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 16;
  const n = KE(r, e), i = new Array(t).fill(null);
  for (const s of Object.values(n))
    i[s.location] = s;
  return i;
}
function c6(r, e, t) {
  const n = u6(r, t), i = h6(e, t);
  if (!n)
    return null;
  const s = i6(n.type), l = (i == null ? void 0 : i.vertexFormat) || s.defaultVertexFormat, o = YE(l);
  return {
    attributeName: (i == null ? void 0 : i.attributeName) || n.name,
    bufferName: (i == null ? void 0 : i.bufferName) || n.name,
    location: n.location,
    shaderType: n.type,
    shaderDataType: s.dataType,
    shaderComponents: s.components,
    vertexFormat: l,
    bufferDataType: o.type,
    bufferComponents: o.components,
    // normalized is a property of the buffer's vertex format
    normalized: o.normalized,
    // integer is a property of the shader declaration
    integer: s.integer,
    stepMode: (i == null ? void 0 : i.stepMode) || n.stepMode || "vertex",
    byteOffset: (i == null ? void 0 : i.byteOffset) || 0,
    byteStride: (i == null ? void 0 : i.byteStride) || 0
  };
}
function u6(r, e) {
  const t = r.attributes.find((n) => n.name === e);
  return t || lr.warn(`shader layout attribute "${e}" not present in shader`), t || null;
}
function h6(r, e) {
  f6(r);
  let t = d6(r, e);
  return t || (t = p6(r, e), t) ? t : (lr.warn(`layout for attribute "${e}" not present in buffer layout`), null);
}
function f6(r) {
  for (const e of r)
    (e.attributes && e.format || !e.attributes && !e.format) && lr.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
}
function d6(r, e) {
  for (const t of r)
    if (t.format && t.name === e)
      return {
        attributeName: t.name,
        bufferName: e,
        stepMode: t.stepMode,
        vertexFormat: t.format,
        // If offset is needed, use `attributes` field.
        byteOffset: 0,
        byteStride: t.byteStride || 0
      };
  return null;
}
function p6(r, e) {
  var t;
  for (const n of r) {
    let i = n.byteStride;
    if (typeof n.byteStride != "number")
      for (const l of n.attributes || []) {
        const o = YE(l.format);
        i += o.byteLength;
      }
    const s = (t = n.attributes) == null ? void 0 : t.find((l) => l.attribute === e);
    if (s)
      return {
        attributeName: s.attribute,
        bufferName: n.name,
        stepMode: n.stepMode,
        vertexFormat: s.format,
        byteOffset: s.byteOffset,
        // @ts-ignore
        byteStride: i
      };
  }
  return null;
}
const uy = class uy extends di {
  constructor(t, n) {
    super(t, n, uy.defaultProps);
    /** Max number of vertex attributes */
    H(this, "maxVertexAttributes");
    /** Attribute infos indexed by location - TODO only needed by webgl module? */
    H(this, "attributeInfos");
    /** Index buffer */
    H(this, "indexBuffer", null);
    /** Attributes indexed by buffer slot */
    H(this, "attributes");
    this.maxVertexAttributes = t.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null);
    const {
      shaderLayout: i,
      bufferLayout: s
    } = n.renderPipeline || {};
    if (!i || !s)
      throw new Error("VertexArray");
    this.attributeInfos = l6(i, s, this.maxVertexAttributes);
  }
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  // DEPRECATED METHODS
  /** @deprecated Set constant attributes (WebGL only) */
  setConstantWebGL(t, n) {
    this.device.reportError(new Error("constant attributes not supported"));
  }
};
H(uy, "defaultProps", {
  ...di.defaultProps,
  renderPipeline: null
});
let C1 = uy;
const hy = class hy extends di {
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  constructor(e, t) {
    super(e, t, hy.defaultProps);
  }
};
H(hy, "defaultProps", {
  ...di.defaultProps,
  layout: void 0,
  buffers: {}
});
let I1 = hy;
const fy = class fy extends di {
  get [Symbol.toStringTag]() {
    return "QuerySet";
  }
  constructor(e, t) {
    super(e, t, fy.defaultProps);
  }
};
H(fy, "defaultProps", {
  ...di.defaultProps,
  type: void 0,
  count: void 0
});
let M1 = fy;
const g6 = {
  f32: {
    type: "f32",
    components: 1
  },
  i32: {
    type: "i32",
    components: 1
  },
  u32: {
    type: "u32",
    components: 1
  },
  // 'bool-webgl': {type: 'bool-webgl', components: 1},
  "vec2<f32>": {
    type: "f32",
    components: 2
  },
  "vec3<f32>": {
    type: "f32",
    components: 3
  },
  "vec4<f32>": {
    type: "f32",
    components: 4
  },
  "vec2<i32>": {
    type: "i32",
    components: 2
  },
  "vec3<i32>": {
    type: "i32",
    components: 3
  },
  "vec4<i32>": {
    type: "i32",
    components: 4
  },
  "vec2<u32>": {
    type: "u32",
    components: 2
  },
  "vec3<u32>": {
    type: "u32",
    components: 3
  },
  "vec4<u32>": {
    type: "u32",
    components: 4
  },
  "mat2x2<f32>": {
    type: "f32",
    components: 4
  },
  "mat2x3<f32>": {
    type: "f32",
    components: 6
  },
  "mat2x4<f32>": {
    type: "f32",
    components: 8
  },
  "mat3x2<f32>": {
    type: "f32",
    components: 6
  },
  "mat3x3<f32>": {
    type: "f32",
    components: 9
  },
  "mat3x4<f32>": {
    type: "f32",
    components: 12
  },
  "mat4x2<f32>": {
    type: "f32",
    components: 8
  },
  "mat4x3<f32>": {
    type: "f32",
    components: 12
  },
  "mat4x4<f32>": {
    type: "f32",
    components: 16
  }
};
function m6(r) {
  return g6[r];
}
function _6(r, e) {
  switch (e) {
    case 1:
      return r;
    // Pad upwards to even multiple of 2
    case 2:
      return r + r % 2;
    // Pad upwards to even multiple of 2
    default:
      return r + (4 - r % 4) % 4;
  }
}
let cm;
function JE(r) {
  return (!cm || cm.byteLength < r) && (cm = new ArrayBuffer(r)), cm;
}
function y6(r, e) {
  const t = JE(r.BYTES_PER_ELEMENT * e);
  return new r(t, 0, e);
}
function b6(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function C_(r) {
  return Array.isArray(r) ? r.length === 0 || typeof r[0] == "number" : b6(r);
}
const PA = 1024;
class v6 {
  /** Create a new UniformBufferLayout given a map of attributes. */
  constructor(e) {
    H(this, "layout", {});
    /** number of bytes needed for buffer allocation */
    H(this, "byteLength");
    let t = 0;
    for (const [i, s] of Object.entries(e)) {
      const l = m6(s), {
        type: o,
        components: d
      } = l;
      t = _6(t, d);
      const m = t;
      t += d, this.layout[i] = {
        type: o,
        size: d,
        offset: m
      };
    }
    t += (4 - t % 4) % 4;
    const n = t * 4;
    this.byteLength = Math.max(n, PA);
  }
  /** Get the data for the complete buffer */
  getData(e) {
    const t = Math.max(this.byteLength, PA), n = JE(t), i = {
      i32: new Int32Array(n),
      u32: new Uint32Array(n),
      f32: new Float32Array(n),
      // TODO not implemented
      f16: new Uint16Array(n)
    };
    for (const [s, l] of Object.entries(e)) {
      const o = this.layout[s];
      if (!o) {
        lr.warn(`Supplied uniform value ${s} not present in uniform block layout`)();
        continue;
      }
      const {
        type: d,
        size: m,
        offset: b
      } = o, T = i[d];
      if (m === 1) {
        if (typeof l != "number" && typeof l != "boolean") {
          lr.warn(`Supplied value for single component uniform ${s} is not a number: ${l}`)();
          continue;
        }
        T[b] = Number(l);
      } else {
        if (!C_(l)) {
          lr.warn(`Supplied value for multi component / array uniform ${s} is not a numeric array: ${l}`)();
          continue;
        }
        T.set(l, b);
      }
    }
    return new Uint8Array(n);
  }
  /** Does this layout have a field with specified name */
  has(e) {
    return !!this.layout[e];
  }
  /** Get offset and size for a field with specified name */
  get(e) {
    return this.layout[e];
  }
}
function x6(r, e) {
  if (r !== e)
    return !1;
  const t = r, n = e;
  if (!C_(t))
    return !1;
  if (C_(n) && t.length === n.length) {
    for (let i = 0; i < t.length; ++i)
      if (n[i] !== t[i])
        return !1;
  }
  return !0;
}
function w6(r) {
  return C_(r) ? r.slice() : r;
}
class A6 {
  constructor(e) {
    H(this, "name");
    H(this, "uniforms", {});
    H(this, "modifiedUniforms", {});
    H(this, "modified", !0);
    H(this, "bindingLayout", {});
    H(this, "needsRedraw", "initialized");
    var t;
    if (this.name = (e == null ? void 0 : e.name) || "unnamed", e != null && e.name && (e != null && e.shaderLayout)) {
      const n = (t = e == null ? void 0 : e.shaderLayout.bindings) == null ? void 0 : t.find((s) => s.type === "uniform" && s.name === (e == null ? void 0 : e.name));
      if (!n)
        throw new Error(e == null ? void 0 : e.name);
      const i = n;
      for (const s of i.uniforms || [])
        this.bindingLayout[s.name] = s;
    }
  }
  /** Set a map of uniforms */
  setUniforms(e) {
    for (const [t, n] of Object.entries(e))
      this._setUniform(t, n), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${t}=${n}`);
  }
  setNeedsRedraw(e) {
    this.needsRedraw = this.needsRedraw || e;
  }
  /** Returns all uniforms */
  getAllUniforms() {
    return this.modifiedUniforms = {}, this.needsRedraw = !1, this.uniforms || {};
  }
  /** Set a single uniform */
  _setUniform(e, t) {
    x6(this.uniforms[e], t) || (this.uniforms[e] = w6(t), this.modifiedUniforms[e] = !0, this.modified = !0);
  }
}
class T6 {
  /**
   * Create a new UniformStore instance
   * @param blocks
   */
  constructor(e) {
    /** Stores the uniform values for each uniform block */
    H(this, "uniformBlocks", /* @__PURE__ */ new Map());
    /** Can generate data for a uniform buffer for each block from data */
    H(this, "uniformBufferLayouts", /* @__PURE__ */ new Map());
    /** Actual buffer for the blocks */
    H(this, "uniformBuffers", /* @__PURE__ */ new Map());
    for (const [t, n] of Object.entries(e)) {
      const i = t, s = new v6(n.uniformTypes || {});
      this.uniformBufferLayouts.set(i, s);
      const l = new A6({
        name: t
      });
      l.setUniforms(n.defaultUniforms || {}), this.uniformBlocks.set(i, l);
    }
  }
  /** Destroy any managed uniform buffers */
  destroy() {
    for (const e of this.uniformBuffers.values())
      e.destroy();
  }
  /**
   * Set uniforms
   * Makes all properties partial
   */
  setUniforms(e) {
    var t;
    for (const [n, i] of Object.entries(e))
      (t = this.uniformBlocks.get(n)) == null || t.setUniforms(i);
    this.updateUniformBuffers();
  }
  /** Get the required minimum length of the uniform buffer */
  getUniformBufferByteLength(e) {
    var t;
    return ((t = this.uniformBufferLayouts.get(e)) == null ? void 0 : t.byteLength) || 0;
  }
  /** Get formatted binary memory that can be uploaded to a buffer */
  getUniformBufferData(e) {
    var n, i;
    const t = ((n = this.uniformBlocks.get(e)) == null ? void 0 : n.getAllUniforms()) || {};
    return (i = this.uniformBufferLayouts.get(e)) == null ? void 0 : i.getData(t);
  }
  /**
   * Creates an unmanaged uniform buffer (umnanaged means that application is responsible for destroying it)
   * The new buffer is initialized with current / supplied values
   */
  createUniformBuffer(e, t, n) {
    n && this.setUniforms(n);
    const i = this.getUniformBufferByteLength(t), s = e.createBuffer({
      usage: Ss.UNIFORM | Ss.COPY_DST,
      byteLength: i
    }), l = this.getUniformBufferData(t);
    return s.write(l), s;
  }
  /** Get the managed uniform buffer. "managed" resources are destroyed when the uniformStore is destroyed. */
  getManagedUniformBuffer(e, t) {
    if (!this.uniformBuffers.get(t)) {
      const n = this.getUniformBufferByteLength(t), i = e.createBuffer({
        usage: Ss.UNIFORM | Ss.COPY_DST,
        byteLength: n
      });
      this.uniformBuffers.set(t, i);
    }
    return this.uniformBuffers.get(t);
  }
  /** Updates all uniform buffers where values have changed */
  updateUniformBuffers() {
    let e = !1;
    for (const t of this.uniformBlocks.keys()) {
      const n = this.updateUniformBuffer(t);
      e || (e = n);
    }
    return e && lr.log(3, `UniformStore.updateUniformBuffers(): ${e}`)(), e;
  }
  /** Update one uniform buffer. Only updates if values have changed */
  updateUniformBuffer(e) {
    var s;
    const t = this.uniformBlocks.get(e);
    let n = this.uniformBuffers.get(e), i = !1;
    if (n && (t != null && t.needsRedraw)) {
      i || (i = t.needsRedraw);
      const l = this.getUniformBufferData(e);
      n = this.uniformBuffers.get(e), n == null || n.write(l);
      const o = (s = this.uniformBlocks.get(e)) == null ? void 0 : s.getAllUniforms();
      lr.log(4, `Writing to uniform buffer ${String(e)}`, l, o)();
    }
    return i;
  }
}
function QE(r) {
  const e = ArrayBuffer.isView(r) ? r.constructor : r;
  switch (e) {
    case Float32Array:
      return "float32";
    case Uint16Array:
      return "uint16";
    case Uint32Array:
      return "uint32";
    case Uint8Array:
    case Uint8ClampedArray:
      return "uint8";
    case Int8Array:
      return "sint8";
    case Int16Array:
      return "sint16";
    case Int32Array:
      return "sint32";
    default:
      throw new Error(e.constructor.name);
  }
}
function e5(r) {
  switch (r) {
    case "float32":
      return Float32Array;
    case "uint32":
      return Uint32Array;
    case "sint32":
      return Int32Array;
    case "uint16":
    case "unorm16":
      return Uint16Array;
    case "sint16":
    case "snorm16":
      return Int16Array;
    case "uint8":
    case "unorm8":
      return Uint8Array;
    case "sint8":
    case "snorm8":
      return Int8Array;
    default:
      throw new Error(r);
  }
}
function S6(r, e, t) {
  if (!e || e > 4)
    throw new Error(`size ${e}`);
  const n = e;
  let i = QE(r);
  if (i === "uint8" && t && n === 1)
    return "unorm8-webgl";
  if (i === "uint8" && t && n === 3)
    return "unorm8x3-webgl";
  if (i === "uint8" || i === "sint8") {
    if (n === 1 || n === 3)
      throw new Error(`size: ${e}`);
    return t && (i = i.replace("int", "norm")), `${i}x${n}`;
  }
  if (i === "uint16" || i === "sint16") {
    if (n === 1 || n === 3)
      throw new Error(`size: ${e}`);
    return t && (i = i.replace("int", "norm")), `${i}x${n}`;
  }
  return n === 1 ? i : `${i}x${n}`;
}
class Y0 {
  constructor(e) {
    H(this, "bufferLayouts");
    this.bufferLayouts = e;
  }
  getBufferLayout(e) {
    return this.bufferLayouts.find((t) => t.name === e) || null;
  }
  /** Get attribute names from a BufferLayout */
  getAttributeNamesForBuffer(e) {
    var t;
    return e.attributes ? (t = e.attributes) == null ? void 0 : t.map((n) => n.attribute) : [e.name];
  }
  mergeBufferLayouts(e, t) {
    const n = [...e];
    for (const i of t) {
      const s = n.findIndex((l) => l.name === i.name);
      s < 0 ? n.push(i) : n[s] = i;
    }
    return n;
  }
}
class Ec {
  constructor(e, t) {
    this.name = e, this.attributes = t, this.size = 0;
  }
  get isArray() {
    return !1;
  }
  get isStruct() {
    return !1;
  }
  get isTemplate() {
    return !1;
  }
}
class RA {
  constructor(e, t, n) {
    this.name = e, this.type = t, this.attributes = n, this.offset = 0, this.size = 0;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class wh extends Ec {
  constructor(e, t) {
    super(e, t), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;
  }
  get isStruct() {
    return !0;
  }
}
class _f extends Ec {
  constructor(e, t) {
    super(e, t), this.count = 0, this.stride = 0;
  }
  get isArray() {
    return !0;
  }
}
class Rh extends Ec {
  constructor(e, t, n, i) {
    super(e, n), this.format = t, this.access = i;
  }
  get isTemplate() {
    return !0;
  }
}
var _h, md, Gp, At, at;
((r) => {
  r[r.Uniform = 0] = "Uniform", r[r.Storage = 1] = "Storage", r[r.Texture = 2] = "Texture", r[r.Sampler = 3] = "Sampler", r[r.StorageTexture = 4] = "StorageTexture";
})(_h || (_h = {}));
class um {
  constructor(e, t, n, i, s, l, o) {
    this.name = e, this.type = t, this.group = n, this.binding = i, this.attributes = s, this.resourceType = l, this.access = o;
  }
  get isArray() {
    return this.type.isArray;
  }
  get isStruct() {
    return this.type.isStruct;
  }
  get isTemplate() {
    return this.type.isTemplate;
  }
  get size() {
    return this.type.size;
  }
  get align() {
    return this.type.isStruct ? this.type.align : 0;
  }
  get members() {
    return this.type.isStruct ? this.type.members : null;
  }
  get format() {
    return this.type.isArray || this.type.isTemplate ? this.type.format : null;
  }
  get count() {
    return this.type.isArray ? this.type.count : 0;
  }
  get stride() {
    return this.type.isArray ? this.type.stride : this.size;
  }
}
class E6 {
  constructor(e, t) {
    this.name = e, this.type = t;
  }
}
class C6 {
  constructor(e, t, n, i) {
    this.name = e, this.type = t, this.locationType = n, this.location = i, this.interpolation = null;
  }
}
class BA {
  constructor(e, t, n, i) {
    this.name = e, this.type = t, this.locationType = n, this.location = i;
  }
}
class I6 {
  constructor(e, t, n, i) {
    this.name = e, this.type = t, this.attributes = n, this.id = i;
  }
}
class M6 {
  constructor(e, t, n) {
    this.name = e, this.type = t, this.attributes = n;
  }
}
class P6 {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = arguments.length > 2 ? arguments[2] : void 0;
    this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = /* @__PURE__ */ new Set(), this.name = e, this.stage = t, this.attributes = n;
  }
}
class R6 {
  constructor() {
    this.vertex = [], this.fragment = [], this.compute = [];
  }
}
class B6 {
  constructor() {
    this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
  }
}
class Ml {
  constructor() {
    this.id = Ml._id++, this.line = 0;
  }
  get isAstNode() {
    return !0;
  }
  get astNodeType() {
    return "";
  }
  constEvaluate(e, t) {
    throw new Error("Cannot evaluate node");
  }
  constEvaluateString(e) {
    return this.constEvaluate(e).toString();
  }
  search(e) {
  }
  searchBlock(e, t) {
    if (e) {
      t(I_.instance);
      for (const n of e) n instanceof Array ? this.searchBlock(n, t) : n.search(t);
      t(M_.instance);
    }
  }
}
Ml._id = 0;
class I_ extends Ml {
}
I_.instance = new I_();
class M_ extends Ml {
}
M_.instance = new M_();
class qi extends Ml {
  constructor() {
    super();
  }
}
class P_ extends qi {
  constructor(e, t, n, i, s, l) {
    super(), this.calls = /* @__PURE__ */ new Set(), this.name = e, this.args = t, this.returnType = n, this.body = i, this.startLine = s, this.endLine = l;
  }
  get astNodeType() {
    return "function";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class L6 extends qi {
  constructor(e) {
    super(), this.expression = e;
  }
  get astNodeType() {
    return "staticAssert";
  }
  search(e) {
    this.expression.search(e);
  }
}
class t5 extends qi {
  constructor(e, t) {
    super(), this.condition = e, this.body = t;
  }
  get astNodeType() {
    return "while";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
class P1 extends qi {
  constructor(e) {
    super(), this.body = e;
  }
  get astNodeType() {
    return "continuing";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
class r5 extends qi {
  constructor(e, t, n, i) {
    super(), this.init = e, this.condition = t, this.increment = n, this.body = i;
  }
  get astNodeType() {
    return "for";
  }
  search(e) {
    var t, n, i;
    (t = this.init) === null || t === void 0 || t.search(e), (n = this.condition) === null || n === void 0 || n.search(e), (i = this.increment) === null || i === void 0 || i.search(e), this.searchBlock(this.body, e);
  }
}
class xh extends qi {
  constructor(e, t, n, i, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = i, this.value = s;
  }
  get astNodeType() {
    return "var";
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class r2 extends qi {
  constructor(e, t, n) {
    super(), this.attributes = null, this.name = e, this.type = t, this.value = n;
  }
  get astNodeType() {
    return "override";
  }
  search(e) {
    var t;
    (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class R_ extends qi {
  constructor(e, t, n, i, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = i, this.value = s;
  }
  get astNodeType() {
    return "let";
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class R1 extends qi {
  constructor(e, t, n, i, s) {
    super(), this.attributes = null, this.name = e, this.type = t, this.storage = n, this.access = i, this.value = s;
  }
  get astNodeType() {
    return "const";
  }
  constEvaluate(e, t) {
    return this.value.constEvaluate(e, t);
  }
  search(e) {
    var t;
    e(this), (t = this.value) === null || t === void 0 || t.search(e);
  }
}
((r) => {
  r.increment = "++", r.decrement = "--";
})(md || (md = {})), ((r) => {
  r.parse = function(e) {
    const t = e;
    if (t == "parse") throw new Error("Invalid value for IncrementOperator");
    return r[t];
  };
})(md || (md = {}));
class n5 extends qi {
  constructor(e, t) {
    super(), this.operator = e, this.variable = t;
  }
  get astNodeType() {
    return "increment";
  }
  search(e) {
    this.variable.search(e);
  }
}
((r) => {
  r.assign = "=", r.addAssign = "+=", r.subtractAssin = "-=", r.multiplyAssign = "*=", r.divideAssign = "/=", r.moduloAssign = "%=", r.andAssign = "&=", r.orAssign = "|=", r.xorAssign = "^=", r.shiftLeftAssign = "<<=", r.shiftRightAssign = ">>=";
})(Gp || (Gp = {})), ((r) => {
  r.parse = function(e) {
    const t = e;
    if (t == "parse") throw new Error("Invalid value for AssignOperator");
    return t;
  };
})(Gp || (Gp = {}));
class i5 extends qi {
  constructor(e, t, n) {
    super(), this.operator = e, this.variable = t, this.value = n;
  }
  get astNodeType() {
    return "assign";
  }
  search(e) {
    this.variable.search(e), this.value.search(e);
  }
}
class n2 extends qi {
  constructor(e, t) {
    super(), this.name = e, this.args = t;
  }
  get astNodeType() {
    return "call";
  }
  search(e) {
    for (const t of this.args) t.search(e);
    e(this);
  }
}
class s5 extends qi {
  constructor(e, t) {
    super(), this.body = e, this.continuing = t;
  }
  get astNodeType() {
    return "loop";
  }
}
class o5 extends qi {
  constructor(e, t) {
    super(), this.condition = e, this.cases = t;
  }
  get astNodeType() {
    return "switch";
  }
}
class a5 extends qi {
  constructor(e, t, n, i) {
    super(), this.condition = e, this.body = t, this.elseif = n, this.else = i;
  }
  get astNodeType() {
    return "if";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e), this.searchBlock(this.elseif, e), this.searchBlock(this.else, e);
  }
}
class l5 extends qi {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "return";
  }
  search(e) {
    var t;
    (t = this.value) === null || t === void 0 || t.search(e);
  }
}
class O6 extends qi {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "enable";
  }
}
class N6 extends qi {
  constructor(e) {
    super(), this.extensions = e;
  }
  get astNodeType() {
    return "requires";
  }
}
class c5 extends qi {
  constructor(e, t) {
    super(), this.severity = e, this.rule = t;
  }
  get astNodeType() {
    return "diagnostic";
  }
}
class i2 extends qi {
  constructor(e, t) {
    super(), this.name = e, this.type = t;
  }
  get astNodeType() {
    return "alias";
  }
}
class D6 extends qi {
  constructor() {
    super();
  }
  get astNodeType() {
    return "discard";
  }
}
class u5 extends qi {
  constructor() {
    super(), this.condition = null, this.loopId = -1;
  }
  get astNodeType() {
    return "break";
  }
}
class h5 extends qi {
  constructor() {
    super(), this.loopId = -1;
  }
  get astNodeType() {
    return "continue";
  }
}
class ur extends qi {
  constructor(e) {
    super(), this.attributes = null, this.name = e;
  }
  get astNodeType() {
    return "type";
  }
  get isStruct() {
    return !1;
  }
  get isArray() {
    return !1;
  }
  static maxFormatType(e) {
    let t = e[0];
    if (t.name === "f32") return t;
    for (let n = 1; n < e.length; ++n) {
      const i = ur._priority.get(t.name);
      ur._priority.get(e[n].name) < i && (t = e[n]);
    }
    return t.name === "x32" ? ur.i32 : t;
  }
}
ur.x32 = new ur("x32"), ur.f32 = new ur("f32"), ur.i32 = new ur("i32"), ur.u32 = new ur("u32"), ur.f16 = new ur("f16"), ur.bool = new ur("bool"), ur._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
class yh extends ur {
  constructor(e, t, n, i) {
    super(e), this.members = t, this.startLine = n, this.endLine = i;
  }
  get astNodeType() {
    return "struct";
  }
  get isStruct() {
    return !0;
  }
  getMemberIndex(e) {
    for (let t = 0; t < this.members.length; t++) if (this.members[t].name == e) return t;
    return -1;
  }
}
class Ht extends ur {
  constructor(e, t, n) {
    super(e), this.format = t, this.access = n;
  }
  get astNodeType() {
    return "template";
  }
}
Ht.vec2f = new Ht("vec2", ur.f32, null), Ht.vec3f = new Ht("vec3", ur.f32, null), Ht.vec4f = new Ht("vec4", ur.f32, null), Ht.vec2i = new Ht("vec2", ur.i32, null), Ht.vec3i = new Ht("vec3", ur.i32, null), Ht.vec4i = new Ht("vec4", ur.i32, null), Ht.vec2u = new Ht("vec2", ur.u32, null), Ht.vec3u = new Ht("vec3", ur.u32, null), Ht.vec4u = new Ht("vec4", ur.u32, null), Ht.vec2h = new Ht("vec2", ur.f16, null), Ht.vec3h = new Ht("vec3", ur.f16, null), Ht.vec4h = new Ht("vec4", ur.f16, null), Ht.vec2b = new Ht("vec2", ur.bool, null), Ht.vec3b = new Ht("vec3", ur.bool, null), Ht.vec4b = new Ht("vec4", ur.bool, null), Ht.mat2x2f = new Ht("mat2x2", ur.f32, null), Ht.mat2x3f = new Ht("mat2x3", ur.f32, null), Ht.mat2x4f = new Ht("mat2x4", ur.f32, null), Ht.mat3x2f = new Ht("mat3x2", ur.f32, null), Ht.mat3x3f = new Ht("mat3x3", ur.f32, null), Ht.mat3x4f = new Ht("mat3x4", ur.f32, null), Ht.mat4x2f = new Ht("mat4x2", ur.f32, null), Ht.mat4x3f = new Ht("mat4x3", ur.f32, null), Ht.mat4x4f = new Ht("mat4x4", ur.f32, null), Ht.mat2x2h = new Ht("mat2x2", ur.f16, null), Ht.mat2x3h = new Ht("mat2x3", ur.f16, null), Ht.mat2x4h = new Ht("mat2x4", ur.f16, null), Ht.mat3x2h = new Ht("mat3x2", ur.f16, null), Ht.mat3x3h = new Ht("mat3x3", ur.f16, null), Ht.mat3x4h = new Ht("mat3x4", ur.f16, null), Ht.mat4x2h = new Ht("mat4x2", ur.f16, null), Ht.mat4x3h = new Ht("mat4x3", ur.f16, null), Ht.mat4x4h = new Ht("mat4x4", ur.f16, null);
class k6 extends ur {
  constructor(e, t, n, i) {
    super(e), this.storage = t, this.type = n, this.access = i;
  }
  get astNodeType() {
    return "pointer";
  }
}
class f5 extends ur {
  constructor(e, t, n, i) {
    super(e), this.attributes = t, this.format = n, this.count = i;
  }
  get astNodeType() {
    return "array";
  }
  get isArray() {
    return !0;
  }
}
class $p extends ur {
  constructor(e, t, n) {
    super(e), this.format = t, this.access = n;
  }
  get astNodeType() {
    return "sampler";
  }
}
class Pc extends Ml {
  constructor() {
    super(), this.postfix = null;
  }
}
class Sf extends Pc {
  constructor(e) {
    super(), this.value = e;
  }
  get astNodeType() {
    return "stringExpr";
  }
  toString() {
    return this.value;
  }
  constEvaluateString() {
    return this.value;
  }
}
class yf extends Pc {
  constructor(e, t) {
    super(), this.type = e, this.args = t;
  }
  get astNodeType() {
    return "createExpr";
  }
  search(e) {
    if (e(this), this.args) for (const t of this.args) t.search(e);
  }
  constEvaluate(e, t) {
    return t && (t[0] = this.type), e.evalExpression(this, e.context);
  }
}
class Kd extends Pc {
  constructor(e, t) {
    super(), this.cachedReturnValue = null, this.name = e, this.args = t;
  }
  get astNodeType() {
    return "callExpr";
  }
  setCachedReturnValue(e) {
    this.cachedReturnValue = e;
  }
  get isBuiltin() {
    return Kd.builtinFunctionNames.has(this.name);
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    for (const t of this.args) t.search(e);
    e(this);
  }
}
Kd.builtinFunctionNames = /* @__PURE__ */ new Set(["all", "all", "any", "select", "arrayLength", "abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "clamp", "cos", "cosh", "countLeadingZeros", "countOneBits", "countTrailingZeros", "cross", "degrees", "determinant", "distance", "dot", "dot4U8Packed", "dot4I8Packed", "exp", "exp2", "extractBits", "faceForward", "firstLeadingBit", "firstTrailingBit", "floor", "fma", "fract", "frexp", "insertBits", "inverseSqrt", "ldexp", "length", "log", "log2", "max", "min", "mix", "modf", "normalize", "pow", "quantizeToF16", "radians", "reflect", "refract", "reverseBits", "round", "saturate", "sign", "sin", "sinh", "smoothStep", "sqrt", "step", "tan", "tanh", "transpose", "trunc", "dpdx", "dpdxCoarse", "dpdxFine", "dpdy", "dpdyCoarse", "dpdyFine", "fwidth", "fwidthCoarse", "fwidthFine", "textureDimensions", "textureGather", "textureGatherCompare", "textureLoad", "textureNumLayers", "textureNumLevels", "textureNumSamples", "textureSample", "textureSampleBias", "textureSampleCompare", "textureSampleCompareLevel", "textureSampleGrad", "textureSampleLevel", "textureSampleBaseClampToEdge", "textureStore", "atomicLoad", "atomicStore", "atomicAdd", "atomicSub", "atomicMax", "atomicMin", "atomicAnd", "atomicOr", "atomicXor", "atomicExchange", "atomicCompareExchangeWeak", "pack4x8snorm", "pack4x8unorm", "pack4xI8", "pack4xU8", "pack4x8Clamp", "pack4xU8Clamp", "pack2x16snorm", "pack2x16unorm", "pack2x16float", "unpack4x8snorm", "unpack4x8unorm", "unpack4xI8", "unpack4xU8", "unpack2x16snorm", "unpack2x16unorm", "unpack2x16float", "storageBarrier", "textureBarrier", "workgroupBarrier", "workgroupUniformLoad", "subgroupAdd", "subgroupExclusiveAdd", "subgroupInclusiveAdd", "subgroupAll", "subgroupAnd", "subgroupAny", "subgroupBallot", "subgroupBroadcast", "subgroupBroadcastFirst", "subgroupElect", "subgroupMax", "subgroupMin", "subgroupMul", "subgroupExclusiveMul", "subgroupInclusiveMul", "subgroupOr", "subgroupShuffle", "subgroupShuffleDown", "subgroupShuffleUp", "subgroupShuffleXor", "subgroupXor", "quadBroadcast", "quadSwapDiagonal", "quadSwapX", "quadSwapY"]);
class Ch extends Pc {
  constructor(e) {
    super(), this.name = e;
  }
  get astNodeType() {
    return "varExpr";
  }
  search(e) {
    e(this), this.postfix && this.postfix.search(e);
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
}
class d5 extends Pc {
  constructor(e, t) {
    super(), this.name = e, this.initializer = t;
  }
  get astNodeType() {
    return "constExpr";
  }
  constEvaluate(e, t) {
    if (this.initializer) {
      const n = e.evalExpression(this.initializer, e.context);
      return n !== null && this.postfix ? n.getDataValue(e, this.postfix, e.context) : n;
    }
    return null;
  }
  search(e) {
    this.initializer.search(e);
  }
}
class as extends Pc {
  constructor(e, t) {
    super(), this.value = e, this.type = t;
  }
  get astNodeType() {
    return "literalExpr";
  }
  constEvaluate(e, t) {
    return t !== void 0 && (t[0] = this.type), this.value;
  }
  get isScalar() {
    return this.value instanceof Et;
  }
  get isVector() {
    return this.value instanceof je || this.value instanceof Hn;
  }
  get scalarValue() {
    return this.value instanceof Et ? this.value.value : (console.error("Value is not scalar."), 0);
  }
  get vectorValue() {
    return this.value instanceof je || this.value instanceof Hn ? this.value.value : (console.error("Value is not a vector or matrix."), []);
  }
}
class p5 extends Pc {
  constructor(e, t) {
    super(), this.type = e, this.value = t;
  }
  get astNodeType() {
    return "bitcastExpr";
  }
  search(e) {
    this.value.search(e);
  }
}
class Hm extends Pc {
  constructor(e) {
    super(), this.contents = e;
  }
  get astNodeType() {
    return "groupExpr";
  }
  constEvaluate(e, t) {
    return this.contents[0].constEvaluate(e, t);
  }
  search(e) {
    this.searchBlock(this.contents, e);
  }
}
class Fd extends Pc {
  constructor(e) {
    super(), this.index = e;
  }
  search(e) {
    this.index.search(e);
  }
}
class g5 extends Pc {
  constructor() {
    super();
  }
}
class Ya extends g5 {
  constructor(e, t) {
    super(), this.operator = e, this.right = t;
  }
  get astNodeType() {
    return "unaryOp";
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    this.right.search(e);
  }
}
class pc extends g5 {
  constructor(e, t, n) {
    super(), this.operator = e, this.left = t, this.right = n;
  }
  get astNodeType() {
    return "binaryOp";
  }
  _getPromotedType(e, t) {
    return e.name === t.name ? e : e.name === "f32" || t.name === "f32" ? ur.f32 : e.name === "u32" || t.name === "u32" ? ur.u32 : ur.i32;
  }
  constEvaluate(e, t) {
    return e.evalExpression(this, e.context);
  }
  search(e) {
    this.left.search(e), this.right.search(e);
  }
}
class m5 extends Ml {
  constructor(e) {
    super(), this.body = e;
  }
}
class Wm extends Pc {
  constructor() {
    super();
  }
  get astNodeType() {
    return "default";
  }
}
class _5 extends m5 {
  constructor(e, t) {
    super(t), this.selectors = e;
  }
  get astNodeType() {
    return "case";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
}
let y5 = class extends m5 {
  constructor(e) {
    super(e);
  }
  get astNodeType() {
    return "default";
  }
  search(e) {
    this.searchBlock(this.body, e);
  }
};
class F6 extends Ml {
  constructor(e, t, n) {
    super(), this.name = e, this.type = t, this.attributes = n;
  }
  get astNodeType() {
    return "argument";
  }
}
class U6 extends Ml {
  constructor(e, t) {
    super(), this.condition = e, this.body = t;
  }
  get astNodeType() {
    return "elseif";
  }
  search(e) {
    this.condition.search(e), this.searchBlock(this.body, e);
  }
}
let z6 = class extends Ml {
  constructor(e, t, n) {
    super(), this.name = e, this.type = t, this.attributes = n;
  }
  get astNodeType() {
    return "member";
  }
};
class j6 extends Ml {
  constructor(e, t) {
    super(), this.name = e, this.value = t;
  }
  get astNodeType() {
    return "attribute";
  }
}
class Ef {
  constructor(e) {
    this.typeInfo = e;
  }
  setDataValue(e, t, n, i) {
    console.error("SetDataValue: Not implemented", t, n);
  }
  getDataValue(e, t, n) {
    return console.error("GetDataValue: Not implemented", t), null;
  }
  toString() {
    return `<${this.typeInfo.name}>`;
  }
}
class B1 extends Ef {
  constructor() {
    super(new Ec("void", null));
  }
  toString() {
    return "void";
  }
}
B1.void = new B1();
let Et = class b5 extends Ef {
  constructor(e, t) {
    super(t), this.typeInfo.name === "i32" || this.typeInfo.name === "u32" ? e = Math.floor(e) : this.typeInfo.name === "bool" && (e = e ? 1 : 0), this.value = e;
  }
  setDataValue(e, t, n, i) {
    n ? console.error("SetDataValue: Scalar data does not support postfix", n) : t instanceof b5 ? (t.value, this.typeInfo.name === "i32" || this.typeInfo.name === "u32" || this.typeInfo.name, this.value = t.value) : console.error("SetDataValue: Invalid value", t);
  }
  getDataValue(e, t, n) {
    return t ? (console.error("GetDataValue: Scalar data does not support postfix", t), null) : this;
  }
  toString() {
    return `${this.value}`;
  }
};
function v5(r, e, t) {
  const n = e.length;
  return n === 2 ? t === "f32" ? new je(e, r.getTypeInfo("vec2f")) : t === "i32" ? new je(e, r.getTypeInfo("vec2i")) : t === "u32" ? new je(e, r.getTypeInfo("vec2u")) : t === "f16" ? new je(e, r.getTypeInfo("vec2h")) : (console.error(`GetDataValue: Unknown format ${t}`), null) : n === 3 ? t === "f32" ? new je(e, r.getTypeInfo("vec3f")) : t === "i32" ? new je(e, r.getTypeInfo("vec3i")) : t === "u32" ? new je(e, r.getTypeInfo("vec3u")) : t === "f16" ? new je(e, r.getTypeInfo("vec3h")) : (console.error(`GetDataValue: Unknown format ${t}`), null) : n === 4 ? t === "f32" ? new je(e, r.getTypeInfo("vec4f")) : t === "i32" ? new je(e, r.getTypeInfo("vec4i")) : t === "u32" ? new je(e, r.getTypeInfo("vec4u")) : t === "f16" ? new je(e, r.getTypeInfo("vec4h")) : (console.error(`GetDataValue: Unknown format ${t}`), null) : (console.error(`GetDataValue: Invalid vector size ${e.length}`), null);
}
class je extends Ef {
  constructor(e, t) {
    super(t), Array.isArray(e) ? this.value = e : this.value = Array.from(e);
  }
  setDataValue(e, t, n, i) {
    n instanceof Sf ? console.error("TODO: Set vector postfix") : t instanceof je ? this.value = t.value : console.error("SetDataValue: Invalid value", t);
  }
  getDataValue(e, t, n) {
    let i = e.getTypeInfo("f32");
    if (this.typeInfo instanceof Rh) i = this.typeInfo.format;
    else {
      const s = this.typeInfo.name;
      s === "vec2f" || s === "vec3f" || s === "vec4f" ? i = e.getTypeInfo("f32") : s === "vec2i" || s === "vec3i" || s === "vec4i" ? i = e.getTypeInfo("i32") : s === "vec2u" || s === "vec3u" || s === "vec4u" ? i = e.getTypeInfo("u32") : s === "vec2h" || s === "vec3h" || s === "vec4h" ? i = e.getTypeInfo("f16") : console.error(`GetDataValue: Unknown type ${s}`);
    }
    if (t instanceof Fd) {
      const s = t.index;
      let l = -1;
      if (s instanceof as) {
        if (!(s.value instanceof Et)) return console.error(`GetValueData: Invalid array index ${s.value}`), null;
        l = s.value.value;
      } else {
        const o = e.evalExpression(s, n);
        if (!(o instanceof Et)) return console.error("GetDataValue: Unknown index type", s), null;
        l = o.value;
      }
      return l < 0 || l >= this.value.length ? (console.error("GetDataValue: Index out of range", l), null) : new Et(this.value[l], i);
    }
    if (t instanceof Sf) {
      const s = t.value, l = [];
      for (const o of s) o === "x" || o === "r" ? l.push(this.value[0]) : o === "y" || o === "g" ? l.push(this.value[1]) : o === "z" || o === "b" ? l.push(this.value[2]) : o === "w" || o === "a" ? l.push(this.value[3]) : console.error(`GetDataValue: Unknown member ${o}`);
      return l.length === 1 ? new Et(l[0], i) : v5(e, l, i.name);
    }
    return this;
  }
  toString() {
    let e = `${this.value[0]}`;
    for (let t = 1; t < this.value.length; ++t) e += `, ${this.value[t]}`;
    return e;
  }
}
class Hn extends Ef {
  constructor(e, t) {
    super(t), this.value = e;
  }
  setDataValue(e, t, n, i) {
    n instanceof Sf ? console.error("TODO: Set matrix postfix") : t instanceof Hn ? this.value = t.value : console.error("SetDataValue: Invalid value", t);
  }
  getDataValue(e, t, n) {
    const i = this.typeInfo.name;
    let s = e.getTypeInfo("f32");
    if (this.typeInfo instanceof Rh) s = this.typeInfo.format;
    else if (i.endsWith("f")) s = e.getTypeInfo("f32");
    else if (i.endsWith("i")) s = e.getTypeInfo("i32");
    else if (i.endsWith("u")) s = e.getTypeInfo("u32");
    else {
      if (!i.endsWith("h")) return console.error(`GetDataValue: Unknown type ${i}`), null;
      s = e.getTypeInfo("f16");
    }
    if (t instanceof Fd) {
      const l = t.index;
      let o, d = -1;
      if (l instanceof as) {
        if (!(l.value instanceof Et)) return console.error(`GetDataValue: Invalid array index ${l.value}`), null;
        d = l.value.value;
      } else {
        const b = e.evalExpression(l, n);
        if (!(b instanceof Et)) return console.error("GetDataValue: Unknown index type", l), null;
        d = b.value;
      }
      if (d < 0 || d >= this.value.length) return console.error("GetDataValue: Index out of range", d), null;
      if (i === "mat2x2" || i === "mat2x2f" || i === "mat2x2h") o = this.value.slice(2 * d, 2 * d + 2);
      else if (i === "mat2x3" || i === "mat2x3f" || i === "mat2x3h") o = this.value.slice(3 * d, 3 * d + 3);
      else if (i === "mat2x4" || i === "mat2x4f" || i === "mat2x4h") o = this.value.slice(4 * d, 4 * d + 4);
      else if (i === "mat3x2" || i === "mat3x2f" || i === "mat3x2h") o = this.value.slice(2 * d, 2 * d + 2);
      else if (i === "mat3x3" || i === "mat3x3f" || i === "mat3x3h") o = this.value.slice(3 * d, 3 * d + 3);
      else if (i === "mat3x4" || i === "mat3x4f" || i === "mat3x4h") o = this.value.slice(4 * d, 4 * d + 4);
      else if (i === "mat4x2" || i === "mat4x2f" || i === "mat4x2h") o = this.value.slice(2 * d, 2 * d + 2);
      else if (i === "mat4x3" || i === "mat4x3f" || i === "mat4x3h") o = this.value.slice(3 * d, 3 * d + 3);
      else {
        if (i !== "mat4x4" && i !== "mat4x4f" && i !== "mat4x4h") return console.error(`GetDataValue: Unknown type ${i}`), null;
        o = this.value.slice(4 * d, 4 * d + 4);
      }
      const m = v5(e, o, s.name);
      if (t.postfix) return m.getDataValue(e, t.postfix, n);
    }
    return this;
  }
  toString() {
    let e = `${this.value[0]}`;
    for (let t = 1; t < this.value.length; ++t) e += `, ${this.value[t]}`;
    return e;
  }
}
class ls extends Ef {
  constructor(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 ? arguments[3] : void 0;
    super(t), this.textureSize = [0, 0, 0], this.buffer = e instanceof ArrayBuffer ? e : e.buffer, this.offset = n, i !== void 0 && (this.textureSize = i);
  }
  setDataValue(e, t, n, i) {
    if (t === null) return void console.log("setDataValue: NULL data.");
    let s = this.offset, l = this.typeInfo;
    for (; n; ) {
      if (n instanceof Fd)
        if (l instanceof _f) {
          const o = n.index;
          if (o instanceof as) {
            if (!(o.value instanceof Et)) return void console.error(`SetDataValue: Invalid index type ${o.value}`);
            s += o.value.value * l.stride;
          } else {
            const d = e.evalExpression(o, i);
            if (!(d instanceof Et)) return void console.error("SetDataValue: Unknown index type", o);
            s += d.value * l.stride;
          }
          l = l.format;
        } else console.error(`SetDataValue: Type ${e.getTypeName(l)} is not an array`);
      else {
        if (!(n instanceof Sf)) return void console.error("SetDataValue: Unknown postfix type", n);
        {
          const o = n.value;
          if (l instanceof wh) {
            let d = !1;
            for (const m of l.members) if (m.name === o) {
              s += m.offset, l = m.type, d = !0;
              break;
            }
            if (!d) return void console.error(`SetDataValue: Member ${o} not found`);
          } else if (l instanceof Ec) {
            const d = e.getTypeName(l);
            let m = 0;
            if (o === "x" || o === "r") m = 0;
            else if (o === "y" || o === "g") m = 1;
            else if (o === "z" || o === "b") m = 2;
            else {
              if (o !== "w" && o !== "a") return void console.error(`SetDataValue: Unknown member ${o}`);
              m = 3;
            }
            if (!(t instanceof Et)) return void console.error("SetDataValue: Invalid value", t);
            const b = t.value;
            return d === "vec2f" ? void (new Float32Array(this.buffer, s, 2)[m] = b) : d === "vec3f" ? void (new Float32Array(this.buffer, s, 3)[m] = b) : d === "vec4f" ? void (new Float32Array(this.buffer, s, 4)[m] = b) : d === "vec2i" ? void (new Int32Array(this.buffer, s, 2)[m] = b) : d === "vec3i" ? void (new Int32Array(this.buffer, s, 3)[m] = b) : d === "vec4i" ? void (new Int32Array(this.buffer, s, 4)[m] = b) : d === "vec2u" ? void (new Uint32Array(this.buffer, s, 2)[m] = b) : d === "vec3u" ? void (new Uint32Array(this.buffer, s, 3)[m] = b) : d === "vec4u" ? void (new Uint32Array(this.buffer, s, 4)[m] = b) : void console.error(`SetDataValue: Type ${d} is not a struct`);
          }
        }
      }
      n = n.postfix;
    }
    this.setData(e, t, l, s, i);
  }
  setData(e, t, n, i, s) {
    const l = e.getTypeName(n);
    if (l !== "f32" && l !== "f16")
      if (l !== "i32" && l !== "atomic<i32>" && l !== "x32")
        if (l !== "u32" && l !== "atomic<u32>")
          if (l !== "bool")
            if (l !== "vec2f" && l !== "vec2h")
              if (l !== "vec3f" && l !== "vec3h")
                if (l !== "vec4f" && l !== "vec4h")
                  if (l !== "vec2i")
                    if (l !== "vec3i")
                      if (l !== "vec4i")
                        if (l !== "vec2u")
                          if (l !== "vec3u")
                            if (l !== "vec4u")
                              if (l !== "vec2b")
                                if (l !== "vec3b")
                                  if (l !== "vec4b")
                                    if (l !== "mat2x2f" && l !== "mat2x2h")
                                      if (l !== "mat2x3f" && l !== "mat2x3h")
                                        if (l !== "mat2x4f" && l !== "mat2x4h")
                                          if (l !== "mat3x2f" && l !== "mat3x2h")
                                            if (l !== "mat3x3f" && l !== "mat3x3h")
                                              if (l !== "mat3x4f" && l !== "mat3x4h")
                                                if (l !== "mat4x2f" && l !== "mat4x2h")
                                                  if (l !== "mat4x3f" && l !== "mat4x3h")
                                                    if (l !== "mat4x4f" && l !== "mat4x4h")
                                                      if (t instanceof ls) {
                                                        if (n === t.typeInfo)
                                                          return void new Uint8Array(this.buffer, i, t.buffer.byteLength).set(new Uint8Array(t.buffer));
                                                        console.error("SetDataValue: Type mismatch", l, e.getTypeName(t.typeInfo));
                                                      } else console.error(`SetData: Unknown type ${l}`);
                                                    else {
                                                      const o = new Float32Array(this.buffer, i, 16);
                                                      t instanceof Hn ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3], o[4] = t.value[4], o[5] = t.value[5], o[6] = t.value[6], o[7] = t.value[7], o[8] = t.value[8], o[9] = t.value[9], o[10] = t.value[10], o[11] = t.value[11], o[12] = t.value[12], o[13] = t.value[13], o[14] = t.value[14], o[15] = t.value[15]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11], o[12] = t[12], o[13] = t[13], o[14] = t[14], o[15] = t[15]);
                                                    }
                                                  else {
                                                    const o = new Float32Array(this.buffer, i, 12);
                                                    t instanceof Hn ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3], o[4] = t.value[4], o[5] = t.value[5], o[6] = t.value[6], o[7] = t.value[7], o[8] = t.value[8], o[9] = t.value[9], o[10] = t.value[10], o[11] = t.value[11]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11]);
                                                  }
                                                else {
                                                  const o = new Float32Array(this.buffer, i, 8);
                                                  t instanceof Hn ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3], o[4] = t.value[4], o[5] = t.value[5], o[6] = t.value[6], o[7] = t.value[7]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7]);
                                                }
                                              else {
                                                const o = new Float32Array(this.buffer, i, 12);
                                                t instanceof Hn ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3], o[4] = t.value[4], o[5] = t.value[5], o[6] = t.value[6], o[7] = t.value[7], o[8] = t.value[8], o[9] = t.value[9], o[10] = t.value[10], o[11] = t.value[11]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8], o[9] = t[9], o[10] = t[10], o[11] = t[11]);
                                              }
                                            else {
                                              const o = new Float32Array(this.buffer, i, 9);
                                              t instanceof Hn ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3], o[4] = t.value[4], o[5] = t.value[5], o[6] = t.value[6], o[7] = t.value[7], o[8] = t.value[8]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7], o[8] = t[8]);
                                            }
                                          else {
                                            const o = new Float32Array(this.buffer, i, 6);
                                            t instanceof Hn ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3], o[4] = t.value[4], o[5] = t.value[5]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5]);
                                          }
                                        else {
                                          const o = new Float32Array(this.buffer, i, 8);
                                          t instanceof Hn ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3], o[4] = t.value[4], o[5] = t.value[5], o[6] = t.value[6], o[7] = t.value[7]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5], o[6] = t[6], o[7] = t[7]);
                                        }
                                      else {
                                        const o = new Float32Array(this.buffer, i, 6);
                                        t instanceof Hn ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3], o[4] = t.value[4], o[5] = t.value[5]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3], o[4] = t[4], o[5] = t[5]);
                                      }
                                    else {
                                      const o = new Float32Array(this.buffer, i, 4);
                                      t instanceof Hn ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]);
                                    }
                                  else {
                                    const o = new Uint32Array(this.buffer, i, 4);
                                    t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]);
                                  }
                                else {
                                  const o = new Uint32Array(this.buffer, i, 3);
                                  t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]);
                                }
                              else {
                                const o = new Uint32Array(this.buffer, i, 2);
                                t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1]) : (o[0] = t[0], o[1] = t[1]);
                              }
                            else {
                              const o = new Uint32Array(this.buffer, i, 4);
                              t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]);
                            }
                          else {
                            const o = new Uint32Array(this.buffer, i, 3);
                            t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]);
                          }
                        else {
                          const o = new Uint32Array(this.buffer, i, 2);
                          t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1]) : (o[0] = t[0], o[1] = t[1]);
                        }
                      else {
                        const o = new Int32Array(this.buffer, i, 4);
                        t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]);
                      }
                    else {
                      const o = new Int32Array(this.buffer, i, 3);
                      t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]);
                    }
                  else {
                    const o = new Int32Array(this.buffer, i, 2);
                    t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1]) : (o[0] = t[0], o[1] = t[1]);
                  }
                else {
                  const o = new Float32Array(this.buffer, i, 4);
                  t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2], o[3] = t.value[3]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2], o[3] = t[3]);
                }
              else {
                const o = new Float32Array(this.buffer, i, 3);
                t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1], o[2] = t.value[2]) : (o[0] = t[0], o[1] = t[1], o[2] = t[2]);
              }
            else {
              const o = new Float32Array(this.buffer, i, 2);
              t instanceof je ? (o[0] = t.value[0], o[1] = t.value[1]) : (o[0] = t[0], o[1] = t[1]);
            }
          else t instanceof Et && (new Int32Array(this.buffer, i, 1)[0] = t.value);
        else t instanceof Et && (new Uint32Array(this.buffer, i, 1)[0] = t.value);
      else t instanceof Et && (new Int32Array(this.buffer, i, 1)[0] = t.value);
    else t instanceof Et && (new Float32Array(this.buffer, i, 1)[0] = t.value);
  }
  getDataValue(e, t, n) {
    let i = this.offset, s = this.typeInfo;
    for (; t; ) {
      if (t instanceof Fd) {
        const o = t.index, d = e.evalExpression(o, n);
        let m = 0;
        if (d instanceof Et ? m = d.value : console.error("GetDataValue: Invalid index type", o), s instanceof _f) i += m * s.stride, s = s.format;
        else {
          const b = e.getTypeName(s);
          b === "mat4x4" || b === "mat4x4f" || b === "mat4x4h" ? (i += 16 * m, s = e.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${e.getTypeName(s)} is not an array`);
        }
      } else {
        if (!(t instanceof Sf)) return console.error("GetDataValue: Unknown postfix type", t), null;
        {
          const o = t.value;
          if (s instanceof wh) {
            let d = !1;
            for (const m of s.members) if (m.name === o) {
              i += m.offset, s = m.type, d = !0;
              break;
            }
            if (!d) return console.error(`GetDataValue: Member ${o} not found`), null;
          } else if (s instanceof Ec) {
            const d = e.getTypeName(s);
            if (d === "vec2f" || d === "vec3f" || d === "vec4f" || d === "vec2i" || d === "vec3i" || d === "vec4i" || d === "vec2u" || d === "vec3u" || d === "vec4u" || d === "vec2b" || d === "vec3b" || d === "vec4b" || d === "vec2h" || d === "vec3h" || d === "vec4h" || d === "vec2" || d === "vec3" || d === "vec4") {
              if (o.length > 0 && o.length < 5) {
                let m = "f32", b = "f";
                const T = [];
                for (let M = 0; M < o.length; ++M) {
                  const E = o[M].toLocaleLowerCase();
                  let D = 0;
                  if (E === "x" || E === "r") D = 0;
                  else if (E === "y" || E === "g") D = 1;
                  else if (E === "z" || E === "b") D = 2;
                  else {
                    if (E !== "w" && E !== "a") return console.error(`Unknown member ${o}`), null;
                    D = 3;
                  }
                  if (d === "vec2f") T.push(new Float32Array(this.buffer, i, 2)[D]);
                  else if (d === "vec3f") {
                    if (i + 12 >= this.buffer.byteLength) return console.log("Insufficient buffer data"), null;
                    const U = new Float32Array(this.buffer, i, 3);
                    T.push(U[D]);
                  } else if (d === "vec4f") T.push(new Float32Array(this.buffer, i, 4)[D]);
                  else if (d === "vec2i") m = "i32", b = "i", T.push(new Int32Array(this.buffer, i, 2)[D]);
                  else if (d === "vec3i") m = "i32", b = "i", T.push(new Int32Array(this.buffer, i, 3)[D]);
                  else if (d === "vec4i") m = "i32", b = "i", T.push(new Int32Array(this.buffer, i, 4)[D]);
                  else if (d === "vec2u") {
                    m = "u32", b = "u";
                    const U = new Uint32Array(this.buffer, i, 2);
                    T.push(U[D]);
                  } else d === "vec3u" ? (m = "u32", b = "u", T.push(new Uint32Array(this.buffer, i, 3)[D])) : d === "vec4u" && (m = "u32", b = "u", T.push(new Uint32Array(this.buffer, i, 4)[D]));
                }
                return T.length === 1 ? new Et(T[0], e.getTypeInfo(m)) : (T.length === 2 ? s = e.getTypeInfo(`vec2${b}`) : T.length === 3 ? s = e.getTypeInfo(`vec3${b}`) : T.length === 4 ? s = e.getTypeInfo(`vec4${b}`) : console.error(`GetDataValue: Invalid vector length ${T.length}`), new je(T, s));
              }
              return console.error(`GetDataValue: Unknown member ${o}`), null;
            }
            return console.error(`GetDataValue: Type ${d} is not a struct`), null;
          }
        }
      }
      t = t.postfix;
    }
    const l = e.getTypeName(s);
    return l === "f32" ? new Et(new Float32Array(this.buffer, i, 1)[0], s) : l === "i32" ? new Et(new Int32Array(this.buffer, i, 1)[0], s) : l === "u32" ? new Et(new Uint32Array(this.buffer, i, 1)[0], s) : l === "vec2f" ? new je(new Float32Array(this.buffer, i, 2), s) : l === "vec3f" ? new je(new Float32Array(this.buffer, i, 3), s) : l === "vec4f" ? new je(new Float32Array(this.buffer, i, 4), s) : l === "vec2i" ? new je(new Int32Array(this.buffer, i, 2), s) : l === "vec3i" ? new je(new Int32Array(this.buffer, i, 3), s) : l === "vec4i" ? new je(new Int32Array(this.buffer, i, 4), s) : l === "vec2u" ? new je(new Uint32Array(this.buffer, i, 2), s) : l === "vec3u" ? new je(new Uint32Array(this.buffer, i, 3), s) : l === "vec4u" ? new je(new Uint32Array(this.buffer, i, 4), s) : s instanceof Rh && s.name === "atomic" ? s.format.name === "u32" ? new Et(new Uint32Array(this.buffer, i, 1)[0], s.format) : s.format.name === "i32" ? new Et(new Int32Array(this.buffer, i, 1)[0], s.format) : (console.error(`GetDataValue: Invalid atomic format ${s.format.name}`), null) : new ls(this.buffer, s, i);
  }
  toString() {
    let e = "";
    if (this.typeInfo instanceof _f)
      if (this.typeInfo.format.name === "f32") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;
      } else if (this.typeInfo.format.name === "i32") {
        const t = new Int32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;
      } else if (this.typeInfo.format.name === "u32") {
        const t = new Uint32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let n = 1; n < t.length; ++n) e += `, ${t[n]}`;
      } else if (this.typeInfo.format.name === "vec2f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}]`;
        for (let n = 1; n < t.length / 2; ++n) e += `, [${t[2 * n]}, ${t[2 * n + 1]}]`;
      } else if (this.typeInfo.format.name === "vec3f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}, ${t[2]}]`;
        for (let n = 4; n < t.length; n += 4) e += `, [${t[n]}, ${t[n + 1]}, ${t[n + 2]}]`;
      } else if (this.typeInfo.format.name === "vec4f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}]`;
        for (let n = 4; n < t.length; n += 4) e += `, [${t[n]}, ${t[n + 1]}, ${t[n + 2]}, ${t[n + 3]}]`;
      } else e = "[...]";
    else this.typeInfo instanceof wh ? e += "{...}" : e = "[...]";
    return e;
  }
}
((r) => {
  r[r.token = 0] = "token", r[r.keyword = 1] = "keyword", r[r.reserved = 2] = "reserved";
})(at || (at = {}));
let ut = class {
  constructor(e, t, n) {
    this.name = e, this.type = t, this.rule = n;
  }
  toString() {
    return this.name;
  }
};
class Ee {
}
At = Ee, Ee.none = new ut("", at.reserved, ""), Ee.eof = new ut("EOF", at.token, ""), Ee.reserved = {
  asm: new ut("asm", at.reserved, "asm"),
  bf16: new ut("bf16", at.reserved, "bf16"),
  do: new ut("do", at.reserved, "do"),
  enum: new ut("enum", at.reserved, "enum"),
  f16: new ut("f16", at.reserved, "f16"),
  f64: new ut("f64", at.reserved, "f64"),
  handle: new ut("handle", at.reserved, "handle"),
  i8: new ut("i8", at.reserved, "i8"),
  i16: new ut("i16", at.reserved, "i16"),
  i64: new ut("i64", at.reserved, "i64"),
  mat: new ut("mat", at.reserved, "mat"),
  premerge: new ut("premerge", at.reserved, "premerge"),
  regardless: new ut("regardless", at.reserved, "regardless"),
  typedef: new ut("typedef", at.reserved, "typedef"),
  u8: new ut("u8", at.reserved, "u8"),
  u16: new ut("u16", at.reserved, "u16"),
  u64: new ut("u64", at.reserved, "u64"),
  unless: new ut("unless", at.reserved, "unless"),
  using: new ut("using", at.reserved, "using"),
  vec: new ut("vec", at.reserved, "vec"),
  void: new ut("void", at.reserved, "void")
}, Ee.keywords = {
  array: new ut("array", at.keyword, "array"),
  atomic: new ut("atomic", at.keyword, "atomic"),
  bool: new ut("bool", at.keyword, "bool"),
  f32: new ut("f32", at.keyword, "f32"),
  i32: new ut("i32", at.keyword, "i32"),
  mat2x2: new ut("mat2x2", at.keyword, "mat2x2"),
  mat2x3: new ut("mat2x3", at.keyword, "mat2x3"),
  mat2x4: new ut("mat2x4", at.keyword, "mat2x4"),
  mat3x2: new ut("mat3x2", at.keyword, "mat3x2"),
  mat3x3: new ut("mat3x3", at.keyword, "mat3x3"),
  mat3x4: new ut("mat3x4", at.keyword, "mat3x4"),
  mat4x2: new ut("mat4x2", at.keyword, "mat4x2"),
  mat4x3: new ut("mat4x3", at.keyword, "mat4x3"),
  mat4x4: new ut("mat4x4", at.keyword, "mat4x4"),
  ptr: new ut("ptr", at.keyword, "ptr"),
  sampler: new ut("sampler", at.keyword, "sampler"),
  sampler_comparison: new ut("sampler_comparison", at.keyword, "sampler_comparison"),
  struct: new ut("struct", at.keyword, "struct"),
  texture_1d: new ut("texture_1d", at.keyword, "texture_1d"),
  texture_2d: new ut("texture_2d", at.keyword, "texture_2d"),
  texture_2d_array: new ut("texture_2d_array", at.keyword, "texture_2d_array"),
  texture_3d: new ut("texture_3d", at.keyword, "texture_3d"),
  texture_cube: new ut("texture_cube", at.keyword, "texture_cube"),
  texture_cube_array: new ut("texture_cube_array", at.keyword, "texture_cube_array"),
  texture_multisampled_2d: new ut("texture_multisampled_2d", at.keyword, "texture_multisampled_2d"),
  texture_storage_1d: new ut("texture_storage_1d", at.keyword, "texture_storage_1d"),
  texture_storage_2d: new ut("texture_storage_2d", at.keyword, "texture_storage_2d"),
  texture_storage_2d_array: new ut("texture_storage_2d_array", at.keyword, "texture_storage_2d_array"),
  texture_storage_3d: new ut("texture_storage_3d", at.keyword, "texture_storage_3d"),
  texture_depth_2d: new ut("texture_depth_2d", at.keyword, "texture_depth_2d"),
  texture_depth_2d_array: new ut("texture_depth_2d_array", at.keyword, "texture_depth_2d_array"),
  texture_depth_cube: new ut("texture_depth_cube", at.keyword, "texture_depth_cube"),
  texture_depth_cube_array: new ut("texture_depth_cube_array", at.keyword, "texture_depth_cube_array"),
  texture_depth_multisampled_2d: new ut("texture_depth_multisampled_2d", at.keyword, "texture_depth_multisampled_2d"),
  texture_external: new ut("texture_external", at.keyword, "texture_external"),
  u32: new ut("u32", at.keyword, "u32"),
  vec2: new ut("vec2", at.keyword, "vec2"),
  vec3: new ut("vec3", at.keyword, "vec3"),
  vec4: new ut("vec4", at.keyword, "vec4"),
  bitcast: new ut("bitcast", at.keyword, "bitcast"),
  block: new ut("block", at.keyword, "block"),
  break: new ut("break", at.keyword, "break"),
  case: new ut("case", at.keyword, "case"),
  continue: new ut("continue", at.keyword, "continue"),
  continuing: new ut("continuing", at.keyword, "continuing"),
  default: new ut("default", at.keyword, "default"),
  diagnostic: new ut("diagnostic", at.keyword, "diagnostic"),
  discard: new ut("discard", at.keyword, "discard"),
  else: new ut("else", at.keyword, "else"),
  enable: new ut("enable", at.keyword, "enable"),
  fallthrough: new ut("fallthrough", at.keyword, "fallthrough"),
  false: new ut("false", at.keyword, "false"),
  fn: new ut("fn", at.keyword, "fn"),
  for: new ut("for", at.keyword, "for"),
  function: new ut("function", at.keyword, "function"),
  if: new ut("if", at.keyword, "if"),
  let: new ut("let", at.keyword, "let"),
  const: new ut("const", at.keyword, "const"),
  loop: new ut("loop", at.keyword, "loop"),
  while: new ut("while", at.keyword, "while"),
  private: new ut("private", at.keyword, "private"),
  read: new ut("read", at.keyword, "read"),
  read_write: new ut("read_write", at.keyword, "read_write"),
  return: new ut("return", at.keyword, "return"),
  requires: new ut("requires", at.keyword, "requires"),
  storage: new ut("storage", at.keyword, "storage"),
  switch: new ut("switch", at.keyword, "switch"),
  true: new ut("true", at.keyword, "true"),
  alias: new ut("alias", at.keyword, "alias"),
  type: new ut("type", at.keyword, "type"),
  uniform: new ut("uniform", at.keyword, "uniform"),
  var: new ut("var", at.keyword, "var"),
  override: new ut("override", at.keyword, "override"),
  workgroup: new ut("workgroup", at.keyword, "workgroup"),
  write: new ut("write", at.keyword, "write"),
  r8unorm: new ut("r8unorm", at.keyword, "r8unorm"),
  r8snorm: new ut("r8snorm", at.keyword, "r8snorm"),
  r8uint: new ut("r8uint", at.keyword, "r8uint"),
  r8sint: new ut("r8sint", at.keyword, "r8sint"),
  r16uint: new ut("r16uint", at.keyword, "r16uint"),
  r16sint: new ut("r16sint", at.keyword, "r16sint"),
  r16float: new ut("r16float", at.keyword, "r16float"),
  rg8unorm: new ut("rg8unorm", at.keyword, "rg8unorm"),
  rg8snorm: new ut("rg8snorm", at.keyword, "rg8snorm"),
  rg8uint: new ut("rg8uint", at.keyword, "rg8uint"),
  rg8sint: new ut("rg8sint", at.keyword, "rg8sint"),
  r32uint: new ut("r32uint", at.keyword, "r32uint"),
  r32sint: new ut("r32sint", at.keyword, "r32sint"),
  r32float: new ut("r32float", at.keyword, "r32float"),
  rg16uint: new ut("rg16uint", at.keyword, "rg16uint"),
  rg16sint: new ut("rg16sint", at.keyword, "rg16sint"),
  rg16float: new ut("rg16float", at.keyword, "rg16float"),
  rgba8unorm: new ut("rgba8unorm", at.keyword, "rgba8unorm"),
  rgba8unorm_srgb: new ut("rgba8unorm_srgb", at.keyword, "rgba8unorm_srgb"),
  rgba8snorm: new ut("rgba8snorm", at.keyword, "rgba8snorm"),
  rgba8uint: new ut("rgba8uint", at.keyword, "rgba8uint"),
  rgba8sint: new ut("rgba8sint", at.keyword, "rgba8sint"),
  bgra8unorm: new ut("bgra8unorm", at.keyword, "bgra8unorm"),
  bgra8unorm_srgb: new ut("bgra8unorm_srgb", at.keyword, "bgra8unorm_srgb"),
  rgb10a2unorm: new ut("rgb10a2unorm", at.keyword, "rgb10a2unorm"),
  rg11b10float: new ut("rg11b10float", at.keyword, "rg11b10float"),
  rg32uint: new ut("rg32uint", at.keyword, "rg32uint"),
  rg32sint: new ut("rg32sint", at.keyword, "rg32sint"),
  rg32float: new ut("rg32float", at.keyword, "rg32float"),
  rgba16uint: new ut("rgba16uint", at.keyword, "rgba16uint"),
  rgba16sint: new ut("rgba16sint", at.keyword, "rgba16sint"),
  rgba16float: new ut("rgba16float", at.keyword, "rgba16float"),
  rgba32uint: new ut("rgba32uint", at.keyword, "rgba32uint"),
  rgba32sint: new ut("rgba32sint", at.keyword, "rgba32sint"),
  rgba32float: new ut("rgba32float", at.keyword, "rgba32float"),
  static_assert: new ut("static_assert", at.keyword, "static_assert")
}, Ee.tokens = {
  decimal_float_literal: new ut("decimal_float_literal", at.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),
  hex_float_literal: new ut("hex_float_literal", at.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),
  int_literal: new ut("int_literal", at.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
  uint_literal: new ut("uint_literal", at.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
  name: new ut("name", at.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
  ident: new ut("ident", at.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
  and: new ut("and", at.token, "&"),
  and_and: new ut("and_and", at.token, "&&"),
  arrow: new ut("arrow ", at.token, "->"),
  attr: new ut("attr", at.token, "@"),
  forward_slash: new ut("forward_slash", at.token, "/"),
  bang: new ut("bang", at.token, "!"),
  bracket_left: new ut("bracket_left", at.token, "["),
  bracket_right: new ut("bracket_right", at.token, "]"),
  brace_left: new ut("brace_left", at.token, "{"),
  brace_right: new ut("brace_right", at.token, "}"),
  colon: new ut("colon", at.token, ":"),
  comma: new ut("comma", at.token, ","),
  equal: new ut("equal", at.token, "="),
  equal_equal: new ut("equal_equal", at.token, "=="),
  not_equal: new ut("not_equal", at.token, "!="),
  greater_than: new ut("greater_than", at.token, ">"),
  greater_than_equal: new ut("greater_than_equal", at.token, ">="),
  shift_right: new ut("shift_right", at.token, ">>"),
  less_than: new ut("less_than", at.token, "<"),
  less_than_equal: new ut("less_than_equal", at.token, "<="),
  shift_left: new ut("shift_left", at.token, "<<"),
  modulo: new ut("modulo", at.token, "%"),
  minus: new ut("minus", at.token, "-"),
  minus_minus: new ut("minus_minus", at.token, "--"),
  period: new ut("period", at.token, "."),
  plus: new ut("plus", at.token, "+"),
  plus_plus: new ut("plus_plus", at.token, "++"),
  or: new ut("or", at.token, "|"),
  or_or: new ut("or_or", at.token, "||"),
  paren_left: new ut("paren_left", at.token, "("),
  paren_right: new ut("paren_right", at.token, ")"),
  semicolon: new ut("semicolon", at.token, ";"),
  star: new ut("star", at.token, "*"),
  tilde: new ut("tilde", at.token, "~"),
  underscore: new ut("underscore", at.token, "_"),
  xor: new ut("xor", at.token, "^"),
  plus_equal: new ut("plus_equal", at.token, "+="),
  minus_equal: new ut("minus_equal", at.token, "-="),
  times_equal: new ut("times_equal", at.token, "*="),
  division_equal: new ut("division_equal", at.token, "/="),
  modulo_equal: new ut("modulo_equal", at.token, "%="),
  and_equal: new ut("and_equal", at.token, "&="),
  or_equal: new ut("or_equal", at.token, "|="),
  xor_equal: new ut("xor_equal", at.token, "^="),
  shift_right_equal: new ut("shift_right_equal", at.token, ">>="),
  shift_left_equal: new ut("shift_left_equal", at.token, "<<=")
}, Ee.simpleTokens = {
  "@": At.tokens.attr,
  "{": At.tokens.brace_left,
  "}": At.tokens.brace_right,
  ":": At.tokens.colon,
  ",": At.tokens.comma,
  "(": At.tokens.paren_left,
  ")": At.tokens.paren_right,
  ";": At.tokens.semicolon
}, Ee.literalTokens = {
  "&": At.tokens.and,
  "&&": At.tokens.and_and,
  "->": At.tokens.arrow,
  "/": At.tokens.forward_slash,
  "!": At.tokens.bang,
  "[": At.tokens.bracket_left,
  "]": At.tokens.bracket_right,
  "=": At.tokens.equal,
  "==": At.tokens.equal_equal,
  "!=": At.tokens.not_equal,
  ">": At.tokens.greater_than,
  ">=": At.tokens.greater_than_equal,
  ">>": At.tokens.shift_right,
  "<": At.tokens.less_than,
  "<=": At.tokens.less_than_equal,
  "<<": At.tokens.shift_left,
  "%": At.tokens.modulo,
  "-": At.tokens.minus,
  "--": At.tokens.minus_minus,
  ".": At.tokens.period,
  "+": At.tokens.plus,
  "++": At.tokens.plus_plus,
  "|": At.tokens.or,
  "||": At.tokens.or_or,
  "*": At.tokens.star,
  "~": At.tokens.tilde,
  _: At.tokens.underscore,
  "^": At.tokens.xor,
  "+=": At.tokens.plus_equal,
  "-=": At.tokens.minus_equal,
  "*=": At.tokens.times_equal,
  "/=": At.tokens.division_equal,
  "%=": At.tokens.modulo_equal,
  "&=": At.tokens.and_equal,
  "|=": At.tokens.or_equal,
  "^=": At.tokens.xor_equal,
  ">>=": At.tokens.shift_right_equal,
  "<<=": At.tokens.shift_left_equal
}, Ee.regexTokens = {
  decimal_float_literal: At.tokens.decimal_float_literal,
  hex_float_literal: At.tokens.hex_float_literal,
  int_literal: At.tokens.int_literal,
  uint_literal: At.tokens.uint_literal,
  ident: At.tokens.ident
}, Ee.storage_class = [At.keywords.function, At.keywords.private, At.keywords.workgroup, At.keywords.uniform, At.keywords.storage], Ee.access_mode = [At.keywords.read, At.keywords.write, At.keywords.read_write], Ee.sampler_type = [At.keywords.sampler, At.keywords.sampler_comparison], Ee.sampled_texture_type = [At.keywords.texture_1d, At.keywords.texture_2d, At.keywords.texture_2d_array, At.keywords.texture_3d, At.keywords.texture_cube, At.keywords.texture_cube_array], Ee.multisampled_texture_type = [At.keywords.texture_multisampled_2d], Ee.storage_texture_type = [At.keywords.texture_storage_1d, At.keywords.texture_storage_2d, At.keywords.texture_storage_2d_array, At.keywords.texture_storage_3d], Ee.depth_texture_type = [At.keywords.texture_depth_2d, At.keywords.texture_depth_2d_array, At.keywords.texture_depth_cube, At.keywords.texture_depth_cube_array, At.keywords.texture_depth_multisampled_2d], Ee.texture_external_type = [At.keywords.texture_external], Ee.any_texture_type = [...At.sampled_texture_type, ...At.multisampled_texture_type, ...At.storage_texture_type, ...At.depth_texture_type, ...At.texture_external_type], Ee.texel_format = [At.keywords.r8unorm, At.keywords.r8snorm, At.keywords.r8uint, At.keywords.r8sint, At.keywords.r16uint, At.keywords.r16sint, At.keywords.r16float, At.keywords.rg8unorm, At.keywords.rg8snorm, At.keywords.rg8uint, At.keywords.rg8sint, At.keywords.r32uint, At.keywords.r32sint, At.keywords.r32float, At.keywords.rg16uint, At.keywords.rg16sint, At.keywords.rg16float, At.keywords.rgba8unorm, At.keywords.rgba8unorm_srgb, At.keywords.rgba8snorm, At.keywords.rgba8uint, At.keywords.rgba8sint, At.keywords.bgra8unorm, At.keywords.bgra8unorm_srgb, At.keywords.rgb10a2unorm, At.keywords.rg11b10float, At.keywords.rg32uint, At.keywords.rg32sint, At.keywords.rg32float, At.keywords.rgba16uint, At.keywords.rgba16sint, At.keywords.rgba16float, At.keywords.rgba32uint, At.keywords.rgba32sint, At.keywords.rgba32float], Ee.const_literal = [At.tokens.int_literal, At.tokens.uint_literal, At.tokens.decimal_float_literal, At.tokens.hex_float_literal, At.keywords.true, At.keywords.false], Ee.literal_or_ident = [At.tokens.ident, At.tokens.int_literal, At.tokens.uint_literal, At.tokens.decimal_float_literal, At.tokens.hex_float_literal, At.tokens.name], Ee.element_count_expression = [At.tokens.int_literal, At.tokens.uint_literal, At.tokens.ident], Ee.template_types = [At.keywords.vec2, At.keywords.vec3, At.keywords.vec4, At.keywords.mat2x2, At.keywords.mat2x3, At.keywords.mat2x4, At.keywords.mat3x2, At.keywords.mat3x3, At.keywords.mat3x4, At.keywords.mat4x2, At.keywords.mat4x3, At.keywords.mat4x4, At.keywords.atomic, At.keywords.bitcast, ...At.any_texture_type], Ee.attribute_name = [At.tokens.ident, At.keywords.block, At.keywords.diagnostic], Ee.assignment_operators = [At.tokens.equal, At.tokens.plus_equal, At.tokens.minus_equal, At.tokens.times_equal, At.tokens.division_equal, At.tokens.modulo_equal, At.tokens.and_equal, At.tokens.or_equal, At.tokens.xor_equal, At.tokens.shift_right_equal, At.tokens.shift_left_equal], Ee.increment_operators = [At.tokens.plus_plus, At.tokens.minus_minus];
class LA {
  constructor(e, t, n) {
    this.type = e, this.lexeme = t, this.line = n;
  }
  toString() {
    return this.lexeme;
  }
  isTemplateType() {
    return Ee.template_types.indexOf(this.type) != -1;
  }
  isArrayType() {
    return this.type == Ee.keywords.array;
  }
  isArrayOrTemplateType() {
    return this.isArrayType() || this.isTemplateType();
  }
}
class V6 {
  constructor(e) {
    this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = e ?? "";
  }
  scanTokens() {
    for (; !this._isAtEnd(); ) if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
    return this._tokens.push(new LA(Ee.eof, "", this._line)), this._tokens;
  }
  scanToken() {
    let e = this._advance();
    if (e == `
`) return this._line++, !0;
    if (this._isWhitespace(e)) return !0;
    if (e == "/") {
      if (this._peekAhead() == "/") {
        for (; e != `
`; ) {
          if (this._isAtEnd()) return !0;
          e = this._advance();
        }
        return this._line++, !0;
      }
      if (this._peekAhead() == "*") {
        this._advance();
        let l = 1;
        for (; l > 0; ) {
          if (this._isAtEnd()) return !0;
          if (e = this._advance(), e == `
`) this._line++;
          else if (e == "*") {
            if (this._peekAhead() == "/" && (this._advance(), l--, l == 0)) return !0;
          } else e == "/" && this._peekAhead() == "*" && (this._advance(), l++);
        }
        return !0;
      }
    }
    const t = Ee.simpleTokens[e];
    if (t) return this._addToken(t), !0;
    let n = Ee.none;
    const i = this._isAlpha(e), s = e === "_";
    if (this._isAlphaNumeric(e)) {
      let l = this._peekAhead();
      for (; this._isAlphaNumeric(l); ) e += this._advance(), l = this._peekAhead();
    }
    if (i) {
      const l = Ee.keywords[e];
      if (l) return this._addToken(l), !0;
    }
    if (i || s) return this._addToken(Ee.tokens.ident), !0;
    for (; ; ) {
      let l = this._findType(e);
      const o = this._peekAhead();
      if (e == "-" && this._tokens.length > 0) {
        if (o == "=") return this._current++, e += o, this._addToken(Ee.tokens.minus_equal), !0;
        if (o == "-") return this._current++, e += o, this._addToken(Ee.tokens.minus_minus), !0;
        const d = this._tokens.length - 1;
        if ((Ee.literal_or_ident.indexOf(this._tokens[d].type) != -1 || this._tokens[d].type == Ee.tokens.paren_right) && o != ">") return this._addToken(l), !0;
      }
      if (e == ">" && (o == ">" || o == "=")) {
        let d = !1, m = this._tokens.length - 1;
        for (let b = 0; b < 5 && m >= 0 && Ee.assignment_operators.indexOf(this._tokens[m].type) === -1; ++b, --m) if (this._tokens[m].type === Ee.tokens.less_than) {
          m > 0 && this._tokens[m - 1].isArrayOrTemplateType() && (d = !0);
          break;
        }
        if (d) return this._addToken(l), !0;
      }
      if (l === Ee.none) {
        let d = e, m = 0;
        const b = 2;
        for (let T = 0; T < b; ++T) if (d += this._peekAhead(T), l = this._findType(d), l !== Ee.none) {
          m = T;
          break;
        }
        if (l === Ee.none) return n !== Ee.none && (this._current--, this._addToken(n), !0);
        e = d, this._current += m + 1;
      }
      if (n = l, this._isAtEnd()) break;
      e += this._advance();
    }
    return n !== Ee.none && (this._addToken(n), !0);
  }
  _findType(e) {
    for (const n in Ee.regexTokens) {
      const i = Ee.regexTokens[n];
      if (this._match(e, i.rule)) return i;
    }
    return Ee.literalTokens[e] || Ee.none;
  }
  _match(e, t) {
    const n = t.exec(e);
    return n && n.index == 0 && n[0] == e;
  }
  _isAtEnd() {
    return this._current >= this._source.length;
  }
  _isAlpha(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z";
  }
  _isAlphaNumeric(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z" || e == "_" || e >= "0" && e <= "9";
  }
  _isWhitespace(e) {
    return e == " " || e == "	" || e == "\r";
  }
  _advance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = this._source[this._current];
    return e = e || 0, e++, this._current += e, t;
  }
  _peekAhead() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return e = e || 0, this._current + e >= this._source.length ? "\0" : this._source[this._current + e];
  }
  _addToken(e) {
    const t = this._source.substring(this._start, this._current);
    this._tokens.push(new LA(e, t, this._line));
  }
}
class q6 {
  constructor(e) {
    this.resources = null, this.inUse = !1, this.info = null, this.node = e;
  }
}
class hm {
  constructor(e, t) {
    this.align = e, this.size = t;
  }
}
let tg = class Hp {
  constructor() {
    this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new R6(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map();
  }
  _isStorageTexture(e) {
    return e.name == "texture_storage_1d" || e.name == "texture_storage_2d" || e.name == "texture_storage_2d_array" || e.name == "texture_storage_3d";
  }
  updateAST(e) {
    for (const t of e) t instanceof P_ && this._functions.set(t.name, new q6(t));
    for (const t of e) if (t instanceof yh) {
      const n = this.getTypeInfo(t, null);
      n instanceof wh && this.structs.push(n);
    }
    for (const t of e) if (t instanceof i2) this.aliases.push(this._getAliasInfo(t));
    else if (t instanceof r2) {
      const n = t, i = this._getAttributeNum(n.attributes, "id", 0), s = n.type != null ? this.getTypeInfo(n.type, n.attributes) : null;
      this.overrides.push(new I6(n.name, s, n.attributes, i));
    } else if (this._isUniformVar(t)) {
      const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), l = this.getTypeInfo(n.type, n.attributes), o = new um(n.name, l, i, s, n.attributes, _h.Uniform, n.access);
      this.uniforms.push(o);
    } else if (this._isStorageVar(t)) {
      const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), l = this.getTypeInfo(n.type, n.attributes), o = this._isStorageTexture(l), d = new um(n.name, l, i, s, n.attributes, o ? _h.StorageTexture : _h.Storage, n.access);
      this.storage.push(d);
    } else if (this._isTextureVar(t)) {
      const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), l = this.getTypeInfo(n.type, n.attributes), o = this._isStorageTexture(l), d = new um(n.name, l, i, s, n.attributes, o ? _h.StorageTexture : _h.Texture, n.access);
      o ? this.storage.push(d) : this.textures.push(d);
    } else if (this._isSamplerVar(t)) {
      const n = t, i = this._getAttributeNum(n.attributes, "group", 0), s = this._getAttributeNum(n.attributes, "binding", 0), l = this.getTypeInfo(n.type, n.attributes), o = new um(n.name, l, i, s, n.attributes, _h.Sampler, n.access);
      this.samplers.push(o);
    } else if (t instanceof P_) {
      const n = this._getAttribute(t, "vertex"), i = this._getAttribute(t, "fragment"), s = this._getAttribute(t, "compute"), l = n || i || s, o = new P6(t.name, l == null ? void 0 : l.name, t.attributes);
      o.attributes = t.attributes, o.startLine = t.startLine, o.endLine = t.endLine, this.functions.push(o), this._functions.get(t.name).info = o, l && (this._functions.get(t.name).inUse = !0, o.inUse = !0, o.resources = this._findResources(t, !!l), o.inputs = this._getInputs(t.args), o.outputs = this._getOutputs(t.returnType), this.entry[l.name].push(o)), o.arguments = t.args.map((d) => new M6(d.name, this.getTypeInfo(d.type, d.attributes), d.attributes)), o.returnType = t.returnType ? this.getTypeInfo(t.returnType, t.attributes) : null;
    }
    for (const t of this._functions.values()) t.info && (t.info.inUse = t.inUse, this._addCalls(t.node, t.info.calls));
    for (const t of this._functions.values()) t.node.search((n) => {
      var i;
      if (n.astNodeType === "varExpr") {
        const s = n;
        for (const l of this.overrides) s.name == l.name && ((i = t.info) === null || i === void 0 || i.overrides.push(l));
      }
    });
    for (const t of this.uniforms) this._markStructsInUse(t.type);
    for (const t of this.storage) this._markStructsInUse(t.type);
  }
  getStructInfo(e) {
    for (const t of this.structs) if (t.name == e) return t;
    return null;
  }
  getOverrideInfo(e) {
    for (const t of this.overrides) if (t.name == e) return t;
    return null;
  }
  _markStructsInUse(e) {
    if (e) if (e.isStruct) {
      if (e.inUse = !0, e.members) for (const t of e.members) this._markStructsInUse(t.type);
    } else if (e.isArray) this._markStructsInUse(e.format);
    else if (e.isTemplate) e.format && this._markStructsInUse(e.format);
    else {
      const t = this._getAlias(e.name);
      t && this._markStructsInUse(t);
    }
  }
  _addCalls(e, t) {
    var n;
    for (const i of e.calls) {
      const s = (n = this._functions.get(i.name)) === null || n === void 0 ? void 0 : n.info;
      s && t.add(s);
    }
  }
  findResource(e, t) {
    for (const n of this.uniforms) if (n.group == e && n.binding == t) return n;
    for (const n of this.storage) if (n.group == e && n.binding == t) return n;
    for (const n of this.textures) if (n.group == e && n.binding == t) return n;
    for (const n of this.samplers) if (n.group == e && n.binding == t) return n;
    return null;
  }
  _findResource(e) {
    for (const t of this.uniforms) if (t.name == e) return t;
    for (const t of this.storage) if (t.name == e) return t;
    for (const t of this.textures) if (t.name == e) return t;
    for (const t of this.samplers) if (t.name == e) return t;
    return null;
  }
  _markStructsFromAST(e) {
    const t = this.getTypeInfo(e, null);
    this._markStructsInUse(t);
  }
  _findResources(e, t) {
    const n = [], i = this, s = [];
    return e.search((l) => {
      if (l instanceof I_) s.push({});
      else if (l instanceof M_) s.pop();
      else if (l instanceof xh) {
        const o = l;
        t && o.type !== null && this._markStructsFromAST(o.type), s.length > 0 && (s[s.length - 1][o.name] = o);
      } else if (l instanceof yf) {
        const o = l;
        t && o.type !== null && this._markStructsFromAST(o.type);
      } else if (l instanceof R_) {
        const o = l;
        t && o.type !== null && this._markStructsFromAST(o.type), s.length > 0 && (s[s.length - 1][o.name] = o);
      } else if (l instanceof Ch) {
        const o = l;
        if (s.length > 0 && s[s.length - 1][o.name])
          return;
        const d = i._findResource(o.name);
        d && n.push(d);
      } else if (l instanceof Kd) {
        const o = l, d = i._functions.get(o.name);
        d && (t && (d.inUse = !0), e.calls.add(d.node), d.resources === null && (d.resources = i._findResources(d.node, t)), n.push(...d.resources));
      } else if (l instanceof n2) {
        const o = l, d = i._functions.get(o.name);
        d && (t && (d.inUse = !0), e.calls.add(d.node), d.resources === null && (d.resources = i._findResources(d.node, t)), n.push(...d.resources));
      }
    }), [...new Map(n.map((l) => [l.name, l])).values()];
  }
  getBindGroups() {
    const e = [];
    function t(n, i) {
      n >= e.length && (e.length = n + 1), e[n] === void 0 && (e[n] = []), i >= e[n].length && (e[n].length = i + 1);
    }
    for (const n of this.uniforms)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    for (const n of this.storage)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    for (const n of this.textures)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    for (const n of this.samplers)
      t(n.group, n.binding), e[n.group][n.binding] = n;
    return e;
  }
  _getOutputs(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    if (t === void 0 && (t = []), e instanceof yh) this._getStructOutputs(e, t);
    else {
      const n = this._getOutputInfo(e);
      n !== null && t.push(n);
    }
    return t;
  }
  _getStructOutputs(e, t) {
    for (const n of e.members) if (n.type instanceof yh) this._getStructOutputs(n.type, t);
    else {
      const i = this._getAttribute(n, "location") || this._getAttribute(n, "builtin");
      if (i !== null) {
        const s = this.getTypeInfo(n.type, n.type.attributes), l = this._parseInt(i.value), o = new BA(n.name, s, i.name, l);
        t.push(o);
      }
    }
  }
  _getOutputInfo(e) {
    const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (t !== null) {
      const n = this.getTypeInfo(e, e.attributes), i = this._parseInt(t.value);
      return new BA("", n, t.name, i);
    }
    return null;
  }
  _getInputs(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
    t === void 0 && (t = []);
    for (const n of e) if (n.type instanceof yh) this._getStructInputs(n.type, t);
    else {
      const i = this._getInputInfo(n);
      i !== null && t.push(i);
    }
    return t;
  }
  _getStructInputs(e, t) {
    for (const n of e.members) if (n.type instanceof yh) this._getStructInputs(n.type, t);
    else {
      const i = this._getInputInfo(n);
      i !== null && t.push(i);
    }
  }
  _getInputInfo(e) {
    const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
    if (t !== null) {
      const n = this._getAttribute(e, "interpolation"), i = this.getTypeInfo(e.type, e.attributes), s = this._parseInt(t.value), l = new C6(e.name, i, t.name, s);
      return n !== null && (l.interpolation = this._parseString(n.value)), l;
    }
    return null;
  }
  _parseString(e) {
    return e instanceof Array && (e = e[0]), e;
  }
  _parseInt(e) {
    e instanceof Array && (e = e[0]);
    const t = parseInt(e);
    return isNaN(t) ? e : t;
  }
  _getAlias(e) {
    for (const t of this.aliases) if (t.name == e) return t.type;
    return null;
  }
  _getAliasInfo(e) {
    return new E6(e.name, this.getTypeInfo(e.type, null));
  }
  getTypeInfo(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (this._types.has(e)) return this._types.get(e);
    if (e instanceof f5) {
      const i = e, s = i.format ? this.getTypeInfo(i.format, i.attributes) : null, l = new _f(i.name, t);
      return l.format = s, l.count = i.count, this._types.set(e, l), this._updateTypeInfo(l), l;
    }
    if (e instanceof yh) {
      const i = e, s = new wh(i.name, t);
      s.startLine = i.startLine, s.endLine = i.endLine;
      for (const l of i.members) {
        const o = this.getTypeInfo(l.type, l.attributes);
        s.members.push(new RA(l.name, o, l.attributes));
      }
      return this._types.set(e, s), this._updateTypeInfo(s), s;
    }
    if (e instanceof $p) {
      const i = e, s = i.format instanceof ur, l = i.format ? s ? this.getTypeInfo(i.format, null) : new Ec(i.format, null) : null, o = new Rh(i.name, l, t, i.access);
      return this._types.set(e, o), this._updateTypeInfo(o), o;
    }
    if (e instanceof Ht) {
      const i = e, s = i.format ? this.getTypeInfo(i.format, null) : null, l = new Rh(i.name, s, t, i.access);
      return this._types.set(e, l), this._updateTypeInfo(l), l;
    }
    const n = new Ec(e.name, t);
    return this._types.set(e, n), this._updateTypeInfo(n), n;
  }
  _updateTypeInfo(e) {
    var t, n, i;
    const s = this._getTypeSize(e);
    if (e.size = (t = s == null ? void 0 : s.size) !== null && t !== void 0 ? t : 0, e instanceof _f && e.format) {
      const l = this._getTypeSize(e.format);
      e.stride = Math.max((n = l == null ? void 0 : l.size) !== null && n !== void 0 ? n : 0, (i = l == null ? void 0 : l.align) !== null && i !== void 0 ? i : 0), this._updateTypeInfo(e.format);
    }
    e instanceof wh && this._updateStructInfo(e);
  }
  _updateStructInfo(e) {
    var t;
    let n = 0, i = 0, s = 0, l = 0;
    for (let o = 0, d = e.members.length; o < d; ++o) {
      const m = e.members[o], b = this._getTypeSize(m);
      if (!b) continue;
      (t = this._getAlias(m.type.name)) !== null && t !== void 0 || m.type;
      const T = b.align, M = b.size;
      n = this._roundUp(T, n + i), i = M, s = n, l = Math.max(l, T), m.offset = n, m.size = M, this._updateTypeInfo(m.type);
    }
    e.size = this._roundUp(l, s + i), e.align = l;
  }
  _getTypeSize(e) {
    var t, n;
    if (e == null) return null;
    const i = this._getAttributeNum(e.attributes, "size", 0), s = this._getAttributeNum(e.attributes, "align", 0);
    if (e instanceof RA && (e = e.type), e instanceof Ec) {
      const l = this._getAlias(e.name);
      l !== null && (e = l);
    }
    {
      const l = Hp._typeInfo[e.name];
      if (l !== void 0) {
        const o = ((t = e.format) === null || t === void 0 ? void 0 : t.name) === "f16" ? 2 : 1;
        return new hm(Math.max(s, l.align / o), Math.max(i, l.size / o));
      }
    }
    {
      const l = Hp._typeInfo[e.name.substring(0, e.name.length - 1)];
      if (l) {
        const o = e.name[e.name.length - 1] === "h" ? 2 : 1;
        return new hm(Math.max(s, l.align / o), Math.max(i, l.size / o));
      }
    }
    if (e instanceof _f) {
      let l = e, o = 8, d = 8;
      const m = this._getTypeSize(l.format);
      return m !== null && (d = m.size, o = m.align), d = l.count * this._getAttributeNum((n = e == null ? void 0 : e.attributes) !== null && n !== void 0 ? n : null, "stride", this._roundUp(o, d)), i && (d = i), new hm(Math.max(s, o), Math.max(i, d));
    }
    if (e instanceof wh) {
      let l = 0, o = 0, d = 0, m = 0, b = 0;
      for (const T of e.members) {
        const M = this._getTypeSize(T.type);
        M !== null && (l = Math.max(M.align, l), d = this._roundUp(M.align, d + m), m = M.size, b = d);
      }
      return o = this._roundUp(l, b + m), new hm(Math.max(s, l), Math.max(i, o));
    }
    return null;
  }
  _isUniformVar(e) {
    return e instanceof xh && e.storage == "uniform";
  }
  _isStorageVar(e) {
    return e instanceof xh && e.storage == "storage";
  }
  _isTextureVar(e) {
    return e instanceof xh && e.type !== null && Hp._textureTypes.indexOf(e.type.name) != -1;
  }
  _isSamplerVar(e) {
    return e instanceof xh && e.type !== null && Hp._samplerTypes.indexOf(e.type.name) != -1;
  }
  _getAttribute(e, t) {
    const n = e;
    if (!n || !n.attributes) return null;
    const i = n.attributes;
    for (let s of i) if (s.name == t) return s;
    return null;
  }
  _getAttributeNum(e, t, n) {
    if (e === null) return n;
    for (let i of e) if (i.name == t) {
      let s = i !== null && i.value !== null ? i.value : n;
      return s instanceof Array && (s = s[0]), typeof s == "number" ? s : typeof s == "string" ? parseInt(s) : n;
    }
    return n;
  }
  _roundUp(e, t) {
    return Math.ceil(t / e) * e;
  }
};
tg._typeInfo = {
  f16: {
    align: 2,
    size: 2
  },
  i32: {
    align: 4,
    size: 4
  },
  u32: {
    align: 4,
    size: 4
  },
  f32: {
    align: 4,
    size: 4
  },
  atomic: {
    align: 4,
    size: 4
  },
  vec2: {
    align: 8,
    size: 8
  },
  vec3: {
    align: 16,
    size: 12
  },
  vec4: {
    align: 16,
    size: 16
  },
  mat2x2: {
    align: 8,
    size: 16
  },
  mat3x2: {
    align: 8,
    size: 24
  },
  mat4x2: {
    align: 8,
    size: 32
  },
  mat2x3: {
    align: 16,
    size: 32
  },
  mat3x3: {
    align: 16,
    size: 48
  },
  mat4x3: {
    align: 16,
    size: 64
  },
  mat2x4: {
    align: 16,
    size: 32
  },
  mat3x4: {
    align: 16,
    size: 48
  },
  mat4x4: {
    align: 16,
    size: 64
  }
}, tg._textureTypes = Ee.any_texture_type.map((r) => r.name), tg._samplerTypes = Ee.sampler_type.map((r) => r.name);
class s2 {
  constructor(e, t, n) {
    this.name = e, this.value = t, this.node = n;
  }
  clone() {
    return new s2(this.name, this.value, this.node);
  }
}
class o2 {
  constructor(e) {
    this.name = e.name, this.node = e;
  }
  clone() {
    return new o2(this.node);
  }
}
class a2 {
  constructor(e) {
    this.parent = null, this.variables = /* @__PURE__ */ new Map(), this.functions = /* @__PURE__ */ new Map(), this.currentFunctionName = "", e && (this.parent = e, this.currentFunctionName = e.currentFunctionName);
  }
  getVariable(e) {
    var t;
    return this.variables.has(e) ? (t = this.variables.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getVariable(e) : null;
  }
  getFunction(e) {
    var t;
    return this.functions.has(e) ? (t = this.functions.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getFunction(e) : null;
  }
  createVariable(e, t, n) {
    this.variables.set(e, new s2(e, t, n ?? null));
  }
  setVariable(e, t, n) {
    const i = this.getVariable(e);
    i !== null ? i.value = t : this.createVariable(e, t, n);
  }
  getVariableValue(e) {
    var t;
    const n = this.getVariable(e);
    return (t = n == null ? void 0 : n.value) !== null && t !== void 0 ? t : null;
  }
  clone() {
    return new a2(this);
  }
}
class G6 {
  evalExpression(e, t) {
    return null;
  }
  getTypeName(e) {
    return "";
  }
  getTypeInfo(e) {
    return null;
  }
  getVariableName(e, t) {
    return "";
  }
}
class $6 {
  constructor(e) {
    this.exec = e;
  }
  getTypeInfo(e) {
    return this.exec.getTypeInfo(e);
  }
  All(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    let i = !0;
    if (n instanceof je) return n.value.forEach((s) => {
      s || (i = !1);
    }), new Et(i ? 1 : 0, this.getTypeInfo("bool"));
    throw new Error(`All() expects a vector argument. Line ${e.line}`);
  }
  Any(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) {
      const i = n.value.some((s) => s);
      return new Et(i ? 1 : 0, this.getTypeInfo("bool"));
    }
    throw new Error(`Any() expects a vector argument. Line ${e.line}`);
  }
  Select(e, t) {
    const n = this.exec.evalExpression(e.args[2], t);
    if (!(n instanceof Et)) throw new Error(`Select() expects a bool condition. Line ${e.line}`);
    return n.value ? this.exec.evalExpression(e.args[1], t) : this.exec.evalExpression(e.args[0], t);
  }
  ArrayLength(e, t) {
    let n = e.args[0];
    n instanceof Ya && (n = n.right);
    const i = this.exec.evalExpression(n, t);
    if (i instanceof ls && i.typeInfo.size === 0) {
      const s = i.typeInfo, l = i.buffer.byteLength / s.stride;
      return new Et(l, this.getTypeInfo("u32"));
    }
    return new Et(i.typeInfo.size, this.getTypeInfo("u32"));
  }
  Abs(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.abs(s)), n.typeInfo);
    const i = n;
    return new Et(Math.abs(i.value), i.typeInfo);
  }
  Acos(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.acos(s)), n.typeInfo);
    const i = n;
    return new Et(Math.acos(i.value), n.typeInfo);
  }
  Acosh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.acosh(s)), n.typeInfo);
    const i = n;
    return new Et(Math.acosh(i.value), n.typeInfo);
  }
  Asin(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.asin(s)), n.typeInfo);
    const i = n;
    return new Et(Math.asin(i.value), n.typeInfo);
  }
  Asinh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.asinh(s)), n.typeInfo);
    const i = n;
    return new Et(Math.asinh(i.value), n.typeInfo);
  }
  Atan(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.atan(s)), n.typeInfo);
    const i = n;
    return new Et(Math.atan(i.value), n.typeInfo);
  }
  Atanh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.atanh(s)), n.typeInfo);
    const i = n;
    return new Et(Math.atanh(i.value), n.typeInfo);
  }
  Atan2(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof je && i instanceof je) return new je(n.value.map((o, d) => Math.atan2(o, i.value[d])), n.typeInfo);
    const s = n, l = i;
    return new Et(Math.atan2(s.value, l.value), n.typeInfo);
  }
  Ceil(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.ceil(s)), n.typeInfo);
    const i = n;
    return new Et(Math.ceil(i.value), n.typeInfo);
  }
  _clamp(e, t, n) {
    return Math.min(Math.max(e, t), n);
  }
  Clamp(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof je && i instanceof je && s instanceof je) return new je(n.value.map((m, b) => this._clamp(m, i.value[b], s.value[b])), n.typeInfo);
    const l = n, o = i, d = s;
    return new Et(this._clamp(l.value, o.value, d.value), n.typeInfo);
  }
  Cos(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.cos(s)), n.typeInfo);
    const i = n;
    return new Et(Math.cos(i.value), n.typeInfo);
  }
  Cosh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.cosh(s)), n.typeInfo);
    const i = n;
    return new Et(Math.cos(i.value), n.typeInfo);
  }
  CountLeadingZeros(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.clz32(s)), n.typeInfo);
    const i = n;
    return new Et(Math.clz32(i.value), n.typeInfo);
  }
  _countOneBits(e) {
    let t = 0;
    for (; e !== 0; ) 1 & e && t++, e >>= 1;
    return t;
  }
  CountOneBits(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => this._countOneBits(s)), n.typeInfo);
    const i = n;
    return new Et(this._countOneBits(i.value), n.typeInfo);
  }
  _countTrailingZeros(e) {
    if (e === 0) return 32;
    let t = 0;
    for (; !(1 & e); ) e >>= 1, t++;
    return t;
  }
  CountTrailingZeros(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => this._countTrailingZeros(s)), n.typeInfo);
    const i = n;
    return new Et(this._countTrailingZeros(i.value), n.typeInfo);
  }
  Cross(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof je && i instanceof je) {
      if (n.value.length !== 3 || i.value.length !== 3) return console.error(`Cross() expects 3D vectors. Line ${e.line}`), null;
      const s = n.value, l = i.value;
      return new je([s[1] * l[2] - l[1] * s[2], s[2] * l[0] - l[2] * s[0], s[0] * l[1] - l[0] * s[1]], n.typeInfo);
    }
    return console.error(`Cross() expects vector arguments. Line ${e.line}`), null;
  }
  Degrees(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = 180 / Math.PI;
    return n instanceof je ? new je(n.value.map((s) => s * i), n.typeInfo) : new Et(n.value * i, n.typeInfo);
  }
  Determinant(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof Hn) {
      const i = n.value, s = this.exec.getTypeName(n.typeInfo), l = s.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
      if (s === "mat2x2" || s === "mat2x2f" || s === "mat2x2h") return new Et(i[0] * i[3] - i[1] * i[2], l);
      if (s === "mat2x3" || s === "mat2x3f" || s === "mat2x3h") return new Et(i[0] * (i[4] * i[8] - i[5] * i[7]) - i[1] * (i[3] * i[8] - i[5] * i[6]) + i[2] * (i[3] * i[7] - i[4] * i[6]), l);
      if (s === "mat2x4" || s === "mat2x4f" || s === "mat2x4h") console.error(`TODO: Determinant for ${s}`);
      else if (s === "mat3x2" || s === "mat3x2f" || s === "mat3x2h") console.error(`TODO: Determinant for ${s}`);
      else {
        if (s === "mat3x3" || s === "mat3x3f" || s === "mat3x3h") return new Et(i[0] * (i[4] * i[8] - i[5] * i[7]) - i[1] * (i[3] * i[8] - i[5] * i[6]) + i[2] * (i[3] * i[7] - i[4] * i[6]), l);
        s === "mat3x4" || s === "mat3x4f" || s === "mat3x4h" || s === "mat4x2" || s === "mat4x2f" || s === "mat4x2h" || s === "mat4x3" || s === "mat4x3f" || s === "mat4x3h" ? console.error(`TODO: Determinant for ${s}`) : s !== "mat4x4" && s !== "mat4x4f" && s !== "mat4x4h" || console.error(`TODO: Determinant for ${s}`);
      }
    }
    return console.error(`Determinant expects a matrix argument. Line ${e.line}`), null;
  }
  Distance(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof je && i instanceof je) {
      let o = 0;
      for (let d = 0; d < n.value.length; ++d) o += (n.value[d] - i.value[d]) * (n.value[d] - i.value[d]);
      return new Et(Math.sqrt(o), this.getTypeInfo("f32"));
    }
    const s = n, l = i;
    return new Et(Math.abs(s.value - l.value), n.typeInfo);
  }
  _dot(e, t) {
    let n = 0;
    for (let i = 0; i < e.length; ++i) n += t[i] * e[i];
    return n;
  }
  Dot(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    return n instanceof je && i instanceof je ? new Et(this._dot(n.value, i.value), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${e.line}`), null);
  }
  Dot4U8Packed(e, t) {
    return console.error(`TODO: dot4U8Packed. Line ${e.line}`), null;
  }
  Dot4I8Packed(e, t) {
    return console.error(`TODO: dot4I8Packed. Line ${e.line}`), null;
  }
  Exp(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.exp(s)), n.typeInfo);
    const i = n;
    return new Et(Math.exp(i.value), n.typeInfo);
  }
  Exp2(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.pow(2, s)), n.typeInfo);
    const i = n;
    return new Et(Math.pow(2, i.value), n.typeInfo);
  }
  ExtractBits(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (i.typeInfo.name !== "u32" && i.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 offset argument. Line ${e.line}`), null;
    if (s.typeInfo.name !== "u32" && s.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 count argument. Line ${e.line}`), null;
    const l = i.value, o = s.value;
    if (n instanceof je) return new je(n.value.map((m) => m >> l & (1 << o) - 1), n.typeInfo);
    if (n.typeInfo.name !== "i32" && n.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 argument. Line ${e.line}`), null;
    const d = n.value;
    return new Et(d >> l & (1 << o) - 1, this.getTypeInfo("i32"));
  }
  FaceForward(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof je && i instanceof je && s instanceof je) {
      const l = this._dot(i.value, s.value);
      return new je(l < 0 ? n.value : n.value.map((o) => -o), n.typeInfo);
    }
    return console.error(`FaceForward() expects vector arguments. Line ${e.line}`), null;
  }
  _firstLeadingBit(e) {
    return e === 0 ? -1 : 31 - Math.clz32(e);
  }
  FirstLeadingBit(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => this._firstLeadingBit(s)), n.typeInfo);
    const i = n;
    return new Et(this._firstLeadingBit(i.value), n.typeInfo);
  }
  _firstTrailingBit(e) {
    return e === 0 ? -1 : Math.log2(e & -e);
  }
  FirstTrailingBit(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => this._firstTrailingBit(s)), n.typeInfo);
    const i = n;
    return new Et(this._firstTrailingBit(i.value), n.typeInfo);
  }
  Floor(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.floor(s)), n.typeInfo);
    const i = n;
    return new Et(Math.floor(i.value), n.typeInfo);
  }
  Fma(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof je && i instanceof je && s instanceof je) return n.value.length !== i.value.length || n.value.length !== s.value.length ? (console.error(`Fma() expects vectors of the same length. Line ${e.line}`), null) : new je(n.value.map((m, b) => m * i.value[b] + s.value[b]), n.typeInfo);
    const l = n, o = i, d = s;
    return new Et(l.value * o.value + d.value, l.typeInfo);
  }
  Fract(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => s - Math.floor(s)), n.typeInfo);
    const i = n;
    return new Et(i.value - Math.floor(i.value), n.typeInfo);
  }
  Frexp(e, t) {
    return console.error(`TODO: frexp. Line ${e.line}`), null;
  }
  InsertBits(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t), l = this.exec.evalExpression(e.args[3], t);
    if (s.typeInfo.name !== "u32" && s.typeInfo.name !== "x32") return console.error(`InsertBits() expects an i32 offset argument. Line ${e.line}`), null;
    const o = s.value, d = (1 << l.value) - 1 << o, m = ~d;
    if (n instanceof je && i instanceof je) return new je(n.value.map((M, E) => M & m | i.value[E] << o & d), n.typeInfo);
    const b = n.value, T = i.value;
    return new Et(b & m | T << o & d, n.typeInfo);
  }
  InverseSqrt(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => 1 / Math.sqrt(s)), n.typeInfo);
    const i = n;
    return new Et(1 / Math.sqrt(i.value), n.typeInfo);
  }
  Ldexp(e, t) {
    return console.error(`TODO: ldexp. Line ${e.line}`), null;
  }
  Length(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) {
      let s = 0;
      return n.value.forEach((l) => {
        s += l * l;
      }), new Et(Math.sqrt(s), this.getTypeInfo("f32"));
    }
    const i = n;
    return new Et(Math.abs(i.value), n.typeInfo);
  }
  Log(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.log(s)), n.typeInfo);
    const i = n;
    return new Et(Math.log(i.value), n.typeInfo);
  }
  Log2(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.log2(s)), n.typeInfo);
    const i = n;
    return new Et(Math.log2(i.value), n.typeInfo);
  }
  Max(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof je && i instanceof je) return new je(n.value.map((o, d) => Math.max(o, i.value[d])), n.typeInfo);
    const s = n, l = i;
    return new Et(Math.max(s.value, l.value), n.typeInfo);
  }
  Min(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof je && i instanceof je) return new je(n.value.map((o, d) => Math.min(o, i.value[d])), n.typeInfo);
    const s = n, l = i;
    return new Et(Math.min(s.value, l.value), n.typeInfo);
  }
  Mix(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof je && i instanceof je && s instanceof je) return new je(n.value.map((d, m) => n.value[m] * (1 - s.value[m]) + i.value[m] * s.value[m]), n.typeInfo);
    const l = i, o = s;
    return new Et(n.value * (1 - o.value) + l.value * o.value, n.typeInfo);
  }
  Modf(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof je && i instanceof je) return new je(n.value.map((l, o) => l % i.value[o]), n.typeInfo);
    const s = i;
    return new Et(n.value % s.value, n.typeInfo);
  }
  Normalize(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) {
      const i = this.Length(e, t).value;
      return new je(n.value.map((s) => s / i), n.typeInfo);
    }
    return console.error(`Normalize() expects a vector argument. Line ${e.line}`), null;
  }
  Pow(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof je && i instanceof je) return new je(n.value.map((o, d) => Math.pow(o, i.value[d])), n.typeInfo);
    const s = n, l = i;
    return new Et(Math.pow(s.value, l.value), n.typeInfo);
  }
  QuantizeToF16(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    return n instanceof je ? new je(n.value.map((i) => i), n.typeInfo) : new Et(n.value, n.typeInfo);
  }
  Radians(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    return n instanceof je ? new je(n.value.map((i) => i * Math.PI / 180), n.typeInfo) : new Et(n.value * Math.PI / 180, n.typeInfo);
  }
  Reflect(e, t) {
    let n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (n instanceof je && i instanceof je) {
      const s = this._dot(n.value, i.value);
      return new je(n.value.map((l, o) => l - 2 * s * i.value[o]), n.typeInfo);
    }
    return console.error(`Reflect() expects vector arguments. Line ${e.line}`), null;
  }
  Refract(e, t) {
    let n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (n instanceof je && i instanceof je && s instanceof Et) {
      const l = this._dot(i.value, n.value);
      return new je(n.value.map((o, d) => {
        const m = 1 - s.value * s.value * (1 - l * l);
        if (m < 0) return 0;
        const b = Math.sqrt(m);
        return s.value * o - (s.value * l + b) * i.value[d];
      }), n.typeInfo);
    }
    return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e.line}`), null;
  }
  ReverseBits(e, t) {
    return console.error(`TODO: reverseBits. Line ${e.line}`), null;
  }
  Round(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.round(s)), n.typeInfo);
    const i = n;
    return new Et(Math.round(i.value), n.typeInfo);
  }
  Saturate(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.min(Math.max(s, 0), 1)), n.typeInfo);
    const i = n;
    return new Et(Math.min(Math.max(i.value, 0), 1), n.typeInfo);
  }
  Sign(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.sign(s)), n.typeInfo);
    const i = n;
    return new Et(Math.sign(i.value), n.typeInfo);
  }
  Sin(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.sin(s)), n.typeInfo);
    const i = n;
    return new Et(Math.sin(i.value), n.typeInfo);
  }
  Sinh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.sinh(s)), n.typeInfo);
    const i = n;
    return new Et(Math.sinh(i.value), n.typeInfo);
  }
  _smoothstep(e, t, n) {
    const i = Math.min(Math.max((n - e) / (t - e), 0), 1);
    return i * i * (3 - 2 * i);
  }
  SmoothStep(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t);
    if (s instanceof je && n instanceof je && i instanceof je) return new je(s.value.map((m, b) => this._smoothstep(n.value[b], i.value[b], m)), s.typeInfo);
    const l = n, o = i, d = s;
    return new Et(this._smoothstep(l.value, o.value, d.value), s.typeInfo);
  }
  Sqrt(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.sqrt(s)), n.typeInfo);
    const i = n;
    return new Et(Math.sqrt(i.value), n.typeInfo);
  }
  Step(e, t) {
    const n = this.exec.evalExpression(e.args[0], t), i = this.exec.evalExpression(e.args[1], t);
    if (i instanceof je && n instanceof je) return new je(i.value.map((l, o) => l < n.value[o] ? 0 : 1), i.typeInfo);
    const s = n;
    return new Et(i.value < s.value ? 0 : 1, s.typeInfo);
  }
  Tan(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.tan(s)), n.typeInfo);
    const i = n;
    return new Et(Math.tan(i.value), n.typeInfo);
  }
  Tanh(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.tanh(s)), n.typeInfo);
    const i = n;
    return new Et(Math.tanh(i.value), n.typeInfo);
  }
  _getTransposeType(e) {
    const t = this.exec.getTypeName(e);
    return t === "mat2x2f" || t === "mat2x2h" ? e : t === "mat2x3f" ? this.getTypeInfo("mat3x2f") : t === "mat2x3h" ? this.getTypeInfo("mat3x2h") : t === "mat2x4f" ? this.getTypeInfo("mat4x2f") : t === "mat2x4h" ? this.getTypeInfo("mat4x2h") : t === "mat3x2f" ? this.getTypeInfo("mat2x3f") : t === "mat3x2h" ? this.getTypeInfo("mat2x3h") : t === "mat3x3f" || t === "mat3x3h" ? e : t === "mat3x4f" ? this.getTypeInfo("mat4x3f") : t === "mat3x4h" ? this.getTypeInfo("mat4x3h") : t === "mat4x2f" ? this.getTypeInfo("mat2x4f") : t === "mat4x2h" ? this.getTypeInfo("mat2x4h") : t === "mat4x3f" ? this.getTypeInfo("mat3x4f") : t === "mat4x3h" ? this.getTypeInfo("mat3x4h") : (t === "mat4x4f" || t === "mat4x4h" || console.error(`Invalid matrix type ${t}`), e);
  }
  Transpose(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (!(n instanceof Hn)) return console.error(`Transpose() expects a matrix argument. Line ${e.line}`), null;
    const i = this._getTransposeType(n.typeInfo);
    if (n.typeInfo.name === "mat2x2" || n.typeInfo.name === "mat2x2f" || n.typeInfo.name === "mat2x2h") {
      const s = n.value;
      return new Hn([s[0], s[2], s[1], s[3]], i);
    }
    if (n.typeInfo.name === "mat2x3" || n.typeInfo.name === "mat2x3f" || n.typeInfo.name === "mat2x3h") {
      const s = n.value;
      return new Hn([s[0], s[3], s[6], s[1], s[4], s[7]], i);
    }
    if (n.typeInfo.name === "mat2x4" || n.typeInfo.name === "mat2x4f" || n.typeInfo.name === "mat2x4h") {
      const s = n.value;
      return new Hn([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13]], i);
    }
    if (n.typeInfo.name === "mat3x2" || n.typeInfo.name === "mat3x2f" || n.typeInfo.name === "mat3x2h") {
      const s = n.value;
      return new Hn([s[0], s[3], s[1], s[4], s[2], s[5]], i);
    }
    if (n.typeInfo.name === "mat3x3" || n.typeInfo.name === "mat3x3f" || n.typeInfo.name === "mat3x3h") {
      const s = n.value;
      return new Hn([s[0], s[3], s[6], s[1], s[4], s[7], s[2], s[5], s[8]], i);
    }
    if (n.typeInfo.name === "mat3x4" || n.typeInfo.name === "mat3x4f" || n.typeInfo.name === "mat3x4h") {
      const s = n.value;
      return new Hn([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13], s[2], s[6], s[10], s[14]], i);
    }
    if (n.typeInfo.name === "mat4x2" || n.typeInfo.name === "mat4x2f" || n.typeInfo.name === "mat4x2h") {
      const s = n.value;
      return new Hn([s[0], s[4], s[1], s[5], s[2], s[6]], i);
    }
    if (n.typeInfo.name === "mat4x3" || n.typeInfo.name === "mat4x3f" || n.typeInfo.name === "mat4x3h") {
      const s = n.value;
      return new Hn([s[0], s[4], s[8], s[1], s[5], s[9], s[2], s[6], s[10]], i);
    }
    if (n.typeInfo.name === "mat4x4" || n.typeInfo.name === "mat4x4f" || n.typeInfo.name === "mat4x4h") {
      const s = n.value;
      return new Hn([s[0], s[4], s[8], s[12], s[1], s[5], s[9], s[13], s[2], s[6], s[10], s[14], s[3], s[7], s[11], s[15]], i);
    }
    return console.error(`Invalid matrix type ${n.typeInfo.name}`), null;
  }
  Trunc(e, t) {
    const n = this.exec.evalExpression(e.args[0], t);
    if (n instanceof je) return new je(n.value.map((s) => Math.trunc(s)), n.typeInfo);
    const i = n;
    return new Et(Math.trunc(i.value), n.typeInfo);
  }
  Dpdx(e, t) {
    return console.error(`TODO: dpdx. Line ${e.line}`), null;
  }
  DpdxCoarse(e, t) {
    return console.error(`TODO: dpdxCoarse. Line ${e.line}`), null;
  }
  DpdxFine(e, t) {
    return console.error("TODO: dpdxFine"), null;
  }
  Dpdy(e, t) {
    return console.error("TODO: dpdy"), null;
  }
  DpdyCoarse(e, t) {
    return console.error("TODO: dpdyCoarse"), null;
  }
  DpdyFine(e, t) {
    return console.error("TODO: dpdyFine"), null;
  }
  Fwidth(e, t) {
    return console.error("TODO: fwidth"), null;
  }
  FwidthCoarse(e, t) {
    return console.error("TODO: fwidthCoarse"), null;
  }
  FwidthFine(e, t) {
    return console.error("TODO: fwidthFine"), null;
  }
  TextureDimensions(e, t) {
    const n = e.args[0];
    if ((e.args.length > 1 ? this.exec.evalExpression(e.args[1], t).value : 0) > 0) return console.error(`TODO: Mip levels. Line ${e.line}`), null;
    if (n instanceof Ch) {
      const i = n.name, s = t.getVariableValue(i);
      return s instanceof ls ? new je(s.textureSize, this.getTypeInfo("vec2u")) : (console.error(`Texture ${i} not found. Line ${e.line}`), null);
    }
    return console.error(`Invalid texture argument for textureDimensions. Line ${e.line}`), null;
  }
  TextureGather(e, t) {
    return console.error("TODO: textureGather"), null;
  }
  TextureGatherCompare(e, t) {
    return console.error("TODO: textureGatherCompare"), null;
  }
  TextureLoad(e, t) {
    const n = e.args[0], i = this.exec.evalExpression(e.args[1], t);
    if ((e.args.length > 2 ? this.exec.evalExpression(e.args[2], t).value : 0) > 0) return console.error(`TODO: Mip levels. Line ${e.line}`), null;
    if (!(i instanceof je) || i.value.length !== 2) return console.error(`Invalid UV argument for textureLoad. Line ${e.line}`), null;
    if (n instanceof Ch) {
      const s = n.name, l = t.getVariableValue(s);
      if (l instanceof ls) {
        const o = l.textureSize, d = Math.floor(i.value[0]), m = Math.floor(i.value[1]);
        if (d < 0 || d >= o[0] || m < 0 || m >= o[1]) return console.error(`Texture ${s} out of bounds. Line ${e.line}`), null;
        const b = 4 * (m * o[0] + d), T = new Uint8Array(l.buffer, b, 4);
        return new je([T[0] / 255, T[1] / 255, T[2] / 255, T[3] / 255], this.getTypeInfo("vec4f"));
      }
      return console.error(`Texture ${s} not found. Line ${e.line}`), null;
    }
    return console.error(`Invalid texture argument for textureLoad. Line ${e.line}`), null;
  }
  TextureNumLayers(e, t) {
    return console.error("TODO: textureNumLayers"), null;
  }
  TextureNumLevels(e, t) {
    return console.error("TODO: textureNumLevels"), null;
  }
  TextureNumSamples(e, t) {
    return console.error("TODO: textureNumSamples"), null;
  }
  TextureSample(e, t) {
    return console.error("TODO: textureSample"), null;
  }
  TextureSampleBias(e, t) {
    return console.error("TODO: textureSampleBias"), null;
  }
  TextureSampleCompare(e, t) {
    return console.error("TODO: textureSampleCompare"), null;
  }
  TextureSampleCompareLevel(e, t) {
    return console.error("TODO: textureSampleCompareLevel"), null;
  }
  TextureSampleGrad(e, t) {
    return console.error("TODO: textureSampleGrad"), null;
  }
  TextureSampleLevel(e, t) {
    return console.error("TODO: textureSampleLevel"), null;
  }
  TextureSampleBaseClampToEdge(e, t) {
    return console.error("TODO: textureSampleBaseClampToEdge"), null;
  }
  TextureStore(e, t) {
    const n = e.args[0], i = this.exec.evalExpression(e.args[1], t), s = this.exec.evalExpression(e.args[2], t).value;
    if (s.length !== 4) return console.error(`Invalid value argument for textureStore. Line ${e.line}`), null;
    if (!(i instanceof je) || i.value.length !== 2) return console.error(`Invalid UV argument for textureStore. Line ${e.line}`), null;
    if (n instanceof Ch) {
      const l = n.name, o = t.getVariableValue(l);
      if (o instanceof ls) {
        const d = o.textureSize, m = Math.floor(i.value[0]), b = Math.floor(i.value[1]);
        if (m < 0 || m >= d[0] || b < 0 || b >= d[1]) return console.error(`Texture ${l} out of bounds. Line ${e.line}`), null;
        const T = 4 * (b * d[0] + m), M = new Uint8Array(o.buffer, T, 4);
        return M[0] = 255 * s[0], M[1] = 255 * s[1], M[2] = 255 * s[2], M[3] = 255 * s[3], null;
      }
      return console.error(`Texture ${l} not found. Line ${e.line}`), null;
    }
    return console.error(`Invalid texture argument for textureStore. Line ${e.line}`), null;
  }
  AtomicLoad(e, t) {
    let n = e.args[0];
    n instanceof Ya && (n = n.right);
    const i = this.exec.getVariableName(n, t);
    return t.getVariable(i).value.getDataValue(this.exec, n.postfix, t);
  }
  AtomicStore(e, t) {
    let n = e.args[0];
    n instanceof Ya && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getDataValue(this.exec, n.postfix, t);
    return d instanceof Et && o instanceof Et && (d.value = o.value), s.value instanceof ls && s.value.setDataValue(this.exec, d, n.postfix, t), null;
  }
  AtomicAdd(e, t) {
    let n = e.args[0];
    n instanceof Ya && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getDataValue(this.exec, n.postfix, t);
    return d instanceof Et && o instanceof Et && (d.value += o.value), s.value instanceof ls && s.value.setDataValue(this.exec, d, n.postfix, t), null;
  }
  AtomicSub(e, t) {
    let n = e.args[0];
    n instanceof Ya && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getDataValue(this.exec, n.postfix, t);
    return d instanceof Et && o instanceof Et && (d.value -= o.value), s.value instanceof ls && s.value.setDataValue(this.exec, d, n.postfix, t), null;
  }
  AtomicMax(e, t) {
    let n = e.args[0];
    n instanceof Ya && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getDataValue(this.exec, n.postfix, t), m = new Et(d.value, d.typeInfo);
    return d instanceof Et && o instanceof Et && (d.value = Math.max(d.value, o.value)), s.value instanceof ls && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicMin(e, t) {
    let n = e.args[0];
    n instanceof Ya && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getDataValue(this.exec, n.postfix, t), m = new Et(d.value, d.typeInfo);
    return d instanceof Et && o instanceof Et && (d.value = Math.min(d.value, o.value)), s.value instanceof ls && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicAnd(e, t) {
    let n = e.args[0];
    n instanceof Ya && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getDataValue(this.exec, n.postfix, t), m = new Et(d.value, d.typeInfo);
    return d instanceof Et && o instanceof Et && (d.value = d.value & o.value), s.value instanceof ls && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicOr(e, t) {
    let n = e.args[0];
    n instanceof Ya && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getDataValue(this.exec, n.postfix, t), m = new Et(d.value, d.typeInfo);
    return d instanceof Et && o instanceof Et && (d.value = d.value | o.value), s.value instanceof ls && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicXor(e, t) {
    let n = e.args[0];
    n instanceof Ya && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getDataValue(this.exec, n.postfix, t), m = new Et(d.value, d.typeInfo);
    return d instanceof Et && o instanceof Et && (d.value = d.value ^ o.value), s.value instanceof ls && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicExchange(e, t) {
    let n = e.args[0];
    n instanceof Ya && (n = n.right);
    const i = this.exec.getVariableName(n, t), s = t.getVariable(i);
    let l = e.args[1];
    const o = this.exec.evalExpression(l, t), d = s.value.getDataValue(this.exec, n.postfix, t), m = new Et(d.value, d.typeInfo);
    return d instanceof Et && o instanceof Et && (d.value = o.value), s.value instanceof ls && s.value.setDataValue(this.exec, d, n.postfix, t), m;
  }
  AtomicCompareExchangeWeak(e, t) {
    return console.error("TODO: atomicCompareExchangeWeak"), null;
  }
  Pack4x8snorm(e, t) {
    return console.error("TODO: pack4x8snorm"), null;
  }
  Pack4x8unorm(e, t) {
    return console.error("TODO: pack4x8unorm"), null;
  }
  Pack4xI8(e, t) {
    return console.error("TODO: pack4xI8"), null;
  }
  Pack4xU8(e, t) {
    return console.error("TODO: pack4xU8"), null;
  }
  Pack4x8Clamp(e, t) {
    return console.error("TODO: pack4x8Clamp"), null;
  }
  Pack4xU8Clamp(e, t) {
    return console.error("TODO: pack4xU8Clamp"), null;
  }
  Pack2x16snorm(e, t) {
    return console.error("TODO: pack2x16snorm"), null;
  }
  Pack2x16unorm(e, t) {
    return console.error("TODO: pack2x16unorm"), null;
  }
  Pack2x16float(e, t) {
    return console.error("TODO: pack2x16float"), null;
  }
  Unpack4x8snorm(e, t) {
    return console.error("TODO: unpack4x8snorm"), null;
  }
  Unpack4x8unorm(e, t) {
    return console.error("TODO: unpack4x8unorm"), null;
  }
  Unpack4xI8(e, t) {
    return console.error("TODO: unpack4xI8"), null;
  }
  Unpack4xU8(e, t) {
    return console.error("TODO: unpack4xU8"), null;
  }
  Unpack2x16snorm(e, t) {
    return console.error("TODO: unpack2x16snorm"), null;
  }
  Unpack2x16unorm(e, t) {
    return console.error("TODO: unpack2x16unorm"), null;
  }
  Unpack2x16float(e, t) {
    return console.error("TODO: unpack2x16float"), null;
  }
  StorageBarrier(e, t) {
    return null;
  }
  TextureBarrier(e, t) {
    return null;
  }
  WorkgroupBarrier(e, t) {
    return null;
  }
  WorkgroupUniformLoad(e, t) {
    return null;
  }
  SubgroupAdd(e, t) {
    return console.error("TODO: subgroupAdd"), null;
  }
  SubgroupExclusiveAdd(e, t) {
    return console.error("TODO: subgroupExclusiveAdd"), null;
  }
  SubgroupInclusiveAdd(e, t) {
    return console.error("TODO: subgroupInclusiveAdd"), null;
  }
  SubgroupAll(e, t) {
    return console.error("TODO: subgroupAll"), null;
  }
  SubgroupAnd(e, t) {
    return console.error("TODO: subgroupAnd"), null;
  }
  SubgroupAny(e, t) {
    return console.error("TODO: subgroupAny"), null;
  }
  SubgroupBallot(e, t) {
    return console.error("TODO: subgroupBallot"), null;
  }
  SubgroupBroadcast(e, t) {
    return console.error("TODO: subgroupBroadcast"), null;
  }
  SubgroupBroadcastFirst(e, t) {
    return console.error("TODO: subgroupBroadcastFirst"), null;
  }
  SubgroupElect(e, t) {
    return console.error("TODO: subgroupElect"), null;
  }
  SubgroupMax(e, t) {
    return console.error("TODO: subgroupMax"), null;
  }
  SubgroupMin(e, t) {
    return console.error("TODO: subgroupMin"), null;
  }
  SubgroupMul(e, t) {
    return console.error("TODO: subgroupMul"), null;
  }
  SubgroupExclusiveMul(e, t) {
    return console.error("TODO: subgroupExclusiveMul"), null;
  }
  SubgroupInclusiveMul(e, t) {
    return console.error("TODO: subgroupInclusiveMul"), null;
  }
  SubgroupOr(e, t) {
    return console.error("TODO: subgroupOr"), null;
  }
  SubgroupShuffle(e, t) {
    return console.error("TODO: subgroupShuffle"), null;
  }
  SubgroupShuffleDown(e, t) {
    return console.error("TODO: subgroupShuffleDown"), null;
  }
  SubgroupShuffleUp(e, t) {
    return console.error("TODO: subgroupShuffleUp"), null;
  }
  SubgroupShuffleXor(e, t) {
    return console.error("TODO: subgroupShuffleXor"), null;
  }
  SubgroupXor(e, t) {
    return console.error("TODO: subgroupXor"), null;
  }
  QuadBroadcast(e, t) {
    return console.error("TODO: quadBroadcast"), null;
  }
  QuadSwapDiagonal(e, t) {
    return console.error("TODO: quadSwapDiagonal"), null;
  }
  QuadSwapX(e, t) {
    return console.error("TODO: quadSwapX"), null;
  }
  QuadSwapY(e, t) {
    return console.error("TODO: quadSwapY"), null;
  }
}
function Sr(r) {
  return Array.isArray(r) || (r == null ? void 0 : r.buffer) instanceof ArrayBuffer;
}
const B_ = new Float32Array(1), H6 = new Uint32Array(B_.buffer), W6 = new Uint32Array(B_.buffer), L_ = new Int32Array(1), X6 = new Float32Array(L_.buffer), Z6 = new Uint32Array(L_.buffer), O_ = new Uint32Array(1), Y6 = new Float32Array(O_.buffer), K6 = new Int32Array(O_.buffer);
function OA(r, e, t) {
  if (e === t) return r;
  if (e === "f32") {
    if (t === "i32" || t === "x32") return B_[0] = r, H6[0];
    if (t === "u32") return B_[0] = r, W6[0];
  } else if (e === "i32" || e === "x32") {
    if (t === "f32") return L_[0] = r, X6[0];
    if (t === "u32") return L_[0] = r, Z6[0];
  } else if (e === "u32") {
    if (t === "f32") return O_[0] = r, Y6[0];
    if (t === "i32" || t === "x32") return O_[0] = r, K6[0];
  }
  return console.error(`Unsupported cast from ${e} to ${t}`), r;
}
class jo extends G6 {
  constructor(e, t) {
    var n;
    super(), this.ast = e ?? [], this.reflection = new tg(), this.reflection.updateAST(this.ast), this.context = (n = t == null ? void 0 : t.clone()) !== null && n !== void 0 ? n : new a2(), this.builtins = new $6(this), this.typeInfo = {
      bool: this.getTypeInfo(ur.bool),
      i32: this.getTypeInfo(ur.i32),
      u32: this.getTypeInfo(ur.u32),
      f32: this.getTypeInfo(ur.f32),
      f16: this.getTypeInfo(ur.f16),
      vec2f: this.getTypeInfo(Ht.vec2f),
      vec2u: this.getTypeInfo(Ht.vec2u),
      vec2i: this.getTypeInfo(Ht.vec2i),
      vec2h: this.getTypeInfo(Ht.vec2h),
      vec3f: this.getTypeInfo(Ht.vec3f),
      vec3u: this.getTypeInfo(Ht.vec3u),
      vec3i: this.getTypeInfo(Ht.vec3i),
      vec3h: this.getTypeInfo(Ht.vec3h),
      vec4f: this.getTypeInfo(Ht.vec4f),
      vec4u: this.getTypeInfo(Ht.vec4u),
      vec4i: this.getTypeInfo(Ht.vec4i),
      vec4h: this.getTypeInfo(Ht.vec4h),
      mat2x2f: this.getTypeInfo(Ht.mat2x2f),
      mat2x3f: this.getTypeInfo(Ht.mat2x3f),
      mat2x4f: this.getTypeInfo(Ht.mat2x4f),
      mat3x2f: this.getTypeInfo(Ht.mat3x2f),
      mat3x3f: this.getTypeInfo(Ht.mat3x3f),
      mat3x4f: this.getTypeInfo(Ht.mat3x4f),
      mat4x2f: this.getTypeInfo(Ht.mat4x2f),
      mat4x3f: this.getTypeInfo(Ht.mat4x3f),
      mat4x4f: this.getTypeInfo(Ht.mat4x4f)
    };
  }
  getVariableValue(e) {
    var t, n;
    const i = (n = (t = this.context.getVariable(e)) === null || t === void 0 ? void 0 : t.value) !== null && n !== void 0 ? n : null;
    return i === null ? null : i instanceof Et || i instanceof je || i instanceof Hn ? i.value : (console.error(`Unsupported return variable type ${i.typeInfo.name}`), null);
  }
  execute(e) {
    (e = e ?? {}).constants && this._setOverrides(e.constants, this.context), this._execStatements(this.ast, this.context);
  }
  dispatchWorkgroups(e, t, n, i) {
    const s = this.context.clone();
    (i = i ?? {}).constants && this._setOverrides(i.constants, s), this._execStatements(this.ast, s);
    const l = s.getFunction(e);
    if (!l) return void console.error(`Function ${e} not found`);
    if (typeof t == "number") t = [t, 1, 1];
    else {
      if (t.length === 0) return void console.error("Invalid dispatch count");
      t.length === 1 ? t = [t[0], 1, 1] : t.length === 2 ? t = [t[0], t[1], 1] : t.length > 3 && (t = [t[0], t[1], t[2]]);
    }
    const o = t[0], d = t[1], m = t[2], b = this.getTypeInfo("vec3u");
    s.setVariable("@num_workgroups", new je(t, b));
    for (const T in n) for (const M in n[T]) {
      const E = n[T][M];
      s.variables.forEach((D) => {
        const U = D.node;
        if (U != null && U.attributes) {
          let q = null, G = null;
          for (const Y of U.attributes) Y.name === "binding" ? q = Y.value : Y.name === "group" && (G = Y.value);
          M == q && T == G && (E.texture !== void 0 && E.size !== void 0 ? D.value = new ls(E.texture, this.getTypeInfo(U.type), 0, E.size) : E.uniform !== void 0 ? D.value = new ls(E.uniform, this.getTypeInfo(U.type)) : D.value = new ls(E, this.getTypeInfo(U.type)));
        }
      });
    }
    for (let T = 0; T < m; ++T) for (let M = 0; M < d; ++M) for (let E = 0; E < o; ++E) s.setVariable("@workgroup_id", new je([E, M, T], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(l, [E, M, T], s);
  }
  execStatement(e, t) {
    if (e instanceof l5) return this.evalExpression(e.value, t);
    if (e instanceof u5) {
      if (e.condition) {
        const n = this.evalExpression(e.condition, t);
        if (!(n instanceof Et)) throw new Error("Invalid break-if condition");
        if (!n.value) return null;
      }
      return jo._breakObj;
    }
    if (e instanceof h5) return jo._continueObj;
    if (e instanceof R_) this._let(e, t);
    else if (e instanceof xh) this._var(e, t);
    else if (e instanceof R1) this._const(e, t);
    else if (e instanceof P_) this._function(e, t);
    else {
      if (e instanceof a5) return this._if(e, t);
      if (e instanceof o5) return this._switch(e, t);
      if (e instanceof r5) return this._for(e, t);
      if (e instanceof t5) return this._while(e, t);
      if (e instanceof s5) return this._loop(e, t);
      if (e instanceof P1) {
        const n = t.clone();
        return n.currentFunctionName = t.currentFunctionName, this._execStatements(e.body, n);
      }
      if (e instanceof i5) this._assign(e, t);
      else if (e instanceof n5) this._increment(e, t);
      else {
        if (e instanceof yh) return null;
        if (e instanceof r2) {
          const n = e.name;
          t.getVariable(n) === null && t.setVariable(n, new Et(0, this.getTypeInfo("u32")));
        } else if (e instanceof n2) this._call(e, t);
        else {
          if (e instanceof c5 || e instanceof i2) return null;
          console.error("Invalid statement type.", e, `Line ${e.line}`);
        }
      }
    }
    return null;
  }
  evalExpression(e, t) {
    for (; e instanceof Hm; ) e = e.contents[0];
    return e instanceof pc ? this._evalBinaryOp(e, t) : e instanceof as ? this._evalLiteral(e, t) : e instanceof Ch ? this._evalVariable(e, t) : e instanceof Kd ? this._evalCall(e, t) : e instanceof yf ? this._evalCreate(e, t) : e instanceof d5 ? this._evalConst(e, t) : e instanceof p5 ? this._evalBitcast(e, t) : e instanceof Ya ? this._evalUnaryOp(e, t) : (console.error("Invalid expression type", e, `Line ${e.line}`), null);
  }
  getTypeInfo(e) {
    var t;
    if (e instanceof ur) {
      const i = this.reflection.getTypeInfo(e);
      if (i !== null) return i;
    }
    const n = (t = this.typeInfo[e]) !== null && t !== void 0 ? t : null;
    return n !== null ? n : null;
  }
  getTypeName(e) {
    if (e === null) return console.error("Type is null."), "unknown";
    let t = e.name;
    if (e instanceof Rh || e instanceof Ht) {
      if (e.format !== null) {
        if (t === "vec2" || t === "vec3" || t === "vec4" || t === "mat2x2" || t === "mat2x3" || t === "mat2x4" || t === "mat3x2" || t === "mat3x3" || t === "mat3x4" || t === "mat4x2" || t === "mat4x3" || t === "mat4x4") {
          if (e.format.name === "f32") return t += "f", t;
          if (e.format.name === "i32") return t += "i", t;
          if (e.format.name === "u32") return t += "u", t;
          if (e.format.name === "bool") return t += "b", t;
          if (e.format.name === "f16") return t += "h", t;
        }
        t += `<${e.format.name}>`;
      } else if (t === "vec2" || t === "vec3" || t === "vec4") return t;
    }
    return t;
  }
  _setOverrides(e, t) {
    for (const n in e) {
      const i = e[n], s = this.reflection.getOverrideInfo(n);
      s !== null ? s.type.name === "u32" || s.type.name === "i32" || s.type.name === "f32" || s.type.name === "f16" ? t.setVariable(n, new Et(i, s.type)) : s.type.name === "bool" ? t.setVariable(n, new Et(i ? 1 : 0, s.type)) : s.type.name === "vec2" || s.type.name === "vec3" || s.type.name === "vec4" || s.type.name === "vec2f" || s.type.name === "vec3f" || s.type.name === "vec4f" || s.type.name === "vec2i" || s.type.name === "vec3i" || s.type.name === "vec4i" || s.type.name === "vec2u" || s.type.name === "vec3u" || s.type.name === "vec4u" || s.type.name === "vec2h" || s.type.name === "vec3h" || s.type.name === "vec4h" ? t.setVariable(n, new je(i, s.type)) : console.error(`Invalid constant type for ${n}`) : console.error(`Override ${n} does not exist in the shader.`);
    }
  }
  _dispatchWorkgroup(e, t, n) {
    const i = [1, 1, 1];
    for (const b of e.node.attributes) if (b.name === "workgroup_size") {
      if (b.value.length > 0) {
        const T = n.getVariableValue(b.value[0]);
        i[0] = T instanceof Et ? T.value : parseInt(b.value[0]);
      }
      if (b.value.length > 1) {
        const T = n.getVariableValue(b.value[1]);
        i[1] = T instanceof Et ? T.value : parseInt(b.value[1]);
      }
      if (b.value.length > 2) {
        const T = n.getVariableValue(b.value[2]);
        i[2] = T instanceof Et ? T.value : parseInt(b.value[2]);
      }
    }
    const s = this.getTypeInfo("vec3u"), l = this.getTypeInfo("u32");
    n.setVariable("@workgroup_size", new je(i, s));
    const o = i[0], d = i[1], m = i[2];
    for (let b = 0, T = 0; b < m; ++b) for (let M = 0; M < d; ++M) for (let E = 0; E < o; ++E, ++T) {
      const D = [E, M, b], U = [E + t[0] * i[0], M + t[1] * i[1], b + t[2] * i[2]];
      n.setVariable("@local_invocation_id", new je(D, s)), n.setVariable("@global_invocation_id", new je(U, s)), n.setVariable("@local_invocation_index", new Et(T, l)), this._dispatchExec(e, n);
    }
  }
  _dispatchExec(e, t) {
    for (const n of e.node.args) for (const i of n.attributes) if (i.name === "builtin") {
      const s = `@${i.value}`, l = t.getVariable(s);
      l !== void 0 && t.variables.set(n.name, l);
    }
    this._execStatements(e.node.body, t);
  }
  getVariableName(e, t) {
    return e instanceof Ch ? e.name : (console.error("Unknown variable type", e, "Line", e.line), null);
  }
  _execStatements(e, t) {
    for (const n of e) {
      if (n instanceof Array) {
        const s = t.clone(), l = this._execStatements(n, s);
        if (l) return l;
        continue;
      }
      const i = this.execStatement(n, t);
      if (i) return i;
    }
    return null;
  }
  _call(e, t) {
    const n = t.clone();
    n.currentFunctionName = e.name;
    const i = t.getFunction(e.name);
    if (i) {
      for (let s = 0; s < i.node.args.length; ++s) {
        const l = i.node.args[s], o = this.evalExpression(e.args[s], n);
        n.setVariable(l.name, o, l);
      }
      this._execStatements(i.node.body, n);
    } else this._callBuiltinFunction(e, n);
  }
  _increment(e, t) {
    const n = this.getVariableName(e.variable, t), i = t.getVariable(n);
    i ? e.operator === "++" ? i.value instanceof Et ? i.value.value++ : console.error(`Variable ${n} is not a scalar. Line ${e.line}`) : e.operator === "--" ? i.value instanceof Et ? i.value.value-- : console.error(`Variable ${n} is not a scalar. Line ${e.line}`) : console.error(`Unknown increment operator ${e.operator}. Line ${e.line}`) : console.error(`Variable ${n} not found. Line ${e.line}`);
  }
  _assign(e, t) {
    const n = this.getVariableName(e.variable, t), i = t.getVariable(n);
    if (i === null) return void console.error(`Variable ${n} not found. Line ${e.line}`);
    const s = this.evalExpression(e.value, t), l = e.operator;
    if (l === "=")
      if (i.value instanceof ls) i.value.setDataValue(this, s, e.variable.postfix, t);
      else if (e.variable.postfix) {
        if (!(i.value instanceof je || i.value instanceof Hn)) return void console.error(`Variable ${i.name} is not a vector or matrix. Line ${e.line}`);
        if (e.variable.postfix instanceof Fd) {
          const o = this.evalExpression(e.variable.postfix.index, t).value;
          if (i.value instanceof je) {
            if (!(s instanceof Et)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
            i.value.value[o] = s.value;
          } else {
            if (!(i.value instanceof Hn)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
            {
              const d = this.evalExpression(e.variable.postfix.index, t).value;
              if (d < 0) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
              if (!(s instanceof je)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
              {
                const m = this.getTypeName(i.value.typeInfo);
                if (m === "mat2x2" || m === "mat2x2f" || m === "mat2x2h") {
                  if (!(d < 2 && s.value.length === 2)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
                  i.value.value[2 * d] = s.value[0], i.value.value[2 * d + 1] = s.value[1];
                } else if (m === "mat2x3" || m === "mat2x3f" || m === "mat2x3h") {
                  if (!(d < 2 && s.value.length === 3)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
                  i.value.value[3 * d] = s.value[0], i.value.value[3 * d + 1] = s.value[1], i.value.value[3 * d + 2] = s.value[2];
                } else if (m === "mat2x4" || m === "mat2x4f" || m === "mat2x4h") {
                  if (!(d < 2 && s.value.length === 4)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
                  i.value.value[4 * d] = s.value[0], i.value.value[4 * d + 1] = s.value[1], i.value.value[4 * d + 2] = s.value[2], i.value.value[4 * d + 3] = s.value[3];
                } else if (m === "mat3x2" || m === "mat3x2f" || m === "mat3x2h") {
                  if (!(d < 3 && s.value.length === 2)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
                  i.value.value[2 * d] = s.value[0], i.value.value[2 * d + 1] = s.value[1];
                } else if (m === "mat3x3" || m === "mat3x3f" || m === "mat3x3h") {
                  if (!(d < 3 && s.value.length === 3)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
                  i.value.value[3 * d] = s.value[0], i.value.value[3 * d + 1] = s.value[1], i.value.value[3 * d + 2] = s.value[2];
                } else if (m === "mat3x4" || m === "mat3x4f" || m === "mat3x4h") {
                  if (!(d < 3 && s.value.length === 4)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
                  i.value.value[4 * d] = s.value[0], i.value.value[4 * d + 1] = s.value[1], i.value.value[4 * d + 2] = s.value[2], i.value.value[4 * d + 3] = s.value[3];
                } else if (m === "mat4x2" || m === "mat4x2f" || m === "mat4x2h") {
                  if (!(d < 4 && s.value.length === 2)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
                  i.value.value[2 * d] = s.value[0], i.value.value[2 * d + 1] = s.value[1];
                } else if (m === "mat4x3" || m === "mat4x3f" || m === "mat4x3h") {
                  if (!(d < 4 && s.value.length === 3)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
                  i.value.value[3 * d] = s.value[0], i.value.value[3 * d + 1] = s.value[1], i.value.value[3 * d + 2] = s.value[2];
                } else {
                  if (m !== "mat4x4" && m !== "mat4x4f" && m !== "mat4x4h") return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
                  if (!(d < 4 && s.value.length === 4)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
                  i.value.value[4 * d] = s.value[0], i.value.value[4 * d + 1] = s.value[1], i.value.value[4 * d + 2] = s.value[2], i.value.value[4 * d + 3] = s.value[3];
                }
              }
            }
          }
        } else if (e.variable.postfix instanceof Sf) {
          const o = e.variable.postfix.value;
          if (!(i.value instanceof je)) return void console.error(`Invalid assignment to ${o}. Variable ${i.name} is not a vector. Line ${e.line}`);
          if (s instanceof Et) {
            if (o.length > 1) return void console.error(`Invalid assignment to ${o} for variable ${i.name}. Line ${e.line}`);
            if (o === "x") i.value.value[0] = s.value;
            else if (o === "y") {
              if (i.value.value.length < 2) return void console.error(`Invalid assignment to ${o} for variable ${i.name}. Line ${e.line}`);
              i.value.value[1] = s.value;
            } else if (o === "z") {
              if (i.value.value.length < 3) return void console.error(`Invalid assignment to ${o} for variable ${i.name}. Line ${e.line}`);
              i.value.value[2] = s.value;
            } else if (o === "w") {
              if (i.value.value.length < 4) return void console.error(`Invalid assignment to ${o} for variable ${i.name}. Line ${e.line}`);
              i.value.value[3] = s.value;
            }
          } else {
            if (!(s instanceof je)) return void console.error(`Invalid assignment to ${i.name}. Line ${e.line}`);
            if (o.length !== s.value.length) return void console.error(`Invalid assignment to ${o} for variable ${i.name}. Line ${e.line}`);
            for (let d = 0; d < o.length; ++d) {
              const m = o[d];
              if (m === "x" || m === "r") i.value.value[0] = s.value[d];
              else if (m === "y" || m === "g") {
                if (s.value.length < 2) return void console.error(`Invalid assignment to ${m} for variable ${i.name}. Line ${e.line}`);
                i.value.value[1] = s.value[d];
              } else if (m === "z" || m === "b") {
                if (s.value.length < 3) return void console.error(`Invalid assignment to ${m} for variable ${i.name}. Line ${e.line}`);
                i.value.value[2] = s.value[d];
              } else {
                if (m !== "w" && m !== "a") return void console.error(`Invalid assignment to ${m} for variable ${i.name}. Line ${e.line}`);
                if (s.value.length < 4) return void console.error(`Invalid assignment to ${m} for variable ${i.name}. Line ${e.line}`);
                i.value.value[3] = s.value[d];
              }
            }
          }
        }
      } else i.value = s;
    else {
      const o = i.value.getDataValue(this, e.variable.postfix, t);
      if (o instanceof je && s instanceof Et) {
        const d = o.value, m = s.value;
        if (l === "+=") for (let b = 0; b < d.length; ++b) d[b] += m;
        else if (l === "-=") for (let b = 0; b < d.length; ++b) d[b] -= m;
        else if (l === "*=") for (let b = 0; b < d.length; ++b) d[b] *= m;
        else if (l === "/=") for (let b = 0; b < d.length; ++b) d[b] /= m;
        else if (l === "%=") for (let b = 0; b < d.length; ++b) d[b] %= m;
        else if (l === "&=") for (let b = 0; b < d.length; ++b) d[b] &= m;
        else if (l === "|=") for (let b = 0; b < d.length; ++b) d[b] |= m;
        else if (l === "^=") for (let b = 0; b < d.length; ++b) d[b] ^= m;
        else if (l === "<<=") for (let b = 0; b < d.length; ++b) d[b] <<= m;
        else if (l === ">>=") for (let b = 0; b < d.length; ++b) d[b] >>= m;
        else console.error(`Invalid operator ${l}. Line ${e.line}`);
      } else if (o instanceof je && s instanceof je) {
        const d = o.value, m = s.value;
        if (d.length !== m.length) return void console.error(`Vector length mismatch. Line ${e.line}`);
        if (l === "+=") for (let b = 0; b < d.length; ++b) d[b] += m[b];
        else if (l === "-=") for (let b = 0; b < d.length; ++b) d[b] -= m[b];
        else if (l === "*=") for (let b = 0; b < d.length; ++b) d[b] *= m[b];
        else if (l === "/=") for (let b = 0; b < d.length; ++b) d[b] /= m[b];
        else if (l === "%=") for (let b = 0; b < d.length; ++b) d[b] %= m[b];
        else if (l === "&=") for (let b = 0; b < d.length; ++b) d[b] &= m[b];
        else if (l === "|=") for (let b = 0; b < d.length; ++b) d[b] |= m[b];
        else if (l === "^=") for (let b = 0; b < d.length; ++b) d[b] ^= m[b];
        else if (l === "<<=") for (let b = 0; b < d.length; ++b) d[b] <<= m[b];
        else if (l === ">>=") for (let b = 0; b < d.length; ++b) d[b] >>= m[b];
        else console.error(`Invalid operator ${l}. Line ${e.line}`);
      } else {
        if (!(o instanceof Et && s instanceof Et)) return void console.error(`Invalid type for ${e.operator} operator. Line ${e.line}`);
        l === "+=" ? o.value += s.value : l === "-=" ? o.value -= s.value : l === "*=" ? o.value *= s.value : l === "/=" ? o.value /= s.value : l === "%=" ? o.value %= s.value : l === "&=" ? o.value &= s.value : l === "|=" ? o.value |= s.value : l === "^=" ? o.value ^= s.value : l === "<<=" ? o.value <<= s.value : l === ">>=" ? o.value >>= s.value : console.error(`Invalid operator ${l}. Line ${e.line}`);
      }
      i.value instanceof ls && i.value.setDataValue(this, o, e.variable.postfix, t);
    }
  }
  _function(e, t) {
    const n = new o2(e);
    t.functions.set(e.name, n);
  }
  _const(e, t) {
    let n = null;
    e.value != null && (n = this.evalExpression(e.value, t)), t.createVariable(e.name, n, e);
  }
  _let(e, t) {
    let n = null;
    e.value != null && (n = this.evalExpression(e.value, t)), t.createVariable(e.name, n, e);
  }
  _var(e, t) {
    let n = null;
    if (e.value !== null) n = this.evalExpression(e.value, t);
    else {
      if (e.type === null) return void console.error(`Variable ${e.name} has no type. Line ${e.line}`);
      if (e.type.name === "f32" || e.type.name === "i32" || e.type.name === "u32" || e.type.name === "bool" || e.type.name === "f16" || e.type.name === "vec2" || e.type.name === "vec3" || e.type.name === "vec4" || e.type.name === "vec2f" || e.type.name === "vec3f" || e.type.name === "vec4f" || e.type.name === "vec2i" || e.type.name === "vec3i" || e.type.name === "vec4i" || e.type.name === "vec2u" || e.type.name === "vec3u" || e.type.name === "vec4u" || e.type.name === "vec2h" || e.type.name === "vec3h" || e.type.name === "vec4h" || e.type.name === "mat2x2" || e.type.name === "mat2x3" || e.type.name === "mat2x4" || e.type.name === "mat3x2" || e.type.name === "mat3x3" || e.type.name === "mat3x4" || e.type.name === "mat4x2" || e.type.name === "mat4x3" || e.type.name === "mat4x4" || e.type.name === "mat2x2f" || e.type.name === "mat2x3f" || e.type.name === "mat2x4f" || e.type.name === "mat3x2f" || e.type.name === "mat3x3f" || e.type.name === "mat3x4f" || e.type.name === "mat4x2f" || e.type.name === "mat4x3f" || e.type.name === "mat4x4f" || e.type.name === "mat2x2h" || e.type.name === "mat2x3h" || e.type.name === "mat2x4h" || e.type.name === "mat3x2h" || e.type.name === "mat3x3h" || e.type.name === "mat3x4h" || e.type.name === "mat4x2h" || e.type.name === "mat4x3h" || e.type.name === "mat4x4h") {
        const i = new yf(e.type, []);
        n = this._evalCreate(i, t);
      }
      if (e.type.name === "array") {
        const i = new yf(e.type, []);
        n = this._evalCreate(i, t);
      }
    }
    t.createVariable(e.name, n, e);
  }
  _switch(e, t) {
    t = t.clone();
    const n = this.evalExpression(e.condition, t);
    if (!(n instanceof Et)) return console.error(`Invalid if condition. Line ${e.line}`), null;
    let i = null;
    for (const s of e.cases) if (s instanceof _5) for (const l of s.selectors) {
      if (l instanceof Wm) {
        i = s;
        continue;
      }
      const o = this.evalExpression(l, t);
      if (!(o instanceof Et)) return console.error(`Invalid case selector. Line ${e.line}`), null;
      if (o.value === n.value) return this._execStatements(s.body, t);
    }
    else s instanceof y5 && (i = s);
    return i ? this._execStatements(i.body, t) : null;
  }
  _if(e, t) {
    t = t.clone();
    const n = this.evalExpression(e.condition, t);
    if (!(n instanceof Et)) return console.error(`Invalid if condition. Line ${e.line}`), null;
    if (n.value) return this._execStatements(e.body, t);
    for (const i of e.elseif) {
      const s = this.evalExpression(i.condition, t);
      if (!(s instanceof Et)) return console.error(`Invalid if condition. Line ${e.line}`), null;
      if (s.value) return this._execStatements(i.body, t);
    }
    return e.else ? this._execStatements(e.else, t) : null;
  }
  _getScalarValue(e) {
    return e instanceof Et ? e.value : (console.error("Expected scalar value.", e), 0);
  }
  _for(e, t) {
    for (t = t.clone(), this.execStatement(e.init, t); this._getScalarValue(this.evalExpression(e.condition, t)); ) {
      const n = this._execStatements(e.body, t);
      if (n === jo._breakObj) break;
      if (n !== null && n !== jo._continueObj) return n;
      this.execStatement(e.increment, t);
    }
    return null;
  }
  _loop(e, t) {
    for (t = t.clone(); ; ) {
      const n = this._execStatements(e.body, t);
      if (n === jo._breakObj) break;
      if (n === jo._continueObj) {
        if (e.continuing && this._execStatements(e.continuing.body, t) === jo._breakObj)
          break;
      } else if (n !== null) return n;
    }
    return null;
  }
  _while(e, t) {
    for (t = t.clone(); this._getScalarValue(this.evalExpression(e.condition, t)); ) {
      const n = this._execStatements(e.body, t);
      if (n === jo._breakObj) break;
      if (n !== jo._continueObj && n !== null) return n;
    }
    return null;
  }
  _evalBitcast(e, t) {
    const n = this.evalExpression(e.value, t), i = e.type;
    if (n instanceof Et) {
      const s = OA(n.value, n.typeInfo.name, i.name);
      return new Et(s, this.getTypeInfo(i));
    }
    if (n instanceof je) {
      const s = this.getTypeName(n.typeInfo);
      let l = "";
      if (s.endsWith("f")) l = "f32";
      else if (s.endsWith("i")) l = "i32";
      else if (s.endsWith("u")) l = "u32";
      else if (s.endsWith("b")) l = "bool";
      else {
        if (!s.endsWith("h")) return console.error(`Unknown vector type ${s}. Line ${e.line}`), null;
        l = "f16";
      }
      const o = this.getTypeName(i);
      let d = "";
      if (o.endsWith("f")) d = "f32";
      else if (o.endsWith("i")) d = "i32";
      else if (o.endsWith("u")) d = "u32";
      else if (o.endsWith("b")) d = "bool";
      else {
        if (!o.endsWith("h")) return console.error(`Unknown vector type ${d}. Line ${e.line}`), null;
        d = "f16";
      }
      const m = function(b, T, M) {
        if (T === M) return b;
        const E = new Array(b.length);
        for (let D = 0; D < b.length; D++) E[D] = OA(b[D], T, M);
        return E;
      }(n.value, l, d);
      return new je(m, this.getTypeInfo(i));
    }
    return console.error(`TODO: bitcast for ${n.typeInfo.name}. Line ${e.line}`), null;
  }
  _evalConst(e, t) {
    const n = t.getVariableValue(e.name);
    return e.postfix ? n.getDataValue(this, e.postfix, t) : n;
  }
  _evalCreate(e, t) {
    var n;
    if (e.type === null) return B1.void;
    const i = this.getTypeName(e.type);
    switch (i) {
      case "bool":
      case "i32":
      case "u32":
      case "f32":
      case "f16":
        return this._callConstructorValue(e, t);
      case "vec2":
      case "vec3":
      case "vec4":
      case "vec2f":
      case "vec3f":
      case "vec4f":
      case "vec2h":
      case "vec3h":
      case "vec4h":
      case "vec2i":
      case "vec3i":
      case "vec4i":
      case "vec2u":
      case "vec3u":
      case "vec4u":
      case "vec2b":
      case "vec3b":
      case "vec4b":
        return this._callConstructorVec(e, t);
      case "mat2x2":
      case "mat2x2f":
      case "mat2x2h":
      case "mat2x3":
      case "mat2x3f":
      case "mat2x3h":
      case "mat2x4":
      case "mat2x4f":
      case "mat2x4h":
      case "mat3x2":
      case "mat3x2f":
      case "mat3x2h":
      case "mat3x3":
      case "mat3x3f":
      case "mat3x3h":
      case "mat3x4":
      case "mat3x4f":
      case "mat3x4h":
      case "mat4x2":
      case "mat4x2f":
      case "mat4x2h":
      case "mat4x3":
      case "mat4x3f":
      case "mat4x3h":
      case "mat4x4":
      case "mat4x4f":
      case "mat4x4h":
        return this._callConstructorMatrix(e, t);
    }
    const s = this.getTypeInfo(e.type);
    if (s === null) return console.error(`Unknown type ${i}. Line ${e.line}`), null;
    if (s.size === 0) return null;
    const l = new ls(new ArrayBuffer(s.size), s, 0);
    if (s instanceof wh) {
      if (e.args) for (let o = 0; o < e.args.length; ++o) {
        const d = s.members[o], m = e.args[o], b = this.evalExpression(m, t);
        l.setData(this, b, d.type, d.offset, t);
      }
    } else if (s instanceof _f) {
      let o = 0;
      if (e.args) for (let d = 0; d < e.args.length; ++d) {
        const m = e.args[d], b = this.evalExpression(m, t);
        s.format === null && (((n = b.typeInfo) === null || n === void 0 ? void 0 : n.name) === "x32" ? s.format = this.getTypeInfo("i32") : s.format = b.typeInfo), l.setData(this, b, s.format, o, t), o += s.stride;
      }
    } else console.error(`Unknown type "${i}". Line ${e.line}`);
    return l;
  }
  _evalLiteral(e, t) {
    const n = this.getTypeInfo(e.type), i = n.name;
    return i === "x32" || i === "u32" || i === "f32" || i === "f16" || i === "i32" || i === "bool" ? new Et(e.scalarValue, n) : i === "vec2" || i === "vec3" || i === "vec4" || i === "vec2f" || i === "vec3f" || i === "vec4f" || i === "vec2h" || i === "vec3h" || i === "vec4h" || i === "vec2i" || i === "vec3i" || i === "vec4i" || i === "vec2u" || i === "vec3u" || i === "vec4u" ? this._callConstructorVec(e, t) : i === "mat2x2" || i === "mat2x3" || i === "mat2x4" || i === "mat3x2" || i === "mat3x3" || i === "mat3x4" || i === "mat4x2" || i === "mat4x3" || i === "mat4x4" || i === "mat2x2f" || i === "mat2x3f" || i === "mat2x4f" || i === "mat3x2f" || i === "mat3x3f" || i === "mat3x4f" || i === "mat4x2f" || i === "mat4x3f" || i === "mat4x4f" || i === "mat2x2h" || i === "mat2x3h" || i === "mat2x4h" || i === "mat3x2h" || i === "mat3x3h" || i === "mat3x4h" || i === "mat4x2h" || i === "mat4x3h" || i === "mat4x4h" ? this._callConstructorMatrix(e, t) : e.value;
  }
  _evalVariable(e, t) {
    const n = t.getVariableValue(e.name);
    return n === null ? n : e != null && e.postfix ? n.getDataValue(this, e.postfix, t) : n;
  }
  _maxFormatTypeInfo(e) {
    let t = e[0];
    if (t.name === "f32") return t;
    for (let n = 1; n < e.length; ++n) {
      const i = jo._priority.get(t.name);
      jo._priority.get(e[n].name) < i && (t = e[n]);
    }
    return t.name === "x32" ? this.getTypeInfo("i32") : t;
  }
  _evalUnaryOp(e, t) {
    const n = this.evalExpression(e.right, t), i = n instanceof Et || n instanceof je ? n.value : null;
    switch (e.operator) {
      case "+": {
        if (Sr(i)) {
          const o = i.map((d, m) => +d);
          return new je(o, n.typeInfo);
        }
        const s = i, l = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new Et(+s, l);
      }
      case "-": {
        if (Sr(i)) {
          const o = i.map((d, m) => -d);
          return new je(o, n.typeInfo);
        }
        const s = i, l = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new Et(-s, l);
      }
      case "!": {
        if (Sr(i)) {
          const o = i.map((d, m) => d ? 0 : 1);
          return new je(o, n.typeInfo);
        }
        const s = i, l = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new Et(s ? 0 : 1, l);
      }
      case "~": {
        if (Sr(i)) {
          const o = i.map((d, m) => ~d);
          return new je(o, n.typeInfo);
        }
        const s = i, l = this._maxFormatTypeInfo([n.typeInfo, n.typeInfo]);
        return new Et(~s, l);
      }
    }
    return console.error(`Invalid unary operator ${e.operator}. Line ${e.line}`), null;
  }
  _evalBinaryOp(e, t) {
    const n = this.evalExpression(e.left, t), i = this.evalExpression(e.right, t), s = n instanceof Et || n instanceof je || n instanceof Hn ? n.value : null, l = i instanceof Et || i instanceof je || i instanceof Hn ? i.value : null;
    switch (e.operator) {
      case "+": {
        if (Sr(s) && Sr(l)) {
          const b = s, T = l;
          if (b.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, D) => E + T[D]);
          return new je(M, n.typeInfo);
        }
        if (Sr(s)) {
          const b = l, T = s.map((M, E) => M + b);
          return new je(T, n.typeInfo);
        }
        if (Sr(l)) {
          const b = s, T = l.map((M, E) => b + M);
          return new je(T, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new Et(o + d, m);
      }
      case "-": {
        if (Sr(s) && Sr(l)) {
          const b = s, T = l;
          if (b.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, D) => E - T[D]);
          return new je(M, n.typeInfo);
        }
        if (Sr(s)) {
          const b = l, T = s.map((M, E) => M - b);
          return new je(T, n.typeInfo);
        }
        if (Sr(l)) {
          const b = s, T = l.map((M, E) => b - M);
          return new je(T, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new Et(o - d, m);
      }
      case "*": {
        if (Sr(s) && Sr(l)) {
          const b = s, T = l;
          if (b.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, D) => E * T[D]);
          return new je(M, n.typeInfo);
        }
        if (Sr(s)) {
          const b = l, T = s.map((M, E) => M * b);
          return new je(T, n.typeInfo);
        }
        if (Sr(l)) {
          const b = s, T = l.map((M, E) => b * M);
          return new je(T, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new Et(o * d, m);
      }
      case "%": {
        if (Sr(s) && Sr(l)) {
          const b = s, T = l;
          if (b.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, D) => E % T[D]);
          return new je(M, n.typeInfo);
        }
        if (Sr(s)) {
          const b = l, T = s.map((M, E) => M % b);
          return new je(T, n.typeInfo);
        }
        if (Sr(l)) {
          const b = s, T = l.map((M, E) => b % M);
          return new je(T, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new Et(o % d, m);
      }
      case "/": {
        if (Sr(s) && Sr(l)) {
          const b = s, T = l;
          if (b.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, D) => E / T[D]);
          return new je(M, n.typeInfo);
        }
        if (Sr(s)) {
          const b = l, T = s.map((M, E) => M / b);
          return new je(T, n.typeInfo);
        }
        if (Sr(l)) {
          const b = s, T = l.map((M, E) => b / M);
          return new je(T, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new Et(o / d, m);
      }
      case "&": {
        if (Sr(s) && Sr(l)) {
          const b = s, T = l;
          if (b.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, D) => E & T[D]);
          return new je(M, n.typeInfo);
        }
        if (Sr(s)) {
          const b = l, T = s.map((M, E) => M & b);
          return new je(T, n.typeInfo);
        }
        if (Sr(l)) {
          const b = s, T = l.map((M, E) => b & M);
          return new je(T, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new Et(o & d, m);
      }
      case "|": {
        if (Sr(s) && Sr(l)) {
          const b = s, T = l;
          if (b.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, D) => E | T[D]);
          return new je(M, n.typeInfo);
        }
        if (Sr(s)) {
          const b = l, T = s.map((M, E) => M | b);
          return new je(T, n.typeInfo);
        }
        if (Sr(l)) {
          const b = s, T = l.map((M, E) => b | M);
          return new je(T, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new Et(o | d, m);
      }
      case "^": {
        if (Sr(s) && Sr(l)) {
          const b = s, T = l;
          if (b.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, D) => E ^ T[D]);
          return new je(M, n.typeInfo);
        }
        if (Sr(s)) {
          const b = l, T = s.map((M, E) => M ^ b);
          return new je(T, n.typeInfo);
        }
        if (Sr(l)) {
          const b = s, T = l.map((M, E) => b ^ M);
          return new je(T, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new Et(o ^ d, m);
      }
      case "<<": {
        if (Sr(s) && Sr(l)) {
          const b = s, T = l;
          if (b.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, D) => E << T[D]);
          return new je(M, n.typeInfo);
        }
        if (Sr(s)) {
          const b = l, T = s.map((M, E) => M << b);
          return new je(T, n.typeInfo);
        }
        if (Sr(l)) {
          const b = s, T = l.map((M, E) => b << M);
          return new je(T, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new Et(o << d, m);
      }
      case ">>": {
        if (Sr(s) && Sr(l)) {
          const b = s, T = l;
          if (b.length !== T.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const M = b.map((E, D) => E >> T[D]);
          return new je(M, n.typeInfo);
        }
        if (Sr(s)) {
          const b = l, T = s.map((M, E) => M >> b);
          return new je(T, n.typeInfo);
        }
        if (Sr(l)) {
          const b = s, T = l.map((M, E) => b >> M);
          return new je(T, i.typeInfo);
        }
        const o = s, d = l, m = this._maxFormatTypeInfo([n.typeInfo, i.typeInfo]);
        return new Et(o >> d, m);
      }
      case ">":
        if (Sr(s) && Sr(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, T) => b > d[T] ? 1 : 0);
          return new je(m, n.typeInfo);
        }
        if (Sr(s)) {
          const o = l, d = s.map((m, b) => m > o ? 1 : 0);
          return new je(d, n.typeInfo);
        }
        if (Sr(l)) {
          const o = s, d = l.map((m, b) => o > m ? 1 : 0);
          return new je(d, i.typeInfo);
        }
        return new Et(s > l ? 1 : 0, this.getTypeInfo("bool"));
      case "<":
        if (Sr(s) && Sr(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, T) => b < d[T] ? 1 : 0);
          return new je(m, n.typeInfo);
        }
        if (Sr(s)) {
          const o = l, d = s.map((m, b) => m < o ? 1 : 0);
          return new je(d, n.typeInfo);
        }
        if (Sr(l)) {
          const o = s, d = l.map((m, b) => o < m ? 1 : 0);
          return new je(d, i.typeInfo);
        }
        return new Et(s < l ? 1 : 0, this.getTypeInfo("bool"));
      case "==":
        if (Sr(s) && Sr(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, T) => b === d[T] ? 1 : 0);
          return new je(m, n.typeInfo);
        }
        if (Sr(s)) {
          const o = l, d = s.map((m, b) => m == o ? 1 : 0);
          return new je(d, n.typeInfo);
        }
        if (Sr(l)) {
          const o = s, d = l.map((m, b) => o == m ? 1 : 0);
          return new je(d, i.typeInfo);
        }
        return new Et(s === l ? 1 : 0, this.getTypeInfo("bool"));
      case "!=":
        if (Sr(s) && Sr(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, T) => b !== d[T] ? 1 : 0);
          return new je(m, n.typeInfo);
        }
        if (Sr(s)) {
          const o = l, d = s.map((m, b) => m !== o ? 1 : 0);
          return new je(d, n.typeInfo);
        }
        if (Sr(l)) {
          const o = s, d = l.map((m, b) => o !== m ? 1 : 0);
          return new je(d, i.typeInfo);
        }
        return new Et(s !== l ? 1 : 0, this.getTypeInfo("bool"));
      case ">=":
        if (Sr(s) && Sr(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, T) => b >= d[T] ? 1 : 0);
          return new je(m, n.typeInfo);
        }
        if (Sr(s)) {
          const o = l, d = s.map((m, b) => m >= o ? 1 : 0);
          return new je(d, n.typeInfo);
        }
        if (Sr(l)) {
          const o = s, d = l.map((m, b) => o >= m ? 1 : 0);
          return new je(d, i.typeInfo);
        }
        return new Et(s >= l ? 1 : 0, this.getTypeInfo("bool"));
      case "<=":
        if (Sr(s) && Sr(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, T) => b <= d[T] ? 1 : 0);
          return new je(m, n.typeInfo);
        }
        if (Sr(s)) {
          const o = l, d = s.map((m, b) => m <= o ? 1 : 0);
          return new je(d, n.typeInfo);
        }
        if (Sr(l)) {
          const o = s, d = l.map((m, b) => o <= m ? 1 : 0);
          return new je(d, i.typeInfo);
        }
        return new Et(s <= l ? 1 : 0, this.getTypeInfo("bool"));
      case "&&":
        if (Sr(s) && Sr(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, T) => b && d[T] ? 1 : 0);
          return new je(m, n.typeInfo);
        }
        if (Sr(s)) {
          const o = l, d = s.map((m, b) => m && o ? 1 : 0);
          return new je(d, n.typeInfo);
        }
        if (Sr(l)) {
          const o = s, d = l.map((m, b) => o && m ? 1 : 0);
          return new je(d, i.typeInfo);
        }
        return new Et(s && l ? 1 : 0, this.getTypeInfo("bool"));
      case "||":
        if (Sr(s) && Sr(l)) {
          const o = s, d = l;
          if (o.length !== d.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
          const m = o.map((b, T) => b || d[T] ? 1 : 0);
          return new je(m, n.typeInfo);
        }
        if (Sr(s)) {
          const o = l, d = s.map((m, b) => m || o ? 1 : 0);
          return new je(d, n.typeInfo);
        }
        if (Sr(l)) {
          const o = s, d = l.map((m, b) => o || m ? 1 : 0);
          return new je(d, i.typeInfo);
        }
        return new Et(s || l ? 1 : 0, this.getTypeInfo("bool"));
    }
    return console.error(`Unknown operator ${e.operator}. Line ${e.line}`), null;
  }
  _evalCall(e, t) {
    if (e.cachedReturnValue !== null) return e.cachedReturnValue;
    const n = t.clone();
    n.currentFunctionName = e.name;
    const i = t.getFunction(e.name);
    if (!i) return this._callBuiltinFunction(e, n);
    for (let s = 0; s < i.node.args.length; ++s) {
      const l = i.node.args[s], o = this.evalExpression(e.args[s], n);
      n.createVariable(l.name, o, l);
    }
    return this._execStatements(i.node.body, n);
  }
  _callBuiltinFunction(e, t) {
    switch (e.name) {
      case "all":
        return this.builtins.All(e, t);
      case "any":
        return this.builtins.Any(e, t);
      case "select":
        return this.builtins.Select(e, t);
      case "arrayLength":
        return this.builtins.ArrayLength(e, t);
      case "abs":
        return this.builtins.Abs(e, t);
      case "acos":
        return this.builtins.Acos(e, t);
      case "acosh":
        return this.builtins.Acosh(e, t);
      case "asin":
        return this.builtins.Asin(e, t);
      case "asinh":
        return this.builtins.Asinh(e, t);
      case "atan":
        return this.builtins.Atan(e, t);
      case "atanh":
        return this.builtins.Atanh(e, t);
      case "atan2":
        return this.builtins.Atan2(e, t);
      case "ceil":
        return this.builtins.Ceil(e, t);
      case "clamp":
        return this.builtins.Clamp(e, t);
      case "cos":
        return this.builtins.Cos(e, t);
      case "cosh":
        return this.builtins.Cosh(e, t);
      case "countLeadingZeros":
        return this.builtins.CountLeadingZeros(e, t);
      case "countOneBits":
        return this.builtins.CountOneBits(e, t);
      case "countTrailingZeros":
        return this.builtins.CountTrailingZeros(e, t);
      case "cross":
        return this.builtins.Cross(e, t);
      case "degrees":
        return this.builtins.Degrees(e, t);
      case "determinant":
        return this.builtins.Determinant(e, t);
      case "distance":
        return this.builtins.Distance(e, t);
      case "dot":
        return this.builtins.Dot(e, t);
      case "dot4U8Packed":
        return this.builtins.Dot4U8Packed(e, t);
      case "dot4I8Packed":
        return this.builtins.Dot4I8Packed(e, t);
      case "exp":
        return this.builtins.Exp(e, t);
      case "exp2":
        return this.builtins.Exp2(e, t);
      case "extractBits":
        return this.builtins.ExtractBits(e, t);
      case "faceForward":
        return this.builtins.FaceForward(e, t);
      case "firstLeadingBit":
        return this.builtins.FirstLeadingBit(e, t);
      case "firstTrailingBit":
        return this.builtins.FirstTrailingBit(e, t);
      case "floor":
        return this.builtins.Floor(e, t);
      case "fma":
        return this.builtins.Fma(e, t);
      case "fract":
        return this.builtins.Fract(e, t);
      case "frexp":
        return this.builtins.Frexp(e, t);
      case "insertBits":
        return this.builtins.InsertBits(e, t);
      case "inverseSqrt":
        return this.builtins.InverseSqrt(e, t);
      case "ldexp":
        return this.builtins.Ldexp(e, t);
      case "length":
        return this.builtins.Length(e, t);
      case "log":
        return this.builtins.Log(e, t);
      case "log2":
        return this.builtins.Log2(e, t);
      case "max":
        return this.builtins.Max(e, t);
      case "min":
        return this.builtins.Min(e, t);
      case "mix":
        return this.builtins.Mix(e, t);
      case "modf":
        return this.builtins.Modf(e, t);
      case "normalize":
        return this.builtins.Normalize(e, t);
      case "pow":
        return this.builtins.Pow(e, t);
      case "quantizeToF16":
        return this.builtins.QuantizeToF16(e, t);
      case "radians":
        return this.builtins.Radians(e, t);
      case "reflect":
        return this.builtins.Reflect(e, t);
      case "refract":
        return this.builtins.Refract(e, t);
      case "reverseBits":
        return this.builtins.ReverseBits(e, t);
      case "round":
        return this.builtins.Round(e, t);
      case "saturate":
        return this.builtins.Saturate(e, t);
      case "sign":
        return this.builtins.Sign(e, t);
      case "sin":
        return this.builtins.Sin(e, t);
      case "sinh":
        return this.builtins.Sinh(e, t);
      case "smoothStep":
        return this.builtins.SmoothStep(e, t);
      case "sqrt":
        return this.builtins.Sqrt(e, t);
      case "step":
        return this.builtins.Step(e, t);
      case "tan":
        return this.builtins.Tan(e, t);
      case "tanh":
        return this.builtins.Tanh(e, t);
      case "transpose":
        return this.builtins.Transpose(e, t);
      case "trunc":
        return this.builtins.Trunc(e, t);
      case "dpdx":
        return this.builtins.Dpdx(e, t);
      case "dpdxCoarse":
        return this.builtins.DpdxCoarse(e, t);
      case "dpdxFine":
        return this.builtins.DpdxFine(e, t);
      case "dpdy":
        return this.builtins.Dpdy(e, t);
      case "dpdyCoarse":
        return this.builtins.DpdyCoarse(e, t);
      case "dpdyFine":
        return this.builtins.DpdyFine(e, t);
      case "fwidth":
        return this.builtins.Fwidth(e, t);
      case "fwidthCoarse":
        return this.builtins.FwidthCoarse(e, t);
      case "fwidthFine":
        return this.builtins.FwidthFine(e, t);
      case "textureDimensions":
        return this.builtins.TextureDimensions(e, t);
      case "textureGather":
        return this.builtins.TextureGather(e, t);
      case "textureGatherCompare":
        return this.builtins.TextureGatherCompare(e, t);
      case "textureLoad":
        return this.builtins.TextureLoad(e, t);
      case "textureNumLayers":
        return this.builtins.TextureNumLayers(e, t);
      case "textureNumLevels":
        return this.builtins.TextureNumLevels(e, t);
      case "textureNumSamples":
        return this.builtins.TextureNumSamples(e, t);
      case "textureSample":
        return this.builtins.TextureSample(e, t);
      case "textureSampleBias":
        return this.builtins.TextureSampleBias(e, t);
      case "textureSampleCompare":
        return this.builtins.TextureSampleCompare(e, t);
      case "textureSampleCompareLevel":
        return this.builtins.TextureSampleCompareLevel(e, t);
      case "textureSampleGrad":
        return this.builtins.TextureSampleGrad(e, t);
      case "textureSampleLevel":
        return this.builtins.TextureSampleLevel(e, t);
      case "textureSampleBaseClampToEdge":
        return this.builtins.TextureSampleBaseClampToEdge(e, t);
      case "textureStore":
        return this.builtins.TextureStore(e, t);
      case "atomicLoad":
        return this.builtins.AtomicLoad(e, t);
      case "atomicStore":
        return this.builtins.AtomicStore(e, t);
      case "atomicAdd":
        return this.builtins.AtomicAdd(e, t);
      case "atomicSub":
        return this.builtins.AtomicSub(e, t);
      case "atomicMax":
        return this.builtins.AtomicMax(e, t);
      case "atomicMin":
        return this.builtins.AtomicMin(e, t);
      case "atomicAnd":
        return this.builtins.AtomicAnd(e, t);
      case "atomicOr":
        return this.builtins.AtomicOr(e, t);
      case "atomicXor":
        return this.builtins.AtomicXor(e, t);
      case "atomicExchange":
        return this.builtins.AtomicExchange(e, t);
      case "atomicCompareExchangeWeak":
        return this.builtins.AtomicCompareExchangeWeak(e, t);
      case "pack4x8snorm":
        return this.builtins.Pack4x8snorm(e, t);
      case "pack4x8unorm":
        return this.builtins.Pack4x8unorm(e, t);
      case "pack4xI8":
        return this.builtins.Pack4xI8(e, t);
      case "pack4xU8":
        return this.builtins.Pack4xU8(e, t);
      case "pack4x8Clamp":
        return this.builtins.Pack4x8Clamp(e, t);
      case "pack4xU8Clamp":
        return this.builtins.Pack4xU8Clamp(e, t);
      case "pack2x16snorm":
        return this.builtins.Pack2x16snorm(e, t);
      case "pack2x16unorm":
        return this.builtins.Pack2x16unorm(e, t);
      case "pack2x16float":
        return this.builtins.Pack2x16float(e, t);
      case "unpack4x8snorm":
        return this.builtins.Unpack4x8snorm(e, t);
      case "unpack4x8unorm":
        return this.builtins.Unpack4x8unorm(e, t);
      case "unpack4xI8":
        return this.builtins.Unpack4xI8(e, t);
      case "unpack4xU8":
        return this.builtins.Unpack4xU8(e, t);
      case "unpack2x16snorm":
        return this.builtins.Unpack2x16snorm(e, t);
      case "unpack2x16unorm":
        return this.builtins.Unpack2x16unorm(e, t);
      case "unpack2x16float":
        return this.builtins.Unpack2x16float(e, t);
      case "storageBarrier":
        return this.builtins.StorageBarrier(e, t);
      case "textureBarrier":
        return this.builtins.TextureBarrier(e, t);
      case "workgroupBarrier":
        return this.builtins.WorkgroupBarrier(e, t);
      case "workgroupUniformLoad":
        return this.builtins.WorkgroupUniformLoad(e, t);
      case "subgroupAdd":
        return this.builtins.SubgroupAdd(e, t);
      case "subgroupExclusiveAdd":
        return this.builtins.SubgroupExclusiveAdd(e, t);
      case "subgroupInclusiveAdd":
        return this.builtins.SubgroupInclusiveAdd(e, t);
      case "subgroupAll":
        return this.builtins.SubgroupAll(e, t);
      case "subgroupAnd":
        return this.builtins.SubgroupAnd(e, t);
      case "subgroupAny":
        return this.builtins.SubgroupAny(e, t);
      case "subgroupBallot":
        return this.builtins.SubgroupBallot(e, t);
      case "subgroupBroadcast":
        return this.builtins.SubgroupBroadcast(e, t);
      case "subgroupBroadcastFirst":
        return this.builtins.SubgroupBroadcastFirst(e, t);
      case "subgroupElect":
        return this.builtins.SubgroupElect(e, t);
      case "subgroupMax":
        return this.builtins.SubgroupMax(e, t);
      case "subgroupMin":
        return this.builtins.SubgroupMin(e, t);
      case "subgroupMul":
        return this.builtins.SubgroupMul(e, t);
      case "subgroupExclusiveMul":
        return this.builtins.SubgroupExclusiveMul(e, t);
      case "subgroupInclusiveMul":
        return this.builtins.SubgroupInclusiveMul(e, t);
      case "subgroupOr":
        return this.builtins.SubgroupOr(e, t);
      case "subgroupShuffle":
        return this.builtins.SubgroupShuffle(e, t);
      case "subgroupShuffleDown":
        return this.builtins.SubgroupShuffleDown(e, t);
      case "subgroupShuffleUp":
        return this.builtins.SubgroupShuffleUp(e, t);
      case "subgroupShuffleXor":
        return this.builtins.SubgroupShuffleXor(e, t);
      case "subgroupXor":
        return this.builtins.SubgroupXor(e, t);
      case "quadBroadcast":
        return this.builtins.QuadBroadcast(e, t);
      case "quadSwapDiagonal":
        return this.builtins.QuadSwapDiagonal(e, t);
      case "quadSwapX":
        return this.builtins.QuadSwapX(e, t);
      case "quadSwapY":
        return this.builtins.QuadSwapY(e, t);
    }
    const n = t.getFunction(e.name);
    if (n) {
      const i = t.clone();
      for (let s = 0; s < n.node.args.length; ++s) {
        const l = n.node.args[s], o = this.evalExpression(e.args[s], i);
        i.setVariable(l.name, o, l);
      }
      return this._execStatements(n.node.body, i);
    }
    return null;
  }
  _callConstructorValue(e, t) {
    if (!e.args || e.args.length === 0) return new Et(0, this.getTypeInfo(e.type));
    const n = this.evalExpression(e.args[0], t);
    return n.typeInfo = this.getTypeInfo(e.type), n;
  }
  _callConstructorVec(e, t) {
    const n = this.getTypeInfo(e.type), i = this.getTypeName(e.type), s = {
      vec2: 2,
      vec2f: 2,
      vec2i: 2,
      vec2u: 2,
      vec2b: 2,
      vec2h: 2,
      vec3: 3,
      vec3f: 3,
      vec3i: 3,
      vec3u: 3,
      vec3b: 3,
      vec3h: 3,
      vec4: 4,
      vec4f: 4,
      vec4i: 4,
      vec4u: 4,
      vec4b: 4,
      vec4h: 4
    }[i];
    if (s === void 0) return console.error(`Invalid vec constructor ${i}. Line ${e.line}`), null;
    const l = i.endsWith("i") || i.endsWith("u"), o = [];
    if (e instanceof as)
      if (e.isVector) {
        const d = e.vectorValue;
        for (const m of d) o.push(m);
      } else o.push(e.scalarValue);
    else if (e.args) for (const d of e.args) {
      const m = this.evalExpression(d, t);
      if (m instanceof je) {
        const b = m.value;
        for (let T = 0; T < b.length; ++T) {
          let M = b[T];
          l && (M = Math.floor(M)), o.push(M);
        }
      } else if (m instanceof Et) {
        let b = m.value;
        l && (b = Math.floor(b)), o.push(b);
      }
    }
    if (e.type instanceof Ht && e.type.format === null && (e.type.format = Ht.f32), o.length === 0) {
      const d = new Array(s).fill(0);
      return new je(d, n);
    }
    if (o.length === 1) for (; o.length < s; ) o.push(o[0]);
    return o.length < s ? (console.error(`Invalid vec constructor. Line ${e.line}`), null) : new je(o.length > s ? o.slice(0, s) : o, n);
  }
  _callConstructorMatrix(e, t) {
    const n = this.getTypeInfo(e.type), i = this.getTypeName(e.type), s = {
      mat2x2: 4,
      mat2x2f: 4,
      mat2x2h: 4,
      mat2x3: 6,
      mat2x3f: 6,
      mat2x3h: 6,
      mat2x4: 8,
      mat2x4f: 8,
      mat2x4h: 8,
      mat3x2: 6,
      mat3x2f: 6,
      mat3x2h: 6,
      mat3x3: 9,
      mat3x3f: 9,
      mat3x3h: 9,
      mat3x4: 12,
      mat3x4f: 12,
      mat3x4h: 12,
      mat4x2: 8,
      mat4x2f: 8,
      mat4x2h: 8,
      mat4x3: 12,
      mat4x3f: 12,
      mat4x3h: 12,
      mat4x4: 16,
      mat4x4f: 16,
      mat4x4h: 16
    }[i];
    if (s === void 0) return console.error(`Invalid matrix constructor ${i}. Line ${e.line}`), null;
    const l = [];
    if (e instanceof as)
      if (e.isVector) {
        const o = e.vectorValue;
        for (const d of o) l.push(d);
      } else l.push(e.scalarValue);
    else if (e.args) for (const o of e.args) {
      const d = this.evalExpression(o, t);
      if (d instanceof je) {
        const m = d.value;
        for (let b = 0; b < m.length; ++b) l.push(m[b]);
      } else d instanceof Et ? l.push(d.value) : d instanceof Hn && l.push(...d.value);
    }
    if (n instanceof Rh && n.format === null && (n.format = this.getTypeInfo("f32")), l.length === 0) {
      const o = new Array(s).fill(0);
      return new Hn(o, n);
    }
    return l.length !== s ? (console.error(`Invalid matrix constructor. Line ${e.line}`), null) : new Hn(l, n);
  }
}
jo._breakObj = new Ef(new Ec("BREAK", null)), jo._continueObj = new Ef(new Ec("CONTINUE", null)), jo._priority = /* @__PURE__ */ new Map([["f32", 0], ["f16", 1], ["u32", 2], ["i32", 3], ["x32", 3]]);
let J6 = class {
  constructor() {
    this._tokens = [], this._current = 0, this._currentLine = 0, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new B6(), this._exec = new jo();
  }
  parse(e) {
    this._initialize(e), this._deferArrayCountEval.length = 0;
    const t = [];
    for (; !this._isAtEnd(); ) {
      const n = this._global_decl_or_directive();
      if (!n) break;
      t.push(n);
    }
    if (this._deferArrayCountEval.length > 0) {
      for (const n of this._deferArrayCountEval) {
        const i = n.arrayType, s = n.countNode;
        if (s instanceof Ch) {
          const l = s.name, o = this._context.constants.get(l);
          if (o) try {
            const d = o.constEvaluate(this._exec);
            i.count = d;
          } catch {
          }
        }
      }
      this._deferArrayCountEval.length = 0;
    }
    return t;
  }
  _initialize(e) {
    if (e)
      if (typeof e == "string") {
        const t = new V6(e);
        this._tokens = t.scanTokens();
      } else this._tokens = e;
    else this._tokens = [];
    this._current = 0;
  }
  _updateNode(e, t) {
    return e.line = t ?? this._currentLine, e;
  }
  _error(e, t) {
    return {
      token: e,
      message: t,
      toString: () => `${t}`
    };
  }
  _isAtEnd() {
    return this._current >= this._tokens.length || this._peek().type == Ee.eof;
  }
  _match(e) {
    if (e instanceof ut) return !!this._check(e) && (this._advance(), !0);
    for (let t = 0, n = e.length; t < n; ++t) {
      const i = e[t];
      if (this._check(i)) return this._advance(), !0;
    }
    return !1;
  }
  _consume(e, t) {
    if (this._check(e)) return this._advance();
    throw this._error(this._peek(), `${t}. Line:${this._currentLine}`);
  }
  _check(e) {
    if (this._isAtEnd()) return !1;
    const t = this._peek();
    if (e instanceof Array) {
      const n = t.type;
      let i = !1;
      for (const s of e) {
        if (n === s) return !0;
        s === Ee.tokens.name && (i = !0);
      }
      if (i) {
        const s = Ee.tokens.name.rule.exec(t.lexeme);
        if (s && s.index == 0 && s[0] == t.lexeme) return !0;
      }
      return !1;
    }
    if (t.type === e) return !0;
    if (e === Ee.tokens.name) {
      const n = Ee.tokens.name.rule.exec(t.lexeme);
      return n && n.index == 0 && n[0] == t.lexeme;
    }
    return !1;
  }
  _advance() {
    var e, t;
    return this._currentLine = (t = (e = this._peek()) === null || e === void 0 ? void 0 : e.line) !== null && t !== void 0 ? t : -1, this._isAtEnd() || this._current++, this._previous();
  }
  _peek() {
    return this._tokens[this._current];
  }
  _previous() {
    return this._tokens[this._current - 1];
  }
  _global_decl_or_directive() {
    for (; this._match(Ee.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._match(Ee.keywords.alias)) {
      const t = this._type_alias();
      return this._consume(Ee.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Ee.keywords.diagnostic)) {
      const t = this._diagnostic();
      return this._consume(Ee.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Ee.keywords.requires)) {
      const t = this._requires_directive();
      return this._consume(Ee.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    if (this._match(Ee.keywords.enable)) {
      const t = this._enable_directive();
      return this._consume(Ee.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([t]), t;
    }
    const e = this._attribute();
    if (this._check(Ee.keywords.var)) {
      const t = this._global_variable_decl();
      return t != null && (t.attributes = e), this._consume(Ee.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ee.keywords.override)) {
      const t = this._override_variable_decl();
      return t != null && (t.attributes = e), this._consume(Ee.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ee.keywords.let)) {
      const t = this._global_let_decl();
      return t != null && (t.attributes = e), this._consume(Ee.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ee.keywords.const)) {
      const t = this._global_const_decl();
      return t != null && (t.attributes = e), this._consume(Ee.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ee.keywords.struct)) {
      const t = this._struct_decl();
      return t != null && (t.attributes = e), this._exec.reflection.updateAST([t]), t;
    }
    if (this._check(Ee.keywords.fn)) {
      const t = this._function_decl();
      return t != null && (t.attributes = e), this._exec.reflection.updateAST([t]), t;
    }
    return null;
  }
  _function_decl() {
    if (!this._match(Ee.keywords.fn)) return null;
    const e = this._currentLine, t = this._consume(Ee.tokens.ident, "Expected function name.").toString();
    this._consume(Ee.tokens.paren_left, "Expected '(' for function arguments.");
    const n = [];
    if (!this._check(Ee.tokens.paren_right)) do {
      if (this._check(Ee.tokens.paren_right)) break;
      const o = this._attribute(), d = this._consume(Ee.tokens.name, "Expected argument name.").toString();
      this._consume(Ee.tokens.colon, "Expected ':' for argument type.");
      const m = this._attribute(), b = this._type_decl();
      b != null && (b.attributes = m, n.push(this._updateNode(new F6(d, b, o))));
    } while (this._match(Ee.tokens.comma));
    this._consume(Ee.tokens.paren_right, "Expected ')' after function arguments.");
    let i = null;
    if (this._match(Ee.tokens.arrow)) {
      const o = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = o);
    }
    const s = this._compound_statement(), l = this._currentLine;
    return this._updateNode(new P_(t, n, i, s, e, l), e);
  }
  _compound_statement() {
    const e = [];
    for (this._consume(Ee.tokens.brace_left, "Expected '{' for block."); !this._check(Ee.tokens.brace_right); ) {
      const t = this._statement();
      t !== null && e.push(t);
    }
    return this._consume(Ee.tokens.brace_right, "Expected '}' for block."), e;
  }
  _statement() {
    for (; this._match(Ee.tokens.semicolon) && !this._isAtEnd(); ) ;
    if (this._check(Ee.tokens.attr) && this._attribute(), this._check(Ee.keywords.if)) return this._if_statement();
    if (this._check(Ee.keywords.switch)) return this._switch_statement();
    if (this._check(Ee.keywords.loop)) return this._loop_statement();
    if (this._check(Ee.keywords.for)) return this._for_statement();
    if (this._check(Ee.keywords.while)) return this._while_statement();
    if (this._check(Ee.keywords.continuing)) return this._continuing_statement();
    if (this._check(Ee.keywords.static_assert)) return this._static_assert_statement();
    if (this._check(Ee.tokens.brace_left)) return this._compound_statement();
    let e = null;
    if (this._check(Ee.keywords.return)) e = this._return_statement();
    else if (this._check([Ee.keywords.var, Ee.keywords.let, Ee.keywords.const])) e = this._variable_statement();
    else if (this._match(Ee.keywords.discard)) e = this._updateNode(new D6());
    else if (this._match(Ee.keywords.break)) {
      const t = this._updateNode(new u5());
      if (this._currentLoop.length > 0) {
        const n = this._currentLoop[this._currentLoop.length - 1];
        t.loopId = n.id;
      }
      e = t, this._check(Ee.keywords.if) && (this._advance(), t.condition = this._optional_paren_expression(), t.condition instanceof Hm && t.condition.contents.length === 1 && (t.condition = t.condition.contents[0]));
    } else if (this._match(Ee.keywords.continue)) {
      const t = this._updateNode(new h5());
      if (!(this._currentLoop.length > 0)) throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${t.line}`);
      {
        const n = this._currentLoop[this._currentLoop.length - 1];
        t.loopId = n.id;
      }
      e = t;
    } else e = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
    return e != null && this._consume(Ee.tokens.semicolon, "Expected ';' after statement."), e;
  }
  _static_assert_statement() {
    if (!this._match(Ee.keywords.static_assert)) return null;
    const e = this._optional_paren_expression();
    return this._updateNode(new L6(e));
  }
  _while_statement() {
    if (!this._match(Ee.keywords.while)) return null;
    const e = this._updateNode(new t5(null, null));
    return this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(Ee.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
  }
  _continuing_statement() {
    if (!this._match(Ee.keywords.continuing)) return null;
    const e = this._compound_statement();
    return this._updateNode(new P1(e));
  }
  _for_statement() {
    if (!this._match(Ee.keywords.for)) return null;
    this._consume(Ee.tokens.paren_left, "Expected '('.");
    const e = this._updateNode(new r5(null, null, null, null));
    return this._currentLoop.push(e), e.init = this._check(Ee.tokens.semicolon) ? null : this._for_init(), this._consume(Ee.tokens.semicolon, "Expected ';'."), e.condition = this._check(Ee.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(Ee.tokens.semicolon, "Expected ';'."), e.increment = this._check(Ee.tokens.paren_right) ? null : this._for_increment(), this._consume(Ee.tokens.paren_right, "Expected ')'."), this._check(Ee.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
  }
  _for_init() {
    return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
  }
  _for_increment() {
    return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
  }
  _variable_statement() {
    if (this._check(Ee.keywords.var)) {
      const e = this._variable_decl();
      if (e === null) throw this._error(this._peek(), "Variable declaration expected.");
      let t = null;
      return this._match(Ee.tokens.equal) && (t = this._short_circuit_or_expression()), this._updateNode(new xh(e.name, e.type, e.storage, e.access, t));
    }
    if (this._match(Ee.keywords.let)) {
      const e = this._consume(Ee.tokens.name, "Expected name for let.").toString();
      let t = null;
      if (this._match(Ee.tokens.colon)) {
        const i = this._attribute();
        t = this._type_decl(), t != null && (t.attributes = i);
      }
      this._consume(Ee.tokens.equal, "Expected '=' for let.");
      const n = this._short_circuit_or_expression();
      return this._updateNode(new R_(e, t, null, null, n));
    }
    if (this._match(Ee.keywords.const)) {
      const e = this._consume(Ee.tokens.name, "Expected name for const.").toString();
      let t = null;
      if (this._match(Ee.tokens.colon)) {
        const i = this._attribute();
        t = this._type_decl(), t != null && (t.attributes = i);
      }
      this._consume(Ee.tokens.equal, "Expected '=' for const.");
      const n = this._short_circuit_or_expression();
      return t === null && n instanceof as && (t = n.type), this._updateNode(new R1(e, t, null, null, n));
    }
    return null;
  }
  _increment_decrement_statement() {
    const e = this._current, t = this._unary_expression();
    if (t == null) return null;
    if (!this._check(Ee.increment_operators)) return this._current = e, null;
    const n = this._consume(Ee.increment_operators, "Expected increment operator");
    return this._updateNode(new n5(n.type === Ee.tokens.plus_plus ? md.increment : md.decrement, t));
  }
  _assignment_statement() {
    let e = null;
    if (this._check(Ee.tokens.brace_right)) return null;
    let t = this._match(Ee.tokens.underscore);
    if (t || (e = this._unary_expression()), !t && e == null) return null;
    const n = this._consume(Ee.assignment_operators, "Expected assignment operator."), i = this._short_circuit_or_expression();
    return this._updateNode(new i5(Gp.parse(n.lexeme), e, i));
  }
  _func_call_statement() {
    if (!this._check(Ee.tokens.ident)) return null;
    const e = this._current, t = this._consume(Ee.tokens.ident, "Expected function name."), n = this._argument_expression_list();
    return n === null ? (this._current = e, null) : this._updateNode(new n2(t.lexeme, n));
  }
  _loop_statement() {
    if (!this._match(Ee.keywords.loop)) return null;
    this._check(Ee.tokens.attr) && this._attribute(), this._consume(Ee.tokens.brace_left, "Expected '{' for loop.");
    const e = this._updateNode(new s5([], null));
    this._currentLoop.push(e);
    let t = this._statement();
    for (; t !== null; ) {
      if (Array.isArray(t)) for (let n of t) e.body.push(n);
      else e.body.push(t);
      if (t instanceof P1) {
        e.continuing = t;
        break;
      }
      t = this._statement();
    }
    return this._currentLoop.pop(), this._consume(Ee.tokens.brace_right, "Expected '}' for loop."), e;
  }
  _switch_statement() {
    if (!this._match(Ee.keywords.switch)) return null;
    const e = this._updateNode(new o5(null, []));
    if (this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(Ee.tokens.attr) && this._attribute(), this._consume(Ee.tokens.brace_left, "Expected '{' for switch."), e.cases = this._switch_body(), e.cases == null || e.cases.length == 0) throw this._error(this._previous(), "Expected 'case' or 'default'.");
    return this._consume(Ee.tokens.brace_right, "Expected '}' for switch."), this._currentLoop.pop(), e;
  }
  _switch_body() {
    const e = [];
    let t = !1;
    for (; this._check([Ee.keywords.default, Ee.keywords.case]); ) {
      if (this._match(Ee.keywords.case)) {
        const n = this._case_selectors();
        for (const s of n) if (s instanceof Wm) {
          if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
          t = !0;
          break;
        }
        this._match(Ee.tokens.colon), this._check(Ee.tokens.attr) && this._attribute(), this._consume(Ee.tokens.brace_left, "Exected '{' for switch case.");
        const i = this._case_body();
        this._consume(Ee.tokens.brace_right, "Exected '}' for switch case."), e.push(this._updateNode(new _5(n, i)));
      }
      if (this._match(Ee.keywords.default)) {
        if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
        this._match(Ee.tokens.colon), this._check(Ee.tokens.attr) && this._attribute(), this._consume(Ee.tokens.brace_left, "Exected '{' for switch default.");
        const n = this._case_body();
        this._consume(Ee.tokens.brace_right, "Exected '}' for switch default."), e.push(this._updateNode(new y5(n)));
      }
    }
    return e;
  }
  _case_selectors() {
    const e = [];
    for (this._match(Ee.keywords.default) ? e.push(this._updateNode(new Wm())) : e.push(this._shift_expression()); this._match(Ee.tokens.comma); ) this._match(Ee.keywords.default) ? e.push(this._updateNode(new Wm())) : e.push(this._shift_expression());
    return e;
  }
  _case_body() {
    if (this._match(Ee.keywords.fallthrough)) return this._consume(Ee.tokens.semicolon, "Expected ';'"), [];
    let e = this._statement();
    if (e == null) return [];
    e instanceof Array || (e = [e]);
    const t = this._case_body();
    return t.length == 0 ? e : [...e, t[0]];
  }
  _if_statement() {
    if (!this._match(Ee.keywords.if)) return null;
    const e = this._currentLine, t = this._optional_paren_expression();
    this._check(Ee.tokens.attr) && this._attribute();
    const n = this._compound_statement();
    let i = [];
    this._match_elseif() && (this._check(Ee.tokens.attr) && this._attribute(), i = this._elseif_statement(i));
    let s = null;
    return this._match(Ee.keywords.else) && (this._check(Ee.tokens.attr) && this._attribute(), s = this._compound_statement()), this._updateNode(new a5(t, n, i, s), e);
  }
  _match_elseif() {
    return this._tokens[this._current].type === Ee.keywords.else && this._tokens[this._current + 1].type === Ee.keywords.if && (this._advance(), this._advance(), !0);
  }
  _elseif_statement() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = this._optional_paren_expression(), n = this._compound_statement();
    return e.push(this._updateNode(new U6(t, n))), this._match_elseif() && (this._check(Ee.tokens.attr) && this._attribute(), this._elseif_statement(e)), e;
  }
  _return_statement() {
    if (!this._match(Ee.keywords.return)) return null;
    const e = this._short_circuit_or_expression();
    return this._updateNode(new l5(e));
  }
  _short_circuit_or_expression() {
    let e = this._short_circuit_and_expr();
    for (; this._match(Ee.tokens.or_or); ) e = this._updateNode(new pc(this._previous().toString(), e, this._short_circuit_and_expr()));
    return e;
  }
  _short_circuit_and_expr() {
    let e = this._inclusive_or_expression();
    for (; this._match(Ee.tokens.and_and); ) e = this._updateNode(new pc(this._previous().toString(), e, this._inclusive_or_expression()));
    return e;
  }
  _inclusive_or_expression() {
    let e = this._exclusive_or_expression();
    for (; this._match(Ee.tokens.or); ) e = this._updateNode(new pc(this._previous().toString(), e, this._exclusive_or_expression()));
    return e;
  }
  _exclusive_or_expression() {
    let e = this._and_expression();
    for (; this._match(Ee.tokens.xor); ) e = this._updateNode(new pc(this._previous().toString(), e, this._and_expression()));
    return e;
  }
  _and_expression() {
    let e = this._equality_expression();
    for (; this._match(Ee.tokens.and); ) e = this._updateNode(new pc(this._previous().toString(), e, this._equality_expression()));
    return e;
  }
  _equality_expression() {
    const e = this._relational_expression();
    return this._match([Ee.tokens.equal_equal, Ee.tokens.not_equal]) ? this._updateNode(new pc(this._previous().toString(), e, this._relational_expression())) : e;
  }
  _relational_expression() {
    let e = this._shift_expression();
    for (; this._match([Ee.tokens.less_than, Ee.tokens.greater_than, Ee.tokens.less_than_equal, Ee.tokens.greater_than_equal]); ) e = this._updateNode(new pc(this._previous().toString(), e, this._shift_expression()));
    return e;
  }
  _shift_expression() {
    let e = this._additive_expression();
    for (; this._match([Ee.tokens.shift_left, Ee.tokens.shift_right]); ) e = this._updateNode(new pc(this._previous().toString(), e, this._additive_expression()));
    return e;
  }
  _additive_expression() {
    let e = this._multiplicative_expression();
    for (; this._match([Ee.tokens.plus, Ee.tokens.minus]); ) e = this._updateNode(new pc(this._previous().toString(), e, this._multiplicative_expression()));
    return e;
  }
  _multiplicative_expression() {
    let e = this._unary_expression();
    for (; this._match([Ee.tokens.star, Ee.tokens.forward_slash, Ee.tokens.modulo]); ) e = this._updateNode(new pc(this._previous().toString(), e, this._unary_expression()));
    return e;
  }
  _unary_expression() {
    return this._match([Ee.tokens.minus, Ee.tokens.bang, Ee.tokens.tilde, Ee.tokens.star, Ee.tokens.and]) ? this._updateNode(new Ya(this._previous().toString(), this._unary_expression())) : this._singular_expression();
  }
  _singular_expression() {
    const e = this._primary_expression(), t = this._postfix_expression();
    return t && (e.postfix = t), e;
  }
  _postfix_expression() {
    if (this._match(Ee.tokens.bracket_left)) {
      const e = this._short_circuit_or_expression();
      this._consume(Ee.tokens.bracket_right, "Expected ']'.");
      const t = this._updateNode(new Fd(e)), n = this._postfix_expression();
      return n && (t.postfix = n), t;
    }
    if (this._match(Ee.tokens.period)) {
      const e = this._consume(Ee.tokens.name, "Expected member name."), t = this._postfix_expression(), n = this._updateNode(new Sf(e.lexeme));
      return t && (n.postfix = t), n;
    }
    return null;
  }
  _getStruct(e) {
    return this._context.aliases.has(e) ? this._context.aliases.get(e).type : this._context.structs.has(e) ? this._context.structs.get(e) : null;
  }
  _getType(e) {
    const t = this._getStruct(e);
    if (t !== null) return t;
    switch (e) {
      case "bool":
        return ur.bool;
      case "i32":
        return ur.i32;
      case "u32":
        return ur.u32;
      case "f32":
        return ur.f32;
      case "f16":
        return ur.f16;
      case "vec2f":
        return Ht.vec2f;
      case "vec3f":
        return Ht.vec3f;
      case "vec4f":
        return Ht.vec4f;
      case "vec2i":
        return Ht.vec2i;
      case "vec3i":
        return Ht.vec3i;
      case "vec4i":
        return Ht.vec4i;
      case "vec2u":
        return Ht.vec2u;
      case "vec3u":
        return Ht.vec3u;
      case "vec4u":
        return Ht.vec4u;
      case "vec2h":
        return Ht.vec2h;
      case "vec3h":
        return Ht.vec3h;
      case "vec4h":
        return Ht.vec4h;
      case "mat2x2f":
        return Ht.mat2x2f;
      case "mat2x3f":
        return Ht.mat2x3f;
      case "mat2x4f":
        return Ht.mat2x4f;
      case "mat3x2f":
        return Ht.mat3x2f;
      case "mat3x3f":
        return Ht.mat3x3f;
      case "mat3x4f":
        return Ht.mat3x4f;
      case "mat4x2f":
        return Ht.mat4x2f;
      case "mat4x3f":
        return Ht.mat4x3f;
      case "mat4x4f":
        return Ht.mat4x4f;
      case "mat2x2h":
        return Ht.mat2x2h;
      case "mat2x3h":
        return Ht.mat2x3h;
      case "mat2x4h":
        return Ht.mat2x4h;
      case "mat3x2h":
        return Ht.mat3x2h;
      case "mat3x3h":
        return Ht.mat3x3h;
      case "mat3x4h":
        return Ht.mat3x4h;
      case "mat4x2h":
        return Ht.mat4x2h;
      case "mat4x3h":
        return Ht.mat4x3h;
      case "mat4x4h":
        return Ht.mat4x4h;
    }
    return null;
  }
  _validateTypeRange(e, t) {
    if (t.name === "i32") {
      if (e < -2147483648 || e > 2147483647) throw this._error(this._previous(), `Value out of range for i32: ${e}. Line: ${this._currentLine}.`);
    } else if (t.name === "u32" && (e < 0 || e > 4294967295)) throw this._error(this._previous(), `Value out of range for u32: ${e}. Line: ${this._currentLine}.`);
  }
  _primary_expression() {
    if (this._match(Ee.tokens.ident)) {
      const n = this._previous().toString();
      if (this._check(Ee.tokens.paren_left)) {
        const i = this._argument_expression_list(), s = this._getType(n);
        return s !== null ? this._updateNode(new yf(s, i)) : this._updateNode(new Kd(n, i));
      }
      if (this._context.constants.has(n)) {
        const i = this._context.constants.get(n);
        return this._updateNode(new d5(n, i.value));
      }
      return this._updateNode(new Ch(n));
    }
    if (this._match(Ee.tokens.int_literal)) {
      const n = this._previous().toString();
      let i = n.endsWith("i") || n.endsWith("i") ? ur.i32 : n.endsWith("u") || n.endsWith("U") ? ur.u32 : ur.x32;
      const s = parseInt(n);
      return this._validateTypeRange(s, i), this._updateNode(new as(new Et(s, this._exec.getTypeInfo(i)), i));
    }
    if (this._match(Ee.tokens.uint_literal)) {
      const n = parseInt(this._previous().toString());
      return this._validateTypeRange(n, ur.u32), this._updateNode(new as(new Et(n, this._exec.getTypeInfo(ur.u32)), ur.u32));
    }
    if (this._match([Ee.tokens.decimal_float_literal, Ee.tokens.hex_float_literal])) {
      let n = this._previous().toString(), i = n.endsWith("h");
      i && (n = n.substring(0, n.length - 1));
      const s = parseFloat(n);
      this._validateTypeRange(s, i ? ur.f16 : ur.f32);
      const l = i ? ur.f16 : ur.f32;
      return this._updateNode(new as(new Et(s, this._exec.getTypeInfo(l)), l));
    }
    if (this._match([Ee.keywords.true, Ee.keywords.false])) {
      let n = this._previous().toString() === Ee.keywords.true.rule;
      return this._updateNode(new as(new Et(n ? 1 : 0, this._exec.getTypeInfo(ur.bool)), ur.bool));
    }
    if (this._check(Ee.tokens.paren_left)) return this._paren_expression();
    if (this._match(Ee.keywords.bitcast)) {
      this._consume(Ee.tokens.less_than, "Expected '<'.");
      const n = this._type_decl();
      this._consume(Ee.tokens.greater_than, "Expected '>'.");
      const i = this._paren_expression();
      return this._updateNode(new p5(n, i));
    }
    const e = this._type_decl(), t = this._argument_expression_list();
    return this._updateNode(new yf(e, t));
  }
  _argument_expression_list() {
    if (!this._match(Ee.tokens.paren_left)) return null;
    const e = [];
    do {
      if (this._check(Ee.tokens.paren_right)) break;
      const t = this._short_circuit_or_expression();
      e.push(t);
    } while (this._match(Ee.tokens.comma));
    return this._consume(Ee.tokens.paren_right, "Expected ')' for agument list"), e;
  }
  _optional_paren_expression() {
    this._match(Ee.tokens.paren_left);
    const e = this._short_circuit_or_expression();
    return this._match(Ee.tokens.paren_right), this._updateNode(new Hm([e]));
  }
  _paren_expression() {
    this._consume(Ee.tokens.paren_left, "Expected '('.");
    const e = this._short_circuit_or_expression();
    return this._consume(Ee.tokens.paren_right, "Expected ')'."), this._updateNode(new Hm([e]));
  }
  _struct_decl() {
    if (!this._match(Ee.keywords.struct)) return null;
    const e = this._currentLine, t = this._consume(Ee.tokens.ident, "Expected name for struct.").toString();
    this._consume(Ee.tokens.brace_left, "Expected '{' for struct body.");
    const n = [];
    for (; !this._check(Ee.tokens.brace_right); ) {
      const l = this._attribute(), o = this._consume(Ee.tokens.name, "Expected variable name.").toString();
      this._consume(Ee.tokens.colon, "Expected ':' for struct member type.");
      const d = this._attribute(), m = this._type_decl();
      m != null && (m.attributes = d), this._check(Ee.tokens.brace_right) ? this._match(Ee.tokens.comma) : this._consume(Ee.tokens.comma, "Expected ',' for struct member."), n.push(this._updateNode(new z6(o, m, l)));
    }
    this._consume(Ee.tokens.brace_right, "Expected '}' after struct body.");
    const i = this._currentLine, s = this._updateNode(new yh(t, n, e, i), e);
    return this._context.structs.set(t, s), s;
  }
  _global_variable_decl() {
    const e = this._variable_decl();
    if (!e) return null;
    if (this._match(Ee.tokens.equal)) {
      const t = this._const_expression(), n = [ur.f32];
      try {
        const i = t.constEvaluate(this._exec, n);
        e.value = new as(i, n[0]), this._exec.context.setVariable(e.name, i);
      } catch {
        e.value = t;
      }
    } else {
      const t = new yf(e.type, null), n = this._exec.evalExpression(t, this._exec.context);
      n !== null && (e.value = new as(n, e.type), this._exec.context.setVariable(e.name, n));
    }
    if (e.type !== null && e.value instanceof as) {
      if (e.value.type.name !== "x32" && this._exec.getTypeName(e.type) !== this._exec.getTypeName(e.value.type))
        throw this._error(this._peek(), `Invalid cast from ${e.value.type.name} to ${e.type.name}. Line:${this._currentLine}`);
      e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type), e.value.type = e.type;
    } else e.type === null && e.value instanceof as && (e.type = e.value.type.name === "x32" ? ur.i32 : e.value.type, e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type));
    return e;
  }
  _override_variable_decl() {
    const e = this._override_decl();
    return e && this._match(Ee.tokens.equal) && (e.value = this._const_expression()), e;
  }
  _global_const_decl() {
    var e;
    if (!this._match(Ee.keywords.const)) return null;
    const t = this._consume(Ee.tokens.name, "Expected variable name");
    let n = null;
    if (this._match(Ee.tokens.colon)) {
      const o = this._attribute();
      n = this._type_decl(), n != null && (n.attributes = o);
    }
    let i = null;
    this._consume(Ee.tokens.equal, "const declarations require an assignment");
    const s = this._short_circuit_or_expression();
    try {
      let o = [ur.f32];
      const d = s.constEvaluate(this._exec, o);
      d instanceof Et && this._validateTypeRange(d.value, o[0]), o[0] instanceof Ht && o[0].format === null && d.typeInfo instanceof Rh && d.typeInfo.format !== null && (d.typeInfo.format.name === "f16" ? o[0].format = ur.f16 : d.typeInfo.format.name === "f32" ? o[0].format = ur.f32 : d.typeInfo.format.name === "i32" ? o[0].format = ur.i32 : d.typeInfo.format.name === "u32" ? o[0].format = ur.u32 : d.typeInfo.format.name === "bool" ? o[0].format = ur.bool : console.error(`TODO: impelement template format type ${d.typeInfo.format.name}`)), i = this._updateNode(new as(d, o[0])), this._exec.context.setVariable(t.toString(), d);
    } catch {
      i = s;
    }
    if (n !== null && i instanceof as) {
      if (i.type.name !== "x32" && this._exec.getTypeName(n) !== this._exec.getTypeName(i.type))
        throw this._error(this._peek(), `Invalid cast from ${i.type.name} to ${n.name}. Line:${this._currentLine}`);
      i.type = n, i.isScalar && this._validateTypeRange(i.scalarValue, i.type);
    } else n === null && i instanceof as && (n = (e = i == null ? void 0 : i.type) !== null && e !== void 0 ? e : ur.f32, n === ur.x32 && (n = ur.i32));
    const l = this._updateNode(new R1(t.toString(), n, "", "", i));
    return this._context.constants.set(l.name, l), l;
  }
  _global_let_decl() {
    if (!this._match(Ee.keywords.let)) return null;
    const e = this._consume(Ee.tokens.name, "Expected variable name");
    let t = null;
    if (this._match(Ee.tokens.colon)) {
      const i = this._attribute();
      t = this._type_decl(), t != null && (t.attributes = i);
    }
    let n = null;
    if (this._match(Ee.tokens.equal)) {
      n = this._const_expression();
      const i = [ur.f32];
      try {
        const s = n.constEvaluate(this._exec, i);
        s !== null && (n = new as(s, i[0]));
      } catch {
      }
    }
    if (t !== null && n instanceof as) {
      if (n.type.name !== "x32" && this._exec.getTypeName(t) !== this._exec.getTypeName(n.type))
        throw this._error(this._peek(), `Invalid cast from ${n.type.name} to ${t.name}. Line:${this._currentLine}`);
      n.type = t;
    } else t === null && n instanceof as && (t = n.type.name === "x32" ? ur.i32 : n.type);
    return n instanceof as && n.isScalar && this._validateTypeRange(n.scalarValue, t), this._updateNode(new R_(e.toString(), t, "", "", n));
  }
  _const_expression() {
    return this._short_circuit_or_expression();
  }
  _variable_decl() {
    if (!this._match(Ee.keywords.var)) return null;
    let e = "", t = "";
    this._match(Ee.tokens.less_than) && (e = this._consume(Ee.storage_class, "Expected storage_class.").toString(), this._match(Ee.tokens.comma) && (t = this._consume(Ee.access_mode, "Expected access_mode.").toString()), this._consume(Ee.tokens.greater_than, "Expected '>'."));
    const n = this._consume(Ee.tokens.name, "Expected variable name");
    let i = null;
    if (this._match(Ee.tokens.colon)) {
      const s = this._attribute();
      i = this._type_decl(), i != null && (i.attributes = s);
    }
    return this._updateNode(new xh(n.toString(), i, e, t, null));
  }
  _override_decl() {
    if (!this._match(Ee.keywords.override)) return null;
    const e = this._consume(Ee.tokens.name, "Expected variable name");
    let t = null;
    if (this._match(Ee.tokens.colon)) {
      const n = this._attribute();
      t = this._type_decl(), t != null && (t.attributes = n);
    }
    return this._updateNode(new r2(e.toString(), t, null));
  }
  _diagnostic() {
    this._consume(Ee.tokens.paren_left, "Expected '('");
    const e = this._consume(Ee.tokens.ident, "Expected severity control name.");
    this._consume(Ee.tokens.comma, "Expected ','");
    let t = this._consume(Ee.tokens.ident, "Expected diagnostic rule name.").toString();
    return this._match(Ee.tokens.period) && (t += `.${this._consume(Ee.tokens.ident, "Expected diagnostic message.").toString()}`), this._consume(Ee.tokens.paren_right, "Expected ')'"), this._updateNode(new c5(e.toString(), t));
  }
  _enable_directive() {
    const e = this._consume(Ee.tokens.ident, "identity expected.");
    return this._updateNode(new O6(e.toString()));
  }
  _requires_directive() {
    const e = [this._consume(Ee.tokens.ident, "identity expected.").toString()];
    for (; this._match(Ee.tokens.comma); ) {
      const t = this._consume(Ee.tokens.ident, "identity expected.");
      e.push(t.toString());
    }
    return this._updateNode(new N6(e));
  }
  _type_alias() {
    const e = this._consume(Ee.tokens.ident, "identity expected.");
    this._consume(Ee.tokens.equal, "Expected '=' for type alias.");
    let t = this._type_decl();
    if (t === null) throw this._error(this._peek(), "Expected Type for Alias.");
    this._context.aliases.has(t.name) && (t = this._context.aliases.get(t.name).type);
    const n = this._updateNode(new i2(e.toString(), t));
    return this._context.aliases.set(n.name, n), n;
  }
  _type_decl() {
    if (this._check([Ee.tokens.ident, ...Ee.texel_format, Ee.keywords.bool, Ee.keywords.f32, Ee.keywords.i32, Ee.keywords.u32])) {
      const n = this._advance(), i = n.toString();
      return this._context.structs.has(i) ? this._context.structs.get(i) : this._context.aliases.has(i) ? this._context.aliases.get(i).type : this._updateNode(new ur(n.toString()));
    }
    let e = this._texture_sampler_types();
    if (e) return e;
    if (this._check(Ee.template_types)) {
      let n = this._advance().toString(), i = null, s = null;
      return this._match(Ee.tokens.less_than) && (i = this._type_decl(), s = null, this._match(Ee.tokens.comma) && (s = this._consume(Ee.access_mode, "Expected access_mode for pointer").toString()), this._consume(Ee.tokens.greater_than, "Expected '>' for type.")), this._updateNode(new Ht(n, i, s));
    }
    if (this._match(Ee.keywords.ptr)) {
      let n = this._previous().toString();
      this._consume(Ee.tokens.less_than, "Expected '<' for pointer.");
      const i = this._consume(Ee.storage_class, "Expected storage_class for pointer");
      this._consume(Ee.tokens.comma, "Expected ',' for pointer.");
      const s = this._type_decl();
      let l = null;
      return this._match(Ee.tokens.comma) && (l = this._consume(Ee.access_mode, "Expected access_mode for pointer").toString()), this._consume(Ee.tokens.greater_than, "Expected '>' for pointer."), this._updateNode(new k6(n, i.toString(), s, l));
    }
    const t = this._attribute();
    if (this._match(Ee.keywords.array)) {
      let n = null, i = -1;
      const s = this._previous();
      let l = null;
      if (this._match(Ee.tokens.less_than)) {
        n = this._type_decl(), this._context.aliases.has(n.name) && (n = this._context.aliases.get(n.name).type);
        let d = "";
        if (this._match(Ee.tokens.comma)) {
          l = this._shift_expression();
          try {
            d = l.constEvaluate(this._exec).toString(), l = null;
          } catch {
            d = "1";
          }
        }
        this._consume(Ee.tokens.greater_than, "Expected '>' for array."), i = d ? parseInt(d) : 0;
      }
      const o = this._updateNode(new f5(s.toString(), t, n, i));
      return l && this._deferArrayCountEval.push({
        arrayType: o,
        countNode: l
      }), o;
    }
    return null;
  }
  _texture_sampler_types() {
    if (this._match(Ee.sampler_type)) return this._updateNode(new $p(this._previous().toString(), null, null));
    if (this._match(Ee.depth_texture_type)) return this._updateNode(new $p(this._previous().toString(), null, null));
    if (this._match(Ee.sampled_texture_type) || this._match(Ee.multisampled_texture_type)) {
      const e = this._previous();
      this._consume(Ee.tokens.less_than, "Expected '<' for sampler type.");
      const t = this._type_decl();
      return this._consume(Ee.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new $p(e.toString(), t, null));
    }
    if (this._match(Ee.storage_texture_type)) {
      const e = this._previous();
      this._consume(Ee.tokens.less_than, "Expected '<' for sampler type.");
      const t = this._consume(Ee.texel_format, "Invalid texel format.").toString();
      this._consume(Ee.tokens.comma, "Expected ',' after texel format.");
      const n = this._consume(Ee.access_mode, "Expected access mode for storage texture type.").toString();
      return this._consume(Ee.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new $p(e.toString(), t, n));
    }
    return null;
  }
  _attribute() {
    let e = [];
    for (; this._match(Ee.tokens.attr); ) {
      const t = this._consume(Ee.attribute_name, "Expected attribute name"), n = this._updateNode(new j6(t.toString(), null));
      if (this._match(Ee.tokens.paren_left)) {
        if (n.value = this._consume(Ee.literal_or_ident, "Expected attribute value").toString(), this._check(Ee.tokens.comma)) {
          this._advance();
          do {
            const i = this._consume(Ee.literal_or_ident, "Expected attribute value").toString();
            n.value instanceof Array || (n.value = [n.value]), n.value.push(i);
          } while (this._match(Ee.tokens.comma));
        }
        this._consume(Ee.tokens.paren_right, "Expected ')'");
      }
      e.push(n);
    }
    return e.length == 0 ? null : e;
  }
};
class Q6 extends tg {
  constructor(e) {
    super(), e && this.update(e);
  }
  update(e) {
    const t = new J6().parse(e);
    this.updateAST(t);
  }
}
function eN(r) {
  var s;
  const e = {
    attributes: [],
    bindings: []
  };
  let t;
  try {
    t = tN(r);
  } catch (l) {
    return lr.error(l.message)(), e;
  }
  for (const l of t.uniforms) {
    const o = [];
    for (const d of ((s = l.type) == null ? void 0 : s.members) || [])
      o.push({
        name: d.name,
        type: NA(d.type)
      });
    e.bindings.push({
      type: "uniform",
      name: l.name,
      group: l.group,
      location: l.binding,
      // @ts-expect-error TODO - unused for now but needs fixing
      members: o
    });
  }
  for (const l of t.textures)
    e.bindings.push({
      type: "texture",
      name: l.name,
      group: l.group,
      location: l.binding
    });
  for (const l of t.samplers)
    e.bindings.push({
      type: "sampler",
      name: l.name,
      group: l.group,
      location: l.binding
    });
  const n = t.entry.vertex[0], i = (n == null ? void 0 : n.inputs.length) || 0;
  for (let l = 0; l < i; l++) {
    const o = n.inputs[l];
    if (o.locationType === "location") {
      const d = NA(o.type);
      e.attributes.push({
        name: o.name,
        location: Number(o.location),
        type: d
      });
    }
  }
  return e;
}
function NA(r) {
  return r.format ? `${r.name}<${r.format.name}>` : r.name;
}
function tN(r) {
  try {
    return new Q6(r);
  } catch (e) {
    if (e instanceof Error)
      throw e;
    let t = "WGSL parse error";
    throw typeof e == "object" && (e != null && e.message) && (t += `: ${e.message} `), typeof e == "object" && (e != null && e.token) && (t += e.token.line || ""), new Error(t, {
      cause: e
    });
  }
}
const rN = 1 / Math.PI * 180, nN = 1 / 180 * Math.PI, iN = {
  EPSILON: 1e-12,
  debug: !1,
  precision: 4,
  printTypes: !1,
  printDegrees: !1,
  printRowMajor: !0,
  _cartographicRadians: !1
};
globalThis.mathgl = globalThis.mathgl || {
  config: {
    ...iN
  }
};
const Zs = globalThis.mathgl.config;
function sN(r) {
  let {
    precision: e = Zs.precision
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return r = cN(r), `${parseFloat(r.toPrecision(e))}`;
}
function Bh(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function oN(r) {
  return lN(r);
}
function aN(r) {
  return yc(r);
}
function lN(r, e) {
  return l2(r, (t) => t * nN, e);
}
function yc(r, e) {
  return l2(r, (t) => t * rN, e);
}
function xc(r, e, t) {
  return l2(r, (n) => Math.max(e, Math.min(t, n)));
}
function N_(r, e, t) {
  return Bh(r) ? r.map((n, i) => N_(n, e[i], t)) : t * e + (1 - t) * r;
}
function Cc(r, e, t) {
  const n = Zs.EPSILON;
  t && (Zs.EPSILON = t);
  try {
    if (r === e)
      return !0;
    if (Bh(r) && Bh(e)) {
      if (r.length !== e.length)
        return !1;
      for (let i = 0; i < r.length; ++i)
        if (!Cc(r[i], e[i]))
          return !1;
      return !0;
    }
    return r && r.equals ? r.equals(e) : e && e.equals ? e.equals(r) : typeof r == "number" && typeof e == "number" ? Math.abs(r - e) <= Zs.EPSILON * Math.max(1, Math.abs(r), Math.abs(e)) : !1;
  } finally {
    Zs.EPSILON = n;
  }
}
function cN(r) {
  return Math.round(r / Zs.EPSILON) * Zs.EPSILON;
}
function uN(r) {
  return r.clone ? r.clone() : new Array(r.length);
}
function l2(r, e, t) {
  if (Bh(r)) {
    const n = r;
    t = t || uN(n);
    for (let i = 0; i < t.length && i < n.length; ++i) {
      const s = typeof r == "number" ? r : r[i];
      t[i] = e(s, i, t);
    }
    return t;
  }
  return e(r);
}
class c2 extends Array {
  // Common methods
  /**
   * Clone the current object
   * @returns a new copy of this object
   */
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = e[n + t];
    return this.check();
  }
  toArray() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (let n = 0; n < this.ELEMENTS; ++n)
      e[t + n] = this[n];
    return e;
  }
  toObject(e) {
    return e;
  }
  from(e) {
    return Array.isArray(e) ? this.copy(e) : (
      // @ts-ignore
      this.fromObject(e)
    );
  }
  to(e) {
    return e === this ? this : Bh(e) ? this.toArray(e) : this.toObject(e);
  }
  toTarget(e) {
    return e ? this.to(e) : this;
  }
  /** @deprecated */
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(Zs);
  }
  /** Formats string according to options */
  formatString(e) {
    let t = "";
    for (let n = 0; n < this.ELEMENTS; ++n)
      t += (n > 0 ? ", " : "") + sN(this[n], e);
    return `${e.printTypes ? this.constructor.name : ""}[${t}]`;
  }
  equals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (!Cc(this[t], e[t]))
        return !1;
    return !0;
  }
  exactEquals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (this[t] !== e[t])
        return !1;
    return !0;
  }
  // Modifiers
  /** Negates all values in this object */
  negate() {
    for (let e = 0; e < this.ELEMENTS; ++e)
      this[e] = -this[e];
    return this.check();
  }
  lerp(e, t, n) {
    if (n === void 0)
      return this.lerp(this, e, t);
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const s = e[i], l = typeof t == "number" ? t : t[i];
      this[i] = s + n * (l - s);
    }
    return this.check();
  }
  /** Minimal */
  min(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.min(e[t], this[t]);
    return this.check();
  }
  /** Maximal */
  max(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.max(e[t], this[t]);
    return this.check();
  }
  clamp(e, t) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = Math.min(Math.max(this[n], e[n]), t[n]);
    return this.check();
  }
  add() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    for (const i of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] += i[s];
    return this.check();
  }
  subtract() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    for (const i of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] -= i[s];
    return this.check();
  }
  scale(e) {
    if (typeof e == "number")
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] *= e;
    else
      for (let t = 0; t < this.ELEMENTS && t < e.length; ++t)
        this[t] *= e[t];
    return this.check();
  }
  /**
   * Multiplies all elements by `scale`
   * Note: `Matrix4.multiplyByScalar` only scales its 3x3 "minor"
   */
  multiplyByScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  // Debug checks
  /** Throws an error if array length is incorrect or contains illegal values */
  check() {
    if (Zs.debug && !this.validate())
      throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
    return this;
  }
  /** Returns false if the array length is incorrect or contains illegal values */
  validate() {
    let e = this.length === this.ELEMENTS;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e = e && Number.isFinite(this[t]);
    return e;
  }
  // three.js compatibility
  /** @deprecated */
  sub(e) {
    return this.subtract(e);
  }
  /** @deprecated */
  setScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = e;
    return this.check();
  }
  /** @deprecated */
  addScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] += e;
    return this.check();
  }
  /** @deprecated */
  subScalar(e) {
    return this.addScalar(-e);
  }
  /** @deprecated */
  multiplyScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  /** @deprecated */
  divideScalar(e) {
    return this.multiplyByScalar(1 / e);
  }
  /** @deprecated */
  clampScalar(e, t) {
    for (let n = 0; n < this.ELEMENTS; ++n)
      this[n] = Math.min(Math.max(this[n], e), t);
    return this.check();
  }
  /** @deprecated */
  get elements() {
    return this;
  }
}
function hN(r, e) {
  if (r.length !== e)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (!Number.isFinite(r[t]))
      return !1;
  return !0;
}
function Yn(r) {
  if (!Number.isFinite(r))
    throw new Error(`Invalid number ${JSON.stringify(r)}`);
  return r;
}
function rg(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  if (Zs.debug && !hN(r, e))
    throw new Error(`math.gl: ${t} some fields set to invalid numbers'`);
  return r;
}
function bc(r, e) {
  if (!r)
    throw new Error(`math.gl assertion ${e}`);
}
class u2 extends c2 {
  // ACCESSORS
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Yn(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Yn(e);
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   *
   * @note `length` is a reserved word for Arrays, so `v.length()` will return number of elements
   * Instead we provide `len` and `magnitude`
   */
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  /**
   * Returns the length of the vector from the origin to the point described by this vector
   */
  magnitude() {
    return this.len();
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  lengthSquared() {
    let e = 0;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e += this[t] * this[t];
    return e;
  }
  /**
   * Returns the squared length of the vector from the origin to the point described by this vector
   */
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(e) {
    return Math.sqrt(this.distanceSquared(e));
  }
  distanceSquared(e) {
    let t = 0;
    for (let n = 0; n < this.ELEMENTS; ++n) {
      const i = this[n] - e[n];
      t += i * i;
    }
    return Yn(t);
  }
  dot(e) {
    let t = 0;
    for (let n = 0; n < this.ELEMENTS; ++n)
      t += this[n] * e[n];
    return Yn(t);
  }
  // MODIFIERS
  normalize() {
    const e = this.magnitude();
    if (e !== 0)
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] /= e;
    return this.check();
  }
  multiply() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    for (const i of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] *= i[s];
    return this.check();
  }
  divide() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    for (const i of t)
      for (let s = 0; s < this.ELEMENTS; ++s)
        this[s] /= i[s];
    return this.check();
  }
  // THREE.js compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(e) {
    return this.distance(e);
  }
  distanceToSquared(e) {
    return this.distanceSquared(e);
  }
  getComponent(e) {
    return bc(e >= 0 && e < this.ELEMENTS, "index is out of range"), Yn(this[e]);
  }
  setComponent(e, t) {
    return bc(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = t, this.check();
  }
  addVectors(e, t) {
    return this.copy(e).add(t);
  }
  subVectors(e, t) {
    return this.copy(e).subtract(t);
  }
  multiplyVectors(e, t) {
    return this.copy(e).multiply(t);
  }
  addScaledVector(e, t) {
    return this.add(new this.constructor(e).multiplyScalar(t));
  }
}
const ng = 1e-6;
let Mc = typeof Float32Array < "u" ? Float32Array : Array;
function fN() {
  const r = new Mc(2);
  return Mc != Float32Array && (r[0] = 0, r[1] = 0), r;
}
function DA(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r;
}
function dN(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r;
}
function x5(r, e, t, n) {
  const i = e[0], s = e[1];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r;
}
function pN(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i, r[1] = t[1] * n + t[3] * i, r;
}
function gN(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i + t[4], r[1] = t[1] * n + t[3] * i + t[5], r;
}
function w5(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[3] * i + t[6], r[1] = t[1] * n + t[4] * i + t[7], r;
}
function A5(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[4] * i + t[12], r[1] = t[1] * n + t[5] * i + t[13], r;
}
(function() {
  const r = fN();
  return function(e, t, n, i, s, l) {
    let o, d;
    for (t || (t = 2), n || (n = 0), i ? d = Math.min(i * t + n, e.length) : d = e.length, o = n; o < d; o += t)
      r[0] = e[o], r[1] = e[o + 1], s(r, r, l), e[o] = r[0], e[o + 1] = r[1];
    return e;
  };
})();
function T5(r, e, t) {
  const n = e[0], i = e[1], s = t[3] * n + t[7] * i || 1;
  return r[0] = (t[0] * n + t[4] * i) / s, r[1] = (t[1] * n + t[5] * i) / s, r;
}
function S5(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = t[3] * n + t[7] * i + t[11] * s || 1;
  return r[0] = (t[0] * n + t[4] * i + t[8] * s) / l, r[1] = (t[1] * n + t[5] * i + t[9] * s) / l, r[2] = (t[2] * n + t[6] * i + t[10] * s) / l, r;
}
function mN(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i, r[1] = t[1] * n + t[3] * i, r[2] = e[2], r;
}
function _N(r, e, t) {
  const n = e[0], i = e[1];
  return r[0] = t[0] * n + t[2] * i, r[1] = t[1] * n + t[3] * i, r[2] = e[2], r[3] = e[3], r;
}
function E5(r, e, t) {
  const n = e[0], i = e[1], s = e[2];
  return r[0] = t[0] * n + t[3] * i + t[6] * s, r[1] = t[1] * n + t[4] * i + t[7] * s, r[2] = t[2] * n + t[5] * i + t[8] * s, r[3] = e[3], r;
}
class h2 extends u2 {
  // Creates a new, empty vec2
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    super(2), Bh(e) && arguments.length === 1 ? this.copy(e) : (Zs.debug && (Yn(e), Yn(t)), this[0] = e, this[1] = t);
  }
  set(e, t) {
    return this[0] = e, this[1] = t, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this.check();
  }
  fromObject(e) {
    return Zs.debug && (Yn(e.x), Yn(e.y)), this[0] = e.x, this[1] = e.y, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 2;
  }
  /**
   * Returns angle from x axis
   * @returns
   */
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  /**
   * Returns angle from y axis
   * @returns
   */
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  // Transforms
  /**
   * Transforms as point
   * @param matrix4
   * @returns
   */
  transform(e) {
    return this.transformAsPoint(e);
  }
  /**
   * transforms as point (4th component is implicitly 1)
   * @param matrix4
   * @returns
   */
  transformAsPoint(e) {
    return A5(this, this, e), this.check();
  }
  /**
   * transforms as vector (4th component is implicitly 0, ignores translation. slightly faster)
   * @param matrix4
   * @returns
   */
  transformAsVector(e) {
    return T5(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return w5(this, this, e), this.check();
  }
  transformByMatrix2x3(e) {
    return gN(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return pN(this, this, e), this.check();
  }
}
function C5() {
  const r = new Mc(3);
  return Mc != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
}
function I5(r) {
  const e = r[0], t = r[1], n = r[2];
  return Math.sqrt(e * e + t * t + n * n);
}
function kA(r, e, t) {
  const n = new Mc(3);
  return n[0] = r, n[1] = e, n[2] = t, n;
}
function yN(r, e, t) {
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], r;
}
function bN(r) {
  const e = r[0], t = r[1], n = r[2];
  return e * e + t * t + n * n;
}
function vN(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r;
}
function xN(r, e) {
  const t = e[0], n = e[1], i = e[2];
  let s = t * t + n * n + i * i;
  return s > 0 && (s = 1 / Math.sqrt(s)), r[0] = e[0] * s, r[1] = e[1] * s, r[2] = e[2] * s, r;
}
function f2(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2];
}
function Xm(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = t[0], o = t[1], d = t[2];
  return r[0] = i * d - s * o, r[1] = s * l - n * d, r[2] = n * o - i * l, r;
}
function wN(r, e, t, n) {
  const i = e[0], s = e[1], l = e[2];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r[2] = l + n * (t[2] - l), r;
}
function d2(r, e, t) {
  const n = e[0], i = e[1], s = e[2];
  let l = t[3] * n + t[7] * i + t[11] * s + t[15];
  return l = l || 1, r[0] = (t[0] * n + t[4] * i + t[8] * s + t[12]) / l, r[1] = (t[1] * n + t[5] * i + t[9] * s + t[13]) / l, r[2] = (t[2] * n + t[6] * i + t[10] * s + t[14]) / l, r;
}
function M5(r, e, t) {
  const n = e[0], i = e[1], s = e[2];
  return r[0] = n * t[0] + i * t[3] + s * t[6], r[1] = n * t[1] + i * t[4] + s * t[7], r[2] = n * t[2] + i * t[5] + s * t[8], r;
}
function P5(r, e, t) {
  const n = t[0], i = t[1], s = t[2], l = t[3], o = e[0], d = e[1], m = e[2];
  let b = i * m - s * d, T = s * o - n * m, M = n * d - i * o, E = i * M - s * T, D = s * b - n * M, U = n * T - i * b;
  const q = l * 2;
  return b *= q, T *= q, M *= q, E *= 2, D *= 2, U *= 2, r[0] = o + b + E, r[1] = d + T + D, r[2] = m + M + U, r;
}
function AN(r, e, t, n) {
  const i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[0], s[1] = i[1] * Math.cos(n) - i[2] * Math.sin(n), s[2] = i[1] * Math.sin(n) + i[2] * Math.cos(n), r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function TN(r, e, t, n) {
  const i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[2] * Math.sin(n) + i[0] * Math.cos(n), s[1] = i[1], s[2] = i[2] * Math.cos(n) - i[0] * Math.sin(n), r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function SN(r, e, t, n) {
  const i = [], s = [];
  return i[0] = e[0] - t[0], i[1] = e[1] - t[1], i[2] = e[2] - t[2], s[0] = i[0] * Math.cos(n) - i[1] * Math.sin(n), s[1] = i[0] * Math.sin(n) + i[1] * Math.cos(n), s[2] = i[2], r[0] = s[0] + t[0], r[1] = s[1] + t[1], r[2] = s[2] + t[2], r;
}
function EN(r, e) {
  const t = r[0], n = r[1], i = r[2], s = e[0], l = e[1], o = e[2], d = Math.sqrt((t * t + n * n + i * i) * (s * s + l * l + o * o)), m = d && f2(r, e) / d;
  return Math.acos(Math.min(Math.max(m, -1), 1));
}
const R5 = yN, B5 = I5, K0 = bN;
(function() {
  const r = C5();
  return function(e, t, n, i, s, l) {
    let o, d;
    for (t || (t = 3), n || (n = 0), i ? d = Math.min(i * t + n, e.length) : d = e.length, o = n; o < d; o += t)
      r[0] = e[o], r[1] = e[o + 1], r[2] = e[o + 2], s(r, r, l), e[o] = r[0], e[o + 1] = r[1], e[o + 2] = r[2];
    return e;
  };
})();
const J0 = [0, 0, 0];
let fm;
class Tt extends u2 {
  static get ZERO() {
    return fm || (fm = new Tt(0, 0, 0), Object.freeze(fm)), fm;
  }
  /**
   * @class
   * @param x
   * @param y
   * @param z
   */
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    super(-0, -0, -0), arguments.length === 1 && Bh(e) ? this.copy(e) : (Zs.debug && (Yn(e), Yn(t), Yn(n)), this[0] = e, this[1] = t, this[2] = n);
  }
  set(e, t, n) {
    return this[0] = e, this[1] = t, this[2] = n, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
  }
  fromObject(e) {
    return Zs.debug && (Yn(e.x), Yn(e.y), Yn(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e;
  }
  // Getters/setters
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Yn(e);
  }
  // ACCESSORS
  angle(e) {
    return EN(this, e);
  }
  // MODIFIERS
  cross(e) {
    return Xm(this, this, e), this.check();
  }
  rotateX(e) {
    let {
      radians: t,
      origin: n = J0
    } = e;
    return AN(this, this, n, t), this.check();
  }
  rotateY(e) {
    let {
      radians: t,
      origin: n = J0
    } = e;
    return TN(this, this, n, t), this.check();
  }
  rotateZ(e) {
    let {
      radians: t,
      origin: n = J0
    } = e;
    return SN(this, this, n, t), this.check();
  }
  // Transforms
  // transforms as point (4th component is implicitly 1)
  transform(e) {
    return this.transformAsPoint(e);
  }
  // transforms as point (4th component is implicitly 1)
  transformAsPoint(e) {
    return d2(this, this, e), this.check();
  }
  // transforms as vector  (4th component is implicitly 0, ignores translation. slightly faster)
  transformAsVector(e) {
    return S5(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return M5(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return mN(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return P5(this, this, e), this.check();
  }
}
let dm;
class p2 extends u2 {
  static get ZERO() {
    return dm || (dm = new p2(0, 0, 0, 0), Object.freeze(dm)), dm;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    super(-0, -0, -0, -0), Bh(e) && arguments.length === 1 ? this.copy(e) : (Zs.debug && (Yn(e), Yn(t), Yn(n), Yn(i)), this[0] = e, this[1] = t, this[2] = n, this[3] = i);
  }
  set(e, t, n, i) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  fromObject(e) {
    return Zs.debug && (Yn(e.x), Yn(e.y), Yn(e.z), Yn(e.w)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this;
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e.w = this[3], e;
  }
  // Getters/setters
  /* eslint-disable no-multi-spaces, brace-style, no-return-assign */
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Yn(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Yn(e);
  }
  transform(e) {
    return d2(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return E5(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return _N(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return P5(this, this, e), this.check();
  }
  // three.js compatibility
  applyMatrix4(e) {
    return e.transform(this, this), this;
  }
}
class L5 extends c2 {
  // fromObject(object) {
  //   const array = object.elements;
  //   return this.fromRowMajor(array);
  // }
  // toObject(object) {
  //   const array = object.elements;
  //   this.toRowMajor(array);
  //   return object;
  // }
  // TODO better override formatString?
  toString() {
    let e = "[";
    if (Zs.printRowMajor) {
      e += "row-major:";
      for (let t = 0; t < this.RANK; ++t)
        for (let n = 0; n < this.RANK; ++n)
          e += ` ${this[n * this.RANK + t]}`;
    } else {
      e += "column-major:";
      for (let t = 0; t < this.ELEMENTS; ++t)
        e += ` ${this[t]}`;
    }
    return e += "]", e;
  }
  getElementIndex(e, t) {
    return t * this.RANK + e;
  }
  // By default assumes row major indices
  getElement(e, t) {
    return this[t * this.RANK + e];
  }
  // By default assumes row major indices
  setElement(e, t, n) {
    return this[t * this.RANK + e] = Yn(n), this;
  }
  getColumn(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Array(this.RANK).fill(-0);
    const n = e * this.RANK;
    for (let i = 0; i < this.RANK; ++i)
      t[i] = this[n + i];
    return t;
  }
  setColumn(e, t) {
    const n = e * this.RANK;
    for (let i = 0; i < this.RANK; ++i)
      this[n + i] = t[i];
    return this;
  }
}
function CN() {
  const r = new Mc(9);
  return Mc != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[5] = 0, r[6] = 0, r[7] = 0), r[0] = 1, r[4] = 1, r[8] = 1, r;
}
function IN(r, e) {
  if (r === e) {
    const t = e[1], n = e[2], i = e[5];
    r[1] = e[3], r[2] = e[6], r[3] = t, r[5] = e[7], r[6] = n, r[7] = i;
  } else
    r[0] = e[0], r[1] = e[3], r[2] = e[6], r[3] = e[1], r[4] = e[4], r[5] = e[7], r[6] = e[2], r[7] = e[5], r[8] = e[8];
  return r;
}
function MN(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], l = e[4], o = e[5], d = e[6], m = e[7], b = e[8], T = b * l - o * m, M = -b * s + o * d, E = m * s - l * d;
  let D = t * T + n * M + i * E;
  return D ? (D = 1 / D, r[0] = T * D, r[1] = (-b * n + i * m) * D, r[2] = (o * n - i * l) * D, r[3] = M * D, r[4] = (b * t - i * d) * D, r[5] = (-o * t + i * s) * D, r[6] = E * D, r[7] = (-m * t + n * d) * D, r[8] = (l * t - n * s) * D, r) : null;
}
function PN(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3], s = r[4], l = r[5], o = r[6], d = r[7], m = r[8];
  return e * (m * s - l * d) + t * (-m * i + l * o) + n * (d * i - s * o);
}
function FA(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3], o = e[4], d = e[5], m = e[6], b = e[7], T = e[8], M = t[0], E = t[1], D = t[2], U = t[3], q = t[4], G = t[5], Y = t[6], he = t[7], X = t[8];
  return r[0] = M * n + E * l + D * m, r[1] = M * i + E * o + D * b, r[2] = M * s + E * d + D * T, r[3] = U * n + q * l + G * m, r[4] = U * i + q * o + G * b, r[5] = U * s + q * d + G * T, r[6] = Y * n + he * l + X * m, r[7] = Y * i + he * o + X * b, r[8] = Y * s + he * d + X * T, r;
}
function RN(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3], o = e[4], d = e[5], m = e[6], b = e[7], T = e[8], M = t[0], E = t[1];
  return r[0] = n, r[1] = i, r[2] = s, r[3] = l, r[4] = o, r[5] = d, r[6] = M * n + E * l + m, r[7] = M * i + E * o + b, r[8] = M * s + E * d + T, r;
}
function BN(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3], o = e[4], d = e[5], m = e[6], b = e[7], T = e[8], M = Math.sin(t), E = Math.cos(t);
  return r[0] = E * n + M * l, r[1] = E * i + M * o, r[2] = E * s + M * d, r[3] = E * l - M * n, r[4] = E * o - M * i, r[5] = E * d - M * s, r[6] = m, r[7] = b, r[8] = T, r;
}
function UA(r, e, t) {
  const n = t[0], i = t[1];
  return r[0] = n * e[0], r[1] = n * e[1], r[2] = n * e[2], r[3] = i * e[3], r[4] = i * e[4], r[5] = i * e[5], r[6] = e[6], r[7] = e[7], r[8] = e[8], r;
}
function LN(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], l = t + t, o = n + n, d = i + i, m = t * l, b = n * l, T = n * o, M = i * l, E = i * o, D = i * d, U = s * l, q = s * o, G = s * d;
  return r[0] = 1 - T - D, r[3] = b - G, r[6] = M + q, r[1] = b + G, r[4] = 1 - m - D, r[7] = E - U, r[2] = M - q, r[5] = E + U, r[8] = 1 - m - T, r;
}
var L1;
(function(r) {
  r[r.COL0ROW0 = 0] = "COL0ROW0", r[r.COL0ROW1 = 1] = "COL0ROW1", r[r.COL0ROW2 = 2] = "COL0ROW2", r[r.COL1ROW0 = 3] = "COL1ROW0", r[r.COL1ROW1 = 4] = "COL1ROW1", r[r.COL1ROW2 = 5] = "COL1ROW2", r[r.COL2ROW0 = 6] = "COL2ROW0", r[r.COL2ROW1 = 7] = "COL2ROW1", r[r.COL2ROW2 = 8] = "COL2ROW2";
})(L1 || (L1 = {}));
const ON = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class us extends L5 {
  static get IDENTITY() {
    return DN();
  }
  static get ZERO() {
    return NN();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return L1;
  }
  constructor(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      n[i - 1] = arguments[i];
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : n.length > 0 ? this.copy([e, ...n]) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this.check();
  }
  // Constructors
  identity() {
    return this.copy(ON);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /** Calculates a 3x3 matrix from the given quaternion
   * q quat  Quaternion to create matrix from
   */
  fromQuaternion(e) {
    return LN(this, e), this.check();
  }
  /**
   * accepts column major order, stores in column major order
   */
  // eslint-disable-next-line max-params
  set(e, t, n, i, s, l, o, d, m) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this[4] = s, this[5] = l, this[6] = o, this[7] = d, this[8] = m, this.check();
  }
  /**
   * accepts row major order, stores as column major
   */
  // eslint-disable-next-line max-params
  setRowMajor(e, t, n, i, s, l, o, d, m) {
    return this[0] = e, this[1] = i, this[2] = o, this[3] = t, this[4] = s, this[5] = d, this[6] = n, this[7] = l, this[8] = m, this.check();
  }
  // Accessors
  determinant() {
    return PN(this);
  }
  // Modifiers
  transpose() {
    return IN(this, this), this.check();
  }
  /** Invert a matrix. Note that this can fail if the matrix is not invertible */
  invert() {
    return MN(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return FA(this, e, this), this.check();
  }
  multiplyRight(e) {
    return FA(this, this, e), this.check();
  }
  rotate(e) {
    return BN(this, this, e), this.check();
  }
  scale(e) {
    return Array.isArray(e) ? UA(this, this, e) : UA(this, this, [e, e]), this.check();
  }
  translate(e) {
    return RN(this, this, e), this.check();
  }
  // Transforms
  transform(e, t) {
    let n;
    switch (e.length) {
      case 2:
        n = w5(t || [-0, -0], e, this);
        break;
      case 3:
        n = M5(t || [-0, -0, -0], e, this);
        break;
      case 4:
        n = E5(t || [-0, -0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return rg(n, e.length), n;
  }
  /** @deprecated */
  transformVector(e, t) {
    return this.transform(e, t);
  }
  /** @deprecated */
  transformVector2(e, t) {
    return this.transform(e, t);
  }
  /** @deprecated */
  transformVector3(e, t) {
    return this.transform(e, t);
  }
}
let pm, gm = null;
function NN() {
  return pm || (pm = new us([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(pm)), pm;
}
function DN() {
  return gm || (gm = new us(), Object.freeze(gm)), gm;
}
function kN(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = 1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function FN(r, e) {
  if (r === e) {
    const t = e[1], n = e[2], i = e[3], s = e[6], l = e[7], o = e[11];
    r[1] = e[4], r[2] = e[8], r[3] = e[12], r[4] = t, r[6] = e[9], r[7] = e[13], r[8] = n, r[9] = s, r[11] = e[14], r[12] = i, r[13] = l, r[14] = o;
  } else
    r[0] = e[0], r[1] = e[4], r[2] = e[8], r[3] = e[12], r[4] = e[1], r[5] = e[5], r[6] = e[9], r[7] = e[13], r[8] = e[2], r[9] = e[6], r[10] = e[10], r[11] = e[14], r[12] = e[3], r[13] = e[7], r[14] = e[11], r[15] = e[15];
  return r;
}
function O1(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], l = e[4], o = e[5], d = e[6], m = e[7], b = e[8], T = e[9], M = e[10], E = e[11], D = e[12], U = e[13], q = e[14], G = e[15], Y = t * o - n * l, he = t * d - i * l, X = t * m - s * l, J = n * d - i * o, ie = n * m - s * o, ye = i * m - s * d, oe = b * U - T * D, Re = b * q - M * D, Ne = b * G - E * D, me = T * q - M * U, _e = T * G - E * U, Fe = M * G - E * q;
  let Me = Y * Fe - he * _e + X * me + J * Ne - ie * Re + ye * oe;
  return Me ? (Me = 1 / Me, r[0] = (o * Fe - d * _e + m * me) * Me, r[1] = (i * _e - n * Fe - s * me) * Me, r[2] = (U * ye - q * ie + G * J) * Me, r[3] = (M * ie - T * ye - E * J) * Me, r[4] = (d * Ne - l * Fe - m * Re) * Me, r[5] = (t * Fe - i * Ne + s * Re) * Me, r[6] = (q * X - D * ye - G * he) * Me, r[7] = (b * ye - M * X + E * he) * Me, r[8] = (l * _e - o * Ne + m * oe) * Me, r[9] = (n * Ne - t * _e - s * oe) * Me, r[10] = (D * ie - U * X + G * Y) * Me, r[11] = (T * X - b * ie - E * Y) * Me, r[12] = (o * Re - l * me - d * oe) * Me, r[13] = (t * me - n * Re + i * oe) * Me, r[14] = (U * he - D * J - q * Y) * Me, r[15] = (b * J - T * he + M * Y) * Me, r) : null;
}
function UN(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3], s = r[4], l = r[5], o = r[6], d = r[7], m = r[8], b = r[9], T = r[10], M = r[11], E = r[12], D = r[13], U = r[14], q = r[15], G = e * l - t * s, Y = e * o - n * s, he = t * o - n * l, X = m * D - b * E, J = m * U - T * E, ie = b * U - T * D, ye = e * ie - t * J + n * X, oe = s * ie - l * J + o * X, Re = m * he - b * Y + T * G, Ne = E * he - D * Y + U * G;
  return d * ye - i * oe + q * Re - M * Ne;
}
function bf(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3], o = e[4], d = e[5], m = e[6], b = e[7], T = e[8], M = e[9], E = e[10], D = e[11], U = e[12], q = e[13], G = e[14], Y = e[15];
  let he = t[0], X = t[1], J = t[2], ie = t[3];
  return r[0] = he * n + X * o + J * T + ie * U, r[1] = he * i + X * d + J * M + ie * q, r[2] = he * s + X * m + J * E + ie * G, r[3] = he * l + X * b + J * D + ie * Y, he = t[4], X = t[5], J = t[6], ie = t[7], r[4] = he * n + X * o + J * T + ie * U, r[5] = he * i + X * d + J * M + ie * q, r[6] = he * s + X * m + J * E + ie * G, r[7] = he * l + X * b + J * D + ie * Y, he = t[8], X = t[9], J = t[10], ie = t[11], r[8] = he * n + X * o + J * T + ie * U, r[9] = he * i + X * d + J * M + ie * q, r[10] = he * s + X * m + J * E + ie * G, r[11] = he * l + X * b + J * D + ie * Y, he = t[12], X = t[13], J = t[14], ie = t[15], r[12] = he * n + X * o + J * T + ie * U, r[13] = he * i + X * d + J * M + ie * q, r[14] = he * s + X * m + J * E + ie * G, r[15] = he * l + X * b + J * D + ie * Y, r;
}
function D_(r, e, t) {
  const n = t[0], i = t[1], s = t[2];
  let l, o, d, m, b, T, M, E, D, U, q, G;
  return e === r ? (r[12] = e[0] * n + e[4] * i + e[8] * s + e[12], r[13] = e[1] * n + e[5] * i + e[9] * s + e[13], r[14] = e[2] * n + e[6] * i + e[10] * s + e[14], r[15] = e[3] * n + e[7] * i + e[11] * s + e[15]) : (l = e[0], o = e[1], d = e[2], m = e[3], b = e[4], T = e[5], M = e[6], E = e[7], D = e[8], U = e[9], q = e[10], G = e[11], r[0] = l, r[1] = o, r[2] = d, r[3] = m, r[4] = b, r[5] = T, r[6] = M, r[7] = E, r[8] = D, r[9] = U, r[10] = q, r[11] = G, r[12] = l * n + b * i + D * s + e[12], r[13] = o * n + T * i + U * s + e[13], r[14] = d * n + M * i + q * s + e[14], r[15] = m * n + E * i + G * s + e[15]), r;
}
function g2(r, e, t) {
  const n = t[0], i = t[1], s = t[2];
  return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r[4] = e[4] * i, r[5] = e[5] * i, r[6] = e[6] * i, r[7] = e[7] * i, r[8] = e[8] * s, r[9] = e[9] * s, r[10] = e[10] * s, r[11] = e[11] * s, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;
}
function zN(r, e, t, n) {
  let i = n[0], s = n[1], l = n[2], o = Math.sqrt(i * i + s * s + l * l), d, m, b, T, M, E, D, U, q, G, Y, he, X, J, ie, ye, oe, Re, Ne, me, _e, Fe, Me, Ct;
  return o < ng ? null : (o = 1 / o, i *= o, s *= o, l *= o, m = Math.sin(t), d = Math.cos(t), b = 1 - d, T = e[0], M = e[1], E = e[2], D = e[3], U = e[4], q = e[5], G = e[6], Y = e[7], he = e[8], X = e[9], J = e[10], ie = e[11], ye = i * i * b + d, oe = s * i * b + l * m, Re = l * i * b - s * m, Ne = i * s * b - l * m, me = s * s * b + d, _e = l * s * b + i * m, Fe = i * l * b + s * m, Me = s * l * b - i * m, Ct = l * l * b + d, r[0] = T * ye + U * oe + he * Re, r[1] = M * ye + q * oe + X * Re, r[2] = E * ye + G * oe + J * Re, r[3] = D * ye + Y * oe + ie * Re, r[4] = T * Ne + U * me + he * _e, r[5] = M * Ne + q * me + X * _e, r[6] = E * Ne + G * me + J * _e, r[7] = D * Ne + Y * me + ie * _e, r[8] = T * Fe + U * Me + he * Ct, r[9] = M * Fe + q * Me + X * Ct, r[10] = E * Fe + G * Me + J * Ct, r[11] = D * Fe + Y * Me + ie * Ct, e !== r && (r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r);
}
function O5(r, e, t) {
  const n = Math.sin(t), i = Math.cos(t), s = e[4], l = e[5], o = e[6], d = e[7], m = e[8], b = e[9], T = e[10], M = e[11];
  return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = s * i + m * n, r[5] = l * i + b * n, r[6] = o * i + T * n, r[7] = d * i + M * n, r[8] = m * i - s * n, r[9] = b * i - l * n, r[10] = T * i - o * n, r[11] = M * i - d * n, r;
}
function jN(r, e, t) {
  const n = Math.sin(t), i = Math.cos(t), s = e[0], l = e[1], o = e[2], d = e[3], m = e[8], b = e[9], T = e[10], M = e[11];
  return e !== r && (r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = s * i - m * n, r[1] = l * i - b * n, r[2] = o * i - T * n, r[3] = d * i - M * n, r[8] = s * n + m * i, r[9] = l * n + b * i, r[10] = o * n + T * i, r[11] = d * n + M * i, r;
}
function N5(r, e, t) {
  const n = Math.sin(t), i = Math.cos(t), s = e[0], l = e[1], o = e[2], d = e[3], m = e[4], b = e[5], T = e[6], M = e[7];
  return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = s * i + m * n, r[1] = l * i + b * n, r[2] = o * i + T * n, r[3] = d * i + M * n, r[4] = m * i - s * n, r[5] = b * i - l * n, r[6] = T * i - o * n, r[7] = M * i - d * n, r;
}
function VN(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[4], l = e[5], o = e[6], d = e[8], m = e[9], b = e[10];
  return r[0] = Math.sqrt(t * t + n * n + i * i), r[1] = Math.sqrt(s * s + l * l + o * o), r[2] = Math.sqrt(d * d + m * m + b * b), r;
}
function qN(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], l = t + t, o = n + n, d = i + i, m = t * l, b = n * l, T = n * o, M = i * l, E = i * o, D = i * d, U = s * l, q = s * o, G = s * d;
  return r[0] = 1 - T - D, r[1] = b + G, r[2] = M - q, r[3] = 0, r[4] = b - G, r[5] = 1 - m - D, r[6] = E + U, r[7] = 0, r[8] = M + q, r[9] = E - U, r[10] = 1 - m - T, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, r;
}
function GN(r, e, t, n, i, s, l) {
  const o = 1 / (t - e), d = 1 / (i - n), m = 1 / (s - l);
  return r[0] = s * 2 * o, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = s * 2 * d, r[6] = 0, r[7] = 0, r[8] = (t + e) * o, r[9] = (i + n) * d, r[10] = (l + s) * m, r[11] = -1, r[12] = 0, r[13] = 0, r[14] = l * s * 2 * m, r[15] = 0, r;
}
function $N(r, e, t, n, i) {
  const s = 1 / Math.tan(e / 2);
  if (r[0] = s / t, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = s, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, i != null && i !== 1 / 0) {
    const l = 1 / (n - i);
    r[10] = (i + n) * l, r[14] = 2 * i * n * l;
  } else
    r[10] = -1, r[14] = -2 * n;
  return r;
}
const HN = $N;
function WN(r, e, t, n, i, s, l) {
  const o = 1 / (e - t), d = 1 / (n - i), m = 1 / (s - l);
  return r[0] = -2 * o, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -2 * d, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 2 * m, r[11] = 0, r[12] = (e + t) * o, r[13] = (i + n) * d, r[14] = (l + s) * m, r[15] = 1, r;
}
const XN = WN;
function ZN(r, e, t, n) {
  let i, s, l, o, d, m, b, T, M, E;
  const D = e[0], U = e[1], q = e[2], G = n[0], Y = n[1], he = n[2], X = t[0], J = t[1], ie = t[2];
  return Math.abs(D - X) < ng && Math.abs(U - J) < ng && Math.abs(q - ie) < ng ? kN(r) : (T = D - X, M = U - J, E = q - ie, i = 1 / Math.sqrt(T * T + M * M + E * E), T *= i, M *= i, E *= i, s = Y * E - he * M, l = he * T - G * E, o = G * M - Y * T, i = Math.sqrt(s * s + l * l + o * o), i ? (i = 1 / i, s *= i, l *= i, o *= i) : (s = 0, l = 0, o = 0), d = M * o - E * l, m = E * s - T * o, b = T * l - M * s, i = Math.sqrt(d * d + m * m + b * b), i ? (i = 1 / i, d *= i, m *= i, b *= i) : (d = 0, m = 0, b = 0), r[0] = s, r[1] = d, r[2] = T, r[3] = 0, r[4] = l, r[5] = m, r[6] = M, r[7] = 0, r[8] = o, r[9] = b, r[10] = E, r[11] = 0, r[12] = -(s * D + l * U + o * q), r[13] = -(d * D + m * U + b * q), r[14] = -(T * D + M * U + E * q), r[15] = 1, r);
}
function YN() {
  const r = new Mc(4);
  return Mc != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 0), r;
}
function KN(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r[2] = e[2] + t[2], r[3] = e[3] + t[3], r;
}
function m2(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r[2] = e[2] * t, r[3] = e[3] * t, r;
}
function JN(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3];
  return Math.sqrt(e * e + t * t + n * n + i * i);
}
function QN(r) {
  const e = r[0], t = r[1], n = r[2], i = r[3];
  return e * e + t * t + n * n + i * i;
}
function eD(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3];
  let l = t * t + n * n + i * i + s * s;
  return l > 0 && (l = 1 / Math.sqrt(l)), r[0] = t * l, r[1] = n * l, r[2] = i * l, r[3] = s * l, r;
}
function tD(r, e) {
  return r[0] * e[0] + r[1] * e[1] + r[2] * e[2] + r[3] * e[3];
}
function rD(r, e, t, n) {
  const i = e[0], s = e[1], l = e[2], o = e[3];
  return r[0] = i + n * (t[0] - i), r[1] = s + n * (t[1] - s), r[2] = l + n * (t[2] - l), r[3] = o + n * (t[3] - o), r;
}
function Jd(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3];
  return r[0] = t[0] * n + t[4] * i + t[8] * s + t[12] * l, r[1] = t[1] * n + t[5] * i + t[9] * s + t[13] * l, r[2] = t[2] * n + t[6] * i + t[10] * s + t[14] * l, r[3] = t[3] * n + t[7] * i + t[11] * s + t[15] * l, r;
}
function nD(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = t[0], o = t[1], d = t[2], m = t[3], b = m * n + o * s - d * i, T = m * i + d * n - l * s, M = m * s + l * i - o * n, E = -l * n - o * i - d * s;
  return r[0] = b * m + E * -l + T * -d - M * -o, r[1] = T * m + E * -o + M * -l - b * -d, r[2] = M * m + E * -d + b * -o - T * -l, r[3] = e[3], r;
}
(function() {
  const r = YN();
  return function(e, t, n, i, s, l) {
    let o, d;
    for (t || (t = 4), n || (n = 0), i ? d = Math.min(i * t + n, e.length) : d = e.length, o = n; o < d; o += t)
      r[0] = e[o], r[1] = e[o + 1], r[2] = e[o + 2], r[3] = e[o + 3], s(r, r, l), e[o] = r[0], e[o + 1] = r[1], e[o + 2] = r[2], e[o + 3] = r[3];
    return e;
  };
})();
var N1;
(function(r) {
  r[r.COL0ROW0 = 0] = "COL0ROW0", r[r.COL0ROW1 = 1] = "COL0ROW1", r[r.COL0ROW2 = 2] = "COL0ROW2", r[r.COL0ROW3 = 3] = "COL0ROW3", r[r.COL1ROW0 = 4] = "COL1ROW0", r[r.COL1ROW1 = 5] = "COL1ROW1", r[r.COL1ROW2 = 6] = "COL1ROW2", r[r.COL1ROW3 = 7] = "COL1ROW3", r[r.COL2ROW0 = 8] = "COL2ROW0", r[r.COL2ROW1 = 9] = "COL2ROW1", r[r.COL2ROW2 = 10] = "COL2ROW2", r[r.COL2ROW3 = 11] = "COL2ROW3", r[r.COL3ROW0 = 12] = "COL3ROW0", r[r.COL3ROW1 = 13] = "COL3ROW1", r[r.COL3ROW2 = 14] = "COL3ROW2", r[r.COL3ROW3 = 15] = "COL3ROW3";
})(N1 || (N1 = {}));
const iD = 45 * Math.PI / 180, sD = 1, Q0 = 0.1, eb = 500, oD = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class Cn extends L5 {
  static get IDENTITY() {
    return lD();
  }
  static get ZERO() {
    return aD();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return N1;
  }
  constructor(e) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
  }
  // eslint-disable-next-line max-params
  set(e, t, n, i, s, l, o, d, m, b, T, M, E, D, U, q) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this[4] = s, this[5] = l, this[6] = o, this[7] = d, this[8] = m, this[9] = b, this[10] = T, this[11] = M, this[12] = E, this[13] = D, this[14] = U, this[15] = q, this.check();
  }
  // accepts row major order, stores as column major
  // eslint-disable-next-line max-params
  setRowMajor(e, t, n, i, s, l, o, d, m, b, T, M, E, D, U, q) {
    return this[0] = e, this[1] = s, this[2] = m, this[3] = E, this[4] = t, this[5] = l, this[6] = b, this[7] = D, this[8] = n, this[9] = o, this[10] = T, this[11] = U, this[12] = i, this[13] = d, this[14] = M, this[15] = q, this.check();
  }
  toRowMajor(e) {
    return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
  }
  // Constructors
  /** Set to identity matrix */
  identity() {
    return this.copy(oD);
  }
  /**
   *
   * @param object
   * @returns self
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  fromObject(e) {
    return this.check();
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @param quaternion Quaternion to create matrix from
   * @returns self
   */
  fromQuaternion(e) {
    return qN(this, e), this.check();
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @param view.left - Left bound of the frustum
   * @param view.right - Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top - Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far - Far bound of the frustum. Can be set to Infinity.
   * @returns self
   */
  frustum(e) {
    const {
      left: t,
      right: n,
      bottom: i,
      top: s,
      near: l = Q0,
      far: o = eb
    } = e;
    return o === 1 / 0 ? cD(this, t, n, i, s, l) : GN(this, t, n, i, s, l, o), this.check();
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point,
   * and up axis
   * @param view.eye - (vector) Position of the viewer
   * @param view.center - (vector) Point the viewer is looking at
   * @param view.up - (vector) Up axis
   * @returns self
   */
  lookAt(e) {
    const {
      eye: t,
      center: n = [0, 0, 0],
      up: i = [0, 1, 0]
    } = e;
    return ZN(this, t, n, i), this.check();
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   * from "traditional" view space parameters
   * @param view.left - Left bound of the frustum
   * @param view.right number  Right bound of the frustum
   * @param view.bottom - Bottom bound of the frustum
   * @param view.top number  Top bound of the frustum
   * @param view.near - Near bound of the frustum
   * @param view.far number  Far bound of the frustum
   * @returns self
   */
  ortho(e) {
    const {
      left: t,
      right: n,
      bottom: i,
      top: s,
      near: l = Q0,
      far: o = eb
    } = e;
    return XN(this, t, n, i, s, l, o), this.check();
  }
  /**
   * Generates an orthogonal projection matrix with the same parameters
   * as a perspective matrix (plus focalDistance)
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. Typically viewport width / viewport height
   * @param view.focalDistance Distance in the view frustum used for extent calculations
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  orthographic(e) {
    const {
      fovy: t = iD,
      aspect: n = sD,
      focalDistance: i = 1,
      near: s = Q0,
      far: l = eb
    } = e;
    zA(t);
    const o = t / 2, d = i * Math.tan(o), m = d * n;
    return this.ortho({
      left: -m,
      right: m,
      bottom: -d,
      top: d,
      near: s,
      far: l
    });
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   * @param view.fovy Vertical field of view in radians
   * @param view.aspect Aspect ratio. typically viewport width/height
   * @param view.near Near bound of the frustum
   * @param view.far Far bound of the frustum
   * @returns self
   */
  perspective(e) {
    const {
      fovy: t = 45 * Math.PI / 180,
      aspect: n = 1,
      near: i = 0.1,
      far: s = 500
    } = e;
    return zA(t), HN(this, t, n, i, s), this.check();
  }
  // Accessors
  determinant() {
    return UN(this);
  }
  /**
   * Extracts the non-uniform scale assuming the matrix is an affine transformation.
   * The scales are the "lengths" of the column vectors in the upper-left 3x3 matrix.
   * @param result
   * @returns self
   */
  getScale() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
    return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
  }
  /**
   * Gets the translation portion, assuming the matrix is a affine transformation matrix.
   * @param result
   * @returns self
   */
  getTranslation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
    return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
  }
  /**
   * Gets upper left 3x3 pure rotation matrix (non-scaling), assume affine transformation matrix
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotation(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const n = this.getScale(t), i = 1 / n[0], s = 1 / n[1], l = 1 / n[2];
    return e[0] = this[0] * i, e[1] = this[1] * s, e[2] = this[2] * l, e[3] = 0, e[4] = this[4] * i, e[5] = this[5] * s, e[6] = this[6] * l, e[7] = 0, e[8] = this[8] * i, e[9] = this[9] * s, e[10] = this[10] * l, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  /**
   *
   * @param result
   * @param scaleResult
   * @returns self
   */
  getRotationMatrix3(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const n = this.getScale(t), i = 1 / n[0], s = 1 / n[1], l = 1 / n[2];
    return e[0] = this[0] * i, e[1] = this[1] * s, e[2] = this[2] * l, e[3] = this[4] * i, e[4] = this[5] * s, e[5] = this[6] * l, e[6] = this[8] * i, e[7] = this[9] * s, e[8] = this[10] * l, e;
  }
  // Modifiers
  transpose() {
    return FN(this, this), this.check();
  }
  invert() {
    return O1(this, this), this.check();
  }
  // Operations
  multiplyLeft(e) {
    return bf(this, e, this), this.check();
  }
  multiplyRight(e) {
    return bf(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the X axis
  rotateX(e) {
    return O5(this, this, e), this.check();
  }
  // Rotates a matrix by the given angle around the Y axis.
  rotateY(e) {
    return jN(this, this, e), this.check();
  }
  /**
   * Rotates a matrix by the given angle around the Z axis.
   * @param radians
   * @returns self
   */
  rotateZ(e) {
    return N5(this, this, e), this.check();
  }
  /**
   *
   * @param param0
   * @returns self
   */
  rotateXYZ(e) {
    return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
  }
  /**
   *
   * @param radians
   * @param axis
   * @returns self
   */
  rotateAxis(e, t) {
    return zN(this, this, e, t), this.check();
  }
  /**
   *
   * @param factor
   * @returns self
   */
  scale(e) {
    return g2(this, this, Array.isArray(e) ? e : [e, e, e]), this.check();
  }
  /**
   *
   * @param vec
   * @returns self
   */
  translate(e) {
    return D_(this, this, e), this.check();
  }
  // Transforms
  /**
   * Transforms any 2, 3 or 4 element vector. 2 and 3 elements are treated as points
   * @param vector
   * @param result
   * @returns self
   */
  transform(e, t) {
    return e.length === 4 ? (t = Jd(t || [-0, -0, -0, -0], e, this), rg(t, 4), t) : this.transformAsPoint(e, t);
  }
  /**
   * Transforms any 2 or 3 element array as point (w implicitly 1)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsPoint(e, t) {
    const {
      length: n
    } = e;
    let i;
    switch (n) {
      case 2:
        i = A5(t || [-0, -0], e, this);
        break;
      case 3:
        i = d2(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return rg(i, e.length), i;
  }
  /**
   * Transforms any 2 or 3 element array as vector (w implicitly 0)
   * @param vector
   * @param result
   * @returns self
   */
  transformAsVector(e, t) {
    let n;
    switch (e.length) {
      case 2:
        n = T5(t || [-0, -0], e, this);
        break;
      case 3:
        n = S5(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return rg(n, e.length), n;
  }
  /** @deprecated */
  transformPoint(e, t) {
    return this.transformAsPoint(e, t);
  }
  /** @deprecated */
  transformVector(e, t) {
    return this.transformAsPoint(e, t);
  }
  /** @deprecated */
  transformDirection(e, t) {
    return this.transformAsVector(e, t);
  }
  // three.js math API compatibility
  makeRotationX(e) {
    return this.identity().rotateX(e);
  }
  makeTranslation(e, t, n) {
    return this.identity().translate([e, t, n]);
  }
}
let mm, _m;
function aD() {
  return mm || (mm = new Cn([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(mm)), mm;
}
function lD() {
  return _m || (_m = new Cn(), Object.freeze(_m)), _m;
}
function zA(r) {
  if (r > Math.PI * 2)
    throw Error("expected radians");
}
function cD(r, e, t, n, i, s) {
  const l = 2 * s / (t - e), o = 2 * s / (i - n), d = (t + e) / (t - e), m = (i + n) / (i - n), b = -1, T = -1, M = -2 * s;
  return r[0] = l, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = d, r[9] = m, r[10] = b, r[11] = T, r[12] = 0, r[13] = 0, r[14] = M, r[15] = 0, r;
}
function jA() {
  const r = new Mc(4);
  return Mc != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r[3] = 1, r;
}
function uD(r) {
  return r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1, r;
}
function D5(r, e, t) {
  t = t * 0.5;
  const n = Math.sin(t);
  return r[0] = n * e[0], r[1] = n * e[1], r[2] = n * e[2], r[3] = Math.cos(t), r;
}
function VA(r, e, t) {
  const n = e[0], i = e[1], s = e[2], l = e[3], o = t[0], d = t[1], m = t[2], b = t[3];
  return r[0] = n * b + l * o + i * m - s * d, r[1] = i * b + l * d + s * o - n * m, r[2] = s * b + l * m + n * d - i * o, r[3] = l * b - n * o - i * d - s * m, r;
}
function hD(r, e, t) {
  t *= 0.5;
  const n = e[0], i = e[1], s = e[2], l = e[3], o = Math.sin(t), d = Math.cos(t);
  return r[0] = n * d + l * o, r[1] = i * d + s * o, r[2] = s * d - i * o, r[3] = l * d - n * o, r;
}
function fD(r, e, t) {
  t *= 0.5;
  const n = e[0], i = e[1], s = e[2], l = e[3], o = Math.sin(t), d = Math.cos(t);
  return r[0] = n * d - s * o, r[1] = i * d + l * o, r[2] = s * d + n * o, r[3] = l * d - i * o, r;
}
function dD(r, e, t) {
  t *= 0.5;
  const n = e[0], i = e[1], s = e[2], l = e[3], o = Math.sin(t), d = Math.cos(t);
  return r[0] = n * d + i * o, r[1] = i * d - n * o, r[2] = s * d + l * o, r[3] = l * d - s * o, r;
}
function pD(r, e) {
  const t = e[0], n = e[1], i = e[2];
  return r[0] = t, r[1] = n, r[2] = i, r[3] = Math.sqrt(Math.abs(1 - t * t - n * n - i * i)), r;
}
function Zm(r, e, t, n) {
  const i = e[0], s = e[1], l = e[2], o = e[3];
  let d = t[0], m = t[1], b = t[2], T = t[3], M, E, D, U, q;
  return M = i * d + s * m + l * b + o * T, M < 0 && (M = -M, d = -d, m = -m, b = -b, T = -T), 1 - M > ng ? (E = Math.acos(M), q = Math.sin(E), D = Math.sin((1 - n) * E) / q, U = Math.sin(n * E) / q) : (D = 1 - n, U = n), r[0] = D * i + U * d, r[1] = D * s + U * m, r[2] = D * l + U * b, r[3] = D * o + U * T, r;
}
function gD(r, e) {
  const t = e[0], n = e[1], i = e[2], s = e[3], l = t * t + n * n + i * i + s * s, o = l ? 1 / l : 0;
  return r[0] = -t * o, r[1] = -n * o, r[2] = -i * o, r[3] = s * o, r;
}
function mD(r, e) {
  return r[0] = -e[0], r[1] = -e[1], r[2] = -e[2], r[3] = e[3], r;
}
function k5(r, e) {
  const t = e[0] + e[4] + e[8];
  let n;
  if (t > 0)
    n = Math.sqrt(t + 1), r[3] = 0.5 * n, n = 0.5 / n, r[0] = (e[5] - e[7]) * n, r[1] = (e[6] - e[2]) * n, r[2] = (e[1] - e[3]) * n;
  else {
    let i = 0;
    e[4] > e[0] && (i = 1), e[8] > e[i * 3 + i] && (i = 2);
    const s = (i + 1) % 3, l = (i + 2) % 3;
    n = Math.sqrt(e[i * 3 + i] - e[s * 3 + s] - e[l * 3 + l] + 1), r[i] = 0.5 * n, n = 0.5 / n, r[3] = (e[s * 3 + l] - e[l * 3 + s]) * n, r[s] = (e[s * 3 + i] + e[i * 3 + s]) * n, r[l] = (e[l * 3 + i] + e[i * 3 + l]) * n;
  }
  return r;
}
const _D = KN, yD = m2, bD = tD, vD = rD, xD = JN, wD = QN, F5 = eD, AD = function() {
  const r = C5(), e = kA(1, 0, 0), t = kA(0, 1, 0);
  return function(n, i, s) {
    const l = f2(i, s);
    return l < -0.999999 ? (Xm(r, e, i), B5(r) < 1e-6 && Xm(r, t, i), xN(r, r), D5(n, r, Math.PI), n) : l > 0.999999 ? (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n) : (Xm(r, i, s), n[0] = r[0], n[1] = r[1], n[2] = r[2], n[3] = 1 + l, F5(n, n));
  };
}();
(function() {
  const r = jA(), e = jA();
  return function(t, n, i, s, l, o) {
    return Zm(r, n, l, o), Zm(e, i, s, o), Zm(t, r, e, 2 * o * (1 - o)), t;
  };
})();
(function() {
  const r = CN();
  return function(e, t, n, i) {
    return r[0] = n[0], r[3] = n[1], r[6] = n[2], r[1] = i[0], r[4] = i[1], r[7] = i[2], r[2] = -t[0], r[5] = -t[1], r[8] = -t[2], F5(e, k5(e, r));
  };
})();
const TD = [0, 0, 0, 1];
class fg extends c2 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    super(-0, -0, -0, -0), Array.isArray(e) && arguments.length === 1 ? this.copy(e) : this.set(e, t, n, i);
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  set(e, t, n, i) {
    return this[0] = e, this[1] = t, this[2] = n, this[3] = i, this.check();
  }
  fromObject(e) {
    return this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this.check();
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   * NOTE: The resultant quaternion is not normalized, so you should
   * be sure to renormalize the quaternion yourself where necessary.
   * @param m
   * @returns
   */
  fromMatrix3(e) {
    return k5(this, e), this.check();
  }
  fromAxisRotation(e, t) {
    return D5(this, e, t), this.check();
  }
  /** Set a quat to the identity quaternion */
  identity() {
    return uD(this), this.check();
  }
  // Set the components of a quat to the given values
  // set(i, j, k, l) {
  //   quat_set(this, i, j, k, l);
  //   return this.check();
  // }
  // Sets a quat from the given angle and rotation axis, then returns it.
  setAxisAngle(e, t) {
    return this.fromAxisRotation(e, t);
  }
  // Getters/setters
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Yn(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Yn(e);
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Yn(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Yn(e);
  }
  // Calculates the length of a quat
  len() {
    return xD(this);
  }
  // Calculates the squared length of a quat
  lengthSquared() {
    return wD(this);
  }
  // Calculates the dot product of two quat's
  // @return {Number}
  dot(e) {
    return bD(this, e);
  }
  // Gets the rotation axis and angle for a given quaternion.
  // If a quaternion is created with setAxisAngle, this method will
  // return the same values as providied in the original parameter
  // list OR functionally equivalent values.
  // Example: The quaternion formed by axis [0, 0, 1] and angle -90
  // is the same as the quaternion formed by [0, 0, 1] and 270.
  // This method favors the latter.
  // @return {{[x,y,z], Number}}
  // getAxisAngle() {
  //   const axis = [];
  // //   const angle = quat_getAxisAngle(axis, this);
  //   return {axis, angle};
  // }
  // MODIFIERS
  // Sets a quaternion to represent the shortest rotation from one vector
  // to another. Both vectors are assumed to be unit length.
  rotationTo(e, t) {
    return AD(this, e, t), this.check();
  }
  // Sets the specified quaternion with values corresponding to the given axes.
  // Each axis is a vec3 and is expected to be unit length and perpendicular
  // to all other specified axes.
  // setAxes() {
  //   Number
  // }
  // Performs a spherical linear interpolation with two control points
  // sqlerp() {
  //   Number;
  // }
  // Adds two quat's
  add(e) {
    return _D(this, this, e), this.check();
  }
  // Calculates the W component of a quat from the X, Y, and Z components.
  // Any existing W component will be ignored.
  calculateW() {
    return pD(this, this), this.check();
  }
  // Calculates the conjugate of a quat If the quaternion is normalized,
  // this function is faster than quat_invert and produces the same result.
  conjugate() {
    return mD(this, this), this.check();
  }
  // Calculates the inverse of a quat
  invert() {
    return gD(this, this), this.check();
  }
  // Performs a linear interpolation between two quat's
  lerp(e, t, n) {
    return n === void 0 ? this.lerp(this, e, t) : (vD(this, e, t, n), this.check());
  }
  // Multiplies two quat's
  multiplyRight(e) {
    return VA(this, this, e), this.check();
  }
  multiplyLeft(e) {
    return VA(this, e, this), this.check();
  }
  // Normalize a quat
  normalize() {
    const e = this.len(), t = e > 0 ? 1 / e : 0;
    return this[0] = this[0] * t, this[1] = this[1] * t, this[2] = this[2] * t, this[3] = this[3] * t, e === 0 && (this[3] = 1), this.check();
  }
  // Rotates a quaternion by the given angle about the X axis
  rotateX(e) {
    return hD(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Y axis
  rotateY(e) {
    return fD(this, this, e), this.check();
  }
  // Rotates a quaternion by the given angle about the Z axis
  rotateZ(e) {
    return dD(this, this, e), this.check();
  }
  // Scales a quat by a scalar number
  scale(e) {
    return yD(this, this, e), this.check();
  }
  // Performs a spherical linear interpolation between two quat
  slerp(e, t, n) {
    let i, s, l;
    switch (arguments.length) {
      case 1:
        ({
          start: i = TD,
          target: s,
          ratio: l
        } = e);
        break;
      case 2:
        i = this, s = e, l = t;
        break;
      default:
        i = e, s = t, l = n;
    }
    return Zm(this, i, s, l), this.check();
  }
  transformVector4(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new p2();
    return nD(t, e, this), rg(t, 4);
  }
  // THREE.js Math API compatibility
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(e, t) {
    return this.setAxisAngle(e, t);
  }
  premultiply(e) {
    return this.multiplyLeft(e);
  }
  multiply(e) {
    return this.multiplyRight(e);
  }
}
const SD = 0.1, ED = 1e-12, U5 = 1e-15, CD = 1e-20;
function z5(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const n = Math.fround(r), i = r - n;
  return e[t] = n, e[t + 1] = i, e;
}
function ID(r) {
  return r - Math.fround(r);
}
function MD(r) {
  const e = new Float32Array(32);
  for (let t = 0; t < 4; ++t)
    for (let n = 0; n < 4; ++n) {
      const i = t * 4 + n;
      z5(r[n * 4 + t], e, i * 2);
    }
  return e;
}
const PD = (
  /* glsl */
  `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`
), RD = {
  name: "fp32",
  vs: PD
}, BD = (
  /* glsl */
  `
uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`
), LD = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1
}, OD = {
  name: "fp64arithmetic",
  vs: BD,
  defaultUniforms: LD,
  uniformTypes: {
    ONE: "f32"
  },
  // Additional Functions
  fp64ify: z5,
  fp64LowPart: ID,
  fp64ifyMatrix4: MD
}, ND = [0, 1, 1, 1], DD = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`
), kD = (
  /* glsl */
  `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`
), qA = {
  props: {},
  uniforms: {},
  name: "picking",
  uniformTypes: {
    isActive: "f32",
    isAttribute: "f32",
    isHighlightActive: "f32",
    useFloatColors: "f32",
    highlightedObjectColor: "vec3<f32>",
    highlightColor: "vec4<f32>"
  },
  defaultUniforms: {
    isActive: !1,
    isAttribute: !1,
    isHighlightActive: !1,
    useFloatColors: !0,
    highlightedObjectColor: [0, 0, 0],
    highlightColor: ND
  },
  vs: DD,
  fs: kD,
  getUniforms: FD
};
function FD() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const e = {};
  if (r.highlightedObjectColor !== void 0) if (r.highlightedObjectColor === null)
    e.isHighlightActive = !1;
  else {
    e.isHighlightActive = !0;
    const t = r.highlightedObjectColor.slice(0, 3);
    e.highlightedObjectColor = t;
  }
  if (r.highlightColor) {
    const t = Array.from(r.highlightColor, (n) => n / 255);
    Number.isFinite(t[3]) || (t[3] = 1), e.highlightColor = t;
  }
  return r.isActive !== void 0 && (e.isActive = !!r.isActive, e.isAttribute = !!r.isAttribute), r.useFloatColors !== void 0 && (e.useFloatColors = !!r.useFloatColors), e;
}
const GA = (
  /* glsl */
  `precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`
), UD = (
  /* wgsl */
  `// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  poightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`
), j5 = 3, zD = 255;
var dg;
(function(r) {
  r[r.POINT = 0] = "POINT", r[r.DIRECTIONAL = 1] = "DIRECTIONAL";
})(dg || (dg = {}));
const Ed = {
  props: {},
  uniforms: {},
  name: "lighting",
  defines: {
    MAX_LIGHTS: j5
  },
  uniformTypes: {
    enabled: "i32",
    lightType: "i32",
    directionalLightCount: "i32",
    pointLightCount: "i32",
    ambientLightColor: "vec3<f32>",
    // TODO define as arrays once we have appropriate uniformTypes
    lightColor0: "vec3<f32>",
    lightPosition0: "vec3<f32>",
    // TODO - could combine direction and attenuation
    lightDirection0: "vec3<f32>",
    lightAttenuation0: "vec3<f32>",
    lightColor1: "vec3<f32>",
    lightPosition1: "vec3<f32>",
    lightDirection1: "vec3<f32>",
    lightAttenuation1: "vec3<f32>",
    lightColor2: "vec3<f32>",
    lightPosition2: "vec3<f32>",
    lightDirection2: "vec3<f32>",
    lightAttenuation2: "vec3<f32>"
  },
  defaultUniforms: {
    enabled: 1,
    lightType: dg.POINT,
    directionalLightCount: 0,
    pointLightCount: 0,
    ambientLightColor: [0.1, 0.1, 0.1],
    lightColor0: [1, 1, 1],
    lightPosition0: [1, 1, 2],
    // TODO - could combine direction and attenuation
    lightDirection0: [1, 1, 1],
    lightAttenuation0: [1, 0, 0],
    lightColor1: [1, 1, 1],
    lightPosition1: [1, 1, 2],
    lightDirection1: [1, 1, 1],
    lightAttenuation1: [1, 0, 0],
    lightColor2: [1, 1, 1],
    lightPosition2: [1, 1, 2],
    lightDirection2: [1, 1, 1],
    lightAttenuation2: [1, 0, 0]
  },
  source: UD,
  vs: GA,
  fs: GA,
  getUniforms: jD
};
function jD(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (r = r && {
    ...r
  }, !r)
    return {
      ...Ed.defaultUniforms
    };
  r.lights && (r = {
    ...r,
    ...qD(r.lights),
    lights: void 0
  });
  const {
    ambientLight: t,
    pointLights: n,
    directionalLights: i
  } = r || {};
  if (!(t || n && n.length > 0 || i && i.length > 0))
    return {
      ...Ed.defaultUniforms,
      enabled: 0
    };
  const l = {
    ...Ed.defaultUniforms,
    ...e,
    ...VD({
      ambientLight: t,
      pointLights: n,
      directionalLights: i
    })
  };
  return r.enabled !== void 0 && (l.enabled = r.enabled ? 1 : 0), l;
}
function VD(r) {
  let {
    ambientLight: e,
    pointLights: t = [],
    directionalLights: n = []
  } = r;
  const i = {};
  i.ambientLightColor = tb(e);
  let s = 0;
  for (const l of t) {
    i.lightType = dg.POINT;
    const o = s;
    i[`lightColor${o}`] = tb(l), i[`lightPosition${o}`] = l.position, i[`lightAttenuation${o}`] = l.attenuation || [1, 0, 0], s++;
  }
  for (const l of n) {
    i.lightType = dg.DIRECTIONAL;
    const o = s;
    i[`lightColor${o}`] = tb(l), i[`lightDirection${o}`] = l.direction, s++;
  }
  return s > j5 && lr.warn("MAX_LIGHTS exceeded")(), i.directionalLightCount = n.length, i.pointLightCount = t.length, i;
}
function qD(r) {
  var t, n;
  const e = {
    pointLights: [],
    directionalLights: []
  };
  for (const i of r || [])
    switch (i.type) {
      case "ambient":
        e.ambientLight = i;
        break;
      case "directional":
        (t = e.directionalLights) == null || t.push(i);
        break;
      case "point":
        (n = e.pointLights) == null || n.push(i);
        break;
    }
  return e;
}
function tb() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    color: e = [0, 0, 0],
    intensity: t = 1
  } = r;
  return e.map((n) => n * t / zD);
}
const V5 = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`
), q5 = (
  /* glsl */
  `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`
), G5 = {
  props: {},
  name: "gouraudMaterial",
  // Note these are switched between phong and gouraud
  vs: q5.replace("phongMaterial", "gouraudMaterial"),
  fs: V5.replace("phongMaterial", "gouraudMaterial"),
  defines: {
    LIGHTING_VERTEX: 1
  },
  dependencies: [Ed],
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(r) {
    const e = {
      ...r
    };
    return e.specularColor && (e.specularColor = e.specularColor.map((t) => t / 255)), {
      ...G5.defaultUniforms,
      ...e
    };
  }
}, GD = (
  /* wgsl */
  `struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> material : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`
), $5 = {
  name: "phongMaterial",
  dependencies: [Ed],
  // Note these are switched between phong and gouraud
  source: GD,
  vs: V5,
  fs: q5,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  uniformTypes: {
    ambient: "f32",
    diffuse: "f32",
    shininess: "f32",
    specularColor: "vec3<f32>"
  },
  defaultUniforms: {
    ambient: 0.35,
    diffuse: 0.6,
    shininess: 32,
    specularColor: [0.15, 0.15, 0.15]
  },
  getUniforms(r) {
    const e = {
      ...r
    };
    return e.specularColor && (e.specularColor = e.specularColor.map((t) => t / 255)), {
      ...$5.defaultUniforms,
      ...e
    };
  }
}, $D = (
  /* glsl */
  `out vec3 pbr_vPosition;
out vec2 pbr_vUV;

#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif

void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
  vec4 pos = pbrProjection.modelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  vec3 normalW = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));
  vec3 tangentW = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));
  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
  pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else // HAS_TANGENTS != 1
  pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}
`
), HD = (
  /* glsl */
  `precision highp float;

uniform pbrMaterialUniforms {
  // Material is unlit
  bool unlit;

  // Base color map
  bool baseColorMapEnabled;
  vec4 baseColorFactor;

  bool normalMapEnabled;  
  float normalScale; // #ifdef HAS_NORMALMAP

  bool emissiveMapEnabled;
  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP

  vec2 metallicRoughnessValues;
  bool metallicRoughnessMapEnabled;

  bool occlusionMapEnabled;
  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP
  
  bool alphaCutoffEnabled;
  float alphaCutoff; // #ifdef ALPHA_CUTOFF
  
  // IBL
  bool IBLenabled;
  vec2 scaleIBLAmbient; // #ifdef USE_IBL
  
  // debugging flags used for shader output of intermediate PBR variables
  // #ifdef PBR_DEBUG
  vec4 scaleDiffBaseMR;
  vec4 scaleFGDSpec;
  // #endif
} pbrMaterial;

// Samplers
#ifdef HAS_BASECOLORMAP
uniform sampler2D pbr_baseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D pbr_normalSampler;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D pbr_emissiveSampler;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D pbr_metallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D pbr_occlusionSampler;
#endif
#ifdef USE_IBL
uniform samplerCube pbr_diffuseEnvSampler;
uniform samplerCube pbr_specularEnvSampler;
uniform sampler2D pbr_brdfLUT;
#endif

// Inputs from vertex shader

in vec3 pbr_vPosition;
in vec2 pbr_vUV;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo {
  float NdotL;                  // cos angle between normal and light direction
  float NdotV;                  // cos angle between normal and view direction
  float NdotH;                  // cos angle between normal and half vector
  float LdotH;                  // cos angle between light direction and half vector
  float VdotH;                  // cos angle between view direction and half vector
  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
  float metalness;              // metallic value at the surface
  vec3 reflectance0;            // full reflectance color (normal incidence angle)
  vec3 reflectance90;           // reflectance color at grazing angle
  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
  vec3 diffuseColor;            // color contribution from diffuse lighting
  vec3 specularColor;           // color contribution from specular lighting
  vec3 n;                       // normal at surface point
  vec3 v;                       // vector from surface point to camera
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else // SRGB_FAST_APPROXIMATION
  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif //SRGB_FAST_APPROXIMATION
  return vec4(linOut,srgbIn.w);;
#else //MANUAL_SRGB
  return srgbIn;
#endif //MANUAL_SRGB
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
  // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
  vec3 pos_dx = dFdx(pbr_vPosition);
  vec3 pos_dy = dFdy(pbr_vPosition);
  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  vec3 ng = normalize(pbr_vNormal);
#else
  vec3 ng = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  vec3 b = normalize(cross(ng, t));
  mat3 tbn = mat3(t, b, ng);
#else // HAS_TANGENTS
  mat3 tbn = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));
#else
  // The tbn matrix is linearly interpolated, so we need to re-normalize
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)
{
  float mipCount = 9.0; // resolution of 512x512
  float lod = (pbrInfo.perceptualRoughness * mipCount);
  // retrieve a scale and bias to F0. See [1], Figure 3
  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,
    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;
  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);

  // For presentation, this allows us to disable IBL terms
  diffuse *= pbrMaterial.scaleIBLAmbient.x;
  specular *= pbrMaterial.scaleIBLAmbient.y;

  return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 diffuse(PBRInfo pbrInfo)
{
  return pbrInfo.diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInfo)
{
  return pbrInfo.reflectance0 +
    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *
    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInfo)
{
  float NdotL = pbrInfo.NdotL;
  float NdotV = pbrInfo.NdotV;
  float r = pbrInfo.alphaRoughness;

  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across
// the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface
// for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes
// from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInfo)
{
  float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;
  float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;
  return roughnessSq / (M_PI * f * f);
}

void PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {
  pbrInfo.NdotL = 1.0;
  pbrInfo.NdotH = 0.0;
  pbrInfo.LdotH = 0.0;
  pbrInfo.VdotH = 1.0;
}

void PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {
  vec3 n = pbrInfo.n;
  vec3 v = pbrInfo.v;
  vec3 l = normalize(lightDirection);             // Vector from surface point to light
  vec3 h = normalize(l+v);                        // Half vector between both l and v

  pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);
  pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
  pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
  pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
}

void PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {
  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInfo, light_direction);
}

vec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {
  // Calculate the shading terms for the microfacet specular shading model
  vec3 F = specularReflection(pbrInfo);
  float G = geometricOcclusion(pbrInfo);
  float D = microfacetDistribution(pbrInfo);

  // Calculation of analytical lighting contribution
  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);
  vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);
  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);
}

vec4 pbr_filterColor(vec4 colorUnused)
{
  // The albedo may be defined from a base texture or a flat color
#ifdef HAS_BASECOLORMAP
  vec4 baseColor = SRGBtoLINEAR(texture(pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;
#else
  vec4 baseColor = pbrMaterial.baseColorFactor;
#endif

#ifdef ALPHA_CUTOFF
  if (baseColor.a < pbrMaterial.alphaCutoff) {
    discard;
  }
#endif

  vec3 color = vec3(0, 0, 0);

  if(pbrMaterial.unlit){
    color.rgb = baseColor.rgb;
  }
  else{
    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    float perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;
    float metallic = pbrMaterial.metallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    vec4 mrSample = texture(pbr_metallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
#endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);
    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing
    // reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%),
    // incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();                          // normal at surface point
    vec3 v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera

    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    vec3 reflection = -normalize(reflect(v, n));

    PBRInfo pbrInfo = PBRInfo(
      0.0, // NdotL
      NdotV,
      0.0, // NdotH
      0.0, // LdotH
      0.0, // VdotH
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );


#ifdef USE_LIGHTS
    // Apply ambient light
    PBRInfo_setAmbientLight(pbrInfo);
    color += calculateFinalColor(pbrInfo, lighting.ambientColor);

    // Apply directional light
    for(int i = 0; i < lighting.directionalLightCount; i++) {
      if (i < lighting.directionalLightCount) {
        PBRInfo_setDirectionalLight(pbrInfo, lighting_getDirectionalLight(i).direction);
        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);
      }
    }

    // Apply point light
    for(int i = 0; i < lighting.pointLightCount; i++) {
      if (i < lighting.pointLightCount) {
        PBRInfo_setPointLight(pbrInfo, lighting_getPointLight(i));
        float attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));
        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);
      }
    }
#endif

    // Calculate lighting contribution from image based lighting source (IBL)
#ifdef USE_IBL
    if (pbrMaterial.IBLenabled) {
      color += getIBLContribution(pbrInfo, n, reflection);
    }
#endif

 // Apply optional PBR terms for additional (optional) shading
#ifdef HAS_OCCLUSIONMAP
    if (pbrMaterial.occlusionMapEnabled) {
      float ao = texture(pbr_occlusionSampler, pbr_vUV).r;
      color = mix(color, color * ao, pbrMaterial.occlusionStrength);
    }
#endif

#ifdef HAS_EMISSIVEMAP
    if (pbrMaterial.emissiveMapEnabled) {
      vec3 emissive = SRGBtoLINEAR(texture(pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;
      color += emissive;
    }
#endif

    // This section uses mix to override final color for reference app visualization
    // of various parameters in the lighting equation.
#ifdef PBR_DEBUG
    // TODO: Figure out how to debug multiple lights

    // color = mix(color, F, pbr_scaleFGDSpec.x);
    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);
    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);
    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);

    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);
    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);
    color = mix(color, vec3(metallic), pbrMaterial.scaleDiffBaseMR.z);
    color = mix(color, vec3(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);
#endif

  }

  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`
), $A = (
  /* glsl */
  `uniform pbrProjectionUniforms {
  mat4 modelViewProjectionMatrix;
  mat4 modelMatrix;
  mat4 normalMatrix;
  vec3 camera;
} pbrProjection;
`
), WD = {
  name: "pbrProjection",
  vs: $A,
  fs: $A,
  // TODO why is this needed?
  getUniforms: (r) => r,
  uniformTypes: {
    modelViewProjectionMatrix: "mat4x4<f32>",
    modelMatrix: "mat4x4<f32>",
    normalMatrix: "mat4x4<f32>",
    camera: "vec3<i32>"
  }
}, _2 = {
  props: {},
  uniforms: {},
  name: "pbrMaterial",
  dependencies: [Ed, WD],
  vs: $D,
  fs: HD,
  defines: {
    LIGHTING_FRAGMENT: 1
    // TODO defining these as 0 breaks shader
    // HAS_NORMALMAP: 0
    // HAS_EMISSIVEMAP: 0,
    // HAS_OCCLUSIONMAP: 0,
    // HAS_BASECOLORMAP: 0,
    // HAS_METALROUGHNESSMAP: 0,
    // ALPHA_CUTOFF: 0
    // USE_IBL: 0
    // PBR_DEBUG: 0
  },
  getUniforms: (r) => r,
  uniformTypes: {
    // Material is unlit
    unlit: "i32",
    // Base color map
    baseColorMapEnabled: "i32",
    baseColorFactor: "vec4<f32>",
    normalMapEnabled: "i32",
    normalScale: "f32",
    // #ifdef HAS_NORMALMAP
    emissiveMapEnabled: "i32",
    emissiveFactor: "vec3<f32>",
    // #ifdef HAS_EMISSIVEMAP
    metallicRoughnessValues: "vec2<f32>",
    metallicRoughnessMapEnabled: "i32",
    occlusionMapEnabled: "i32",
    occlusionStrength: "f32",
    // #ifdef HAS_OCCLUSIONMAP
    alphaCutoffEnabled: "i32",
    alphaCutoff: "f32",
    // #ifdef ALPHA_CUTOFF
    // IBL
    IBLenabled: "i32",
    scaleIBLAmbient: "vec2<f32>",
    // #ifdef USE_IBL
    // debugging flags used for shader output of intermediate PBR variables
    // #ifdef PBR_DEBUG
    scaleDiffBaseMR: "vec4<f32>",
    scaleFGDSpec: "vec4<f32>"
  }
}, HA = `uniform layerUniforms {
  uniform float opacity;
} layer;
`, XD = {
  name: "layer",
  vs: HA,
  fs: HA,
  getUniforms: (r) => ({
    // apply gamma to opacity to make it visually "linear"
    // TODO - v10: use raw opacity?
    opacity: Math.pow(r.opacity, 1 / 2.2)
  }),
  uniformTypes: {
    opacity: "f32"
  }
}, H5 = "#define SMOOTH_EDGE_RADIUS 0.5", ZD = `
${H5}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`, YD = `
${H5}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`, W5 = {
  name: "geometry",
  vs: ZD,
  fs: YD
}, KD = 25;
var Fs;
(function(r) {
  r[r.Start = 1] = "Start", r[r.Move = 2] = "Move", r[r.End = 4] = "End", r[r.Cancel = 8] = "Cancel";
})(Fs || (Fs = {}));
var Ws;
(function(r) {
  r[r.None = 0] = "None", r[r.Left = 1] = "Left", r[r.Right = 2] = "Right", r[r.Up = 4] = "Up", r[r.Down = 8] = "Down", r[r.Horizontal = 3] = "Horizontal", r[r.Vertical = 12] = "Vertical", r[r.All = 15] = "All";
})(Ws || (Ws = {}));
var fn;
(function(r) {
  r[r.Possible = 1] = "Possible", r[r.Began = 2] = "Began", r[r.Changed = 4] = "Changed", r[r.Ended = 8] = "Ended", r[r.Recognized = 8] = "Recognized", r[r.Cancelled = 16] = "Cancelled", r[r.Failed = 32] = "Failed";
})(fn || (fn = {}));
const JD = "compute", QD = "auto", D1 = "manipulation", Ym = "none", k1 = "pan-x", F1 = "pan-y";
function ek(r) {
  if (r.includes(Ym))
    return Ym;
  const e = r.includes(k1), t = r.includes(F1);
  return e && t ? Ym : e || t ? e ? k1 : F1 : r.includes(D1) ? D1 : QD;
}
class tk {
  constructor(e, t) {
    this.actions = "", this.manager = e, this.set(t);
  }
  /**
   * set the touchAction value on the element or enable the polyfill
   */
  set(e) {
    e === JD && (e = this.compute()), this.manager.element && (this.manager.element.style.touchAction = e, this.actions = e);
  }
  /**
   * just re-set the touchAction value
   */
  update() {
    this.set(this.manager.options.touchAction);
  }
  /**
   * compute the value for the touchAction property based on the recognizer's settings
   */
  compute() {
    let e = [];
    for (const t of this.manager.recognizers)
      t.options.enable && (e = e.concat(t.getTouchAction()));
    return ek(e.join(" "));
  }
}
function k_(r) {
  return r.trim().split(/\s+/g);
}
function rb(r, e, t) {
  if (r)
    for (const n of k_(e))
      r.addEventListener(n, t, !1);
}
function nb(r, e, t) {
  if (r)
    for (const n of k_(e))
      r.removeEventListener(n, t, !1);
}
function WA(r) {
  return (r.ownerDocument || r).defaultView;
}
function rk(r, e) {
  let t = r;
  for (; t; ) {
    if (t === e)
      return !0;
    t = t.parentNode;
  }
  return !1;
}
function X5(r) {
  const e = r.length;
  if (e === 1)
    return {
      x: Math.round(r[0].clientX),
      y: Math.round(r[0].clientY)
    };
  let t = 0, n = 0, i = 0;
  for (; i < e; )
    t += r[i].clientX, n += r[i].clientY, i++;
  return {
    x: Math.round(t / e),
    y: Math.round(n / e)
  };
}
function XA(r) {
  const e = [];
  let t = 0;
  for (; t < r.pointers.length; )
    e[t] = {
      clientX: Math.round(r.pointers[t].clientX),
      clientY: Math.round(r.pointers[t].clientY)
    }, t++;
  return {
    timeStamp: Date.now(),
    pointers: e,
    center: X5(e),
    deltaX: r.deltaX,
    deltaY: r.deltaY
  };
}
function Z5(r, e) {
  const t = e.x - r.x, n = e.y - r.y;
  return Math.sqrt(t * t + n * n);
}
function ZA(r, e) {
  const t = e.clientX - r.clientX, n = e.clientY - r.clientY;
  return Math.sqrt(t * t + n * n);
}
function nk(r, e) {
  const t = e.x - r.x, n = e.y - r.y;
  return Math.atan2(n, t) * 180 / Math.PI;
}
function YA(r, e) {
  const t = e.clientX - r.clientX, n = e.clientY - r.clientY;
  return Math.atan2(n, t) * 180 / Math.PI;
}
function Y5(r, e) {
  return r === e ? Ws.None : Math.abs(r) >= Math.abs(e) ? r < 0 ? Ws.Left : Ws.Right : e < 0 ? Ws.Up : Ws.Down;
}
function ik(r, e) {
  const t = e.center;
  let n = r.offsetDelta, i = r.prevDelta;
  const s = r.prevInput;
  return (e.eventType === Fs.Start || (s == null ? void 0 : s.eventType) === Fs.End) && (i = r.prevDelta = {
    x: (s == null ? void 0 : s.deltaX) || 0,
    y: (s == null ? void 0 : s.deltaY) || 0
  }, n = r.offsetDelta = {
    x: t.x,
    y: t.y
  }), {
    deltaX: i.x + (t.x - n.x),
    deltaY: i.y + (t.y - n.y)
  };
}
function K5(r, e, t) {
  return {
    x: e / r || 0,
    y: t / r || 0
  };
}
function sk(r, e) {
  return ZA(e[0], e[1]) / ZA(r[0], r[1]);
}
function ok(r, e) {
  return YA(e[1], e[0]) - YA(r[1], r[0]);
}
function ak(r, e) {
  const t = r.lastInterval || e, n = e.timeStamp - t.timeStamp;
  let i, s, l, o;
  if (e.eventType !== Fs.Cancel && (n > KD || t.velocity === void 0)) {
    const d = e.deltaX - t.deltaX, m = e.deltaY - t.deltaY, b = K5(n, d, m);
    s = b.x, l = b.y, i = Math.abs(b.x) > Math.abs(b.y) ? b.x : b.y, o = Y5(d, m), r.lastInterval = e;
  } else
    i = t.velocity, s = t.velocityX, l = t.velocityY, o = t.direction;
  e.velocity = i, e.velocityX = s, e.velocityY = l, e.direction = o;
}
function lk(r, e) {
  const {
    session: t
  } = r, {
    pointers: n
  } = e, {
    length: i
  } = n;
  t.firstInput || (t.firstInput = XA(e)), i > 1 && !t.firstMultiple ? t.firstMultiple = XA(e) : i === 1 && (t.firstMultiple = !1);
  const {
    firstInput: s,
    firstMultiple: l
  } = t, o = l ? l.center : s.center, d = e.center = X5(n);
  e.timeStamp = Date.now(), e.deltaTime = e.timeStamp - s.timeStamp, e.angle = nk(o, d), e.distance = Z5(o, d);
  const {
    deltaX: m,
    deltaY: b
  } = ik(t, e);
  e.deltaX = m, e.deltaY = b, e.offsetDirection = Y5(e.deltaX, e.deltaY);
  const T = K5(e.deltaTime, e.deltaX, e.deltaY);
  e.overallVelocityX = T.x, e.overallVelocityY = T.y, e.overallVelocity = Math.abs(T.x) > Math.abs(T.y) ? T.x : T.y, e.scale = l ? sk(l.pointers, n) : 1, e.rotation = l ? ok(l.pointers, n) : 0, e.maxPointers = t.prevInput ? e.pointers.length > t.prevInput.maxPointers ? e.pointers.length : t.prevInput.maxPointers : e.pointers.length;
  let M = r.element;
  return rk(e.srcEvent.target, M) && (M = e.srcEvent.target), e.target = M, ak(t, e), e;
}
function ck(r, e, t) {
  const n = t.pointers.length, i = t.changedPointers.length, s = e & Fs.Start && n - i === 0, l = e & (Fs.End | Fs.Cancel) && n - i === 0;
  t.isFirst = !!s, t.isFinal = !!l, s && (r.session = {}), t.eventType = e;
  const o = lk(r, t);
  r.emit("hammer.input", o), r.recognize(o), r.session.prevInput = o;
}
let uk = class {
  constructor(e) {
    this.evEl = "", this.evWin = "", this.evTarget = "", this.domHandler = (t) => {
      this.manager.options.enable && this.handler(t);
    }, this.manager = e, this.element = e.element, this.target = e.options.inputTarget || e.element;
  }
  callback(e, t) {
    ck(this.manager, e, t);
  }
  // eslint-disable @typescript-eslint/unbound-method
  /**
   * bind the events
   */
  init() {
    rb(this.element, this.evEl, this.domHandler), rb(this.target, this.evTarget, this.domHandler), rb(WA(this.element), this.evWin, this.domHandler);
  }
  /**
   * unbind the events
   */
  destroy() {
    nb(this.element, this.evEl, this.domHandler), nb(this.target, this.evTarget, this.domHandler), nb(WA(this.element), this.evWin, this.domHandler);
  }
};
const hk = {
  pointerdown: Fs.Start,
  pointermove: Fs.Move,
  pointerup: Fs.End,
  pointercancel: Fs.Cancel,
  pointerout: Fs.Cancel
}, fk = "pointerdown", dk = "pointermove pointerup pointercancel";
class pk extends uk {
  constructor(e) {
    super(e), this.evEl = fk, this.evWin = dk, this.store = this.manager.session.pointerEvents = [], this.init();
  }
  /**
   * handle mouse events
   */
  handler(e) {
    const {
      store: t
    } = this;
    let n = !1;
    const i = hk[e.type], s = e.pointerType, l = s === "touch";
    let o = t.findIndex((d) => d.pointerId === e.pointerId);
    i & Fs.Start && (e.buttons || l) ? o < 0 && (t.push(e), o = t.length - 1) : i & (Fs.End | Fs.Cancel) && (n = !0), !(o < 0) && (t[o] = e, this.callback(i, {
      pointers: t,
      changedPointers: [e],
      eventType: i,
      pointerType: s,
      srcEvent: e
    }), n && t.splice(o, 1));
  }
}
const gk = ["", "webkit", "Moz", "MS", "ms", "o"];
function mk(r, e) {
  const t = e[0].toUpperCase() + e.slice(1);
  for (const n of gk) {
    const i = n ? n + t : e;
    if (i in r)
      return i;
  }
}
const _k = 1, KA = 2, JA = {
  touchAction: "compute",
  enable: !0,
  inputTarget: null,
  cssProps: {
    /**
     * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
     */
    userSelect: "none",
    /**
     * (Webkit) Disable default dragging behavior
     */
    // @ts-ignore
    userDrag: "none",
    /**
     * (iOS only) Disables the default callout shown when you touch and hold a touch target.
     * When you touch and hold a touch target such as a link, Safari displays
     * a callout containing information about the link. This property allows you to disable that callout.
     */
    // @ts-ignore
    touchCallout: "none",
    /**
     * (iOS only) Sets the color of the highlight that appears over a link while it's being tapped.
     */
    // @ts-ignore
    tapHighlightColor: "rgba(0,0,0,0)"
  }
};
class yk {
  constructor(e, t) {
    this.options = {
      ...JA,
      ...t,
      cssProps: {
        ...JA.cssProps,
        ...t.cssProps
      },
      inputTarget: t.inputTarget || e
    }, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = new pk(this), this.touchAction = new tk(this, this.options.touchAction), this.toggleCssProps(!0);
  }
  /**
   * set options
   */
  set(e) {
    return Object.assign(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this;
  }
  /**
   * stop recognizing for this session.
   * This session will be discarded, when a new [input]start event is fired.
   * When forced, the recognizer cycle is stopped immediately.
   */
  stop(e) {
    this.session.stopped = e ? KA : _k;
  }
  /**
   * run the recognizers!
   * called by the inputHandler function on every movement of the pointers (touches)
   * it walks through all the recognizers and tries to detect the gesture that is being made
   */
  recognize(e) {
    const {
      session: t
    } = this;
    if (t.stopped)
      return;
    this.session.prevented && e.srcEvent.preventDefault();
    let n;
    const {
      recognizers: i
    } = this;
    let {
      curRecognizer: s
    } = t;
    (!s || s && s.state & fn.Recognized) && (s = t.curRecognizer = null);
    let l = 0;
    for (; l < i.length; )
      n = i[l], t.stopped !== KA && // 1
      (!s || n === s || // 2
      n.canRecognizeWith(s)) ? n.recognize(e) : n.reset(), !s && n.state & (fn.Began | fn.Changed | fn.Ended) && (s = t.curRecognizer = n), l++;
  }
  /**
   * get a recognizer by its event name.
   */
  get(e) {
    const {
      recognizers: t
    } = this;
    for (let n = 0; n < t.length; n++)
      if (t[n].options.event === e)
        return t[n];
    return null;
  }
  /**
   * add a recognizer to the manager
   * existing recognizers with the same event name will be removed
   */
  add(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.add(n);
      return this;
    }
    const t = this.get(e.options.event);
    return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e;
  }
  /**
   * remove a recognizer by name or instance
   */
  remove(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.remove(n);
      return this;
    }
    const t = typeof e == "string" ? this.get(e) : e;
    if (t) {
      const {
        recognizers: n
      } = this, i = n.indexOf(t);
      i !== -1 && (n.splice(i, 1), this.touchAction.update());
    }
    return this;
  }
  /**
   * bind event
   */
  on(e, t) {
    if (!e || !t)
      return;
    const {
      handlers: n
    } = this;
    for (const i of k_(e))
      n[i] = n[i] || [], n[i].push(t);
  }
  /**
   * unbind event, leave hander blank to remove all handlers
   */
  off(e, t) {
    if (!e)
      return;
    const {
      handlers: n
    } = this;
    for (const i of k_(e))
      t ? n[i] && n[i].splice(n[i].indexOf(t), 1) : delete n[i];
  }
  /**
   * emit event to the listeners
   */
  emit(e, t) {
    const n = this.handlers[e] && this.handlers[e].slice();
    if (!n || !n.length)
      return;
    const i = t;
    i.type = e, i.preventDefault = function() {
      t.srcEvent.preventDefault();
    };
    let s = 0;
    for (; s < n.length; )
      n[s](i), s++;
  }
  /**
   * destroy the manager and unbinds all events
   * it doesn't unbind dom events, that is the user own responsibility
   */
  destroy() {
    this.toggleCssProps(!1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
  }
  /**
   * add/remove the css properties as defined in manager.options.cssProps
   */
  toggleCssProps(e) {
    const {
      element: t
    } = this;
    if (t) {
      for (const [n, i] of Object.entries(this.options.cssProps)) {
        const s = mk(t.style, n);
        e ? (this.oldCssProps[s] = t.style[s], t.style[s] = i) : t.style[s] = this.oldCssProps[s] || "";
      }
      e || (this.oldCssProps = {});
    }
  }
}
let bk = 1;
function vk() {
  return bk++;
}
function QA(r) {
  return r & fn.Cancelled ? "cancel" : r & fn.Ended ? "end" : r & fn.Changed ? "move" : r & fn.Began ? "start" : "";
}
class J5 {
  constructor(e) {
    this.options = e, this.id = vk(), this.state = fn.Possible, this.simultaneous = {}, this.requireFail = [];
  }
  /**
   * set options
   */
  set(e) {
    return Object.assign(this.options, e), this.manager.touchAction.update(), this;
  }
  /**
   * recognize simultaneous with an other recognizer.
   */
  recognizeWith(e) {
    if (Array.isArray(e)) {
      for (const i of e)
        this.recognizeWith(i);
      return this;
    }
    let t;
    if (typeof e == "string") {
      if (t = this.manager.get(e), !t)
        throw new Error(`Cannot find recognizer ${e}`);
    } else
      t = e;
    const {
      simultaneous: n
    } = this;
    return n[t.id] || (n[t.id] = t, t.recognizeWith(this)), this;
  }
  /**
   * drop the simultaneous link. it doesnt remove the link on the other recognizer.
   */
  dropRecognizeWith(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.dropRecognizeWith(n);
      return this;
    }
    let t;
    return typeof e == "string" ? t = this.manager.get(e) : t = e, t && delete this.simultaneous[t.id], this;
  }
  /**
   * recognizer can only run when an other is failing
   */
  requireFailure(e) {
    if (Array.isArray(e)) {
      for (const i of e)
        this.requireFailure(i);
      return this;
    }
    let t;
    if (typeof e == "string") {
      if (t = this.manager.get(e), !t)
        throw new Error(`Cannot find recognizer ${e}`);
    } else
      t = e;
    const {
      requireFail: n
    } = this;
    return n.indexOf(t) === -1 && (n.push(t), t.requireFailure(this)), this;
  }
  /**
   * drop the requireFailure link. it does not remove the link on the other recognizer.
   */
  dropRequireFailure(e) {
    if (Array.isArray(e)) {
      for (const n of e)
        this.dropRequireFailure(n);
      return this;
    }
    let t;
    if (typeof e == "string" ? t = this.manager.get(e) : t = e, t) {
      const n = this.requireFail.indexOf(t);
      n > -1 && this.requireFail.splice(n, 1);
    }
    return this;
  }
  /**
   * has require failures boolean
   */
  hasRequireFailures() {
    return !!this.requireFail.find((e) => e.options.enable);
  }
  /**
   * if the recognizer can recognize simultaneous with an other recognizer
   */
  canRecognizeWith(e) {
    return !!this.simultaneous[e.id];
  }
  /**
   * You should use `tryEmit` instead of `emit` directly to check
   * that all the needed recognizers has failed before emitting.
   */
  emit(e) {
    if (!e) return;
    const {
      state: t
    } = this;
    t < fn.Ended && this.manager.emit(this.options.event + QA(t), e), this.manager.emit(this.options.event, e), e.additionalEvent && this.manager.emit(e.additionalEvent, e), t >= fn.Ended && this.manager.emit(this.options.event + QA(t), e);
  }
  /**
   * Check that all the require failure recognizers has failed,
   * if true, it emits a gesture event,
   * otherwise, setup the state to FAILED.
   */
  tryEmit(e) {
    this.canEmit() ? this.emit(e) : this.state = fn.Failed;
  }
  /**
   * can we emit?
   */
  canEmit() {
    let e = 0;
    for (; e < this.requireFail.length; ) {
      if (!(this.requireFail[e].state & (fn.Failed | fn.Possible)))
        return !1;
      e++;
    }
    return !0;
  }
  /**
   * update the recognizer
   */
  recognize(e) {
    const t = {
      ...e
    };
    if (!this.options.enable) {
      this.reset(), this.state = fn.Failed;
      return;
    }
    this.state & (fn.Recognized | fn.Cancelled | fn.Failed) && (this.state = fn.Possible), this.state = this.process(t), this.state & (fn.Began | fn.Changed | fn.Ended | fn.Cancelled) && this.tryEmit(t);
  }
  /**
   * return the event names that are emitted by this recognizer
   */
  getEventNames() {
    return [this.options.event];
  }
  /**
   * called when the gesture isn't allowed to recognize
   * like when another is being recognized or it is disabled
   */
  reset() {
  }
}
class Q5 extends J5 {
  /**
   * Used to check if it the recognizer receives valid input, like input.distance > 10.
   */
  attrTest(e) {
    const t = this.options.pointers;
    return t === 0 || e.pointers.length === t;
  }
  /**
   * Process the input and return the state for the recognizer
   */
  process(e) {
    const {
      state: t
    } = this, {
      eventType: n
    } = e, i = t & (fn.Began | fn.Changed), s = this.attrTest(e);
    return i && (n & Fs.Cancel || !s) ? t | fn.Cancelled : i || s ? n & Fs.End ? t | fn.Ended : t & fn.Began ? t | fn.Changed : fn.Began : fn.Failed;
  }
}
class eT extends J5 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super({
      enable: !0,
      event: "tap",
      pointers: 1,
      taps: 1,
      interval: 300,
      time: 250,
      threshold: 9,
      posThreshold: 10,
      ...e
    }), this.pTime = null, this.pCenter = null, this._timer = null, this._input = null, this.count = 0;
  }
  getTouchAction() {
    return [D1];
  }
  process(e) {
    const {
      options: t
    } = this, n = e.pointers.length === t.pointers, i = e.distance < t.threshold, s = e.deltaTime < t.time;
    if (this.reset(), e.eventType & Fs.Start && this.count === 0)
      return this.failTimeout();
    if (i && s && n) {
      if (e.eventType !== Fs.End)
        return this.failTimeout();
      const l = this.pTime ? e.timeStamp - this.pTime < t.interval : !0, o = !this.pCenter || Z5(this.pCenter, e.center) < t.posThreshold;
      if (this.pTime = e.timeStamp, this.pCenter = e.center, !o || !l ? this.count = 1 : this.count += 1, this._input = e, this.count % t.taps === 0)
        return this.hasRequireFailures() ? (this._timer = setTimeout(() => {
          this.state = fn.Recognized, this.tryEmit(this._input);
        }, t.interval), fn.Began) : fn.Recognized;
    }
    return fn.Failed;
  }
  failTimeout() {
    return this._timer = setTimeout(() => {
      this.state = fn.Failed;
    }, this.options.interval), fn.Failed;
  }
  reset() {
    clearTimeout(this._timer);
  }
  emit(e) {
    this.state === fn.Recognized && (e.tapCount = this.count, this.manager.emit(this.options.event, e));
  }
}
const xk = ["", "start", "move", "end", "cancel", "up", "down", "left", "right"];
class tT extends Q5 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super({
      enable: !0,
      pointers: 1,
      event: "pan",
      threshold: 10,
      direction: Ws.All,
      ...e
    }), this.pX = null, this.pY = null;
  }
  getTouchAction() {
    const {
      options: {
        direction: e
      }
    } = this, t = [];
    return e & Ws.Horizontal && t.push(F1), e & Ws.Vertical && t.push(k1), t;
  }
  getEventNames() {
    return xk.map((e) => this.options.event + e);
  }
  directionTest(e) {
    const {
      options: t
    } = this;
    let n = !0, {
      distance: i
    } = e, {
      direction: s
    } = e;
    const l = e.deltaX, o = e.deltaY;
    return s & t.direction || (t.direction & Ws.Horizontal ? (s = l === 0 ? Ws.None : l < 0 ? Ws.Left : Ws.Right, n = l !== this.pX, i = Math.abs(e.deltaX)) : (s = o === 0 ? Ws.None : o < 0 ? Ws.Up : Ws.Down, n = o !== this.pY, i = Math.abs(e.deltaY))), e.direction = s, n && i > t.threshold && !!(s & t.direction);
  }
  attrTest(e) {
    return super.attrTest(e) && (!!(this.state & fn.Began) || !(this.state & fn.Began) && this.directionTest(e));
  }
  emit(e) {
    this.pX = e.deltaX, this.pY = e.deltaY;
    const t = Ws[e.direction].toLowerCase();
    t && (e.additionalEvent = this.options.event + t), super.emit(e);
  }
}
const wk = ["", "start", "move", "end", "cancel", "in", "out"];
class Ak extends Q5 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super({
      enable: !0,
      event: "pinch",
      threshold: 0,
      pointers: 2,
      ...e
    });
  }
  getTouchAction() {
    return [Ym];
  }
  getEventNames() {
    return wk.map((e) => this.options.event + e);
  }
  attrTest(e) {
    return super.attrTest(e) && (Math.abs(e.scale - 1) > this.options.threshold || !!(this.state & fn.Began));
  }
  emit(e) {
    if (e.scale !== 1) {
      const t = e.scale < 1 ? "in" : "out";
      e.additionalEvent = this.options.event + t;
    }
    super.emit(e);
  }
}
class xy {
  constructor(e, t, n) {
    this.element = e, this.callback = t, this.options = n;
  }
}
const Tk = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", Sk = Tk.indexOf("firefox") !== -1, rT = 4.000244140625, Ek = 40, Ck = 0.25;
class Ik extends xy {
  constructor(e, t, n) {
    super(e, t, {
      enable: !0,
      ...n
    }), this.handleEvent = (i) => {
      if (!this.options.enable)
        return;
      let s = i.deltaY;
      globalThis.WheelEvent && (Sk && i.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL && (s /= globalThis.devicePixelRatio), i.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE && (s *= Ek)), s !== 0 && s % rT === 0 && (s = Math.floor(s / rT)), i.shiftKey && s && (s = s * Ck), this.callback({
        type: "wheel",
        center: {
          x: i.clientX,
          y: i.clientY
        },
        delta: -s,
        srcEvent: i,
        pointerType: "mouse",
        target: i.target
      });
    }, e.addEventListener("wheel", this.handleEvent, {
      passive: !1
    });
  }
  destroy() {
    this.element.removeEventListener("wheel", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "wheel" && (this.options.enable = t);
  }
}
const nT = ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"];
class Mk extends xy {
  constructor(e, t, n) {
    super(e, t, {
      enable: !0,
      ...n
    }), this.handleEvent = (s) => {
      this.handleOverEvent(s), this.handleOutEvent(s), this.handleEnterEvent(s), this.handleLeaveEvent(s), this.handleMoveEvent(s);
    }, this.pressed = !1;
    const {
      enable: i
    } = this.options;
    this.enableMoveEvent = i, this.enableLeaveEvent = i, this.enableEnterEvent = i, this.enableOutEvent = i, this.enableOverEvent = i, nT.forEach((s) => e.addEventListener(s, this.handleEvent));
  }
  destroy() {
    nT.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    switch (e) {
      case "pointermove":
        this.enableMoveEvent = t;
        break;
      case "pointerover":
        this.enableOverEvent = t;
        break;
      case "pointerout":
        this.enableOutEvent = t;
        break;
      case "pointerenter":
        this.enableEnterEvent = t;
        break;
      case "pointerleave":
        this.enableLeaveEvent = t;
        break;
    }
  }
  handleOverEvent(e) {
    this.enableOverEvent && e.type === "mouseover" && this._emit("pointerover", e);
  }
  handleOutEvent(e) {
    this.enableOutEvent && e.type === "mouseout" && this._emit("pointerout", e);
  }
  handleEnterEvent(e) {
    this.enableEnterEvent && e.type === "mouseenter" && this._emit("pointerenter", e);
  }
  handleLeaveEvent(e) {
    this.enableLeaveEvent && e.type === "mouseleave" && this._emit("pointerleave", e);
  }
  handleMoveEvent(e) {
    if (this.enableMoveEvent)
      switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          e.buttons === 0 && (this.pressed = !1), this.pressed || this._emit("pointermove", e);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(e, t) {
    this.callback({
      type: e,
      center: {
        x: t.clientX,
        y: t.clientY
      },
      srcEvent: t,
      pointerType: "mouse",
      target: t.target
    });
  }
}
const iT = ["keydown", "keyup"];
class Pk extends xy {
  constructor(e, t, n) {
    super(e, t, {
      enable: !0,
      tabIndex: 0,
      ...n
    }), this.handleEvent = (i) => {
      const s = i.target || i.srcElement;
      s.tagName === "INPUT" && s.type === "text" || s.tagName === "TEXTAREA" || (this.enableDownEvent && i.type === "keydown" && this.callback({
        type: "keydown",
        srcEvent: i,
        key: i.key,
        target: i.target
      }), this.enableUpEvent && i.type === "keyup" && this.callback({
        type: "keyup",
        srcEvent: i,
        key: i.key,
        target: i.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, e.tabIndex = this.options.tabIndex, e.style.outline = "none", iT.forEach((i) => e.addEventListener(i, this.handleEvent));
  }
  destroy() {
    iT.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "keydown" && (this.enableDownEvent = t), e === "keyup" && (this.enableUpEvent = t);
  }
}
class Rk extends xy {
  constructor(e, t, n) {
    super(e, t, n), this.handleEvent = (i) => {
      this.options.enable && this.callback({
        type: "contextmenu",
        center: {
          x: i.clientX,
          y: i.clientY
        },
        srcEvent: i,
        pointerType: "mouse",
        target: i.target
      });
    }, e.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === "contextmenu" && (this.options.enable = t);
  }
}
const sT = 1, U1 = 2, oT = 4, Bk = {
  pointerdown: sT,
  pointermove: U1,
  pointerup: oT,
  mousedown: sT,
  mousemove: U1,
  mouseup: oT
}, Lk = 0, Ok = 1, Nk = 2, Dk = 1, kk = 2, Fk = 4;
function Uk(r) {
  const e = Bk[r.srcEvent.type];
  if (!e)
    return null;
  const {
    buttons: t,
    button: n
  } = r.srcEvent;
  let i = !1, s = !1, l = !1;
  return e === U1 ? (i = !!(t & Dk), s = !!(t & Fk), l = !!(t & kk)) : (i = n === Lk, s = n === Ok, l = n === Nk), {
    leftButton: i,
    middleButton: s,
    rightButton: l
  };
}
function zk(r, e) {
  const t = r.center;
  if (!t)
    return null;
  const n = e.getBoundingClientRect(), i = n.width / e.offsetWidth || 1, s = n.height / e.offsetHeight || 1, l = {
    x: (t.x - n.left - e.clientLeft) / i,
    y: (t.y - n.top - e.clientTop) / s
  };
  return {
    center: t,
    offsetCenter: l
  };
}
const jk = {
  srcElement: "root",
  priority: 0
};
class Vk {
  constructor(e, t) {
    this.handleEvent = (n) => {
      if (this.isEmpty())
        return;
      const i = this._normalizeEvent(n);
      let s = n.srcEvent.target;
      for (; s && s !== i.rootElement; ) {
        if (this._emit(i, s), i.handled)
          return;
        s = s.parentNode;
      }
      this._emit(i, "root");
    }, this.eventManager = e, this.recognizerName = t, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    const {
      handlers: l,
      handlersByElement: o
    } = this, d = {
      ...jk,
      ...n
    };
    let m = o.get(d.srcElement);
    m || (m = [], o.set(d.srcElement, m));
    const b = {
      type: e,
      handler: t,
      srcElement: d.srcElement,
      priority: d.priority
    };
    i && (b.once = !0), s && (b.passive = !0), l.push(b), this._active = this._active || !b.passive;
    let T = m.length - 1;
    for (; T >= 0 && !(m[T].priority >= b.priority); )
      T--;
    m.splice(T + 1, 0, b);
  }
  remove(e, t) {
    const {
      handlers: n,
      handlersByElement: i
    } = this;
    for (let s = n.length - 1; s >= 0; s--) {
      const l = n[s];
      if (l.type === e && l.handler === t) {
        n.splice(s, 1);
        const o = i.get(l.srcElement);
        o.splice(o.indexOf(l), 1), o.length === 0 && i.delete(l.srcElement);
      }
    }
    this._active = n.some((s) => !s.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(e, t) {
    const n = this.handlersByElement.get(t);
    if (n) {
      let i = !1;
      const s = () => {
        e.handled = !0;
      }, l = () => {
        e.handled = !0, i = !0;
      }, o = [];
      for (let d = 0; d < n.length; d++) {
        const {
          type: m,
          handler: b,
          once: T
        } = n[d];
        if (b({
          ...e,
          type: m,
          stopPropagation: s,
          stopImmediatePropagation: l
        }), T && o.push(n[d]), i)
          break;
      }
      for (let d = 0; d < o.length; d++) {
        const {
          type: m,
          handler: b
        } = o[d];
        this.remove(m, b);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(e) {
    const t = this.eventManager.getElement();
    return {
      ...e,
      ...Uk(e),
      ...zk(e, t),
      preventDefault: () => {
        e.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: t
    };
  }
}
function qk(r) {
  if ("recognizer" in r)
    return r;
  let e;
  const t = Array.isArray(r) ? [...r] : [r];
  if (typeof t[0] == "function") {
    const n = t.shift(), i = t.shift() || {};
    e = new n(i);
  } else
    e = t.shift();
  return {
    recognizer: e,
    recognizeWith: typeof t[0] == "string" ? [t[0]] : t[0],
    requireFailure: typeof t[1] == "string" ? [t[1]] : t[1]
  };
}
class Gk {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this._onBasicInput = (n) => {
      this.manager.emit(n.srcEvent.type, n);
    }, this._onOtherEvent = (n) => {
      this.manager.emit(n.type, n);
    }, this.options = {
      recognizers: [],
      events: {},
      touchAction: "compute",
      tabIndex: 0,
      cssProps: {},
      ...t
    }, this.events = /* @__PURE__ */ new Map(), this.element = e, !!e) {
      this.manager = new yk(e, this.options);
      for (const n of this.options.recognizers) {
        const {
          recognizer: i,
          recognizeWith: s,
          requireFailure: l
        } = qk(n);
        this.manager.add(i), s && i.recognizeWith(s), l && i.requireFailure(l);
      }
      this.manager.on("hammer.input", this._onBasicInput), this.wheelInput = new Ik(e, this._onOtherEvent, {
        enable: !1
      }), this.moveInput = new Mk(e, this._onOtherEvent, {
        enable: !1
      }), this.keyInput = new Pk(e, this._onOtherEvent, {
        enable: !1,
        tabIndex: t.tabIndex
      }), this.contextmenuInput = new Rk(e, this._onOtherEvent, {
        enable: !1
      }), this.on(this.options.events);
    }
  }
  getElement() {
    return this.element;
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy());
  }
  /** Register an event handler function to be called on `event` */
  on(e, t, n) {
    this._addEventHandler(e, t, n, !1);
  }
  once(e, t, n) {
    this._addEventHandler(e, t, n, !0);
  }
  watch(e, t, n) {
    this._addEventHandler(e, t, n, !1, !0);
  }
  off(e, t) {
    this._removeEventHandler(e, t);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(e, t) {
    var s, l, o, d;
    const {
      manager: n
    } = this;
    if (!n)
      return;
    const i = n.get(e);
    i && (i.set({
      enable: t
    }), n.touchAction.update()), (s = this.wheelInput) == null || s.enableEventType(e, t), (l = this.moveInput) == null || l.enableEventType(e, t), (o = this.keyInput) == null || o.enableEventType(e, t), (d = this.contextmenuInput) == null || d.enableEventType(e, t);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(e, t, n, i, s) {
    if (typeof e != "string") {
      n = t;
      for (const [m, b] of Object.entries(e))
        this._addEventHandler(m, b, n, i, s);
      return;
    }
    const {
      manager: l,
      events: o
    } = this;
    if (!l) return;
    let d = o.get(e);
    if (!d) {
      const m = this._getRecognizerName(e) || e;
      d = new Vk(this, m), o.set(e, d), l && l.on(e, d.handleEvent);
    }
    d.add(e, t, n, i, s), d.isEmpty() || this._toggleRecognizer(d.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(e, t) {
    if (typeof e != "string") {
      for (const [s, l] of Object.entries(e))
        this._removeEventHandler(s, l);
      return;
    }
    const {
      events: n
    } = this, i = n.get(e);
    if (i && (i.remove(e, t), i.isEmpty())) {
      const {
        recognizerName: s
      } = i;
      let l = !1;
      for (const o of n.values())
        if (o.recognizerName === s && !o.isEmpty()) {
          l = !0;
          break;
        }
      l || this._toggleRecognizer(s, !1);
    }
  }
  _getRecognizerName(e) {
    var t;
    return (t = this.manager.recognizers.find((n) => n.getEventNames().includes(e))) == null ? void 0 : t.options.event;
  }
}
const Rn = {
  /**
   * `LNGLAT` if rendering into a geospatial viewport, `CARTESIAN` otherwise
   */
  DEFAULT: -1,
  /**
   * Positions are interpreted as [longitude, latitude, elevation]
   * longitude/latitude are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT: 1,
  /**
   * Positions are interpreted as [x, y, z] in meter offsets from the coordinate origin.
   * Dimensions are in meters.
   */
  METER_OFFSETS: 2,
  /**
   * Positions are interpreted as [deltaLng, deltaLat, elevation] from the coordinate origin.
   * deltaLng/deltaLat are in degrees, elevation is in meters.
   * Dimensions are in meters.
   */
  LNGLAT_OFFSETS: 3,
  /**
   * Positions and dimensions are in the common units of the viewport.
   */
  CARTESIAN: 0
};
Object.defineProperty(Rn, "IDENTITY", {
  get: () => (qn.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
});
const wc = {
  /**
   * Render geospatial data in Web Mercator projection
   */
  WEB_MERCATOR: 1,
  /**
   * Render geospatial data as a 3D globe
   */
  GLOBE: 2,
  /**
   * (Internal use only) Web Mercator projection at high zoom
   */
  WEB_MERCATOR_AUTO_OFFSET: 4,
  /**
   * No transformation
   */
  IDENTITY: 0
}, z1 = {
  common: 0,
  meters: 1,
  pixels: 2
}, j1 = {
  click: "onClick",
  panstart: "onDragStart",
  panmove: "onDrag",
  panend: "onDragEnd"
}, aT = {
  multipan: [tT, {
    threshold: 10,
    direction: Ws.Vertical,
    pointers: 2
  }],
  pinch: [Ak, {}, null, ["multipan"]],
  pan: [tT, {
    threshold: 1
  }, ["pinch"], ["multipan"]],
  dblclick: [eT, {
    event: "dblclick",
    taps: 2
  }],
  click: [eT, {
    event: "click"
  }, null, ["dblclick"]]
}, $k = Object.keys(Rn).map((r) => `const int COORDINATE_SYSTEM_${r} = ${Rn[r]};`).join(""), Hk = Object.keys(wc).map((r) => `const int PROJECTION_MODE_${r} = ${wc[r]};`).join(""), Wk = Object.keys(z1).map((r) => `const int UNIT_${r.toUpperCase()} = ${z1[r]};`).join(""), Xk = `${$k}
${Hk}
${Wk}
uniform projectUniforms {
bool wrapLongitude;
int coordinateSystem;
vec3 commonUnitsPerMeter;
int projectionMode;
float scale;
vec3 commonUnitsPerWorldUnit;
vec3 commonUnitsPerWorldUnit2;
vec4 center;
mat4 modelMatrix;
mat4 viewProjectionMatrix;
vec2 viewportSize;
float devicePixelRatio;
float focalDistance;
vec3 cameraPosition;
vec3 coordinateOrigin;
vec3 commonOrigin;
bool pseudoMeters;
} project;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project.pseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project.commonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project.commonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project.commonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project.wrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project.modelMatrix * position;
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project.coordinateOrigin;
}
}
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project.commonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project.coordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
return offset * project.focalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project.scale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project.scale;
}
`;
function Zk(r, e) {
  if (r === e)
    return !0;
  if (Array.isArray(r)) {
    const t = r.length;
    if (!e || e.length !== t)
      return !1;
    for (let n = 0; n < t; n++)
      if (r[n] !== e[n])
        return !1;
    return !0;
  }
  return !1;
}
function Pg(r) {
  let e = {}, t;
  return (n) => {
    for (const i in n)
      if (!Zk(n[i], e[i])) {
        t = r(n), e = n;
        break;
      }
    return t;
  };
}
const lT = [0, 0, 0, 0], Yk = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], eC = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], Kk = [0, 0, 0], tC = [0, 0, 0], Jk = Pg(tF);
function rC(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : tC;
  t.length < 3 && (t = [t[0], t[1], 0]);
  let n = t, i, s = !0;
  switch (e === Rn.LNGLAT_OFFSETS || e === Rn.METER_OFFSETS ? i = t : i = r.isGeospatial ? (
    // @ts-expect-error longitude and latitude are not defined on the base Viewport, but is expected on geospatial viewports
    [Math.fround(r.longitude), Math.fround(r.latitude), 0]
  ) : null, r.projectionMode) {
    case wc.WEB_MERCATOR:
      (e === Rn.LNGLAT || e === Rn.CARTESIAN) && (i = [0, 0, 0], s = !1);
      break;
    case wc.WEB_MERCATOR_AUTO_OFFSET:
      e === Rn.LNGLAT ? n = i : e === Rn.CARTESIAN && (n = [Math.fround(r.center[0]), Math.fround(r.center[1]), 0], i = r.unprojectPosition(n), n[0] -= t[0], n[1] -= t[1], n[2] -= t[2]);
      break;
    case wc.IDENTITY:
      n = r.position.map(Math.fround), n[2] = n[2] || 0;
      break;
    case wc.GLOBE:
      s = !1, i = null;
      break;
    default:
      s = !1;
  }
  return {
    geospatialOrigin: i,
    shaderCoordinateOrigin: n,
    offsetMode: s
  };
}
function Qk(r, e, t) {
  const {
    viewMatrixUncentered: n,
    projectionMatrix: i
  } = r;
  let {
    viewMatrix: s,
    viewProjectionMatrix: l
  } = r, o = lT, d = lT, m = r.cameraPosition;
  const {
    geospatialOrigin: b,
    shaderCoordinateOrigin: T,
    offsetMode: M
  } = rC(r, e, t);
  return M && (d = r.projectPosition(b || T), m = [m[0] - d[0], m[1] - d[1], m[2] - d[2]], d[3] = 1, o = Jd([], d, l), s = n || s, l = bf([], i, s), l = bf([], l, Yk)), {
    viewMatrix: s,
    viewProjectionMatrix: l,
    projectionCenter: o,
    originCommon: d,
    cameraPosCommon: m,
    shaderCoordinateOrigin: T,
    geospatialOrigin: b
  };
}
function eF(r) {
  let {
    viewport: e,
    devicePixelRatio: t = 1,
    modelMatrix: n = null,
    // Match Layer.defaultProps
    coordinateSystem: i = Rn.DEFAULT,
    coordinateOrigin: s = tC,
    autoWrapLongitude: l = !1
  } = r;
  i === Rn.DEFAULT && (i = e.isGeospatial ? Rn.LNGLAT : Rn.CARTESIAN);
  const o = Jk({
    viewport: e,
    devicePixelRatio: t,
    coordinateSystem: i,
    coordinateOrigin: s
  });
  return o.wrapLongitude = l, o.modelMatrix = n || eC, o;
}
function tF(r) {
  let {
    viewport: e,
    devicePixelRatio: t,
    coordinateSystem: n,
    coordinateOrigin: i
  } = r;
  const {
    projectionCenter: s,
    viewProjectionMatrix: l,
    originCommon: o,
    cameraPosCommon: d,
    shaderCoordinateOrigin: m,
    geospatialOrigin: b
  } = Qk(e, n, i), T = e.getDistanceScales(), M = [e.width * t, e.height * t], E = Jd([], [0, 0, -e.focalDistance, 1], e.projectionMatrix)[3] || 1, D = {
    // Projection mode values
    coordinateSystem: n,
    projectionMode: e.projectionMode,
    coordinateOrigin: m,
    commonOrigin: o.slice(0, 3),
    center: s,
    // Backward compatibility
    // TODO: remove in v9
    // @ts-expect-error _pseudoMeters is only defined on WebMercator viewport
    pseudoMeters: !!e._pseudoMeters,
    // Screen size
    viewportSize: M,
    devicePixelRatio: t,
    focalDistance: E,
    commonUnitsPerMeter: T.unitsPerMeter,
    commonUnitsPerWorldUnit: T.unitsPerMeter,
    commonUnitsPerWorldUnit2: Kk,
    scale: e.scale,
    // This is the mercator scale (2 ** zoom)
    wrapLongitude: !1,
    viewProjectionMatrix: l,
    modelMatrix: eC,
    // This is for lighting calculations
    cameraPosition: d
  };
  if (b) {
    const U = e.getDistanceScales(b);
    switch (n) {
      case Rn.METER_OFFSETS:
        D.commonUnitsPerWorldUnit = U.unitsPerMeter, D.commonUnitsPerWorldUnit2 = U.unitsPerMeter2;
        break;
      case Rn.LNGLAT:
      case Rn.LNGLAT_OFFSETS:
        e._pseudoMeters || (D.commonUnitsPerMeter = U.unitsPerMeter), D.commonUnitsPerWorldUnit = U.unitsPerDegree, D.commonUnitsPerWorldUnit2 = U.unitsPerDegree2;
        break;
      // a.k.a "preprojected" positions
      case Rn.CARTESIAN:
        D.commonUnitsPerWorldUnit = [1, 1, U.unitsPerMeter[2]], D.commonUnitsPerWorldUnit2 = [0, 0, U.unitsPerMeter2[2]];
        break;
    }
  }
  return D;
}
const rF = {};
function nF() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : rF;
  return "viewport" in r ? eF(r) : {};
}
const y2 = {
  name: "project",
  dependencies: [RD, W5],
  vs: Xk,
  getUniforms: nF,
  uniformTypes: {
    wrapLongitude: "f32",
    coordinateSystem: "i32",
    commonUnitsPerMeter: "vec3<f32>",
    projectionMode: "i32",
    scale: "f32",
    commonUnitsPerWorldUnit: "vec3<f32>",
    commonUnitsPerWorldUnit2: "vec3<f32>",
    center: "vec4<f32>",
    modelMatrix: "mat4x4<f32>",
    viewProjectionMatrix: "mat4x4<f32>",
    viewportSize: "vec2<f32>",
    devicePixelRatio: "f32",
    focalDistance: "f32",
    cameraPosition: "vec3<f32>",
    coordinateOrigin: "vec3<f32>",
    commonOrigin: "vec3<f32>",
    pseudoMeters: "f32"
  }
  // @ts-ignore TODO v9.1
}, iF = `
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`, b2 = {
  name: "project32",
  dependencies: [y2],
  vs: iF
};
function sF() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function Cd(r, e) {
  const t = Jd([], e, r);
  return m2(t, t, 1 / t[3]), t;
}
function cT(r, e) {
  const t = r % e;
  return t < 0 ? e + t : t;
}
function V1(r, e, t) {
  return r < e ? e : r > t ? t : r;
}
function oF(r) {
  return Math.log(r) * Math.LOG2E;
}
const v2 = Math.log2 || oF;
function zu(r, e) {
  if (!r)
    throw new Error(e || "@math.gl/web-mercator: assertion failed.");
}
const Ac = Math.PI, nC = Ac / 4, Il = Ac / 180, q1 = 180 / Ac, Ud = 512, F_ = 4003e4, U_ = 85.051129, aF = 1.5;
function lF(r) {
  return v2(r);
}
function pg(r) {
  const [e, t] = r;
  zu(Number.isFinite(e)), zu(Number.isFinite(t) && t >= -90 && t <= 90, "invalid latitude");
  const n = e * Il, i = t * Il, s = Ud * (n + Ac) / (2 * Ac), l = Ud * (Ac + Math.log(Math.tan(nC + i * 0.5))) / (2 * Ac);
  return [s, l];
}
function zd(r) {
  const [e, t] = r, n = e / Ud * (2 * Ac) - Ac, i = 2 * (Math.atan(Math.exp(t / Ud * (2 * Ac) - Ac)) - nC);
  return [n * q1, i * q1];
}
function cF(r) {
  const {
    latitude: e
  } = r;
  zu(Number.isFinite(e));
  const t = Math.cos(e * Il);
  return lF(F_ * t) - 9;
}
function Km(r) {
  const e = Math.cos(r * Il);
  return Ud / F_ / e;
}
function G1(r) {
  const {
    latitude: e,
    longitude: t,
    highPrecision: n = !1
  } = r;
  zu(Number.isFinite(e) && Number.isFinite(t));
  const i = Ud, s = Math.cos(e * Il), l = i / 360, o = l / s, d = i / F_ / s, m = {
    unitsPerMeter: [d, d, d],
    metersPerUnit: [1 / d, 1 / d, 1 / d],
    unitsPerDegree: [l, o, d],
    degreesPerUnit: [1 / l, 1 / o, 1 / d]
  };
  if (n) {
    const b = Il * Math.tan(e * Il) / s, T = l * b / 2, M = i / F_ * b, E = M / o * d;
    m.unitsPerDegree2 = [0, T, M], m.unitsPerMeter2 = [E, 0, E];
  }
  return m;
}
function iC(r, e) {
  const [t, n, i] = r, [s, l, o] = e, {
    unitsPerMeter: d,
    unitsPerMeter2: m
  } = G1({
    longitude: t,
    latitude: n,
    highPrecision: !0
  }), b = pg(r);
  b[0] += s * (d[0] + m[0] * l), b[1] += l * (d[1] + m[1] * l);
  const T = zd(b), M = (i || 0) + (o || 0);
  return Number.isFinite(i) || Number.isFinite(o) ? [T[0], T[1], M] : T;
}
function uF(r) {
  const {
    // Viewport props
    height: e,
    pitch: t,
    bearing: n,
    altitude: i,
    // Pre-calculated parameters
    scale: s,
    center: l
  } = r, o = sF();
  D_(o, o, [0, 0, -i]), O5(o, o, -t * Il), N5(o, o, n * Il);
  const d = s / e;
  return g2(o, o, [d, d, d]), l && D_(o, o, vN([], l)), o;
}
function hF(r) {
  const {
    width: e,
    height: t,
    altitude: n,
    pitch: i = 0,
    offset: s,
    center: l,
    scale: o,
    nearZMultiplier: d = 1,
    farZMultiplier: m = 1
  } = r;
  let {
    fovy: b = gg(aF)
  } = r;
  n !== void 0 && (b = gg(n));
  const T = b * Il, M = i * Il, E = x2(b);
  let D = E;
  l && (D += l[2] * o / Math.cos(M) / t);
  const U = T * (0.5 + (s ? s[1] : 0) / t), q = Math.sin(U) * D / Math.sin(V1(Math.PI / 2 - M - U, 0.01, Math.PI - 0.01)), G = Math.sin(M) * q + D, Y = D * 10, he = Math.min(G * m, Y);
  return {
    fov: T,
    aspect: e / t,
    focalDistance: E,
    near: d,
    far: he
  };
}
function gg(r) {
  return 2 * Math.atan(0.5 / r) * q1;
}
function x2(r) {
  return 0.5 / Math.tan(0.5 * r * Il);
}
function sC(r, e) {
  const [t, n, i = 0] = r;
  return zu(Number.isFinite(t) && Number.isFinite(n) && Number.isFinite(i)), Cd(e, [t, n, i, 1]);
}
function w2(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const [n, i, s] = r;
  if (zu(Number.isFinite(n) && Number.isFinite(i), "invalid pixel coordinate"), Number.isFinite(s))
    return Cd(e, [n, i, s, 1]);
  const l = Cd(e, [n, i, 0, 1]), o = Cd(e, [n, i, 1, 1]), d = l[2], m = o[2], b = d === m ? 0 : ((t || 0) - d) / (m - d);
  return x5([], l, o, b);
}
function fF(r) {
  const {
    width: e,
    height: t,
    bounds: n,
    minExtent: i = 0,
    // 0.01 would be about 1000 meters (degree is ~110KM)
    maxZoom: s = 24,
    // ~x4,000,000 => About 10 meter extents
    offset: l = [0, 0]
  } = r, [[o, d], [m, b]] = n, T = dF(r.padding), M = pg([o, V1(b, -85.051129, U_)]), E = pg([m, V1(d, -85.051129, U_)]), D = [Math.max(Math.abs(E[0] - M[0]), i), Math.max(Math.abs(E[1] - M[1]), i)], U = [e - T.left - T.right - Math.abs(l[0]) * 2, t - T.top - T.bottom - Math.abs(l[1]) * 2];
  zu(U[0] > 0 && U[1] > 0);
  const q = U[0] / D[0], G = U[1] / D[1], Y = (T.right - T.left) / 2 / q, he = (T.top - T.bottom) / 2 / G, X = [(E[0] + M[0]) / 2 + Y, (E[1] + M[1]) / 2 + he], J = zd(X), ie = Math.min(s, v2(Math.abs(Math.min(q, G))));
  return zu(Number.isFinite(ie)), {
    longitude: J[0],
    latitude: J[1],
    zoom: ie
  };
}
function dF() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return typeof r == "number" ? {
    top: r,
    bottom: r,
    left: r,
    right: r
  } : (zu(Number.isFinite(r.top) && Number.isFinite(r.bottom) && Number.isFinite(r.left) && Number.isFinite(r.right)), r);
}
const uT = Math.PI / 180;
function pF(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const {
    width: t,
    height: n,
    unproject: i
  } = r, s = {
    targetZ: e
  }, l = i([0, n], s), o = i([t, n], s);
  let d, m;
  const b = r.fovy ? 0.5 * r.fovy * uT : Math.atan(0.5 / r.altitude), T = (90 - r.pitch) * uT;
  return b > T - 0.01 ? (d = hT(r, 0, e), m = hT(r, t, e)) : (d = i([0, 0], s), m = i([t, 0], s)), [l, o, m, d];
}
function hT(r, e, t) {
  const {
    pixelUnprojectionMatrix: n
  } = r, i = Cd(n, [e, 0, 1, 1]), s = Cd(n, [e, r.height, 1, 1]), o = (t * r.distanceScales.unitsPerMeter[2] - i[2]) / (s[2] - i[2]), d = x5([], i, s, o), m = zd(d);
  return m.push(t), m;
}
const fT = 512;
function gF(r) {
  const {
    width: e,
    height: t,
    pitch: n = 0
  } = r;
  let {
    longitude: i,
    latitude: s,
    zoom: l,
    bearing: o = 0
  } = r;
  (i < -180 || i > 180) && (i = cT(i + 180, 360) - 180), (o < -180 || o > 180) && (o = cT(o + 180, 360) - 180);
  const d = v2(t / fT);
  if (l <= d)
    l = d, s = 0;
  else {
    const m = t / 2 / Math.pow(2, l), b = zd([0, m])[1];
    if (s < b)
      s = b;
    else {
      const T = zd([0, fT - m])[1];
      s > T && (s = T);
    }
  }
  return {
    width: e,
    height: t,
    longitude: i,
    latitude: s,
    zoom: l,
    pitch: n,
    bearing: o
  };
}
const oC = (
  /* glsl */
  `
uniform shadowUniforms {
  bool drawShadowMap;
  bool useShadowMap;
  vec4 color;
  highp int lightId;
  float lightCount;
  mat4 viewProjectionMatrix0;
  mat4 viewProjectionMatrix1;
  vec4 projectCenter0;
  vec4 projectCenter1;
} shadow;
`
), mF = (
  /* glsl */
  `
const int max_lights = 2;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  mat4 viewProjectionMatrices[max_lights];
  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;
  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;
  vec4 projectCenters[max_lights];
  projectCenters[0] = shadow.projectCenter0;
  projectCenters[1] = shadow.projectCenter1;

  if (shadow.drawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);
  }
  if (shadow.useShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow.lightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`
), _F = `
${oC}
${mF}
`, yF = (
  /* glsl */
  `
const int max_lights = 2;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow.drawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow.useShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow.lightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow.color.a / shadow.lightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`
), bF = `
${oC}
${yF}
`, vF = Pg(SF), xF = Pg(EF), wF = [0, 0, 0, 1], AF = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function TF(r, e) {
  const [t, n, i] = r, s = w2([t, n, i], e);
  return Number.isFinite(i) ? s : [s[0], s[1], 0];
}
function SF(r) {
  let {
    viewport: e,
    center: t
  } = r;
  return new Cn(e.viewProjectionMatrix).invert().transform(t);
}
function EF(r) {
  let {
    viewport: e,
    shadowMatrices: t
  } = r;
  const n = [], i = e.pixelUnprojectionMatrix, s = e.isGeospatial ? void 0 : 1, l = [
    [0, 0, s],
    // top left ground
    [e.width, 0, s],
    // top right ground
    [0, e.height, s],
    // bottom left ground
    [e.width, e.height, s],
    // bottom right ground
    [0, 0, -1],
    // top left near
    [e.width, 0, -1],
    // top right near
    [0, e.height, -1],
    // bottom left near
    [e.width, e.height, -1]
    // bottom right near
  ].map((o) => (
    // @ts-expect-error z may be undefined
    TF(o, i)
  ));
  for (const o of t) {
    const d = o.clone().translate(new Tt(e.center).negate()), m = l.map((T) => d.transform(T)), b = new Cn().ortho({
      left: Math.min(...m.map((T) => T[0])),
      right: Math.max(...m.map((T) => T[0])),
      bottom: Math.min(...m.map((T) => T[1])),
      top: Math.max(...m.map((T) => T[1])),
      near: Math.min(...m.map((T) => -T[2])),
      far: Math.max(...m.map((T) => -T[2]))
    });
    n.push(b.multiplyRight(o));
  }
  return n;
}
function CF(r) {
  const {
    shadowEnabled: e = !0,
    project: t
  } = r;
  if (!e || !t || !r.shadowMatrices || !r.shadowMatrices.length)
    return {
      drawShadowMap: !1,
      useShadowMap: !1,
      shadow_uShadowMap0: r.dummyShadowMap,
      shadow_uShadowMap1: r.dummyShadowMap
    };
  const n = y2.getUniforms(t), i = vF({
    viewport: t.viewport,
    center: n.center
  }), s = [], l = xF({
    shadowMatrices: r.shadowMatrices,
    viewport: t.viewport
  }).slice();
  for (let d = 0; d < r.shadowMatrices.length; d++) {
    const m = l[d], b = m.clone().translate(new Tt(t.viewport.center).negate());
    n.coordinateSystem === Rn.LNGLAT && n.projectionMode === wc.WEB_MERCATOR ? (l[d] = b, s[d] = i) : (l[d] = m.clone().multiplyRight(AF), s[d] = b.transform(i));
  }
  const o = {
    drawShadowMap: !!r.drawToShadowMap,
    useShadowMap: r.shadowMaps ? r.shadowMaps.length > 0 : !1,
    color: r.shadowColor || wF,
    lightId: r.shadowLightId || 0,
    lightCount: r.shadowMatrices.length,
    shadow_uShadowMap0: r.dummyShadowMap,
    shadow_uShadowMap1: r.dummyShadowMap
  };
  for (let d = 0; d < l.length; d++)
    o[`viewProjectionMatrix${d}`] = l[d], o[`projectCenter${d}`] = s[d];
  for (let d = 0; d < 2; d++)
    o[`shadow_uShadowMap${d}`] = r.shadowMaps && r.shadowMaps[d] || r.dummyShadowMap;
  return o;
}
const dT = {
  name: "shadow",
  dependencies: [y2],
  vs: _F,
  fs: bF,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  getUniforms: CF,
  uniformTypes: {
    drawShadowMap: "f32",
    useShadowMap: "f32",
    color: "vec4<f32>",
    lightId: "i32",
    lightCount: "f32",
    viewProjectionMatrix0: "mat4x4<f32>",
    viewProjectionMatrix1: "mat4x4<f32>",
    projectCenter0: "vec4<f32>",
    projectCenter1: "vec4<f32>"
  }
}, A2 = {
  ...qA,
  defaultUniforms: {
    ...qA.defaultUniforms,
    useFloatColors: !1
  },
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  }
}, IF = [W5], MF = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
function PF() {
  const r = x_.getDefaultShaderAssembler();
  for (const e of IF)
    r.addDefaultModule(e);
  for (const e of MF)
    r.addShaderHook(e);
  return r;
}
const RF = [255, 255, 255], BF = 1;
let LF = 0;
class aC {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.type = "ambient";
    const {
      color: t = RF
    } = e, {
      intensity: n = BF
    } = e;
    this.id = e.id || `ambient-${LF++}`, this.color = t, this.intensity = n;
  }
}
const OF = [255, 255, 255], NF = 1, DF = [0, 0, -1];
let kF = 0;
class pT {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.type = "directional";
    const {
      color: t = OF
    } = e, {
      intensity: n = NF
    } = e, {
      direction: i = DF
    } = e, {
      _shadow: s = !1
    } = e;
    this.id = e.id || `directional-${kF++}`, this.color = t, this.intensity = n, this.type = "directional", this.direction = new Tt(i).normalize().toArray(), this.shadow = s;
  }
  getProjectedLight(e) {
    return this;
  }
}
class FF {
  /** Create a new Pass instance */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      id: "pass"
    };
    const {
      id: n
    } = t;
    this.id = n, this.device = e, this.props = {
      ...t
    };
  }
  setProps(e) {
    Object.assign(this.props, e);
  }
  render(e) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  cleanup() {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
}
class T2 extends FF {
  constructor() {
    super(...arguments), this._lastRenderIndex = -1;
  }
  render(e) {
    const [t, n] = this.device.canvasContext.getDrawingBufferSize(), i = e.clearCanvas ?? !0, s = e.clearColor ?? (i ? [0, 0, 0, 0] : !1), l = i ? 1 : !1, o = i ? 0 : !1, d = e.colorMask ?? 15, m = {
      viewport: [0, 0, t, n]
    };
    e.colorMask && (m.colorMask = d), e.scissorRect && (m.scissorRect = e.scissorRect);
    const b = this.device.beginRenderPass({
      framebuffer: e.target,
      parameters: m,
      clearColor: s,
      clearDepth: l,
      clearStencil: o
    });
    try {
      return this._drawLayers(b, e);
    } finally {
      b.end();
    }
  }
  /** Draw a list of layers in a list of viewports */
  _drawLayers(e, t) {
    const {
      target: n,
      shaderModuleProps: i,
      viewports: s,
      views: l,
      onViewportActive: o,
      clearStack: d = !0
    } = t;
    t.pass = t.pass || "unknown", d && (this._lastRenderIndex = -1);
    const m = [];
    for (const b of s) {
      const T = l && l[b.id];
      o == null || o(b);
      const M = this._getDrawLayerParams(b, t), E = b.subViewports || [b];
      for (const D of E) {
        const U = this._drawLayersInViewport(e, {
          target: n,
          shaderModuleProps: i,
          viewport: D,
          view: T,
          pass: t.pass,
          layers: t.layers
        }, M);
        m.push(U);
      }
    }
    return m;
  }
  // When a viewport contains multiple subviewports (e.g. repeated web mercator map),
  // this is only done once for the parent viewport
  /* Resolve the parameters needed to draw each layer */
  _getDrawLayerParams(e, t) {
    var U;
    let {
      layers: n,
      pass: i,
      isPicking: s = !1,
      layerFilter: l,
      cullRect: o,
      effects: d,
      shaderModuleProps: m
    } = t, b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const T = [], M = lC(this._lastRenderIndex + 1), E = {
      layer: n[0],
      viewport: e,
      isPicking: s,
      renderPass: i,
      cullRect: o
    }, D = {};
    for (let q = 0; q < n.length; q++) {
      const G = n[q], Y = this._shouldDrawLayer(G, E, l, D), he = {
        shouldDrawLayer: Y
      };
      Y && !b && (he.shouldDrawLayer = !0, he.layerRenderIndex = M(G, Y), he.shaderModuleProps = this._getShaderModuleProps(G, d, i, m), he.layerParameters = {
        ...(U = G.context.deck) == null ? void 0 : U.props.parameters,
        ...this.getLayerParameters(G, q, e)
      }), T[q] = he;
    }
    return T;
  }
  // Draws a list of layers in one viewport
  // TODO - when picking we could completely skip rendering viewports that dont
  // intersect with the picking rect
  /* eslint-disable max-depth, max-statements */
  _drawLayersInViewport(e, t, n) {
    let {
      layers: i,
      shaderModuleProps: s,
      pass: l,
      target: o,
      viewport: d,
      view: m
    } = t;
    const b = UF(this.device, {
      shaderModuleProps: s,
      target: o,
      viewport: d
    });
    if (m && m.props.clear) {
      const M = m.props.clear === !0 ? {
        color: !0,
        depth: !0
      } : m.props.clear;
      this.device.beginRenderPass({
        framebuffer: o,
        parameters: {
          viewport: b,
          scissorRect: b
        },
        clearColor: M.color ? [0, 0, 0, 0] : !1,
        clearDepth: M.depth ? 1 : !1
      }).end();
    }
    const T = {
      totalCount: i.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    e.setParameters({
      viewport: b
    });
    for (let M = 0; M < i.length; M++) {
      const E = i[M], D = n[M], {
        shouldDrawLayer: U
      } = D;
      if (U && E.props.pickable && T.pickableCount++, E.isComposite && T.compositeCount++, E.isDrawable && D.shouldDrawLayer) {
        const {
          layerRenderIndex: q,
          shaderModuleProps: G,
          layerParameters: Y
        } = D;
        T.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, q), G.project && (G.project.viewport = d), E.context.renderPass = e;
        try {
          E._drawLayer({
            renderPass: e,
            shaderModuleProps: G,
            uniforms: {
              layerIndex: q
            },
            parameters: Y
          });
        } catch (he) {
          E.raiseError(he, `drawing ${E} to ${l}`);
        }
      }
    }
    return T;
  }
  /* eslint-enable max-depth, max-statements */
  /* Methods for subclass overrides */
  shouldDrawLayer(e) {
    return !0;
  }
  getShaderModuleProps(e, t, n) {
    return null;
  }
  getLayerParameters(e, t, n) {
    return e.props.parameters;
  }
  /* Private */
  _shouldDrawLayer(e, t, n, i) {
    if (!(e.props.visible && this.shouldDrawLayer(e)))
      return !1;
    t.layer = e;
    let l = e.parent;
    for (; l; ) {
      if (!l.props.visible || !l.filterSubLayer(t))
        return !1;
      t.layer = l, l = l.parent;
    }
    if (n) {
      const o = t.layer.id;
      if (o in i || (i[o] = n(t)), !i[o])
        return !1;
    }
    return e.activateViewport(t.viewport), !0;
  }
  _getShaderModuleProps(e, t, n, i) {
    var d, m;
    const s = this.device.canvasContext.cssToDeviceRatio(), l = ((d = e.internalState) == null ? void 0 : d.propsInTransition) || e.props, o = {
      layer: l,
      picking: {
        isActive: !1
      },
      project: {
        viewport: e.context.viewport,
        devicePixelRatio: s,
        modelMatrix: l.modelMatrix,
        coordinateSystem: l.coordinateSystem,
        coordinateOrigin: l.coordinateOrigin,
        autoWrapLongitude: e.wrapLongitude
      }
    };
    if (t)
      for (const b of t)
        gT(o, (m = b.getShaderModuleProps) == null ? void 0 : m.call(b, e, o));
    return gT(o, this.getShaderModuleProps(e, t, o), i);
  }
}
function lC() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {}, n = (i, s) => {
    const l = i.props._offset, o = i.id, d = i.parent && i.parent.id;
    let m;
    if (d && !(d in e) && n(i.parent, !1), d in t) {
      const b = t[d] = t[d] || lC(e[d], e);
      m = b(i, s), t[o] = b;
    } else Number.isFinite(l) ? (m = l + (e[d] || 0), t[o] = null) : m = r;
    return s && m >= r && (r = m + 1), e[o] = m, m;
  };
  return n;
}
function UF(r, e) {
  var m;
  let {
    shaderModuleProps: t,
    target: n,
    viewport: i
  } = e;
  const s = ((m = t == null ? void 0 : t.project) == null ? void 0 : m.devicePixelRatio) ?? // @ts-expect-error TODO - assuming WebGL context
  r.canvasContext.cssToDeviceRatio(), [, l] = r.canvasContext.getDrawingBufferSize(), o = n ? n.height : l, d = i;
  return [d.x * s, o - (d.y + d.height) * s, d.width * s, d.height * s];
}
function gT(r) {
  for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
    t[n - 1] = arguments[n];
  for (const i of t)
    if (i)
      for (const s in i)
        r[s] ? Object.assign(r[s], i[s]) : r[s] = i[s];
  return r;
}
class zF extends T2 {
  constructor(e, t) {
    super(e, t);
    const n = e.createTexture({
      format: "rgba8unorm",
      width: 1,
      height: 1,
      sampler: {
        minFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      },
      mipmaps: !0
    }), i = e.createTexture({
      format: "depth16unorm",
      width: 1,
      height: 1,
      mipmaps: !1
    });
    this.fbo = e.createFramebuffer({
      id: "shadowmap",
      width: 1,
      height: 1,
      colorAttachments: [n],
      // Depth attachment has to be specified for depth test to work
      depthStencilAttachment: i
    });
  }
  delete() {
    this.fbo && (this.fbo.destroy(), this.fbo = null);
  }
  getShadowMap() {
    return this.fbo.colorAttachments[0].texture;
  }
  render(e) {
    const t = this.fbo, n = this.device.canvasContext.cssToDeviceRatio(), i = e.viewports[0], s = i.width * n, l = i.height * n, o = [1, 1, 1, 1];
    (s !== t.width || l !== t.height) && t.resize({
      width: s,
      height: l
    }), super.render({
      ...e,
      clearColor: o,
      target: t,
      pass: "shadow"
    });
  }
  getLayerParameters(e, t, n) {
    return {
      ...e.props.parameters,
      blend: !1,
      depthWriteEnabled: !0,
      depthCompare: "less-equal"
    };
  }
  shouldDrawLayer(e) {
    return e.props.shadowEnabled !== !1;
  }
  getShaderModuleProps(e, t, n) {
    return {
      shadow: {
        project: n.project,
        drawToShadowMap: !0
      }
    };
  }
}
const jF = {
  color: [255, 255, 255],
  intensity: 1
}, mT = [{
  color: [255, 255, 255],
  intensity: 1,
  direction: [-1, 3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, -8, -2.5]
}], VF = [0, 0, 0, 200 / 255];
class S2 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.id = "lighting-effect", this.shadowColor = VF, this.shadow = !1, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.dummyShadowMap = null, this.setProps(e);
  }
  setup(e) {
    this.context = e;
    const {
      device: t,
      deck: n
    } = e;
    this.shadow && !this.dummyShadowMap && (this._createShadowPasses(t), n._addDefaultShaderModule(dT), this.dummyShadowMap = t.createTexture({
      width: 1,
      height: 1
    }));
  }
  setProps(e) {
    this.ambientLight = void 0, this.directionalLights = [], this.pointLights = [];
    for (const t in e) {
      const n = e[t];
      switch (n.type) {
        case "ambient":
          this.ambientLight = n;
          break;
        case "directional":
          this.directionalLights.push(n);
          break;
        case "point":
          this.pointLights.push(n);
          break;
      }
    }
    this._applyDefaultLights(), this.shadow = this.directionalLights.some((t) => t.shadow), this.context && this.setup(this.context), this.props = e;
  }
  preRender(e) {
    let {
      layers: t,
      layerFilter: n,
      viewports: i,
      onViewportActive: s,
      views: l
    } = e;
    if (this.shadow) {
      this.shadowMatrices = this._calculateMatrices();
      for (let o = 0; o < this.shadowPasses.length; o++)
        this.shadowPasses[o].render({
          layers: t,
          layerFilter: n,
          viewports: i,
          onViewportActive: s,
          views: l,
          shaderModuleProps: {
            shadow: {
              shadowLightId: o,
              dummyShadowMap: this.dummyShadowMap,
              shadowMatrices: this.shadowMatrices
            }
          }
        });
    }
  }
  getShaderModuleProps(e, t) {
    const n = this.shadow ? {
      project: t.project,
      shadowMaps: this.shadowPasses.map((l) => l.getShadowMap()),
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {}, i = {
      enabled: !0,
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((l) => l.getProjectedLight({
        layer: e
      })),
      pointLights: this.pointLights.map((l) => l.getProjectedLight({
        layer: e
      }))
    }, s = e.props.material;
    return {
      shadow: n,
      lighting: i,
      phongMaterial: s,
      gouraudMaterial: s
    };
  }
  cleanup(e) {
    for (const t of this.shadowPasses)
      t.delete();
    this.shadowPasses.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, e.deck._removeDefaultShaderModule(dT));
  }
  _calculateMatrices() {
    const e = [];
    for (const t of this.directionalLights) {
      const n = new Cn().lookAt({
        eye: new Tt(t.direction).negate()
      });
      e.push(n);
    }
    return e;
  }
  _createShadowPasses(e) {
    for (let t = 0; t < this.directionalLights.length; t++) {
      const n = new zF(e);
      this.shadowPasses[t] = n;
    }
  }
  _applyDefaultLights() {
    const {
      ambientLight: e,
      pointLights: t,
      directionalLights: n
    } = this;
    !e && t.length === 0 && n.length === 0 && (this.ambientLight = new aC(jF), this.directionalLights.push(new pT(mT[0]), new pT(mT[1])));
  }
}
class qF {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._pool = [], this.opts = {
      overAlloc: 2,
      poolSize: 100
    }, this.setOptions(e);
  }
  setOptions(e) {
    Object.assign(this.opts, e);
  }
  allocate(e, t, n) {
    let {
      size: i = 1,
      type: s,
      padding: l = 0,
      copy: o = !1,
      initialize: d = !1,
      maxCount: m
    } = n;
    const b = s || e && e.constructor || Float32Array, T = t * i + l;
    if (ArrayBuffer.isView(e)) {
      if (T <= e.length)
        return e;
      if (T * e.BYTES_PER_ELEMENT <= e.buffer.byteLength)
        return new b(e.buffer, 0, T);
    }
    let M = 1 / 0;
    m && (M = m * i + l);
    const E = this._allocate(b, T, d, M);
    return e && o ? E.set(e) : d || E.fill(0, 0, 4), this._release(e), E;
  }
  release(e) {
    this._release(e);
  }
  _allocate(e, t, n, i) {
    let s = Math.max(Math.ceil(t * this.opts.overAlloc), 1);
    s > i && (s = i);
    const l = this._pool, o = e.BYTES_PER_ELEMENT * s, d = l.findIndex((m) => m.byteLength >= o);
    if (d >= 0) {
      const m = new e(l.splice(d, 1)[0], 0, s);
      return n && m.fill(0), m;
    }
    return new e(s);
  }
  _release(e) {
    if (!ArrayBuffer.isView(e))
      return;
    const t = this._pool, {
      buffer: n
    } = e, {
      byteLength: i
    } = n, s = t.findIndex((l) => l.byteLength >= i);
    s < 0 ? t.push(n) : (s > 0 || t.length < this.opts.poolSize) && t.splice(s, 0, n), t.length > this.opts.poolSize && t.shift();
  }
}
const mg = new qF();
function Wp() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function GF(r, e) {
  const t = r % e;
  return t < 0 ? e + t : t;
}
function $F(r) {
  return [r[12], r[13], r[14]];
}
function HF(r) {
  return {
    left: sd(r[3] + r[0], r[7] + r[4], r[11] + r[8], r[15] + r[12]),
    right: sd(r[3] - r[0], r[7] - r[4], r[11] - r[8], r[15] - r[12]),
    bottom: sd(r[3] + r[1], r[7] + r[5], r[11] + r[9], r[15] + r[13]),
    top: sd(r[3] - r[1], r[7] - r[5], r[11] - r[9], r[15] - r[13]),
    near: sd(r[3] + r[2], r[7] + r[6], r[11] + r[10], r[15] + r[14]),
    far: sd(r[3] - r[2], r[7] - r[6], r[11] - r[10], r[15] - r[14])
  };
}
const _T = new Tt();
function sd(r, e, t, n) {
  _T.set(r, e, t);
  const i = _T.len();
  return {
    distance: n / i,
    normal: new Tt(-r / i, -e / i, -t / i)
  };
}
function WF(r) {
  return r - Math.fround(r);
}
let Rp;
function ib(r, e) {
  const {
    size: t = 1,
    startIndex: n = 0
  } = e, i = e.endIndex !== void 0 ? e.endIndex : r.length, s = (i - n) / t;
  Rp = mg.allocate(Rp, s, {
    type: Float32Array,
    size: t * 2
  });
  let l = n, o = 0;
  for (; l < i; ) {
    for (let d = 0; d < t; d++) {
      const m = r[l++];
      Rp[o + d] = m, Rp[o + d + t] = WF(m);
    }
    o += t * 2;
  }
  return Rp.subarray(0, s * t * 2);
}
function XF(r) {
  let e = null, t = !1;
  for (const n of r)
    n && (e ? (t || (e = [[e[0][0], e[0][1]], [e[1][0], e[1][1]]], t = !0), e[0][0] = Math.min(e[0][0], n[0][0]), e[0][1] = Math.min(e[0][1], n[0][1]), e[1][0] = Math.max(e[1][0], n[1][0]), e[1][1] = Math.max(e[1][1], n[1][1])) : e = n);
  return e;
}
const ZF = Math.PI / 180, YF = Wp(), yT = [0, 0, 0], KF = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function JF(r) {
  let {
    width: e,
    height: t,
    orthographic: n,
    fovyRadians: i,
    focalDistance: s,
    padding: l,
    near: o,
    far: d
  } = r;
  const m = e / t, b = n ? new Cn().orthographic({
    fovy: i,
    aspect: m,
    focalDistance: s,
    near: o,
    far: d
  }) : new Cn().perspective({
    fovy: i,
    aspect: m,
    near: o,
    far: d
  });
  if (l) {
    const {
      left: T = 0,
      right: M = 0,
      top: E = 0,
      bottom: D = 0
    } = l, U = xc((T + e - M) / 2, 0, e) - e / 2, q = xc((E + t - D) / 2, 0, t) - t / 2;
    b[8] -= U * 2 / e, b[9] += q * 2 / t;
  }
  return b;
}
class Qd {
  // eslint-disable-next-line complexity
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._frustumPlanes = {}, this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || KF, this.focalDistance = e.focalDistance || 1, this.position = e.position || yT, this.modelMatrix = e.modelMatrix || null;
    const {
      longitude: t,
      latitude: n
    } = e;
    this.isGeospatial = Number.isFinite(n) && Number.isFinite(t), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    return this.isGeospatial ? this.zoom < 12 ? wc.WEB_MERCATOR : wc.WEB_MERCATOR_AUTO_OFFSET : wc.IDENTITY;
  }
  // Two viewports are equal if width and height are identical, and if
  // their view and projection matrices are (approximately) equal.
  equals(e) {
    return e instanceof Qd ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && Cc(e.projectionMatrix, this.projectionMatrix) && Cc(e.viewMatrix, this.viewMatrix) : !1;
  }
  /**
   * Projects xyz (possibly latitude and longitude) to pixel coordinates in window
   * using viewport projection parameters
   * - [longitude, latitude] to [x, y]
   * - [longitude, latitude, Z] => [x, y, z]
   * Note: By default, returns top-left coordinates for canvas/SVG type render
   *
   * @param {Array} lngLatZ - [lng, lat] or [lng, lat, Z]
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether projected coords are top left
   * @return {Array} - [x, y] or [x, y, z] in top left coords
   */
  project(e) {
    let {
      topLeft: t = !0
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.projectPosition(e), i = sC(n, this.pixelProjectionMatrix), [s, l] = i, o = t ? l : this.height - l;
    return e.length === 2 ? [s, o] : [s, o, i[2]];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e) {
    let {
      topLeft: t = !0,
      targetZ: n
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const [i, s, l] = e, o = t ? s : this.height - s, d = n && n * this.distanceScales.unitsPerMeter[2], m = w2([i, o, l], this.pixelUnprojectionMatrix, d), [b, T, M] = this.unprojectPosition(m);
    return Number.isFinite(l) ? [b, T, M] : Number.isFinite(n) ? [b, T, n] : [b, T];
  }
  // NON_LINEAR PROJECTION HOOKS
  // Used for web meractor projection
  projectPosition(e) {
    const [t, n] = this.projectFlat(e), i = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [t, n, i];
  }
  unprojectPosition(e) {
    const [t, n] = this.unprojectFlat(e), i = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [t, n, i];
  }
  /**
   * Project [lng,lat] on sphere onto [x,y] on 512*512 Mercator Zoom 0 tile.
   * Performs the nonlinear part of the web mercator projection.
   * Remaining projection is done with 4x4 matrices which also handles
   * perspective.
   * @param {Array} lngLat - [lng, lat] coordinates
   *   Specifies a point on the sphere to project onto the map.
   * @return {Array} [x,y] coordinates.
   */
  projectFlat(e) {
    if (this.isGeospatial) {
      const t = pg(e);
      return t[1] = xc(t[1], -318, 830), t;
    }
    return e;
  }
  /**
   * Unproject world point [x,y] on map onto {lat, lon} on sphere
   * @param {object|Vector} xy - object with {x,y} members
   *  representing point on projected map plane
   * @return {GeoCoordinates} - object with {lat,lon} of point on sphere.
   *   Has toArray method if you need a GeoJSON Array.
   *   Per cartographic tradition, lat and lon are specified as degrees.
   */
  unprojectFlat(e) {
    return this.isGeospatial ? zd(e) : e;
  }
  /**
   * Get bounds of the current viewport
   * @return {Array} - [minX, minY, maxX, maxY]
   */
  getBounds() {
    const t = {
      targetZ: (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).z || 0
    }, n = this.unproject([0, 0], t), i = this.unproject([this.width, 0], t), s = this.unproject([0, this.height], t), l = this.unproject([this.width, this.height], t);
    return [Math.min(n[0], i[0], s[0], l[0]), Math.min(n[1], i[1], s[1], l[1]), Math.max(n[0], i[0], s[0], l[0]), Math.max(n[1], i[1], s[1], l[1])];
  }
  getDistanceScales(e) {
    return e && this.isGeospatial ? G1({
      longitude: e[0],
      latitude: e[1],
      highPrecision: !0
    }) : this.distanceScales;
  }
  containsPixel(e) {
    let {
      x: t,
      y: n,
      width: i = 1,
      height: s = 1
    } = e;
    return t < this.x + this.width && this.x < t + i && n < this.y + this.height && this.y < n + s;
  }
  // Extract frustum planes in common space
  getFrustumPlanes() {
    return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, HF(this.viewProjectionMatrix)), this._frustumPlanes);
  }
  // EXPERIMENTAL METHODS
  /**
   * Needed by panning and linear transition
   * Pan the viewport to place a given world coordinate at screen point [x, y]
   *
   * @param {Array} coords - world coordinates
   * @param {Array} pixel - [x,y] coordinates on screen
   * @return {Object} props of the new viewport
   */
  panByPosition(e, t) {
    return null;
  }
  // INTERNAL METHODS
  /* eslint-disable complexity, max-statements */
  _initProps(e) {
    const t = e.longitude, n = e.latitude;
    this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = cF({
      latitude: n
    }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || G1({
      latitude: n,
      longitude: t
    }));
    const i = Math.pow(2, this.zoom);
    this.scale = i;
    const {
      position: s,
      modelMatrix: l
    } = e;
    let o = yT;
    if (s && (o = l ? new Cn(l).transformAsVector(s, []) : s), this.isGeospatial) {
      const d = this.projectPosition([t, n, 0]);
      this.center = new Tt(o).scale(this.distanceScales.unitsPerMeter).add(d);
    } else
      this.center = this.projectPosition(o);
  }
  /* eslint-enable complexity, max-statements */
  _initMatrices(e) {
    const {
      // View matrix
      viewMatrix: t = YF,
      // Projection matrix
      projectionMatrix: n = null,
      // Projection matrix parameters, used if projectionMatrix not supplied
      orthographic: i = !1,
      fovyRadians: s,
      fovy: l = 75,
      near: o = 0.1,
      // Distance of near clipping plane
      far: d = 1e3,
      // Distance of far clipping plane
      padding: m = null,
      // Center offset in pixels
      focalDistance: b = 1
    } = e;
    this.viewMatrixUncentered = t, this.viewMatrix = new Cn().multiplyRight(t).translate(new Tt(this.center).negate()), this.projectionMatrix = n || JF({
      width: this.width,
      height: this.height,
      orthographic: i,
      fovyRadians: s || l * ZF,
      focalDistance: b,
      padding: m,
      near: o,
      far: d
    });
    const T = Wp();
    bf(T, T, this.projectionMatrix), bf(T, T, this.viewMatrix), this.viewProjectionMatrix = T, this.viewMatrixInverse = O1([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = $F(this.viewMatrixInverse);
    const M = Wp(), E = Wp();
    g2(M, M, [this.width / 2, -this.height / 2, 1]), D_(M, M, [1, -1, 0]), bf(E, M, this.viewProjectionMatrix), this.pixelProjectionMatrix = E, this.pixelUnprojectionMatrix = O1(Wp(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || qn.warn("Pixel project matrix not invertible")();
  }
}
Qd.displayName = "Viewport";
class Cf extends Qd {
  /* eslint-disable complexity, max-statements */
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      latitude: t = 0,
      longitude: n = 0,
      zoom: i = 0,
      pitch: s = 0,
      bearing: l = 0,
      nearZMultiplier: o = 0.1,
      farZMultiplier: d = 1.01,
      nearZ: m,
      farZ: b,
      orthographic: T = !1,
      projectionMatrix: M,
      repeat: E = !1,
      worldOffset: D = 0,
      position: U,
      padding: q,
      // backward compatibility
      // TODO: remove in v9
      legacyMeterSizes: G = !1
    } = e;
    let {
      width: Y,
      height: he,
      altitude: X = 1.5
    } = e;
    const J = Math.pow(2, i);
    Y = Y || 1, he = he || 1;
    let ie, ye = null;
    if (M)
      X = M[5] / 2, ie = gg(X);
    else {
      e.fovy ? (ie = e.fovy, X = x2(ie)) : ie = gg(X);
      let Re;
      if (q) {
        const {
          top: Ne = 0,
          bottom: me = 0
        } = q;
        Re = [0, xc((Ne + he - me) / 2, 0, he) - he / 2];
      }
      ye = hF({
        width: Y,
        height: he,
        scale: J,
        center: U && [0, 0, U[2] * Km(t)],
        offset: Re,
        pitch: s,
        fovy: ie,
        nearZMultiplier: o,
        farZMultiplier: d
      }), Number.isFinite(m) && (ye.near = m), Number.isFinite(b) && (ye.far = b);
    }
    let oe = uF({
      height: he,
      pitch: s,
      bearing: l,
      scale: J,
      altitude: X
    });
    D && (oe = new Cn().translate([512 * D, 0, 0]).multiplyLeft(oe)), super({
      ...e,
      // x, y,
      width: Y,
      height: he,
      // view matrix
      viewMatrix: oe,
      longitude: n,
      latitude: t,
      zoom: i,
      // projection matrix parameters
      ...ye,
      fovy: ie,
      focalDistance: X
    }), this.latitude = t, this.longitude = n, this.zoom = i, this.pitch = s, this.bearing = l, this.altitude = X, this.fovy = ie, this.orthographic = T, this._subViewports = E ? [] : null, this._pseudoMeters = G, Object.freeze(this);
  }
  /* eslint-enable complexity, max-statements */
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const e = this.getBounds(), t = Math.floor((e[0] + 180) / 360), n = Math.ceil((e[2] - 180) / 360);
      for (let i = t; i <= n; i++) {
        const s = i ? new Cf({
          ...this,
          worldOffset: i
        }) : this;
        this._subViewports.push(s);
      }
    }
    return this._subViewports;
  }
  projectPosition(e) {
    if (this._pseudoMeters)
      return super.projectPosition(e);
    const [t, n] = this.projectFlat(e), i = (e[2] || 0) * Km(e[1]);
    return [t, n, i];
  }
  unprojectPosition(e) {
    if (this._pseudoMeters)
      return super.unprojectPosition(e);
    const [t, n] = this.unprojectFlat(e), i = (e[2] || 0) / Km(n);
    return [t, n, i];
  }
  /**
   * Add a meter delta to a base lnglat coordinate, returning a new lnglat array
   *
   * Note: Uses simple linear approximation around the viewport center
   * Error increases with size of offset (roughly 1% per 100km)
   *
   * @param {[Number,Number]|[Number,Number,Number]) lngLatZ - base coordinate
   * @param {[Number,Number]|[Number,Number,Number]) xyz - array of meter deltas
   * @return {[Number,Number]|[Number,Number,Number]) array of [lng,lat,z] deltas
   */
  addMetersToLngLat(e, t) {
    return iC(e, t);
  }
  panByPosition(e, t) {
    const n = w2(t, this.pixelUnprojectionMatrix), i = this.projectFlat(e), s = DA([], i, dN([], n)), l = DA([], this.center, s), [o, d] = this.unprojectFlat(l);
    return {
      longitude: o,
      latitude: d
    };
  }
  getBounds() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = pF(this, e.z || 0);
    return [Math.min(t[0][0], t[1][0], t[2][0], t[3][0]), Math.min(t[0][1], t[1][1], t[2][1], t[3][1]), Math.max(t[0][0], t[1][0], t[2][0], t[3][0]), Math.max(t[0][1], t[1][1], t[2][1], t[3][1])];
  }
  /**
   * Returns a new viewport that fit around the given rectangle.
   * Only supports non-perspective mode.
   */
  fitBounds(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      width: n,
      height: i
    } = this, {
      longitude: s,
      latitude: l,
      zoom: o
    } = fF({
      width: n,
      height: i,
      bounds: e,
      ...t
    });
    return new Cf({
      width: n,
      height: i,
      longitude: s,
      latitude: l,
      zoom: o
    });
  }
}
Cf.displayName = "WebMercatorViewport";
const bT = [0, 0, 0];
function sb(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const n = e.projectPosition(r);
  if (t && e instanceof Cf) {
    const [i, s, l = 0] = r, o = e.getDistanceScales([i, s]);
    n[2] = l * o.unitsPerMeter[2];
  }
  return n;
}
function QF(r) {
  const {
    viewport: e,
    modelMatrix: t,
    coordinateOrigin: n
  } = r;
  let {
    coordinateSystem: i,
    fromCoordinateSystem: s,
    fromCoordinateOrigin: l
  } = r;
  return i === Rn.DEFAULT && (i = e.isGeospatial ? Rn.LNGLAT : Rn.CARTESIAN), s === void 0 && (s = i), l === void 0 && (l = n), {
    viewport: e,
    coordinateSystem: i,
    coordinateOrigin: n,
    modelMatrix: t,
    fromCoordinateSystem: s,
    fromCoordinateOrigin: l
  };
}
function cC(r, e) {
  let {
    viewport: t,
    modelMatrix: n,
    coordinateSystem: i,
    coordinateOrigin: s,
    offsetMode: l
  } = e, [o, d, m = 0] = r;
  switch (n && ([o, d, m] = Jd([], [o, d, m, 1], n)), i) {
    case Rn.LNGLAT:
      return sb([o, d, m], t, l);
    case Rn.LNGLAT_OFFSETS:
      return sb([o + s[0], d + s[1], m + (s[2] || 0)], t, l);
    case Rn.METER_OFFSETS:
      return sb(iC(s, [o, d, m]), t, l);
    case Rn.CARTESIAN:
    default:
      return t.isGeospatial ? [o + s[0], d + s[1], m + s[2]] : t.projectPosition([o, d, m]);
  }
}
function e8(r, e) {
  const {
    viewport: t,
    coordinateSystem: n,
    coordinateOrigin: i,
    modelMatrix: s,
    fromCoordinateSystem: l,
    fromCoordinateOrigin: o
  } = QF(e), {
    autoOffset: d = !0
  } = e, {
    geospatialOrigin: m = bT,
    shaderCoordinateOrigin: b = bT,
    offsetMode: T = !1
  } = d ? rC(t, n, i) : {}, M = cC(r, {
    viewport: t,
    modelMatrix: s,
    coordinateSystem: l,
    coordinateOrigin: o,
    offsetMode: T
  });
  if (T) {
    const E = t.projectPosition(m || b);
    R5(M, M, E);
  }
  return M;
}
let t8 = 1, r8 = 1;
class uC {
  constructor() {
    H(this, "time", 0);
    H(this, "channels", /* @__PURE__ */ new Map());
    H(this, "animations", /* @__PURE__ */ new Map());
    H(this, "playing", !1);
    H(this, "lastEngineTime", -1);
  }
  addChannel(e) {
    const {
      delay: t = 0,
      duration: n = Number.POSITIVE_INFINITY,
      rate: i = 1,
      repeat: s = 1
    } = e, l = t8++, o = {
      time: 0,
      delay: t,
      duration: n,
      rate: i,
      repeat: s
    };
    return this._setChannelTime(o, this.time), this.channels.set(l, o), l;
  }
  removeChannel(e) {
    this.channels.delete(e);
    for (const [t, n] of this.animations)
      n.channel === e && this.detachAnimation(t);
  }
  isFinished(e) {
    const t = this.channels.get(e);
    return t === void 0 ? !1 : this.time >= t.delay + t.duration * t.repeat;
  }
  getTime(e) {
    if (e === void 0)
      return this.time;
    const t = this.channels.get(e);
    return t === void 0 ? -1 : t.time;
  }
  setTime(e) {
    this.time = Math.max(0, e);
    const t = this.channels.values();
    for (const i of t)
      this._setChannelTime(i, this.time);
    const n = this.animations.values();
    for (const i of n) {
      const {
        animation: s,
        channel: l
      } = i;
      s.setTime(this.getTime(l));
    }
  }
  play() {
    this.playing = !0;
  }
  pause() {
    this.playing = !1, this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(e, t) {
    const n = r8++;
    return this.animations.set(n, {
      animation: e,
      channel: t
    }), e.setTime(this.getTime(t)), n;
  }
  detachAnimation(e) {
    this.animations.delete(e);
  }
  update(e) {
    this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
  }
  _setChannelTime(e, t) {
    const n = t - e.delay, i = e.duration * e.repeat;
    n >= i ? e.time = e.duration * e.rate : (e.time = Math.max(0, n) % e.duration, e.time *= e.rate);
  }
}
function n8(r) {
  return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(r) : setTimeout(r, 1e3 / 60);
}
function i8(r) {
  return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(r) : clearTimeout(r);
}
let s8 = 0;
const o8 = {
  device: null,
  onAddHTML: () => "",
  onInitialize: async () => null,
  onRender: () => {
  },
  onFinalize: () => {
  },
  onError: (r) => console.error(r),
  // eslint-disable-line no-console
  stats: w1.stats.get(`animation-loop-${s8++}`),
  // view parameters
  useDevicePixels: !0,
  autoResizeViewport: !1,
  autoResizeDrawingBuffer: !1
};
class a8 {
  // _gpuTimeQuery: Query | null = null;
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(e) {
    H(this, "device", null);
    H(this, "canvas", null);
    H(this, "props");
    H(this, "animationProps", null);
    H(this, "timeline", null);
    H(this, "stats");
    H(this, "cpuTime");
    H(this, "gpuTime");
    H(this, "frameRate");
    H(this, "display");
    H(this, "needsRedraw", "initialized");
    H(this, "_initialized", !1);
    H(this, "_running", !1);
    H(this, "_animationFrameId", null);
    H(this, "_nextFramePromise", null);
    H(this, "_resolveNextFrame", null);
    H(this, "_cpuStartTime", 0);
    H(this, "_error", null);
    if (this.props = {
      ...o8,
      ...e
    }, e = this.props, !e.device)
      throw new Error("No device provided");
    const {
      useDevicePixels: t = !0
    } = this.props;
    this.stats = e.stats || new Yd({
      id: "animation-loop-stats"
    }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({
      autoResizeViewport: e.autoResizeViewport,
      autoResizeDrawingBuffer: e.autoResizeDrawingBuffer,
      useDevicePixels: t
    }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
  }
  destroy() {
    this.stop(), this._setDisplay(null);
  }
  /** @deprecated Use .destroy() */
  delete() {
    this.destroy();
  }
  setError(e) {
    var n, i;
    if (this.props.onError(e), this._error = Error(), ((i = (n = this.device) == null ? void 0 : n.canvasContext) == null ? void 0 : i.canvas) instanceof HTMLCanvasElement) {
      const s = document.createElement("h1");
      s.innerHTML = e.message, s.style.position = "absolute", s.style.top = "20%", s.style.left = "10px", s.style.color = "black", s.style.backgroundColor = "red", document.body.appendChild(s);
    }
  }
  /** Flags this animation loop as needing redraw */
  setNeedsRedraw(e) {
    return this.needsRedraw = this.needsRedraw || e, this;
  }
  /** TODO - move these props to CanvasContext? */
  setProps(e) {
    return "autoResizeViewport" in e && (this.props.autoResizeViewport = e.autoResizeViewport || !1), "autoResizeDrawingBuffer" in e && (this.props.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer || !1), "useDevicePixels" in e && (this.props.useDevicePixels = e.useDevicePixels || !1), this;
  }
  /** Starts a render loop if not already running */
  async start() {
    if (this._running)
      return this;
    this._running = !0;
    try {
      let e;
      return this._initialized || (this._initialized = !0, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (e !== !1 && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null;
    } catch (e) {
      const t = e instanceof Error ? e : new Error("Unknown error");
      throw this.props.onError(t), t;
    }
  }
  /** Stops a render loop if already running, finalizing */
  stop() {
    return this._running && (this.animationProps && !this._error && this.props.onFinalize(this.animationProps), this._cancelAnimationFrame(), this._nextFramePromise = null, this._resolveNextFrame = null, this._running = !1), this;
  }
  /** Explicitly draw a frame */
  redraw() {
    var e;
    return (e = this.device) != null && e.isLost || this._error ? this : (this._beginFrameTimers(), this._setupFrame(), this._updateAnimationProps(), this._renderFrame(this._getAnimationProps()), this._clearNeedsRedraw(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endFrameTimers(), this);
  }
  /** Add a timeline, it will be automatically updated by the animation loop. */
  attachTimeline(e) {
    return this.timeline = e, this.timeline;
  }
  /** Remove a timeline */
  detachTimeline() {
    this.timeline = null;
  }
  /** Wait until a render completes */
  waitForRender() {
    return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
      this._resolveNextFrame = e;
    })), this._nextFramePromise;
  }
  /** TODO - should use device.deviceContext */
  async toDataURL() {
    if (this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.canvas instanceof HTMLCanvasElement)
      return this.canvas.toDataURL();
    throw new Error("OffscreenCanvas");
  }
  // PRIVATE METHODS
  _initialize() {
    this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  _setDisplay(e) {
    this.display && (this.display.destroy(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
  }
  _requestAnimationFrame() {
    this._running && (this._animationFrameId = n8(this._animationFrame.bind(this)));
  }
  _cancelAnimationFrame() {
    this._animationFrameId !== null && (i8(this._animationFrameId), this._animationFrameId = null);
  }
  _animationFrame() {
    this._running && (this.redraw(), this._requestAnimationFrame());
  }
  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(e) {
    var t;
    if (this.display) {
      this.display._renderFrame(e);
      return;
    }
    this.props.onRender(this._getAnimationProps()), (t = this.device) == null || t.submit();
  }
  _clearNeedsRedraw() {
    this.needsRedraw = !1;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer(), this._resizeViewport();
  }
  // Initialize the  object that will be passed to app callbacks
  _initializeAnimationProps() {
    var t, n;
    const e = (n = (t = this.device) == null ? void 0 : t.canvasContext) == null ? void 0 : n.canvas;
    if (!this.device || !e)
      throw new Error("loop");
    this.animationProps = {
      animationLoop: this,
      device: this.device,
      canvas: e,
      timeline: this.timeline,
      // Initial values
      useDevicePixels: this.props.useDevicePixels,
      needsRedraw: !1,
      // Placeholders
      width: 1,
      height: 1,
      aspect: 1,
      // Animation props
      time: 0,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      // Experimental
      _mousePosition: null
      // Event props
    };
  }
  _getAnimationProps() {
    if (!this.animationProps)
      throw new Error("animationProps");
    return this.animationProps;
  }
  // Update the context object that will be passed to app callbacks
  _updateAnimationProps() {
    if (!this.animationProps)
      return;
    const {
      width: e,
      height: t,
      aspect: n
    } = this._getSizeAndAspect();
    (e !== this.animationProps.width || t !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), n !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = t, this.animationProps.aspect = n, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
  }
  /** Wait for supplied device */
  async _initDevice() {
    var e;
    if (this.device = await this.props.device, !this.device)
      throw new Error("No device provided");
    this.canvas = ((e = this.device.canvasContext) == null ? void 0 : e.canvas) || null;
  }
  _createInfoDiv() {
    if (this.canvas && this.props.onAddHTML) {
      const e = document.createElement("div");
      document.body.appendChild(e), e.style.position = "relative";
      const t = document.createElement("div");
      t.style.position = "absolute", t.style.left = "10px", t.style.bottom = "10px", t.style.width = "300px", t.style.background = "white", this.canvas instanceof HTMLCanvasElement && e.appendChild(this.canvas), e.appendChild(t);
      const n = this.props.onAddHTML(t);
      n && (t.innerHTML = n);
    }
  }
  _getSizeAndAspect() {
    var s, l, o, d;
    if (!this.device)
      return {
        width: 1,
        height: 1,
        aspect: 1
      };
    const [e, t] = ((l = (s = this.device) == null ? void 0 : s.canvasContext) == null ? void 0 : l.getPixelSize()) || [1, 1];
    let n = 1;
    const i = (d = (o = this.device) == null ? void 0 : o.canvasContext) == null ? void 0 : d.canvas;
    return i && i.clientHeight ? n = i.clientWidth / i.clientHeight : e > 0 && t > 0 && (n = e / t), {
      width: e,
      height: t,
      aspect: n
    };
  }
  /** Default viewport setup */
  _resizeViewport() {
    this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(
      0,
      0,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferWidth,
      // @ts-expect-error Expose canvasContext
      this.device.gl.drawingBufferHeight
    );
  }
  /**
   * Resize the render buffer of the canvas to match canvas client size
   * Optionally multiplying with devicePixel ratio
   */
  _resizeCanvasDrawingBuffer() {
    var e, t;
    this.props.autoResizeDrawingBuffer && ((t = (e = this.device) == null ? void 0 : e.canvasContext) == null || t.resize({
      useDevicePixels: this.props.useDevicePixels
    }));
  }
  _beginFrameTimers() {
    this.frameRate.timeEnd(), this.frameRate.timeStart(), this.cpuTime.timeStart();
  }
  _endFrameTimers() {
    this.cpuTime.timeEnd();
  }
  // Event handling
  _startEventHandling() {
    this.canvas && (this.canvas.addEventListener("mousemove", this._onMousemove.bind(this)), this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this)));
  }
  _onMousemove(e) {
    e instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [e.offsetX, e.offsetY]);
  }
  _onMouseleave(e) {
    this._getAnimationProps()._mousePosition = null;
  }
}
const ob = {};
function Rg() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  ob[r] = ob[r] || 1;
  const e = ob[r]++;
  return `${r}-${e}`;
}
class vT {
  constructor(e) {
    H(this, "id");
    H(this, "userData", {});
    /** Determines how vertices are read from the 'vertex' attributes */
    H(this, "topology");
    H(this, "bufferLayout", []);
    H(this, "vertexCount");
    H(this, "indices");
    H(this, "attributes");
    if (this.id = e.id || Rg("geometry"), this.topology = e.topology, this.indices = e.indices || null, this.attributes = e.attributes, this.vertexCount = e.vertexCount, this.bufferLayout = e.bufferLayout || [], this.indices && !(this.indices.usage & Ss.INDEX))
      throw new Error("Index buffer must have INDEX usage");
  }
  destroy() {
    var e;
    (e = this.indices) == null || e.destroy();
    for (const t of Object.values(this.attributes))
      t.destroy();
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getIndexes() {
    return this.indices || null;
  }
  _calculateVertexCount(e) {
    return e.byteLength / 12;
  }
}
function l8(r, e) {
  if (e instanceof vT)
    return e;
  const t = c8(r, e), {
    attributes: n,
    bufferLayout: i
  } = u8(r, e);
  return new vT({
    topology: e.topology || "triangle-list",
    bufferLayout: i,
    vertexCount: e.vertexCount,
    indices: t,
    attributes: n
  });
}
function c8(r, e) {
  if (!e.indices)
    return;
  const t = e.indices.value;
  return r.createBuffer({
    usage: Ss.INDEX,
    data: t
  });
}
function u8(r, e) {
  const t = [], n = {};
  for (const [s, l] of Object.entries(e.attributes)) {
    let o = s;
    switch (s) {
      case "POSITION":
        o = "positions";
        break;
      case "NORMAL":
        o = "normals";
        break;
      case "TEXCOORD_0":
        o = "texCoords";
        break;
      case "COLOR_0":
        o = "colors";
        break;
    }
    if (l) {
      n[o] = r.createBuffer({
        data: l.value,
        id: `${s}-buffer`
      });
      const {
        value: d,
        size: m,
        normalized: b
      } = l;
      t.push({
        name: o,
        format: S6(d, m, b)
      });
    }
  }
  const i = e._calculateVertexCount(e.attributes, e.indices);
  return {
    attributes: n,
    bufferLayout: t,
    vertexCount: i
  };
}
const dy = class dy {
  constructor(e) {
    H(this, "device");
    H(this, "destroyPolicy");
    H(this, "_hashCounter", 0);
    H(this, "_hashes", {});
    H(this, "_renderPipelineCache", {});
    H(this, "_computePipelineCache", {});
    this.device = e, this.destroyPolicy = e.props._factoryDestroyPolicy;
  }
  /** Get the singleton default pipeline factory for the specified device */
  static getDefaultPipelineFactory(e) {
    return e._lumaData.defaultPipelineFactory = e._lumaData.defaultPipelineFactory || new dy(e), e._lumaData.defaultPipelineFactory;
  }
  /** Return a RenderPipeline matching props. Reuses a similar pipeline if already created. */
  createRenderPipeline(e) {
    const t = {
      ...kd.defaultProps,
      ...e
    }, n = this._hashRenderPipeline(t);
    if (!this._renderPipelineCache[n]) {
      const i = this.device.createRenderPipeline({
        ...t,
        id: t.id ? `${t.id}-cached` : void 0
      });
      i.hash = n, this._renderPipelineCache[n] = {
        pipeline: i,
        useCount: 0
      };
    }
    return this._renderPipelineCache[n].useCount++, this._renderPipelineCache[n].pipeline;
  }
  createComputePipeline(e) {
    const t = {
      ...E_.defaultProps,
      ...e
    }, n = this._hashComputePipeline(t);
    if (!this._computePipelineCache[n]) {
      const i = this.device.createComputePipeline({
        ...t,
        id: t.id ? `${t.id}-cached` : void 0
      });
      i.hash = n, this._computePipelineCache[n] = {
        pipeline: i,
        useCount: 0
      };
    }
    return this._computePipelineCache[n].useCount++, this._computePipelineCache[n].pipeline;
  }
  release(e) {
    const t = e.hash, n = e instanceof E_ ? this._computePipelineCache : this._renderPipelineCache;
    n[t].useCount--, n[t].useCount === 0 && this.destroyPolicy === "unused" && (n[t].pipeline.destroy(), delete n[t]);
  }
  // PRIVATE
  _hashComputePipeline(e) {
    return `${this._getHash(e.shader.source)}`;
  }
  /** Calculate a hash based on all the inputs for a render pipeline */
  _hashRenderPipeline(e) {
    const t = e.vs ? this._getHash(e.vs.source) : 0, n = e.fs ? this._getHash(e.fs.source) : 0, i = "-", s = this._getHash(JSON.stringify(e.bufferLayout));
    switch (this.device.type) {
      case "webgl":
        return `${t}/${n}V${i}BL${s}`;
      default:
        const l = this._getHash(JSON.stringify(e.parameters));
        return `${t}/${n}V${i}T${e.topology}P${l}BL${s}`;
    }
  }
  _getHash(e) {
    return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
  }
};
H(dy, "defaultProps", {
  ...kd.defaultProps
});
let $1 = dy;
const py = class py {
  /** @internal */
  constructor(e) {
    H(this, "device");
    H(this, "destroyPolicy");
    H(this, "_cache", {});
    this.device = e, this.destroyPolicy = e.props._factoryDestroyPolicy;
  }
  /** Returns the default ShaderFactory for the given {@link Device}, creating one if necessary. */
  static getDefaultShaderFactory(e) {
    var t;
    return (t = e._lumaData).defaultShaderFactory || (t.defaultShaderFactory = new py(e)), e._lumaData.defaultShaderFactory;
  }
  /** Requests a {@link Shader} from the cache, creating a new Shader only if necessary. */
  createShader(e) {
    const t = this._hashShader(e);
    let n = this._cache[t];
    if (!n) {
      const i = this.device.createShader({
        ...e,
        id: e.id ? `${e.id}-cached` : void 0
      });
      this._cache[t] = n = {
        shader: i,
        useCount: 0
      };
    }
    return n.useCount++, n.shader;
  }
  /** Releases a previously-requested {@link Shader}, destroying it if no users remain. */
  release(e) {
    const t = this._hashShader(e), n = this._cache[t];
    n && (n.useCount--, n.useCount === 0 && this.destroyPolicy === "unused" && (delete this._cache[t], n.shader.destroy()));
  }
  // PRIVATE
  _hashShader(e) {
    return `${e.stage}:${e.source}`;
  }
};
H(py, "defaultProps", {
  ...A_.defaultProps
});
let H1 = py;
function h8(r, e) {
  var i;
  const t = {}, n = "Values";
  if (r.attributes.length === 0 && !((i = r.varyings) != null && i.length))
    return {
      "No attributes or varyings": {
        [n]: "N/A"
      }
    };
  for (const s of r.attributes)
    if (s) {
      const l = `${s.location} ${s.name}: ${s.type}`;
      t[`in ${l}`] = {
        [n]: s.stepMode || "vertex"
      };
    }
  for (const s of r.varyings || []) {
    const l = `${s.location} ${s.name}`;
    t[`out ${l}`] = {
      [n]: JSON.stringify(s)
    };
  }
  return t;
}
let so = null, Kh = null;
function f8(r, e) {
  let {
    id: t,
    opaque: n,
    top: i = "0",
    left: s = "0",
    rgbaScale: l = 1
  } = e;
  so || (so = document.createElement("canvas"), so.id = t, so.title = t, so.style.zIndex = "100", so.style.position = "absolute", so.style.top = i, so.style.left = s, so.style.border = "blue 5px solid", so.style.transform = "scaleY(-1)", document.body.appendChild(so), Kh = so.getContext("2d")), (so.width !== r.width || so.height !== r.height) && (so.width = r.width / 2, so.height = r.height / 2, so.style.width = "400px", so.style.height = "400px");
  const o = r.device.readPixelsToArrayWebGL(r), d = Kh == null ? void 0 : Kh.createImageData(r.width, r.height);
  if (d) {
    for (let b = 0; b < o.length; b += 4)
      d.data[0 + b + 0] = o[b + 0] * l, d.data[0 + b + 1] = o[b + 1] * l, d.data[0 + b + 2] = o[b + 2] * l, d.data[0 + b + 3] = n ? 255 : o[b + 3] * l;
    Kh == null || Kh.putImageData(d, 0, 0);
  }
}
function W1(r, e, t) {
  if (r === e)
    return !0;
  if (!t || !r || !e)
    return !1;
  if (Array.isArray(r)) {
    if (!Array.isArray(e) || r.length !== e.length)
      return !1;
    for (let n = 0; n < r.length; n++)
      if (!W1(r[n], e[n], t - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof r == "object" && typeof e == "object") {
    const n = Object.keys(r), i = Object.keys(e);
    if (n.length !== i.length)
      return !1;
    for (const s of n)
      if (!e.hasOwnProperty(s) || !W1(r[s], e[s], t - 1))
        return !1;
    return !0;
  }
  return !1;
}
function d8(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function p8(r) {
  return Array.isArray(r) ? r.length === 0 || typeof r[0] == "number" : !1;
}
function hC(r) {
  return d8(r) || p8(r);
}
function g8(r) {
  return hC(r) || typeof r == "number" || typeof r == "boolean";
}
function fC(r) {
  const e = {
    bindings: {},
    uniforms: {}
  };
  return Object.keys(r).forEach((t) => {
    const n = r[t];
    g8(n) ? e.uniforms[t] = n : e.bindings[t] = n;
  }), e;
}
class m8 {
  /** Tracks if uniforms have changed */
  // moduleUniformsChanged: Record<keyof ShaderPropsT, false | string>;
  /**
   * Create a new UniformStore instance
   * @param modules
   */
  constructor(e, t) {
    H(this, "options", {
      disableWarnings: !1
    });
    /**
     * The map of modules
     * @todo should should this include the resolved dependencies?
     */
    // @ts-ignore Fix typings
    H(this, "modules");
    /** Stores the uniform values for each module */
    H(this, "moduleUniforms");
    /** Stores the uniform bindings for each module  */
    H(this, "moduleBindings");
    Object.assign(this.options, t);
    const n = e2(Object.values(e).filter((i) => i.dependencies));
    for (const i of n)
      e[i.name] = i;
    lr.log(1, "Creating ShaderInputs with modules", Object.keys(e))(), this.modules = e, this.moduleUniforms = {}, this.moduleBindings = {};
    for (const [i, s] of Object.entries(e))
      this._addModule(s), s.name && i !== s.name && !this.options.disableWarnings && lr.warn(`Module name: ${i} vs ${s.name}`)();
  }
  /** Destroy */
  destroy() {
  }
  /**
   * Set module props
   */
  setProps(e) {
    var t;
    for (const n of Object.keys(e)) {
      const i = n, s = e[i] || {}, l = this.modules[i];
      if (!l) {
        this.options.disableWarnings || lr.warn(`Module ${n} not found`)();
        continue;
      }
      const o = this.moduleUniforms[i], d = this.moduleBindings[i], m = ((t = l.getUniforms) == null ? void 0 : t.call(l, s, o)) || s, {
        uniforms: b,
        bindings: T
      } = fC(m);
      this.moduleUniforms[i] = {
        ...o,
        ...b
      }, this.moduleBindings[i] = {
        ...d,
        ...T
      };
    }
  }
  /**
   * Return the map of modules
   * @todo should should this include the resolved dependencies?
   */
  getModules() {
    return Object.values(this.modules);
  }
  /** Get all uniform values for all modules */
  getUniformValues() {
    return this.moduleUniforms;
  }
  /** Merges all bindings for the shader (from the various modules) */
  getBindingValues() {
    const e = {};
    for (const t of Object.values(this.moduleBindings))
      Object.assign(e, t);
    return e;
  }
  // INTERNAL
  /** Return a debug table that can be used for console.table() or log.table() */
  getDebugTable() {
    var t;
    const e = {};
    for (const [n, i] of Object.entries(this.moduleUniforms))
      for (const [s, l] of Object.entries(i))
        e[`${n}.${s}`] = {
          type: (t = this.modules[n].uniformTypes) == null ? void 0 : t[s],
          value: String(l)
        };
    return e;
  }
  _addModule(e) {
    const t = e.name;
    this.moduleUniforms[t] = e.defaultUniforms || {}, this.moduleBindings[t] = {};
  }
}
let _8 = "";
async function y8(r, e) {
  const t = new Image();
  return t.crossOrigin = "anonymous", t.src = r.startsWith("http") ? r : _8 + r, await t.decode(), e ? await createImageBitmap(t, e) : await createImageBitmap(t);
}
class ab {
  constructor(e, t) {
    H(this, "device");
    H(this, "id");
    // TODO - should we type these as possibly `null`? It will make usage harder?
    // @ts-expect-error
    H(this, "texture");
    // @ts-expect-error
    H(this, "sampler");
    // @ts-expect-error
    H(this, "view");
    H(this, "ready");
    H(this, "isReady", !1);
    H(this, "destroyed", !1);
    H(this, "resolveReady", () => {
    });
    H(this, "rejectReady", () => {
    });
    this.device = e, this.id = t.id || Rg("async-texture"), typeof (t == null ? void 0 : t.data) == "string" && t.dimension === "2d" && (t = {
      ...t,
      data: y8(t.data)
    }), this.ready = new Promise((n, i) => {
      this.resolveReady = () => {
        this.isReady = !0, n();
      }, this.rejectReady = i;
    }), this.initAsync(t);
  }
  get [Symbol.toStringTag]() {
    return "AsyncTexture";
  }
  toString() {
    return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
  }
  async initAsync(e) {
    let t, n;
    const i = e.data, s = await dC(i).then(t, n);
    if (this.destroyed)
      return;
    const l = {
      ...e,
      data: s
    };
    this.texture = this.device.createTexture(l), this.sampler = this.texture.sampler, this.view = this.texture.view, this.isReady = !0;
  }
  destroy() {
    this.texture && (this.texture.destroy(), this.texture = null), this.destroyed = !0;
  }
  /**
   * Textures are immutable and cannot be resized after creation,
   * but we can create a similar texture with the same parameters but a new size.
   * @note Does not copy contents of the texture
   * @todo Abort pending promise and create a texture with the new size?
   */
  resize(e) {
    if (!this.isReady)
      throw new Error("Cannot resize texture before it is ready");
    if (e.width === this.texture.width && e.height === this.texture.height)
      return !1;
    if (this.texture) {
      const t = this.texture;
      this.texture = t.clone(e), t.destroy();
    }
    return !0;
  }
}
async function dC(r) {
  if (r = await r, Array.isArray(r))
    return await Promise.all(r.map(dC));
  if (r && typeof r == "object" && r.constructor === Object) {
    const e = r, t = await Promise.all(Object.values(e)), n = Object.keys(e), i = {};
    for (let s = 0; s < n.length; s++)
      i[n[s]] = t[s];
    return i;
  }
  return r;
}
const Jh = 2, b8 = 1e4, gy = class gy {
  constructor(e, t) {
    H(this, "device");
    H(this, "id");
    // @ts-expect-error assigned in function called from constructor
    H(this, "source");
    // @ts-expect-error assigned in function called from constructor
    H(this, "vs");
    // @ts-expect-error assigned in function called from constructor
    H(this, "fs");
    H(this, "pipelineFactory");
    H(this, "shaderFactory");
    H(this, "userData", {});
    // Fixed properties (change can trigger pipeline rebuild)
    /** The render pipeline GPU parameters, depth testing etc */
    H(this, "parameters");
    /** The primitive topology */
    H(this, "topology");
    /** Buffer layout */
    H(this, "bufferLayout");
    // Dynamic properties
    /** Use instanced rendering */
    H(this, "isInstanced", void 0);
    /** instance count. `undefined` means not instanced */
    H(this, "instanceCount", 0);
    /** Vertex count */
    H(this, "vertexCount");
    /** Index buffer */
    H(this, "indexBuffer", null);
    /** Buffer-valued attributes */
    H(this, "bufferAttributes", {});
    /** Constant-valued attributes */
    H(this, "constantAttributes", {});
    /** Bindings (textures, samplers, uniform buffers) */
    H(this, "bindings", {});
    /** Sets uniforms @deprecated Use uniform buffers and setBindings() for portability*/
    H(this, "uniforms", {});
    /**
     * VertexArray
     * @note not implemented: if bufferLayout is updated, vertex array has to be rebuilt!
     * @todo - allow application to define multiple vertex arrays?
     * */
    H(this, "vertexArray");
    /** TransformFeedback, WebGL 2 only. */
    H(this, "transformFeedback", null);
    /** The underlying GPU "program". @note May be recreated if parameters change */
    H(this, "pipeline");
    /** ShaderInputs instance */
    // @ts-expect-error Assigned in function called by constructor
    H(this, "shaderInputs");
    // @ts-expect-error Assigned in function called by constructor
    H(this, "_uniformStore");
    H(this, "_attributeInfos", {});
    H(this, "_gpuGeometry", null);
    H(this, "_getModuleUniforms");
    H(this, "props");
    H(this, "_pipelineNeedsUpdate", "newly created");
    H(this, "_needsRedraw", "initializing");
    H(this, "_destroyed", !1);
    /** "Time" of last draw. Monotonically increasing timestamp */
    H(this, "_lastDrawTimestamp", -1);
    /** Throttle draw call logging */
    H(this, "_lastLogTime", 0);
    H(this, "_logOpen", !1);
    H(this, "_drawCount", 0);
    var d, m, b, T;
    this.props = {
      ...gy.defaultProps,
      ...t
    }, t = this.props, this.id = t.id || Rg("model"), this.device = e, Object.assign(this.userData, t.userData);
    const n = Object.fromEntries(((d = this.props.modules) == null ? void 0 : d.map((M) => [M.name, M])) || []), i = t.shaderInputs || new m8(n, {
      disableWarnings: this.props.disableWarnings
    });
    this.setShaderInputs(i);
    const s = x8(e), l = (
      // @ts-ignore shaderInputs is assigned in setShaderInputs above.
      (((m = this.props.modules) == null ? void 0 : m.length) > 0 ? this.props.modules : (b = this.shaderInputs) == null ? void 0 : b.getModules()) || []
    );
    if (this.device.type === "webgpu" && this.props.source) {
      (T = this.props).shaderLayout || (T.shaderLayout = eN(this.props.source));
      const {
        source: M,
        getUniforms: E
      } = this.props.shaderAssembler.assembleWGSLShader({
        platformInfo: s,
        ...this.props,
        modules: l
      });
      this.source = M, this._getModuleUniforms = E;
    } else {
      const {
        vs: M,
        fs: E,
        getUniforms: D
      } = this.props.shaderAssembler.assembleGLSLShaderPair({
        platformInfo: s,
        ...this.props,
        modules: l
      });
      this.vs = M, this.fs = E, this._getModuleUniforms = D;
    }
    this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, t.geometry && this.setGeometry(t.geometry), this.pipelineFactory = t.pipelineFactory || $1.getDefaultPipelineFactory(this.device), this.shaderFactory = t.shaderFactory || H1.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = e.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), "isInstanced" in t && (this.isInstanced = t.isInstanced), t.instanceCount && this.setInstanceCount(t.instanceCount), t.vertexCount && this.setVertexCount(t.vertexCount), t.indexBuffer && this.setIndexBuffer(t.indexBuffer), t.attributes && this.setAttributes(t.attributes), t.constantAttributes && this.setConstantAttributes(t.constantAttributes), t.bindings && this.setBindings(t.bindings), t.uniforms && this.setUniformsWebGL(t.uniforms), t.moduleSettings && this.updateModuleSettingsWebGL(t.moduleSettings), t.transformFeedback && (this.transformFeedback = t.transformFeedback), Object.seal(this);
  }
  get [Symbol.toStringTag]() {
    return "Model";
  }
  toString() {
    return `Model(${this.id})`;
  }
  destroy() {
    var e;
    this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), (e = this._gpuGeometry) == null || e.destroy(), this._destroyed = !0);
  }
  // Draw call
  /** Query redraw status. Clears the status. */
  needsRedraw() {
    this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp && this.setNeedsRedraw("contents of bound textures or buffers updated");
    const e = this._needsRedraw;
    return this._needsRedraw = !1, e;
  }
  /** Mark the model as needing a redraw */
  setNeedsRedraw(e) {
    this._needsRedraw || (this._needsRedraw = e);
  }
  predraw() {
    this.updateShaderInputs(), this.pipeline = this._updatePipeline();
  }
  draw(e) {
    const t = this._areBindingsLoading();
    if (t)
      return lr.info(Jh, `>>> DRAWING ABORTED ${this.id}: ${t} not loaded`)(), !1;
    try {
      e.pushDebugGroup(`${this}.predraw(${e})`), this.predraw();
    } finally {
      e.popDebugGroup();
    }
    let n;
    try {
      e.pushDebugGroup(`${this}.draw(${e})`), this._logDrawCallStart(), this.pipeline = this._updatePipeline();
      const i = this._getBindings();
      this.pipeline.setBindings(i, {
        disableWarnings: this.props.disableWarnings
      }), X1(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
      const {
        indexBuffer: s
      } = this.vertexArray, l = s ? s.byteLength / (s.indexType === "uint32" ? 4 : 2) : void 0;
      n = this.pipeline.draw({
        renderPass: e,
        vertexArray: this.vertexArray,
        isInstanced: this.isInstanced,
        vertexCount: this.vertexCount,
        instanceCount: this.instanceCount,
        indexCount: l,
        transformFeedback: this.transformFeedback || void 0,
        // WebGL shares underlying cached pipelines even for models that have different parameters and topology,
        // so we must provide our unique parameters to each draw
        // (In WebGPU most parameters are encoded in the pipeline and cannot be changed per draw call)
        parameters: this.parameters,
        topology: this.topology
      });
    } finally {
      e.popDebugGroup(), this._logDrawCallEnd();
    }
    return this._logFramebuffer(e), n ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", n;
  }
  // Update fixed fields (can trigger pipeline rebuild)
  /**
   * Updates the optional geometry
   * Geometry, set topology and bufferLayout
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setGeometry(e) {
    var n;
    (n = this._gpuGeometry) == null || n.destroy();
    const t = e && l8(this.device, e);
    if (t) {
      this.setTopology(t.topology || "triangle-list");
      const i = new Y0(this.bufferLayout);
      this.bufferLayout = i.mergeBufferLayouts(t.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(t);
    }
    this._gpuGeometry = t;
  }
  /**
   * Updates the primitive topology ('triangle-list', 'triangle-strip' etc).
   * @note Triggers a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  setTopology(e) {
    e !== this.topology && (this.topology = e, this._setPipelineNeedsUpdate("topology"));
  }
  /**
   * Updates the buffer layout.
   * @note Triggers a pipeline rebuild / pipeline cache fetch
   */
  setBufferLayout(e) {
    const t = new Y0(this.bufferLayout);
    this.bufferLayout = this._gpuGeometry ? t.mergeBufferLayouts(e, this._gpuGeometry.bufferLayout) : e, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
      renderPipeline: this.pipeline
    }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry);
  }
  /**
   * Set GPU parameters.
   * @note Can trigger a pipeline rebuild / pipeline cache fetch.
   * @param parameters
   */
  setParameters(e) {
    W1(e, this.parameters, 2) || (this.parameters = e, this._setPipelineNeedsUpdate("parameters"));
  }
  // Update dynamic fields
  /**
   * Updates the instance count (used in draw calls)
   * @note Any attributes with stepMode=instance need to be at least this big
   */
  setInstanceCount(e) {
    this.instanceCount = e, this.isInstanced === void 0 && e > 0 && (this.isInstanced = !0), this.setNeedsRedraw("instanceCount");
  }
  /**
   * Updates the vertex count (used in draw calls)
   * @note Any attributes with stepMode=vertex need to be at least this big
   */
  setVertexCount(e) {
    this.vertexCount = e, this.setNeedsRedraw("vertexCount");
  }
  /** Set the shader inputs */
  setShaderInputs(e) {
    this.shaderInputs = e, this._uniformStore = new T6(this.shaderInputs.modules);
    for (const [t, n] of Object.entries(this.shaderInputs.modules))
      if (v8(n)) {
        const i = this._uniformStore.getManagedUniformBuffer(this.device, t);
        this.bindings[`${t}Uniforms`] = i;
      }
    this.setNeedsRedraw("shaderInputs");
  }
  /** Update uniform buffers from the model's shader inputs */
  updateShaderInputs() {
    this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()), this.setBindings(this.shaderInputs.getBindingValues()), this.setNeedsRedraw("shaderInputs");
  }
  /**
   * Sets bindings (textures, samplers, uniform buffers)
   */
  setBindings(e) {
    Object.assign(this.bindings, e), this.setNeedsRedraw("bindings");
  }
  /**
   * Updates optional transform feedback. WebGL only.
   */
  setTransformFeedback(e) {
    this.transformFeedback = e, this.setNeedsRedraw("transformFeedback");
  }
  /**
   * Sets the index buffer
   * @todo - how to unset it if we change geometry?
   */
  setIndexBuffer(e) {
    this.vertexArray.setIndexBuffer(e), this.setNeedsRedraw("indexBuffer");
  }
  /**
   * Sets attributes (buffers)
   * @note Overrides any attributes previously set with the same name
   */
  setAttributes(e, t) {
    const n = (t == null ? void 0 : t.disableWarnings) ?? this.props.disableWarnings;
    e.indices && lr.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)();
    const i = new Y0(this.bufferLayout);
    for (const [s, l] of Object.entries(e)) {
      const o = i.getBufferLayout(s);
      if (!o) {
        n || lr.warn(`Model(${this.id}): Missing layout for buffer "${s}".`)();
        continue;
      }
      const d = i.getAttributeNamesForBuffer(o);
      let m = !1;
      for (const b of d) {
        const T = this._attributeInfos[b];
        T && (this.vertexArray.setBuffer(T.location, l), m = !0);
      }
      !m && !n && lr.warn(`Model(${this.id}): Ignoring buffer "${l.id}" for unknown attribute "${s}"`)();
    }
    this.setNeedsRedraw("attributes");
  }
  /**
   * Sets constant attributes
   * @note Overrides any attributes previously set with the same name
   * Constant attributes are only supported in WebGL, not in WebGPU
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @param constantAttributes
   */
  setConstantAttributes(e, t) {
    for (const [n, i] of Object.entries(e)) {
      const s = this._attributeInfos[n];
      s ? this.vertexArray.setConstantWebGL(s.location, i) : ((t == null ? void 0 : t.disableWarnings) ?? this.props.disableWarnings) || lr.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${n}"`)();
    }
    this.setNeedsRedraw("constants");
  }
  // DEPRECATED METHODS
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniforms(e) {
    this.setUniformsWebGL(e);
  }
  /**
   * Sets individual uniforms
   * @deprecated WebGL only, use uniform buffers for portability
   * @param uniforms
   */
  setUniformsWebGL(e) {
    X1(e) || (this.pipeline.setUniformsWebGL(e), Object.assign(this.uniforms, e)), this.setNeedsRedraw("uniforms");
  }
  /**
   * @deprecated Updates shader module settings (which results in uniforms being set)
   */
  updateModuleSettingsWebGL(e) {
    const {
      bindings: t,
      uniforms: n
    } = fC(this._getModuleUniforms(e));
    Object.assign(this.bindings, t), Object.assign(this.uniforms, n), this.setNeedsRedraw("moduleSettings");
  }
  // Internal methods
  /** Check that bindings are loaded. Returns id of first binding that is still loading. */
  _areBindingsLoading() {
    for (const e of Object.values(this.bindings))
      if (e instanceof ab && !e.isReady)
        return e.id;
    return !1;
  }
  /** Extracts texture view from loaded async textures. Returns null if any textures have not yet been loaded. */
  _getBindings() {
    const e = {};
    for (const [t, n] of Object.entries(this.bindings))
      n instanceof ab ? n.isReady && (e[t] = n.texture) : e[t] = n;
    return e;
  }
  /** Get the timestamp of the latest updated bound GPU memory resource (buffer/texture). */
  _getBindingsUpdateTimestamp() {
    let e = 0;
    for (const t of Object.values(this.bindings))
      t instanceof w_ ? e = Math.max(e, t.texture.updateTimestamp) : t instanceof Ss || t instanceof Wi ? e = Math.max(e, t.updateTimestamp) : t instanceof ab ? e = t.texture ? Math.max(e, t.texture.updateTimestamp) : (
        // The texture will become available in the future
        1 / 0
      ) : t instanceof T_ || (e = Math.max(e, t.buffer.updateTimestamp));
    return e;
  }
  /**
   * Updates the optional geometry attributes
   * Geometry, sets several attributes, indexBuffer, and also vertex count
   * @note Can trigger a pipeline rebuild / pipeline cache fetch on WebGPU
   */
  _setGeometryAttributes(e) {
    const t = {
      ...e.attributes
    };
    for (const [n] of Object.entries(t))
      !this.pipeline.shaderLayout.attributes.find((i) => i.name === n) && n !== "positions" && delete t[n];
    this.vertexCount = e.vertexCount, this.setIndexBuffer(e.indices || null), this.setAttributes(e.attributes, {
      disableWarnings: !0
    }), this.setAttributes(t, {
      disableWarnings: this.props.disableWarnings
    }), this.setNeedsRedraw("geometry attributes");
  }
  /** Mark pipeline as needing update */
  _setPipelineNeedsUpdate(e) {
    this._pipelineNeedsUpdate || (this._pipelineNeedsUpdate = e), this.setNeedsRedraw(e);
  }
  /** Update pipeline if needed */
  _updatePipeline() {
    if (this._pipelineNeedsUpdate) {
      let e = null, t = null;
      this.pipeline && (lr.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), e = this.pipeline.vs, t = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
      const n = this.shaderFactory.createShader({
        id: `${this.id}-vertex`,
        stage: "vertex",
        source: this.source || this.vs,
        debugShaders: this.props.debugShaders
      });
      let i = null;
      this.source ? i = n : this.fs && (i = this.shaderFactory.createShader({
        id: `${this.id}-fragment`,
        stage: "fragment",
        source: this.source || this.fs,
        debugShaders: this.props.debugShaders
      })), this.pipeline = this.pipelineFactory.createRenderPipeline({
        ...this.props,
        bufferLayout: this.bufferLayout,
        topology: this.topology,
        parameters: this.parameters,
        // TODO - why set bindings here when we reset them every frame?
        // Should we expose a BindGroup abstraction?
        bindings: this._getBindings(),
        vs: n,
        fs: i
      }), this._attributeInfos = KE(this.pipeline.shaderLayout, this.bufferLayout), e && this.shaderFactory.release(e), t && this.shaderFactory.release(t);
    }
    return this.pipeline;
  }
  _logDrawCallStart() {
    const e = lr.level > 3 ? 0 : b8;
    lr.level < 2 || Date.now() - this._lastLogTime < e || (this._lastLogTime = Date.now(), this._logOpen = !0, lr.group(Jh, `>>> DRAWING MODEL ${this.id}`, {
      collapsed: lr.level <= 2
    })());
  }
  _logDrawCallEnd() {
    if (this._logOpen) {
      const e = h8(this.pipeline.shaderLayout, this.id);
      lr.table(Jh, e)();
      const t = this.shaderInputs.getDebugTable();
      for (const [i, s] of Object.entries(this.uniforms))
        t[i] = {
          value: s
        };
      lr.table(Jh, t)();
      const n = this._getAttributeDebugTable();
      lr.table(Jh, this._attributeInfos)(), lr.table(Jh, n)(), lr.groupEnd(Jh)(), this._logOpen = !1;
    }
  }
  _logFramebuffer(e) {
    const t = this.device.props.debugFramebuffers;
    if (this._drawCount++, !t)
      return;
    const n = e.props.framebuffer;
    n && f8(n, {
      id: n.id
    });
  }
  _getAttributeDebugTable() {
    const e = {};
    for (const [t, n] of Object.entries(this._attributeInfos)) {
      const i = this.vertexArray.attributes[n.location];
      e[n.location] = {
        name: t,
        type: n.shaderType,
        values: i ? this._getBufferOrConstantValues(i, n.bufferDataType) : "null"
      };
    }
    if (this.vertexArray.indexBuffer) {
      const {
        indexBuffer: t
      } = this.vertexArray, n = t.indexType === "uint32" ? new Uint32Array(t.debugData) : new Uint16Array(t.debugData);
      e.indices = {
        name: "indices",
        type: t.indexType,
        values: n.toString()
      };
    }
    return e;
  }
  // TODO - fix typing of luma data types
  _getBufferOrConstantValues(e, t) {
    const n = e5(t);
    return (e instanceof Ss ? new n(e.debugData) : e).toString();
  }
};
H(gy, "defaultProps", {
  ...kd.defaultProps,
  source: void 0,
  vs: null,
  fs: null,
  id: "unnamed",
  handle: void 0,
  userData: {},
  defines: {},
  modules: [],
  moduleSettings: void 0,
  geometry: null,
  indexBuffer: null,
  attributes: {},
  constantAttributes: {},
  varyings: [],
  isInstanced: void 0,
  instanceCount: 0,
  vertexCount: 0,
  shaderInputs: void 0,
  pipelineFactory: void 0,
  shaderFactory: void 0,
  transformFeedback: void 0,
  shaderAssembler: x_.getDefaultShaderAssembler(),
  debugShaders: void 0,
  disableWarnings: void 0
});
let Lh = gy;
function v8(r) {
  return !!(r.uniformTypes && !X1(r.uniformTypes));
}
function x8(r) {
  return {
    type: r.type,
    shaderLanguage: r.info.shadingLanguage,
    shaderLanguageVersion: r.info.shadingLanguageVersion,
    gpu: r.info.gpu,
    // HACK - we pretend that the DeviceFeatures is a Set, it has a similar API
    features: r.features
  };
}
function X1(r) {
  for (const e in r)
    return !1;
  return !0;
}
const ug = class ug {
  constructor(e) {
    H(this, "device");
    H(this, "model");
    H(this, "transformFeedback");
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ug.defaultProps;
    if (!ug.isSupported(e))
      throw new Error("BufferTransform not yet implemented on WebGPU");
    this.device = e, this.model = new Lh(this.device, {
      id: t.id || "buffer-transform-model",
      fs: t.fs || CO(),
      topology: t.topology || "point-list",
      varyings: t.outputs || t.varyings,
      ...t
    }), this.transformFeedback = this.device.createTransformFeedback({
      layout: this.model.pipeline.shaderLayout,
      // @ts-expect-error TODO
      buffers: t.feedbackBuffers
    }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this);
  }
  static isSupported(e) {
    var t;
    return ((t = e == null ? void 0 : e.info) == null ? void 0 : t.type) === "webgl";
  }
  /** Destroy owned resources. */
  destroy() {
    this.model && this.model.destroy();
  }
  /** @deprecated Use {@link destroy}. */
  delete() {
    this.destroy();
  }
  /** Run one transform loop. */
  run(e) {
    e != null && e.inputBuffers && this.model.setAttributes(e.inputBuffers), e != null && e.outputBuffers && this.transformFeedback.setBuffers(e.outputBuffers);
    const t = this.device.beginRenderPass(e);
    this.model.draw(t), t.end();
  }
  // DEPRECATED METHODS
  /** @deprecated App knows what buffers it is passing in - Returns the {@link Buffer} or {@link BufferRange} for given varying name. */
  getBuffer(e) {
    return this.transformFeedback.getBuffer(e);
  }
  /** @deprecated App knows what buffers it is passing in - Reads the {@link Buffer} or {@link BufferRange} for given varying name. */
  readAsync(e) {
    const t = this.getBuffer(e);
    if (!t)
      throw new Error("BufferTransform#getBuffer");
    if (t instanceof Ss)
      return t.readAsync();
    const {
      buffer: n,
      byteOffset: i = 0,
      byteLength: s = n.byteLength
    } = t;
    return n.readAsync(i, s);
  }
};
H(ug, "defaultProps", {
  ...Lh.defaultProps,
  outputs: void 0,
  feedbackBuffers: void 0
});
let _g = ug;
class Id {
  constructor(e) {
    H(this, "id");
    /** Determines how vertices are read from the 'vertex' attributes */
    H(this, "topology");
    H(this, "vertexCount");
    H(this, "indices");
    H(this, "attributes");
    H(this, "userData", {});
    const {
      attributes: t = {},
      indices: n = null,
      vertexCount: i = null
    } = e;
    this.id = e.id || Rg("geometry"), this.topology = e.topology, n && (this.indices = ArrayBuffer.isView(n) ? {
      value: n,
      size: 1
    } : n), this.attributes = {};
    for (const [s, l] of Object.entries(t)) {
      const o = ArrayBuffer.isView(l) ? {
        value: l
      } : l;
      if (!ArrayBuffer.isView(o.value))
        throw new Error(`${this._print(s)}: must be typed array or object with value as typed array`);
      if ((s === "POSITION" || s === "positions") && !o.size && (o.size = 3), s === "indices") {
        if (this.indices)
          throw new Error("Multiple indices detected");
        this.indices = o;
      } else
        this.attributes[s] = o;
    }
    this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = i || this._calculateVertexCount(this.attributes, this.indices);
  }
  getVertexCount() {
    return this.vertexCount;
  }
  /**
   * Return an object with all attributes plus indices added as a field.
   * TODO Geometry types are a mess
   */
  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }
  // PRIVATE
  _print(e) {
    return `Geometry ${this.id} attribute ${e}`;
  }
  /**
   * GeometryAttribute
   * value: typed array
   * type: indices, vertices, uvs
   * size: elements per vertex
   * target: WebGL buffer type (string or constant)
   *
   * @param attributes
   * @param indices
   * @returns
   */
  _setAttributes(e, t) {
    return this;
  }
  _calculateVertexCount(e, t) {
    if (t)
      return t.value.length;
    let n = 1 / 0;
    for (const i of Object.values(e)) {
      const {
        value: s,
        size: l,
        constant: o
      } = i;
      !o && s && l !== void 0 && l >= 1 && (n = Math.min(n, s.length / l));
    }
    return n;
  }
}
class z_ {
  constructor() {
    H(this, "id");
    H(this, "matrix", new Cn());
    H(this, "display", !0);
    H(this, "position", new Tt());
    H(this, "rotation", new Tt());
    H(this, "scale", new Tt(1, 1, 1));
    H(this, "userData", {});
    H(this, "props", {});
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      id: t
    } = e;
    this.id = t || Rg(this.constructor.name), this._setScenegraphNodeProps(e);
  }
  getBounds() {
    return null;
  }
  destroy() {
  }
  /** @deprecated use .destroy() */
  delete() {
    this.destroy();
  }
  setProps(e) {
    return this._setScenegraphNodeProps(e), this;
  }
  toString() {
    return `{type: ScenegraphNode, id: ${this.id})}`;
  }
  setPosition(e) {
    return this.position = e, this;
  }
  setRotation(e) {
    return this.rotation = e, this;
  }
  setScale(e) {
    return this.scale = e, this;
  }
  setMatrix(e) {
    (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? this.matrix.copy(e) : this.matrix = e;
  }
  setMatrixComponents(e) {
    const {
      position: t,
      rotation: n,
      scale: i,
      update: s = !0
    } = e;
    return t && this.setPosition(t), n && this.setRotation(n), i && this.setScale(i), s && this.updateMatrix(), this;
  }
  updateMatrix() {
    const e = this.position, t = this.rotation, n = this.scale;
    return this.matrix.identity(), this.matrix.translate(e), this.matrix.rotateXYZ(t), this.matrix.scale(n), this;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      position: t,
      rotation: n,
      scale: i
    } = e;
    return t && this.setPosition(t), n && this.setRotation(n), i && this.setScale(i), this.updateMatrix(), this;
  }
  getCoordinateUniforms(e, t) {
    t = t || this.matrix;
    const n = new Cn(e).multiplyRight(t), i = n.invert(), s = i.transpose();
    return {
      viewMatrix: e,
      modelMatrix: t,
      objectMatrix: t,
      worldMatrix: n,
      worldInverseMatrix: i,
      worldInverseTransposeMatrix: s
    };
  }
  // TODO - copied code, not yet vetted
  /*
  transform() {
    if (!this.parent) {
      this.endPosition.set(this.position);
      this.endRotation.set(this.rotation);
      this.endScale.set(this.scale);
    } else {
      const parent = this.parent;
      this.endPosition.set(this.position.add(parent.endPosition));
      this.endRotation.set(this.rotation.add(parent.endRotation));
      this.endScale.set(this.scale.add(parent.endScale));
    }
       const ch = this.children;
    for (let i = 0; i < ch.length; ++i) {
      ch[i].transform();
    }
       return this;
  }
  */
  _setScenegraphNodeProps(e) {
    "position" in e && this.setPosition(e.position), "rotation" in e && this.setRotation(e.rotation), "scale" in e && this.setScale(e.scale), "matrix" in e && this.setMatrix(e.matrix), Object.assign(this.props, e);
  }
}
class Md extends z_ {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    t = Array.isArray(t) ? {
      children: t
    } : t;
    const {
      children: n = []
    } = t;
    lr.assert(n.every((i) => i instanceof z_), "every child must an instance of ScenegraphNode");
    super(t);
    H(this, "children");
    this.children = n;
  }
  getBounds() {
    const t = [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
    return this.traverse((n, i) => {
      let {
        worldMatrix: s
      } = i;
      const l = n.getBounds();
      if (!l)
        return;
      const [o, d] = l, m = new Tt(o).add(d).divide([2, 2, 2]);
      s.transformAsPoint(m, m);
      const b = new Tt(d).subtract(o).divide([2, 2, 2]);
      s.transformAsVector(b, b);
      for (let T = 0; T < 8; T++) {
        const M = new Tt(T & 1 ? -1 : 1, T & 2 ? -1 : 1, T & 4 ? -1 : 1).multiply(b).add(m);
        for (let E = 0; E < 3; E++)
          t[0][E] = Math.min(t[0][E], M[E]), t[1][E] = Math.max(t[1][E], M[E]);
      }
    }), Number.isFinite(t[0][0]) ? t : null;
  }
  destroy() {
    this.children.forEach((t) => t.destroy()), this.removeAll(), super.destroy();
  }
  // Unpacks arrays and nested arrays of children
  add() {
    for (var t = arguments.length, n = new Array(t), i = 0; i < t; i++)
      n[i] = arguments[i];
    for (const s of n)
      Array.isArray(s) ? this.add(...s) : this.children.push(s);
    return this;
  }
  remove(t) {
    const n = this.children, i = n.indexOf(t);
    return i > -1 && n.splice(i, 1), this;
  }
  removeAll() {
    return this.children = [], this;
  }
  traverse(t) {
    let {
      worldMatrix: n = new Cn()
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = new Cn(n).multiplyRight(this.matrix);
    for (const s of this.children)
      s instanceof Md ? s.traverse(t, {
        worldMatrix: i
      }) : t(s, {
        worldMatrix: i
      });
  }
}
class Z1 extends z_ {
  // TODO - is this used? override callbacks to make sure we call them with this
  // onBeforeRender = null;
  // onAfterRender = null;
  // AfterRender = null;
  constructor(t) {
    super(t);
    H(this, "model");
    H(this, "bounds", null);
    H(this, "managedResources");
    this.model = t.model, this.managedResources = t.managedResources || [], this.bounds = t.bounds || null, this.setProps(t);
  }
  destroy() {
    this.model && (this.model.destroy(), this.model = null), this.managedResources.forEach((t) => t.destroy()), this.managedResources = [];
  }
  getBounds() {
    return this.bounds;
  }
  // Expose model methods
  draw(t) {
    return this.model.draw(t);
  }
}
const w8 = {
  blendColorOperation: "add",
  blendColorSrcFactor: "one",
  blendColorDstFactor: "zero",
  blendAlphaOperation: "add",
  blendAlphaSrcFactor: "constant-alpha",
  blendAlphaDstFactor: "zero"
};
class pC extends T2 {
  constructor() {
    super(...arguments), this._colorEncoderState = null;
  }
  render(e) {
    return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
  }
  // Private
  // Draws list of layers and viewports into the picking buffer
  // Note: does not sample the buffer, that has to be done by the caller
  _drawPickingBuffer(e) {
    let {
      layers: t,
      layerFilter: n,
      views: i,
      viewports: s,
      onViewportActive: l,
      pickingFBO: o,
      deviceRect: {
        x: d,
        y: m,
        width: b,
        height: T
      },
      cullRect: M,
      effects: E,
      pass: D = "picking",
      pickZ: U,
      shaderModuleProps: q
    } = e;
    this.pickZ = U;
    const G = this._resetColorEncoder(U), Y = [d, m, b, T], he = super.render({
      target: o,
      layers: t,
      layerFilter: n,
      views: i,
      viewports: s,
      onViewportActive: l,
      cullRect: M,
      effects: E == null ? void 0 : E.filter((J) => J.useInPicking),
      pass: D,
      isPicking: !0,
      shaderModuleProps: q,
      clearColor: [0, 0, 0, 0],
      colorMask: 15,
      scissorRect: Y
    });
    return this._colorEncoderState = null, {
      decodePickingColor: G && T8.bind(null, G),
      stats: he
    };
  }
  shouldDrawLayer(e) {
    const {
      pickable: t,
      operation: n
    } = e.props;
    return t && n.includes("draw") || n.includes("terrain") || n.includes("mask");
  }
  getShaderModuleProps(e, t, n) {
    return {
      picking: {
        isActive: 1,
        isAttribute: this.pickZ
      },
      lighting: {
        enabled: !1
      }
    };
  }
  getLayerParameters(e, t, n) {
    const i = {
      ...e.props.parameters
    }, {
      pickable: s,
      operation: l
    } = e.props;
    return !this._colorEncoderState || l.includes("terrain") ? i.blend = !1 : s && l.includes("draw") && (Object.assign(i, w8), i.blend = !0, i.blendColor = A8(this._colorEncoderState, e, n)), i;
  }
  _resetColorEncoder(e) {
    return this._colorEncoderState = e ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    }, this._colorEncoderState;
  }
}
function A8(r, e, t) {
  const {
    byLayer: n,
    byAlpha: i
  } = r;
  let s, l = n.get(e);
  return l ? (l.viewports.push(t), s = l.a) : (s = n.size + 1, s <= 255 ? (l = {
    a: s,
    layer: e,
    viewports: [t]
  }, n.set(e, l), i[s] = l) : (qn.warn("Too many pickable layers, only picking the first 255")(), s = 0)), [0, 0, 0, s / 255];
}
function T8(r, e) {
  const t = r.byAlpha[e[3]];
  return t && {
    pickedLayer: t.layer,
    pickedViewports: t.viewports,
    pickedObjectIndex: t.layer.decodePickingColor(e)
  };
}
const fd = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
}, j_ = Symbol.for("component"), Ih = Symbol.for("propTypes"), lb = Symbol.for("deprecatedProps"), Pd = Symbol.for("asyncPropDefaults"), If = Symbol.for("asyncPropOriginal"), Ah = Symbol.for("asyncPropResolved");
function jd(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => !0;
  return Array.isArray(r) ? gC(r, e, []) : e(r) ? [r] : [];
}
function gC(r, e, t) {
  let n = -1;
  for (; ++n < r.length; ) {
    const i = r[n];
    Array.isArray(i) ? gC(i, e, t) : e(i) && t.push(i);
  }
  return t;
}
function S8(r) {
  let {
    target: e,
    source: t,
    start: n = 0,
    count: i = 1
  } = r;
  const s = t.length, l = i * s;
  let o = 0;
  for (let d = n; o < s; o++)
    e[d++] = t[o];
  for (; o < l; )
    o < l - o ? (e.copyWithin(n + o, n, n + o), o *= 2) : (e.copyWithin(n + o, n, n + l - o), o = l);
  return e;
}
class E8 {
  constructor(e, t, n) {
    this._loadCount = 0, this._subscribers = /* @__PURE__ */ new Set(), this.id = e, this.context = n, this.setData(t);
  }
  // consumer: {onChange: Function}
  subscribe(e) {
    this._subscribers.add(e);
  }
  unsubscribe(e) {
    this._subscribers.delete(e);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(e, t) {
    if (e === this._data && !t)
      return;
    this._data = e;
    const n = ++this._loadCount;
    let i = e;
    typeof e == "string" && (i = Ph(e)), i instanceof Promise ? (this.isLoaded = !1, this._loader = i.then((s) => {
      this._loadCount === n && (this.isLoaded = !0, this._error = void 0, this._content = s);
    }).catch((s) => {
      this._loadCount === n && (this.isLoaded = !0, this._error = s || !0);
    })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
    for (const s of this._subscribers)
      s.onChange(this.getData());
  }
}
class C8 {
  constructor(e) {
    var t;
    this.protocol = e.protocol || "resource://", this._context = {
      device: e.device,
      // @ts-expect-error
      gl: (t = e.device) == null ? void 0 : t.gl,
      resourceManager: this
    }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
  }
  contains(e) {
    return e.startsWith(this.protocol) ? !0 : e in this._resources;
  }
  add(e) {
    let {
      resourceId: t,
      data: n,
      forceUpdate: i = !1,
      persistent: s = !0
    } = e, l = this._resources[t];
    l ? l.setData(n, i) : (l = new E8(t, n, this._context), this._resources[t] = l), l.persistent = s;
  }
  remove(e) {
    const t = this._resources[e];
    t && (t.delete(), delete this._resources[e]);
  }
  unsubscribe(e) {
    let {
      consumerId: t
    } = e;
    const n = this._consumers[t];
    if (n) {
      for (const i in n) {
        const s = n[i], l = this._resources[s.resourceId];
        l && l.unsubscribe(s);
      }
      delete this._consumers[t], this.prune();
    }
  }
  subscribe(e) {
    let {
      resourceId: t,
      onChange: n,
      consumerId: i,
      requestId: s = "default"
    } = e;
    const {
      _resources: l,
      protocol: o
    } = this;
    t.startsWith(o) && (t = t.replace(o, ""), l[t] || this.add({
      resourceId: t,
      data: null,
      persistent: !1
    }));
    const d = l[t];
    if (this._track(i, s, d, n), d)
      return d.getData();
  }
  prune() {
    this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
  }
  finalize() {
    for (const e in this._resources)
      this._resources[e].delete();
  }
  _track(e, t, n, i) {
    const s = this._consumers, l = s[e] = s[e] || {};
    let o = l[t];
    const d = o && o.resourceId && this._resources[o.resourceId];
    d && (d.unsubscribe(o), this.prune()), n && (o ? (o.onChange = i, o.resourceId = n.id) : o = {
      onChange: i,
      resourceId: n.id
    }, l[t] = o, n.subscribe(o));
  }
  _prune() {
    this._pruneRequest = null;
    for (const e of Object.keys(this._resources)) {
      const t = this._resources[e];
      !t.persistent && !t.inUse() && (t.delete(), delete this._resources[e]);
    }
  }
}
const I8 = "layerManager.setLayers", M8 = "layerManager.activateViewport";
class P8 {
  /**
   * @param device
   * @param param1
   */
  // eslint-disable-next-line
  constructor(e, t) {
    this._lastRenderedLayers = [], this._needsRedraw = !1, this._needsUpdate = !1, this._nextLayers = null, this._debug = !1, this._defaultShaderModulesChanged = !1, this.activateViewport = (o) => {
      Vo(M8, this, o), o && (this.context.viewport = o);
    };
    const {
      deck: n,
      stats: i,
      viewport: s,
      timeline: l
    } = t || {};
    this.layers = [], this.resourceManager = new C8({
      device: e,
      protocol: "deck://"
    }), this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      device: e,
      // @ts-expect-error
      gl: e == null ? void 0 : e.gl,
      deck: n,
      shaderAssembler: PF(),
      defaultShaderModules: [XD],
      renderPass: void 0,
      stats: i || new Yd({
        id: "deck.gl"
      }),
      // Make sure context.viewport is not empty on the first layer initialization
      viewport: s || new Qd({
        id: "DEFAULT-INITIAL-VIEWPORT"
      }),
      // Current viewport, exposed to layers for project* function
      timeline: l || new uC(),
      resourceManager: this.resourceManager,
      onError: void 0
    }, Object.seal(this);
  }
  /** Method to call when the layer manager is not needed anymore. */
  finalize() {
    this.resourceManager.finalize();
    for (const e of this.layers)
      this._finalizeLayer(e);
  }
  /** Check if a redraw is needed */
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    }, t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    for (const n of this.layers) {
      const i = n.getNeedsRedraw(e);
      t = t || i;
    }
    return t;
  }
  /** Check if a deep update of all layers is needed */
  needsUpdate() {
    return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate;
  }
  /** Layers will be redrawn (in next animation frame) */
  setNeedsRedraw(e) {
    this._needsRedraw = this._needsRedraw || e;
  }
  /** Layers will be updated deeply (in next animation frame)
    Potentially regenerating attributes and sub layers */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e;
  }
  /** Gets a list of currently rendered layers. Optionally filter by id. */
  getLayers() {
    let {
      layerIds: e
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e ? this.layers.filter((t) => e.find((n) => t.id.indexOf(n) === 0)) : this.layers;
  }
  /** Set props needed for layer rendering and picking. */
  setProps(e) {
    "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
  }
  /** Supply a new layer list, initiating sublayer generation and layer matching */
  setLayers(e, t) {
    Vo(I8, this, t, e), this._lastRenderedLayers = e;
    const n = jd(e, Boolean);
    for (const i of n)
      i.context = this.context;
    this._updateLayers(this.layers, n);
  }
  /** Update layers from last cycle if `setNeedsUpdate()` has been called */
  updateLayers() {
    const e = this.needsUpdate();
    e && (this.setNeedsRedraw(`updating layers: ${e}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
  }
  /** Register a default shader module */
  addDefaultShaderModule(e) {
    const {
      defaultShaderModules: t
    } = this.context;
    t.find((n) => n.name === e.name) || (t.push(e), this._defaultShaderModulesChanged = !0);
  }
  /** Deregister a default shader module */
  removeDefaultShaderModule(e) {
    const {
      defaultShaderModules: t
    } = this.context, n = t.findIndex((i) => i.name === e.name);
    n >= 0 && (t.splice(n, 1), this._defaultShaderModulesChanged = !0);
  }
  _handleError(e, t, n) {
    n.raiseError(t, `${e} of ${n}`);
  }
  // TODO - mark layers with exceptions as bad and remove from rendering cycle?
  /** Match all layers, checking for caught errors
    to avoid having an exception in one layer disrupt other layers */
  _updateLayers(e, t) {
    const n = {};
    for (const l of e)
      n[l.id] ? qn.warn(`Multiple old layers with same id ${l.id}`)() : n[l.id] = l;
    if (this._defaultShaderModulesChanged) {
      for (const l of e)
        l.setNeedsUpdate(), l.setChangeFlags({
          extensionsChanged: !0
        });
      this._defaultShaderModulesChanged = !1;
    }
    const i = [];
    this._updateSublayersRecursively(t, n, i), this._finalizeOldLayers(n);
    let s = !1;
    for (const l of i)
      if (l.hasUniformTransition()) {
        s = `Uniform transition in ${l}`;
        break;
      }
    this._needsUpdate = s, this.layers = i;
  }
  /* eslint-disable complexity,max-statements */
  // Note: adds generated layers to `generatedLayers` array parameter
  _updateSublayersRecursively(e, t, n) {
    for (const i of e) {
      i.context = this.context;
      const s = t[i.id];
      s === null && qn.warn(`Multiple new layers with same id ${i.id}`)(), t[i.id] = null;
      let l = null;
      try {
        this._debug && s !== i && i.validateProps(), s ? (this._transferLayerState(s, i), this._updateLayer(i)) : this._initializeLayer(i), n.push(i), l = i.isComposite ? i.getSubLayers() : null;
      } catch (o) {
        this._handleError("matching", o, i);
      }
      l && this._updateSublayersRecursively(l, t, n);
    }
  }
  /* eslint-enable complexity,max-statements */
  // Finalize any old layers that were not matched
  _finalizeOldLayers(e) {
    for (const t in e) {
      const n = e[t];
      n && this._finalizeLayer(n);
    }
  }
  // / EXCEPTION SAFE LAYER ACCESS
  /** Safely initializes a single layer, calling layer methods */
  _initializeLayer(e) {
    try {
      e._initialize(), e.lifecycle = fd.INITIALIZED;
    } catch (t) {
      this._handleError("initialization", t, e);
    }
  }
  /** Transfer state from one layer to a newer version */
  _transferLayerState(e, t) {
    t._transferState(e), t.lifecycle = fd.MATCHED, t !== e && (e.lifecycle = fd.AWAITING_GC);
  }
  /** Safely updates a single layer, cleaning all flags */
  _updateLayer(e) {
    try {
      e._update();
    } catch (t) {
      this._handleError("update", t, e);
    }
  }
  /** Safely finalizes a single layer, removing all resources */
  _finalizeLayer(e) {
    this._needsRedraw = this._needsRedraw || `finalized ${e}`, e.lifecycle = fd.AWAITING_FINALIZATION;
    try {
      e._finalize(), e.lifecycle = fd.FINALIZED;
    } catch (t) {
      this._handleError("finalization", t, e);
    }
  }
}
function Tc(r, e, t) {
  if (r === e)
    return !0;
  if (!t || !r || !e)
    return !1;
  if (Array.isArray(r)) {
    if (!Array.isArray(e) || r.length !== e.length)
      return !1;
    for (let n = 0; n < r.length; n++)
      if (!Tc(r[n], e[n], t - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof r == "object" && typeof e == "object") {
    const n = Object.keys(r), i = Object.keys(e);
    if (n.length !== i.length)
      return !1;
    for (const s of n)
      if (!e.hasOwnProperty(s) || !Tc(r[s], e[s], t - 1))
        return !1;
    return !0;
  }
  return !1;
}
class R8 {
  constructor(e) {
    this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
      onViewStateChange: e.onViewStateChange,
      onInteractionStateChange: e.onInteractionStateChange
    }, Object.seal(this), this.setProps(e);
  }
  /** Remove all resources and event listeners */
  finalize() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.finalize();
    }
    this.controllers = {};
  }
  /** Check if a redraw is needed */
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  /** Mark the manager as dirty. Will rebuild all viewports and update controllers. */
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
  }
  /** Checks each viewport for transition updates */
  updateViewStates() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.updateTransition();
    }
  }
  /** Get a set of viewports for a given width and height
   * TODO - Intention is for deck.gl to autodeduce width and height and drop the need for props
   * @param rect (object, optional) - filter the viewports
   *   + not provided - return all viewports
   *   + {x, y} - only return viewports that contain this pixel
   *   + {x, y, width, height} - only return viewports that overlap with this rectangle
   */
  getViewports(e) {
    return e ? this._viewports.filter((t) => t.containsPixel(e)) : this._viewports;
  }
  /** Get a map of all views */
  getViews() {
    const e = {};
    return this.views.forEach((t) => {
      e[t.id] = t;
    }), e;
  }
  /** Resolves a viewId string to a View */
  getView(e) {
    return this.views.find((t) => t.id === e);
  }
  /** Returns the viewState for a specific viewId. Matches the viewState by
    1. view.viewStateId
    2. view.id
    3. root viewState
    then applies the view's filter if any */
  getViewState(e) {
    const t = typeof e == "string" ? this.getView(e) : e, n = t && this.viewState[t.getViewStateId()] || this.viewState;
    return t ? t.filterViewState(n) : n;
  }
  getViewport(e) {
    return this._viewportMap[e];
  }
  /**
   * Unproject pixel coordinates on screen onto world coordinates,
   * (possibly [lon, lat]) on map.
   * - [x, y] => [lng, lat]
   * - [x, y, z] => [lng, lat, Z]
   * @param {Array} xyz -
   * @param {Object} opts - options
   * @param {Object} opts.topLeft=true - Whether origin is top left
   * @return {Array|null} - [lng, lat, Z] or [X, Y, Z]
   */
  unproject(e, t) {
    const n = this.getViewports(), i = {
      x: e[0],
      y: e[1]
    };
    for (let s = n.length - 1; s >= 0; --s) {
      const l = n[s];
      if (l.containsPixel(i)) {
        const o = e.slice();
        return o[0] -= l.x, o[1] -= l.y, l.unproject(o, t);
      }
    }
    return null;
  }
  /** Update the manager with new Deck props */
  setProps(e) {
    e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
  }
  //
  // PRIVATE METHODS
  //
  _update() {
    this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
  }
  _setSize(e, t) {
    (e !== this.width || t !== this.height) && (this.width = e, this.height = t, this.setNeedsUpdate("Size changed"));
  }
  // Update the view descriptor list and set change flag if needed
  // Does not actually rebuild the `Viewport`s until `getViewports` is called
  _setViews(e) {
    e = jd(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
  }
  _setViewState(e) {
    e ? (!Tc(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : qn.warn("missing `viewState` or `initialViewState`")();
  }
  _createController(e, t) {
    const n = t.type;
    return new n({
      timeline: this.timeline,
      eventManager: this._eventManager,
      // Set an internal callback that calls the prop callback if provided
      onViewStateChange: this._eventCallbacks.onViewStateChange,
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (s) => {
        var l;
        return (l = this.getView(e.id)) == null ? void 0 : l.makeViewport({
          viewState: s,
          width: this.width,
          height: this.height
        });
      }
    });
  }
  _updateController(e, t, n, i) {
    const s = e.controller;
    if (s && n) {
      const l = {
        ...t,
        ...s,
        id: e.id,
        x: n.x,
        y: n.y,
        width: n.width,
        height: n.height
      };
      return (!i || i.constructor !== s.type) && (i = this._createController(e, l)), i && i.setProps(l), i;
    }
    return null;
  }
  // Rebuilds viewports from descriptors towards a certain window size
  _rebuildViewports() {
    const {
      views: e
    } = this, t = this.controllers;
    this._viewports = [], this.controllers = {};
    let n = !1;
    for (let i = e.length; i--; ) {
      const s = e[i], l = this.getViewState(s), o = s.makeViewport({
        viewState: l,
        width: this.width,
        height: this.height
      });
      let d = t[s.id];
      const m = !!s.controller;
      m && !d && (n = !0), (n || !m) && d && (d.finalize(), d = null), this.controllers[s.id] = this._updateController(s, l, o, d), o && this._viewports.unshift(o);
    }
    for (const i in t) {
      const s = t[i];
      s && !this.controllers[i] && s.finalize();
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {}, this._viewports.forEach((e) => {
      e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
    });
  }
  // Check if viewport array has changed, returns true if any change
  // Note that descriptors can be the same
  _diffViews(e, t) {
    return e.length !== t.length ? !0 : e.some((n, i) => !e[i].equals(t[i]));
  }
}
const B8 = /([0-9]+\.?[0-9]*)(%|px)/;
function lh(r) {
  switch (typeof r) {
    case "number":
      return {
        position: r,
        relative: !1
      };
    case "string":
      const e = B8.exec(r);
      if (e && e.length >= 3) {
        const t = e[2] === "%", n = parseFloat(e[1]);
        return {
          position: t ? n / 100 : n,
          relative: t
        };
      }
    // fallthrough
    default:
      throw new Error(`Could not parse position string ${r}`);
  }
}
function ch(r, e) {
  return r.relative ? Math.round(r.position * e) : r.position;
}
class mC {
  constructor(e) {
    const {
      id: t,
      x: n = 0,
      y: i = 0,
      width: s = "100%",
      height: l = "100%",
      padding: o = null
    } = e;
    this.id = t || this.constructor.displayName || "view", this.props = {
      ...e,
      id: this.id
    }, this._x = lh(n), this._y = lh(i), this._width = lh(s), this._height = lh(l), this._padding = o && {
      left: lh(o.left || 0),
      right: lh(o.right || 0),
      top: lh(o.top || 0),
      bottom: lh(o.bottom || 0)
    }, this.equals = this.equals.bind(this), Object.seal(this);
  }
  equals(e) {
    return this === e ? !0 : this.constructor === e.constructor && Tc(this.props, e.props, 2);
  }
  /** Make viewport from canvas dimensions and view state */
  makeViewport(e) {
    let {
      width: t,
      height: n,
      viewState: i
    } = e;
    i = this.filterViewState(i);
    const s = this.getDimensions({
      width: t,
      height: n
    });
    if (!s.height || !s.width)
      return null;
    const l = this.getViewportType(i);
    return new l({
      ...i,
      ...this.props,
      ...s
    });
  }
  getViewStateId() {
    const {
      viewState: e
    } = this.props;
    return typeof e == "string" ? e : (e == null ? void 0 : e.id) || this.id;
  }
  // Allows view to override (or completely define) viewState
  filterViewState(e) {
    if (this.props.viewState && typeof this.props.viewState == "object") {
      if (!this.props.viewState.id)
        return this.props.viewState;
      const t = {
        ...e
      };
      for (const n in this.props.viewState)
        n !== "id" && (t[n] = this.props.viewState[n]);
      return t;
    }
    return e;
  }
  /** Resolve the dimensions of the view from overall canvas dimensions */
  getDimensions(e) {
    let {
      width: t,
      height: n
    } = e;
    const i = {
      x: ch(this._x, t),
      y: ch(this._y, n),
      width: ch(this._width, t),
      height: ch(this._height, n)
    };
    return this._padding && (i.padding = {
      left: ch(this._padding.left, t),
      top: ch(this._padding.top, n),
      right: ch(this._padding.right, t),
      bottom: ch(this._padding.bottom, n)
    }), i;
  }
  // Used by sub classes to resolve controller props
  get controller() {
    const e = this.props.controller;
    return e ? e === !0 ? {
      type: this.ControllerType
    } : typeof e == "function" ? {
      type: e
    } : {
      type: this.ControllerType,
      ...e
    } : null;
  }
}
class wy {
  /**
   * @params timeline {Timeline}
   */
  constructor(e) {
    this._inProgress = !1, this._handle = null, this.time = 0, this.settings = {
      duration: 0
    }, this._timeline = e;
  }
  /* Public API */
  get inProgress() {
    return this._inProgress;
  }
  /**
   * (re)start this transition.
   * @params props {object} - optional overriding props. see constructor
   */
  start(e) {
    var t, n;
    this.cancel(), this.settings = e, this._inProgress = !0, (n = (t = this.settings).onStart) == null || n.call(t, this);
  }
  /**
   * end this transition if it is in progress.
   */
  end() {
    var e, t;
    this._inProgress && (this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, (t = (e = this.settings).onEnd) == null || t.call(e, this));
  }
  /**
   * cancel this transition if it is in progress.
   */
  cancel() {
    var e, t;
    this._inProgress && ((t = (e = this.settings).onInterrupt) == null || t.call(e, this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1);
  }
  /**
   * update this transition. Returns `true` if updated.
   */
  update() {
    var e, t;
    if (!this._inProgress)
      return !1;
    if (this._handle === null) {
      const {
        _timeline: n,
        settings: i
      } = this;
      this._handle = n.addChannel({
        delay: n.getTime(),
        duration: i.duration
      });
    }
    return this.time = this._timeline.getTime(this._handle), this._onUpdate(), (t = (e = this.settings).onUpdate) == null || t.call(e, this), this._timeline.isFinished(this._handle) && this.end(), !0;
  }
  /* Private API */
  _onUpdate() {
  }
}
const xT = () => {
}, Y1 = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
}, L8 = (r) => r, O8 = Y1.BREAK;
class N8 {
  constructor(e) {
    this._onTransitionUpdate = (t) => {
      const {
        time: n,
        settings: {
          interpolator: i,
          startProps: s,
          endProps: l,
          duration: o,
          easing: d
        }
      } = t, m = d(n / o), b = i.interpolateProps(s, l, m);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...b
      }).getViewportProps(), this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    }, this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new wy(e.timeline), this.onViewStateChange = e.onViewStateChange || xT, this.onStateChange = e.onStateChange || xT;
  }
  finalize() {
    this.transition.cancel();
  }
  // Returns current transitioned viewport.
  getViewportInTransition() {
    return this.propsInTransition;
  }
  // Process the vewiport change, either ignore or trigger a new transition.
  // Return true if a new transition is triggered, false otherwise.
  processViewStateChange(e) {
    let t = !1;
    const n = this.props;
    if (this.props = e, !n || this._shouldIgnoreViewportChange(n, e))
      return !1;
    if (this._isTransitionEnabled(e)) {
      let i = n;
      if (this.transition.inProgress) {
        const {
          interruption: s,
          endProps: l
        } = this.transition.settings;
        i = {
          ...n,
          ...s === Y1.SNAP_TO_END ? l : this.propsInTransition || n
        };
      }
      this._triggerTransition(i, e), t = !0;
    } else
      this.transition.cancel();
    return t;
  }
  updateTransition() {
    this.transition.update();
  }
  // Helper methods
  _isTransitionEnabled(e) {
    const {
      transitionDuration: t,
      transitionInterpolator: n
    } = e;
    return (t > 0 || t === "auto") && !!n;
  }
  _isUpdateDueToCurrentTransition(e) {
    return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1;
  }
  _shouldIgnoreViewportChange(e, t) {
    return this.transition.inProgress ? this.transition.settings.interruption === Y1.IGNORE || // Ignore update if it is due to current active transition.
    this._isUpdateDueToCurrentTransition(t) : this._isTransitionEnabled(t) ? t.transitionInterpolator.arePropsEqual(e, t) : !0;
  }
  _triggerTransition(e, t) {
    const n = this.getControllerState(e), i = this.getControllerState(t).shortestPathFrom(n), s = t.transitionInterpolator, l = s.getDuration ? s.getDuration(e, t) : t.transitionDuration;
    if (l === 0)
      return;
    const o = s.initializeProps(e, i);
    this.propsInTransition = {};
    const d = {
      duration: l,
      easing: t.transitionEasing || L8,
      interpolator: s,
      interruption: t.transitionInterruption || O8,
      startProps: o.start,
      endProps: o.end,
      onStart: t.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(t.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(t.onTransitionEnd)
    };
    this.transition.start(d), this.onStateChange({
      inTransition: !0
    }), this.updateTransition();
  }
  _onTransitionEnd(e) {
    return (t) => {
      this.propsInTransition = null, this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      }), e == null || e(t);
    };
  }
}
function Xs(r, e) {
  if (!r)
    throw new Error(e || "deck.gl: assertion failed.");
}
class D8 {
  /**
   * @param opts {array|object}
   * @param opts.compare {array} - prop names used in equality check
   * @param opts.extract {array} - prop names needed for interpolation
   * @param opts.required {array} - prop names that must be supplied
   * alternatively, supply one list of prop names as `opts` if all of the above are the same.
   */
  constructor(e) {
    const {
      compare: t,
      extract: n,
      required: i
    } = e;
    this._propsToCompare = t, this._propsToExtract = n || t, this._requiredProps = i;
  }
  /**
   * Checks if two sets of props need transition in between
   * @param currentProps {object} - a list of viewport props
   * @param nextProps {object} - a list of viewport props
   * @returns {bool} - true if two props are equivalent
   */
  arePropsEqual(e, t) {
    for (const n of this._propsToCompare)
      if (!(n in e) || !(n in t) || !Cc(e[n], t[n]))
        return !1;
    return !0;
  }
  /**
   * Called before transition starts to validate/pre-process start and end props
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Object} {start, end} - start and end props to be passed
   *   to `interpolateProps`
   */
  initializeProps(e, t) {
    const n = {}, i = {};
    for (const s of this._propsToExtract)
      (s in e || s in t) && (n[s] = e[s], i[s] = t[s]);
    return this._checkRequiredProps(n), this._checkRequiredProps(i), {
      start: n,
      end: i
    };
  }
  /**
   * Returns transition duration
   * @param startProps {object} - a list of starting viewport props
   * @param endProps {object} - a list of target viewport props
   * @returns {Number} - transition duration in milliseconds
   */
  getDuration(e, t) {
    return t.transitionDuration;
  }
  _checkRequiredProps(e) {
    this._requiredProps && this._requiredProps.forEach((t) => {
      const n = e[t];
      Xs(Number.isFinite(n) || Array.isArray(n), `${t} is required for transition`);
    });
  }
}
const k8 = ["longitude", "latitude", "zoom", "bearing", "pitch"], F8 = ["longitude", "latitude", "zoom"];
class E2 extends D8 {
  /**
   * @param {Object} opts
   * @param {Array} opts.transitionProps - list of props to apply linear transition to.
   * @param {Array} opts.around - a screen point to zoom/rotate around.
   * @param {Function} opts.makeViewport - construct a viewport instance with given props.
   */
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = Array.isArray(e) ? e : e.transitionProps, n = Array.isArray(e) ? {} : e;
    n.transitionProps = Array.isArray(t) ? {
      compare: t,
      required: t
    } : t || {
      compare: k8,
      required: F8
    }, super(n.transitionProps), this.opts = n;
  }
  initializeProps(e, t) {
    const n = super.initializeProps(e, t), {
      makeViewport: i,
      around: s
    } = this.opts;
    if (i && s) {
      const l = i(e), o = i(t), d = l.unproject(s);
      n.start.around = s, Object.assign(n.end, {
        around: o.project(d),
        aroundPosition: d,
        width: t.width,
        height: t.height
      });
    }
    return n;
  }
  interpolateProps(e, t, n) {
    const i = {};
    for (const s of this._propsToExtract)
      i[s] = N_(e[s] || 0, t[s] || 0, n);
    if (t.aroundPosition && this.opts.makeViewport) {
      const s = this.opts.makeViewport({
        ...t,
        ...i
      });
      Object.assign(i, s.panByPosition(
        t.aroundPosition,
        // anchor point in current screen coordinates
        N_(e.around, t.around, n)
      ));
    }
    return i;
  }
}
const uh = {
  transitionDuration: 0
}, U8 = 300, ym = (r) => 1 - (1 - r) * (1 - r), od = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  MULTI_PAN: ["multipanstart", "multipanmove", "multipanend"],
  DOUBLE_CLICK: ["dblclick"],
  KEYBOARD: ["keydown"]
}, Qh = {};
class _C {
  constructor(e) {
    this.state = {}, this._events = {}, this._interactionState = {
      isDragging: !1
    }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new N8({
      ...e,
      getControllerState: (t) => new this.ControllerState(t),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {
    }), this.onStateChange = e.onStateChange || (() => {
    }), this.makeViewport = e.makeViewport;
  }
  set events(e) {
    this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props);
  }
  finalize() {
    var e;
    for (const t in this._events)
      this._events[t] && ((e = this.eventManager) == null || e.off(t, this.handleEvent));
    this.transitionManager.finalize();
  }
  /**
   * Callback for events
   */
  handleEvent(e) {
    this._controllerState = void 0;
    const t = this._eventStartBlocked;
    switch (e.type) {
      case "panstart":
        return t ? !1 : this._onPanStart(e);
      case "panmove":
        return this._onPan(e);
      case "panend":
        return this._onPanEnd(e);
      case "pinchstart":
        return t ? !1 : this._onPinchStart(e);
      case "pinchmove":
        return this._onPinch(e);
      case "pinchend":
        return this._onPinchEnd(e);
      case "multipanstart":
        return t ? !1 : this._onMultiPanStart(e);
      case "multipanmove":
        return this._onMultiPan(e);
      case "multipanend":
        return this._onMultiPanEnd(e);
      case "dblclick":
        return this._onDoubleClick(e);
      case "wheel":
        return this._onWheel(e);
      case "keydown":
        return this._onKeyDown(e);
      default:
        return !1;
    }
  }
  /* Event utils */
  // Event object: http://hammerjs.github.io/api/#event-object
  get controllerState() {
    return this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    }), this._controllerState;
  }
  getCenter(e) {
    const {
      x: t,
      y: n
    } = this.props, {
      offsetCenter: i
    } = e;
    return [i.x - t, i.y - n];
  }
  isPointInBounds(e, t) {
    const {
      width: n,
      height: i
    } = this.props;
    if (t && t.handled)
      return !1;
    const s = e[0] >= 0 && e[0] <= n && e[1] >= 0 && e[1] <= i;
    return s && t && t.stopPropagation(), s;
  }
  isFunctionKeyPressed(e) {
    const {
      srcEvent: t
    } = e;
    return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || !1;
  }
  // When a multi-touch event ends, e.g. pinch, not all pointers are lifted at the same time.
  // This triggers a brief `pan` event.
  // Calling this method will temporarily disable *start events to avoid conflicting transitions.
  blockEvents(e) {
    const t = setTimeout(() => {
      this._eventStartBlocked === t && (this._eventStartBlocked = null);
    }, e);
    this._eventStartBlocked = t;
  }
  /**
   * Extract interactivity options
   */
  setProps(e) {
    e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
    const {
      inertia: t
    } = e;
    this.inertia = Number.isFinite(t) ? t : t === !0 ? U8 : 0;
    const {
      scrollZoom: n = !0,
      dragPan: i = !0,
      dragRotate: s = !0,
      doubleClickZoom: l = !0,
      touchZoom: o = !0,
      touchRotate: d = !1,
      keyboard: m = !0
    } = e, b = !!this.onViewStateChange;
    this.toggleEvents(od.WHEEL, b && n), this.toggleEvents(od.PAN, b), this.toggleEvents(od.PINCH, b && (o || d)), this.toggleEvents(od.MULTI_PAN, b && d), this.toggleEvents(od.DOUBLE_CLICK, b && l), this.toggleEvents(od.KEYBOARD, b && m), this.scrollZoom = n, this.dragPan = i, this.dragRotate = s, this.doubleClickZoom = l, this.touchZoom = o, this.touchRotate = d, this.keyboard = m;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(e, t) {
    this.eventManager && e.forEach((n) => {
      this._events[n] !== t && (this._events[n] = t, t ? this.eventManager.on(n, this.handleEvent) : this.eventManager.off(n, this.handleEvent));
    });
  }
  // Private Methods
  /* Callback util */
  // formats map state and invokes callback function
  updateViewport(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = {
      ...e.getViewportProps(),
      ...t
    }, s = this.controllerState !== e;
    if (this.state = e.getState(), this._setInteractionState(n), s) {
      const l = this.controllerState && this.controllerState.getViewportProps();
      this.onViewStateChange && this.onViewStateChange({
        viewState: i,
        interactionState: this._interactionState,
        oldViewState: l,
        viewId: this.props.id
      });
    }
  }
  _onTransition(e) {
    this.onViewStateChange({
      ...e,
      interactionState: this._interactionState,
      viewId: this.props.id
    });
  }
  _setInteractionState(e) {
    Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
  }
  /* Event handlers */
  // Default handler for the `panstart` event.
  _onPanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    let n = this.isFunctionKeyPressed(e) || e.rightButton || !1;
    (this.invertPan || this.dragMode === "pan") && (n = !n);
    const i = this.controllerState[n ? "panStart" : "rotateStart"]({
      pos: t
    });
    return this._panMove = n, this.updateViewport(i, uh, {
      isDragging: !0
    }), !0;
  }
  // Default handler for the `panmove` and `panend` event.
  _onPan(e) {
    return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1;
  }
  _onPanEnd(e) {
    return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1;
  }
  // Default handler for panning to move.
  // Called by `_onPan` when panning without function key pressed.
  _onPanMove(e) {
    if (!this.dragPan)
      return !1;
    const t = this.getCenter(e), n = this.controllerState.pan({
      pos: t
    });
    return this.updateViewport(n, uh, {
      isDragging: !0,
      isPanning: !0
    }), !0;
  }
  _onPanMoveEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragPan && t && e.velocity) {
      const n = this.getCenter(e), i = [n[0] + e.velocityX * t / 2, n[1] + e.velocityY * t / 2], s = this.controllerState.pan({
        pos: i
      }).panEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: ym
      }, {
        isDragging: !1,
        isPanning: !0
      });
    } else {
      const n = this.controllerState.panEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isPanning: !1
      });
    }
    return !0;
  }
  // Default handler for panning to rotate.
  // Called by `_onPan` when panning with function key pressed.
  _onPanRotate(e) {
    if (!this.dragRotate)
      return !1;
    const t = this.getCenter(e), n = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(n, uh, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onPanRotateEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragRotate && t && e.velocity) {
      const n = this.getCenter(e), i = [n[0] + e.velocityX * t / 2, n[1] + e.velocityY * t / 2], s = this.controllerState.rotate({
        pos: i
      }).rotateEnd();
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: ym
      }, {
        isDragging: !1,
        isRotating: !0
      });
    } else {
      const n = this.controllerState.rotateEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `wheel` event.
  _onWheel(e) {
    if (!this.scrollZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    e.srcEvent.preventDefault();
    const {
      speed: n = 0.01,
      smooth: i = !1
    } = this.scrollZoom === !0 ? {} : this.scrollZoom, {
      delta: s
    } = e;
    let l = 2 / (1 + Math.exp(-Math.abs(s * n)));
    s < 0 && l !== 0 && (l = 1 / l);
    const o = this.controllerState.zoom({
      pos: t,
      scale: l
    });
    return this.updateViewport(o, {
      ...this._getTransitionProps({
        around: t
      }),
      transitionDuration: i ? 250 : 1
    }, {
      isZooming: !0,
      isPanning: !0
    }), !0;
  }
  _onMultiPanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const n = this.controllerState.rotateStart({
      pos: t
    });
    return this.updateViewport(n, uh, {
      isDragging: !0
    }), !0;
  }
  _onMultiPan(e) {
    if (!this.touchRotate || !this.isDragging())
      return !1;
    const t = this.getCenter(e);
    t[0] -= e.deltaX;
    const n = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(n, uh, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onMultiPanEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this;
    if (this.touchRotate && t && e.velocityY) {
      const n = this.getCenter(e), i = [n[0], n[1] += e.velocityY * t / 2], s = this.controllerState.rotate({
        pos: i
      });
      this.updateViewport(s, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: ym
      }, {
        isDragging: !1,
        isRotating: !0
      }), this.blockEvents(t);
    } else {
      const n = this.controllerState.rotateEnd();
      this.updateViewport(n, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  // Default handler for the `pinchstart` event.
  _onPinchStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const n = this.controllerState.zoomStart({
      pos: t
    }).rotateStart({
      pos: t
    });
    return Qh._startPinchRotation = e.rotation, Qh._lastPinchEvent = e, this.updateViewport(n, uh, {
      isDragging: !0
    }), !0;
  }
  // Default handler for the `pinchmove` and `pinchend` events.
  _onPinch(e) {
    if (!this.touchZoom && !this.touchRotate || !this.isDragging())
      return !1;
    let t = this.controllerState;
    if (this.touchZoom) {
      const {
        scale: n
      } = e, i = this.getCenter(e);
      t = t.zoom({
        pos: i,
        scale: n
      });
    }
    if (this.touchRotate) {
      const {
        rotation: n
      } = e;
      t = t.rotate({
        deltaAngleX: Qh._startPinchRotation - n
      });
    }
    return this.updateViewport(t, uh, {
      isDragging: !0,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    }), Qh._lastPinchEvent = e, !0;
  }
  _onPinchEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this, {
      _lastPinchEvent: n
    } = Qh;
    if (this.touchZoom && t && n && e.scale !== n.scale) {
      const i = this.getCenter(e);
      let s = this.controllerState.rotateEnd();
      const l = Math.log2(e.scale), o = (l - Math.log2(n.scale)) / (e.deltaTime - n.deltaTime), d = Math.pow(2, l + o * t / 2);
      s = s.zoom({
        pos: i,
        scale: d
      }).zoomEnd(), this.updateViewport(s, {
        ...this._getTransitionProps({
          around: i
        }),
        transitionDuration: t,
        transitionEasing: ym
      }, {
        isDragging: !1,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: !1
      }), this.blockEvents(t);
    } else {
      const i = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      });
    }
    return Qh._startPinchRotation = null, Qh._lastPinchEvent = null, !0;
  }
  // Default handler for the `dblclick` event.
  _onDoubleClick(e) {
    if (!this.doubleClickZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const n = this.isFunctionKeyPressed(e), i = this.controllerState.zoom({
      pos: t,
      scale: n ? 0.5 : 2
    });
    return this.updateViewport(i, this._getTransitionProps({
      around: t
    }), {
      isZooming: !0,
      isPanning: !0
    }), this.blockEvents(100), !0;
  }
  // Default handler for the `keydown` event
  _onKeyDown(e) {
    if (!this.keyboard)
      return !1;
    const t = this.isFunctionKeyPressed(e), {
      zoomSpeed: n,
      moveSpeed: i,
      rotateSpeedX: s,
      rotateSpeedY: l
    } = this.keyboard === !0 ? {} : this.keyboard, {
      controllerState: o
    } = this;
    let d;
    const m = {};
    switch (e.srcEvent.code) {
      case "Minus":
        d = t ? o.zoomOut(n).zoomOut(n) : o.zoomOut(n), m.isZooming = !0;
        break;
      case "Equal":
        d = t ? o.zoomIn(n).zoomIn(n) : o.zoomIn(n), m.isZooming = !0;
        break;
      case "ArrowLeft":
        t ? (d = o.rotateLeft(s), m.isRotating = !0) : (d = o.moveLeft(i), m.isPanning = !0);
        break;
      case "ArrowRight":
        t ? (d = o.rotateRight(s), m.isRotating = !0) : (d = o.moveRight(i), m.isPanning = !0);
        break;
      case "ArrowUp":
        t ? (d = o.rotateUp(l), m.isRotating = !0) : (d = o.moveUp(i), m.isPanning = !0);
        break;
      case "ArrowDown":
        t ? (d = o.rotateDown(l), m.isRotating = !0) : (d = o.moveDown(i), m.isPanning = !0);
        break;
      default:
        return !1;
    }
    return this.updateViewport(d, this._getTransitionProps(), m), !0;
  }
  _getTransitionProps(e) {
    const {
      transition: t
    } = this;
    return !t || !t.transitionInterpolator ? uh : e ? {
      ...t,
      transitionInterpolator: new E2({
        ...e,
        ...t.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : t;
  }
}
class z8 {
  constructor(e, t) {
    this._viewportProps = this.applyConstraints(e), this._state = t;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const wT = 5, j8 = 1.2;
class yC extends z8 {
  constructor(e) {
    const {
      /** Mapbox viewport properties */
      /** The width of the viewport */
      width: t,
      /** The height of the viewport */
      height: n,
      /** The latitude at the center of the viewport */
      latitude: i,
      /** The longitude at the center of the viewport */
      longitude: s,
      /** The tile zoom level of the map. */
      zoom: l,
      /** The bearing of the viewport in degrees */
      bearing: o = 0,
      /** The pitch of the viewport in degrees */
      pitch: d = 0,
      /**
       * Specify the altitude of the viewport camera
       * Unit: map heights, default 1.5
       * Non-public API, see https://github.com/mapbox/mapbox-gl-js/issues/1137
       */
      altitude: m = 1.5,
      /** Viewport position */
      position: b = [0, 0, 0],
      /** Viewport constraints */
      maxZoom: T = 20,
      minZoom: M = 0,
      maxPitch: E = 60,
      minPitch: D = 0,
      /** Interaction states, required to calculate change during transform */
      /* The point on map being grabbed when the operation first started */
      startPanLngLat: U,
      /* Center of the zoom when the operation first started */
      startZoomLngLat: q,
      /* Pointer position when rotation started */
      startRotatePos: G,
      /** Bearing when current perspective rotate operation started */
      startBearing: Y,
      /** Pitch when current perspective rotate operation started */
      startPitch: he,
      /** Zoom when current zoom operation started */
      startZoom: X,
      /** Normalize viewport props to fit map height into viewport */
      normalize: J = !0
    } = e;
    Xs(Number.isFinite(s)), Xs(Number.isFinite(i)), Xs(Number.isFinite(l)), super({
      width: t,
      height: n,
      latitude: i,
      longitude: s,
      zoom: l,
      bearing: o,
      pitch: d,
      altitude: m,
      maxZoom: T,
      minZoom: M,
      maxPitch: E,
      minPitch: D,
      normalize: J,
      position: b
    }, {
      startPanLngLat: U,
      startZoomLngLat: q,
      startRotatePos: G,
      startBearing: Y,
      startPitch: he,
      startZoom: X
    }), this.makeViewport = e.makeViewport;
  }
  /**
   * Start panning
   * @param {[Number, Number]} pos - position on screen where the pointer grabs
   */
  panStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startPanLngLat: this._unproject(t)
    });
  }
  /**
   * Pan
   * @param {[Number, Number]} pos - position on screen where the pointer is
   * @param {[Number, Number], optional} startPos - where the pointer grabbed at
   *   the start of the operation. Must be supplied of `panStart()` was not called
   */
  pan(e) {
    let {
      pos: t,
      startPos: n
    } = e;
    const i = this.getState().startPanLngLat || this._unproject(n);
    if (!i)
      return this;
    const l = this.makeViewport(this.getViewportProps()).panByPosition(i, t);
    return this._getUpdatedState(l);
  }
  /**
   * End panning
   * Must call if `panStart()` was called
   */
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  /**
   * Start rotating
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotateStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startRotatePos: t,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  /**
   * Rotate
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  rotate(e) {
    let {
      pos: t,
      deltaAngleX: n = 0,
      deltaAngleY: i = 0
    } = e;
    const {
      startRotatePos: s,
      startBearing: l,
      startPitch: o
    } = this.getState();
    if (!s || l === void 0 || o === void 0)
      return this;
    let d;
    return t ? d = this._getNewRotation(t, s, o, l) : d = {
      bearing: l + n,
      pitch: o + i
    }, this._getUpdatedState(d);
  }
  /**
   * End rotating
   * Must call if `rotateStart()` was called
   */
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  /**
   * Start zooming
   * @param {[Number, Number]} pos - position on screen where the center is
   */
  zoomStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(t),
      startZoom: this.getViewportProps().zoom
    });
  }
  /**
   * Zoom
   * @param {[Number, Number]} pos - position on screen where the current center is
   * @param {[Number, Number]} startPos - the center position at
   *   the start of the operation. Must be supplied of `zoomStart()` was not called
   * @param {Number} scale - a number between [0, 1] specifying the accumulated
   *   relative scale.
   */
  zoom(e) {
    let {
      pos: t,
      startPos: n,
      scale: i
    } = e, {
      startZoom: s,
      startZoomLngLat: l
    } = this.getState();
    if (l || (s = this.getViewportProps().zoom, l = this._unproject(n) || this._unproject(t)), !l)
      return this;
    const {
      maxZoom: o,
      minZoom: d
    } = this.getViewportProps();
    let m = s + Math.log2(i);
    m = xc(m, d, o);
    const b = this.makeViewport({
      ...this.getViewportProps(),
      zoom: m
    });
    return this._getUpdatedState({
      zoom: m,
      ...b.panByPosition(l, t)
    });
  }
  /**
   * End zooming
   * Must call if `zoomStart()` was called
   */
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
    return this._zoomFromCenter(e);
  }
  zoomOut() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
    return this._zoomFromCenter(1 / e);
  }
  moveLeft() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([e, 0]);
  }
  moveRight() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([-e, 0]);
  }
  moveUp() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([0, e]);
  }
  moveDown() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([0, -e]);
  }
  rotateLeft() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - e
    });
  }
  rotateRight() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + e
    });
  }
  rotateUp() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + e
    });
  }
  rotateDown() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - e
    });
  }
  shortestPathFrom(e) {
    const t = e.getViewportProps(), n = {
      ...this.getViewportProps()
    }, {
      bearing: i,
      longitude: s
    } = n;
    return Math.abs(i - t.bearing) > 180 && (n.bearing = i < 0 ? i + 360 : i - 360), Math.abs(s - t.longitude) > 180 && (n.longitude = s < 0 ? s + 360 : s - 360), n;
  }
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(e) {
    const {
      maxZoom: t,
      minZoom: n,
      zoom: i
    } = e;
    e.zoom = xc(i, n, t);
    const {
      maxPitch: s,
      minPitch: l,
      pitch: o
    } = e;
    e.pitch = xc(o, l, s);
    const {
      normalize: d = !0
    } = e;
    return d && Object.assign(e, gF(e)), e;
  }
  /* Private methods */
  _zoomFromCenter(e) {
    const {
      width: t,
      height: n
    } = this.getViewportProps();
    return this.zoom({
      pos: [t / 2, n / 2],
      scale: e
    });
  }
  _panFromCenter(e) {
    const {
      width: t,
      height: n
    } = this.getViewportProps();
    return this.pan({
      startPos: [t / 2, n / 2],
      pos: [t / 2 + e[0], n / 2 + e[1]]
    });
  }
  _getUpdatedState(e) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...e
    });
  }
  _unproject(e) {
    const t = this.makeViewport(this.getViewportProps());
    return e && t.unproject(e);
  }
  _getNewRotation(e, t, n, i) {
    const s = e[0] - t[0], l = e[1] - t[1], o = e[1], d = t[1], {
      width: m,
      height: b
    } = this.getViewportProps(), T = s / m;
    let M = 0;
    l > 0 ? Math.abs(b - d) > wT && (M = l / (d - b) * j8) : l < 0 && d > wT && (M = 1 - o / d), M = xc(M, -1, 1);
    const {
      minPitch: E,
      maxPitch: D
    } = this.getViewportProps(), U = i + 180 * T;
    let q = n;
    return M > 0 ? q = n + M * (D - n) : M < 0 && (q = n - M * (E - n)), {
      pitch: q,
      bearing: U
    };
  }
}
class V8 extends _C {
  constructor() {
    super(...arguments), this.ControllerState = yC, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new E2({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    }, this.dragMode = "pan";
  }
  setProps(e) {
    e.position = e.position || [0, 0, 0];
    const t = this.props;
    super.setProps(e), (!t || t.height !== e.height) && this.updateViewport(new this.ControllerState({
      makeViewport: this.makeViewport,
      ...e,
      ...this.state
    }));
  }
}
class C2 extends mC {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e);
  }
  getViewportType() {
    return Cf;
  }
  get ControllerType() {
    return V8;
  }
}
C2.displayName = "MapView";
const q8 = new S2();
function G8(r, e) {
  const t = r.order ?? 1 / 0, n = e.order ?? 1 / 0;
  return t - n;
}
class $8 {
  constructor(e) {
    this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = e, this._needsRedraw = "Initial render", this._setEffects([]);
  }
  /**
   * Register a new default effect, i.e. an effect presents regardless of user supplied props.effects
   */
  addDefaultEffect(e) {
    const t = this._defaultEffects;
    if (!t.find((n) => n.id === e.id)) {
      const n = t.findIndex((i) => G8(i, e) > 0);
      n < 0 ? t.push(e) : t.splice(n, 0, e), e.setup(this._context), this._setEffects(this.effects);
    }
  }
  setProps(e) {
    "effects" in e && (Tc(e.effects, this.effects, 1) || this._setEffects(e.effects));
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(e) {
    const t = {};
    for (const i of this.effects)
      t[i.id] = i;
    const n = [];
    for (const i of e) {
      const s = t[i.id];
      let l = i;
      s && s !== i ? s.setProps ? (s.setProps(i.props), l = s) : s.cleanup(this._context) : s || i.setup(this._context), n.push(l), delete t[i.id];
    }
    for (const i in t)
      t[i].cleanup(this._context);
    this.effects = n, this._resolvedEffects = n.concat(this._defaultEffects), e.some((i) => i instanceof S2) || this._resolvedEffects.push(q8), this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const e of this._resolvedEffects)
      e.cleanup(this._context);
    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
  }
}
class H8 extends T2 {
  shouldDrawLayer(e) {
    const {
      operation: t
    } = e.props;
    return t.includes("draw") || t.includes("terrain");
  }
}
const W8 = "deckRenderer.renderLayers";
class X8 {
  constructor(e) {
    this.device = e, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new H8(e), this.pickLayersPass = new pC(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
  }
  setProps(e) {
    this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
  }
  renderLayers(e) {
    if (!e.viewports.length)
      return;
    const t = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, n = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...e
    };
    n.effects && this._preRender(n.effects, n);
    const i = this.lastPostProcessEffect ? this.renderBuffers[0] : n.target;
    this.lastPostProcessEffect && (n.clearColor = [0, 0, 0, 0], n.clearCanvas = !0);
    const s = t.render({
      ...n,
      target: i
    });
    n.effects && this._postRender(n.effects, n), this.renderCount++, Vo(W8, this, s, e);
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  finalize() {
    const {
      renderBuffers: e
    } = this;
    for (const t of e)
      t.delete();
    e.length = 0;
  }
  _preRender(e, t) {
    this.lastPostProcessEffect = null, t.preRenderStats = t.preRenderStats || {};
    for (const n of e)
      t.preRenderStats[n.id] = n.preRender(t), n.postRender && (this.lastPostProcessEffect = n.id);
    this.lastPostProcessEffect && this._resizeRenderBuffers();
  }
  _resizeRenderBuffers() {
    const {
      renderBuffers: e
    } = this, t = this.device.canvasContext.getDrawingBufferSize();
    e.length === 0 && [0, 1].map((n) => {
      const i = this.device.createTexture({
        sampler: {
          minFilter: "linear",
          magFilter: "linear"
        }
      });
      e.push(this.device.createFramebuffer({
        id: `deck-renderbuffer-${n}`,
        colorAttachments: [i]
      }));
    });
    for (const n of e)
      n.resize(t);
  }
  _postRender(e, t) {
    const {
      renderBuffers: n
    } = this, i = {
      ...t,
      inputBuffer: n[0],
      swapBuffer: n[1]
    };
    for (const s of e)
      if (s.postRender) {
        i.target = s.id === this.lastPostProcessEffect ? t.target : void 0;
        const l = s.postRender(i);
        i.inputBuffer = l, i.swapBuffer = l === n[0] ? n[1] : n[0];
      }
  }
}
const Z8 = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function Y8(r) {
  let {
    pickedColors: e,
    decodePickingColor: t,
    deviceX: n,
    deviceY: i,
    deviceRadius: s,
    deviceRect: l
  } = r;
  const {
    x: o,
    y: d,
    width: m,
    height: b
  } = l;
  let T = s * s, M = -1, E = 0;
  for (let D = 0; D < b; D++) {
    const U = D + d - i, q = U * U;
    if (q > T)
      E += 4 * m;
    else
      for (let G = 0; G < m; G++) {
        if (e[E + 3] - 1 >= 0) {
          const he = G + o - n, X = he * he + q;
          X <= T && (T = X, M = E);
        }
        E += 4;
      }
  }
  if (M >= 0) {
    const D = e.slice(M, M + 4), U = t(D);
    if (U) {
      const q = Math.floor(M / 4 / m), G = M / 4 - q * m;
      return {
        ...U,
        pickedColor: D,
        pickedX: o + G,
        pickedY: d + q
      };
    }
    qn.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return Z8;
}
function K8(r) {
  let {
    pickedColors: e,
    decodePickingColor: t
  } = r;
  const n = /* @__PURE__ */ new Map();
  if (e) {
    for (let i = 0; i < e.length; i += 4)
      if (e[i + 3] - 1 >= 0) {
        const l = e.slice(i, i + 4), o = l.join(",");
        if (!n.has(o)) {
          const d = t(l);
          d ? n.set(o, {
            ...d,
            color: l
          }) : qn.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
  }
  return Array.from(n.values());
}
function bC(r) {
  let {
    pickInfo: e,
    viewports: t,
    pixelRatio: n,
    x: i,
    y: s,
    z: l
  } = r, o = t[0];
  t.length > 1 && (o = Q8((e == null ? void 0 : e.pickedViewports) || t, {
    x: i,
    y: s
  }));
  let d;
  if (o) {
    const m = [i - o.x, s - o.y];
    l !== void 0 && (m[2] = l), d = o.unproject(m);
  }
  return {
    color: null,
    layer: null,
    viewport: o,
    index: -1,
    picked: !1,
    x: i,
    y: s,
    pixel: [i, s],
    coordinate: d,
    devicePixel: e && "pickedX" in e ? [e.pickedX, e.pickedY] : void 0,
    pixelRatio: n
  };
}
function J8(r) {
  const {
    pickInfo: e,
    lastPickedInfo: t,
    mode: n,
    layers: i
  } = r, {
    pickedColor: s,
    pickedLayer: l,
    pickedObjectIndex: o
  } = e, d = l ? [l] : [];
  if (n === "hover") {
    const T = t.index, M = t.layerId, E = l ? l.props.id : null;
    if (E !== M || o !== T) {
      if (E !== M) {
        const D = i.find((U) => U.props.id === M);
        D && d.unshift(D);
      }
      t.layerId = E, t.index = o, t.info = null;
    }
  }
  const m = bC(r), b = /* @__PURE__ */ new Map();
  return b.set(null, m), d.forEach((T) => {
    let M = {
      ...m
    };
    T === l && (M.color = s, M.index = o, M.picked = !0), M = vC({
      layer: T,
      info: M,
      mode: n
    });
    const E = M.layer;
    T === l && n === "hover" && (t.info = M), b.set(E.id, M), n === "hover" && E.updateAutoHighlight(M);
  }), b;
}
function vC(r) {
  let {
    layer: e,
    info: t,
    mode: n
  } = r;
  for (; e && t; ) {
    const i = t.layer || null;
    t.sourceLayer = i, t.layer = e, t = e.getPickingInfo({
      info: t,
      mode: n,
      sourceLayer: i
    }), e = e.parent;
  }
  return t;
}
function Q8(r, e) {
  for (let t = r.length - 1; t >= 0; t--) {
    const n = r[t];
    if (n.containsPixel(e))
      return n;
  }
  return r[0];
}
class eU {
  constructor(e) {
    this._pickable = !0, this.device = e, this.pickLayersPass = new pC(e), this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(e) {
    "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
  }
  finalize() {
    this.pickingFBO && this.pickingFBO.destroy(), this.depthFBO && this.depthFBO.destroy();
  }
  /** Pick the closest info at given coordinate */
  pickObject(e) {
    return this._pickClosestObject(e);
  }
  /** Get all unique infos within a bounding box */
  pickObjects(e) {
    return this._pickVisibleObjects(e);
  }
  // Returns a new picking info object by assuming the last picked object is still picked
  getLastPickedObject(e) {
    let {
      x: t,
      y: n,
      layers: i,
      viewports: s
    } = e, l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.lastPickedInfo.info;
    const o = l && l.layer && l.layer.id, d = l && l.viewport && l.viewport.id, m = o ? i.find((E) => E.id === o) : null, b = d && s.find((E) => E.id === d) || s[0], T = b && b.unproject([t - b.x, n - b.y]);
    return {
      ...l,
      ...{
        x: t,
        y: n,
        viewport: b,
        coordinate: T,
        layer: m
      }
    };
  }
  // Private
  /** Ensures that picking framebuffer exists and matches the canvas size */
  _resizeBuffer() {
    var t, n;
    if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
      colorAttachments: ["rgba8unorm"],
      depthStencilAttachment: "depth16unorm"
    }), this.device.isTextureFormatRenderable("rgba32float"))) {
      const i = this.device.createFramebuffer({
        colorAttachments: ["rgba32float"],
        depthStencilAttachment: "depth16unorm"
      });
      this.depthFBO = i;
    }
    const {
      canvas: e
    } = this.device.getDefaultCanvasContext();
    (t = this.pickingFBO) == null || t.resize({
      width: e.width,
      height: e.height
    }), (n = this.depthFBO) == null || n.resize({
      width: e.width,
      height: e.height
    });
  }
  /** Preliminary filtering of the layers list. Skid picking pass if no layer is pickable. */
  _getPickable(e) {
    if (this._pickable === !1)
      return null;
    const t = e.filter((n) => this.pickLayersPass.shouldDrawLayer(n) && !n.isComposite);
    return t.length ? t : null;
  }
  /** Pick the closest object at the given coordinate */
  // eslint-disable-next-line max-statements,complexity
  _pickClosestObject(e) {
    let {
      layers: t,
      views: n,
      viewports: i,
      x: s,
      y: l,
      radius: o = 0,
      depth: d = 1,
      mode: m = "query",
      unproject3D: b,
      onViewportActive: T,
      effects: M
    } = e;
    const E = this.device.canvasContext.cssToDeviceRatio(), D = this._getPickable(t);
    if (!D || i.length === 0)
      return {
        result: [],
        emptyInfo: bC({
          viewports: i,
          x: s,
          y: l,
          pixelRatio: E
        })
      };
    this._resizeBuffer();
    const U = this.device.canvasContext.cssToDevicePixels([s, l], !0), q = [U.x + Math.floor(U.width / 2), U.y + Math.floor(U.height / 2)], G = Math.round(o * E), {
      width: Y,
      height: he
    } = this.pickingFBO, X = this._getPickingRect({
      deviceX: q[0],
      deviceY: q[1],
      deviceRadius: G,
      deviceWidth: Y,
      deviceHeight: he
    }), J = {
      x: s - o,
      y: l - o,
      width: o * 2 + 1,
      height: o * 2 + 1
    };
    let ie;
    const ye = [], oe = /* @__PURE__ */ new Set();
    for (let Re = 0; Re < d; Re++) {
      let Ne;
      if (X) {
        const _e = this._drawAndSample({
          layers: D,
          views: n,
          viewports: i,
          onViewportActive: T,
          deviceRect: X,
          cullRect: J,
          effects: M,
          pass: `picking:${m}`
        });
        Ne = Y8({
          ..._e,
          deviceX: q[0],
          deviceY: q[1],
          deviceRadius: G,
          deviceRect: X
        });
      } else
        Ne = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let me;
      if (Ne.pickedLayer && b && this.depthFBO) {
        const {
          pickedColors: _e
        } = this._drawAndSample({
          layers: [Ne.pickedLayer],
          views: n,
          viewports: i,
          onViewportActive: T,
          deviceRect: {
            x: Ne.pickedX,
            y: Ne.pickedY,
            width: 1,
            height: 1
          },
          cullRect: J,
          effects: M,
          pass: `picking:${m}:z`
        }, !0);
        _e[3] && (me = _e[0]);
      }
      Ne.pickedLayer && Re + 1 < d && (oe.add(Ne.pickedLayer), Ne.pickedLayer.disablePickingIndex(Ne.pickedObjectIndex)), ie = J8({
        pickInfo: Ne,
        lastPickedInfo: this.lastPickedInfo,
        mode: m,
        layers: D,
        viewports: i,
        x: s,
        y: l,
        z: me,
        pixelRatio: E
      });
      for (const _e of ie.values())
        _e.layer && ye.push(_e);
      if (!Ne.pickedColor)
        break;
    }
    for (const Re of oe)
      Re.restorePickingColors();
    return {
      result: ye,
      emptyInfo: ie.get(null)
    };
  }
  /** Pick all objects within the given bounding box */
  _pickVisibleObjects(e) {
    let {
      layers: t,
      views: n,
      viewports: i,
      x: s,
      y: l,
      width: o = 1,
      height: d = 1,
      mode: m = "query",
      maxObjects: b = null,
      onViewportActive: T,
      effects: M
    } = e;
    const E = this._getPickable(t);
    if (!E || i.length === 0)
      return [];
    this._resizeBuffer();
    const D = this.device.canvasContext.cssToDeviceRatio(), U = this.device.canvasContext.cssToDevicePixels([s, l], !0), q = U.x, G = U.y + U.height, Y = this.device.canvasContext.cssToDevicePixels([s + o, l + d], !0), he = Y.x + Y.width, X = Y.y, J = {
      x: q,
      y: X,
      // deviceTop and deviceRight represent the first pixel outside the desired rect
      width: he - q,
      height: G - X
    }, ie = this._drawAndSample({
      layers: E,
      views: n,
      viewports: i,
      onViewportActive: T,
      deviceRect: J,
      cullRect: {
        x: s,
        y: l,
        width: o,
        height: d
      },
      effects: M,
      pass: `picking:${m}`
    }), ye = K8(ie), oe = /* @__PURE__ */ new Map(), Re = [], Ne = Number.isFinite(b);
    for (let me = 0; me < ye.length && !(Ne && Re.length >= b); me++) {
      const _e = ye[me];
      let Fe = {
        color: _e.pickedColor,
        layer: null,
        index: _e.pickedObjectIndex,
        picked: !0,
        x: s,
        y: l,
        pixelRatio: D
      };
      Fe = vC({
        layer: _e.pickedLayer,
        info: Fe,
        mode: m
      });
      const Me = Fe.layer.id;
      oe.has(Me) || oe.set(Me, /* @__PURE__ */ new Set());
      const Ct = oe.get(Me), ht = Fe.object ?? Fe.index;
      Ct.has(ht) || (Ct.add(ht), Re.push(Fe));
    }
    return Re;
  }
  _drawAndSample(e) {
    let {
      layers: t,
      views: n,
      viewports: i,
      onViewportActive: s,
      deviceRect: l,
      cullRect: o,
      effects: d,
      pass: m
    } = e, b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const T = b ? this.depthFBO : this.pickingFBO, M = {
      layers: t,
      layerFilter: this.layerFilter,
      views: n,
      viewports: i,
      onViewportActive: s,
      pickingFBO: T,
      deviceRect: l,
      cullRect: o,
      effects: d,
      pass: m,
      pickZ: b,
      preRenderStats: {},
      isPicking: !0
    };
    for (const he of d)
      he.useInPicking && (M.preRenderStats[he.id] = he.preRender(M));
    const {
      decodePickingColor: E
    } = this.pickLayersPass.render(M), {
      x: D,
      y: U,
      width: q,
      height: G
    } = l, Y = new (b ? Float32Array : Uint8Array)(q * G * 4);
    return this.device.readPixelsToArrayWebGL(T, {
      sourceX: D,
      sourceY: U,
      sourceWidth: q,
      sourceHeight: G,
      target: Y
    }), {
      pickedColors: Y,
      decodePickingColor: E
    };
  }
  // Calculate a picking rect centered on deviceX and deviceY and clipped to device
  // Returns null if pixel is outside of device
  _getPickingRect(e) {
    let {
      deviceX: t,
      deviceY: n,
      deviceRadius: i,
      deviceWidth: s,
      deviceHeight: l
    } = e;
    const o = Math.max(0, t - i), d = Math.max(0, n - i), m = Math.min(s, t + i + 1) - o, b = Math.min(l, n + i + 1) - d;
    return m <= 0 || b <= 0 ? null : {
      x: o,
      y: d,
      width: m,
      height: b
    };
  }
}
const tU = {
  "top-left": {
    top: 0,
    left: 0
  },
  "top-right": {
    top: 0,
    right: 0
  },
  "bottom-left": {
    bottom: 0,
    left: 0
  },
  "bottom-right": {
    bottom: 0,
    right: 0
  },
  fill: {
    top: 0,
    left: 0,
    bottom: 0,
    right: 0
  }
}, rU = "top-left", AT = "__root";
class nU {
  constructor(e) {
    let {
      deck: t,
      parentElement: n
    } = e;
    this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = t, this.parentElement = n;
  }
  getWidgets() {
    return this.resolvedWidgets;
  }
  /** Declarative API to configure widgets */
  setProps(e) {
    e.widgets && !Tc(e.widgets, this.widgets, 1) && this._setWidgets(e.widgets);
  }
  finalize() {
    for (const e of this.getWidgets())
      this._remove(e);
    this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
    for (const e in this.containers)
      this.containers[e].remove();
  }
  /** Imperative API. Widgets added this way are not affected by the declarative prop. */
  addDefault(e) {
    this.defaultWidgets.find((t) => t.id === e.id) || (this._add(e), this.defaultWidgets.push(e), this._setWidgets(this.widgets));
  }
  /** Resolve widgets from the declarative prop */
  _setWidgets(e) {
    const t = {};
    for (const n of this.resolvedWidgets)
      t[n.id] = n;
    this.resolvedWidgets.length = 0;
    for (const n of this.defaultWidgets)
      t[n.id] = null, this.resolvedWidgets.push(n);
    for (let n of e) {
      const i = t[n.id];
      i ? /* Widget placement changed */ i.viewId !== n.viewId || i.placement !== n.placement ? (this._remove(i), this._add(n)) : n !== i && (i.setProps(n.props), n = i) : this._add(n), t[n.id] = null, this.resolvedWidgets.push(n);
    }
    for (const n in t) {
      const i = t[n];
      i && this._remove(i);
    }
    this.widgets = e;
  }
  _add(e) {
    const {
      viewId: t = null,
      placement: n = rU
    } = e, i = e.onAdd({
      deck: this.deck,
      viewId: t
    });
    i && this._getContainer(t, n).append(i), e._element = i;
  }
  _remove(e) {
    var t;
    (t = e.onRemove) == null || t.call(e), e._element && e._element.remove(), e._element = void 0;
  }
  /* global document */
  _getContainer(e, t) {
    var l;
    const n = e || AT;
    let i = this.containers[n];
    i || (i = document.createElement("div"), i.style.pointerEvents = "none", i.style.position = "absolute", i.style.overflow = "hidden", (l = this.parentElement) == null || l.append(i), this.containers[n] = i);
    let s = i.querySelector(`.${t}`);
    return s || (s = document.createElement("div"), s.className = t, s.style.position = "absolute", s.style.zIndex = "2", Object.assign(s.style, tU[t]), i.append(s)), s;
  }
  _updateContainers() {
    const e = this.deck.width, t = this.deck.height;
    for (const n in this.containers) {
      const i = this.lastViewports[n] || null, s = n === AT || i, l = this.containers[n];
      s ? (l.style.display = "block", l.style.left = `${i ? i.x : 0}px`, l.style.top = `${i ? i.y : 0}px`, l.style.width = `${i ? i.width : e}px`, l.style.height = `${i ? i.height : t}px`) : l.style.display = "none";
    }
  }
  onRedraw(e) {
    var s, l;
    let {
      viewports: t,
      layers: n
    } = e;
    const i = t.reduce((o, d) => (o[d.id] = d, o), {});
    for (const o of this.getWidgets()) {
      const {
        viewId: d
      } = o;
      if (d) {
        const m = i[d];
        m && (o.onViewportChange && o.onViewportChange(m), (s = o.onRedraw) == null || s.call(o, {
          viewports: [m],
          layers: n
        }));
      } else {
        if (o.onViewportChange)
          for (const m of t)
            o.onViewportChange(m);
        (l = o.onRedraw) == null || l.call(o, {
          viewports: t,
          layers: n
        });
      }
    }
    this.lastViewports = i, this._updateContainers();
  }
  onHover(e, t) {
    var n, i;
    for (const s of this.getWidgets()) {
      const {
        viewId: l
      } = s;
      (!l || l === ((n = e.viewport) == null ? void 0 : n.id)) && ((i = s.onHover) == null || i.call(s, e, t));
    }
  }
  onEvent(e, t) {
    var i, s;
    const n = j1[t.type];
    if (n)
      for (const l of this.getWidgets()) {
        const {
          viewId: o
        } = l;
        (!o || o === ((i = e.viewport) == null ? void 0 : i.id)) && ((s = l[n]) == null || s.call(l, e, t));
      }
  }
}
const iU = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class sU {
  constructor() {
    this.id = "default-tooltip", this.placement = "fill", this.props = {}, this.isVisible = !1;
  }
  onAdd(e) {
    let {
      deck: t
    } = e;
    const n = document.createElement("div");
    return n.className = "deck-tooltip", Object.assign(n.style, iU), this.deck = t, this.element = n, n;
  }
  onRemove() {
    this.deck = void 0, this.element = void 0;
  }
  setProps() {
  }
  onViewportChange(e) {
    var t;
    this.isVisible && e.id === ((t = this.lastViewport) == null ? void 0 : t.id) && e !== this.lastViewport && this.setTooltip(null);
  }
  onHover(e) {
    const {
      deck: t
    } = this, n = t && t.props.getTooltip;
    if (!n)
      return;
    const i = n(e);
    this.lastViewport = e.viewport, this.setTooltip(i, e.x, e.y);
  }
  setTooltip(e, t, n) {
    const i = this.element;
    if (i) {
      if (typeof e == "string")
        i.innerText = e;
      else if (e)
        e.text && (i.innerText = e.text), e.html && (i.innerHTML = e.html), e.className && (i.className = e.className);
      else {
        this.isVisible = !1, i.style.display = "none";
        return;
      }
      this.isVisible = !0, i.style.display = "block", i.style.transform = `translate(${t}px, ${n}px)`, e && typeof e == "object" && "style" in e && Object.assign(i.style, e.style);
    }
  }
}
var _d;
(function(r) {
  r[r.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", r[r.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", r[r.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", r[r.POINTS = 0] = "POINTS", r[r.LINES = 1] = "LINES", r[r.LINE_LOOP = 2] = "LINE_LOOP", r[r.LINE_STRIP = 3] = "LINE_STRIP", r[r.TRIANGLES = 4] = "TRIANGLES", r[r.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", r[r.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", r[r.ZERO = 0] = "ZERO", r[r.ONE = 1] = "ONE", r[r.SRC_COLOR = 768] = "SRC_COLOR", r[r.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", r[r.SRC_ALPHA = 770] = "SRC_ALPHA", r[r.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", r[r.DST_ALPHA = 772] = "DST_ALPHA", r[r.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", r[r.DST_COLOR = 774] = "DST_COLOR", r[r.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", r[r.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", r[r.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", r[r.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", r[r.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", r[r.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", r[r.FUNC_ADD = 32774] = "FUNC_ADD", r[r.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", r[r.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", r[r.BLEND_EQUATION = 32777] = "BLEND_EQUATION", r[r.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", r[r.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", r[r.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", r[r.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", r[r.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", r[r.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", r[r.BLEND_COLOR = 32773] = "BLEND_COLOR", r[r.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", r[r.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", r[r.LINE_WIDTH = 2849] = "LINE_WIDTH", r[r.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", r[r.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", r[r.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", r[r.FRONT_FACE = 2886] = "FRONT_FACE", r[r.DEPTH_RANGE = 2928] = "DEPTH_RANGE", r[r.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", r[r.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", r[r.DEPTH_FUNC = 2932] = "DEPTH_FUNC", r[r.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", r[r.STENCIL_FUNC = 2962] = "STENCIL_FUNC", r[r.STENCIL_FAIL = 2964] = "STENCIL_FAIL", r[r.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", r[r.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", r[r.STENCIL_REF = 2967] = "STENCIL_REF", r[r.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", r[r.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", r[r.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", r[r.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", r[r.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", r[r.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", r[r.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", r[r.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", r[r.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", r[r.VIEWPORT = 2978] = "VIEWPORT", r[r.SCISSOR_BOX = 3088] = "SCISSOR_BOX", r[r.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", r[r.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", r[r.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", r[r.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", r[r.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", r[r.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", r[r.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", r[r.RED_BITS = 3410] = "RED_BITS", r[r.GREEN_BITS = 3411] = "GREEN_BITS", r[r.BLUE_BITS = 3412] = "BLUE_BITS", r[r.ALPHA_BITS = 3413] = "ALPHA_BITS", r[r.DEPTH_BITS = 3414] = "DEPTH_BITS", r[r.STENCIL_BITS = 3415] = "STENCIL_BITS", r[r.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", r[r.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", r[r.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", r[r.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", r[r.SAMPLES = 32937] = "SAMPLES", r[r.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", r[r.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", r[r.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", r[r.VENDOR = 7936] = "VENDOR", r[r.RENDERER = 7937] = "RENDERER", r[r.VERSION = 7938] = "VERSION", r[r.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", r[r.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", r[r.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", r[r.STATIC_DRAW = 35044] = "STATIC_DRAW", r[r.STREAM_DRAW = 35040] = "STREAM_DRAW", r[r.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", r[r.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", r[r.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", r[r.BUFFER_SIZE = 34660] = "BUFFER_SIZE", r[r.BUFFER_USAGE = 34661] = "BUFFER_USAGE", r[r.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", r[r.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", r[r.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", r[r.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", r[r.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", r[r.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", r[r.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", r[r.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", r[r.CULL_FACE = 2884] = "CULL_FACE", r[r.FRONT = 1028] = "FRONT", r[r.BACK = 1029] = "BACK", r[r.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", r[r.BLEND = 3042] = "BLEND", r[r.DEPTH_TEST = 2929] = "DEPTH_TEST", r[r.DITHER = 3024] = "DITHER", r[r.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", r[r.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", r[r.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", r[r.SCISSOR_TEST = 3089] = "SCISSOR_TEST", r[r.STENCIL_TEST = 2960] = "STENCIL_TEST", r[r.NO_ERROR = 0] = "NO_ERROR", r[r.INVALID_ENUM = 1280] = "INVALID_ENUM", r[r.INVALID_VALUE = 1281] = "INVALID_VALUE", r[r.INVALID_OPERATION = 1282] = "INVALID_OPERATION", r[r.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", r[r.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", r[r.CW = 2304] = "CW", r[r.CCW = 2305] = "CCW", r[r.DONT_CARE = 4352] = "DONT_CARE", r[r.FASTEST = 4353] = "FASTEST", r[r.NICEST = 4354] = "NICEST", r[r.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", r[r.BYTE = 5120] = "BYTE", r[r.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", r[r.SHORT = 5122] = "SHORT", r[r.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", r[r.INT = 5124] = "INT", r[r.UNSIGNED_INT = 5125] = "UNSIGNED_INT", r[r.FLOAT = 5126] = "FLOAT", r[r.DOUBLE = 5130] = "DOUBLE", r[r.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", r[r.ALPHA = 6406] = "ALPHA", r[r.RGB = 6407] = "RGB", r[r.RGBA = 6408] = "RGBA", r[r.LUMINANCE = 6409] = "LUMINANCE", r[r.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", r[r.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", r[r.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", r[r.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", r[r.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", r[r.VERTEX_SHADER = 35633] = "VERTEX_SHADER", r[r.COMPILE_STATUS = 35713] = "COMPILE_STATUS", r[r.DELETE_STATUS = 35712] = "DELETE_STATUS", r[r.LINK_STATUS = 35714] = "LINK_STATUS", r[r.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", r[r.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", r[r.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", r[r.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", r[r.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", r[r.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", r[r.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", r[r.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", r[r.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", r[r.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", r[r.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", r[r.SHADER_TYPE = 35663] = "SHADER_TYPE", r[r.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", r[r.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", r[r.NEVER = 512] = "NEVER", r[r.LESS = 513] = "LESS", r[r.EQUAL = 514] = "EQUAL", r[r.LEQUAL = 515] = "LEQUAL", r[r.GREATER = 516] = "GREATER", r[r.NOTEQUAL = 517] = "NOTEQUAL", r[r.GEQUAL = 518] = "GEQUAL", r[r.ALWAYS = 519] = "ALWAYS", r[r.KEEP = 7680] = "KEEP", r[r.REPLACE = 7681] = "REPLACE", r[r.INCR = 7682] = "INCR", r[r.DECR = 7683] = "DECR", r[r.INVERT = 5386] = "INVERT", r[r.INCR_WRAP = 34055] = "INCR_WRAP", r[r.DECR_WRAP = 34056] = "DECR_WRAP", r[r.NEAREST = 9728] = "NEAREST", r[r.LINEAR = 9729] = "LINEAR", r[r.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", r[r.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", r[r.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", r[r.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", r[r.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", r[r.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", r[r.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", r[r.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", r[r.TEXTURE_2D = 3553] = "TEXTURE_2D", r[r.TEXTURE = 5890] = "TEXTURE", r[r.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", r[r.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", r[r.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", r[r.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", r[r.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", r[r.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", r[r.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", r[r.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", r[r.TEXTURE0 = 33984] = "TEXTURE0", r[r.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", r[r.REPEAT = 10497] = "REPEAT", r[r.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", r[r.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", r[r.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", r[r.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", r[r.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", r[r.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", r[r.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", r[r.INT_VEC2 = 35667] = "INT_VEC2", r[r.INT_VEC3 = 35668] = "INT_VEC3", r[r.INT_VEC4 = 35669] = "INT_VEC4", r[r.BOOL = 35670] = "BOOL", r[r.BOOL_VEC2 = 35671] = "BOOL_VEC2", r[r.BOOL_VEC3 = 35672] = "BOOL_VEC3", r[r.BOOL_VEC4 = 35673] = "BOOL_VEC4", r[r.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", r[r.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", r[r.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", r[r.SAMPLER_2D = 35678] = "SAMPLER_2D", r[r.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", r[r.LOW_FLOAT = 36336] = "LOW_FLOAT", r[r.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", r[r.HIGH_FLOAT = 36338] = "HIGH_FLOAT", r[r.LOW_INT = 36339] = "LOW_INT", r[r.MEDIUM_INT = 36340] = "MEDIUM_INT", r[r.HIGH_INT = 36341] = "HIGH_INT", r[r.FRAMEBUFFER = 36160] = "FRAMEBUFFER", r[r.RENDERBUFFER = 36161] = "RENDERBUFFER", r[r.RGBA4 = 32854] = "RGBA4", r[r.RGB5_A1 = 32855] = "RGB5_A1", r[r.RGB565 = 36194] = "RGB565", r[r.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", r[r.STENCIL_INDEX = 6401] = "STENCIL_INDEX", r[r.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", r[r.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", r[r.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", r[r.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", r[r.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", r[r.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", r[r.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", r[r.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", r[r.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", r[r.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", r[r.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", r[r.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", r[r.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", r[r.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", r[r.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", r[r.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", r[r.NONE = 0] = "NONE", r[r.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", r[r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", r[r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", r[r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", r[r.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", r[r.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", r[r.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", r[r.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", r[r.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", r[r.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", r[r.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", r[r.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", r[r.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", r[r.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", r[r.READ_BUFFER = 3074] = "READ_BUFFER", r[r.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", r[r.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", r[r.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", r[r.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", r[r.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", r[r.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", r[r.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", r[r.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", r[r.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", r[r.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", r[r.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", r[r.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", r[r.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", r[r.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", r[r.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", r[r.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", r[r.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", r[r.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", r[r.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", r[r.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", r[r.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", r[r.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", r[r.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", r[r.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", r[r.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", r[r.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", r[r.RED = 6403] = "RED", r[r.RGB8 = 32849] = "RGB8", r[r.RGBA8 = 32856] = "RGBA8", r[r.RGB10_A2 = 32857] = "RGB10_A2", r[r.TEXTURE_3D = 32879] = "TEXTURE_3D", r[r.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", r[r.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", r[r.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", r[r.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", r[r.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", r[r.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", r[r.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", r[r.SRGB = 35904] = "SRGB", r[r.SRGB8 = 35905] = "SRGB8", r[r.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", r[r.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", r[r.RGBA32F = 34836] = "RGBA32F", r[r.RGB32F = 34837] = "RGB32F", r[r.RGBA16F = 34842] = "RGBA16F", r[r.RGB16F = 34843] = "RGB16F", r[r.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", r[r.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", r[r.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", r[r.RGB9_E5 = 35901] = "RGB9_E5", r[r.RGBA32UI = 36208] = "RGBA32UI", r[r.RGB32UI = 36209] = "RGB32UI", r[r.RGBA16UI = 36214] = "RGBA16UI", r[r.RGB16UI = 36215] = "RGB16UI", r[r.RGBA8UI = 36220] = "RGBA8UI", r[r.RGB8UI = 36221] = "RGB8UI", r[r.RGBA32I = 36226] = "RGBA32I", r[r.RGB32I = 36227] = "RGB32I", r[r.RGBA16I = 36232] = "RGBA16I", r[r.RGB16I = 36233] = "RGB16I", r[r.RGBA8I = 36238] = "RGBA8I", r[r.RGB8I = 36239] = "RGB8I", r[r.RED_INTEGER = 36244] = "RED_INTEGER", r[r.RGB_INTEGER = 36248] = "RGB_INTEGER", r[r.RGBA_INTEGER = 36249] = "RGBA_INTEGER", r[r.R8 = 33321] = "R8", r[r.RG8 = 33323] = "RG8", r[r.R16F = 33325] = "R16F", r[r.R32F = 33326] = "R32F", r[r.RG16F = 33327] = "RG16F", r[r.RG32F = 33328] = "RG32F", r[r.R8I = 33329] = "R8I", r[r.R8UI = 33330] = "R8UI", r[r.R16I = 33331] = "R16I", r[r.R16UI = 33332] = "R16UI", r[r.R32I = 33333] = "R32I", r[r.R32UI = 33334] = "R32UI", r[r.RG8I = 33335] = "RG8I", r[r.RG8UI = 33336] = "RG8UI", r[r.RG16I = 33337] = "RG16I", r[r.RG16UI = 33338] = "RG16UI", r[r.RG32I = 33339] = "RG32I", r[r.RG32UI = 33340] = "RG32UI", r[r.R8_SNORM = 36756] = "R8_SNORM", r[r.RG8_SNORM = 36757] = "RG8_SNORM", r[r.RGB8_SNORM = 36758] = "RGB8_SNORM", r[r.RGBA8_SNORM = 36759] = "RGBA8_SNORM", r[r.RGB10_A2UI = 36975] = "RGB10_A2UI", r[r.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", r[r.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", r[r.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", r[r.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", r[r.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", r[r.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", r[r.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", r[r.HALF_FLOAT = 5131] = "HALF_FLOAT", r[r.RG = 33319] = "RG", r[r.RG_INTEGER = 33320] = "RG_INTEGER", r[r.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", r[r.CURRENT_QUERY = 34917] = "CURRENT_QUERY", r[r.QUERY_RESULT = 34918] = "QUERY_RESULT", r[r.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", r[r.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", r[r.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", r[r.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", r[r.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", r[r.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", r[r.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", r[r.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", r[r.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", r[r.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", r[r.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", r[r.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", r[r.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", r[r.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", r[r.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", r[r.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", r[r.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", r[r.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", r[r.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", r[r.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", r[r.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", r[r.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", r[r.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", r[r.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", r[r.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", r[r.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", r[r.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", r[r.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", r[r.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", r[r.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", r[r.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", r[r.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", r[r.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", r[r.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", r[r.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", r[r.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", r[r.SAMPLER_3D = 35679] = "SAMPLER_3D", r[r.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", r[r.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", r[r.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", r[r.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", r[r.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", r[r.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", r[r.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", r[r.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", r[r.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", r[r.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", r[r.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", r[r.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", r[r.MAX_SAMPLES = 36183] = "MAX_SAMPLES", r[r.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", r[r.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", r[r.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", r[r.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", r[r.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", r[r.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", r[r.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", r[r.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", r[r.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", r[r.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", r[r.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", r[r.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", r[r.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", r[r.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", r[r.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", r[r.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", r[r.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", r[r.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", r[r.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", r[r.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", r[r.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", r[r.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", r[r.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", r[r.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", r[r.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", r[r.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", r[r.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", r[r.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", r[r.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", r[r.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", r[r.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", r[r.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", r[r.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", r[r.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", r[r.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", r[r.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", r[r.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", r[r.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", r[r.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", r[r.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", r[r.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", r[r.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", r[r.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", r[r.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", r[r.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", r[r.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", r[r.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", r[r.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", r[r.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", r[r.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", r[r.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", r[r.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", r[r.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", r[r.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", r[r.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", r[r.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", r[r.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", r[r.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", r[r.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", r[r.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", r[r.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", r[r.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", r[r.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", r[r.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", r[r.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", r[r.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", r[r.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", r[r.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", r[r.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", r[r.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", r[r.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", r[r.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", r[r.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", r[r.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", r[r.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", r[r.OBJECT_TYPE = 37138] = "OBJECT_TYPE", r[r.SYNC_CONDITION = 37139] = "SYNC_CONDITION", r[r.SYNC_STATUS = 37140] = "SYNC_STATUS", r[r.SYNC_FLAGS = 37141] = "SYNC_FLAGS", r[r.SYNC_FENCE = 37142] = "SYNC_FENCE", r[r.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", r[r.UNSIGNALED = 37144] = "UNSIGNALED", r[r.SIGNALED = 37145] = "SIGNALED", r[r.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", r[r.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", r[r.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", r[r.WAIT_FAILED = 37149] = "WAIT_FAILED", r[r.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", r[r.COLOR = 6144] = "COLOR", r[r.DEPTH = 6145] = "DEPTH", r[r.STENCIL = 6146] = "STENCIL", r[r.MIN = 32775] = "MIN", r[r.MAX = 32776] = "MAX", r[r.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", r[r.STREAM_READ = 35041] = "STREAM_READ", r[r.STREAM_COPY = 35042] = "STREAM_COPY", r[r.STATIC_READ = 35045] = "STATIC_READ", r[r.STATIC_COPY = 35046] = "STATIC_COPY", r[r.DYNAMIC_READ = 35049] = "DYNAMIC_READ", r[r.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", r[r.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", r[r.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", r[r.INVALID_INDEX = 4294967295] = "INVALID_INDEX", r[r.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", r[r.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", r[r.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", r[r.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", r[r.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", r[r.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", r[r.R16_EXT = 33322] = "R16_EXT", r[r.RG16_EXT = 33324] = "RG16_EXT", r[r.RGB16_EXT = 32852] = "RGB16_EXT", r[r.RGBA16_EXT = 32859] = "RGBA16_EXT", r[r.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", r[r.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", r[r.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", r[r.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", r[r.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", r[r.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", r[r.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", r[r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", r[r.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", r[r.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", r[r.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", r[r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", r[r.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", r[r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", r[r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", r[r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", r[r.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", r[r.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", r[r.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", r[r.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", r[r.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", r[r.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", r[r.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", r[r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", r[r.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", r[r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", r[r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", r[r.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", r[r.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", r[r.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", r[r.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", r[r.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", r[r.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", r[r.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", r[r.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", r[r.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", r[r.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", r[r.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", r[r.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", r[r.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", r[r.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", r[r.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", r[r.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", r[r.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", r[r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", r[r.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", r[r.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", r[r.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", r[r.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", r[r.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", r[r.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", r[r.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", r[r.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", r[r.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", r[r.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", r[r.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", r[r.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", r[r.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", r[r.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", r[r.LINE_WEBGL = 6913] = "LINE_WEBGL", r[r.FILL_WEBGL = 6914] = "FILL_WEBGL", r[r.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", r[r.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", r[r.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", r[r.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", r[r.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", r[r.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", r[r.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", r[r.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", r[r.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", r[r.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", r[r.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", r[r.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", r[r.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", r[r.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", r[r.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", r[r.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", r[r.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", r[r.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", r[r.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", r[r.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", r[r.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", r[r.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", r[r.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", r[r.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
})(_d || (_d = {}));
const I2 = {
  3042: !1,
  32773: new Float32Array([0, 0, 0, 0]),
  32777: 32774,
  34877: 32774,
  32969: 1,
  32968: 0,
  32971: 1,
  32970: 0,
  3106: new Float32Array([0, 0, 0, 0]),
  // TBD
  3107: [!0, !0, !0, !0],
  2884: !1,
  2885: 1029,
  2929: !1,
  2931: 1,
  2932: 513,
  2928: new Float32Array([0, 1]),
  // TBD
  2930: !0,
  3024: !0,
  35725: null,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: null,
  36007: null,
  34229: null,
  34964: null,
  2886: 2305,
  33170: 4352,
  2849: 1,
  32823: !1,
  32824: 0,
  10752: 0,
  32926: !1,
  32928: !1,
  32938: 1,
  32939: !1,
  3089: !1,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  3088: new Int32Array([0, 0, 1024, 1024]),
  2960: !1,
  2961: 0,
  2968: 4294967295,
  36005: 4294967295,
  2962: 519,
  2967: 0,
  2963: 4294967295,
  34816: 519,
  36003: 0,
  36004: 4294967295,
  2964: 7680,
  2965: 7680,
  2966: 7680,
  34817: 7680,
  34818: 7680,
  34819: 7680,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  2978: [0, 0, 1024, 1024],
  36389: null,
  36662: null,
  36663: null,
  35053: null,
  35055: null,
  35723: 4352,
  36010: null,
  35977: !1,
  3333: 4,
  3317: 4,
  37440: !1,
  37441: !1,
  37443: 37444,
  3330: 0,
  3332: 0,
  3331: 0,
  3314: 0,
  32878: 0,
  3316: 0,
  3315: 0,
  32877: 0
}, Ns = (r, e, t) => e ? r.enable(t) : r.disable(t), TT = (r, e, t) => r.hint(t, e), Ha = (r, e, t) => r.pixelStorei(t, e), ST = (r, e, t) => {
  const n = t === 36006 ? 36009 : 36008;
  return r.bindFramebuffer(n, e);
}, Bp = (r, e, t) => {
  const i = {
    34964: 34962,
    36662: 36662,
    36663: 36663,
    35053: 35051,
    35055: 35052
  }[t];
  r.bindBuffer(i, e);
};
function cb(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r) && !(r instanceof DataView);
}
const oU = {
  3042: Ns,
  32773: (r, e) => r.blendColor(...e),
  32777: "blendEquation",
  34877: "blendEquation",
  32969: "blendFunc",
  32968: "blendFunc",
  32971: "blendFunc",
  32970: "blendFunc",
  3106: (r, e) => r.clearColor(...e),
  3107: (r, e) => r.colorMask(...e),
  2884: Ns,
  2885: (r, e) => r.cullFace(e),
  2929: Ns,
  2931: (r, e) => r.clearDepth(e),
  2932: (r, e) => r.depthFunc(e),
  2928: (r, e) => r.depthRange(...e),
  2930: (r, e) => r.depthMask(e),
  3024: Ns,
  35723: TT,
  35725: (r, e) => r.useProgram(e),
  36007: (r, e) => r.bindRenderbuffer(36161, e),
  36389: (r, e) => {
    var t;
    return (t = r.bindTransformFeedback) == null ? void 0 : t.call(r, 36386, e);
  },
  34229: (r, e) => r.bindVertexArray(e),
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  36006: ST,
  36010: ST,
  // Buffers
  34964: Bp,
  36662: Bp,
  36663: Bp,
  35053: Bp,
  35055: Bp,
  2886: (r, e) => r.frontFace(e),
  33170: TT,
  2849: (r, e) => r.lineWidth(e),
  32823: Ns,
  32824: "polygonOffset",
  10752: "polygonOffset",
  35977: Ns,
  32926: Ns,
  32928: Ns,
  32938: "sampleCoverage",
  32939: "sampleCoverage",
  3089: Ns,
  3088: (r, e) => r.scissor(...e),
  2960: Ns,
  2961: (r, e) => r.clearStencil(e),
  2968: (r, e) => r.stencilMaskSeparate(1028, e),
  36005: (r, e) => r.stencilMaskSeparate(1029, e),
  2962: "stencilFuncFront",
  2967: "stencilFuncFront",
  2963: "stencilFuncFront",
  34816: "stencilFuncBack",
  36003: "stencilFuncBack",
  36004: "stencilFuncBack",
  2964: "stencilOpFront",
  2965: "stencilOpFront",
  2966: "stencilOpFront",
  34817: "stencilOpBack",
  34818: "stencilOpBack",
  34819: "stencilOpBack",
  2978: (r, e) => r.viewport(...e),
  // WEBGL2 EXTENSIONS
  // EXT_depth_clamp https://registry.khronos.org/webgl/extensions/EXT_depth_clamp/
  34383: Ns,
  // WEBGL_provoking_vertex https://registry.khronos.org/webgl/extensions/WEBGL_provoking_vertex/
  // [GL.PROVOKING_VERTEX_WEBL]: TODO - extension function needed
  // WEBGL_polygon_mode https://registry.khronos.org/webgl/extensions/WEBGL_polygon_mode/
  // POLYGON_MODE_WEBGL  TODO - extension function needed
  10754: Ns,
  // WEBGL_clip_cull_distance https://registry.khronos.org/webgl/extensions/WEBGL_clip_cull_distance/
  12288: Ns,
  12289: Ns,
  12290: Ns,
  12291: Ns,
  12292: Ns,
  12293: Ns,
  12294: Ns,
  12295: Ns,
  // PIXEL PACK/UNPACK MODES
  3333: Ha,
  3317: Ha,
  37440: Ha,
  37441: Ha,
  37443: Ha,
  3330: Ha,
  3332: Ha,
  3331: Ha,
  3314: Ha,
  32878: Ha,
  3316: Ha,
  3315: Ha,
  32877: Ha,
  // Function-style setters
  framebuffer: (r, e) => {
    const t = e && "handle" in e ? e.handle : e;
    return r.bindFramebuffer(36160, t);
  },
  blend: (r, e) => e ? r.enable(3042) : r.disable(3042),
  blendColor: (r, e) => r.blendColor(...e),
  blendEquation: (r, e) => {
    const t = typeof e == "number" ? [e, e] : e;
    r.blendEquationSeparate(...t);
  },
  blendFunc: (r, e) => {
    const t = (e == null ? void 0 : e.length) === 2 ? [...e, ...e] : e;
    r.blendFuncSeparate(...t);
  },
  clearColor: (r, e) => r.clearColor(...e),
  clearDepth: (r, e) => r.clearDepth(e),
  clearStencil: (r, e) => r.clearStencil(e),
  colorMask: (r, e) => r.colorMask(...e),
  cull: (r, e) => e ? r.enable(2884) : r.disable(2884),
  cullFace: (r, e) => r.cullFace(e),
  depthTest: (r, e) => e ? r.enable(2929) : r.disable(2929),
  depthFunc: (r, e) => r.depthFunc(e),
  depthMask: (r, e) => r.depthMask(e),
  depthRange: (r, e) => r.depthRange(...e),
  dither: (r, e) => e ? r.enable(3024) : r.disable(3024),
  derivativeHint: (r, e) => {
    r.hint(35723, e);
  },
  frontFace: (r, e) => r.frontFace(e),
  mipmapHint: (r, e) => r.hint(33170, e),
  lineWidth: (r, e) => r.lineWidth(e),
  polygonOffsetFill: (r, e) => e ? r.enable(32823) : r.disable(32823),
  polygonOffset: (r, e) => r.polygonOffset(...e),
  sampleCoverage: (r, e) => r.sampleCoverage(e[0], e[1] || !1),
  scissorTest: (r, e) => e ? r.enable(3089) : r.disable(3089),
  scissor: (r, e) => r.scissor(...e),
  stencilTest: (r, e) => e ? r.enable(2960) : r.disable(2960),
  stencilMask: (r, e) => {
    e = cb(e) ? e : [e, e];
    const [t, n] = e;
    r.stencilMaskSeparate(1028, t), r.stencilMaskSeparate(1029, n);
  },
  stencilFunc: (r, e) => {
    e = cb(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, n, i, s, l, o] = e;
    r.stencilFuncSeparate(1028, t, n, i), r.stencilFuncSeparate(1029, s, l, o);
  },
  stencilOp: (r, e) => {
    e = cb(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, n, i, s, l, o] = e;
    r.stencilOpSeparate(1028, t, n, i), r.stencilOpSeparate(1029, s, l, o);
  },
  viewport: (r, e) => r.viewport(...e)
};
function ss(r, e, t) {
  return e[r] !== void 0 ? e[r] : t[r];
}
const aU = {
  blendEquation: (r, e, t) => r.blendEquationSeparate(ss(32777, e, t), ss(34877, e, t)),
  blendFunc: (r, e, t) => r.blendFuncSeparate(ss(32969, e, t), ss(32968, e, t), ss(32971, e, t), ss(32970, e, t)),
  polygonOffset: (r, e, t) => r.polygonOffset(ss(32824, e, t), ss(10752, e, t)),
  sampleCoverage: (r, e, t) => r.sampleCoverage(ss(32938, e, t), ss(32939, e, t)),
  stencilFuncFront: (r, e, t) => r.stencilFuncSeparate(1028, ss(2962, e, t), ss(2967, e, t), ss(2963, e, t)),
  stencilFuncBack: (r, e, t) => r.stencilFuncSeparate(1029, ss(34816, e, t), ss(36003, e, t), ss(36004, e, t)),
  stencilOpFront: (r, e, t) => r.stencilOpSeparate(1028, ss(2964, e, t), ss(2965, e, t), ss(2966, e, t)),
  stencilOpBack: (r, e, t) => r.stencilOpSeparate(1029, ss(34817, e, t), ss(34818, e, t), ss(34819, e, t))
}, ET = {
  // GENERIC SETTERS
  enable: (r, e) => r({
    [e]: !0
  }),
  disable: (r, e) => r({
    [e]: !1
  }),
  pixelStorei: (r, e, t) => r({
    [e]: t
  }),
  hint: (r, e, t) => r({
    [e]: t
  }),
  // SPECIFIC SETTERS
  useProgram: (r, e) => r({
    35725: e
  }),
  bindRenderbuffer: (r, e, t) => r({
    36007: t
  }),
  bindTransformFeedback: (r, e, t) => r({
    36389: t
  }),
  bindVertexArray: (r, e) => r({
    34229: e
  }),
  bindFramebuffer: (r, e, t) => {
    switch (e) {
      case 36160:
        return r({
          36006: t,
          36010: t
        });
      case 36009:
        return r({
          36006: t
        });
      case 36008:
        return r({
          36010: t
        });
      default:
        return null;
    }
  },
  bindBuffer: (r, e, t) => {
    const n = {
      34962: [34964],
      36662: [36662],
      36663: [36663],
      35051: [35053],
      35052: [35055]
    }[e];
    return n ? r({
      [n]: t
    }) : {
      valueChanged: !0
    };
  },
  blendColor: (r, e, t, n, i) => r({
    32773: new Float32Array([e, t, n, i])
  }),
  blendEquation: (r, e) => r({
    32777: e,
    34877: e
  }),
  blendEquationSeparate: (r, e, t) => r({
    32777: e,
    34877: t
  }),
  blendFunc: (r, e, t) => r({
    32969: e,
    32968: t,
    32971: e,
    32970: t
  }),
  blendFuncSeparate: (r, e, t, n, i) => r({
    32969: e,
    32968: t,
    32971: n,
    32970: i
  }),
  clearColor: (r, e, t, n, i) => r({
    3106: new Float32Array([e, t, n, i])
  }),
  clearDepth: (r, e) => r({
    2931: e
  }),
  clearStencil: (r, e) => r({
    2961: e
  }),
  colorMask: (r, e, t, n, i) => r({
    3107: [e, t, n, i]
  }),
  cullFace: (r, e) => r({
    2885: e
  }),
  depthFunc: (r, e) => r({
    2932: e
  }),
  depthRange: (r, e, t) => r({
    2928: new Float32Array([e, t])
  }),
  depthMask: (r, e) => r({
    2930: e
  }),
  frontFace: (r, e) => r({
    2886: e
  }),
  lineWidth: (r, e) => r({
    2849: e
  }),
  polygonOffset: (r, e, t) => r({
    32824: e,
    10752: t
  }),
  sampleCoverage: (r, e, t) => r({
    32938: e,
    32939: t
  }),
  scissor: (r, e, t, n, i) => r({
    3088: new Int32Array([e, t, n, i])
  }),
  stencilMask: (r, e) => r({
    2968: e,
    36005: e
  }),
  stencilMaskSeparate: (r, e, t) => r({
    [e === 1028 ? 2968 : 36005]: t
  }),
  stencilFunc: (r, e, t, n) => r({
    2962: e,
    2967: t,
    2963: n,
    34816: e,
    36003: t,
    36004: n
  }),
  stencilFuncSeparate: (r, e, t, n, i) => r({
    [e === 1028 ? 2962 : 34816]: t,
    [e === 1028 ? 2967 : 36003]: n,
    [e === 1028 ? 2963 : 36004]: i
  }),
  stencilOp: (r, e, t, n) => r({
    2964: e,
    2965: t,
    2966: n,
    34817: e,
    34818: t,
    34819: n
  }),
  stencilOpSeparate: (r, e, t, n, i) => r({
    [e === 1028 ? 2964 : 34817]: t,
    [e === 1028 ? 2965 : 34818]: n,
    [e === 1028 ? 2966 : 34819]: i
  }),
  viewport: (r, e, t, n, i) => r({
    2978: [e, t, n, i]
  })
}, eu = (r, e) => r.isEnabled(e), CT = {
  3042: eu,
  2884: eu,
  2929: eu,
  3024: eu,
  32823: eu,
  32926: eu,
  32928: eu,
  3089: eu,
  2960: eu,
  35977: eu
}, lU = /* @__PURE__ */ new Set([34016, 36388, 36387, 35983, 35368, 34965, 35739, 35738, 3074, 34853, 34854, 34855, 34856, 34857, 34858, 34859, 34860, 34861, 34862, 34863, 34864, 34865, 34866, 34867, 34868, 35097, 32873, 35869, 32874, 34068]);
function ep(r, e) {
  if (uU(e))
    return;
  const t = {};
  for (const i in e) {
    const s = Number(i), l = oU[i];
    l && (typeof l == "string" ? t[l] = !0 : l(r, e[i], s));
  }
  const n = r.state && r.state.cache;
  if (n)
    for (const i in t) {
      const s = aU[i];
      s(r, e, n);
    }
}
function xC(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : I2;
  if (typeof e == "number") {
    const i = e, s = CT[i];
    return s ? s(r, i) : r.getParameter(i);
  }
  const t = Array.isArray(e) ? e : Object.keys(e), n = {};
  for (const i of t) {
    const s = CT[i];
    n[i] = s ? s(r, Number(i)) : r.getParameter(Number(i));
  }
  return n;
}
function cU(r) {
  ep(r, I2);
}
function uU(r) {
  for (const e in r)
    return !1;
  return !0;
}
function hU(r, e) {
  if (r === e)
    return !0;
  const t = Array.isArray(r) || ArrayBuffer.isView(r), n = Array.isArray(e) || ArrayBuffer.isView(e);
  if (t && n && r.length === e.length) {
    for (let i = 0; i < r.length; ++i)
      if (r[i] !== e[i])
        return !1;
    return !0;
  }
  return !1;
}
class vf {
  constructor(e, t) {
    H(this, "gl");
    H(this, "program", null);
    H(this, "stateStack", []);
    H(this, "enable", !0);
    H(this, "cache", null);
    H(this, "log");
    H(this, "initialized", !1);
    this.gl = e, this.log = (t == null ? void 0 : t.log) || (() => {
    }), this._updateCache = this._updateCache.bind(this), Object.seal(this);
  }
  static get(e) {
    return e.state;
  }
  push() {
    this.stateStack.push({});
  }
  pop() {
    const e = this.stateStack[this.stateStack.length - 1];
    ep(this.gl, e), this.stateStack.pop();
  }
  /**
   * Initialize WebGL state caching on a context
   * can be called multiple times to enable/disable
   *
   * @note After calling this function, context state will be cached
   * .push() and .pop() will be available for saving,
   * temporarily modifying, and then restoring state.
   */
  trackState(e, t) {
    if (this.cache = t.copyState ? xC(e) : Object.assign({}, I2), this.initialized)
      throw new Error("WebGLStateTracker");
    this.initialized = !0, this.gl.state = this, dU(e);
    for (const n in ET) {
      const i = ET[n];
      fU(e, n, i);
    }
    IT(e, "getParameter"), IT(e, "isEnabled");
  }
  /**
  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
   * @param values
   * @returns
   */
  _updateCache(e) {
    let t = !1, n;
    const i = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
    for (const s in e) {
      const l = e[s], o = this.cache[s];
      hU(l, o) || (t = !0, n = o, i && !(s in i) && (i[s] = o), this.cache[s] = l);
    }
    return {
      valueChanged: t,
      oldValue: n
    };
  }
}
function IT(r, e) {
  const t = r[e].bind(r);
  r[e] = function(i) {
    if (i === void 0 || lU.has(i))
      return t(i);
    const s = vf.get(r);
    return i in s.cache || (s.cache[i] = t(i)), s.enable ? (
      // Call the getter the params so that it can e.g. serve from a cache
      s.cache[i]
    ) : (
      // Optionally call the original function to do a "hard" query from the WebGL2RenderingContext
      t(i)
    );
  }, Object.defineProperty(r[e], "name", {
    value: `${e}-from-cache`,
    configurable: !1
  });
}
function fU(r, e, t) {
  if (!r[e])
    return;
  const n = r[e].bind(r);
  r[e] = function() {
    const s = vf.get(r);
    for (var l = arguments.length, o = new Array(l), d = 0; d < l; d++)
      o[d] = arguments[d];
    const {
      valueChanged: m,
      oldValue: b
    } = t(s._updateCache, ...o);
    return m && n(...o), b;
  }, Object.defineProperty(r[e], "name", {
    value: `${e}-to-cache`,
    configurable: !1
  });
}
function dU(r) {
  const e = r.useProgram.bind(r);
  r.useProgram = function(n) {
    const i = vf.get(r);
    i.program !== n && (e(n), i.program = n);
  };
}
function pU(r, e, t) {
  let n = "";
  const i = {
    preserveDrawingBuffer: !0,
    // failIfMajorPerformanceCaveat: true,
    ...t
  };
  let s = null;
  if (s || (s = r.getContext("webgl2", i)), i.failIfMajorPerformanceCaveat && (n || (n = "Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow.")), !s && !t.failIfMajorPerformanceCaveat && (i.failIfMajorPerformanceCaveat = !1, s = r.getContext("webgl2", i), s.luma || (s.luma = {}), s.luma.softwareRenderer = !0), s || (s = r.getContext("webgl", {}), s && (s = null, n || (n = "Your browser only supports WebGL1"))), !s)
    throw n || (n = "Your browser does not support WebGL"), new Error(`Failed to create WebGL context: ${n}`);
  const {
    onContextLost: l,
    onContextRestored: o
  } = e;
  return r.addEventListener("webglcontextlost", (d) => l(d), !1), r.addEventListener("webglcontextrestored", (d) => o(d), !1), s.luma || (s.luma = {}), s;
}
function Vd(r, e, t) {
  return t[e] === void 0 && (t[e] = r.getExtension(e) || null), t[e];
}
function gU(r, e) {
  const t = r.getParameter(7936), n = r.getParameter(7937);
  Vd(r, "WEBGL_debug_renderer_info", e);
  const i = e.WEBGL_debug_renderer_info, s = r.getParameter(i ? i.UNMASKED_VENDOR_WEBGL : 7936), l = r.getParameter(i ? i.UNMASKED_RENDERER_WEBGL : 7937), o = s || t, d = l || n, m = r.getParameter(7938), b = wC(o, d), T = mU(o, d), M = _U(o, d);
  return {
    type: "webgl",
    gpu: b,
    gpuType: M,
    gpuBackend: T,
    vendor: o,
    renderer: d,
    version: m,
    shadingLanguage: "glsl",
    shadingLanguageVersion: 300
  };
}
function wC(r, e) {
  return /NVIDIA/i.exec(r) || /NVIDIA/i.exec(e) ? "nvidia" : /INTEL/i.exec(r) || /INTEL/i.exec(e) ? "intel" : /Apple/i.exec(r) || /Apple/i.exec(e) ? "apple" : /AMD/i.exec(r) || /AMD/i.exec(e) || /ATI/i.exec(r) || /ATI/i.exec(e) ? "amd" : /SwiftShader/i.exec(r) || /SwiftShader/i.exec(e) ? "software" : "unknown";
}
function mU(r, e) {
  return /Metal/i.exec(r) || /Metal/i.exec(e) ? "metal" : /ANGLE/i.exec(r) || /ANGLE/i.exec(e) ? "opengl" : "unknown";
}
function _U(r, e) {
  if (/SwiftShader/i.exec(r) || /SwiftShader/i.exec(e))
    return "cpu";
  switch (wC(r, e)) {
    case "intel":
      return "integrated";
    case "software":
      return "cpu";
    case "unknown":
      return "unknown";
    default:
      return "discrete";
  }
}
function AC(r) {
  switch (r) {
    case "uint8":
      return 5121;
    case "sint8":
      return 5120;
    case "unorm8":
      return 5121;
    case "snorm8":
      return 5120;
    case "uint16":
      return 5123;
    case "sint16":
      return 5122;
    case "unorm16":
      return 5123;
    case "snorm16":
      return 5122;
    case "uint32":
      return 5125;
    case "sint32":
      return 5124;
    // WebGPU does not support normalized 32 bit integer attributes
    // case 'unorm32': return GL.UNSIGNED_INT;
    // case 'snorm32': return GL.INT;
    case "float16":
      return 5131;
    case "float32":
      return 5126;
  }
  throw new Error(String(r));
}
const Xp = "WEBGL_compressed_texture_s3tc", Zp = "WEBGL_compressed_texture_s3tc_srgb", yd = "EXT_texture_compression_rgtc", bd = "EXT_texture_compression_bptc", yU = "WEBGL_compressed_texture_etc", bU = "WEBGL_compressed_texture_astc", vU = "WEBGL_compressed_texture_etc1", xU = "WEBGL_compressed_texture_pvrtc", wU = "WEBGL_compressed_texture_atc", MT = "EXT_texture_norm16", PT = "EXT_render_snorm", AU = "EXT_color_buffer_float", M2 = {
  "float32-renderable-webgl": ["EXT_color_buffer_float"],
  "float16-renderable-webgl": ["EXT_color_buffer_half_float"],
  "rgb9e5ufloat-renderable-webgl": ["WEBGL_render_shared_exponent"],
  "snorm8-renderable-webgl": [PT],
  "norm16-renderable-webgl": [MT],
  "snorm16-renderable-webgl": [MT, PT],
  "float32-filterable": ["OES_texture_float_linear"],
  "float16-filterable-webgl": ["OES_texture_half_float_linear"],
  "texture-filterable-anisotropic-webgl": ["EXT_texture_filter_anisotropic"],
  "texture-blend-float-webgl": ["EXT_float_blend"],
  "texture-compression-bc": [Xp, Zp, yd, bd],
  // 'texture-compression-bc3-srgb-webgl': [X_S3TC_SRGB],
  // 'texture-compression-bc3-webgl': [X_S3TC],
  "texture-compression-bc5-webgl": [yd],
  "texture-compression-bc7-webgl": [bd],
  "texture-compression-etc2": [yU],
  "texture-compression-astc": [bU],
  "texture-compression-etc1-webgl": [vU],
  "texture-compression-pvrtc-webgl": [xU],
  "texture-compression-atc-webgl": [wU]
};
function TU(r) {
  return r in M2;
}
function SU(r, e, t) {
  return (M2[e] || []).every((i) => Vd(r, i, t));
}
const P2 = {
  // 8-bit formats
  r8unorm: {
    gl: 33321,
    rb: !0
  },
  r8snorm: {
    gl: 36756
  },
  r8uint: {
    gl: 33330,
    rb: !0
  },
  r8sint: {
    gl: 33329,
    rb: !0
  },
  // 16-bit formats
  rg8unorm: {
    gl: 33323,
    rb: !0
  },
  rg8snorm: {
    gl: 36757
  },
  rg8uint: {
    gl: 33336,
    rb: !0
  },
  rg8sint: {
    gl: 33335,
    rb: !0
  },
  r16uint: {
    gl: 33332,
    rb: !0
  },
  r16sint: {
    gl: 33331,
    rb: !0
  },
  r16float: {
    gl: 33325,
    rb: !0
  },
  "r16unorm-webgl": {
    gl: 33322,
    rb: !0
  },
  "r16snorm-webgl": {
    gl: 36760
  },
  // Packed 16-bit formats
  "rgba4unorm-webgl": {
    gl: 32854,
    rb: !0
  },
  "rgb565unorm-webgl": {
    gl: 36194,
    rb: !0
  },
  "rgb5a1unorm-webgl": {
    gl: 32855,
    rb: !0
  },
  // 24-bit formats
  "rgb8unorm-webgl": {
    gl: 32849
  },
  "rgb8snorm-webgl": {
    gl: 36758
  },
  // 32-bit formats  
  rgba8unorm: {
    gl: 32856
  },
  "rgba8unorm-srgb": {
    gl: 35907
  },
  rgba8snorm: {
    gl: 36759
  },
  rgba8uint: {
    gl: 36220
  },
  rgba8sint: {
    gl: 36238
  },
  // reverse colors, webgpu only
  bgra8unorm: {},
  "bgra8unorm-srgb": {},
  rg16uint: {
    gl: 33338
  },
  rg16sint: {
    gl: 33337
  },
  rg16float: {
    gl: 33327,
    rb: !0
  },
  "rg16unorm-webgl": {
    gl: 33324
  },
  "rg16snorm-webgl": {
    gl: 36761
  },
  r32uint: {
    gl: 33334,
    rb: !0
  },
  r32sint: {
    gl: 33333,
    rb: !0
  },
  r32float: {
    gl: 33326
  },
  // Packed 32-bit formats
  rgb9e5ufloat: {
    gl: 35901
  },
  // , filter: true},
  rg11b10ufloat: {
    gl: 35898,
    rb: !0
  },
  rgb10a2unorm: {
    gl: 32857,
    rb: !0
  },
  "rgb10a2uint-webgl": {
    gl: 36975,
    rb: !0
  },
  // 48-bit formats
  "rgb16unorm-webgl": {
    gl: 32852
  },
  // rgb not renderable
  "rgb16snorm-webgl": {
    gl: 36762
  },
  // rgb not renderable
  // 64-bit formats
  rg32uint: {
    gl: 33340,
    rb: !0
  },
  rg32sint: {
    gl: 33339,
    rb: !0
  },
  rg32float: {
    gl: 33328,
    rb: !0
  },
  rgba16uint: {
    gl: 36214,
    rb: !0
  },
  rgba16sint: {
    gl: 36232,
    rb: !0
  },
  rgba16float: {
    gl: 34842
  },
  "rgba16unorm-webgl": {
    gl: 32859,
    rb: !0
  },
  "rgba16snorm-webgl": {
    gl: 36763
  },
  // 96-bit formats (deprecated!)
  "rgb32float-webgl": {
    gl: 34837,
    x: AU,
    dataFormat: 6407,
    types: [5126]
  },
  // 128-bit formats
  rgba32uint: {
    gl: 36208,
    rb: !0
  },
  rgba32sint: {
    gl: 36226,
    rb: !0
  },
  rgba32float: {
    gl: 34836,
    rb: !0
  },
  // Depth and stencil formats
  stencil8: {
    gl: 36168,
    rb: !0
  },
  // 8 stencil bits
  depth16unorm: {
    gl: 33189,
    dataFormat: 6402,
    types: [5123],
    rb: !0
  },
  // 16 depth bits
  depth24plus: {
    gl: 33190,
    dataFormat: 6402,
    types: [5125]
  },
  depth32float: {
    gl: 36012,
    dataFormat: 6402,
    types: [5126],
    rb: !0
  },
  // The depth component of the "depth24plus" and "depth24plus-stencil8" formats may be implemented as either a 24-bit depth value or a "depth32float" value.
  "depth24plus-stencil8": {
    gl: 35056,
    rb: !0,
    depthTexture: !0,
    dataFormat: 34041,
    types: [34042]
  },
  // "depth32float-stencil8" feature - TODO below is render buffer only?
  "depth32float-stencil8": {
    gl: 36013,
    dataFormat: 34041,
    types: [36269],
    rb: !0
  },
  // BC compressed formats: check device.features.has("texture-compression-bc");
  "bc1-rgb-unorm-webgl": {
    gl: 33776,
    x: Xp
  },
  "bc1-rgb-unorm-srgb-webgl": {
    gl: 35916,
    x: Zp
  },
  "bc1-rgba-unorm": {
    gl: 33777,
    x: Xp
  },
  "bc1-rgba-unorm-srgb": {
    gl: 35916,
    x: Zp
  },
  "bc2-rgba-unorm": {
    gl: 33778,
    x: Xp
  },
  "bc2-rgba-unorm-srgb": {
    gl: 35918,
    x: Zp
  },
  "bc3-rgba-unorm": {
    gl: 33779,
    x: Xp
  },
  "bc3-rgba-unorm-srgb": {
    gl: 35919,
    x: Zp
  },
  "bc4-r-unorm": {
    gl: 36283,
    x: yd
  },
  "bc4-r-snorm": {
    gl: 36284,
    x: yd
  },
  "bc5-rg-unorm": {
    gl: 36285,
    x: yd
  },
  "bc5-rg-snorm": {
    gl: 36286,
    x: yd
  },
  "bc6h-rgb-ufloat": {
    gl: 36495,
    x: bd
  },
  "bc6h-rgb-float": {
    gl: 36494,
    x: bd
  },
  "bc7-rgba-unorm": {
    gl: 36492,
    x: bd
  },
  "bc7-rgba-unorm-srgb": {
    gl: 36493,
    x: bd
  },
  // WEBGL_compressed_texture_etc: device.features.has("texture-compression-etc2")
  // Note: Supposedly guaranteed availability compressed formats in WebGL2, but through CPU decompression
  "etc2-rgb8unorm": {
    gl: 37492
  },
  "etc2-rgb8unorm-srgb": {
    gl: 37494
  },
  "etc2-rgb8a1unorm": {
    gl: 37496
  },
  "etc2-rgb8a1unorm-srgb": {
    gl: 37497
  },
  "etc2-rgba8unorm": {
    gl: 37493
  },
  "etc2-rgba8unorm-srgb": {
    gl: 37495
  },
  "eac-r11unorm": {
    gl: 37488
  },
  "eac-r11snorm": {
    gl: 37489
  },
  "eac-rg11unorm": {
    gl: 37490
  },
  "eac-rg11snorm": {
    gl: 37491
  },
  // X_ASTC compressed formats: device.features.has("texture-compression-astc")
  "astc-4x4-unorm": {
    gl: 37808
  },
  "astc-4x4-unorm-srgb": {
    gl: 37840
  },
  "astc-5x4-unorm": {
    gl: 37809
  },
  "astc-5x4-unorm-srgb": {
    gl: 37841
  },
  "astc-5x5-unorm": {
    gl: 37810
  },
  "astc-5x5-unorm-srgb": {
    gl: 37842
  },
  "astc-6x5-unorm": {
    gl: 37811
  },
  "astc-6x5-unorm-srgb": {
    gl: 37843
  },
  "astc-6x6-unorm": {
    gl: 37812
  },
  "astc-6x6-unorm-srgb": {
    gl: 37844
  },
  "astc-8x5-unorm": {
    gl: 37813
  },
  "astc-8x5-unorm-srgb": {
    gl: 37845
  },
  "astc-8x6-unorm": {
    gl: 37814
  },
  "astc-8x6-unorm-srgb": {
    gl: 37846
  },
  "astc-8x8-unorm": {
    gl: 37815
  },
  "astc-8x8-unorm-srgb": {
    gl: 37847
  },
  "astc-10x5-unorm": {
    gl: 37819
  },
  "astc-10x5-unorm-srgb": {
    gl: 37851
  },
  "astc-10x6-unorm": {
    gl: 37817
  },
  "astc-10x6-unorm-srgb": {
    gl: 37849
  },
  "astc-10x8-unorm": {
    gl: 37818
  },
  "astc-10x8-unorm-srgb": {
    gl: 37850
  },
  "astc-10x10-unorm": {
    gl: 37819
  },
  "astc-10x10-unorm-srgb": {
    gl: 37851
  },
  "astc-12x10-unorm": {
    gl: 37820
  },
  "astc-12x10-unorm-srgb": {
    gl: 37852
  },
  "astc-12x12-unorm": {
    gl: 37821
  },
  "astc-12x12-unorm-srgb": {
    gl: 37853
  },
  // WEBGL_compressed_texture_pvrtc
  "pvrtc-rgb4unorm-webgl": {
    gl: 35840
  },
  "pvrtc-rgba4unorm-webgl": {
    gl: 35842
  },
  "pvrtc-rbg2unorm-webgl": {
    gl: 35841
  },
  "pvrtc-rgba2unorm-webgl": {
    gl: 35843
  },
  // WEBGL_compressed_texture_etc1
  "etc1-rbg-unorm-webgl": {
    gl: 36196
  },
  // WEBGL_compressed_texture_atc
  "atc-rgb-unorm-webgl": {
    gl: 35986
  },
  "atc-rgba-unorm-webgl": {
    gl: 35986
  },
  "atc-rgbai-unorm-webgl": {
    gl: 34798
  }
};
function EU(r, e, t) {
  let n = e.create;
  const i = P2[e.format];
  return (i == null ? void 0 : i.gl) === void 0 && (n = !1), i != null && i.x && (n = n && !!Vd(r, i.x, t)), {
    format: e.format,
    // @ts-ignore
    create: n && e.create,
    // @ts-ignore
    render: n && e.render,
    // @ts-ignore
    filter: n && e.filter,
    // @ts-ignore
    blend: n && e.blend,
    // @ts-ignore
    store: n && e.store
  };
}
function TC(r) {
  var i;
  const e = P2[r], t = MU(r), n = t2(r);
  return {
    internalFormat: t,
    format: (e == null ? void 0 : e.dataFormat) || IU(n.channels, n.integer, n.normalized, t),
    // depth formats don't have a type
    type: n.dataType ? AC(n.dataType) : ((i = e == null ? void 0 : e.types) == null ? void 0 : i[0]) || 5121,
    compressed: n.compressed || !1
  };
}
function CU(r) {
  switch (t2(r).attachment) {
    case "depth":
      return 36096;
    case "stencil":
      return 36128;
    case "depth-stencil":
      return 33306;
    default:
      throw new Error(`Not a depth stencil format: ${r}`);
  }
}
function IU(r, e, t, n) {
  if (n === 6408 || n === 6407)
    return n;
  switch (r) {
    case "r":
      return e && !t ? 36244 : 6403;
    case "rg":
      return e && !t ? 33320 : 33319;
    case "rgb":
      return e && !t ? 36248 : 6407;
    case "rgba":
      return e && !t ? 36249 : 6408;
    case "bgra":
      throw new Error("bgra pixels not supported by WebGL");
    default:
      return 6408;
  }
}
function MU(r) {
  const e = P2[r], t = e == null ? void 0 : e.gl;
  if (t === void 0)
    throw new Error(`Unsupported texture format ${r}`);
  return t;
}
const RT = {
  // optional WebGPU features
  "depth-clip-control": "EXT_depth_clamp",
  // TODO these seem subtly different
  // 'timestamp-query' // GPUQueryType "timestamp-query"
  // "indirect-first-instance"
  // Textures are handled by getTextureFeatures()
  // 'depth32float-stencil8' // GPUTextureFormat 'depth32float-stencil8'
  // optional WebGL features
  "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
  "compilation-status-async-webgl": "KHR_parallel_shader_compile",
  "polygon-mode-webgl": "WEBGL_polygon_mode",
  "provoking-vertex-webgl": "WEBGL_provoking_vertex",
  "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
  "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
  "shader-conservative-depth-webgl": "EXT_conservative_depth"
  // Textures are handled by getTextureFeatures()
};
class PU extends qO {
  constructor(t, n, i) {
    super([], i);
    H(this, "gl");
    H(this, "extensions");
    H(this, "testedFeatures", /* @__PURE__ */ new Set());
    this.gl = t, this.extensions = n, Vd(t, "EXT_color_buffer_float", n);
  }
  *[Symbol.iterator]() {
    const t = this.getFeatures();
    for (const n of t)
      this.has(n) && (yield n);
    return [];
  }
  has(t) {
    var n;
    return (n = this.disabledFeatures) != null && n[t] ? !1 : (this.testedFeatures.has(t) || (this.testedFeatures.add(t), TU(t) && SU(this.gl, t, this.extensions) && this.features.add(t), this.getWebGLFeature(t) && this.features.add(t)), this.features.has(t));
  }
  // FOR DEVICE
  initializeFeatures() {
    const t = this.getFeatures().filter((n) => n !== "polygon-mode-webgl");
    for (const n of t)
      this.has(n);
  }
  // IMPLEMENTATION
  getFeatures() {
    return [...Object.keys(RT), ...Object.keys(M2)];
  }
  /** Extract all WebGL features */
  getWebGLFeature(t) {
    const n = RT[t];
    return typeof n == "string" ? !!Vd(this.gl, n, this.extensions) : !!n;
  }
}
class RU extends VO {
  constructor(t) {
    super();
    // WebGL does not support compute shaders
    // PRIVATE
    H(this, "gl");
    H(this, "limits", {});
    this.gl = t;
  }
  get maxTextureDimension1D() {
    return 0;
  }
  // WebGL does not support 1D textures
  get maxTextureDimension2D() {
    return this.getParameter(3379);
  }
  get maxTextureDimension3D() {
    return this.getParameter(32883);
  }
  get maxTextureArrayLayers() {
    return this.getParameter(35071);
  }
  get maxBindGroups() {
    return 0;
  }
  get maxDynamicUniformBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxDynamicStorageBuffersPerPipelineLayout() {
    return 0;
  }
  // TBD
  get maxSampledTexturesPerShaderStage() {
    return this.getParameter(35660);
  }
  // ) TBD
  get maxSamplersPerShaderStage() {
    return this.getParameter(35661);
  }
  get maxStorageBuffersPerShaderStage() {
    return 0;
  }
  // TBD
  get maxStorageTexturesPerShaderStage() {
    return 0;
  }
  // TBD
  get maxUniformBuffersPerShaderStage() {
    return this.getParameter(35375);
  }
  get maxUniformBufferBindingSize() {
    return this.getParameter(35376);
  }
  get maxStorageBufferBindingSize() {
    return 0;
  }
  get minUniformBufferOffsetAlignment() {
    return this.getParameter(35380);
  }
  get minStorageBufferOffsetAlignment() {
    return 0;
  }
  get maxVertexBuffers() {
    return 16;
  }
  // WebGL 2 supports 16 buffers, see https://github.com/gpuweb/gpuweb/issues/4284
  get maxVertexAttributes() {
    return this.getParameter(34921);
  }
  get maxVertexBufferArrayStride() {
    return 2048;
  }
  // TBD, this is just the default value from WebGPU
  get maxInterStageShaderComponents() {
    return this.getParameter(35659);
  }
  get maxComputeWorkgroupStorageSize() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeInvocationsPerWorkgroup() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeX() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeY() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupSizeZ() {
    return 0;
  }
  // WebGL does not support compute shaders
  get maxComputeWorkgroupsPerDimension() {
    return 0;
  }
  getParameter(t) {
    return this.limits[t] === void 0 && (this.limits[t] = this.gl.getParameter(t)), this.limits[t] || 0;
  }
}
class ig extends S_ {
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "gl");
    H(this, "handle");
    H(this, "colorAttachments", []);
    H(this, "depthStencilAttachment", null);
    const i = n.handle === null;
    this.device = t, this.gl = t.gl, this.handle = this.props.handle || i ? this.props.handle : this.gl.createFramebuffer(), i || (t.setSpectorMetadata(this.handle, {
      id: this.props.id,
      props: this.props
    }), this.autoCreateAttachmentTextures(), this.updateAttachments());
  }
  /** destroys any auto created resources etc. */
  destroy() {
    super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle);
  }
  updateAttachments() {
    const t = this.gl.bindFramebuffer(36160, this.handle);
    for (let n = 0; n < this.colorAttachments.length; ++n) {
      const i = this.colorAttachments[n];
      if (i) {
        const s = 36064 + n;
        this._attachTextureView(s, i);
      }
    }
    if (this.depthStencilAttachment) {
      const n = CU(this.depthStencilAttachment.props.format);
      this._attachTextureView(n, this.depthStencilAttachment);
    }
    if (this.device.props.debug) {
      const n = this.gl.checkFramebufferStatus(36160);
      if (n !== 36053)
        throw new Error(`Framebuffer ${LU(n)}`);
    }
    this.gl.bindFramebuffer(36160, t);
  }
  // PRIVATE
  /** In WebGL we must use renderbuffers for depth/stencil attachments (unless we have extensions) */
  // protected override createDepthStencilTexture(format: TextureFormat): Texture {
  //   // return new WEBGLRenderbuffer(this.device, {
  //   return new WEBGLTexture(this.device, {
  //     id: `${this.id}-depth-stencil`,
  //     format,
  //     width: this.width,
  //     height: this.height,
  //     mipmaps: false
  //   });
  // }
  /**
   * @param attachment
   * @param texture
   * @param layer = 0 - index into WEBGLTextureArray and Texture3D or face for `TextureCubeMap`
   * @param level = 0 - mipmapLevel
   */
  _attachTextureView(t, n) {
    const {
      gl: i
    } = this.device, {
      texture: s
    } = n, l = n.props.baseMipLevel, o = n.props.baseArrayLayer;
    switch (i.bindTexture(s.glTarget, s.handle), s.glTarget) {
      case 35866:
      case 32879:
        i.framebufferTextureLayer(36160, t, s.handle, l, o);
        break;
      case 34067:
        const d = BU(o);
        i.framebufferTexture2D(36160, t, d, s.handle, l);
        break;
      case 3553:
        i.framebufferTexture2D(36160, t, 3553, s.handle, l);
        break;
      default:
        throw new Error("Illegal texture type");
    }
    i.bindTexture(s.glTarget, null);
  }
}
function BU(r) {
  return r < 34069 ? r + 34069 : r;
}
function LU(r) {
  switch (r) {
    case 36053:
      return "success";
    case 36054:
      return "Mismatched attachments";
    case 36055:
      return "No attachments";
    case 36057:
      return "Height/width mismatch";
    case 36061:
      return "Unsupported or split attachments";
    // WebGL2
    case 36182:
      return "Samples mismatch";
    // OVR_multiview2 extension
    // case GL.FRAMEBUFFER_INCOMPLETE_VIEW_TARGETS_OVR: return 'baseViewIndex mismatch';
    default:
      return `${r}`;
  }
}
class OU extends A1 {
  constructor(t, n) {
    super(n);
    H(this, "device");
    H(this, "format", "rgba8unorm");
    H(this, "depthStencilFormat", "depth24plus");
    H(this, "presentationSize");
    H(this, "_framebuffer", null);
    this.device = t, this.presentationSize = [-1, -1], this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this.update();
  }
  get [Symbol.toStringTag]() {
    return "WebGLCanvasContext";
  }
  getCurrentFramebuffer() {
    return this.update(), this._framebuffer = this._framebuffer || new ig(this.device, {
      handle: null
    }), this._framebuffer;
  }
  /** Resizes and updates render targets if necessary */
  update() {
    const t = this.getPixelSize();
    (t[0] !== this.presentationSize[0] || t[1] !== this.presentationSize[1]) && (this.presentationSize = t, this.resize());
  }
  /**
   * Resize the canvas' drawing buffer.
   *
   * Can match the canvas CSS size, and optionally also consider devicePixelRatio
   * Can be called every frame
   *
   * Regardless of size, the drawing buffer will always be scaled to the viewport, but
   * for best visual results, usually set to either:
   *  canvas CSS width x canvas CSS height
   *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
   * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
   */
  resize(t) {
    if (this.device.gl && this.canvas) {
      const n = this.getDevicePixelRatio(t == null ? void 0 : t.useDevicePixels);
      this.setDevicePixelRatio(n, t);
      return;
    }
  }
  commit() {
  }
}
async function SC(r, e) {
  const t = document.getElementsByTagName("head")[0];
  if (!t)
    throw new Error("loadScript");
  const n = document.createElement("script");
  return n.setAttribute("type", "text/javascript"), n.setAttribute("src", r), new Promise((i, s) => {
    n.onload = i, n.onerror = (l) => s(new Error(`Unable to load script '${r}': ${l}`)), t.appendChild(n);
  });
}
const NU = 1;
let bi = null, BT = !1;
const R2 = {
  debugSpectorJS: lr.get("debug-spectorjs"),
  // https://github.com/BabylonJS/Spector.js#basic-usage
  // https://forum.babylonjs.com/t/spectorcdn-is-temporarily-off/48241
  // spectorUrl: 'https://spectorcdn.babylonjs.com/spector.bundle.js';
  debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
  gl: void 0
};
async function DU(r) {
  if (!globalThis.SPECTOR)
    try {
      await SC(r.debugSpectorJSUrl || R2.debugSpectorJSUrl);
    } catch (e) {
      lr.warn(String(e));
    }
}
function kU(r) {
  var e;
  if (r = {
    ...R2,
    ...r
  }, !r.debugSpectorJS)
    return null;
  if (!bi && globalThis.SPECTOR && !((e = globalThis.luma) != null && e.spector)) {
    lr.probe(NU, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
    const {
      Spector: t
    } = globalThis.SPECTOR;
    bi = new t(), globalThis.luma && (globalThis.luma.spector = bi);
  }
  if (!bi)
    return null;
  if (BT || (BT = !0, bi.spyCanvases(), bi == null || bi.onCaptureStarted.add((t) => lr.info("Spector capture started:", t)()), bi == null || bi.onCapture.add((t) => {
    lr.info("Spector capture complete:", t)(), bi == null || bi.getResultUI(), bi == null || bi.resultView.display(), bi == null || bi.resultView.addCapture(t);
  })), r.gl) {
    const t = r.gl, n = t.device;
    bi == null || bi.startCapture(r.gl, 500), t.device = n, new Promise((i) => setTimeout(i, 2e3)).then((i) => {
      lr.info("Spector capture stopped after 2 seconds")(), bi == null || bi.stopCapture();
    });
  }
  return bi;
}
const FU = "https://unpkg.com/webgl-debug@2.0.1/index.js";
function EC(r) {
  return r.luma = r.luma || {}, r.luma;
}
async function UU() {
  Pf() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await SC(FU));
}
function zU(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return e.debugWebGL || e.traceWebGL ? VU(r, e) : jU(r);
}
function jU(r) {
  const e = EC(r);
  return e.realContext ? e.realContext : r;
}
function VU(r, e) {
  if (!globalThis.WebGLDebugUtils)
    return lr.warn("webgl-debug not loaded")(), r;
  const t = EC(r);
  if (t.debugContext)
    return t.debugContext;
  globalThis.WebGLDebugUtils.init({
    ..._d,
    ...r
  });
  const n = globalThis.WebGLDebugUtils.makeDebugContext(r, qU.bind(null, e), GU.bind(null, e));
  for (const l in _d)
    !(l in n) && typeof _d[l] == "number" && (n[l] = _d[l]);
  class i {
  }
  Object.setPrototypeOf(n, Object.getPrototypeOf(r)), Object.setPrototypeOf(i, n);
  const s = Object.create(i);
  return t.realContext = r, t.debugContext = s, s.debug = !0, s;
}
function LT(r, e) {
  e = Array.from(e).map((n) => n === void 0 ? "undefined" : n);
  let t = globalThis.WebGLDebugUtils.glFunctionArgsToString(r, e);
  return t = `${t.slice(0, 100)}${t.length > 100 ? "..." : ""}`, `gl.${r}(${t})`;
}
function qU(r, e, t, n) {
  n = Array.from(n).map((o) => o === void 0 ? "undefined" : o);
  const i = globalThis.WebGLDebugUtils.glEnumToString(e), s = globalThis.WebGLDebugUtils.glFunctionArgsToString(t, n), l = `${i} in gl.${t}(${s})`;
  lr.error(l)();
  debugger;
}
function GU(r, e, t) {
  let n = "";
  lr.level >= 1 && (n = LT(e, t), r.traceWebGL && lr.log(1, n)());
  for (const i of t)
    if (i === void 0) {
      n = n || LT(e, t);
      debugger;
    }
}
const ub = {};
function $U() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  ub[r] = ub[r] || 1;
  const e = ub[r]++;
  return `${r}-${e}`;
}
class sg extends Ss {
  constructor(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(t, n);
    H(this, "device");
    H(this, "gl");
    H(this, "handle");
    /** Target in OpenGL defines the type of buffer */
    H(this, "glTarget");
    /** Usage is a hint on how frequently the buffer will be updates */
    H(this, "glUsage");
    /** Index type is needed when issuing draw calls, so we pre-compute it */
    H(this, "glIndexType", 5123);
    /** Number of bytes allocated on the GPU for this buffer */
    H(this, "byteLength");
    /** Number of bytes used */
    H(this, "bytesUsed");
    this.device = t, this.gl = this.device.gl;
    const i = typeof n == "object" ? n.handle : void 0;
    this.handle = i || this.gl.createBuffer(), t.setSpectorMetadata(this.handle, {
      ...this.props,
      data: typeof this.props.data
    }), this.glTarget = HU(this.props.usage), this.glUsage = WU(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, n.data ? this._initWithData(n.data, n.byteOffset, n.byteLength) : this._initWithByteLength(n.byteLength || 0);
  }
  // PRIVATE METHODS
  /** Allocate a new buffer and initialize to contents of typed array */
  _initWithData(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : t.byteLength + n;
    const s = this.glTarget;
    this.gl.bindBuffer(s, this.handle), this.gl.bufferData(s, i, this.glUsage), this.gl.bufferSubData(s, n, t), this.gl.bindBuffer(s, null), this.bytesUsed = i, this.byteLength = i, this._setDebugData(t, n, i), this.trackAllocatedMemory(i);
  }
  // Allocate a GPU buffer of specified size.
  _initWithByteLength(t) {
    let n = t;
    t === 0 && (n = new Float32Array(0));
    const i = this.glTarget;
    return this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, n, this.glUsage), this.gl.bindBuffer(i, null), this.bytesUsed = t, this.byteLength = t, this._setDebugData(null, 0, t), this.trackAllocatedMemory(t), this;
  }
  destroy() {
    !this.destroyed && this.handle && (this.removeStats(), this.trackDeallocatedMemory(), this.gl.deleteBuffer(this.handle), this.destroyed = !0, this.handle = null);
  }
  write(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const i = 36663;
    this.gl.bindBuffer(i, this.handle), this.gl.bufferSubData(i, n, t), this.gl.bindBuffer(i, null), this._setDebugData(t, n, t.byteLength);
  }
  /** Asynchronously read data from the buffer */
  async readAsync() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 ? arguments[1] : void 0;
    return this.readSyncWebGL(t, n);
  }
  /** Synchronously read data from the buffer. WebGL only. */
  readSyncWebGL() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 ? arguments[1] : void 0;
    n = n ?? this.byteLength - t;
    const i = new Uint8Array(n), s = 0;
    return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, t, i, s, n), this.gl.bindBuffer(36662, null), this._setDebugData(i, t, n), i;
  }
}
function HU(r) {
  return r & Ss.INDEX ? 34963 : r & Ss.VERTEX ? 34962 : r & Ss.UNIFORM ? 35345 : 34962;
}
function WU(r) {
  return r & Ss.INDEX || r & Ss.VERTEX ? 35044 : r & Ss.UNIFORM ? 35048 : 35044;
}
function XU(r) {
  const e = r.split(/\r?\n/), t = [];
  for (const n of e) {
    if (n.length <= 1)
      continue;
    const i = n.split(":");
    if (i.length === 2) {
      const [T, M] = i;
      t.push({
        message: M.trim(),
        type: OT(T),
        lineNum: 0,
        linePos: 0
      });
      continue;
    }
    const [s, l, o, ...d] = i;
    let m = parseInt(o, 10);
    isNaN(m) && (m = 0);
    let b = parseInt(l, 10);
    isNaN(b) && (b = 0), t.push({
      message: d.join(":").trim(),
      type: OT(s),
      lineNum: m,
      linePos: b
      // TODO
    });
  }
  return t;
}
function OT(r) {
  const e = ["warning", "error", "info"], t = r.toLowerCase();
  return e.includes(t) ? t : "info";
}
class ZU extends A_ {
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "handle");
    switch (this.device = t, this.props.stage) {
      case "vertex":
        this.handle = this.props.handle || this.device.gl.createShader(35633);
        break;
      case "fragment":
        this.handle = this.props.handle || this.device.gl.createShader(35632);
        break;
      default:
        throw new Error(this.props.stage);
    }
    this._compile(this.source);
  }
  destroy() {
    this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = !0);
  }
  get asyncCompilationStatus() {
    return this._waitForCompilationComplete().then(() => this.compilationStatus);
  }
  async getCompilationInfo() {
    return await this._waitForCompilationComplete(), this.getCompilationInfoSync();
  }
  getCompilationInfoSync() {
    const t = this.device.gl.getShaderInfoLog(this.handle);
    return t ? XU(t) : [];
  }
  getTranslatedSource() {
    const n = this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders;
    return (n == null ? void 0 : n.getTranslatedShaderSource(this.handle)) || null;
  }
  // PRIVATE METHODS
  /** Compile a shader and get compilation status */
  async _compile(t) {
    t = t.startsWith("#version ") ? t : `#version 300 es
${t}`;
    const {
      gl: n
    } = this.device;
    if (n.shaderSource(this.handle, t), n.compileShader(this.handle), !this.device.props.debug) {
      this.compilationStatus = "pending";
      return;
    }
    if (!this.device.features.has("compilation-status-async-webgl")) {
      if (this._getCompilationStatus(), this.debugShader(), this.compilationStatus === "error")
        throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
      return;
    }
    lr.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), lr.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader();
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForCompilationComplete() {
    const t = async (s) => await new Promise((l) => setTimeout(l, s));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await t(10);
      return;
    }
    const {
      gl: i
    } = this.device;
    for (; ; ) {
      if (i.getShaderParameter(this.handle, 37297))
        return;
      await t(10);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getCompilationStatus() {
    this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
  }
}
function YU(r, e, t, n) {
  if (ez(e))
    return n(r);
  const i = r;
  i.pushState();
  try {
    return KU(r, e), ep(i.gl, t), n(r);
  } finally {
    i.popState();
  }
}
function KU(r, e) {
  const t = r, {
    gl: n
  } = t;
  if (e.cullMode)
    switch (e.cullMode) {
      case "none":
        n.disable(2884);
        break;
      case "front":
        n.enable(2884), n.cullFace(1028);
        break;
      case "back":
        n.enable(2884), n.cullFace(1029);
        break;
    }
  if (e.frontFace && n.frontFace(xf("frontFace", e.frontFace, {
    ccw: 2305,
    cw: 2304
  })), e.unclippedDepth && r.features.has("depth-clip-control") && n.enable(34383), e.depthBias !== void 0 && (n.enable(32823), n.polygonOffset(e.depthBias, e.depthBiasSlopeScale || 0)), e.provokingVertex && r.features.has("provoking-vertex-webgl")) {
    const s = t.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex, l = xf("provokingVertex", e.provokingVertex, {
      first: 36429,
      last: 36430
    });
    s == null || s.provokingVertexWEBGL(l);
  }
  if ((e.polygonMode || e.polygonOffsetLine) && r.features.has("polygon-mode-webgl")) {
    if (e.polygonMode) {
      const s = t.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode, l = xf("polygonMode", e.polygonMode, {
        fill: 6914,
        line: 6913
      });
      s == null || s.polygonModeWEBGL(1028, l), s == null || s.polygonModeWEBGL(1029, l);
    }
    e.polygonOffsetLine && n.enable(10754);
  }
  if (r.features.has("shader-clip-cull-distance-webgl") && (e.clipDistance0 && n.enable(12288), e.clipDistance1 && n.enable(12289), e.clipDistance2 && n.enable(12290), e.clipDistance3 && n.enable(12291), e.clipDistance4 && n.enable(12292), e.clipDistance5 && n.enable(12293), e.clipDistance6 && n.enable(12294), e.clipDistance7 && n.enable(12295)), e.depthWriteEnabled !== void 0 && n.depthMask(QU("depthWriteEnabled", e.depthWriteEnabled)), e.depthCompare && (e.depthCompare !== "always" ? n.enable(2929) : n.disable(2929), n.depthFunc(K1("depthCompare", e.depthCompare))), e.stencilWriteMask) {
    const i = e.stencilWriteMask;
    n.stencilMaskSeparate(1028, i), n.stencilMaskSeparate(1029, i);
  }
  if (e.stencilReadMask && lr.warn("stencilReadMask not supported under WebGL"), e.stencilCompare) {
    const i = e.stencilReadMask || 4294967295, s = K1("depthCompare", e.stencilCompare);
    e.stencilCompare !== "always" ? n.enable(2960) : n.disable(2960), n.stencilFuncSeparate(1028, s, 0, i), n.stencilFuncSeparate(1029, s, 0, i);
  }
  if (e.stencilPassOperation && e.stencilFailOperation && e.stencilDepthFailOperation) {
    const i = hb("stencilPassOperation", e.stencilPassOperation), s = hb("stencilFailOperation", e.stencilFailOperation), l = hb("stencilDepthFailOperation", e.stencilDepthFailOperation);
    n.stencilOpSeparate(1028, s, l, i), n.stencilOpSeparate(1029, s, l, i);
  }
  switch (e.blend) {
    case !0:
      n.enable(3042);
      break;
    case !1:
      n.disable(3042);
      break;
  }
  if (e.blendColorOperation || e.blendAlphaOperation) {
    const i = NT("blendColorOperation", e.blendColorOperation || "add"), s = NT("blendAlphaOperation", e.blendAlphaOperation || "add");
    n.blendEquationSeparate(i, s);
    const l = bm("blendColorSrcFactor", e.blendColorSrcFactor || "one"), o = bm("blendColorDstFactor", e.blendColorDstFactor || "zero"), d = bm("blendAlphaSrcFactor", e.blendAlphaSrcFactor || "one"), m = bm("blendAlphaDstFactor", e.blendAlphaDstFactor || "zero");
    n.blendFuncSeparate(l, o, d, m);
  }
}
function K1(r, e) {
  return xf(r, e, {
    never: 512,
    less: 513,
    equal: 514,
    "less-equal": 515,
    greater: 516,
    "not-equal": 517,
    "greater-equal": 518,
    always: 519
  });
}
function hb(r, e) {
  return xf(r, e, {
    keep: 7680,
    zero: 0,
    replace: 7681,
    invert: 5386,
    "increment-clamp": 7682,
    "decrement-clamp": 7683,
    "increment-wrap": 34055,
    "decrement-wrap": 34056
  });
}
function NT(r, e) {
  return xf(r, e, {
    add: 32774,
    subtract: 32778,
    "reverse-subtract": 32779,
    min: 32775,
    max: 32776
  });
}
function bm(r, e) {
  return xf(r, e, {
    one: 1,
    zero: 0,
    "src-color": 768,
    "one-minus-src-color": 769,
    "dst-color": 774,
    "one-minus-dst-color": 775,
    "src-alpha": 770,
    "one-minus-src-alpha": 771,
    "dst-alpha": 772,
    "one-minus-dst-alpha": 773,
    "src-alpha-saturated": 776,
    "constant-color": 32769,
    "one-minus-constant-color": 32770,
    "constant-alpha": 32771,
    "one-minus-constant-alpha": 32772
  });
}
function JU(r, e) {
  return `Illegal parameter ${e} for ${r}`;
}
function xf(r, e, t) {
  if (!(e in t))
    throw new Error(JU(r, e));
  return t[e];
}
function QU(r, e) {
  return e;
}
function ez(r) {
  let e = !0;
  for (const t in r) {
    e = !1;
    break;
  }
  return e;
}
function CC(r) {
  const e = {};
  return r.addressModeU && (e[10242] = fb(r.addressModeU)), r.addressModeV && (e[10243] = fb(r.addressModeV)), r.addressModeW && (e[32882] = fb(r.addressModeW)), r.magFilter && (e[10240] = J1(r.magFilter)), (r.minFilter || r.mipmapFilter) && (e[10241] = tz(r.minFilter || "linear", r.mipmapFilter)), r.lodMinClamp !== void 0 && (e[33082] = r.lodMinClamp), r.lodMaxClamp !== void 0 && (e[33083] = r.lodMaxClamp), r.type === "comparison-sampler" && (e[34892] = 34894), r.compare && (e[34893] = K1("compare", r.compare)), r.maxAnisotropy && (e[34046] = r.maxAnisotropy), e;
}
function fb(r) {
  switch (r) {
    case "clamp-to-edge":
      return 33071;
    case "repeat":
      return 10497;
    case "mirror-repeat":
      return 33648;
  }
}
function J1(r) {
  switch (r) {
    case "nearest":
      return 9728;
    case "linear":
      return 9729;
  }
}
function tz(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
  if (!e)
    return J1(r);
  switch (e) {
    case "none":
      return J1(r);
    case "nearest":
      return r === "nearest" ? 9984 : 9986;
    case "linear":
      return r === "nearest" ? 9985 : 9987;
  }
}
class Q1 extends T_ {
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "handle");
    H(this, "parameters");
    this.device = t, this.parameters = CC(n), this.handle = this.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters);
  }
  destroy() {
    this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0);
  }
  toString() {
    return `Sampler(${this.id},${JSON.stringify(this.props)})`;
  }
  /** Set sampler parameters on the sampler */
  _setSamplerParameters(t) {
    for (const [n, i] of Object.entries(t)) {
      const s = Number(n);
      switch (s) {
        case 33082:
        case 33083:
          this.device.gl.samplerParameterf(this.handle, s, i);
          break;
        default:
          this.device.gl.samplerParameteri(this.handle, s, i);
          break;
      }
    }
  }
}
class vd extends w_ {
  constructor(t, n) {
    super(t, {
      ...Wi.defaultProps,
      ...n
    });
    H(this, "device");
    H(this, "gl");
    H(this, "handle");
    // Does not have a WebGL representation
    H(this, "texture");
    this.device = t, this.gl = this.device.gl, this.handle = null, this.texture = n.texture;
  }
}
const rz = "Failed to deduce GL constant from typed array";
function nz(r) {
  switch (ArrayBuffer.isView(r) ? r.constructor : r) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(rz);
  }
}
function iz(r, e) {
  const {
    clamped: t = !0
  } = e || {};
  switch (r) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return t ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
function IC(r) {
  switch (r) {
    case 6406:
    case 33326:
    case 6403:
    case 36244:
      return 1;
    case 33339:
    case 33340:
    case 33328:
    case 33320:
    case 33319:
      return 2;
    case 6407:
    case 36248:
    case 34837:
      return 3;
    case 6408:
    case 36249:
    case 34836:
      return 4;
    // TODO: Add support for additional WebGL2 formats
    default:
      return 0;
  }
}
function sz(r) {
  switch (r) {
    case 5121:
      return 1;
    case 33635:
    case 32819:
    case 32820:
      return 2;
    case 5126:
      return 4;
    // TODO: Add support for additional WebGL2 types
    default:
      return 0;
  }
}
function V_(r, e, t) {
  if (oz(e))
    return t(r);
  const {
    nocatch: n = !0
  } = e, i = vf.get(r);
  i.push(), ep(r, e);
  let s;
  if (n)
    s = t(r), i.pop();
  else
    try {
      s = t(r);
    } finally {
      i.pop();
    }
  return s;
}
function oz(r) {
  for (const e in r)
    return !1;
  return !0;
}
function az(r, e, t) {
  const {
    dimension: n,
    width: i,
    height: s,
    depth: l = 0
  } = t, {
    glInternalFormat: o
  } = t, d = t.glTarget;
  switch (n) {
    case "2d-array":
    case "3d":
      r.texStorage3D(d, e, o, i, s, l);
      break;
    default:
      r.texStorage2D(d, e, o, i, s);
  }
}
function DT(r, e, t, n) {
  const {
    width: i,
    height: s
  } = n, {
    dimension: l,
    depth: o = 0,
    mipLevel: d = 0
  } = n, {
    x: m = 0,
    y: b = 0,
    z: T = 0
  } = n, {
    glFormat: M,
    glType: E
  } = n, D = MC(n.glTarget, l, o), U = n.flipY ? {
    37440: !0
  } : {};
  V_(r, U, () => {
    switch (l) {
      case "2d-array":
      case "3d":
        r.bindTexture(D, e), r.texSubImage3D(D, d, m, b, T, i, s, o, M, E, t), r.bindTexture(D, null);
        break;
      case "2d":
      case "cube":
        r.bindTexture(D, e), r.texSubImage2D(D, d, m, b, i, s, M, E, t), r.bindTexture(D, null);
        break;
      default:
        throw new Error(l);
    }
  });
}
function kT(r, e, t) {
  const {
    dimension: n,
    width: i,
    height: s,
    depth: l = 0,
    mipLevel: o = 0,
    byteOffset: d = 0
  } = t, {
    x: m = 0,
    y: b = 0,
    z: T = 0
  } = t, {
    glFormat: M,
    glType: E,
    compressed: D
  } = t, U = MC(t.glTarget, n, l);
  switch (n) {
    case "2d-array":
    case "3d":
      D ? r.compressedTexSubImage3D(U, o, m, b, T, i, s, l, M, e, d) : r.texSubImage3D(U, o, m, b, T, i, s, l, M, E, e, d);
      break;
    case "2d":
    case "cube":
      D ? r.compressedTexSubImage2D(U, o, m, b, i, s, M, e, d) : r.texSubImage2D(U, o, m, b, i, s, M, E, e, d);
      break;
    default:
      throw new Error(n);
  }
}
function lz(r) {
  switch (r) {
    case "1d":
      break;
    // not supported in any WebGL version
    case "2d":
      return 3553;
    // supported in WebGL1
    case "3d":
      return 32879;
    // supported in WebGL2
    case "cube":
      return 34067;
    // supported in WebGL1
    case "2d-array":
      return 35866;
  }
  throw new Error(r);
}
function MC(r, e, t) {
  return e === "cube" ? 34069 + t : r;
}
function cz(r, e) {
  var G;
  const {
    sourceX: t = 0,
    sourceY: n = 0,
    sourceAttachment: i = 0
    // TODO - support gl.readBuffer
  } = e || {};
  let {
    target: s = null,
    // following parameters are auto deduced if not provided
    sourceWidth: l,
    sourceHeight: o,
    sourceDepth: d,
    sourceFormat: m,
    sourceType: b
  } = e || {};
  const {
    framebuffer: T,
    deleteFramebuffer: M
  } = PC(r), {
    gl: E,
    handle: D
  } = T;
  l || (l = T.width), o || (o = T.height);
  const U = (G = T.colorAttachments[i]) == null ? void 0 : G.texture;
  if (!U)
    throw new Error(`Invalid framebuffer attachment ${i}`);
  d = (U == null ? void 0 : U.depth) || 1, m || (m = (U == null ? void 0 : U.glFormat) || 6408), b || (b = (U == null ? void 0 : U.glType) || 5121), s = fz(s, b, m, l, o), b = b || nz(s);
  const q = E.bindFramebuffer(36160, D);
  return E.readBuffer(36064 + i), E.readPixels(t, n, l, o, m, b, s), E.readBuffer(36064), E.bindFramebuffer(36160, q || null), M && T.destroy(), s;
}
function uz(r, e) {
  const {
    target: t,
    sourceX: n = 0,
    sourceY: i = 0,
    sourceFormat: s = 6408,
    targetByteOffset: l = 0
  } = e || {};
  let {
    sourceWidth: o,
    sourceHeight: d,
    sourceType: m
  } = e || {};
  const {
    framebuffer: b,
    deleteFramebuffer: T
  } = PC(r);
  o = o || b.width, d = d || b.height;
  const M = b;
  m = m || 5121;
  let E = t;
  if (!E) {
    const U = IC(s), q = sz(m), G = l + o * d * U * q;
    E = M.device.createBuffer({
      byteLength: G
    });
  }
  const D = r.device.createCommandEncoder();
  return D.copyTextureToBuffer({
    sourceTexture: r,
    width: o,
    height: d,
    origin: [n, i],
    destinationBuffer: E,
    byteOffset: l
  }), D.destroy(), T && b.destroy(), E;
}
function PC(r) {
  return r instanceof S_ ? {
    framebuffer: r,
    deleteFramebuffer: !1
  } : {
    framebuffer: hz(r),
    deleteFramebuffer: !0
  };
}
function hz(r, e) {
  const {
    device: t,
    width: n,
    height: i,
    id: s
  } = r;
  return t.createFramebuffer({
    ...e,
    id: `framebuffer-for-${s}`,
    width: n,
    height: i,
    colorAttachments: [r]
  });
}
function fz(r, e, t, n, i, s) {
  if (r)
    return r;
  e || (e = 5121);
  const l = iz(e, {
    clamped: !1
  }), o = IC(t);
  return new l(n * i * o);
}
class og extends Wi {
  constructor(t, n) {
    super(t, n);
    // readonly MAX_ATTRIBUTES: number;
    H(this, "device");
    H(this, "gl");
    H(this, "handle");
    H(this, "sampler", void 0);
    // TODO - currently unused in WebGL. Create dummy sampler?
    H(this, "view", void 0);
    // TODO - currently unused in WebGL. Create dummy view?
    H(this, "mipmaps");
    // Texture type
    /** Whether the internal format is compressed */
    H(this, "compressed");
    /**
     * The WebGL target corresponding to the texture type
     * @note `target` cannot be modified by bind:
     * textures are special because when you first bind them to a target,
     * When you first bind a texture as a GL_TEXTURE_2D, you are saying that this texture is a 2D texture.
     * And it will always be a 2D texture; this state cannot be changed ever.
     * A texture that was first bound as a GL_TEXTURE_2D, must always be bound as a GL_TEXTURE_2D;
     * attempting to bind it as GL_TEXTURE_3D will give rise to a run-time error
     */
    H(this, "glTarget");
    /** The WebGL format - essentially channel structure */
    H(this, "glFormat");
    /** The WebGL data format - the type of each channel */
    H(this, "glType");
    /** The WebGL constant corresponding to the WebGPU style constant in format */
    H(this, "glInternalFormat");
    // state
    /** Texture binding slot - TODO - move to texture view? */
    H(this, "textureUnit", 0);
    const i = {
      ...this.props
    };
    i.data = n.data, this.device = t, this.gl = this.device.gl, this.glTarget = lz(this.props.dimension);
    const s = TC(this.props.format);
    this.glInternalFormat = s.internalFormat, this.glFormat = s.format, this.glType = s.type, this.compressed = s.compressed, this.mipmaps = !!this.props.mipmaps, this._initialize(i), Object.seal(this);
  }
  /** Initialize texture with supplied props */
  // eslint-disable-next-line max-statements
  _initialize(t) {
    this.handle = this.props.handle || this.gl.createTexture(), this.device.setSpectorMetadata(this.handle, {
      ...this.props,
      data: t.data
    });
    let {
      width: n,
      height: i
    } = t;
    if (!n || !i) {
      const s = Wi.getTextureDataSize(t.data);
      n = (s == null ? void 0 : s.width) || 1, i = (s == null ? void 0 : s.height) || 1;
    }
    if (this.width = n, this.height = i, this.depth = t.depth, this.setSampler(t.sampler), this.view = new vd(this.device, {
      ...this.props,
      texture: this
    }), this.bind(), az(this.gl, this.mipLevels, this), t.data)
      switch (t.dimension) {
        case "1d":
          this.setTexture1DData(t.data);
          break;
        case "2d":
          this.setTexture2DData(t.data);
          break;
        case "3d":
          this.setTexture3DData(t.data);
          break;
        case "cube":
          this.setTextureCubeData(t.data);
          break;
        case "2d-array":
          this.setTextureArrayData(t.data);
          break;
        case "cube-array":
          this.setTextureCubeArrayData(t.data);
          break;
        // @ts-expect-error
        default:
          throw new Error(t.dimension);
      }
    this.mipmaps && this.generateMipmap();
  }
  destroy() {
    this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = !0);
  }
  createView(t) {
    return new vd(this.device, {
      ...t,
      texture: this
    });
  }
  setSampler() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n;
    t instanceof Q1 ? (this.sampler = t, n = t.props) : (this.sampler = new Q1(this.device, t), n = t);
    const i = CC(n);
    this._setSamplerParameters(i);
  }
  // Call to regenerate mipmaps after modifying texture(s)
  generateMipmap(t) {
    if (!(!(this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format)) && (lr.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)(), !(t != null && t.force))))
      try {
        this.gl.bindTexture(this.glTarget, this.handle), this.gl.generateMipmap(this.glTarget);
      } catch (i) {
        lr.warn(`Error generating mipmap for ${this}: ${i.message}`)();
      } finally {
        this.gl.bindTexture(this.glTarget, null);
      }
  }
  // Image Data Setters
  copyExternalImage(t) {
    const n = Wi.getExternalImageSize(t.image), i = {
      ...Wi.defaultCopyExternalImageOptions,
      ...n,
      ...t
    }, {
      image: s,
      depth: l,
      mipLevel: o,
      x: d,
      y: m,
      z: b,
      flipY: T
    } = i;
    let {
      width: M,
      height: E
    } = i;
    const {
      dimension: D,
      glTarget: U,
      glFormat: q,
      glInternalFormat: G,
      glType: Y
    } = this;
    if (M = Math.min(M, this.width - d), E = Math.min(E, this.height - m), t.sourceX || t.sourceY)
      throw new Error("WebGL does not support sourceX/sourceY)");
    return DT(this.device.gl, this.handle, s, {
      dimension: D,
      mipLevel: o,
      x: d,
      y: m,
      z: b,
      width: M,
      height: E,
      depth: l,
      glFormat: q,
      glType: Y,
      glTarget: U,
      flipY: T
    }), {
      width: i.width,
      height: i.height
    };
  }
  setTexture1DData(t) {
    throw new Error("setTexture1DData not supported in WebGL.");
  }
  /** Set a simple texture */
  setTexture2DData(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    this.bind();
    const i = Wi.normalizeTextureData(t, this);
    i.length > 1 && this.props.mipmaps !== !1 && lr.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
    for (let s = 0; s < i.length; s++) {
      const l = i[s];
      this._setMipLevel(n, s, l);
    }
    this.unbind();
  }
  /**
   * Sets a 3D texture
   * @param data
   */
  setTexture3DData(t) {
    if (this.props.dimension !== "3d")
      throw new Error(this.id);
    ArrayBuffer.isView(t) && (this.bind(), kT(this.device.gl, t, this), this.unbind());
  }
  /**
   * Set a Texture Cube Data
   * @todo - could support TextureCubeArray with depth
   * @param data
   * @param index
   */
  setTextureCubeData(t) {
    if (this.props.dimension !== "cube")
      throw new Error(this.id);
    for (const n of Wi.CubeFaces)
      this.setTextureCubeFaceData(t[n], n);
  }
  /**
   * Sets an entire texture array
   * @param data
   */
  setTextureArrayData(t) {
    throw this.props.dimension !== "2d-array" ? new Error(this.id) : new Error("setTextureArrayData not implemented.");
  }
  /**
   * Sets an entire texture cube array
   * @param data
   */
  setTextureCubeArrayData(t) {
    throw new Error("setTextureCubeArrayData not supported in WebGL2.");
  }
  setTextureCubeFaceData(t, n) {
    Array.isArray(t) && t.length > 1 && this.props.mipmaps !== !1 && lr.warn(`${this.id} has mipmap and multiple LODs.`)();
    const i = Wi.CubeFaces.indexOf(n);
    this.setTexture2DData(t, i);
  }
  // DEPRECATED METHODS
  /** Update external texture (video frame or canvas) @deprecated Use ExternalTexture */
  update() {
    throw new Error("Texture.update() not implemented. Use ExternalTexture");
  }
  // INTERNAL METHODS
  /** @todo update this method to accept LODs */
  setImageDataForFace(t) {
    const {
      face: n,
      width: i,
      height: s,
      pixels: l,
      data: o,
      format: d = 6408,
      type: m = 5121
      // generateMipmap = false // TODO
    } = t, {
      gl: b
    } = this, T = l || o;
    this.bind(), T instanceof Promise ? T.then((M) => this.setImageDataForFace(Object.assign({}, t, {
      face: n,
      data: M,
      pixels: M
    }))) : this.width || this.height ? b.texImage2D(n, 0, d, i, s, 0, d, m, T) : b.texImage2D(n, 0, d, d, m, T);
  }
  _getImageDataMap(t) {
    for (let n = 0; n < Wi.CubeFaces.length; ++n) {
      const i = Wi.CubeFaces[n];
      t[i] && (t[34069 + n] = t[i], delete t[i]);
    }
    return t;
  }
  // RESOURCE METHODS
  /**
   * Sets sampler parameters on texture
   */
  _setSamplerParameters(t) {
    lr.log(1, `${this.id} sampler parameters`, this.device.getGLKeys(t))(), this.gl.bindTexture(this.glTarget, this.handle);
    for (const [n, i] of Object.entries(t)) {
      const s = Number(n), l = i;
      switch (s) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.glTarget, s, l);
          break;
        case 10241:
          this.gl.texParameteri(this.glTarget, s, l);
          break;
        case 10242:
        case 10243:
          this.gl.texParameteri(this.glTarget, s, l);
          break;
        case 34046:
          this.device.features.has("texture-filterable-anisotropic-webgl") && this.gl.texParameteri(this.glTarget, s, l);
          break;
        default:
          this.gl.texParameteri(this.glTarget, s, l);
          break;
      }
    }
    this.gl.bindTexture(this.glTarget, null);
  }
  // INTERNAL SETTERS
  /**
   * Copy a region of data from a CPU memory buffer into this texture.
   * @todo -   GLUnpackParameters parameters
   */
  _setMipLevel(t, n, i) {
    let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : this.glTarget;
    if (Wi.isExternalImage(i)) {
      DT(this.device.gl, this.handle, i, {
        ...this,
        depth: t,
        mipLevel: n,
        glTarget: s,
        flipY: this.props.flipY
      });
      return;
    }
    if (Wi.isTextureLevelData(i)) {
      kT(this.device.gl, i.data, {
        ...this,
        depth: t,
        mipLevel: n,
        glTarget: s
      });
      return;
    }
    throw new Error("Texture: invalid image data");
  }
  // HELPERS
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind(t) {
    const {
      gl: n
    } = this;
    return t !== void 0 && (this.textureUnit = t, n.activeTexture(33984 + t)), n.bindTexture(this.glTarget, this.handle), t;
  }
  unbind(t) {
    const {
      gl: n
    } = this;
    return t !== void 0 && (this.textureUnit = t, n.activeTexture(33984 + t)), n.bindTexture(this.glTarget, null), t;
  }
}
const dz = [1, 2, 4, 8];
class pz extends T1 {
  constructor(t, n) {
    var l;
    super(t, n);
    H(this, "device");
    /** Parameters that should be applied before each draw call */
    H(this, "glParameters");
    this.device = t;
    let i;
    if (!((l = n == null ? void 0 : n.parameters) != null && l.viewport))
      if (n != null && n.framebuffer) {
        const {
          width: o,
          height: d
        } = n.framebuffer;
        i = [0, 0, o, d];
      } else {
        const [o, d] = t.getCanvasContext().getDrawingBufferSize();
        i = [0, 0, o, d];
      }
    this.device.pushState(), this.setParameters({
      viewport: i,
      ...this.props.parameters
    });
    const s = this.props.framebuffer;
    if (s != null && s.handle)
      if (this.props.framebuffer) {
        const o = this.props.framebuffer.colorAttachments.map((d, m) => 36064 + m);
        this.device.gl.drawBuffers(o);
      } else
        this.device.gl.drawBuffers([1029]);
    this.clear();
  }
  end() {
    this.device.popState();
  }
  pushDebugGroup(t) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(t) {
  }
  // beginOcclusionQuery(queryIndex: number): void;
  // endOcclusionQuery(): void;
  // executeBundles(bundles: Iterable<GPURenderBundle>): void;
  /**
   * Maps RenderPass parameters to GL parameters
   */
  setParameters() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const n = {
      ...this.glParameters
    };
    n.framebuffer = this.props.framebuffer || null, this.props.depthReadOnly && (n.depthMask = !this.props.depthReadOnly), n.stencilMask = this.props.stencilReadOnly ? 0 : 1, n[35977] = this.props.discard, t.viewport && (t.viewport.length >= 6 ? (n.viewport = t.viewport.slice(0, 4), n.depthRange = [t.viewport[4], t.viewport[5]]) : n.viewport = t.viewport), t.scissorRect && (n.scissorTest = !0, n.scissor = t.scissorRect), t.blendConstant && (n.blendColor = t.blendConstant), t.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), t[2967] = t.stencilReference), t.colorMask && (n.colorMask = dz.map((i) => !!(i & t.colorMask))), this.glParameters = n, ep(this.device.gl, n);
  }
  beginOcclusionQuery(t) {
    const n = this.props.occlusionQuerySet;
    n == null || n.beginOcclusionQuery();
  }
  endOcclusionQuery() {
    const t = this.props.occlusionQuerySet;
    t == null || t.endOcclusionQuery();
  }
  // PRIVATE
  /**
   * Optionally clears depth, color and stencil buffers based on parameters
   */
  clear() {
    const t = {
      ...this.glParameters
    };
    let n = 0;
    this.props.clearColors && this.props.clearColors.forEach((i, s) => {
      i && this.clearColorBuffer(s, i);
    }), this.props.clearColor !== !1 && this.props.clearColors === void 0 && (n |= 16384, t.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (n |= 256, t.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (n |= 1024, t.clearStencil = this.props.clearStencil), n !== 0 && V_(this.device.gl, t, () => {
      this.device.gl.clear(n);
    });
  }
  /**
   * WebGL2 - clear a specific color buffer
   */
  clearColorBuffer() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0, 0];
    V_(this.device.gl, {
      framebuffer: this.props.framebuffer
    }, () => {
      switch (n.constructor) {
        case Int8Array:
        case Int16Array:
        case Int32Array:
          this.device.gl.clearBufferiv(6144, t, n);
          break;
        case Uint8Array:
        case Uint8ClampedArray:
        case Uint16Array:
        case Uint32Array:
          this.device.gl.clearBufferuiv(6144, t, n);
          break;
        case Float32Array:
          this.device.gl.clearBufferfv(6144, t, n);
          break;
        default:
          throw new Error("clearColorBuffer: color must be typed array");
      }
    });
  }
}
function gz(r) {
  return mz.includes(r);
}
const mz = [35678, 35680, 35679, 35682, 36289, 36292, 36293, 36298, 36299, 36300, 36303, 36306, 36307, 36308, 36311], RC = {
  5126: [5126, 1, "float", "f32", "float32"],
  35664: [5126, 2, "vec2", "vec2<f32>", "float32x2"],
  35665: [5126, 3, "vec3", "vec3<f32>", "float32x3"],
  35666: [5126, 4, "vec4", "vec4<f32>", "float32x4"],
  5124: [5124, 1, "int", "i32", "sint32"],
  35667: [5124, 2, "ivec2", "vec2<i32>", "sint32x2"],
  35668: [5124, 3, "ivec3", "vec3<i32>", "sint32x3"],
  35669: [5124, 4, "ivec4", "vec4<i32>", "sint32x4"],
  5125: [5125, 1, "uint", "u32", "uint32"],
  36294: [5125, 2, "uvec2", "vec2<u32>", "uint32x2"],
  36295: [5125, 3, "uvec3", "vec3<u32>", "uint32x3"],
  36296: [5125, 4, "uvec4", "vec4<u32>", "uint32x4"],
  35670: [5126, 1, "bool", "f32", "float32"],
  35671: [5126, 2, "bvec2", "vec2<f32>", "float32x2"],
  35672: [5126, 3, "bvec3", "vec3<f32>", "float32x3"],
  35673: [5126, 4, "bvec4", "vec4<f32>", "float32x4"],
  // TODO - are sizes/components below correct?
  35674: [5126, 8, "mat2", "mat2x2<f32>"],
  // 4
  35685: [5126, 8, "mat2x3", "mat2x3<f32>"],
  // 6
  35686: [5126, 8, "mat2x4", "mat2x4<f32>"],
  // 8
  35687: [5126, 12, "mat3x2", "mat3x2<f32>"],
  // 6
  35675: [5126, 12, "mat3", "mat3x3<f32>"],
  // 9
  35688: [5126, 12, "mat3x4", "mat3x4<f32>"],
  // 12
  35689: [5126, 16, "mat4x2", "mat4x2<f32>"],
  // 8
  35690: [5126, 16, "mat4x3", "mat4x3<f32>"],
  // 12
  35676: [5126, 16, "mat4", "mat4x4<f32>"]
  // 16
};
function BC(r) {
  const e = RC[r];
  if (!e)
    throw new Error("uniform");
  const [t, n, , i] = e;
  return {
    format: i,
    components: n,
    glType: t
  };
}
function _z(r) {
  const e = RC[r];
  if (!e)
    throw new Error("attribute");
  const [, t, , n, i] = e;
  return {
    attributeType: n,
    vertexFormat: i,
    components: t
  };
}
function yz(r, e) {
  const t = {
    attributes: [],
    bindings: []
  };
  t.attributes = bz(r, e);
  const n = wz(r, e);
  for (const o of n) {
    const d = o.uniforms.map((m) => ({
      name: m.name,
      format: m.format,
      byteOffset: m.byteOffset,
      byteStride: m.byteStride,
      arrayLength: m.arrayLength
    }));
    t.bindings.push({
      type: "uniform",
      name: o.name,
      group: 0,
      location: o.location,
      visibility: (o.vertex ? 1 : 0) & (o.fragment ? 2 : 0),
      minBindingSize: o.byteLength,
      uniforms: d
    });
  }
  const i = xz(r, e);
  let s = 0;
  for (const o of i)
    if (gz(o.type)) {
      const {
        viewDimension: d,
        sampleType: m
      } = Tz(o.type);
      t.bindings.push({
        type: "texture",
        name: o.name,
        group: 0,
        location: s,
        viewDimension: d,
        sampleType: m
      }), o.textureUnit = s, s += 1;
    }
  i.length && (t.uniforms = i);
  const l = vz(r, e);
  return l != null && l.length && (t.varyings = l), t;
}
function bz(r, e) {
  const t = [], n = r.getProgramParameter(e, 35721);
  for (let i = 0; i < n; i++) {
    const s = r.getActiveAttrib(e, i);
    if (!s)
      throw new Error("activeInfo");
    const {
      name: l,
      type: o
      /* , size*/
    } = s, d = r.getAttribLocation(e, l);
    if (d >= 0) {
      const {
        attributeType: m
      } = _z(o), b = /instance/i.test(l) ? "instance" : "vertex";
      t.push({
        name: l,
        location: d,
        stepMode: b,
        type: m
        // size - for arrays, size is the number of elements in the array
      });
    }
  }
  return t.sort((i, s) => i.location - s.location), t;
}
function vz(r, e) {
  const t = [], n = r.getProgramParameter(e, 35971);
  for (let i = 0; i < n; i++) {
    const s = r.getTransformFeedbackVarying(e, i);
    if (!s)
      throw new Error("activeInfo");
    const {
      name: l,
      type: o,
      size: d
    } = s, {
      glType: m,
      components: b
    } = BC(o), T = {
      location: i,
      name: l,
      type: m,
      size: d * b
    };
    t.push(T);
  }
  return t.sort((i, s) => i.location - s.location), t;
}
function xz(r, e) {
  const t = [], n = r.getProgramParameter(e, 35718);
  for (let i = 0; i < n; i++) {
    const s = r.getActiveUniform(e, i);
    if (!s)
      throw new Error("activeInfo");
    const {
      name: l,
      size: o,
      type: d
    } = s, {
      name: m,
      isArray: b
    } = Sz(l);
    let T = r.getUniformLocation(e, m);
    const M = {
      // WebGL locations are uniquely typed but just numbers
      location: T,
      name: m,
      size: o,
      type: d,
      isArray: b
    };
    if (t.push(M), M.size > 1)
      for (let E = 0; E < M.size; E++) {
        const D = `${m}[${E}]`;
        T = r.getUniformLocation(e, D);
        const U = {
          ...M,
          name: D,
          location: T
        };
        t.push(U);
      }
  }
  return t;
}
function wz(r, e) {
  const t = (s, l) => r.getActiveUniformBlockParameter(e, s, l), n = [], i = r.getProgramParameter(e, 35382);
  for (let s = 0; s < i; s++) {
    const l = {
      name: r.getActiveUniformBlockName(e, s) || "",
      location: t(s, 35391),
      byteLength: t(s, 35392),
      vertex: t(s, 35396),
      fragment: t(s, 35398),
      uniformCount: t(s, 35394),
      uniforms: []
    }, o = t(s, 35395) || [], d = r.getActiveUniforms(e, o, 35383), m = r.getActiveUniforms(e, o, 35384), b = r.getActiveUniforms(e, o, 35387), T = r.getActiveUniforms(e, o, 35388);
    for (let M = 0; M < l.uniformCount; ++M) {
      const E = r.getActiveUniform(e, o[M]);
      if (!E)
        throw new Error("activeInfo");
      l.uniforms.push({
        name: E.name,
        format: BC(d[M]).format,
        type: d[M],
        arrayLength: m[M],
        byteOffset: b[M],
        byteStride: T[M]
        // matrixStride: uniformStride[i],
        // rowMajor: uniformRowMajor[i]
      });
    }
    n.push(l);
  }
  return n.sort((s, l) => s.location - l.location), n;
}
const Az = {
  35678: ["2d", "float"],
  35680: ["cube", "float"],
  35679: ["3d", "float"],
  35682: ["3d", "depth"],
  36289: ["2d-array", "float"],
  36292: ["2d-array", "depth"],
  36293: ["cube", "float"],
  36298: ["2d", "sint"],
  36299: ["3d", "sint"],
  36300: ["cube", "sint"],
  36303: ["2d-array", "uint"],
  36306: ["2d", "uint"],
  36307: ["3d", "uint"],
  36308: ["cube", "uint"],
  36311: ["2d-array", "uint"]
};
function Tz(r) {
  const e = Az[r];
  if (!e)
    throw new Error("sampler");
  const [t, n] = e;
  return {
    viewDimension: t,
    sampleType: n
  };
}
function Sz(r) {
  if (r[r.length - 1] !== "]")
    return {
      name: r,
      length: 1,
      isArray: !1
    };
  const t = /([^[]*)(\[[0-9]+\])?/.exec(r);
  if (!t || t.length < 2)
    throw new Error(`Failed to parse GLSL uniform name ${r}`);
  return {
    name: t[1],
    length: t[2] ? 1 : 0,
    isArray: !!t[2]
  };
}
function Ez(r, e, t, n) {
  const i = r;
  let s = n;
  s === !0 && (s = 1), s === !1 && (s = 0);
  const l = typeof s == "number" ? [s] : s;
  switch (t) {
    case 35678:
    case 35680:
    case 35679:
    case 35682:
    case 36289:
    case 36292:
    case 36293:
    case 36298:
    case 36299:
    case 36300:
    case 36303:
    case 36306:
    case 36307:
    case 36308:
    case 36311:
      if (typeof n != "number")
        throw new Error("samplers must be set to integers");
      return r.uniform1i(e, n);
    case 5126:
      return r.uniform1fv(e, l);
    case 35664:
      return r.uniform2fv(e, l);
    case 35665:
      return r.uniform3fv(e, l);
    case 35666:
      return r.uniform4fv(e, l);
    case 5124:
      return r.uniform1iv(e, l);
    case 35667:
      return r.uniform2iv(e, l);
    case 35668:
      return r.uniform3iv(e, l);
    case 35669:
      return r.uniform4iv(e, l);
    case 35670:
      return r.uniform1iv(e, l);
    case 35671:
      return r.uniform2iv(e, l);
    case 35672:
      return r.uniform3iv(e, l);
    case 35673:
      return r.uniform4iv(e, l);
    // WEBGL2 - unsigned integers
    case 5125:
      return i.uniform1uiv(e, l, 1);
    case 36294:
      return i.uniform2uiv(e, l, 2);
    case 36295:
      return i.uniform3uiv(e, l, 3);
    case 36296:
      return i.uniform4uiv(e, l, 4);
    // WebGL2 - quadratic matrices
    // false: don't transpose the matrix
    case 35674:
      return r.uniformMatrix2fv(e, !1, l);
    case 35675:
      return r.uniformMatrix3fv(e, !1, l);
    case 35676:
      return r.uniformMatrix4fv(e, !1, l);
    // WebGL2 - rectangular matrices
    case 35685:
      return i.uniformMatrix2x3fv(e, !1, l);
    case 35686:
      return i.uniformMatrix2x4fv(e, !1, l);
    case 35687:
      return i.uniformMatrix3x2fv(e, !1, l);
    case 35688:
      return i.uniformMatrix3x4fv(e, !1, l);
    case 35689:
      return i.uniformMatrix4x2fv(e, !1, l);
    case 35690:
      return i.uniformMatrix4x3fv(e, !1, l);
  }
  throw new Error("Illegal uniform");
}
function Cz(r) {
  return hC(r) !== null || typeof r == "number" || typeof r == "boolean";
}
function Iz(r) {
  const e = {
    bindings: {},
    uniforms: {}
  };
  return Object.keys(r).forEach((t) => {
    const n = r[t];
    Cz(n) ? e.uniforms[t] = n : e.bindings[t] = n;
  }), e;
}
function Mz(r) {
  switch (r) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 3;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 5;
    default:
      throw new Error(r);
  }
}
function Pz(r) {
  switch (r) {
    case "point-list":
      return 0;
    case "line-list":
      return 1;
    case "line-strip":
      return 1;
    case "triangle-list":
      return 4;
    case "triangle-strip":
      return 4;
    default:
      throw new Error(r);
  }
}
const FT = 4;
class Rz extends kd {
  // TODO are these used?
  constructor(t, n) {
    super(t, n);
    /** The WebGL device that created this render pipeline */
    H(this, "device");
    /** Handle to underlying WebGL program */
    H(this, "handle");
    /** vertex shader */
    H(this, "vs");
    /** fragment shader */
    H(this, "fs");
    /** The layout extracted from shader by WebGL introspection APIs */
    H(this, "introspectedLayout");
    /** Uniforms set on this model */
    H(this, "uniforms", {});
    /** Bindings set on this model */
    H(this, "bindings", {});
    /** WebGL varyings */
    H(this, "varyings", null);
    H(this, "_uniformCount", 0);
    H(this, "_uniformSetters", {});
    this.device = t, this.handle = this.props.handle || this.device.gl.createProgram(), this.device.setSpectorMetadata(this.handle, {
      id: this.props.id
    }), this.vs = n.vs, this.fs = n.fs;
    const {
      varyings: i,
      bufferMode: s = 35981
    } = n;
    i && i.length > 0 && (this.varyings = i, this.device.gl.transformFeedbackVaryings(this.handle, i, s)), this._linkShaders(), lr.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = yz(this.device.gl, this.handle), lr.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = Bz(this.introspectedLayout, n.shaderLayout);
  }
  destroy() {
    this.handle && (this.device.gl.deleteProgram(this.handle), this.destroyed = !0);
  }
  /**
   * Bindings include: textures, samplers and uniform buffers
   * @todo needed for portable model
   */
  setBindings(t, n) {
    for (const [i, s] of Object.entries(t)) {
      const l = this.shaderLayout.bindings.find((o) => o.name === i) || this.shaderLayout.bindings.find((o) => o.name === `${i}Uniforms`);
      if (!l) {
        const o = this.shaderLayout.bindings.map((d) => `"${d.name}"`).join(", ");
        n != null && n.disableWarnings || lr.warn(`No binding "${i}" in render pipeline "${this.id}", expected one of ${o}`, s)();
        continue;
      }
      switch (s || lr.warn(`Unsetting binding "${i}" in render pipeline "${this.id}"`)(), l.type) {
        case "uniform":
          if (!(s instanceof sg) && !(s.buffer instanceof sg))
            throw new Error("buffer value");
          break;
        case "texture":
          if (!(s instanceof vd || s instanceof og || s instanceof ig))
            throw new Error("texture value");
          break;
        case "sampler":
          lr.warn(`Ignoring sampler ${i}`)();
          break;
        default:
          throw new Error(l.type);
      }
      this.bindings[i] = s;
    }
  }
  /** @todo needed for portable model
   * @note The WebGL API is offers many ways to draw things
   * This function unifies those ways into a single call using common parameters with sane defaults
   */
  draw(t) {
    var q;
    const {
      renderPass: n,
      parameters: i = this.props.parameters,
      topology: s = this.props.topology,
      vertexArray: l,
      vertexCount: o,
      // indexCount,
      instanceCount: d,
      isInstanced: m = !1,
      firstVertex: b = 0,
      // firstIndex,
      // firstInstance,
      // baseVertex,
      transformFeedback: T
    } = t, M = Mz(s), E = !!l.indexBuffer, D = (q = l.indexBuffer) == null ? void 0 : q.glIndexType;
    if (this.linkStatus !== "success")
      return lr.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
    if (!this._areTexturesRenderable())
      return lr.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
    this.device.gl.useProgram(this.handle), l.bindBeforeRender(n), T && T.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
    const U = n;
    return YU(this.device, i, U.glParameters, () => {
      E && m ? this.device.gl.drawElementsInstanced(
        M,
        o || 0,
        // indexCount?
        D,
        b,
        d || 0
      ) : E ? this.device.gl.drawElements(M, o || 0, D, b) : m ? this.device.gl.drawArraysInstanced(M, b, o || 0, d || 0) : this.device.gl.drawArrays(M, b, o || 0), T && T.end();
    }), l.unbindAfterRender(n), !0;
  }
  // DEPRECATED METHODS
  setUniformsWebGL(t) {
    const {
      bindings: n
    } = Iz(t);
    Object.keys(n).forEach((i) => {
      lr.warn(`Unsupported value "${JSON.stringify(n[i])}" used in setUniforms() for key ${i}. Use setBindings() instead?`)();
    }), Object.assign(this.uniforms, t);
  }
  // PRIVATE METHODS
  // setAttributes(attributes: Record<string, Buffer>): void {}
  // setBindings(bindings: Record<string, Binding>): void {}
  async _linkShaders() {
    const {
      gl: t
    } = this.device;
    if (t.attachShader(this.handle, this.vs.handle), t.attachShader(this.handle, this.fs.handle), lr.time(FT, `linkProgram for ${this.id}`)(), t.linkProgram(this.handle), lr.timeEnd(FT, `linkProgram for ${this.id}`)(), lr.level, !this.device.features.has("compilation-status-async-webgl")) {
      const i = this._getLinkStatus();
      this._reportLinkStatus(i);
      return;
    }
    lr.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), lr.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
    const n = this._getLinkStatus();
    this._reportLinkStatus(n);
  }
  /** Report link status. First, check for shader compilation failures if linking fails */
  async _reportLinkStatus(t) {
    var n;
    switch (t) {
      case "success":
        return;
      default:
        switch (this.vs.compilationStatus) {
          case "error":
            throw this.vs.debugShader(), new Error(`Error during compilation of shader ${this.vs.id}`);
          case "pending":
            this.vs.asyncCompilationStatus.then(() => this.vs.debugShader());
            break;
        }
        switch ((n = this.fs) == null ? void 0 : n.compilationStatus) {
          case "error":
            throw this.fs.debugShader(), new Error(`Error during compilation of shader ${this.fs.id}`);
          case "pending":
            this.fs.asyncCompilationStatus.then(() => this.fs.debugShader());
            break;
        }
        const i = this.device.gl.getProgramInfoLog(this.handle);
        throw new Error(`Error during ${t}: ${i}`);
    }
  }
  /**
   * Get the shader compilation status
   * TODO - Load log even when no error reported, to catch warnings?
   * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
   */
  _getLinkStatus() {
    const {
      gl: t
    } = this.device;
    return t.getProgramParameter(this.handle, 35714) ? (t.validateProgram(this.handle), t.getProgramParameter(this.handle, 35715) ? (this.linkStatus = "success", "success") : (this.linkStatus = "error", "validation")) : (this.linkStatus = "error", "linking");
  }
  /** Use KHR_parallel_shader_compile extension if available */
  async _waitForLinkComplete() {
    const t = async (s) => await new Promise((l) => setTimeout(l, s));
    if (!this.device.features.has("compilation-status-async-webgl")) {
      await t(10);
      return;
    }
    const {
      gl: i
    } = this.device;
    for (; ; ) {
      if (i.getProgramParameter(this.handle, 37297))
        return;
      await t(10);
    }
  }
  /**
   * Checks if all texture-values uniforms are renderable (i.e. loaded)
   * Update a texture if needed (e.g. from video)
   * Note: This is currently done before every draw call
   */
  _areTexturesRenderable() {
    let t = !0;
    for (const n of this.shaderLayout.bindings)
      !this.bindings[n.name] && !this.bindings[n.name.replace(/Uniforms$/, "")] && (lr.warn(`Binding ${n.name} not found in ${this.id}`)(), t = !1);
    return t;
  }
  /** Apply any bindings (before each draw call) */
  _applyBindings() {
    if (this.linkStatus !== "success")
      return;
    const {
      gl: t
    } = this.device;
    t.useProgram(this.handle);
    let n = 0, i = 0;
    for (const s of this.shaderLayout.bindings) {
      const l = this.bindings[s.name] || this.bindings[s.name.replace(/Uniforms$/, "")];
      if (!l)
        throw new Error(`No value for binding ${s.name} in ${this.id}`);
      switch (s.type) {
        case "uniform":
          const {
            name: o
          } = s, d = t.getUniformBlockIndex(this.handle, o);
          if (d === 4294967295)
            throw new Error(`Invalid uniform block name ${o}`);
          t.uniformBlockBinding(this.handle, i, d), l instanceof sg ? t.bindBufferBase(35345, i, l.handle) : t.bindBufferRange(
            35345,
            i,
            // @ts-expect-error
            l.buffer.handle,
            // @ts-expect-error
            l.offset || 0,
            // @ts-expect-error
            l.size || l.buffer.byteLength - l.offset
          ), i += 1;
          break;
        case "texture":
          if (!(l instanceof vd || l instanceof og || l instanceof ig))
            throw new Error("texture");
          let m;
          if (l instanceof vd)
            m = l.texture;
          else if (l instanceof og)
            m = l;
          else if (l instanceof ig && l.colorAttachments[0] instanceof vd)
            lr.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), m = l.colorAttachments[0].texture;
          else
            throw new Error("No texture");
          t.activeTexture(33984 + n), t.bindTexture(m.glTarget, m.handle), n += 1;
          break;
        case "sampler":
          break;
        case "storage":
        case "read-only-storage":
          throw new Error(`binding type '${s.type}' not supported in WebGL`);
      }
    }
  }
  /**
   * Due to program sharing, uniforms need to be reset before every draw call
   * (though caching will avoid redundant WebGL calls)
   */
  _applyUniforms() {
    for (const t of this.shaderLayout.uniforms || []) {
      const {
        name: n,
        location: i,
        type: s,
        textureUnit: l
      } = t, o = this.uniforms[n] ?? l;
      o !== void 0 && Ez(this.device.gl, i, s, o);
    }
  }
}
function Bz(r, e) {
  const t = {
    ...r,
    attributes: r.attributes.map((n) => ({
      ...n
    }))
  };
  for (const n of (e == null ? void 0 : e.attributes) || []) {
    const i = t.attributes.find((s) => s.name === n.name);
    i ? (i.type = n.type || i.type, i.stepMode = n.stepMode || i.stepMode) : lr.warn(`shader layout attribute ${n.name} not present in shader`);
  }
  return t;
}
class Lz extends E1 {
  constructor(t) {
    super(t, {});
    H(this, "device");
    H(this, "commands", []);
    this.device = t;
  }
  submitCommands() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.commands;
    for (const n of t)
      switch (n.name) {
        case "copy-buffer-to-buffer":
          Oz(this.device, n.options);
          break;
        case "copy-buffer-to-texture":
          Nz(this.device, n.options);
          break;
        case "copy-texture-to-buffer":
          Dz(this.device, n.options);
          break;
        case "copy-texture-to-texture":
          kz(this.device, n.options);
          break;
        // case 'clear-texture':
        //   _clearTexture(this.device, command.options);
        //   break;
        default:
          throw new Error(n.name);
      }
  }
}
function Oz(r, e) {
  const t = e.sourceBuffer, n = e.destinationBuffer;
  r.gl.bindBuffer(36662, t.handle), r.gl.bindBuffer(36663, n.handle), r.gl.copyBufferSubData(36662, 36663, e.sourceOffset ?? 0, e.destinationOffset ?? 0, e.size), r.gl.bindBuffer(36662, null), r.gl.bindBuffer(36663, null);
}
function Nz(r, e) {
  throw new Error("Not implemented");
}
function Dz(r, e) {
  const {
    /** Texture to copy to/from. */
    sourceTexture: t,
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    mipLevel: n = 0,
    /** Defines which aspects of the texture to copy to/from. */
    aspect: i = "all",
    /** Width to copy */
    width: s = e.sourceTexture.width,
    /** Height to copy */
    height: l = e.sourceTexture.height,
    depthOrArrayLayers: o = 0,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    origin: d = [0, 0],
    /** Destination buffer */
    destinationBuffer: m,
    /** Offset, in bytes, from the beginning of the buffer to the start of the image data (default 0) */
    byteOffset: b = 0,
    /**
     * The stride, in bytes, between the beginning of each block row and the subsequent block row.
     * Required if there are multiple block rows (i.e. the copy height or depth is more than one block).
     */
    bytesPerRow: T,
    /**
     * Number of block rows per single image of the texture.
     * rowsPerImage &times; bytesPerRow is the stride, in bytes, between the beginning of each image of data and the subsequent image.
     * Required if there are multiple images (i.e. the copy depth is more than one).
     */
    rowsPerImage: M
  } = e;
  if (i !== "all")
    throw new Error("aspect not supported in WebGL");
  if (n !== 0 || o !== 0 || T || M)
    throw new Error("not implemented");
  const {
    framebuffer: E,
    destroyFramebuffer: D
  } = LC(t);
  let U;
  try {
    const q = m, G = s || E.width, Y = l || E.height, he = TC(E.colorAttachments[0].texture.props.format), X = he.format, J = he.type;
    r.gl.bindBuffer(35051, q.handle), U = r.gl.bindFramebuffer(36160, E.handle), r.gl.readPixels(d[0], d[1], G, Y, X, J, b);
  } finally {
    r.gl.bindBuffer(35051, null), U !== void 0 && r.gl.bindFramebuffer(36160, U), D && E.destroy();
  }
}
function kz(r, e) {
  const {
    /** Texture to copy to/from. */
    sourceTexture: t,
    /**  Mip-map level of the texture to copy to (Default 0) */
    destinationMipLevel: n = 0,
    /** Defines which aspects of the texture to copy to/from. */
    // aspect = 'all',
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy from. */
    origin: i = [0, 0],
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to. */
    destinationOrigin: s = [0, 0],
    /** Texture to copy to/from. */
    destinationTexture: l
    /**  Mip-map level of the texture to copy to/from. (Default 0) */
    // destinationMipLevel = options.mipLevel,
    /** Defines the origin of the copy - the minimum corner of the texture sub-region to copy to/from. */
    // destinationOrigin = [0, 0],
    /** Defines which aspects of the texture to copy to/from. */
    // destinationAspect = options.aspect,
  } = e;
  let {
    width: o = e.destinationTexture.width,
    height: d = e.destinationTexture.height
    // depthOrArrayLayers = 0
  } = e;
  const {
    framebuffer: m,
    destroyFramebuffer: b
  } = LC(t), [T, M] = i, [E, D, U] = s, q = r.gl.bindFramebuffer(36160, m.handle);
  let G = null, Y;
  if (l instanceof og)
    G = l, o = Number.isFinite(o) ? o : G.width, d = Number.isFinite(d) ? d : G.height, G.bind(0), Y = G.glTarget;
  else
    throw new Error("invalid destination");
  switch (Y) {
    case 3553:
    case 34067:
      r.gl.copyTexSubImage2D(Y, n, E, D, T, M, o, d);
      break;
    case 35866:
    case 32879:
      r.gl.copyTexSubImage3D(Y, n, E, D, U, T, M, o, d);
      break;
  }
  G && G.unbind(), r.gl.bindFramebuffer(36160, q), b && m.destroy();
}
function LC(r) {
  if (r instanceof Wi) {
    const {
      width: e,
      height: t,
      id: n
    } = r;
    return {
      framebuffer: r.device.createFramebuffer({
        id: `framebuffer-for-${n}`,
        width: e,
        height: t,
        colorAttachments: [r]
      }),
      destroyFramebuffer: !0
    };
  }
  return {
    framebuffer: r,
    destroyFramebuffer: !1
  };
}
class Fz extends S1 {
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "commandBuffer");
    this.device = t, this.commandBuffer = new Lz(t);
  }
  destroy() {
  }
  finish() {
    this.commandBuffer.submitCommands();
  }
  // beginRenderPass(GPURenderPassDescriptor descriptor): GPURenderPassEncoder;
  // beginComputePass(optional GPUComputePassDescriptor descriptor = {}): GPUComputePassEncoder;
  // finish(options?: {id?: string}): GPUCommandBuffer;
  copyBufferToBuffer(t) {
    this.commandBuffer.commands.push({
      name: "copy-buffer-to-buffer",
      options: t
    });
  }
  copyBufferToTexture(t) {
    this.commandBuffer.commands.push({
      name: "copy-buffer-to-texture",
      options: t
    });
  }
  copyTextureToBuffer(t) {
    this.commandBuffer.commands.push({
      name: "copy-texture-to-buffer",
      options: t
    });
  }
  copyTextureToTexture(t) {
    this.commandBuffer.commands.push({
      name: "copy-texture-to-texture",
      options: t
    });
  }
  // clearTexture(options: ClearTextureOptions): void {
  //   this.commandBuffer.commands.push({name: 'copy-texture-to-texture', options});
  // }
  pushDebugGroup(t) {
  }
  popDebugGroup() {
  }
  insertDebugMarker(t) {
  }
  resolveQuerySet(t, n, i) {
  }
}
function Uz(r) {
  const {
    target: e,
    source: t,
    start: n = 0,
    count: i = 1
  } = r, s = t.length, l = i * s;
  let o = 0;
  for (let d = n; o < s; o++)
    e[d++] = t[o];
  for (; o < l; )
    o < l - o ? (e.copyWithin(n + o, n, n + o), o *= 2) : (e.copyWithin(n + o, n, n + l - o), o = l);
  return r.target;
}
class B2 extends C1 {
  // Create a VertexArray
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "handle");
    /** Attribute 0 buffer constant */
    H(this, "buffer", null);
    H(this, "bufferValue", null);
    this.device = t, this.handle = this.device.gl.createVertexArray();
  }
  get [Symbol.toStringTag]() {
    return "VertexArray";
  }
  /** * Attribute 0 can not be disable on most desktop OpenGL based browsers */
  static isConstantAttributeZeroSupported(t) {
    return s4() === "Chrome";
  }
  destroy() {
    var t;
    super.destroy(), this.buffer && ((t = this.buffer) == null || t.destroy()), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0);
  }
  /**
  // Set (bind/unbind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER or null. Constants not supported
   *
   * @param elementBuffer
   */
  setIndexBuffer(t) {
    const n = t;
    if (n && n.glTarget !== 34963)
      throw new Error("Use .setBuffer()");
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34963, n ? n.handle : null), this.indexBuffer = n, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a buffer, enables the location, sets divisor */
  setBuffer(t, n) {
    const i = n;
    if (i.glTarget === 34963)
      throw new Error("Use .setIndexBuffer()");
    const {
      size: s,
      type: l,
      stride: o,
      offset: d,
      normalized: m,
      integer: b,
      divisor: T
    } = this._getAccessor(t);
    this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, i.handle), b ? this.device.gl.vertexAttribIPointer(t, s, l, o, d) : this.device.gl.vertexAttribPointer(t, s, l, m, o, d), this.device.gl.bindBuffer(34962, null), this.device.gl.enableVertexAttribArray(t), this.device.gl.vertexAttribDivisor(t, T || 0), this.attributes[t] = i, this.device.gl.bindVertexArray(null);
  }
  /** Set a location in vertex attributes array to a constant value, disables the location */
  setConstantWebGL(t, n) {
    this._enable(t, !1), this.attributes[t] = n;
  }
  bindBeforeRender() {
    this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes();
  }
  unbindAfterRender() {
    this.device.gl.bindVertexArray(null);
  }
  // Internal methods
  /**
   * Constant attributes need to be reset before every draw call
   * Any attribute that is disabled in the current vertex array object
   * is read from the context's global constant value for that attribute location.
   * @note Constant attributes are only supported in WebGL, not in WebGPU
   */
  _applyConstantAttributes() {
    for (let t = 0; t < this.maxVertexAttributes; ++t) {
      const n = this.attributes[t];
      ArrayBuffer.isView(n) && this.device.setConstantAttributeWebGL(t, n);
    }
  }
  /**
   * Set a location in vertex attributes array to a buffer, enables the location, sets divisor
   * @note requires vertex array to be bound
   */
  // protected _setAttributeLayout(location: number): void {
  //   const {size, type, stride, offset, normalized, integer, divisor} = this._getAccessor(location);
  //   // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
  //   if (integer) {
  //     this.device.gl.vertexAttribIPointer(location, size, type, stride, offset);
  //   } else {
  //     // Attaches ARRAY_BUFFER with specified buffer format to location
  //     this.device.gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
  //   }
  //   this.device.gl.vertexAttribDivisor(location, divisor || 0);
  // }
  /** Get an accessor from the  */
  _getAccessor(t) {
    const n = this.attributeInfos[t];
    if (!n)
      throw new Error(`Unknown attribute location ${t}`);
    const i = AC(n.bufferDataType);
    return {
      size: n.bufferComponents,
      type: i,
      stride: n.byteStride,
      offset: n.byteOffset,
      normalized: n.normalized,
      // it is the shader attribute declaration, not the vertex memory format,
      // that determines if the data in the buffer will be treated as integers.
      //
      // Also note that WebGL supports assigning non-normalized integer data to floating point attributes,
      // but as far as we can tell, WebGPU does not.
      integer: n.integer,
      divisor: n.stepMode === "instance" ? 1 : 0
    };
  }
  /**
   * Enabling an attribute location makes it reference the currently bound buffer
   * Disabling an attribute location makes it reference the global constant value
   * TODO - handle single values for size 1 attributes?
   * TODO - convert classic arrays based on known type?
   */
  _enable(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    const s = B2.isConstantAttributeZeroSupported(this.device) || t !== 0;
    (n || s) && (t = Number(t), this.device.gl.bindVertexArray(this.handle), n ? this.device.gl.enableVertexAttribArray(t) : this.device.gl.disableVertexAttribArray(t), this.device.gl.bindVertexArray(null));
  }
  /**
   * Provide a means to create a buffer that is equivalent to a constant.
   * NOTE: Desktop OpenGL cannot disable attribute 0.
   * https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
   * this-has-significant-performance-penalty
   */
  getConstantBuffer(t, n) {
    const i = zz(n), s = i.byteLength * t, l = i.length * t;
    if (this.buffer && s !== this.buffer.byteLength)
      throw new Error(`Buffer size is immutable, byte length ${s} !== ${this.buffer.byteLength}.`);
    let o = !this.buffer;
    if (this.buffer = this.buffer || this.device.createBuffer({
      byteLength: s
    }), o = o || !jz(i, this.bufferValue), o) {
      const d = y6(n.constructor, l);
      Uz({
        target: d,
        source: i,
        start: 0,
        count: l
      }), this.buffer.write(d), this.bufferValue = n;
    }
    return this.buffer;
  }
}
function zz(r) {
  return Array.isArray(r) ? new Float32Array(r) : r;
}
function jz(r, e) {
  if (!r || !e || r.length !== e.length || r.constructor !== e.constructor)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
class Vz extends I1 {
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "gl");
    H(this, "handle");
    /**
     * NOTE: The Model already has this information while drawing, but
     * TransformFeedback currently needs it internally, to look up
     * varying information outside of a draw() call.
     */
    H(this, "layout");
    H(this, "buffers", {});
    H(this, "unusedBuffers", {});
    /**
     * Allows us to avoid a Chrome bug where a buffer that is already bound to a
     * different target cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
     * This a major workaround, see: https://github.com/KhronosGroup/WebGL/issues/2346
     */
    H(this, "bindOnUse", !0);
    H(this, "_bound", !1);
    this.device = t, this.gl = t.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, n.buffers && this.setBuffers(n.buffers), Object.seal(this);
  }
  destroy() {
    this.gl.deleteTransformFeedback(this.handle), super.destroy();
  }
  begin() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "point-list";
    this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(Pz(t));
  }
  end() {
    this.gl.endTransformFeedback(), this.bindOnUse && this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null);
  }
  // SUBCLASS
  setBuffers(t) {
    this.buffers = {}, this.unusedBuffers = {}, this.bind(() => {
      for (const n in t)
        this.setBuffer(n, t[n]);
    });
  }
  setBuffer(t, n) {
    const i = this._getVaryingIndex(t), {
      buffer: s,
      byteLength: l,
      byteOffset: o
    } = this._getBufferRange(n);
    if (i < 0) {
      this.unusedBuffers[t] = s, lr.warn(`${this.id} unusedBuffers varying buffer ${t}`)();
      return;
    }
    this.buffers[i] = {
      buffer: s,
      byteLength: l,
      byteOffset: o
    }, this.bindOnUse || this._bindBuffer(i, s, o, l);
  }
  getBuffer(t) {
    if (UT(t))
      return this.buffers[t] || null;
    const n = this._getVaryingIndex(t);
    return n >= 0 ? this.buffers[n] : null;
  }
  bind() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
    if (typeof t != "function")
      return this.gl.bindTransformFeedback(36386, t), this;
    let n;
    return this._bound ? n = t() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = !0, n = t(), this._bound = !1, this.gl.bindTransformFeedback(36386, null)), n;
  }
  unbind() {
    this.bind(null);
  }
  // PRIVATE METHODS
  /** Extract offsets for bindBufferRange */
  _getBufferRange(t) {
    if (t instanceof sg)
      return {
        buffer: t,
        byteOffset: 0,
        byteLength: t.byteLength
      };
    const {
      buffer: n,
      byteOffset: i = 0,
      byteLength: s = t.buffer.byteLength
    } = t;
    return {
      buffer: n,
      byteOffset: i,
      byteLength: s
    };
  }
  _getVaryingIndex(t) {
    if (UT(t))
      return Number(t);
    for (const n of this.layout.varyings)
      if (t === n.name)
        return n.location;
    return -1;
  }
  /**
   * Need to avoid chrome bug where buffer that is already bound to a different target
   * cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
   */
  _bindBuffers() {
    for (const t in this.buffers) {
      const {
        buffer: n,
        byteLength: i,
        byteOffset: s
      } = this._getBufferRange(this.buffers[t]);
      this._bindBuffer(Number(t), n, s, i);
    }
  }
  _unbindBuffers() {
    for (const t in this.buffers)
      this.gl.bindBufferBase(35982, Number(t), null);
  }
  _bindBuffer(t, n) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, s = arguments.length > 3 ? arguments[3] : void 0;
    const l = n && n.handle;
    !l || s === void 0 ? this.gl.bindBufferBase(35982, t, l) : this.gl.bindBufferRange(35982, t, l, i, s);
  }
}
function UT(r) {
  return typeof r == "number" ? Number.isInteger(r) : /^\d+$/.test(r);
}
class qz extends M1 {
  // Create a query class
  constructor(t, n) {
    super(t, n);
    H(this, "device");
    H(this, "handle");
    H(this, "target", null);
    H(this, "_queryPending", !1);
    H(this, "_pollingPromise", null);
    if (this.device = t, n.count > 1)
      throw new Error("WebGL QuerySet can only have one value");
    this.handle = this.device.gl.createQuery(), Object.seal(this);
  }
  get [Symbol.toStringTag]() {
    return "Query";
  }
  destroy() {
    this.device.gl.deleteQuery(this.handle);
  }
  // FOR RENDER PASS AND COMMAND ENCODER
  /**
   * Shortcut for timer query (dependent on extension in both WebGL1 and 2)
   * Measures GPU time delta between this call and a matching `end` call in the
   * GPU instruction stream.
   */
  beginTimestampQuery() {
    return this._begin(35007);
  }
  endTimestampQuery() {
    this._end();
  }
  // Shortcut for occlusion queries
  beginOcclusionQuery(t) {
    return this._begin(t != null && t.conservative ? 36202 : 35887);
  }
  endOcclusionQuery() {
    this._end();
  }
  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this._begin(35976);
  }
  endTransformFeedbackQuery() {
    this._end();
  }
  async resolveQuery() {
    return [await this.pollQuery()];
  }
  // PRIVATE METHODS
  /**
   * Due to OpenGL API limitations, after calling `begin()` on one Query
   * instance, `end()` must be called on that same instance before
   * calling `begin()` on another query. While there can be multiple
   * outstanding queries representing disjoint `begin()`/`end()` intervals.
   * It is not possible to interleave or overlap `begin` and `end` calls.
   */
  _begin(t) {
    this._queryPending || (this.target = t, this.device.gl.beginQuery(this.target, this.handle));
  }
  // ends the current query
  _end() {
    this._queryPending || this.target && (this.device.gl.endQuery(this.target), this.target = null, this._queryPending = !0);
  }
  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending)
      return !1;
    const t = this.device.gl.getQueryParameter(this.handle, 34919);
    return t && (this._queryPending = !1), t;
  }
  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.device.gl.getParameter(36795);
  }
  // Returns query result.
  getResult() {
    return this.device.gl.getQueryParameter(this.handle, 34918);
  }
  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  // Polls the query
  pollQuery() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
    if (this._pollingPromise)
      return this._pollingPromise;
    let n = 0;
    return this._pollingPromise = new Promise((i, s) => {
      const l = () => {
        this.isResultAvailable() ? (i(this.getResult()), this._pollingPromise = null) : n++ > t ? (s("Timed out"), this._pollingPromise = null) : requestAnimationFrame(l);
      };
      requestAnimationFrame(l);
    }), this._pollingPromise;
  }
}
class Th extends Eh {
  //
  // Public API
  //
  constructor(t) {
    var T, M;
    super({
      ...t,
      id: t.id || $U("webgl-device")
    });
    //
    // Public `Device` API
    //
    /** type of this device */
    H(this, "type", "webgl");
    // Use the ! assertion to handle the case where _reuseDevices causes the constructor to return early
    /** The underlying WebGL context */
    H(this, "handle");
    H(this, "features");
    H(this, "limits");
    H(this, "info");
    H(this, "canvasContext");
    H(this, "lost");
    H(this, "_resolveContextLost");
    /** WebGL2 context. */
    H(this, "gl");
    H(this, "debug", !1);
    /** State used by luma.gl classes: TODO - move to canvasContext*/
    H(this, "_canvasSizeInfo", {
      clientWidth: 0,
      clientHeight: 0,
      devicePixelRatio: 1
    });
    /** State used by luma.gl classes - TODO - not used? */
    H(this, "_extensions", {});
    H(this, "_polyfilled", !1);
    /** Instance of Spector.js (if initialized) */
    H(this, "spectorJS");
    H(this, "renderPass", null);
    /** Store constants */
    H(this, "_constants");
    const n = Eh._getCanvasContextProps(t);
    if (!n)
      throw new Error("WebGLDevice requires props.createCanvasContext to be set");
    let i = (M = (T = n.canvas) == null ? void 0 : T.gl) == null ? void 0 : M.device;
    if (i)
      throw new Error(`WebGL context already attached to device ${i.id}`);
    this.canvasContext = new OU(this, n), this.lost = new Promise((E) => {
      this._resolveContextLost = E;
    });
    const s = {
      ...t.webgl
    };
    n.alphaMode === "premultiplied" && (s.premultipliedAlpha = !0), t.powerPreference !== void 0 && (s.powerPreference = t.powerPreference);
    const o = this.props._handle || pU(this.canvasContext.canvas, {
      onContextLost: (E) => {
        var D;
        return (D = this._resolveContextLost) == null ? void 0 : D.call(this, {
          reason: "destroyed",
          message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
        });
      },
      // eslint-disable-next-line no-console
      onContextRestored: (E) => console.log("WebGL context restored")
    }, s);
    if (!o)
      throw new Error("WebGL context creation failed");
    if (i = o.device, i) {
      if (t._reuseDevices)
        return lr.log(1, `Not creating a new Device, instead returning a reference to Device ${i.id} already attached to WebGL context`, i)(), i._reused = !0, i;
      throw new Error(`WebGL context already attached to device ${i.id}`);
    }
    this.handle = o, this.gl = o, this.spectorJS = kU({
      ...this.props,
      gl: this.handle
    }), this.gl.device = this, this.gl._version = 2, this.info = gU(this.gl, this._extensions), this.limits = new RU(this.gl), this.features = new PU(this.gl, this._extensions, this.props._disabledFeatures), this.props._initializeFeatures && this.features.initializeFeatures(), n.autoResize !== !1 && this.canvasContext.resize(), new vf(this.gl, {
      log: function() {
        for (var E = arguments.length, D = new Array(E), U = 0; U < E; U++)
          D[U] = arguments[U];
        return lr.log(1, ...D)();
      }
    }).trackState(this.gl, {
      copyState: !1
    });
    const m = t.debugWebGL || t.debug, b = t.debugWebGL;
    m && (this.gl = zU(this.gl, {
      debugWebGL: m,
      traceWebGL: b
    }), lr.warn("WebGL debug mode activated. Performance reduced.")(), t.debugWebGL && (lr.level = Math.max(lr.level, 1)));
  }
  /**
   * Destroys the device
   *
   * @note "Detaches" from the WebGL context unless _reuseDevices is true.
   *
   * @note The underlying WebGL context is not immediately destroyed,
   * but may be destroyed later through normal JavaScript garbage collection.
   * This is a fundamental limitation since WebGL does not offer any
   * browser API for destroying WebGL contexts.
   */
  destroy() {
    !this.props._reuseDevices && !this._reused && delete this.gl.device;
  }
  get isLost() {
    return this.gl.isContextLost();
  }
  // IMPLEMENTATION OF ABSTRACT DEVICE
  createCanvasContext(t) {
    throw new Error("WebGL only supports a single canvas");
  }
  createBuffer(t) {
    const n = this._normalizeBufferProps(t);
    return new sg(this, n);
  }
  createTexture(t) {
    return new og(this, t);
  }
  createExternalTexture(t) {
    throw new Error("createExternalTexture() not implemented");
  }
  createSampler(t) {
    return new Q1(this, t);
  }
  createShader(t) {
    return new ZU(this, t);
  }
  createFramebuffer(t) {
    return new ig(this, t);
  }
  createVertexArray(t) {
    return new B2(this, t);
  }
  createTransformFeedback(t) {
    return new Vz(this, t);
  }
  createQuerySet(t) {
    return new qz(this, t);
  }
  createRenderPipeline(t) {
    return new Rz(this, t);
  }
  beginRenderPass(t) {
    return new pz(this, t);
  }
  createComputePipeline(t) {
    throw new Error("ComputePipeline not supported in WebGL");
  }
  beginComputePass(t) {
    throw new Error("ComputePass not supported in WebGL");
  }
  createCommandEncoder() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return new Fz(this, t);
  }
  /**
   * Offscreen Canvas Support: Commit the frame
   * https://developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/commit
   * Chrome's offscreen canvas does not require gl.commit
   */
  submit() {
    var t;
    (t = this.renderPass) == null || t.end(), this.renderPass = null;
  }
  //
  // TEMPORARY HACKS - will be removed in v9.1
  //
  /** @deprecated - should use command encoder */
  readPixelsToArrayWebGL(t, n) {
    return cz(t, n);
  }
  /** @deprecated - should use command encoder */
  readPixelsToBufferWebGL(t, n) {
    return uz(t, n);
  }
  setParametersWebGL(t) {
    ep(this.gl, t);
  }
  getParametersWebGL(t) {
    return xC(this.gl, t);
  }
  withParametersWebGL(t, n) {
    return V_(this.gl, t, n);
  }
  resetWebGL() {
    lr.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), cU(this.gl);
  }
  _getDeviceSpecificTextureFormatCapabilities(t) {
    return EU(this.gl, t, this._extensions);
  }
  //
  // WebGL-only API (not part of `Device` API)
  //
  /**
   * Triggers device (or WebGL context) loss.
   * @note primarily intended for testing how application reacts to device loss
   */
  loseDevice() {
    var s;
    let t = !1;
    const i = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
    return i && (t = !0, i.loseContext()), (s = this._resolveContextLost) == null || s.call(this, {
      reason: "destroyed",
      message: "Application triggered context loss"
    }), t;
  }
  /** Save current WebGL context state onto an internal stack */
  pushState() {
    vf.get(this.gl).push();
  }
  /** Restores previously saved context state */
  popState() {
    vf.get(this.gl).pop();
  }
  /**
   * Storing data on a special field on WebGLObjects makes that data visible in SPECTOR chrome debug extension
   * luma.gl ids and props can be inspected
   */
  setSpectorMetadata(t, n) {
    t.__SPECTOR_Metadata = n;
  }
  /**
   * Returns the GL.<KEY> constant that corresponds to a numeric value of a GL constant
   * Be aware that there are some duplicates especially for constants that are 0,
   * so this isn't guaranteed to return the right key in all cases.
   */
  getGLKey(t, n) {
    const i = Number(t);
    for (const s in this.gl)
      if (this.gl[s] === i)
        return `GL.${s}`;
    return n != null && n.emptyIfUnknown ? "" : String(t);
  }
  /**
   * Returns a map with any GL.<KEY> constants mapped to strings, both for keys and values
   */
  getGLKeys(t) {
    const n = {
      emptyIfUnknown: !0
    };
    return Object.entries(t).reduce((i, s) => {
      let [l, o] = s;
      return i[`${l}:${this.getGLKey(l, n)}`] = `${o}:${this.getGLKey(o, n)}`, i;
    }, {});
  }
  /**
   * Set a constant value for a location. Disabled attributes at that location will read from this value
   * @note WebGL constants are stored globally on the WebGL context, not the VertexArray
   * so they need to be updated before every render
   * @todo - remember/cache values to avoid setting them unnecessarily?
   */
  setConstantAttributeWebGL(t, n) {
    const i = this.limits.maxVertexAttributes;
    this._constants = this._constants || new Array(i).fill(null);
    const s = this._constants[t];
    switch (s && Wz(s, n) && lr.info(1, `setConstantAttributeWebGL(${t}) could have been skipped, value unchanged`)(), this._constants[t] = n, n.constructor) {
      case Float32Array:
        Gz(this, t, n);
        break;
      case Int32Array:
        $z(this, t, n);
        break;
      case Uint32Array:
        Hz(this, t, n);
        break;
      default:
        throw new Error("constant");
    }
  }
  /** Ensure extensions are only requested once */
  getExtension(t) {
    return Vd(this.gl, t, this._extensions), this._extensions;
  }
}
function Gz(r, e, t) {
  switch (t.length) {
    case 1:
      r.gl.vertexAttrib1fv(e, t);
      break;
    case 2:
      r.gl.vertexAttrib2fv(e, t);
      break;
    case 3:
      r.gl.vertexAttrib3fv(e, t);
      break;
    case 4:
      r.gl.vertexAttrib4fv(e, t);
      break;
  }
}
function $z(r, e, t) {
  r.gl.vertexAttribI4iv(e, t);
}
function Hz(r, e, t) {
  r.gl.vertexAttribI4uiv(e, t);
}
function Wz(r, e) {
  if (!r || !e || r.length !== e.length || r.constructor !== e.constructor)
    return !1;
  for (let t = 0; t < r.length; ++t)
    if (r[t] !== e[t])
      return !1;
  return !0;
}
const Xz = {
  WEBGL_depth_texture: {
    UNSIGNED_INT_24_8_WEBGL: 34042
  },
  OES_element_index_uint: {},
  OES_texture_float: {},
  OES_texture_half_float: {
    // @ts-expect-error different numbers?
    HALF_FLOAT_OES: 5131
  },
  EXT_color_buffer_float: {},
  OES_standard_derivatives: {
    FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723
  },
  EXT_frag_depth: {},
  EXT_blend_minmax: {
    MIN_EXT: 32775,
    MAX_EXT: 32776
  },
  EXT_shader_texture_lod: {}
}, Zz = (r) => ({
  drawBuffersWEBGL(e) {
    return r.drawBuffers(e);
  },
  COLOR_ATTACHMENT0_WEBGL: 36064,
  COLOR_ATTACHMENT1_WEBGL: 36065,
  COLOR_ATTACHMENT2_WEBGL: 36066,
  COLOR_ATTACHMENT3_WEBGL: 36067
}), Yz = (r) => ({
  VERTEX_ARRAY_BINDING_OES: 34229,
  createVertexArrayOES() {
    return r.createVertexArray();
  },
  deleteVertexArrayOES(e) {
    return r.deleteVertexArray(e);
  },
  isVertexArrayOES(e) {
    return r.isVertexArray(e);
  },
  bindVertexArrayOES(e) {
    return r.bindVertexArray(e);
  }
}), Kz = (r) => ({
  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
  drawArraysInstancedANGLE() {
    return r.drawArraysInstanced(...arguments);
  },
  drawElementsInstancedANGLE() {
    return r.drawElementsInstanced(...arguments);
  },
  vertexAttribDivisorANGLE() {
    return r.vertexAttribDivisor(...arguments);
  }
});
function Jz() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  const e = HTMLCanvasElement.prototype;
  if (!r && e.originalGetContext) {
    e.getContext = e.originalGetContext, e.originalGetContext = void 0;
    return;
  }
  e.originalGetContext = e.getContext, e.getContext = function(t, n) {
    if (t === "webgl" || t === "experimental-webgl") {
      const i = this.originalGetContext("webgl2", n);
      return i instanceof HTMLElement && Qz(i), i;
    }
    return this.originalGetContext(t, n);
  };
}
function Qz(r) {
  r.getExtension("EXT_color_buffer_float");
  const e = {
    ...Xz,
    WEBGL_disjoint_timer_query: r.getExtension("EXT_disjoint_timer_query_webgl2"),
    WEBGL_draw_buffers: Zz(r),
    OES_vertex_array_object: Yz(r),
    ANGLE_instanced_arrays: Kz(r)
  }, t = r.getExtension;
  r.getExtension = function(i) {
    const s = t.call(r, i);
    return s || (i in e ? e[i] : null);
  };
  const n = r.getSupportedExtensions;
  r.getSupportedExtensions = function() {
    const i = n.apply(r) || [];
    return i == null ? void 0 : i.concat(Object.keys(e));
  };
}
const vm = 1;
class e7 extends XO {
  constructor() {
    super();
    /** type of device's created by this adapter */
    H(this, "type", "webgl");
    Eh.defaultProps = {
      ...Eh.defaultProps,
      ...R2
    }, Th.adapter = this;
  }
  /** Check if WebGL 2 is available */
  isSupported() {
    return typeof WebGL2RenderingContext < "u";
  }
  /** Force any created WebGL contexts to be WebGL2 contexts, polyfilled with WebGL1 extensions */
  enforceWebGL2(t) {
    Jz(t);
  }
  /**
   * Get a device instance from a GL context
   * Creates a WebGLCanvasContext against the contexts canvas
   * @note autoResize will be disabled, assuming that whoever created the external context will be handling resizes.
   * @param gl
   * @returns
   */
  async attach(t) {
    if (t instanceof Th)
      return t;
    if ((t == null ? void 0 : t.device) instanceof Eh)
      return t.device;
    if (!t7(t))
      throw new Error("Invalid WebGL2RenderingContext");
    return new Th({
      _handle: t,
      createCanvasContext: {
        canvas: t.canvas,
        autoResize: !1
      }
    });
  }
  async create() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    lr.groupCollapsed(vm, "WebGLDevice created")();
    const n = [];
    (t.debugWebGL || t.debug) && n.push(UU()), t.debugSpectorJS && n.push(DU(t));
    const i = await Promise.allSettled(n);
    for (const o of i)
      o.status === "rejected" && lr.error(`Failed to initialize debug libraries ${o.reason}`)();
    const s = new Th(t), l = `${s._reused ? "Reusing" : "Created"} device with WebGL2 ${s.debug ? "debug " : ""}context: ${s.info.vendor}, ${s.info.renderer} for canvas: ${s.canvasContext.id}`;
    return lr.probe(vm, l)(), lr.table(vm, s.info)(), lr.groupEnd(vm)(), s;
  }
}
function t7(r) {
  return typeof WebGL2RenderingContext < "u" && r instanceof WebGL2RenderingContext ? !0 : !!(r && Number.isFinite(r._version));
}
const zT = new e7();
function hh() {
}
const r7 = (r) => {
  let {
    isDragging: e
  } = r;
  return e ? "grabbing" : "grab";
}, OC = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  parameters: {},
  parent: null,
  device: null,
  deviceProps: {
    type: "webgl"
  },
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  // Rely on external controller, e.g. react-map-gl
  useDevicePixels: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: !1,
  _pickable: !0,
  _typedArrayManagerProps: {},
  _customRender: null,
  widgets: [],
  onDeviceInitialized: hh,
  onWebGLInitialized: hh,
  onResize: hh,
  onViewStateChange: hh,
  onInteractionStateChange: hh,
  onBeforeRender: hh,
  onAfterRender: hh,
  onLoad: hh,
  onError: (r) => qn.error(r.message, r.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor: r7,
  getTooltip: null,
  debug: !1,
  drawPickingColors: !1
};
class yg {
  constructor(e) {
    this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
      isHovering: !1,
      isDragging: !1
    }, this.stats = new Yd({
      id: "deck.gl"
    }), this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    }, this._metricsCounter = 0, this._needsRedraw = "Initial render", this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    }, this._lastPointerDownInfo = null, this._onPointerMove = (n) => {
      const {
        _pickRequest: i
      } = this;
      if (n.type === "pointerleave")
        i.x = -1, i.y = -1, i.radius = 0;
      else {
        if (n.leftButton || n.rightButton)
          return;
        {
          const s = n.offsetCenter;
          if (!s)
            return;
          i.x = s.x, i.y = s.y, i.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = {
        x: i.x,
        y: i.y
      }), i.event = n;
    }, this._onEvent = (n) => {
      const i = j1[n.type], s = n.offsetCenter;
      if (!i || !s || !this.layerManager)
        return;
      const l = this.layerManager.getLayers(), o = this.deckPicker.getLastPickedObject({
        x: s.x,
        y: s.y,
        layers: l,
        viewports: this.getViewports(s)
      }, this._lastPointerDownInfo), {
        layer: d
      } = o, m = d && (d[i] || d.props[i]), b = this.props[i];
      let T = !1;
      m && (T = m.call(d, o, n)), T || (b == null || b(o, n), this.widgetManager.onEvent(o, n));
    }, this._onPointerDown = (n) => {
      const i = n.offsetCenter, s = this._pick("pickObject", "pickObject Time", {
        x: i.x,
        y: i.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = s.result[0] || s.emptyInfo;
    }, this.props = {
      ...OC,
      ...e
    }, e = this.props, e.viewState && e.initialViewState && qn.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, e.device && (this.device = e.device);
    let t = this.device;
    !t && e.gl && (e.gl instanceof WebGLRenderingContext && qn.error("WebGL1 context not supported.")(), t = zT.attach(e.gl)), t || (t = w1.createDevice({
      type: "best-available",
      // luma by default throws if a device is already attached
      // asynchronous device creation could happen after finalize() is called
      // TODO - createDevice should support AbortController?
      _reuseDevices: !0,
      adapters: [zT],
      ...e.deviceProps,
      createCanvasContext: {
        canvas: this._createCanvas(e),
        useDevicePixels: this.props.useDevicePixels,
        // TODO v9.2 - replace AnimationLoop's `autoResizeDrawingBuffer` with CanvasContext's `autoResize`
        autoResize: !1
      }
    })), this.animationLoop = this._createAnimationLoop(t, e), this.setProps(e), e._typedArrayManagerProps && mg.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
  }
  /** Stop rendering and dispose all resources */
  finalize() {
    var e, t, n, i, s, l, o, d, m, b;
    (e = this.animationLoop) == null || e.stop(), (t = this.animationLoop) == null || t.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, (n = this.layerManager) == null || n.finalize(), this.layerManager = null, (i = this.viewManager) == null || i.finalize(), this.viewManager = null, (s = this.effectManager) == null || s.finalize(), this.effectManager = null, (l = this.deckRenderer) == null || l.finalize(), this.deckRenderer = null, (o = this.deckPicker) == null || o.finalize(), this.deckPicker = null, (d = this.eventManager) == null || d.destroy(), this.eventManager = null, (m = this.widgetManager) == null || m.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && !this.props.gl && this.canvas && ((b = this.canvas.parentElement) == null || b.removeChild(this.canvas), this.canvas = null);
  }
  /** Partially update props */
  setProps(e) {
    var n;
    this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && qn.removed("onLayerHover", "onHover")(), "onLayerClick" in e && qn.removed("onLayerClick", "onClick")(), e.initialViewState && // depth = 3 when comparing viewStates: viewId.position.0
    !Tc(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
    const t = Object.create(this.props);
    Object.assign(t, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    }), (n = this.animationLoop) == null || n.setProps(t), this.layerManager && (this.viewManager.setProps(t), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(t), this.effectManager.setProps(t), this.deckRenderer.setProps(t), this.deckPicker.setProps(t), this.widgetManager.setProps(t)), this.stats.get("setProps Time").timeEnd();
  }
  // Public API
  /**
   * Check if a redraw is needed
   * @returns `false` or a string summarizing the redraw reason
   */
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    if (!this.layerManager)
      return !1;
    if (this.props._animate)
      return "Deck._animate";
    let t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    const n = this.viewManager.needsRedraw(e), i = this.layerManager.needsRedraw(e), s = this.effectManager.needsRedraw(e), l = this.deckRenderer.needsRedraw(e);
    return t = t || n || i || s || l, t;
  }
  /**
   * Redraw the GL context
   * @param reason If not provided, only redraw if deemed necessary. Otherwise redraw regardless of internal states.
   * @returns
   */
  redraw(e) {
    if (!this.layerManager)
      return;
    let t = this.needsRedraw({
      clearRedrawFlags: !0
    });
    t = e || t, t && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(t) : this._drawLayers(t));
  }
  /** Flag indicating that the Deck instance has initialized its resources and it's safe to call public methods. */
  get isInitialized() {
    return this.viewManager !== null;
  }
  /** Get a list of views that are currently rendered */
  getViews() {
    return Xs(this.viewManager), this.viewManager.views;
  }
  /** Get a list of viewports that are currently rendered.
   * @param rect If provided, only returns viewports within the given bounding box.
   */
  getViewports(e) {
    return Xs(this.viewManager), this.viewManager.getViewports(e);
  }
  /** Get the current canvas element. */
  getCanvas() {
    return this.canvas;
  }
  /** Query the object rendered on top at a given point */
  pickObject(e) {
    const t = this._pick("pickObject", "pickObject Time", e).result;
    return t.length ? t[0] : null;
  }
  /* Query all rendered objects at a given point */
  pickMultipleObjects(e) {
    return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
  }
  /* Query all objects rendered on top within a bounding box */
  pickObjects(e) {
    return this._pick("pickObjects", "pickObjects Time", e);
  }
  /** Experimental
   * Add a global resource for sharing among layers
   */
  _addResources(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    for (const n in e)
      this.layerManager.resourceManager.add({
        resourceId: n,
        data: e[n],
        forceUpdate: t
      });
  }
  /** Experimental
   * Remove a global resource
   */
  _removeResources(e) {
    for (const t of e)
      this.layerManager.resourceManager.remove(t);
  }
  /** Experimental
   * Register a default effect. Effects will be sorted by order, those with a low order will be rendered first
   */
  _addDefaultEffect(e) {
    this.effectManager.addDefaultEffect(e);
  }
  _addDefaultShaderModule(e) {
    this.layerManager.addDefaultShaderModule(e);
  }
  _removeDefaultShaderModule(e) {
    var t;
    (t = this.layerManager) == null || t.removeDefaultShaderModule(e);
  }
  _pick(e, t, n) {
    Xs(this.deckPicker);
    const {
      stats: i
    } = this;
    i.get("Pick Count").incrementCount(), i.get(t).timeStart();
    const s = this.deckPicker[e]({
      // layerManager, viewManager and effectManager are always defined if deckPicker is
      layers: this.layerManager.getLayers(n),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(n),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...n
    });
    return i.get(t).timeEnd(), s;
  }
  /** Resolve props.canvas to element */
  _createCanvas(e) {
    let t = e.canvas;
    return typeof t == "string" && (t = document.getElementById(t), Xs(t)), t || (t = document.createElement("canvas"), t.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(t)), Object.assign(t.style, e.style), t;
  }
  /** Updates canvas width and/or height, if provided as props */
  _setCanvasSize(e) {
    var i;
    if (!this.canvas)
      return;
    const {
      width: t,
      height: n
    } = e;
    if (t || t === 0) {
      const s = Number.isFinite(t) ? `${t}px` : t;
      this.canvas.style.width = s;
    }
    if (n || n === 0) {
      const s = Number.isFinite(n) ? `${n}px` : n;
      this.canvas.style.position = ((i = e.style) == null ? void 0 : i.position) || "absolute", this.canvas.style.height = s;
    }
  }
  /** If canvas size has changed, reads out the new size and update */
  _updateCanvasSize() {
    var i, s;
    const {
      canvas: e
    } = this;
    if (!e)
      return;
    const t = e.clientWidth ?? e.width, n = e.clientHeight ?? e.height;
    (t !== this.width || n !== this.height) && (this.width = t, this.height = n, (i = this.viewManager) == null || i.setProps({
      width: t,
      height: n
    }), (s = this.layerManager) == null || s.activateViewport(this.getViewports()[0]), this.props.onResize({
      width: t,
      height: n
    }));
  }
  _createAnimationLoop(e, t) {
    const {
      // width,
      // height,
      gl: n,
      // debug,
      onError: i,
      // onBeforeRender,
      // onAfterRender,
      useDevicePixels: s
    } = t;
    return new a8({
      device: e,
      useDevicePixels: s,
      // TODO v9
      autoResizeDrawingBuffer: !n,
      // do not auto resize external context
      autoResizeViewport: !1,
      // @ts-expect-error luma.gl needs to accept Promise<void> return value
      onInitialize: (l) => this._setDevice(l.device),
      onRender: this._onRenderFrame.bind(this),
      // @ts-expect-error typing mismatch: AnimationLoop does not accept onError:null
      onError: i
      // onBeforeRender,
      // onAfterRender,
    });
  }
  // Get the most relevant view state: props.viewState, if supplied, shadows internal viewState
  // TODO: For backwards compatibility ensure numeric width and height is added to the viewState
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  // Get the view descriptor list
  _getViews() {
    const {
      views: e
    } = this.props, t = Array.isArray(e) ? e : (
      // If null, default to a full screen map view port
      e ? [e] : [new C2({
        id: "default-view"
      })]
    );
    return t.length && this.props.controller && (t[0].props.controller = this.props.controller), t;
  }
  _onContextLost() {
    const {
      onError: e
    } = this.props;
    this.animationLoop && e && e(new Error("WebGL context is lost"));
  }
  /** Actually run picking */
  _pickAndCallback() {
    var t, n, i;
    const {
      _pickRequest: e
    } = this;
    if (e.event) {
      const {
        result: s,
        emptyInfo: l
      } = this._pick("pickObject", "pickObject Time", e);
      this.cursorState.isHovering = s.length > 0;
      let o = l, d = !1;
      for (const m of s)
        o = m, d = ((t = m.layer) == null ? void 0 : t.onHover(m, e.event)) || d;
      d || ((i = (n = this.props).onHover) == null || i.call(n, o, e.event), this.widgetManager.onHover(o, e.event)), e.event = null;
    }
  }
  _updateCursor() {
    const e = this.props.parent || this.canvas;
    e && (e.style.cursor = this.props.getCursor(this.cursorState));
  }
  _setDevice(e) {
    var i, s;
    if (this.device = e, !this.animationLoop)
      return;
    this.canvas || (this.canvas = (i = this.device.canvasContext) == null ? void 0 : i.canvas), this.device instanceof Th && this.device.setParametersWebGL({
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthTest: !0,
      depthFunc: 515
    }), this.props.onDeviceInitialized(this.device), this.device instanceof Th && this.props.onWebGLInitialized(this.device.gl);
    const t = new uC();
    t.play(), this.animationLoop.attachTimeline(t), this.eventManager = new Gk(this.props.parent || this.canvas, {
      touchAction: this.props.touchAction,
      recognizers: Object.keys(aT).map((l) => {
        var E;
        const [o, d, m, b] = aT[l], T = (E = this.props.eventRecognizerOptions) == null ? void 0 : E[l], M = {
          ...d,
          ...T,
          event: l
        };
        return {
          recognizer: new o(M),
          recognizeWith: m,
          requestFailure: b
        };
      }),
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const l in j1)
      this.eventManager.on(l, this._onEvent);
    this.viewManager = new R8({
      timeline: t,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const n = this.viewManager.getViewports()[0];
    this.layerManager = new P8(this.device, {
      deck: this,
      stats: this.stats,
      viewport: n,
      timeline: t
    }), this.effectManager = new $8({
      deck: this,
      device: this.device
    }), this.deckRenderer = new X8(this.device), this.deckPicker = new eU(this.device), this.widgetManager = new nU({
      deck: this,
      parentElement: (s = this.canvas) == null ? void 0 : s.parentElement
    }), this.widgetManager.addDefault(new sU()), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
  }
  /** Internal only: default render function (redraw all layers and views) */
  _drawLayers(e, t) {
    var l;
    const {
      device: n,
      gl: i
    } = this.layerManager.context;
    this.props.onBeforeRender({
      device: n,
      gl: i
    });
    const s = {
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...t
    };
    (l = this.deckRenderer) == null || l.renderLayers(s), s.pass === "screen" && this.widgetManager.onRedraw({
      viewports: s.viewports,
      layers: s.layers
    }), this.props.onAfterRender({
      device: n,
      gl: i
    });
  }
  // Callbacks
  _onRenderFrame() {
    this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), qn.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
  }
  // Callbacks
  _onViewStateChange(e) {
    const t = this.props.onViewStateChange(e) || e.viewState;
    this.viewState && (this.viewState = {
      ...this.viewState,
      [e.viewId]: t
    }, this.props.viewState || this.viewManager && this.viewManager.setProps({
      viewState: this.viewState
    }));
  }
  _onInteractionStateChange(e) {
    this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e);
  }
  _getFrameStats() {
    const {
      stats: e
    } = this;
    e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
    const t = this.animationLoop.stats;
    e.get("GPU Time").addTime(t.get("GPU Time").lastTiming), e.get("CPU Time").addTime(t.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const {
      metrics: e,
      stats: t
    } = this;
    e.fps = t.get("frameRate").getHz(), e.setPropsTime = t.get("setProps Time").time, e.updateAttributesTime = t.get("Update Attributes").time, e.framesRedrawn = t.get("Redraw Count").count, e.pickTime = t.get("pickObject Time").time + t.get("pickMultipleObjects Time").time + t.get("pickObjects Time").time, e.pickCount = t.get("Pick Count").count, e.gpuTime = t.get("GPU Time").time, e.cpuTime = t.get("CPU Time").time, e.gpuTimePerFrame = t.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = t.get("CPU Time").getAverageTime();
    const n = w1.stats.get("Memory Usage");
    e.bufferMemory = n.get("Buffer Memory").count, e.textureMemory = n.get("Texture Memory").count, e.renderbufferMemory = n.get("Renderbuffer Memory").count, e.gpuMemory = n.get("GPU Memory").count;
  }
}
yg.defaultProps = OC;
yg.VERSION = QL;
function n7(r) {
  switch (r) {
    case "float64":
      return Float64Array;
    case "uint8":
    case "unorm8":
      return Uint8ClampedArray;
    default:
      return e5(r);
  }
}
const i7 = QE;
function xm(r, e) {
  return {
    attribute: r,
    // @ts-expect-error Not all combinations are valid vertex formats; it's up to DataColumn to ensure
    format: e.size > 1 ? `${e.type}x${e.size}` : e.type,
    byteOffset: e.offset || 0
    // Note stride is set on the top level
  };
}
function uf(r) {
  return r.stride || r.size * r.bytesPerElement;
}
function s7(r, e) {
  return r.type === e.type && r.size === e.size && uf(r) === uf(e) && (r.offset || 0) === (e.offset || 0);
}
function ev(r, e) {
  e.offset && qn.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  const t = uf(r), n = e.vertexOffset !== void 0 ? e.vertexOffset : r.vertexOffset || 0, i = e.elementOffset || 0, s = (
    // offsets defined by the attribute
    n * t + i * r.bytesPerElement + // offsets defined by external buffers if any
    (r.offset || 0)
  );
  return {
    ...e,
    offset: s,
    stride: t
  };
}
function o7(r, e) {
  const t = ev(r, e);
  return {
    high: t,
    low: {
      ...t,
      offset: t.offset + r.size * 4
    }
  };
}
class a7 {
  /* eslint-disable max-statements */
  constructor(e, t, n) {
    this._buffer = null, this.device = e, this.id = t.id || "", this.size = t.size || 1;
    const i = t.logicalType || t.type, s = i === "float64";
    let {
      defaultValue: l
    } = t;
    l = Number.isFinite(l) ? [l] : l || new Array(this.size).fill(0);
    let o;
    s ? o = "float32" : !i && t.isIndexed ? o = "uint32" : o = i || "float32";
    let d = n7(i || o);
    this.doublePrecision = s, s && t.fp64 === !1 && (d = Float32Array), this.value = null, this.settings = {
      ...t,
      defaultType: d,
      defaultValue: l,
      logicalType: i,
      type: o,
      normalized: o.includes("norm"),
      size: this.size,
      bytesPerElement: d.BYTES_PER_ELEMENT
    }, this.state = {
      ...n,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: !1
    };
  }
  /* eslint-enable max-statements */
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    return this._buffer;
  }
  get byteOffset() {
    const e = this.getAccessor();
    return e.vertexOffset ? e.vertexOffset * uf(e) : 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(e) {
    this.state.numInstances = e;
  }
  delete() {
    this._buffer && (this._buffer.delete(), this._buffer = null), mg.release(this.state.allocatedValue);
  }
  getBuffer() {
    return this.state.constant ? null : this.state.externalBuffer || this._buffer;
  }
  getValue() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const n = {};
    if (this.state.constant) {
      const i = this.value;
      if (t) {
        const s = ev(this.getAccessor(), t), l = s.offset / i.BYTES_PER_ELEMENT, o = s.size || this.size;
        n[e] = i.subarray(l, l + o);
      } else
        n[e] = i;
    } else
      n[e] = this.getBuffer();
    return this.doublePrecision && (this.value instanceof Float64Array ? n[`${e}64Low`] = n[e] : n[`${e}64Low`] = new Float32Array(this.size)), n;
  }
  _getBufferLayout() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const n = this.getAccessor(), i = [], s = {
      name: this.id,
      byteStride: uf(n),
      attributes: i
    };
    if (this.doublePrecision) {
      const l = o7(n, t || {});
      i.push(xm(e, {
        ...n,
        ...l.high
      }), xm(`${e}64Low`, {
        ...n,
        ...l.low
      }));
    } else if (t) {
      const l = ev(n, t);
      i.push(xm(e, {
        ...n,
        ...l
      }));
    } else
      i.push(xm(e, n));
    return s;
  }
  setAccessor(e) {
    this.state.bufferAccessor = e;
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  // Returns [min: Array(size), max: Array(size)]
  /* eslint-disable max-depth */
  getBounds() {
    if (this.state.bounds)
      return this.state.bounds;
    let e = null;
    if (this.state.constant && this.value) {
      const t = Array.from(this.value);
      e = [t, t];
    } else {
      const {
        value: t,
        numInstances: n,
        size: i
      } = this, s = n * i;
      if (t && s && t.length >= s) {
        const l = new Array(i).fill(1 / 0), o = new Array(i).fill(-1 / 0);
        for (let d = 0; d < s; )
          for (let m = 0; m < i; m++) {
            const b = t[d++];
            b < l[m] && (l[m] = b), b > o[m] && (o[m] = b);
          }
        e = [l, o];
      }
    }
    return this.state.bounds = e, e;
  }
  // returns true if success
  // eslint-disable-next-line max-statements
  setData(e) {
    const {
      state: t
    } = this;
    let n;
    ArrayBuffer.isView(e) ? n = {
      value: e
    } : e instanceof Ss ? n = {
      buffer: e
    } : n = e;
    const i = {
      ...this.settings,
      ...n
    };
    if (ArrayBuffer.isView(n.value)) {
      if (!n.type)
        if (this.doublePrecision && n.value instanceof Float64Array)
          i.type = "float32";
        else {
          const l = i7(n.value);
          i.type = i.normalized ? l.replace("int", "norm") : l;
        }
      i.bytesPerElement = n.value.BYTES_PER_ELEMENT, i.stride = uf(i);
    }
    if (t.bounds = null, n.constant) {
      let s = n.value;
      if (s = this._normalizeValue(s, [], 0), this.settings.normalized && (s = this.normalizeConstant(s)), !(!t.constant || !this._areValuesEqual(s, this.value)))
        return !1;
      t.externalBuffer = null, t.constant = !0, this.value = ArrayBuffer.isView(s) ? s : new Float32Array(s);
    } else if (n.buffer) {
      const s = n.buffer;
      t.externalBuffer = s, t.constant = !1, this.value = n.value || null;
    } else if (n.value) {
      this._checkExternalBuffer(n);
      let s = n.value;
      t.externalBuffer = null, t.constant = !1, this.value = s;
      let {
        buffer: l
      } = this;
      const o = uf(i), d = (i.vertexOffset || 0) * o;
      if (this.doublePrecision && s instanceof Float64Array && (s = ib(s, i)), this.settings.isIndexed) {
        const b = this.settings.defaultType;
        s.constructor !== b && (s = new b(s));
      }
      const m = s.byteLength + d + o * 2;
      (!l || l.byteLength < m) && (l = this._createBuffer(m)), l.write(s, d);
    }
    return this.setAccessor(i), !0;
  }
  updateSubBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.state.bounds = null;
    const t = this.value, {
      startOffset: n = 0,
      endOffset: i
    } = e;
    this.buffer.write(this.doublePrecision && t instanceof Float64Array ? ib(t, {
      size: this.size,
      startIndex: n,
      endIndex: i
    }) : t.subarray(n, i), n * t.BYTES_PER_ELEMENT + this.byteOffset);
  }
  allocate(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const {
      state: n
    } = this, i = n.allocatedValue, s = mg.allocate(i, e + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: t
    });
    this.value = s;
    const {
      byteOffset: l
    } = this;
    let {
      buffer: o
    } = this;
    return (!o || o.byteLength < s.byteLength + l) && (o = this._createBuffer(s.byteLength + l), t && i && o.write(i instanceof Float64Array ? ib(i, this) : i, l)), n.allocatedValue = s, n.constant = !1, n.externalBuffer = null, this.setAccessor(this.settings), !0;
  }
  // PRIVATE HELPER METHODS
  _checkExternalBuffer(e) {
    const {
      value: t
    } = e;
    if (!ArrayBuffer.isView(t))
      throw new Error(`Attribute ${this.id} value is not TypedArray`);
    const n = this.settings.defaultType;
    let i = !1;
    if (this.doublePrecision && (i = t.BYTES_PER_ELEMENT < 4), i)
      throw new Error(`Attribute ${this.id} does not support ${t.constructor.name}`);
    !(t instanceof n) && this.settings.normalized && !("normalized" in e) && qn.warn(`Attribute ${this.id} is normalized`)();
  }
  // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/vertexAttribPointer
  normalizeConstant(e) {
    switch (this.settings.type) {
      case "snorm8":
        return new Float32Array(e).map((t) => (t + 128) / 255 * 2 - 1);
      case "snorm16":
        return new Float32Array(e).map((t) => (t + 32768) / 65535 * 2 - 1);
      case "unorm8":
        return new Float32Array(e).map((t) => t / 255);
      case "unorm16":
        return new Float32Array(e).map((t) => t / 65535);
      default:
        return e;
    }
  }
  /* check user supplied values and apply fallback */
  _normalizeValue(e, t, n) {
    const {
      defaultValue: i,
      size: s
    } = this.settings;
    if (Number.isFinite(e))
      return t[n] = e, t;
    if (!e) {
      let l = s;
      for (; --l >= 0; )
        t[n + l] = i[l];
      return t;
    }
    switch (s) {
      case 4:
        t[n + 3] = Number.isFinite(e[3]) ? e[3] : i[3];
      case 3:
        t[n + 2] = Number.isFinite(e[2]) ? e[2] : i[2];
      case 2:
        t[n + 1] = Number.isFinite(e[1]) ? e[1] : i[1];
      case 1:
        t[n + 0] = Number.isFinite(e[0]) ? e[0] : i[0];
        break;
      default:
        let l = s;
        for (; --l >= 0; )
          t[n + l] = Number.isFinite(e[l]) ? e[l] : i[l];
    }
    return t;
  }
  _areValuesEqual(e, t) {
    if (!e || !t)
      return !1;
    const {
      size: n
    } = this;
    for (let i = 0; i < n; i++)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  _createBuffer(e) {
    var i;
    this._buffer && this._buffer.destroy();
    const {
      isIndexed: t,
      type: n
    } = this.settings;
    return this._buffer = this.device.createBuffer({
      ...(i = this._buffer) == null ? void 0 : i.props,
      id: this.id,
      usage: t ? Ss.INDEX : Ss.VERTEX,
      indexType: t ? n : void 0,
      byteLength: e
    }), this._buffer;
  }
}
const jT = [], VT = [];
function NC(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1 / 0, n = jT;
  const i = {
    index: -1,
    data: r,
    // visitor can optionally utilize this to avoid constructing a new array for every object
    target: []
  };
  return r ? typeof r[Symbol.iterator] == "function" ? n = r : r.length > 0 && (VT.length = r.length, n = VT) : n = jT, (e > 0 || Number.isFinite(t)) && (n = (Array.isArray(n) ? n : Array.from(n)).slice(e, t), i.index = e - 1), {
    iterable: n,
    objectInfo: i
  };
}
function DC(r) {
  return r && r[Symbol.asyncIterator];
}
function l7(r, e) {
  const {
    size: t,
    stride: n,
    offset: i,
    startIndices: s,
    nested: l
  } = e, o = r.BYTES_PER_ELEMENT, d = n ? n / o : t, m = i ? i / o : 0, b = Math.floor((r.length - m) / d);
  return (T, M) => {
    let {
      index: E,
      target: D
    } = M;
    if (!s) {
      const Y = E * d + m;
      for (let he = 0; he < t; he++)
        D[he] = r[Y + he];
      return D;
    }
    const U = s[E], q = s[E + 1] || b;
    let G;
    if (l) {
      G = new Array(q - U);
      for (let Y = U; Y < q; Y++) {
        const he = Y * d + m;
        D = new Array(t);
        for (let X = 0; X < t; X++)
          D[X] = r[he + X];
        G[Y - U] = D;
      }
    } else if (d === t)
      G = r.subarray(U * t + m, q * t + m);
    else {
      G = new r.constructor((q - U) * t);
      let Y = 0;
      for (let he = U; he < q; he++) {
        const X = he * d + m;
        for (let J = 0; J < t; J++)
          G[Y++] = r[X + J];
      }
    }
    return G;
  };
}
const c7 = [], Jm = [[0, 1 / 0]];
function u7(r, e) {
  if (r === Jm || (e[0] < 0 && (e[0] = 0), e[0] >= e[1]))
    return r;
  const t = [], n = r.length;
  let i = 0;
  for (let s = 0; s < n; s++) {
    const l = r[s];
    l[1] < e[0] ? (t.push(l), i = s + 1) : l[0] > e[1] ? t.push(l) : e = [Math.min(l[0], e[0]), Math.max(l[1], e[1])];
  }
  return t.splice(i, 0, e), t;
}
const h7 = {
  interpolation: {
    duration: 0,
    easing: (r) => r
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function kC(r, e) {
  if (!r)
    return null;
  Number.isFinite(r) && (r = {
    type: "interpolation",
    duration: r
  });
  const t = r.type || "interpolation";
  return {
    ...h7[t],
    ...e,
    ...r,
    type: t
  };
}
class FC extends a7 {
  constructor(e, t) {
    super(e, t, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: !0,
      needsRedraw: !1,
      layoutChanged: !1,
      updateRanges: Jm
    }), this.constant = !1, this.settings.update = t.update || (t.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(e) {
    this.state.startIndices = e;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw() {
    let {
      clearChangedFlags: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this.state.needsRedraw;
    return this.state.needsRedraw = t && !e, t;
  }
  layoutChanged() {
    return this.state.layoutChanged;
  }
  setAccessor(e) {
    var t;
    (t = this.state).layoutChanged || (t.layoutChanged = !s7(e, this.getAccessor())), super.setAccessor(e);
  }
  getUpdateTriggers() {
    const {
      accessor: e
    } = this.settings;
    return [this.id].concat(typeof e != "function" && e || []);
  }
  supportsTransition() {
    return !!this.settings.transition;
  }
  // Resolve transition settings object if transition is enabled, otherwise `null`
  getTransitionSetting(e) {
    if (!e || !this.supportsTransition())
      return null;
    const {
      accessor: t
    } = this.settings, n = this.settings.transition, i = Array.isArray(t) ? (
      // @ts-ignore
      e[t.find((s) => e[s])]
    ) : (
      // @ts-ignore
      e[t]
    );
    return kC(i, n);
  }
  setNeedsUpdate() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id, t = arguments.length > 1 ? arguments[1] : void 0;
    if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), t) {
      const {
        startRow: n = 0,
        endRow: i = 1 / 0
      } = t;
      this.state.updateRanges = u7(this.state.updateRanges, [n, i]);
    } else
      this.state.updateRanges = Jm;
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = !1, this.state.updateRanges = c7;
  }
  setNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id;
    this.state.needsRedraw = this.state.needsRedraw || e;
  }
  allocate(e) {
    const {
      state: t,
      settings: n
    } = this;
    return n.noAlloc ? !1 : n.update ? (super.allocate(e, t.updateRanges !== Jm), !0) : !1;
  }
  updateBuffer(e) {
    let {
      numInstances: t,
      data: n,
      props: i,
      context: s
    } = e;
    if (!this.needsUpdate())
      return !1;
    const {
      state: {
        updateRanges: l
      },
      settings: {
        update: o,
        noAlloc: d
      }
    } = this;
    let m = !0;
    if (o) {
      for (const [b, T] of l)
        o.call(s, this, {
          data: n,
          startRow: b,
          endRow: T,
          props: i,
          numInstances: t
        });
      if (this.value) if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
        this.setData({
          value: this.value,
          constant: this.constant
        }), this.constant = !1;
      else
        for (const [b, T] of l) {
          const M = Number.isFinite(b) ? this.getVertexOffset(b) : 0, E = Number.isFinite(T) ? this.getVertexOffset(T) : d || !Number.isFinite(t) ? this.value.length : t * this.size;
          super.updateSubBuffer({
            startOffset: M,
            endOffset: E
          });
        }
      this._checkAttributeArray();
    } else
      m = !1;
    return this.clearNeedsUpdate(), this.setNeedsRedraw(), m;
  }
  // Use generic value
  // Returns true if successful
  setConstantValue(e) {
    return e === void 0 || typeof e == "function" ? !1 : (this.setData({
      constant: !0,
      value: e
    }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0);
  }
  // Use external buffer
  // Returns true if successful
  // eslint-disable-next-line max-statements
  setExternalBuffer(e) {
    const {
      state: t
    } = this;
    return e ? (this.clearNeedsUpdate(), t.lastExternalBuffer === e || (t.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (t.lastExternalBuffer = null, !1);
  }
  // Binary value is a typed array packed from mapping the source data with the accessor
  // If the returned value from the accessor is the same as the attribute value, set it directly
  // Otherwise use the auto updater for transform/normalization
  setBinaryValue(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const {
      state: n,
      settings: i
    } = this;
    if (!e)
      return n.binaryValue = null, n.binaryAccessor = null, !1;
    if (i.noAlloc)
      return !1;
    if (n.binaryValue === e)
      return this.clearNeedsUpdate(), !0;
    if (n.binaryValue = e, this.setNeedsRedraw(), i.transform || t !== this.startIndices) {
      ArrayBuffer.isView(e) && (e = {
        value: e
      });
      const l = e;
      Xs(ArrayBuffer.isView(l.value), `invalid ${i.accessor}`);
      const o = !!l.size && l.size !== this.size;
      return n.binaryAccessor = l7(l.value, {
        size: l.size || this.size,
        stride: l.stride,
        offset: l.offset,
        startIndices: t,
        nested: o
      }), !1;
    }
    return this.clearNeedsUpdate(), this.setData(e), !0;
  }
  getVertexOffset(e) {
    const {
      startIndices: t
    } = this;
    return (t ? e < t.length ? t[e] : this.numInstances : e) * this.size;
  }
  getValue() {
    const e = this.settings.shaderAttributes, t = super.getValue();
    if (!e)
      return t;
    for (const n in e)
      Object.assign(t, super.getValue(n, e[n]));
    return t;
  }
  /** Generate WebGPU-style buffer layout descriptor from this attribute */
  getBufferLayout(e) {
    this.state.layoutChanged = !1;
    const t = this.settings.shaderAttributes, n = super._getBufferLayout(), {
      stepMode: i
    } = this.settings;
    if (i === "dynamic" ? n.stepMode = e ? e.isInstanced ? "instance" : "vertex" : "instance" : n.stepMode = i ?? "vertex", !t)
      return n;
    for (const s in t) {
      const l = super._getBufferLayout(s, t[s]);
      n.attributes.push(...l.attributes);
    }
    return n;
  }
  /* eslint-disable max-depth, max-statements */
  _autoUpdater(e, t) {
    let {
      data: n,
      startRow: i,
      endRow: s,
      props: l,
      numInstances: o
    } = t;
    if (e.constant)
      return;
    const {
      settings: d,
      state: m,
      value: b,
      size: T,
      startIndices: M
    } = e, {
      accessor: E,
      transform: D
    } = d, U = m.binaryAccessor || // @ts-ignore
    (typeof E == "function" ? E : l[E]);
    Xs(typeof U == "function", `accessor "${E}" is not a function`);
    let q = e.getVertexOffset(i);
    const {
      iterable: G,
      objectInfo: Y
    } = NC(n, i, s);
    for (const he of G) {
      Y.index++;
      let X = U(he, Y);
      if (D && (X = D.call(this, X)), M) {
        const J = (Y.index < M.length - 1 ? M[Y.index + 1] : o) - M[Y.index];
        if (X && Array.isArray(X[0])) {
          let ie = q;
          for (const ye of X)
            e._normalizeValue(ye, b, ie), ie += T;
        } else X && X.length > T ? b.set(X, q) : (e._normalizeValue(X, Y.target, 0), S8({
          target: b,
          source: Y.target,
          start: q,
          count: J
        }));
        q += J * T;
      } else
        e._normalizeValue(X, b, q), q += T;
    }
  }
  /* eslint-enable max-depth, max-statements */
  // Validate deck.gl level fields
  _validateAttributeUpdaters() {
    const {
      settings: e
    } = this;
    if (!(e.noAlloc || typeof e.update == "function"))
      throw new Error(`Attribute ${this.id} missing update or accessor`);
  }
  // check that the first few elements of the attribute are reasonable
  /* eslint-disable no-fallthrough */
  _checkAttributeArray() {
    const {
      value: e
    } = this, t = Math.min(4, this.size);
    if (e && e.length >= t) {
      let n = !0;
      switch (t) {
        case 4:
          n = n && Number.isFinite(e[3]);
        case 3:
          n = n && Number.isFinite(e[2]);
        case 2:
          n = n && Number.isFinite(e[1]);
        case 1:
          n = n && Number.isFinite(e[0]);
          break;
        default:
          n = !1;
      }
      if (!n)
        throw new Error(`Illegal attribute generated for ${this.id}`);
    }
  }
}
function db(r) {
  const {
    source: e,
    target: t,
    start: n = 0,
    size: i,
    getData: s
  } = r, l = r.end || t.length, o = e.length, d = l - n;
  if (o > d) {
    t.set(e.subarray(0, d), n);
    return;
  }
  if (t.set(e, n), !s)
    return;
  let m = o;
  for (; m < d; ) {
    const b = s(m, e);
    for (let T = 0; T < i; T++)
      t[n + m] = b[T] || 0, m++;
  }
}
function f7(r) {
  let {
    source: e,
    target: t,
    size: n,
    getData: i,
    sourceStartIndices: s,
    targetStartIndices: l
  } = r;
  if (!s || !l)
    return db({
      source: e,
      target: t,
      size: n,
      getData: i
    }), t;
  let o = 0, d = 0;
  const m = i && ((T, M) => i(T + d, M)), b = Math.min(s.length, l.length);
  for (let T = 1; T < b; T++) {
    const M = s[T] * n, E = l[T] * n;
    db({
      source: e.subarray(o, M),
      target: t,
      start: d,
      end: E,
      size: n,
      getData: m
    }), o = M, d = E;
  }
  return d < t.length && db({
    // @ts-ignore
    source: [],
    target: t,
    start: d,
    size: n,
    getData: m
  }), t;
}
function d7(r) {
  const {
    device: e,
    settings: t,
    value: n
  } = r, i = new FC(e, t);
  return i.setData({
    value: n instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
    normalized: t.normalized
  }), i;
}
function UC(r) {
  switch (r) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error(`No defined attribute type for size "${r}"`);
  }
}
function zC(r) {
  switch (r) {
    case 1:
      return "float32";
    case 2:
      return "float32x2";
    case 3:
      return "float32x3";
    case 4:
      return "float32x4";
    default:
      throw new Error("invalid type size");
  }
}
function jC(r) {
  r.push(r.shift());
}
function p7(r, e) {
  const {
    doublePrecision: t,
    settings: n,
    value: i,
    size: s
  } = r, l = t && i instanceof Float64Array ? 2 : 1;
  let o = 0;
  const {
    shaderAttributes: d
  } = r.settings;
  if (d)
    for (const m of Object.values(d))
      o = Math.max(o, m.vertexOffset ?? 0);
  return (n.noAlloc ? i.length : (e + o) * s) * l;
}
function VC(r) {
  let {
    device: e,
    source: t,
    target: n
  } = r;
  return (!n || n.byteLength < t.byteLength) && (n == null || n.destroy(), n = e.createBuffer({
    byteLength: t.byteLength,
    usage: t.usage
  })), n;
}
function qC(r) {
  let {
    device: e,
    buffer: t,
    attribute: n,
    fromLength: i,
    toLength: s,
    fromStartIndices: l,
    getData: o = (X) => X
  } = r;
  const d = n.doublePrecision && n.value instanceof Float64Array ? 2 : 1, m = n.size * d, b = n.byteOffset, T = n.settings.bytesPerElement < 4 ? b / n.settings.bytesPerElement * 4 : b, M = n.startIndices, E = l && M, D = n.isConstant;
  if (!E && t && i >= s)
    return t;
  const U = n.value instanceof Float64Array ? Float32Array : n.value.constructor, q = D ? n.value : (
    // TODO(v9.1): Avoid non-portable synchronous reads.
    new U(n.getBuffer().readSyncWebGL(b, s * U.BYTES_PER_ELEMENT).buffer)
  );
  if (n.settings.normalized && !D) {
    const X = o;
    o = (J, ie) => n.normalizeConstant(X(J, ie));
  }
  const G = D ? (X, J) => o(q, J) : (X, J) => o(q.subarray(X + b, X + b + m), J), Y = t ? new Float32Array(t.readSyncWebGL(T, i * 4).buffer) : new Float32Array(0), he = new Float32Array(s);
  return f7({
    source: Y,
    target: he,
    sourceStartIndices: l,
    targetStartIndices: M,
    size: m,
    getData: G
  }), (!t || t.byteLength < he.byteLength + T) && (t == null || t.destroy(), t = e.createBuffer({
    byteLength: he.byteLength + T,
    usage: 35050
  })), t.write(he, T), t;
}
class GC {
  constructor(e) {
    let {
      device: t,
      attribute: n,
      timeline: i
    } = e;
    this.buffers = [], this.currentLength = 0, this.device = t, this.transition = new wy(i), this.attribute = n, this.attributeInTransition = d7(n), this.currentStartIndices = n.startIndices;
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1 / 0;
    this.settings = e, this.currentStartIndices = this.attribute.startIndices, this.currentLength = p7(this.attribute, t), this.transition.start({
      ...e,
      duration: n
    });
  }
  update() {
    const e = this.transition.update();
    return e && this.onUpdate(), e;
  }
  setBuffer(e) {
    this.attributeInTransition.setData({
      buffer: e,
      normalized: this.attribute.settings.normalized,
      // Retain placeholder value to generate correct shader layout
      value: this.attributeInTransition.value
    });
  }
  cancel() {
    this.transition.cancel();
  }
  delete() {
    this.cancel();
    for (const e of this.buffers)
      e.destroy();
    this.buffers.length = 0;
  }
}
class g7 extends GC {
  constructor(e) {
    let {
      device: t,
      attribute: n,
      timeline: i
    } = e;
    super({
      device: t,
      attribute: n,
      timeline: i
    }), this.type = "interpolation", this.transform = b7(t, n);
  }
  start(e, t) {
    const n = this.currentLength, i = this.currentStartIndices;
    if (super.start(e, t, e.duration), e.duration <= 0) {
      this.transition.cancel();
      return;
    }
    const {
      buffers: s,
      attribute: l
    } = this;
    jC(s), s[0] = qC({
      device: this.device,
      buffer: s[0],
      attribute: l,
      fromLength: n,
      toLength: this.currentLength,
      fromStartIndices: i,
      getData: e.enter
    }), s[1] = VC({
      device: this.device,
      source: s[0],
      target: s[1]
    }), this.setBuffer(s[1]);
    const {
      transform: o
    } = this, d = o.model;
    let m = Math.floor(this.currentLength / l.size);
    $C(l) && (m /= 2), d.setVertexCount(m), l.isConstant ? (d.setAttributes({
      aFrom: s[0]
    }), d.setConstantAttributes({
      aTo: l.value
    })) : d.setAttributes({
      aFrom: s[0],
      aTo: l.getBuffer()
    }), o.transformFeedback.setBuffers({
      vCurrent: s[1]
    });
  }
  onUpdate() {
    const {
      duration: e,
      easing: t
    } = this.settings, {
      time: n
    } = this.transition;
    let i = n / e;
    t && (i = t(i));
    const {
      model: s
    } = this.transform, l = {
      time: i
    };
    s.shaderInputs.setProps({
      interpolation: l
    }), this.transform.run({
      discard: !0
    });
  }
  delete() {
    super.delete(), this.transform.destroy();
  }
}
const m7 = `uniform interpolationUniforms {
  float time;
} interpolation;
`, qT = {
  name: "interpolation",
  vs: m7,
  uniformTypes: {
    time: "f32"
  }
}, _7 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`, y7 = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
function $C(r) {
  return r.doublePrecision && r.value instanceof Float64Array;
}
function b7(r, e) {
  const t = e.size, n = UC(t), i = zC(t), s = e.getBufferLayout();
  return $C(e) ? new _g(r, {
    vs: y7,
    bufferLayout: [{
      name: "aFrom",
      byteStride: 8 * t,
      attributes: [{
        attribute: "aFrom",
        format: i,
        byteOffset: 0
      }, {
        attribute: "aFrom64Low",
        format: i,
        byteOffset: 4 * t
      }]
    }, {
      name: "aTo",
      byteStride: 8 * t,
      attributes: [{
        attribute: "aTo",
        format: i,
        byteOffset: 0
      }, {
        attribute: "aTo64Low",
        format: i,
        byteOffset: 4 * t
      }]
    }],
    // @ts-expect-error fp64 module only sets ONE uniform via defaultUniforms
    modules: [OD, qT],
    defines: {
      ATTRIBUTE_TYPE: n,
      ATTRIBUTE_SIZE: t
    },
    // Default uniforms are not set without this
    moduleSettings: {},
    varyings: ["vCurrent", "vCurrent64Low"],
    bufferMode: 35980,
    disableWarnings: !0
  }) : new _g(r, {
    vs: _7,
    bufferLayout: [{
      name: "aFrom",
      format: i
    }, {
      name: "aTo",
      format: s.attributes[0].format
    }],
    modules: [qT],
    defines: {
      ATTRIBUTE_TYPE: n
    },
    varyings: ["vCurrent"],
    // TODO investigate why this is needed
    disableWarnings: !0
  });
}
class v7 extends GC {
  constructor(e) {
    let {
      device: t,
      attribute: n,
      timeline: i
    } = e;
    super({
      device: t,
      attribute: n,
      timeline: i
    }), this.type = "spring", this.texture = E7(t), this.framebuffer = C7(t, this.texture), this.transform = S7(t, n);
  }
  start(e, t) {
    const n = this.currentLength, i = this.currentStartIndices;
    super.start(e, t);
    const {
      buffers: s,
      attribute: l
    } = this;
    for (let d = 0; d < 2; d++)
      s[d] = qC({
        device: this.device,
        buffer: s[d],
        attribute: l,
        fromLength: n,
        toLength: this.currentLength,
        fromStartIndices: i,
        getData: e.enter
      });
    s[2] = VC({
      device: this.device,
      source: s[0],
      target: s[2]
    }), this.setBuffer(s[1]);
    const {
      model: o
    } = this.transform;
    o.setVertexCount(Math.floor(this.currentLength / l.size)), l.isConstant ? o.setConstantAttributes({
      aTo: l.value
    }) : o.setAttributes({
      aTo: l.getBuffer()
    });
  }
  onUpdate() {
    const {
      buffers: e,
      transform: t,
      framebuffer: n,
      transition: i
    } = this, s = this.settings;
    t.model.setAttributes({
      aPrev: e[0],
      aCur: e[1]
    }), t.transformFeedback.setBuffers({
      vNext: e[2]
    });
    const l = {
      stiffness: s.stiffness,
      damping: s.damping
    };
    t.model.shaderInputs.setProps({
      spring: l
    }), t.run({
      framebuffer: n,
      discard: !1,
      parameters: {
        viewport: [0, 0, 1, 1]
      },
      clearColor: [0, 0, 0, 0]
    }), jC(e), this.setBuffer(e[1]), this.device.readPixelsToArrayWebGL(n)[0] > 0 || i.end();
  }
  delete() {
    super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy();
  }
}
const x7 = `uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`, w7 = {
  name: "spring",
  vs: x7,
  uniformTypes: {
    damping: "f32",
    stiffness: "f32"
  }
}, A7 = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`, T7 = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
function S7(r, e) {
  const t = UC(e.size), n = zC(e.size);
  return new _g(r, {
    vs: A7,
    fs: T7,
    bufferLayout: [{
      name: "aPrev",
      format: n
    }, {
      name: "aCur",
      format: n
    }, {
      name: "aTo",
      format: e.getBufferLayout().attributes[0].format
    }],
    varyings: ["vNext"],
    modules: [w7],
    defines: {
      ATTRIBUTE_TYPE: t
    },
    parameters: {
      depthCompare: "always",
      blendColorOperation: "max",
      blendColorSrcFactor: "one",
      blendColorDstFactor: "one",
      blendAlphaOperation: "max",
      blendAlphaSrcFactor: "one",
      blendAlphaDstFactor: "one"
    }
  });
}
function E7(r) {
  return r.createTexture({
    data: new Uint8Array(4),
    format: "rgba8unorm",
    mipmaps: !1,
    width: 1,
    height: 1
  });
}
function C7(r, e) {
  return r.createFramebuffer({
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    colorAttachments: [e]
  });
}
const I7 = {
  interpolation: g7,
  spring: v7
};
class M7 {
  constructor(e, t) {
    let {
      id: n,
      timeline: i
    } = t;
    if (!e) throw new Error("AttributeTransitionManager is constructed without device");
    this.id = n, this.device = e, this.timeline = i, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1;
  }
  finalize() {
    for (const e in this.transitions)
      this._removeTransition(e);
  }
  /* Public methods */
  // Called when attribute manager updates
  // Check the latest attributes for updates.
  update(e) {
    let {
      attributes: t,
      transitions: n,
      numInstances: i
    } = e;
    this.numInstances = i || 1;
    for (const s in t) {
      const l = t[s], o = l.getTransitionSetting(n);
      o && this._updateAttribute(s, l, o);
    }
    for (const s in this.transitions) {
      const l = t[s];
      (!l || !l.getTransitionSetting(n)) && this._removeTransition(s);
    }
  }
  // Returns `true` if attribute is transition-enabled
  hasAttribute(e) {
    const t = this.transitions[e];
    return t && t.inProgress;
  }
  // Get all the animated attributes
  getAttributes() {
    const e = {};
    for (const t in this.transitions) {
      const n = this.transitions[t];
      n.inProgress && (e[t] = n.attributeInTransition);
    }
    return e;
  }
  /* eslint-disable max-statements */
  // Called every render cycle, run transform feedback
  // Returns `true` if anything changes
  run() {
    if (this.numInstances === 0)
      return !1;
    for (const t in this.transitions)
      this.transitions[t].update() && (this.needsRedraw = !0);
    const e = this.needsRedraw;
    return this.needsRedraw = !1, e;
  }
  /* eslint-enable max-statements */
  /* Private methods */
  _removeTransition(e) {
    this.transitions[e].delete(), delete this.transitions[e];
  }
  // Check an attributes for updates
  // Returns a transition object if a new transition is triggered.
  _updateAttribute(e, t, n) {
    const i = this.transitions[e];
    let s = !i || i.type !== n.type;
    if (s) {
      i && this._removeTransition(e);
      const l = I7[n.type];
      l ? this.transitions[e] = new l({
        attribute: t,
        timeline: this.timeline,
        device: this.device
      }) : (qn.error(`unsupported transition type '${n.type}'`)(), s = !1);
    }
    (s || t.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(n, this.numInstances));
  }
}
const GT = "attributeManager.invalidate", P7 = "attributeManager.updateStart", R7 = "attributeManager.updateEnd", B7 = "attribute.updateStart", L7 = "attribute.allocate", O7 = "attribute.updateEnd";
class N7 {
  constructor(e) {
    let {
      id: t = "attribute-manager",
      stats: n,
      timeline: i
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.mergeBoundsMemoized = Pg(XF), this.id = t, this.device = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = n, this.attributeTransitionManager = new M7(e, {
      id: `${t}-transitions`,
      timeline: i
    }), Object.seal(this);
  }
  finalize() {
    for (const e in this.attributes)
      this.attributes[e].delete();
    this.attributeTransitionManager.finalize();
  }
  // Returns the redraw flag, optionally clearing it.
  // Redraw flag will be set if any attributes attributes changed since
  // flag was last cleared.
  //
  // @param {String} [clearRedrawFlags=false] - whether to clear the flag
  // @return {false|String} - reason a redraw is needed.
  getNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this.needsRedraw;
    return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, t && this.id;
  }
  // Sets the redraw flag.
  // @param {Boolean} redraw=true
  setNeedsRedraw() {
    this.needsRedraw = !0;
  }
  // Adds attributes
  add(e) {
    this._add(e);
  }
  // Adds attributes
  addInstanced(e) {
    this._add(e, {
      stepMode: "instance"
    });
  }
  /**
   * Removes attributes
   * Takes an array of attribute names and delete them from
   * the attribute map if they exists
   *
   * @example
   * attributeManager.remove(['position']);
   *
   * @param {Object} attributeNameArray - attribute name array (see above)
   */
  remove(e) {
    for (const t of e)
      this.attributes[t] !== void 0 && (this.attributes[t].delete(), delete this.attributes[t]);
  }
  // Marks an attribute for update
  invalidate(e, t) {
    const n = this._invalidateTrigger(e, t);
    Vo(GT, this, e, n);
  }
  invalidateAll(e) {
    for (const t in this.attributes)
      this.attributes[t].setNeedsUpdate(t, e);
    Vo(GT, this, "all");
  }
  // Ensure all attribute buffers are updated from props or data.
  // eslint-disable-next-line complexity
  update(e) {
    let {
      data: t,
      numInstances: n,
      startIndices: i = null,
      transitions: s,
      props: l = {},
      buffers: o = {},
      context: d = {}
    } = e, m = !1;
    Vo(P7, this), this.stats && this.stats.get("Update Attributes").timeStart();
    for (const b in this.attributes) {
      const T = this.attributes[b], M = T.settings.accessor;
      T.startIndices = i, T.numInstances = n, l[b] && qn.removed(`props.${b}`, `data.attributes.${b}`)(), T.setExternalBuffer(o[b]) || T.setBinaryValue(typeof M == "string" ? o[M] : void 0, t.startIndices) || typeof M == "string" && !o[M] && T.setConstantValue(l[M]) || T.needsUpdate() && (m = !0, this._updateAttribute({
        attribute: T,
        numInstances: n,
        data: t,
        props: l,
        context: d
      })), this.needsRedraw = this.needsRedraw || T.needsRedraw();
    }
    m && Vo(R7, this, n), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances: n,
      transitions: s
    });
  }
  // Update attribute transition to the current timestamp
  // Returns `true` if any transition is in progress
  updateTransition() {
    const {
      attributeTransitionManager: e
    } = this, t = e.run();
    return this.needsRedraw = this.needsRedraw || t, t;
  }
  /**
   * Returns all attribute descriptors
   * Note: Format matches luma.gl Model/Program.setAttributes()
   * @return {Object} attributes - descriptors
   */
  getAttributes() {
    return {
      ...this.attributes,
      ...this.attributeTransitionManager.getAttributes()
    };
  }
  /**
   * Computes the spatial bounds of a given set of attributes
   */
  getBounds(e) {
    const t = e.map((n) => {
      var i;
      return (i = this.attributes[n]) == null ? void 0 : i.getBounds();
    });
    return this.mergeBoundsMemoized(t);
  }
  /**
   * Returns changed attribute descriptors
   * This indicates which WebGLBuffers need to be updated
   * @return {Object} attributes - descriptors
   */
  getChangedAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearChangedFlags: !1
    };
    const {
      attributes: t,
      attributeTransitionManager: n
    } = this, i = {
      ...n.getAttributes()
    };
    for (const s in t) {
      const l = t[s];
      l.needsRedraw(e) && !n.hasAttribute(s) && (i[s] = l);
    }
    return i;
  }
  /** Generate WebGPU-style buffer layout descriptors from all attributes */
  getBufferLayouts(e) {
    return Object.values(this.getAttributes()).map((t) => t.getBufferLayout(e));
  }
  // PRIVATE METHODS
  /** Register new attributes */
  _add(e, t) {
    for (const n in e) {
      const i = e[n], s = {
        ...i,
        id: n,
        size: i.isIndexed && 1 || i.size || 1,
        ...t
      };
      this.attributes[n] = new FC(this.device, s);
    }
    this._mapUpdateTriggersToAttributes();
  }
  // build updateTrigger name to attribute name mapping
  _mapUpdateTriggersToAttributes() {
    const e = {};
    for (const t in this.attributes)
      this.attributes[t].getUpdateTriggers().forEach((i) => {
        e[i] || (e[i] = []), e[i].push(t);
      });
    this.updateTriggers = e;
  }
  _invalidateTrigger(e, t) {
    const {
      attributes: n,
      updateTriggers: i
    } = this, s = i[e];
    return s && s.forEach((l) => {
      const o = n[l];
      o && o.setNeedsUpdate(o.id, t);
    }), s;
  }
  _updateAttribute(e) {
    const {
      attribute: t,
      numInstances: n
    } = e;
    if (Vo(B7, t), t.constant) {
      t.setConstantValue(t.value);
      return;
    }
    t.allocate(n) && Vo(L7, t, n), t.updateBuffer(e) && (this.needsRedraw = !0, Vo(O7, t, n));
  }
}
class D7 extends wy {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const {
      time: e,
      settings: {
        fromValue: t,
        toValue: n,
        duration: i,
        easing: s
      }
    } = this, l = s(e / i);
    this._value = N_(t, n, l);
  }
}
const $T = 1e-5;
function HT(r, e, t, n, i) {
  const s = e - r, o = (t - e) * i, d = -s * n;
  return o + d + s + e;
}
function k7(r, e, t, n, i) {
  if (Array.isArray(t)) {
    const s = [];
    for (let l = 0; l < t.length; l++)
      s[l] = HT(r[l], e[l], t[l], n, i);
    return s;
  }
  return HT(r, e, t, n, i);
}
function WT(r, e) {
  if (Array.isArray(r)) {
    let t = 0;
    for (let n = 0; n < r.length; n++) {
      const i = r[n] - e[n];
      t += i * i;
    }
    return Math.sqrt(t);
  }
  return Math.abs(r - e);
}
class F7 extends wy {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const {
      fromValue: e,
      toValue: t,
      damping: n,
      stiffness: i
    } = this.settings, {
      _prevValue: s = e,
      _currValue: l = e
    } = this;
    let o = k7(s, l, t, n, i);
    const d = WT(o, t), m = WT(o, l);
    d < $T && m < $T && (o = t, this.end()), this._prevValue = l, this._currValue = o;
  }
}
const U7 = {
  interpolation: D7,
  spring: F7
};
class z7 {
  constructor(e) {
    this.transitions = /* @__PURE__ */ new Map(), this.timeline = e;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(e, t, n, i) {
    const {
      transitions: s
    } = this;
    if (s.has(e)) {
      const d = s.get(e), {
        value: m = d.settings.fromValue
      } = d;
      t = m, this.remove(e);
    }
    if (i = kC(i), !i)
      return;
    const l = U7[i.type];
    if (!l) {
      qn.error(`unsupported transition type '${i.type}'`)();
      return;
    }
    const o = new l(this.timeline);
    o.start({
      ...i,
      fromValue: t,
      toValue: n
    }), s.set(e, o);
  }
  remove(e) {
    const {
      transitions: t
    } = this;
    t.has(e) && (t.get(e).cancel(), t.delete(e));
  }
  update() {
    const e = {};
    for (const [t, n] of this.transitions)
      n.update(), e[t] = n.value, n.inProgress || this.remove(t);
    return e;
  }
  clear() {
    for (const e of this.transitions.keys())
      this.remove(e);
  }
}
function j7(r) {
  const e = r[Ih];
  for (const t in e) {
    const n = e[t], {
      validate: i
    } = n;
    if (i && !i(r[t], n))
      throw new Error(`Invalid prop ${t}: ${r[t]}`);
  }
}
function V7(r, e) {
  const t = HC({
    newProps: r,
    oldProps: e,
    propTypes: r[Ih],
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  }), n = G7(r, e);
  let i = !1;
  return n || (i = $7(r, e)), {
    dataChanged: n,
    propsChanged: t,
    updateTriggersChanged: i,
    extensionsChanged: H7(r, e),
    transitionsChanged: q7(r, e)
  };
}
function q7(r, e) {
  if (!r.transitions)
    return !1;
  const t = {}, n = r[Ih];
  let i = !1;
  for (const s in r.transitions) {
    const l = n[s], o = l && l.type;
    (o === "number" || o === "color" || o === "array") && tv(r[s], e[s], l) && (t[s] = !0, i = !0);
  }
  return i ? t : !1;
}
function HC(r) {
  let {
    newProps: e,
    oldProps: t,
    ignoreProps: n = {},
    propTypes: i = {},
    triggerName: s = "props"
  } = r;
  if (t === e)
    return !1;
  if (typeof e != "object" || e === null)
    return `${s} changed shallowly`;
  if (typeof t != "object" || t === null)
    return `${s} changed shallowly`;
  for (const l of Object.keys(e))
    if (!(l in n)) {
      if (!(l in t))
        return `${s}.${l} added`;
      const o = tv(e[l], t[l], i[l]);
      if (o)
        return `${s}.${l} ${o}`;
    }
  for (const l of Object.keys(t))
    if (!(l in n)) {
      if (!(l in e))
        return `${s}.${l} dropped`;
      if (!Object.hasOwnProperty.call(e, l)) {
        const o = tv(e[l], t[l], i[l]);
        if (o)
          return `${s}.${l} ${o}`;
      }
    }
  return !1;
}
function tv(r, e, t) {
  let n = t && t.equal;
  return n && !n(r, e, t) || !n && (n = r && e && r.equals, n && !n.call(r, e)) ? "changed deeply" : !n && e !== r ? "changed shallowly" : null;
}
function G7(r, e) {
  if (e === null)
    return "oldProps is null, initial diff";
  let t = !1;
  const {
    dataComparator: n,
    _dataDiff: i
  } = r;
  return n ? n(r.data, e.data) || (t = "Data comparator detected a change") : r.data !== e.data && (t = "A new data container was supplied"), t && i && (t = i(r.data, e.data) || t), t;
}
function $7(r, e) {
  if (e === null)
    return {
      all: !0
    };
  if ("all" in r.updateTriggers && XT(r, e, "all"))
    return {
      all: !0
    };
  const t = {};
  let n = !1;
  for (const i in r.updateTriggers)
    i !== "all" && XT(r, e, i) && (t[i] = !0, n = !0);
  return n ? t : !1;
}
function H7(r, e) {
  if (e === null)
    return !0;
  const t = e.extensions, {
    extensions: n
  } = r;
  if (n === t)
    return !1;
  if (!t || !n || n.length !== t.length)
    return !0;
  for (let i = 0; i < n.length; i++)
    if (!n[i].equals(t[i]))
      return !0;
  return !1;
}
function XT(r, e, t) {
  let n = r.updateTriggers[t];
  n = n ?? {};
  let i = e.updateTriggers[t];
  return i = i ?? {}, HC({
    oldProps: i,
    newProps: n,
    triggerName: t
  });
}
const W7 = "count(): argument not an object", X7 = "count(): argument not a container";
function Z7(r) {
  if (!K7(r))
    throw new Error(W7);
  if (typeof r.count == "function")
    return r.count();
  if (Number.isFinite(r.size))
    return r.size;
  if (Number.isFinite(r.length))
    return r.length;
  if (Y7(r))
    return Object.keys(r).length;
  throw new Error(X7);
}
function Y7(r) {
  return r !== null && typeof r == "object" && r.constructor === Object;
}
function K7(r) {
  return r !== null && typeof r == "object";
}
function ZT(r, e) {
  if (!e)
    return r;
  const t = {
    ...r,
    ...e
  };
  if ("defines" in e && (t.defines = {
    ...r.defines,
    ...e.defines
  }), "modules" in e && (t.modules = (r.modules || []).concat(e.modules), e.modules.some((n) => n.name === "project64"))) {
    const n = t.modules.findIndex((i) => i.name === "project32");
    n >= 0 && t.modules.splice(n, 1);
  }
  if ("inject" in e)
    if (!r.inject)
      t.inject = e.inject;
    else {
      const n = {
        ...r.inject
      };
      for (const i in e.inject)
        n[i] = (n[i] || "") + e.inject[i];
      t.inject = n;
    }
  return t;
}
const J7 = {
  minFilter: "linear",
  mipmapFilter: "linear",
  magFilter: "linear",
  addressModeU: "clamp-to-edge",
  addressModeV: "clamp-to-edge"
}, rv = {};
function Q7(r, e, t, n) {
  if (t instanceof Wi)
    return t;
  t.constructor && t.constructor.name !== "Object" && (t = {
    data: t
  });
  let i = null;
  t.compressed && (i = {
    minFilter: "linear",
    mipmapFilter: t.data.length > 1 ? "nearest" : "linear"
  });
  const s = e.createTexture({
    ...t,
    sampler: {
      ...J7,
      ...i,
      ...n
    },
    mipmaps: !0
  });
  return rv[s.id] = r, s;
}
function e9(r, e) {
  !e || !(e instanceof Wi) || rv[e.id] === r && (e.delete(), delete rv[e.id]);
}
const t9 = {
  boolean: {
    validate(r, e) {
      return !0;
    },
    equal(r, e, t) {
      return !!r == !!e;
    }
  },
  number: {
    validate(r, e) {
      return Number.isFinite(r) && (!("max" in e) || r <= e.max) && (!("min" in e) || r >= e.min);
    }
  },
  color: {
    validate(r, e) {
      return e.optional && !r || nv(r) && (r.length === 3 || r.length === 4);
    },
    equal(r, e, t) {
      return Tc(r, e, 1);
    }
  },
  accessor: {
    validate(r, e) {
      const t = q_(r);
      return t === "function" || t === q_(e.value);
    },
    equal(r, e, t) {
      return typeof e == "function" ? !0 : Tc(r, e, 1);
    }
  },
  array: {
    validate(r, e) {
      return e.optional && !r || nv(r);
    },
    equal(r, e, t) {
      const {
        compare: n
      } = t, i = Number.isInteger(n) ? n : n ? 1 : 0;
      return n ? Tc(r, e, i) : r === e;
    }
  },
  object: {
    equal(r, e, t) {
      if (t.ignore)
        return !0;
      const {
        compare: n
      } = t, i = Number.isInteger(n) ? n : n ? 1 : 0;
      return n ? Tc(r, e, i) : r === e;
    }
  },
  function: {
    validate(r, e) {
      return e.optional && !r || typeof r == "function";
    },
    equal(r, e, t) {
      return !t.compare && t.ignore !== !1 || r === e;
    }
  },
  data: {
    transform: (r, e, t) => {
      if (!r)
        return r;
      const {
        dataTransform: n
      } = t.props;
      return n ? n(r) : typeof r.shape == "string" && r.shape.endsWith("-table") && Array.isArray(r.data) ? r.data : r;
    }
  },
  image: {
    transform: (r, e, t) => {
      const n = t.context;
      return !n || !n.device ? null : Q7(t.id, n.device, r, {
        ...e.parameters,
        ...t.props.textureParameters
      });
    },
    release: (r, e, t) => {
      e9(t.id, r);
    }
  }
};
function r9(r) {
  const e = {}, t = {}, n = {};
  for (const [i, s] of Object.entries(r)) {
    const l = s == null ? void 0 : s.deprecatedFor;
    if (l)
      n[i] = Array.isArray(l) ? l : [l];
    else {
      const o = n9(i, s);
      e[i] = o, t[i] = o.value;
    }
  }
  return {
    propTypes: e,
    defaultProps: t,
    deprecatedProps: n
  };
}
function n9(r, e) {
  switch (q_(e)) {
    case "object":
      return Lp(r, e);
    case "array":
      return Lp(r, {
        type: "array",
        value: e,
        compare: !1
      });
    case "boolean":
      return Lp(r, {
        type: "boolean",
        value: e
      });
    case "number":
      return Lp(r, {
        type: "number",
        value: e
      });
    case "function":
      return Lp(r, {
        type: "function",
        value: e,
        compare: !0
      });
    default:
      return {
        name: r,
        type: "unknown",
        value: e
      };
  }
}
function Lp(r, e) {
  return "type" in e ? {
    name: r,
    ...t9[e.type],
    ...e
  } : "value" in e ? {
    name: r,
    type: q_(e.value),
    ...e
  } : {
    name: r,
    type: "object",
    value: e
  };
}
function nv(r) {
  return Array.isArray(r) || ArrayBuffer.isView(r);
}
function q_(r) {
  return nv(r) ? "array" : r === null ? "null" : typeof r;
}
function i9(r, e) {
  let t;
  for (let s = e.length - 1; s >= 0; s--) {
    const l = e[s];
    "extensions" in l && (t = l.extensions);
  }
  const n = iv(r.constructor, t), i = Object.create(n);
  i[j_] = r, i[If] = {}, i[Ah] = {};
  for (let s = 0; s < e.length; ++s) {
    const l = e[s];
    for (const o in l)
      i[o] = l[o];
  }
  return Object.freeze(i), i;
}
const s9 = "_mergedDefaultProps";
function iv(r, e) {
  if (!(r instanceof Ay.constructor)) return {};
  let t = s9;
  if (e)
    for (const i of e) {
      const s = i.constructor;
      s && (t += `:${s.extensionName || s.name}`);
    }
  const n = WC(r, t);
  return n || (r[t] = o9(r, e || []));
}
function o9(r, e) {
  if (!r.prototype)
    return null;
  const n = Object.getPrototypeOf(r), i = iv(n), s = WC(r, "defaultProps") || {}, l = r9(s), o = Object.assign(/* @__PURE__ */ Object.create(null), i, l.defaultProps), d = Object.assign(/* @__PURE__ */ Object.create(null), i == null ? void 0 : i[Ih], l.propTypes), m = Object.assign(/* @__PURE__ */ Object.create(null), i == null ? void 0 : i[lb], l.deprecatedProps);
  for (const b of e) {
    const T = iv(b.constructor);
    T && (Object.assign(o, T), Object.assign(d, T[Ih]), Object.assign(m, T[lb]));
  }
  return a9(o, r), c9(o, d), l9(o, m), o[Ih] = d, o[lb] = m, e.length === 0 && !L2(r, "_propTypes") && (r._propTypes = d), o;
}
function a9(r, e) {
  const t = h9(e);
  Object.defineProperties(r, {
    // `id` is treated specially because layer might need to override it
    id: {
      writable: !0,
      value: t
    }
  });
}
function l9(r, e) {
  for (const t in e)
    Object.defineProperty(r, t, {
      enumerable: !1,
      set(n) {
        const i = `${this.id}: ${t}`;
        for (const s of e[t])
          L2(this, s) || (this[s] = n);
        qn.deprecated(i, e[t].join("/"))();
      }
    });
}
function c9(r, e) {
  const t = {}, n = {};
  for (const i in e) {
    const s = e[i], {
      name: l,
      value: o
    } = s;
    s.async && (t[l] = o, n[l] = u9(l));
  }
  r[Pd] = t, r[If] = {}, Object.defineProperties(r, n);
}
function u9(r) {
  return {
    enumerable: !0,
    // Save the provided value for async props in a special map
    set(e) {
      typeof e == "string" || e instanceof Promise || DC(e) ? this[If][r] = e : this[Ah][r] = e;
    },
    // Only the component's state knows the true value of async prop
    get() {
      if (this[Ah]) {
        if (r in this[Ah])
          return this[Ah][r] || this[Pd][r];
        if (r in this[If]) {
          const e = this[j_] && this[j_].internalState;
          if (e && e.hasAsyncProp(r))
            return e.getAsyncProp(r) || this[Pd][r];
        }
      }
      return this[Pd][r];
    }
  };
}
function L2(r, e) {
  return Object.prototype.hasOwnProperty.call(r, e);
}
function WC(r, e) {
  return L2(r, e) && r[e];
}
function h9(r) {
  const e = r.componentName;
  return e || qn.warn(`${r.name}.componentName not specified`)(), e || r.name;
}
let f9 = 0;
class Ay {
  constructor() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    this.props = i9(this, t), this.id = this.props.id, this.count = f9++;
  }
  // clone this layer with modified props
  clone(e) {
    const {
      props: t
    } = this, n = {};
    for (const i in t[Pd])
      i in t[Ah] ? n[i] = t[Ah][i] : i in t[If] && (n[i] = t[If][i]);
    return new this.constructor({
      ...t,
      ...n,
      ...e
    });
  }
}
Ay.componentName = "Component";
Ay.defaultProps = {};
const d9 = Object.freeze({});
class p9 {
  constructor(e) {
    this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
    }, this.oldProps = null, this.oldAsyncProps = null;
  }
  finalize() {
    for (const e in this.asyncProps) {
      const t = this.asyncProps[e];
      t && t.type && t.type.release && t.type.release(t.resolvedValue, t.type, this.component);
    }
    this.asyncProps = {}, this.component = null, this.resetOldProps();
  }
  /* Layer-facing props API */
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || d9;
  }
  resetOldProps() {
    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
  }
  // Checks if a prop is overridden
  hasAsyncProp(e) {
    return e in this.asyncProps;
  }
  // Returns value of an overriden prop
  getAsyncProp(e) {
    const t = this.asyncProps[e];
    return t && t.resolvedValue;
  }
  isAsyncPropLoading(e) {
    if (e) {
      const t = this.asyncProps[e];
      return !!(t && t.pendingLoadCount > 0 && t.pendingLoadCount !== t.resolvedLoadCount);
    }
    for (const t in this.asyncProps)
      if (this.isAsyncPropLoading(t))
        return !0;
    return !1;
  }
  // Without changing the original prop value, swap out the data resolution under the hood
  reloadAsyncProp(e, t) {
    this._watchPromise(e, Promise.resolve(t));
  }
  // Updates all async/overridden props (when new props come in)
  // Checks if urls have changed, starts loading, or removes override
  setAsyncProps(e) {
    this.component = e[j_] || this.component;
    const t = e[Ah] || {}, n = e[If] || e, i = e[Pd] || {};
    for (const s in t) {
      const l = t[s];
      this._createAsyncPropData(s, i[s]), this._updateAsyncProp(s, l), t[s] = this.getAsyncProp(s);
    }
    for (const s in n) {
      const l = n[s];
      this._createAsyncPropData(s, i[s]), this._updateAsyncProp(s, l);
    }
  }
  /* Placeholder methods for subclassing */
  _fetch(e, t) {
    return null;
  }
  _onResolve(e, t) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  _onError(e, t) {
  }
  // eslint-disable-line @typescript-eslint/no-empty-function
  // Intercept strings (URLs) and Promises and activates loading and prop rewriting
  _updateAsyncProp(e, t) {
    if (this._didAsyncInputValueChange(e, t)) {
      if (typeof t == "string" && (t = this._fetch(e, t)), t instanceof Promise) {
        this._watchPromise(e, t);
        return;
      }
      if (DC(t)) {
        this._resolveAsyncIterable(e, t);
        return;
      }
      this._setPropValue(e, t);
    }
  }
  // Whenever async props are changing, we need to make a copy of oldProps
  // otherwise the prop rewriting will affect the value both in props and oldProps.
  // While the copy is relatively expensive, this only happens on load completion.
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const e in this.asyncProps)
        Object.defineProperty(this.oldAsyncProps, e, {
          enumerable: !0,
          value: this.oldProps[e]
        });
    }
  }
  // Checks if an input value actually changed (to avoid reloading/rewatching promises/urls)
  _didAsyncInputValueChange(e, t) {
    const n = this.asyncProps[e];
    return t === n.resolvedValue || t === n.lastValue ? !1 : (n.lastValue = t, !0);
  }
  // Set normal, non-async value
  _setPropValue(e, t) {
    this._freezeAsyncOldProps();
    const n = this.asyncProps[e];
    n && (t = this._postProcessValue(n, t), n.resolvedValue = t, n.pendingLoadCount++, n.resolvedLoadCount = n.pendingLoadCount);
  }
  // Set a just resolved async value, calling onAsyncPropUpdates if value changes asynchronously
  _setAsyncPropValue(e, t, n) {
    const i = this.asyncProps[e];
    i && n >= i.resolvedLoadCount && t !== void 0 && (this._freezeAsyncOldProps(), i.resolvedValue = t, i.resolvedLoadCount = n, this.onAsyncPropUpdated(e, t));
  }
  // Tracks a promise, sets the prop when loaded, handles load count
  _watchPromise(e, t) {
    const n = this.asyncProps[e];
    if (n) {
      n.pendingLoadCount++;
      const i = n.pendingLoadCount;
      t.then((s) => {
        this.component && (s = this._postProcessValue(n, s), this._setAsyncPropValue(e, s, i), this._onResolve(e, s));
      }).catch((s) => {
        this._onError(e, s);
      });
    }
  }
  async _resolveAsyncIterable(e, t) {
    if (e !== "data") {
      this._setPropValue(e, t);
      return;
    }
    const n = this.asyncProps[e];
    if (!n)
      return;
    n.pendingLoadCount++;
    const i = n.pendingLoadCount;
    let s = [], l = 0;
    for await (const o of t) {
      if (!this.component)
        return;
      const {
        dataTransform: d
      } = this.component.props;
      d ? s = d(o, s) : s = s.concat(o), Object.defineProperty(s, "__diff", {
        enumerable: !1,
        value: [{
          startRow: l,
          endRow: s.length
        }]
      }), l = s.length, this._setAsyncPropValue(e, s, i);
    }
    this._onResolve(e, s);
  }
  // Give the app a chance to post process the loaded data
  _postProcessValue(e, t) {
    const n = e.type;
    return n && this.component && (n.release && n.release(e.resolvedValue, n, this.component), n.transform) ? n.transform(t, n, this.component) : t;
  }
  // Creating an asyncProp record if needed
  _createAsyncPropData(e, t) {
    if (!this.asyncProps[e]) {
      const i = this.component && this.component.props[Ih];
      this.asyncProps[e] = {
        type: i && i[e],
        lastValue: null,
        resolvedValue: t,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class g9 extends p9 {
  constructor(e) {
    let {
      attributeManager: t,
      layer: n
    } = e;
    super(n), this.attributeManager = t, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
  }
  get layer() {
    return this.component;
  }
  /* Override base Component methods with Layer-specific handling */
  _fetch(e, t) {
    const n = this.layer, i = n == null ? void 0 : n.props.fetch;
    return i ? i(t, {
      propName: e,
      layer: n
    }) : super._fetch(e, t);
  }
  _onResolve(e, t) {
    const n = this.layer;
    if (n) {
      const i = n.props.onDataLoad;
      e === "data" && i && i(t, {
        propName: e,
        layer: n
      });
    }
  }
  _onError(e, t) {
    const n = this.layer;
    n && n.raiseError(t, `loading ${e} of ${this.layer}`);
  }
}
const m9 = "layer.changeFlag", _9 = "layer.initialize", y9 = "layer.update", b9 = "layer.finalize", v9 = "layer.matched", YT = 2 ** 24 - 1, x9 = Object.freeze([]), w9 = Pg((r) => {
  let {
    oldViewport: e,
    viewport: t
  } = r;
  return e.equals(t);
});
let cc = new Uint8ClampedArray(0);
const A9 = {
  // data: Special handling for null, see below
  data: {
    type: "data",
    value: x9,
    async: !0
  },
  dataComparator: {
    type: "function",
    value: null,
    optional: !0
  },
  _dataDiff: {
    type: "function",
    // @ts-ignore __diff is not defined on data
    value: (r) => r && r.__diff,
    optional: !0
  },
  dataTransform: {
    type: "function",
    value: null,
    optional: !0
  },
  onDataLoad: {
    type: "function",
    value: null,
    optional: !0
  },
  onError: {
    type: "function",
    value: null,
    optional: !0
  },
  fetch: {
    type: "function",
    value: (r, e) => {
      let {
        propName: t,
        layer: n,
        loaders: i,
        loadOptions: s,
        signal: l
      } = e;
      const {
        resourceManager: o
      } = n.context;
      s = s || n.getLoadOptions(), i = i || n.props.loaders, l && (s = {
        ...s,
        fetch: {
          ...s == null ? void 0 : s.fetch,
          signal: l
        }
      });
      let d = o.contains(r);
      return !d && !s && (o.add({
        resourceId: r,
        data: Ph(r, i),
        persistent: !1
      }), d = !0), d ? o.subscribe({
        resourceId: r,
        onChange: (m) => {
          var b;
          return (b = n.internalState) == null ? void 0 : b.reloadAsyncProp(t, m);
        },
        consumerId: n.id,
        requestId: t
      }) : Ph(r, i, s);
    }
  },
  updateTriggers: {},
  // Update triggers: a core change detection mechanism in deck.gl
  visible: !0,
  pickable: !1,
  opacity: {
    type: "number",
    min: 0,
    max: 1,
    value: 1
  },
  operation: "draw",
  onHover: {
    type: "function",
    value: null,
    optional: !0
  },
  onClick: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragStart: {
    type: "function",
    value: null,
    optional: !0
  },
  onDrag: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragEnd: {
    type: "function",
    value: null,
    optional: !0
  },
  coordinateSystem: Rn.DEFAULT,
  coordinateOrigin: {
    type: "array",
    value: [0, 0, 0],
    compare: !0
  },
  modelMatrix: {
    type: "array",
    value: null,
    compare: !0,
    optional: !0
  },
  wrapLongitude: !1,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: {
    type: "object",
    value: {},
    optional: !0,
    compare: 2
  },
  loadOptions: {
    type: "object",
    value: null,
    optional: !0,
    ignore: !0
  },
  transitions: null,
  extensions: [],
  loaders: {
    type: "array",
    value: [],
    optional: !0,
    ignore: !0
  },
  // Offset depth based on layer index to avoid z-fighting.
  // Negative values pull layer towards the camera
  // https://www.opengl.org/archives/resources/faq/technical/polygonoffset.htm
  getPolygonOffset: {
    type: "function",
    value: (r) => {
      let {
        layerIndex: e
      } = r;
      return [0, -e * 100];
    }
  },
  // Selection/Highlighting
  highlightedObjectIndex: null,
  autoHighlight: !1,
  highlightColor: {
    type: "accessor",
    value: [0, 0, 128, 128]
  }
};
class tp extends Ay {
  constructor() {
    super(...arguments), this.internalState = null, this.lifecycle = fd.NO_STATE, this.parent = null;
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  toString() {
    return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
  }
  // Public API for users
  /** Projects a point with current view state from the current layer's coordinate system to screen */
  project(e) {
    Xs(this.internalState);
    const t = this.internalState.viewport || this.context.viewport, n = cC(e, {
      viewport: t,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    }), [i, s, l] = sC(n, t.pixelProjectionMatrix);
    return e.length === 2 ? [i, s] : [i, s, l];
  }
  /** Unprojects a screen pixel to the current view's default coordinate system
      Note: this does not reverse `project`. */
  unproject(e) {
    return Xs(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
  }
  /** Projects a point with current view state from the current layer's coordinate system to the world space */
  projectPosition(e, t) {
    Xs(this.internalState);
    const n = this.internalState.viewport || this.context.viewport;
    return e8(e, {
      viewport: n,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...t
    });
  }
  // Public API for custom layer implementation
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !1;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return !0;
  }
  /** Updates selected state members and marks the layer for redraw */
  setState(e) {
    this.setChangeFlags({
      stateChanged: !0
    }), Object.assign(this.state, e), this.setNeedsRedraw();
  }
  /** Sets the redraw flag for this layer, will trigger a redraw next animation frame */
  setNeedsRedraw() {
    this.internalState && (this.internalState.needsRedraw = !0);
  }
  /** Mark this layer as needs a deep update */
  setNeedsUpdate() {
    this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
  }
  /** Returns true if using shader-based WGS84 longitude wrapping */
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  /** @deprecated Returns true if the layer is visible in the picking pass */
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  /** Returns an array of models used by this layer, can be overriden by layer subclass */
  getModels() {
    const e = this.state;
    return e && (e.models || e.model && [e.model]) || [];
  }
  /** Update shader input parameters */
  setShaderModuleProps() {
    for (const e of this.getModels())
      e.shaderInputs.setProps(...arguments);
  }
  /** Returns the attribute manager of this layer */
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  /** Returns the most recent layer that matched to this state
    (When reacting to an async event, this layer may no longer be the latest) */
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  /** Returns the default parse options for async props */
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const {
      coordinateSystem: e
    } = this.props;
    return e === Rn.DEFAULT || e === Rn.LNGLAT || e === Rn.CARTESIAN;
  }
  // Event handling
  onHover(e, t) {
    return this.props.onHover && this.props.onHover(e, t) || !1;
  }
  onClick(e, t) {
    return this.props.onClick && this.props.onClick(e, t) || !1;
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  // @return {Array} - a black color
  nullPickingColor() {
    return [0, 0, 0];
  }
  // Returns the picking color that doesn't match any subfeature
  // Use if some graphics do not belong to any pickable subfeature
  encodePickingColor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return t[0] = e + 1 & 255, t[1] = e + 1 >> 8 & 255, t[2] = e + 1 >> 8 >> 8 & 255, t;
  }
  // Returns the index corresponding to a picking color that doesn't match any subfeature
  // @param {Uint8Array} color - color array to be decoded
  // @return {Array} - the decoded picking color
  decodePickingColor(e) {
    Xs(e instanceof Uint8Array);
    const [t, n, i] = e;
    return t + n * 256 + i * 65536 - 1;
  }
  /** Deduces number of instances. Intention is to support:
    - Explicit setting of numInstances
    - Auto-deduction for ES6 containers that define a size member
    - Auto-deduction for Classic Arrays via the built-in length attribute
    - Auto-deduction via arrays */
  getNumInstances() {
    return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : Z7(this.props.data);
  }
  /** Buffer layout describes how many attribute values are packed for each data object
      The default (null) is one value each object.
      Some data formats (e.g. paths, polygons) have various length. Their buffer layout
      is in the form of [L0, L1, L2, ...] */
  getStartIndices() {
    return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
  }
  // Default implementation
  getBounds() {
    var e;
    return (e = this.getAttributeManager()) == null ? void 0 : e.getBounds(["positions", "instancePositions"]);
  }
  getShaders(e) {
    e = ZT(e, {
      disableWarnings: !0,
      modules: this.context.defaultShaderModules
    });
    for (const t of this.props.extensions)
      e = ZT(e, t.getShaders.call(this, t));
    return e;
  }
  /** Controls if updateState should be called. By default returns true if any prop has changed */
  shouldUpdateState(e) {
    return e.changeFlags.propsOrDataChanged;
  }
  /** Default implementation, all attributes will be invalidated and updated when data changes */
  // eslint-disable-next-line complexity
  updateState(e) {
    const t = this.getAttributeManager(), {
      dataChanged: n
    } = e.changeFlags;
    if (n && t)
      if (Array.isArray(n))
        for (const i of n)
          t.invalidateAll(i);
      else
        t.invalidateAll();
    if (t) {
      const {
        props: i
      } = e, s = this.internalState.hasPickingBuffer, l = Number.isInteger(i.highlightedObjectIndex) || i.pickable || i.extensions.some((o) => o.getNeedsPickingBuffer.call(this, o));
      if (s !== l) {
        this.internalState.hasPickingBuffer = l;
        const {
          pickingColors: o,
          instancePickingColors: d
        } = t.attributes, m = o || d;
        m && (l && m.constant && (m.constant = !1, t.invalidate(m.id)), !m.value && !l && (m.constant = !0, m.value = [0, 0, 0]));
      }
    }
  }
  /** Called once when layer is no longer matched and state will be discarded. Layers can destroy WebGL resources here. */
  finalizeState(e) {
    for (const n of this.getModels())
      n.destroy();
    const t = this.getAttributeManager();
    t && t.finalize(), this.context && this.context.resourceManager.unsubscribe({
      consumerId: this.id
    }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
  }
  // If state has a model, draw it with supplied uniforms
  draw(e) {
    for (const t of this.getModels())
      t.draw(e.renderPass);
  }
  // called to populate the info object that is passed to the event handler
  // @return null to cancel event
  getPickingInfo(e) {
    let {
      info: t,
      mode: n,
      sourceLayer: i
    } = e;
    const {
      index: s
    } = t;
    return s >= 0 && Array.isArray(this.props.data) && (t.object = this.props.data[s]), t;
  }
  // END LIFECYCLE METHODS
  // / INTERNAL METHODS - called by LayerManager, DeckRenderer and DeckPicker
  /** (Internal) Propagate an error event through the system */
  raiseError(e, t) {
    var n, i, s, l;
    t && (e = new Error(`${t}: ${e.message}`, {
      cause: e
    })), (i = (n = this.props).onError) != null && i.call(n, e) || (l = (s = this.context) == null ? void 0 : s.onError) == null || l.call(s, e, this);
  }
  /** (Internal) Checks if this layer needs redraw */
  getNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    return this._getNeedsRedraw(e);
  }
  /** (Internal) Checks if this layer needs a deep update */
  needsUpdate() {
    return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
  }
  /** Checks if this layer has ongoing uniform transition */
  hasUniformTransition() {
    var e;
    return ((e = this.internalState) == null ? void 0 : e.uniformTransitions.active) || !1;
  }
  /** Called when this layer is rendered into the given viewport */
  activateViewport(e) {
    if (!this.internalState)
      return;
    const t = this.internalState.viewport;
    this.internalState.viewport = e, (!t || !w9({
      oldViewport: t,
      viewport: e
    })) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
  }
  /** Default implementation of attribute invalidation, can be redefined */
  invalidateAttribute() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "all";
    const t = this.getAttributeManager();
    t && (e === "all" ? t.invalidateAll() : t.invalidate(e));
  }
  /** Send updated attributes to the WebGL model */
  updateAttributes(e) {
    let t = !1;
    for (const n in e)
      e[n].layoutChanged() && (t = !0);
    for (const n of this.getModels())
      this._setModelAttributes(n, e, t);
  }
  /** Recalculate any attributes if needed */
  _updateAttributes() {
    const e = this.getAttributeManager();
    if (!e)
      return;
    const t = this.props, n = this.getNumInstances(), i = this.getStartIndices();
    e.update({
      data: t.data,
      numInstances: n,
      startIndices: i,
      props: t,
      transitions: t.transitions,
      // @ts-ignore (TS2339) property attribute is not present on some acceptable data types
      buffers: t.data.attributes,
      context: this
    });
    const s = e.getChangedAttributes({
      clearChangedFlags: !0
    });
    this.updateAttributes(s);
  }
  /** Update attribute transitions. This is called in drawLayer, no model updates required. */
  _updateAttributeTransition() {
    const e = this.getAttributeManager();
    e && e.updateTransition();
  }
  /** Update uniform (prop) transitions. This is called in updateState, may result in model updates. */
  _updateUniformTransition() {
    const {
      uniformTransitions: e
    } = this.internalState;
    if (e.active) {
      const t = e.update(), n = Object.create(this.props);
      for (const i in t)
        Object.defineProperty(n, i, {
          value: t[i]
        });
      return n;
    }
    return this.props;
  }
  /** Updater for the automatically populated instancePickingColors attribute */
  calculateInstancePickingColors(e, t) {
    let {
      numInstances: n
    } = t;
    if (e.constant)
      return;
    const i = Math.floor(cc.length / 4);
    if (this.internalState.usesPickingColorCache = !0, i < n) {
      n > YT && qn.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), cc = mg.allocate(cc, n, {
        size: 4,
        copy: !0,
        maxCount: Math.max(n, YT)
      });
      const s = Math.floor(cc.length / 4), l = [0, 0, 0];
      for (let o = i; o < s; o++)
        this.encodePickingColor(o, l), cc[o * 4 + 0] = l[0], cc[o * 4 + 1] = l[1], cc[o * 4 + 2] = l[2], cc[o * 4 + 3] = 0;
    }
    e.value = cc.subarray(0, n * 4);
  }
  /** Apply changed attributes to model */
  _setModelAttributes(e, t) {
    var o;
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    if (!Object.keys(t).length)
      return;
    if (n) {
      const d = this.getAttributeManager();
      e.setBufferLayout(d.getBufferLayouts(e)), t = d.getAttributes();
    }
    const i = ((o = e.userData) == null ? void 0 : o.excludeAttributes) || {}, s = {}, l = {};
    for (const d in t) {
      if (i[d])
        continue;
      const m = t[d].getValue();
      for (const b in m) {
        const T = m[b];
        T instanceof Ss ? t[d].settings.isIndexed ? e.setIndexBuffer(T) : s[b] = T : T && (l[b] = T);
      }
    }
    e.setAttributes(s), e.setConstantAttributes(l);
  }
  /** (Internal) Sets the picking color at the specified index to null picking color. Used for multi-depth picking.
     This method may be overriden by layer implementations */
  disablePickingIndex(e) {
    const t = this.props.data;
    if (!("attributes" in t)) {
      this._disablePickingIndex(e);
      return;
    }
    const {
      pickingColors: n,
      instancePickingColors: i
    } = this.getAttributeManager().attributes, s = n || i, l = s && t.attributes && t.attributes[s.id];
    if (l && l.value) {
      const o = l.value, d = this.encodePickingColor(e);
      for (let m = 0; m < t.length; m++) {
        const b = s.getVertexOffset(m);
        o[b] === d[0] && o[b + 1] === d[1] && o[b + 2] === d[2] && this._disablePickingIndex(m);
      }
    } else
      this._disablePickingIndex(e);
  }
  // TODO - simplify subclassing interface
  _disablePickingIndex(e) {
    const {
      pickingColors: t,
      instancePickingColors: n
    } = this.getAttributeManager().attributes, i = t || n;
    if (!i)
      return;
    const s = i.getVertexOffset(e), l = i.getVertexOffset(e + 1);
    i.buffer.write(new Uint8Array(l - s), s);
  }
  /** (Internal) Re-enable all picking indices after multi-depth picking */
  restorePickingColors() {
    const {
      pickingColors: e,
      instancePickingColors: t
    } = this.getAttributeManager().attributes, n = e || t;
    n && // @ts-ignore (TS2531) this method is only called internally with internalState defined
    (this.internalState.usesPickingColorCache && n.value.buffer !== cc.buffer && (n.value = cc.subarray(0, n.value.length)), n.updateSubBuffer({
      startOffset: 0
    }));
  }
  /* eslint-disable max-statements */
  /* (Internal) Called by layer manager when a new layer is found */
  _initialize() {
    Xs(!this.internalState), Xs(Number.isFinite(this.props.coordinateSystem)), Vo(_9, this);
    const e = this._getAttributeManager();
    e && e.addInstanced({
      instancePickingColors: {
        type: "uint8",
        size: 4,
        noAlloc: !0,
        // Updaters are always called with `this` pointing to the layer
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateInstancePickingColors
      }
    }), this.internalState = new g9({
      attributeManager: e,
      layer: this
    }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
      get: () => (qn.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
    }), this.internalState.uniformTransitions = new z7(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
    for (const t of this.props.extensions)
      t.initializeState.call(this, this.context, t);
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: !0,
      extensionsChanged: !0
    }), this._update();
  }
  /** (Internal) Called by layer manager to transfer state from an old layer */
  _transferState(e) {
    Vo(v9, this, this === e);
    const {
      state: t,
      internalState: n
    } = e;
    this !== e && (this.internalState = n, this.state = t, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
  }
  /** (Internal) Called by layer manager when a new layer is added or an existing layer is matched with a new instance */
  _update() {
    const e = this.needsUpdate();
    if (Vo(y9, this, e), !e)
      return;
    const t = this.props, n = this.context, i = this.internalState, s = n.viewport, l = this._updateUniformTransition();
    i.propsInTransition = l, n.viewport = i.viewport || s, this.props = l;
    try {
      const o = this._getUpdateParams(), d = this.getModels();
      if (n.device)
        this.updateState(o);
      else
        try {
          this.updateState(o);
        } catch {
        }
      for (const b of this.props.extensions)
        b.updateState.call(this, o, b);
      this.setNeedsRedraw(), this._updateAttributes();
      const m = this.getModels()[0] !== d[0];
      this._postUpdate(o, m);
    } finally {
      n.viewport = s, this.props = t, this._clearChangeFlags(), i.needsUpdate = !1, i.resetOldProps();
    }
  }
  /* eslint-enable max-statements */
  /** (Internal) Called by manager when layer is about to be disposed
      Note: not guaranteed to be called on application shutdown */
  _finalize() {
    Vo(b9, this), this.finalizeState(this.context);
    for (const e of this.props.extensions)
      e.finalizeState.call(this, this.context, e);
  }
  // Calculates uniforms
  _drawLayer(e) {
    let {
      renderPass: t,
      shaderModuleProps: n = null,
      uniforms: i = {},
      parameters: s = {}
    } = e;
    this._updateAttributeTransition();
    const l = this.props, o = this.context;
    this.props = this.internalState.propsInTransition || l;
    try {
      n && this.setShaderModuleProps(n);
      const {
        getPolygonOffset: d
      } = this.props, m = d && d(i) || [0, 0];
      o.device instanceof Th && o.device.setParametersWebGL({
        polygonOffset: m
      });
      for (const b of this.getModels())
        b.setParameters(s);
      if (o.device instanceof Th)
        o.device.withParametersWebGL(s, () => {
          const b = {
            renderPass: t,
            shaderModuleProps: n,
            uniforms: i,
            parameters: s,
            context: o
          };
          for (const T of this.props.extensions)
            T.draw.call(this, b, T);
          this.draw(b);
        });
      else {
        const b = {
          renderPass: t,
          shaderModuleProps: n,
          uniforms: i,
          parameters: s,
          context: o
        };
        for (const T of this.props.extensions)
          T.draw.call(this, b, T);
        this.draw(b);
      }
    } finally {
      this.props = l;
    }
  }
  // Helper methods
  /** Returns the current change flags */
  getChangeFlags() {
    var e;
    return (e = this.internalState) == null ? void 0 : e.changeFlags;
  }
  /* eslint-disable complexity */
  /** Dirty some change flags, will be handled by updateLayer */
  setChangeFlags(e) {
    if (!this.internalState)
      return;
    const {
      changeFlags: t
    } = this.internalState;
    for (const i in e)
      if (e[i]) {
        let s = !1;
        switch (i) {
          case "dataChanged":
            const l = e[i], o = t[i];
            l && Array.isArray(o) && (t.dataChanged = Array.isArray(l) ? o.concat(l) : l, s = !0);
          default:
            t[i] || (t[i] = e[i], s = !0);
        }
        s && Vo(m9, this, i, e);
      }
    const n = !!(t.dataChanged || t.updateTriggersChanged || t.propsChanged || t.extensionsChanged);
    t.propsOrDataChanged = n, t.somethingChanged = n || t.viewportChanged || t.stateChanged;
  }
  /* eslint-enable complexity */
  /** Clear all changeFlags, typically after an update */
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: !1,
      propsChanged: !1,
      updateTriggersChanged: !1,
      viewportChanged: !1,
      stateChanged: !1,
      extensionsChanged: !1,
      propsOrDataChanged: !1,
      somethingChanged: !1
    };
  }
  /** Compares the layers props with old props from a matched older layer
      and extracts change flags that describe what has change so that state
      can be update correctly with minimal effort */
  _diffProps(e, t) {
    var i;
    const n = V7(e, t);
    if (n.updateTriggersChanged)
      for (const s in n.updateTriggersChanged)
        n.updateTriggersChanged[s] && this.invalidateAttribute(s);
    if (n.transitionsChanged)
      for (const s in n.transitionsChanged)
        this.internalState.uniformTransitions.add(s, t[s], e[s], (i = e.transitions) == null ? void 0 : i[s]);
    return this.setChangeFlags(n);
  }
  /** (Internal) called by layer manager to perform extra props validation (in development only) */
  validateProps() {
    j7(this.props);
  }
  /** (Internal) Called by deck picker when the hovered object changes to update the auto highlight */
  updateAutoHighlight(e) {
    this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
  }
  // May be overriden by subclasses
  // TODO - simplify subclassing interface
  /** Update picking module parameters to highlight the hovered object */
  _updateAutoHighlight(e) {
    const t = {
      // @ts-ignore
      highlightedObjectColor: e.picked ? e.color : null
    }, {
      highlightColor: n
    } = this.props;
    e.picked && typeof n == "function" && (t.highlightColor = n(e)), this.setShaderModuleProps({
      picking: t
    }), this.setNeedsRedraw();
  }
  /** Create new attribute manager */
  _getAttributeManager() {
    const e = this.context;
    return new N7(e.device, {
      id: this.props.id,
      stats: e.stats,
      timeline: e.timeline
    });
  }
  // Private methods
  /** Called after updateState to perform common tasks */
  _postUpdate(e, t) {
    const {
      props: n,
      oldProps: i
    } = e, s = this.state.model;
    s != null && s.isInstanced && s.setInstanceCount(this.getNumInstances());
    const {
      autoHighlight: l,
      highlightedObjectIndex: o,
      highlightColor: d
    } = n;
    if (t || i.autoHighlight !== l || i.highlightedObjectIndex !== o || i.highlightColor !== d) {
      const m = {};
      Array.isArray(d) && (m.highlightColor = d), (t || i.autoHighlight !== l || o !== i.highlightedObjectIndex) && (m.highlightedObjectColor = Number.isFinite(o) && o >= 0 ? this.encodePickingColor(o) : null), this.setShaderModuleProps({
        picking: m
      });
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      // @ts-ignore TS2531 this method can only be called internally with internalState assigned
      changeFlags: this.internalState.changeFlags
    };
  }
  /** Checks state of attributes and model */
  _getNeedsRedraw(e) {
    if (!this.internalState)
      return !1;
    let t = !1;
    t = t || this.internalState.needsRedraw && this.id;
    const n = this.getAttributeManager(), i = n ? n.getNeedsRedraw(e) : !1;
    if (t = t || i, t)
      for (const s of this.props.extensions)
        s.onNeedsRedraw.call(this, s);
    return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, t;
  }
  /** Callback when asyn prop is loaded */
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
  }
}
tp.defaultProps = A9;
tp.layerName = "Layer";
const T9 = "compositeLayer.renderLayers";
class XC extends tp {
  /** `true` if this layer renders other layers */
  get isComposite() {
    return !0;
  }
  /** `true` if the layer renders to screen */
  get isDrawable() {
    return !1;
  }
  /** Returns true if all async resources are loaded */
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
  }
  /** Return last rendered sub layers */
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  // initializeState is usually not needed for composite layers
  // Provide empty definition to disable check for missing definition
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  initializeState(e) {
  }
  /** Updates selected state members and marks the composite layer to need rerender */
  setState(e) {
    super.setState(e), this.setNeedsUpdate();
  }
  /** called to augment the info object that is bubbled up from a sublayer
      override Layer.getPickingInfo() because decoding / setting uniform do
      not apply to a composite layer. */
  getPickingInfo(e) {
    let {
      info: t
    } = e;
    const {
      object: n
    } = t;
    return n && n.__source && n.__source.parent && n.__source.parent.id === this.id && (t.object = n.__source.object, t.index = n.__source.index), t;
  }
  /**
   * Filters sub layers at draw time. Return true if the sub layer should be drawn.
   */
  filterSubLayer(e) {
    return !0;
  }
  /** Returns true if sub layer needs to be rendered */
  shouldRenderSubLayer(e, t) {
    return t && t.length;
  }
  /** Returns sub layer class for a specific sublayer */
  getSubLayerClass(e, t) {
    const {
      _subLayerProps: n
    } = this.props;
    return n && n[e] && n[e].type || t;
  }
  /** When casting user data into another format to pass to sublayers,
      add reference to the original object and object index */
  getSubLayerRow(e, t, n) {
    return e.__source = {
      parent: this,
      object: t,
      index: n
    }, e;
  }
  /** Some composite layers cast user data into another format before passing to sublayers
    We need to unwrap them before calling the accessor so that they see the original data
    objects */
  getSubLayerAccessor(e) {
    if (typeof e == "function") {
      const t = {
        index: -1,
        // @ts-ignore accessing resolved data
        data: this.props.data,
        target: []
      };
      return (n, i) => n && n.__source ? (t.index = n.__source.index, e(n.__source.object, t)) : e(n, i);
    }
    return e;
  }
  /** Returns sub layer props for a specific sublayer */
  // eslint-disable-next-line complexity
  getSubLayerProps() {
    var ye;
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      opacity: t,
      pickable: n,
      visible: i,
      parameters: s,
      getPolygonOffset: l,
      highlightedObjectIndex: o,
      autoHighlight: d,
      highlightColor: m,
      coordinateSystem: b,
      coordinateOrigin: T,
      wrapLongitude: M,
      positionFormat: E,
      modelMatrix: D,
      extensions: U,
      fetch: q,
      operation: G,
      _subLayerProps: Y
    } = this.props, he = {
      id: "",
      updateTriggers: {},
      opacity: t,
      pickable: n,
      visible: i,
      parameters: s,
      getPolygonOffset: l,
      highlightedObjectIndex: o,
      autoHighlight: d,
      highlightColor: m,
      coordinateSystem: b,
      coordinateOrigin: T,
      wrapLongitude: M,
      positionFormat: E,
      modelMatrix: D,
      extensions: U,
      fetch: q,
      operation: G
    }, X = Y && e.id && Y[e.id], J = X && X.updateTriggers, ie = e.id || "sublayer";
    if (X) {
      const oe = this.props[Ih], Re = e.type ? e.type._propTypes : {};
      for (const Ne in X) {
        const me = Re[Ne] || oe[Ne];
        me && me.type === "accessor" && (X[Ne] = this.getSubLayerAccessor(X[Ne]));
      }
    }
    Object.assign(
      he,
      e,
      // experimental feature that allows users to override sublayer props via parent layer prop
      X
    ), he.id = `${this.props.id}-${ie}`, he.updateTriggers = {
      all: (ye = this.props.updateTriggers) == null ? void 0 : ye.all,
      ...e.updateTriggers,
      ...J
    };
    for (const oe of U) {
      const Re = oe.getSubLayerProps.call(this, oe);
      Re && Object.assign(he, Re, {
        updateTriggers: Object.assign(he.updateTriggers, Re.updateTriggers)
      });
    }
    return he;
  }
  /** Update sub layers to highlight the hovered object */
  _updateAutoHighlight(e) {
    for (const t of this.getSubLayers())
      t.updateAutoHighlight(e);
  }
  /** Override base Layer method */
  _getAttributeManager() {
    return null;
  }
  /** (Internal) Called after an update to rerender sub layers */
  _postUpdate(e, t) {
    let n = this.internalState.subLayers;
    const i = !n || this.needsUpdate();
    if (i) {
      const s = this.renderLayers();
      n = jd(s, Boolean), this.internalState.subLayers = n;
    }
    Vo(T9, this, i, n);
    for (const s of n)
      s.parent = this;
  }
}
XC.layerName = "CompositeLayer";
const wm = Math.PI / 180, KT = 180 / Math.PI, Qm = 6370972, xd = 256;
function S9() {
  const r = xd / Qm, e = Math.PI / 180 * xd;
  return {
    unitsPerMeter: [r, r, r],
    unitsPerMeter2: [0, 0, 0],
    metersPerUnit: [1 / r, 1 / r, 1 / r],
    unitsPerDegree: [e, e, r],
    unitsPerDegree2: [0, 0, 0],
    degreesPerUnit: [1 / e, 1 / e, 1 / r]
  };
}
class E9 extends Qd {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      longitude: t = 0,
      zoom: n = 0,
      // Matches Maplibre defaults
      // https://github.com/maplibre/maplibre-gl-js/blob/f8ab4b48d59ab8fe7b068b102538793bbdd4c848/src/geo/projection/globe_transform.ts#L632-L633
      nearZMultiplier: i = 0.5,
      farZMultiplier: s = 1,
      resolution: l = 10
    } = e;
    let {
      latitude: o = 0,
      height: d,
      altitude: m = 1.5,
      fovy: b
    } = e;
    o = Math.max(Math.min(o, U_), -85.051129), d = d || 1, b ? m = x2(b) : b = gg(m);
    const T = 1 / Math.PI / Math.cos(o * Math.PI / 180), M = Math.pow(2, n) * T, E = e.nearZ ?? i, D = e.farZ ?? (m + xd * 2 * M / d) * s, U = new Cn().lookAt({
      eye: [0, -m, 0],
      up: [0, 0, 1]
    });
    U.rotateX(o * wm), U.rotateZ(-t * wm), U.scale(M / d), super({
      ...e,
      // x, y, width,
      height: d,
      // view matrix
      viewMatrix: U,
      longitude: t,
      latitude: o,
      zoom: n,
      // projection matrix parameters
      distanceScales: S9(),
      fovy: b,
      focalDistance: m,
      near: E,
      far: D
    }), this.scale = M, this.latitude = o, this.longitude = t, this.resolution = l;
  }
  get projectionMode() {
    return wc.GLOBE;
  }
  getDistanceScales() {
    return this.distanceScales;
  }
  getBounds() {
    const t = {
      targetZ: (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).z || 0
    }, n = this.unproject([0, this.height / 2], t), i = this.unproject([this.width / 2, 0], t), s = this.unproject([this.width, this.height / 2], t), l = this.unproject([this.width / 2, this.height], t);
    return s[0] < this.longitude && (s[0] += 360), n[0] > this.longitude && (n[0] -= 360), [Math.min(n[0], s[0], i[0], l[0]), Math.min(n[1], s[1], i[1], l[1]), Math.max(n[0], s[0], i[0], l[0]), Math.max(n[1], s[1], i[1], l[1])];
  }
  unproject(e) {
    let {
      topLeft: t = !0,
      targetZ: n
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const [i, s, l] = e, o = t ? s : this.height - s, {
      pixelUnprojectionMatrix: d
    } = this;
    let m;
    if (Number.isFinite(l))
      m = pb(d, [i, o, l, 1]);
    else {
      const E = pb(d, [i, o, -1, 1]), D = pb(d, [i, o, 1, 1]), U = ((n || 0) / Qm + 1) * xd, q = K0(R5([], E, D)), G = K0(E), Y = K0(D), X = 4 * ((4 * G * Y - (q - G - Y) ** 2) / 16) / q, J = Math.sqrt(G - X), ie = Math.sqrt(Math.max(0, U * U - X)), ye = (J - ie) / Math.sqrt(q);
      m = wN([], E, D, ye);
    }
    const [b, T, M] = this.unprojectPosition(m);
    return Number.isFinite(l) ? [b, T, M] : Number.isFinite(n) ? [b, T, n] : [b, T];
  }
  projectPosition(e) {
    const [t, n, i = 0] = e, s = t * wm, l = n * wm, o = Math.cos(l), d = (i / Qm + 1) * xd;
    return [Math.sin(s) * o * d, -Math.cos(s) * o * d, Math.sin(l) * d];
  }
  unprojectPosition(e) {
    const [t, n, i] = e, s = B5(e), l = Math.asin(i / s), d = Math.atan2(t, -n) * KT, m = l * KT, b = (s / xd - 1) * Qm;
    return [d, m, b];
  }
  projectFlat(e) {
    return e;
  }
  unprojectFlat(e) {
    return e;
  }
  panByPosition(e, t) {
    const n = this.unproject(t);
    return {
      longitude: e[0] - n[0] + this.longitude,
      latitude: e[1] - n[1] + this.latitude
    };
  }
}
function pb(r, e) {
  const t = Jd([], e, r);
  return m2(t, t, 1 / t[3]), t;
}
class C9 extends yC {
  // Apply any constraints (mathematical or defined by _viewportProps) to map state
  applyConstraints(e) {
    const {
      maxZoom: t,
      minZoom: n,
      zoom: i
    } = e;
    e.zoom = xc(i, n, t);
    const {
      longitude: s,
      latitude: l
    } = e;
    return (s < -180 || s > 180) && (e.longitude = GF(s + 180, 360) - 180), e.latitude = xc(l, -85.051129, U_), e;
  }
}
class I9 extends _C {
  constructor() {
    super(...arguments), this.ControllerState = C9, this.transition = {
      transitionDuration: 300,
      transitionInterpolator: new E2(["longitude", "latitude", "zoom"])
    }, this.dragMode = "pan";
  }
  setProps(e) {
    super.setProps(e), this.dragRotate = !1, this.touchRotate = !1;
  }
}
class ZC extends mC {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super(e);
  }
  getViewportType(e) {
    return e.zoom > 12 ? Cf : E9;
  }
  get ControllerType() {
    return I9;
  }
}
ZC.displayName = "GlobeView";
const gb = 512, M9 = Math.PI / 180;
function YC(r) {
  let {
    map: e,
    gl: t,
    deck: n
  } = r;
  if (e.__deck)
    return e.__deck;
  const i = n == null ? void 0 : n.props._customRender, s = n == null ? void 0 : n.props.onLoad, l = {
    ...n == null ? void 0 : n.props,
    _customRender: () => {
      e.triggerRepaint(), i == null || i("");
    }
  };
  l.parameters = {
    ...sv(e, !0),
    ...l.parameters
  }, l.views || (l.views = G_(e));
  let o;
  return (!n || n.props.gl === t) && (Object.assign(l, {
    gl: t,
    width: null,
    height: null,
    touchAction: "unset",
    viewState: bg(e)
  }), n != null && n.isInitialized ? JT(n, e) : l.onLoad = () => {
    s == null || s(), JT(o, e);
  }), n ? (o = n, n.setProps(l), n.userData.isExternal = !0) : (o = new yg(l), e.on("remove", () => {
    KC(e);
  })), o.userData.mapboxLayers = /* @__PURE__ */ new Set(), e.__deck = o, e.on("render", () => {
    o.isInitialized && N9(o, e);
  }), o;
}
function JT(r, e) {
  const t = () => {
    r.isInitialized ? D9(r, e) : e.off("move", t);
  };
  e.on("move", t);
}
function KC(r) {
  var e;
  (e = r.__deck) == null || e.finalize(), r.__deck = null;
}
function sv(r, e) {
  const t = e ? {
    depthWriteEnabled: !0,
    depthCompare: "less-equal",
    depthBias: 0,
    blend: !0,
    blendColorSrcFactor: "src-alpha",
    blendColorDstFactor: "one-minus-src-alpha",
    blendAlphaSrcFactor: "one",
    blendAlphaDstFactor: "one-minus-src-alpha",
    blendColorOperation: "add",
    blendAlphaOperation: "add"
  } : {};
  return JC(r) === "globe" && (t.cullMode = "back"), t;
}
function P9(r, e) {
  r.userData.mapboxLayers.add(e), O2(r);
}
function R9(r, e) {
  r.userData.mapboxLayers.delete(e), O2(r);
}
function B9(r, e) {
  O2(r);
}
function L9(r, e, t, n) {
  let {
    currentViewport: i
  } = r.userData, s = !1;
  i || (i = QC(r, e, n), r.userData.currentViewport = i, s = !0), r.isInitialized && r._drawLayers("mapbox-repaint", {
    viewports: [i],
    layerFilter: (l) => {
      let {
        layer: o
      } = l;
      return t.id === o.id || o.props.operation.includes("terrain");
    },
    clearStack: s,
    clearCanvas: !1
  });
}
function JC(r) {
  var n;
  const e = (n = r.getProjection) == null ? void 0 : n.call(r), t = (
    // maplibre projection spec
    (e == null ? void 0 : e.type) || // mapbox projection spec
    (e == null ? void 0 : e.name)
  );
  if (t === "globe")
    return "globe";
  if (t && t !== "mercator")
    throw new Error("Unsupported projection");
  return "mercator";
}
function G_(r) {
  return JC(r) === "globe" ? new ZC({
    id: "mapbox"
  }) : new C2({
    id: "mapbox"
  });
}
function bg(r) {
  var i;
  const {
    lng: e,
    lat: t
  } = r.getCenter(), n = {
    // Longitude returned by getCenter can be outside of [-180, 180] when zooming near the anti meridian
    // https://github.com/visgl/deck.gl/issues/6894
    longitude: (e + 540) % 360 - 180,
    latitude: t,
    zoom: r.getZoom(),
    bearing: r.getBearing(),
    pitch: r.getPitch(),
    padding: r.getPadding(),
    repeat: r.getRenderWorldCopies()
  };
  return (i = r.getTerrain) != null && i.call(r) && O9(r, n), n;
}
function O9(r, e) {
  if (r.getFreeCameraOptions) {
    const {
      position: t
    } = r.getFreeCameraOptions();
    if (!t || t.z === void 0)
      return;
    const n = r.transform.height, {
      longitude: i,
      latitude: s,
      pitch: l
    } = e, o = t.x * gb, d = (1 - t.y) * gb, m = t.z * gb, b = pg([i, s]), T = o - b[0], M = d - b[1], E = Math.sqrt(T * T + M * M), D = l * M9, U = 1.5 * n, q = D < 1e-3 ? (
      // Pitch angle too small to deduce the look at point, assume elevation is 0
      U * Math.cos(D) / m
    ) : U * Math.sin(D) / E;
    e.zoom = Math.log2(q);
    const G = U * Math.cos(D) / q, Y = m - G;
    e.position = [0, 0, Y / Km(s)];
  } else typeof r.transform.elevation == "number" && (e.position = [0, 0, r.transform.elevation]);
}
function QC(r, e, t) {
  const n = bg(e), i = G_(e);
  t && (i.props.nearZMultiplier = 0.2);
  const s = (t == null ? void 0 : t.nearZ) ?? e.transform._nearZ, l = (t == null ? void 0 : t.farZ) ?? e.transform._farZ;
  return Number.isFinite(s) && (n.nearZ = s / e.transform.height, n.farZ = l / e.transform.height), i.makeViewport({
    width: r.width,
    height: r.height,
    viewState: n
  });
}
function N9(r, e) {
  const {
    mapboxLayers: t,
    isExternal: n
  } = r.userData;
  if (n) {
    const i = Array.from(t, (b) => b.id), l = jd(r.props.layers, Boolean).some((b) => b && !i.includes(b.id));
    let o = r.getViewports();
    const d = o.findIndex((b) => b.id === "mapbox"), m = o.length > 1 || d < 0;
    (l || m) && (d >= 0 && (o = o.slice(), o[d] = QC(r, e)), r._drawLayers("mapbox-repaint", {
      viewports: o,
      layerFilter: (b) => (!r.props.layerFilter || r.props.layerFilter(b)) && (b.viewport.id !== "mapbox" || !i.includes(b.layer.id)),
      clearCanvas: !1
    }));
  }
  r.userData.currentViewport = null;
}
function D9(r, e) {
  r.setProps({
    viewState: bg(e)
  }), r.needsRedraw({
    clearRedrawFlags: !0
  });
}
function O2(r) {
  if (r.userData.isExternal)
    return;
  const e = [];
  r.userData.mapboxLayers.forEach((t) => {
    const n = t.props.type, i = new n(t.props);
    e.push(i);
  }), r.setProps({
    layers: e
  });
}
class k9 {
  /* eslint-disable no-this-before-super */
  constructor(e) {
    if (!e.id)
      throw new Error("Layer must have an unique id");
    this.id = e.id, this.type = "custom", this.renderingMode = e.renderingMode || "3d", this.slot = e.slot, this.map = null, this.deck = null, this.props = e;
  }
  /* Mapbox custom layer methods */
  onAdd(e, t) {
    this.map = e, this.deck = YC({
      map: e,
      gl: t,
      deck: this.props.deck
    }), P9(this.deck, this);
  }
  onRemove() {
    this.deck && R9(this.deck, this);
  }
  setProps(e) {
    Object.assign(this.props, e, {
      id: this.id
    }), this.deck && B9(this.deck);
  }
  render(e, t) {
    L9(this.deck, this.map, this, t);
  }
}
const mb = "__UNDEFINED__";
function Am(r, e, t, n) {
  if (!r || !e || !r.style || !r.style._loaded)
    return;
  const i = jd(n, Boolean);
  if (t !== n) {
    const o = jd(t, Boolean), d = new Set(o.map((m) => m.id));
    for (const m of i)
      d.delete(m.id);
    for (const m of d)
      r.getLayer(m) && r.removeLayer(m);
  }
  for (const o of i) {
    const d = r.getLayer(o.id);
    d ? (d.implementation || d).setProps(o.props) : r.addLayer(
      new k9({
        id: o.id,
        deck: e,
        // @ts-expect-error slot is not defined in LayerProps
        slot: o.props.slot
      }),
      // @ts-expect-error beforeId is not defined in LayerProps
      o.props.beforeId
    );
  }
  const s = r.style._order, l = {};
  for (const o of i) {
    let {
      beforeId: d
    } = o.props;
    (!d || !s.includes(d)) && (d = mb), l[d] = l[d] || [], l[d].push(o.id);
  }
  for (const o in l) {
    const d = l[o];
    let m = o === mb ? s.length : s.indexOf(o), b = o === mb ? void 0 : o;
    for (let T = d.length - 1; T >= 0; T--) {
      const M = d[T], E = s.indexOf(M);
      E !== m - 1 && (r.moveLayer(M, b), E > m && m++), m--, b = M;
    }
  }
}
class F9 {
  constructor(e) {
    this._handleStyleChange = () => {
      Am(this._map, this._deck, this._props.layers, this._props.layers);
    }, this._updateContainerSize = () => {
      if (this._map && this._container) {
        const {
          clientWidth: i,
          clientHeight: s
        } = this._map.getContainer();
        Object.assign(this._container.style, {
          width: `${i}px`,
          height: `${s}px`
        });
      }
    }, this._updateViewState = () => {
      const i = this._deck, s = this._map;
      i && s && (i.setProps({
        views: this._props.views || G_(s),
        viewState: bg(s)
      }), i.isInitialized && i.redraw());
    }, this._handleMouseEvent = (i) => {
      const s = this._deck;
      if (!s || !s.isInitialized)
        return;
      const l = {
        type: i.type,
        offsetCenter: i.point,
        srcEvent: i
      }, o = this._lastMouseDownPoint;
      switch (!i.point && o && (l.deltaX = i.originalEvent.clientX - o.clientX, l.deltaY = i.originalEvent.clientY - o.clientY, l.offsetCenter = {
        x: o.x + l.deltaX,
        y: o.y + l.deltaY
      }), l.type) {
        case "mousedown":
          s._onPointerDown(l), this._lastMouseDownPoint = {
            ...i.point,
            clientX: i.originalEvent.clientX,
            clientY: i.originalEvent.clientY
          };
          break;
        case "dragstart":
          l.type = "panstart", s._onEvent(l);
          break;
        case "drag":
          l.type = "panmove", s._onEvent(l);
          break;
        case "dragend":
          l.type = "panend", s._onEvent(l);
          break;
        case "click":
          l.tapCount = 1, s._onEvent(l);
          break;
        case "dblclick":
          l.type = "click", l.tapCount = 2, s._onEvent(l);
          break;
        case "mousemove":
          l.type = "pointermove", s._onPointerMove(l);
          break;
        case "mouseout":
          l.type = "pointerleave", s._onPointerMove(l);
          break;
        default:
          return;
      }
    };
    const {
      interleaved: t = !1,
      ...n
    } = e;
    this._interleaved = t, this._props = n;
  }
  /** Update (partial) props of the underlying Deck instance. */
  setProps(e) {
    this._interleaved && e.layers && Am(this._map, this._deck, this._props.layers, e.layers), Object.assign(this._props, e), this._deck && this._map && this._deck.setProps({
      ...this._props,
      parameters: {
        ...sv(this._map, this._interleaved),
        ...this._props.parameters
      }
    });
  }
  // The local Map type is for internal typecheck only. It does not necesarily satisefy mapbox/maplibre types at runtime.
  // Do not restrict the argument type here to avoid type conflict.
  /** Called when the control is added to a map */
  onAdd(e) {
    return this._map = e, this._interleaved ? this._onAddInterleaved(e) : this._onAddOverlaid(e);
  }
  _onAddOverlaid(e) {
    const t = document.createElement("div");
    return Object.assign(t.style, {
      position: "absolute",
      left: 0,
      top: 0,
      textAlign: "initial",
      pointerEvents: "none"
    }), this._container = t, this._deck = new yg({
      ...this._props,
      parent: t,
      parameters: {
        ...sv(e, !1),
        ...this._props.parameters
      },
      views: this._props.views || G_(e),
      viewState: bg(e)
    }), e.on("resize", this._updateContainerSize), e.on("render", this._updateViewState), e.on("mousedown", this._handleMouseEvent), e.on("dragstart", this._handleMouseEvent), e.on("drag", this._handleMouseEvent), e.on("dragend", this._handleMouseEvent), e.on("mousemove", this._handleMouseEvent), e.on("mouseout", this._handleMouseEvent), e.on("click", this._handleMouseEvent), e.on("dblclick", this._handleMouseEvent), this._updateContainerSize(), t;
  }
  _onAddInterleaved(e) {
    const t = e.painter.context.gl;
    return t instanceof WebGLRenderingContext && qn.warn("Incompatible basemap library. See: https://deck.gl/docs/api-reference/mapbox/overview#compatibility")(), this._deck = YC({
      map: e,
      gl: t,
      deck: new yg({
        ...this._props,
        gl: t
      })
    }), e.on("styledata", this._handleStyleChange), Am(e, this._deck, [], this._props.layers), document.createElement("div");
  }
  /** Called when the control is removed from a map */
  onRemove() {
    const e = this._map;
    e && (this._interleaved ? this._onRemoveInterleaved(e) : this._onRemoveOverlaid(e)), this._deck = void 0, this._map = void 0, this._container = void 0;
  }
  _onRemoveOverlaid(e) {
    var t;
    e.off("resize", this._updateContainerSize), e.off("render", this._updateViewState), e.off("mousedown", this._handleMouseEvent), e.off("dragstart", this._handleMouseEvent), e.off("drag", this._handleMouseEvent), e.off("dragend", this._handleMouseEvent), e.off("mousemove", this._handleMouseEvent), e.off("mouseout", this._handleMouseEvent), e.off("click", this._handleMouseEvent), e.off("dblclick", this._handleMouseEvent), (t = this._deck) == null || t.finalize();
  }
  _onRemoveInterleaved(e) {
    e.off("styledata", this._handleStyleChange), Am(e, this._deck, this._props.layers, []), KC(e);
  }
  getDefaultPosition() {
    return "top-left";
  }
  /** Forwards the Deck.pickObject method */
  pickObject(e) {
    return Xs(this._deck), this._deck.pickObject(e);
  }
  /** Forwards the Deck.pickMultipleObjects method */
  pickMultipleObjects(e) {
    return Xs(this._deck), this._deck.pickMultipleObjects(e);
  }
  /** Forwards the Deck.pickObjects method */
  pickObjects(e) {
    return Xs(this._deck), this._deck.pickObjects(e);
  }
  /** Remove from map and releases all resources */
  finalize() {
    this._map && this._map.removeControl(this);
  }
  /** If interleaved: true, returns base map's canvas, otherwise forwards the Deck.getCanvas method. */
  getCanvas() {
    return this._map ? this._interleaved ? this._map.getCanvas() : this._deck.getCanvas() : null;
  }
}
const QT = `uniform pointCloudUniforms {
  float radiusPixels;
  highp int sizeUnits;
} pointCloud;
`, U9 = {
  name: "pointCloud",
  vs: QT,
  fs: QT,
  uniformTypes: {
    radiusPixels: "f32",
    sizeUnits: "i32"
  }
}, z9 = `#version 300 es
#define SHADER_NAME point-cloud-layer-vertex-shader
in vec3 positions;
in vec3 instanceNormals;
in vec4 instanceColors;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec3 instancePickingColors;
out vec4 vColor;
out vec2 unitPosition;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.normal = project_normal(instanceNormals);
unitPosition = positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
vec3 offset = vec3(positions.xy * project_size_to_pixel(pointCloud.radiusPixels, pointCloud.sizeUnits), 0.0);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, instanceColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, j9 = `#version 300 es
#define SHADER_NAME point-cloud-layer-fragment-shader
precision highp float;
in vec4 vColor;
in vec2 unitPosition;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition.xy;
float distToCenter = length(unitPosition);
if (distToCenter > 1.0) {
discard;
}
fragColor = vColor;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, eI = [0, 0, 0, 255], tI = [0, 0, 1], V9 = {
  sizeUnits: "pixels",
  pointSize: {
    type: "number",
    min: 0,
    value: 10
  },
  //  point radius in pixels
  getPosition: {
    type: "accessor",
    value: (r) => r.position
  },
  getNormal: {
    type: "accessor",
    value: tI
  },
  getColor: {
    type: "accessor",
    value: eI
  },
  material: !0,
  // Depreated
  radiusPixels: {
    deprecatedFor: "pointSize"
  }
};
function q9(r) {
  const {
    header: e,
    attributes: t
  } = r;
  if (!(!e || !t) && (r.length = e.vertexCount, t.POSITION && (t.instancePositions = t.POSITION), t.NORMAL && (t.instanceNormals = t.NORMAL), t.COLOR_0)) {
    const {
      size: n,
      value: i
    } = t.COLOR_0;
    t.instanceColors = {
      size: n,
      type: "unorm8",
      value: i
    };
  }
}
class N2 extends tp {
  getShaders() {
    return super.getShaders({
      vs: z9,
      fs: j9,
      modules: [b2, G5, A2, U9]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: !0,
        accessor: "getNormal",
        defaultValue: tI
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: "unorm8",
        transition: !0,
        accessor: "getColor",
        defaultValue: eI
      }
    });
  }
  updateState(e) {
    var i;
    const {
      changeFlags: t,
      props: n
    } = e;
    super.updateState(e), t.extensionsChanged && ((i = this.state.model) == null || i.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll()), t.dataChanged && q9(n.data);
  }
  draw(e) {
    let {
      uniforms: t
    } = e;
    const {
      pointSize: n,
      sizeUnits: i
    } = this.props, s = this.state.model, l = {
      sizeUnits: z1[i],
      radiusPixels: n
    };
    s.shaderInputs.setProps({
      pointCloud: l
    }), s.draw(this.context.renderPass);
  }
  _getModel() {
    const e = [];
    for (let t = 0; t < 3; t++) {
      const n = t / 3 * Math.PI * 2;
      e.push(Math.cos(n) * 2, Math.sin(n) * 2, 0);
    }
    return new Lh(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: new Id({
        topology: "triangle-list",
        attributes: {
          positions: new Float32Array(e)
        }
      }),
      isInstanced: !0
    });
  }
}
N2.layerName = "PointCloudLayer";
N2.defaultProps = V9;
const Ka = {
  OUTSIDE: -1,
  // Represents that an object is not contained within the frustum.
  INTERSECTING: 0,
  // Represents that an object intersects one of the frustum's planes.
  INSIDE: 1
  // Represents that an object is fully within the frustum.
};
new Tt();
new Tt();
const Op = new Tt(), e3 = new Tt();
class Bg {
  /** Creates a bounding sphere */
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    this.radius = -0, this.center = new Tt(), this.fromCenterRadius(e, t);
  }
  /** Sets the bounding sphere from `center` and `radius`. */
  fromCenterRadius(e, t) {
    return this.center.from(e), this.radius = t, this;
  }
  /**
   * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
   * tightly and fully encompasses the box.
   */
  fromCornerPoints(e, t) {
    return t = Op.from(t), this.center = new Tt().from(e).add(t).scale(0.5), this.radius = this.center.distance(t), this;
  }
  /** Compares the provided BoundingSphere component wise */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.radius === e.radius;
  }
  /** Duplicates a BoundingSphere instance. */
  clone() {
    return new Bg(this.center, this.radius);
  }
  /** Computes a bounding sphere that contains both the left and right bounding spheres. */
  union(e) {
    const t = this.center, n = this.radius, i = e.center, s = e.radius, l = Op.copy(i).subtract(t), o = l.magnitude();
    if (n >= o + s)
      return this.clone();
    if (s >= o + n)
      return e.clone();
    const d = (n + o + s) * 0.5;
    return e3.copy(l).scale((-n + d) / o).add(t), this.center.copy(e3), this.radius = d, this;
  }
  /** Computes a bounding sphere by enlarging the provided sphere to contain the provided point. */
  expand(e) {
    const n = Op.from(e).subtract(this.center).magnitude();
    return n > this.radius && (this.radius = n), this;
  }
  // BoundingVolume interface
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param sphere The bounding sphere to apply the transformation to.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns self.
   */
  transform(e) {
    this.center.transform(e);
    const t = VN(Op, e);
    return this.radius = Math.max(t[0], Math.max(t[1], t[2])) * this.radius, this;
  }
  /** Computes the estimated distance squared from the closest point on a bounding sphere to a point. */
  distanceSquaredTo(e) {
    const t = this.distanceTo(e);
    return t * t;
  }
  /** Computes the estimated distance from the closest point on a bounding sphere to a point. */
  distanceTo(e) {
    const n = Op.from(e).subtract(this.center);
    return Math.max(0, n.len() - this.radius);
  }
  /** Determines which side of a plane a sphere is located. */
  intersectPlane(e) {
    const t = this.center, n = this.radius, s = e.normal.dot(t) + e.distance;
    return s < -n ? Ka.OUTSIDE : s < n ? Ka.INTERSECTING : Ka.INSIDE;
  }
}
const G9 = new Tt(), $9 = new Tt(), Tm = new Tt(), Sm = new Tt(), Em = new Tt(), H9 = new Tt(), W9 = new Tt(), Bu = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
class Lg {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];
    this.center = new Tt().from(e), this.halfAxes = new us(t);
  }
  /** Returns an array with three halfSizes for the bounding box */
  get halfSize() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), n = this.halfAxes.getColumn(2);
    return [new Tt(e).len(), new Tt(t).len(), new Tt(n).len()];
  }
  /** Returns a quaternion describing the orientation of the bounding box */
  get quaternion() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), n = this.halfAxes.getColumn(2), i = new Tt(e).normalize(), s = new Tt(t).normalize(), l = new Tt(n).normalize();
    return new fg().fromMatrix3(new us([...i, ...s, ...l]));
  }
  /**
   * Create OrientedBoundingBox from quaternion based OBB,
   */
  fromCenterHalfSizeQuaternion(e, t, n) {
    const i = new fg(n), s = new us().fromQuaternion(i);
    return s[0] = s[0] * t[0], s[1] = s[1] * t[0], s[2] = s[2] * t[0], s[3] = s[3] * t[1], s[4] = s[4] * t[1], s[5] = s[5] * t[1], s[6] = s[6] * t[2], s[7] = s[7] * t[2], s[8] = s[8] * t[2], this.center = new Tt().from(e), this.halfAxes = s, this;
  }
  /** Duplicates a OrientedBoundingBox instance. */
  clone() {
    return new Lg(this.center, this.halfAxes);
  }
  /** Compares the provided OrientedBoundingBox component wise and returns */
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.halfAxes.equals(e.halfAxes);
  }
  /** Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box. */
  getBoundingSphere() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Bg();
    const t = this.halfAxes, n = t.getColumn(0, Tm), i = t.getColumn(1, Sm), s = t.getColumn(2, Em), l = G9.copy(n).add(i).add(s);
    return e.center.copy(this.center), e.radius = l.magnitude(), e;
  }
  /** Determines which side of a plane the oriented bounding box is located. */
  intersectPlane(e) {
    const t = this.center, n = e.normal, i = this.halfAxes, s = n.x, l = n.y, o = n.z, d = Math.abs(s * i[Bu.COLUMN0ROW0] + l * i[Bu.COLUMN0ROW1] + o * i[Bu.COLUMN0ROW2]) + Math.abs(s * i[Bu.COLUMN1ROW0] + l * i[Bu.COLUMN1ROW1] + o * i[Bu.COLUMN1ROW2]) + Math.abs(s * i[Bu.COLUMN2ROW0] + l * i[Bu.COLUMN2ROW1] + o * i[Bu.COLUMN2ROW2]), m = n.dot(t) + e.distance;
    return m <= -d ? Ka.OUTSIDE : m >= d ? Ka.INSIDE : Ka.INTERSECTING;
  }
  /** Computes the estimated distance from the closest point on a bounding box to a point. */
  distanceTo(e) {
    return Math.sqrt(this.distanceSquaredTo(e));
  }
  /**
   * Computes the estimated distance squared from the closest point
   * on a bounding box to a point.
   * See Geometric Tools for Computer Graphics 10.4.2
   */
  distanceSquaredTo(e) {
    const t = $9.from(e).subtract(this.center), n = this.halfAxes, i = n.getColumn(0, Tm), s = n.getColumn(1, Sm), l = n.getColumn(2, Em), o = i.magnitude(), d = s.magnitude(), m = l.magnitude();
    i.normalize(), s.normalize(), l.normalize();
    let b = 0, T;
    return T = Math.abs(t.dot(i)) - o, T > 0 && (b += T * T), T = Math.abs(t.dot(s)) - d, T > 0 && (b += T * T), T = Math.abs(t.dot(l)) - m, T > 0 && (b += T * T), b;
  }
  /**
   * The distances calculated by the vector from the center of the bounding box
   * to position projected onto direction.
   *
   * - If you imagine the infinite number of planes with normal direction,
   *   this computes the smallest distance to the closest and farthest planes
   *   from `position` that intersect the bounding box.
   *
   * @param position The position to calculate the distance from.
   * @param direction The direction from position.
   * @param result An Interval (array of length 2) to store the nearest and farthest distances.
   * @returns Interval (array of length 2) with nearest and farthest distances
   *   on the bounding box from position in direction.
   */
  // eslint-disable-next-line max-statements
  computePlaneDistances(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [-0, -0], i = Number.POSITIVE_INFINITY, s = Number.NEGATIVE_INFINITY;
    const l = this.center, o = this.halfAxes, d = o.getColumn(0, Tm), m = o.getColumn(1, Sm), b = o.getColumn(2, Em), T = H9.copy(d).add(m).add(b).add(l), M = W9.copy(T).subtract(e);
    let E = t.dot(M);
    return i = Math.min(E, i), s = Math.max(E, s), T.copy(l).add(d).add(m).subtract(b), M.copy(T).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), T.copy(l).add(d).subtract(m).add(b), M.copy(T).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), T.copy(l).add(d).subtract(m).subtract(b), M.copy(T).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), l.copy(T).subtract(d).add(m).add(b), M.copy(T).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), l.copy(T).subtract(d).add(m).subtract(b), M.copy(T).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), l.copy(T).subtract(d).subtract(m).add(b), M.copy(T).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), l.copy(T).subtract(d).subtract(m).subtract(b), M.copy(T).subtract(e), E = t.dot(M), i = Math.min(E, i), s = Math.max(E, s), n[0] = i, n[1] = s, n;
  }
  /**
   * Applies a 4x4 affine transformation matrix to a bounding sphere.
   * @param transform The transformation matrix to apply to the bounding sphere.
   * @returns itself, i.e. the modified BoundingVolume.
   */
  transform(e) {
    this.center.transformAsPoint(e);
    const t = this.halfAxes.getColumn(0, Tm);
    t.transformAsPoint(e);
    const n = this.halfAxes.getColumn(1, Sm);
    n.transformAsPoint(e);
    const i = this.halfAxes.getColumn(2, Em);
    return i.transformAsPoint(e), this.halfAxes = new us([...t, ...n, ...i]), this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
}
const t3 = new Tt(), r3 = new Tt();
class iu {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 1], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    this.normal = new Tt(), this.distance = -0, this.fromNormalDistance(e, t);
  }
  /** Creates a plane from a normal and a distance from the origin. */
  fromNormalDistance(e, t) {
    return bc(Number.isFinite(t)), this.normal.from(e).normalize(), this.distance = t, this;
  }
  /** Creates a plane from a normal and a point on the plane. */
  fromPointNormal(e, t) {
    e = t3.from(e), this.normal.from(t).normalize();
    const n = -this.normal.dot(e);
    return this.distance = n, this;
  }
  /** Creates a plane from the general equation */
  fromCoefficients(e, t, n, i) {
    return this.normal.set(e, t, n), bc(Cc(this.normal.len(), 1)), this.distance = i, this;
  }
  /** Duplicates a Plane instance. */
  clone() {
    return new iu(this.normal, this.distance);
  }
  /** Compares the provided Planes by normal and distance */
  equals(e) {
    return Cc(this.distance, e.distance) && Cc(this.normal, e.normal);
  }
  /** Computes the signed shortest distance of a point to a plane.
   * The sign of the distance determines which side of the plane the point is on.
   */
  getPointDistance(e) {
    return this.normal.dot(e) + this.distance;
  }
  /** Transforms the plane by the given transformation matrix. */
  transform(e) {
    const t = r3.copy(this.normal).transformAsVector(e).normalize(), n = this.normal.scale(-this.distance).transform(e);
    return this.fromPointNormal(n, t);
  }
  projectPointOntoPlane(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const n = t3.from(e), i = this.getPointDistance(n), s = r3.copy(this.normal).scale(i);
    return n.subtract(s).to(t);
  }
}
const n3 = [new Tt([1, 0, 0]), new Tt([0, 1, 0]), new Tt([0, 0, 1])], i3 = new Tt(), X9 = new Tt();
class Tl {
  /**
   * Create a new `CullingVolume` bounded by an array of clipping planed
   * @param planes Array of clipping planes.
   * */
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    this.planes = e;
  }
  /**
   * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
   * The planes are aligned to the x, y, and z axes in world coordinates.
   */
  fromBoundingSphere(e) {
    this.planes.length = 2 * n3.length;
    const t = e.center, n = e.radius;
    let i = 0;
    for (const s of n3) {
      let l = this.planes[i], o = this.planes[i + 1];
      l || (l = this.planes[i] = new iu()), o || (o = this.planes[i + 1] = new iu());
      const d = i3.copy(s).scale(-n).add(t);
      l.fromPointNormal(d, s);
      const m = i3.copy(s).scale(n).add(t), b = X9.copy(s).negate();
      o.fromPointNormal(m, b), i += 2;
    }
    return this;
  }
  /** Determines whether a bounding volume intersects the culling volume. */
  computeVisibility(e) {
    let t = Ka.INSIDE;
    for (const n of this.planes)
      switch (e.intersectPlane(n)) {
        case Ka.OUTSIDE:
          return Ka.OUTSIDE;
        case Ka.INTERSECTING:
          t = Ka.INTERSECTING;
          break;
      }
    return t;
  }
  /**
   * Determines whether a bounding volume intersects the culling volume.
   *
   * @param parentPlaneMask A bit mask from the boundingVolume's parent's check against the same culling
   *   volume, such that if (planeMask & (1 << planeIndex) === 0), for k < 31, then
   *   the parent (and therefore this) volume is completely inside plane[planeIndex]
   *   and that plane check can be skipped.
   */
  computeVisibilityWithPlaneMask(e, t) {
    if (bc(Number.isFinite(t), "parentPlaneMask is required."), t === Tl.MASK_OUTSIDE || t === Tl.MASK_INSIDE)
      return t;
    let n = Tl.MASK_INSIDE;
    const i = this.planes;
    for (let s = 0; s < this.planes.length; ++s) {
      const l = s < 31 ? 1 << s : 0;
      if (s < 31 && (t & l) === 0)
        continue;
      const o = i[s], d = e.intersectPlane(o);
      if (d === Ka.OUTSIDE)
        return Tl.MASK_OUTSIDE;
      d === Ka.INTERSECTING && (n |= l);
    }
    return n;
  }
}
Tl.MASK_OUTSIDE = 4294967295;
Tl.MASK_INSIDE = 0;
Tl.MASK_INDETERMINATE = 2147483647;
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
const ru = new us(), Z9 = new us(), Y9 = new us(), Cm = new us(), s3 = new us();
function K9(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = CD, n = 10;
  let i = 0, s = 0;
  const l = Z9, o = Y9;
  l.identity(), o.copy(r);
  const d = t * J9(o);
  for (; s < n && Q9(o) > d; )
    ej(o, Cm), s3.copy(Cm).transpose(), o.multiplyRight(Cm), o.multiplyLeft(s3), l.multiplyRight(Cm), ++i > 2 && (++s, i = 0);
  return e.unitary = l.toTarget(e.unitary), e.diagonal = o.toTarget(e.diagonal), e;
}
function J9(r) {
  let e = 0;
  for (let t = 0; t < 9; ++t) {
    const n = r[t];
    e += n * n;
  }
  return Math.sqrt(e);
}
const ov = [1, 0, 0], av = [2, 2, 1];
function Q9(r) {
  let e = 0;
  for (let t = 0; t < 3; ++t) {
    const n = r[ru.getElementIndex(av[t], ov[t])];
    e += 2 * n * n;
  }
  return Math.sqrt(e);
}
function ej(r, e) {
  const t = U5;
  let n = 0, i = 1;
  for (let m = 0; m < 3; ++m) {
    const b = Math.abs(r[ru.getElementIndex(av[m], ov[m])]);
    b > n && (i = m, n = b);
  }
  const s = ov[i], l = av[i];
  let o = 1, d = 0;
  if (Math.abs(r[ru.getElementIndex(l, s)]) > t) {
    const m = r[ru.getElementIndex(l, l)], b = r[ru.getElementIndex(s, s)], T = r[ru.getElementIndex(l, s)], M = (m - b) / 2 / T;
    let E;
    M < 0 ? E = -1 / (-M + Math.sqrt(1 + M * M)) : E = 1 / (M + Math.sqrt(1 + M * M)), o = 1 / Math.sqrt(1 + E * E), d = E * o;
  }
  return us.IDENTITY.to(e), e[ru.getElementIndex(s, s)] = e[ru.getElementIndex(l, l)] = o, e[ru.getElementIndex(l, s)] = d, e[ru.getElementIndex(s, l)] = -d, e;
}
const fh = new Tt(), tj = new Tt(), rj = new Tt(), nj = new Tt(), ij = new Tt(), sj = new us(), oj = {
  diagonal: new us(),
  unitary: new us()
};
function aj(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Lg();
  if (!r || r.length === 0)
    return e.halfAxes = new us([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new Tt(), e;
  const t = r.length, n = new Tt(0, 0, 0);
  for (const Re of r)
    n.add(Re);
  const i = 1 / t;
  n.multiplyByScalar(i);
  let s = 0, l = 0, o = 0, d = 0, m = 0, b = 0;
  for (const Re of r) {
    const Ne = fh.copy(Re).subtract(n);
    s += Ne.x * Ne.x, l += Ne.x * Ne.y, o += Ne.x * Ne.z, d += Ne.y * Ne.y, m += Ne.y * Ne.z, b += Ne.z * Ne.z;
  }
  s *= i, l *= i, o *= i, d *= i, m *= i, b *= i;
  const T = sj;
  T[0] = s, T[1] = l, T[2] = o, T[3] = l, T[4] = d, T[5] = m, T[6] = o, T[7] = m, T[8] = b;
  const {
    unitary: M
  } = K9(T, oj), E = e.halfAxes.copy(M);
  let D = E.getColumn(0, rj), U = E.getColumn(1, nj), q = E.getColumn(2, ij), G = -Number.MAX_VALUE, Y = -Number.MAX_VALUE, he = -Number.MAX_VALUE, X = Number.MAX_VALUE, J = Number.MAX_VALUE, ie = Number.MAX_VALUE;
  for (const Re of r)
    fh.copy(Re), G = Math.max(fh.dot(D), G), Y = Math.max(fh.dot(U), Y), he = Math.max(fh.dot(q), he), X = Math.min(fh.dot(D), X), J = Math.min(fh.dot(U), J), ie = Math.min(fh.dot(q), ie);
  D = D.multiplyByScalar(0.5 * (X + G)), U = U.multiplyByScalar(0.5 * (J + Y)), q = q.multiplyByScalar(0.5 * (ie + he)), e.center.copy(D).add(U).add(q);
  const ye = tj.set(G - X, Y - J, he - ie).multiplyByScalar(0.5), oe = new us([ye[0], 0, 0, 0, ye[1], 0, 0, 0, ye[2]]);
  return e.halfAxes.multiplyRight(oe), e;
}
const _b = Math.PI / 180, Im = new Float32Array(16), o3 = new Float32Array(12);
function a3(r, e, t) {
  const n = e[0] * _b, i = e[1] * _b, s = e[2] * _b, l = Math.sin(s), o = Math.sin(n), d = Math.sin(i), m = Math.cos(s), b = Math.cos(n), T = Math.cos(i), M = t[0], E = t[1], D = t[2];
  r[0] = M * T * b, r[1] = M * d * b, r[2] = M * -o, r[3] = E * (-d * m + T * o * l), r[4] = E * (T * m + d * o * l), r[5] = E * b * l, r[6] = D * (d * l + T * o * m), r[7] = D * (-T * l + d * o * m), r[8] = D * b * m;
}
function l3(r) {
  return r[0] = r[0], r[1] = r[1], r[2] = r[2], r[3] = r[4], r[4] = r[5], r[5] = r[6], r[6] = r[8], r[7] = r[9], r[8] = r[10], r[9] = r[12], r[10] = r[13], r[11] = r[14], r.subarray(0, 12);
}
const rI = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrixCol0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrixCol1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrixCol2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(r, e) {
    let {
      startRow: t,
      endRow: n
    } = e;
    const {
      data: i,
      getOrientation: s,
      getScale: l,
      getTranslation: o,
      getTransformMatrix: d
    } = this.props, m = Array.isArray(d), b = m && d.length === 16, T = Array.isArray(l), M = Array.isArray(s), E = Array.isArray(o), D = b || !m && !!d(i[0]);
    D ? r.constant = b : r.constant = M && T && E;
    const U = r.value;
    if (r.constant) {
      let q;
      D ? (Im.set(d), q = l3(Im)) : (q = o3, a3(q, s, l), q.set(o, 9)), r.value = new Float32Array(q);
    } else {
      let q = t * r.size;
      const {
        iterable: G,
        objectInfo: Y
      } = NC(i, t, n);
      for (const he of G) {
        Y.index++;
        let X;
        if (D)
          Im.set(b ? d : d(he, Y)), X = l3(Im);
        else {
          X = o3;
          const J = M ? s : s(he, Y), ie = T ? l : l(he, Y);
          a3(X, J, ie), X.set(E ? o : o(he, Y), 9);
        }
        U[q++] = X[0], U[q++] = X[1], U[q++] = X[2], U[q++] = X[3], U[q++] = X[4], U[q++] = X[5], U[q++] = X[6], U[q++] = X[7], U[q++] = X[8], U[q++] = X[9], U[q++] = X[10], U[q++] = X[11];
      }
    }
  }
};
function nI(r, e) {
  return e === Rn.CARTESIAN || e === Rn.METER_OFFSETS || e === Rn.DEFAULT && !r.isGeospatial;
}
const c3 = `uniform simpleMeshUniforms {
  float sizeScale;
  bool composeModelMatrix;
  bool hasTexture;
  bool flatShading;
} simpleMesh;
`, lj = {
  name: "simpleMesh",
  vs: c3,
  fs: c3,
  uniformTypes: {
    sizeScale: "f32",
    composeModelMatrix: "f32",
    hasTexture: "f32",
    flatShading: "f32"
  }
}, cj = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = texCoords;
geometry.pickingColor = instancePickingColors;
vTexCoord = texCoords;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;
if (simpleMesh.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
geometry.position = position_commonspace;
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
}
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, uj = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
DECKGL_FILTER_COLOR(color, geometry);
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
}
`;
function yb(r) {
  const e = r.positions || r.POSITION;
  qn.assert(e, 'no "postions" or "POSITION" attribute in mesh');
  const t = e.value.length / e.size;
  let n = r.COLOR_0 || r.colors;
  n || (n = {
    size: 3,
    value: new Float32Array(t * 3).fill(1)
  });
  let i = r.NORMAL || r.normals;
  i || (i = {
    size: 3,
    value: new Float32Array(t * 3).fill(0)
  });
  let s = r.TEXCOORD_0 || r.texCoords;
  return s || (s = {
    size: 2,
    value: new Float32Array(t * 2).fill(0)
  }), {
    positions: e,
    colors: n,
    normals: i,
    texCoords: s
  };
}
function u3(r) {
  return r instanceof Id ? (r.attributes = yb(r.attributes), r) : r.attributes ? new Id({
    ...r,
    topology: "triangle-list",
    attributes: yb(r.attributes)
  }) : new Id({
    topology: "triangle-list",
    attributes: yb(r)
  });
}
const hj = [0, 0, 0, 255], fj = {
  mesh: {
    type: "object",
    value: null,
    async: !0
  },
  texture: {
    type: "image",
    value: null,
    async: !0
  },
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  // _instanced is a hack to use world position instead of meter offsets in mesh
  // TODO - formalize API
  _instanced: !0,
  // NOTE(Tarek): Quick and dirty wireframe. Just draws
  // the same mesh with LINE_STRIPS. Won't follow edges
  // of the original mesh.
  wireframe: !1,
  // Optional material for 'lighting' shader module
  material: !0,
  getPosition: {
    type: "accessor",
    value: (r) => r.position
  },
  getColor: {
    type: "accessor",
    value: hj
  },
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  // 4x4 matrix
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  textureParameters: {
    type: "object",
    ignore: !0,
    value: null
  }
};
class D2 extends tp {
  getShaders() {
    return super.getShaders({
      vs: cj,
      fs: uj,
      modules: [b2, $5, A2, lj]
    });
  }
  getBounds() {
    var n;
    if (this.props._instanced)
      return super.getBounds();
    let e = this.state.positionBounds;
    if (e)
      return e;
    const {
      mesh: t
    } = this.props;
    if (!t)
      return null;
    if (e = (n = t.header) == null ? void 0 : n.boundingBox, !e) {
      const {
        attributes: i
      } = u3(t);
      i.POSITION = i.POSITION || i.positions, e = RE(i);
    }
    return this.state.positionBounds = e, e;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        transition: !0,
        type: "float64",
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: "unorm8",
        transition: !0,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: rI
    }), this.setState({
      // Avoid luma.gl's missing uniform warning
      // TODO - add feature to luma.gl to specify ignored uniforms?
      emptyTexture: this.context.device.createTexture({
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(e) {
    var s;
    super.updateState(e);
    const {
      props: t,
      oldProps: n,
      changeFlags: i
    } = e;
    if (t.mesh !== n.mesh || i.extensionsChanged) {
      if (this.state.positionBounds = null, (s = this.state.model) == null || s.destroy(), t.mesh) {
        this.state.model = this.getModel(t.mesh);
        const l = t.mesh.attributes || t.mesh;
        this.setState({
          hasNormals: !!(l.NORMAL || l.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    t.texture !== n.texture && t.texture instanceof Wi && this.setTexture(t.texture), this.state.model && this.state.model.setTopology(this.props.wireframe ? "line-strip" : "triangle-list");
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.emptyTexture.delete();
  }
  draw(e) {
    let {
      uniforms: t
    } = e;
    const {
      model: n
    } = this.state;
    if (!n)
      return;
    const {
      viewport: i,
      renderPass: s
    } = this.context, {
      sizeScale: l,
      coordinateSystem: o,
      _instanced: d
    } = this.props, m = {
      sizeScale: l,
      composeModelMatrix: !d || nI(i, o),
      flatShading: !this.state.hasNormals
    };
    n.shaderInputs.setProps({
      simpleMesh: m
    }), n.draw(s);
  }
  get isLoaded() {
    var e;
    return !!((e = this.state) != null && e.model && super.isLoaded);
  }
  getModel(e) {
    const t = new Lh(this.context.device, {
      ...this.getShaders(),
      id: this.props.id,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      geometry: u3(e),
      isInstanced: !0
    }), {
      texture: n
    } = this.props, {
      emptyTexture: i
    } = this.state, s = {
      sampler: n || i,
      hasTexture: !!n
    };
    return t.shaderInputs.setProps({
      simpleMesh: s
    }), t;
  }
  setTexture(e) {
    const {
      emptyTexture: t,
      model: n
    } = this.state;
    if (n) {
      const i = {
        sampler: e || t,
        hasTexture: !!e
      };
      n.shaderInputs.setProps({
        simpleMesh: i
      });
    }
  }
}
D2.defaultProps = fj;
D2.layerName = "SimpleMeshLayer";
var vc;
(function(r) {
  r[r.FUNC_ADD = 32774] = "FUNC_ADD", r[r.ONE = 1] = "ONE", r[r.SRC_ALPHA = 770] = "SRC_ALPHA", r[r.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", r[r.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", r[r.LINEAR = 9729] = "LINEAR", r[r.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", r[r.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL";
})(vc || (vc = {}));
function iI(r, e, t, n) {
  const i = {
    defines: {
      // TODO: Use EXT_sRGB if available (Standard in WebGL 2.0)
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    },
    bindings: {},
    uniforms: {
      // TODO: find better values?
      camera: [0, 0, 0],
      // Model should override
      metallicRoughnessValues: [1, 1]
      // Default is 1 and 1
    },
    parameters: {},
    glParameters: {},
    generatedTextures: []
  };
  i.defines.USE_TEX_LOD = 1;
  const {
    imageBasedLightingEnvironment: s
  } = n;
  return s && (i.bindings.pbr_diffuseEnvSampler = s.diffuseEnvSampler.texture, i.bindings.pbr_specularEnvSampler = s.specularEnvSampler.texture, i.bindings.pbr_BrdfLUT = s.brdfLutTexture.texture, i.uniforms.scaleIBLAmbient = [1, 1]), n != null && n.pbrDebug && (i.defines.PBR_DEBUG = 1, i.uniforms.scaleDiffBaseMR = [0, 0, 0, 0], i.uniforms.scaleFGDSpec = [0, 0, 0, 0]), t.NORMAL && (i.defines.HAS_NORMALS = 1), t.TANGENT && (n != null && n.useTangents) && (i.defines.HAS_TANGENTS = 1), t.TEXCOORD_0 && (i.defines.HAS_UV = 1), n != null && n.imageBasedLightingEnvironment && (i.defines.USE_IBL = 1), n != null && n.lights && (i.defines.USE_LIGHTS = 1), e && dj(r, e, i), i;
}
function dj(r, e, t) {
  if (t.uniforms.unlit = !!e.unlit, e.pbrMetallicRoughness && pj(r, e.pbrMetallicRoughness, t), e.normalTexture) {
    ag(r, e.normalTexture, "pbr_normalSampler", "HAS_NORMALMAP", t);
    const {
      scale: n = 1
    } = e.normalTexture;
    t.uniforms.normalScale = n;
  }
  if (e.occlusionTexture) {
    ag(r, e.occlusionTexture, "pbr_occlusionSampler", "HAS_OCCLUSIONMAP", t);
    const {
      strength: n = 1
    } = e.occlusionTexture;
    t.uniforms.occlusionStrength = n;
  }
  switch (e.emissiveTexture && (ag(r, e.emissiveTexture, "pbr_emissiveSampler", "HAS_EMISSIVEMAP", t), t.uniforms.emissiveFactor = e.emissiveFactor || [0, 0, 0]), e.alphaMode) {
    case "MASK":
      const {
        alphaCutoff: n = 0.5
      } = e;
      t.defines.ALPHA_CUTOFF = 1, t.uniforms.alphaCutoff = n;
      break;
    case "BLEND":
      lr.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")(), t.parameters.blendColorOperation = "add", t.parameters.blendColorSrcFactor = "src-alpha", t.parameters.blendColorDstFactor = "one-minus-src-alpha", t.parameters.blendAlphaOperation = "add", t.parameters.blendAlphaSrcFactor = "one", t.parameters.blendAlphaDstFactor = "one-minus-src-alpha", t.glParameters.blend = !0, t.glParameters.blendEquation = vc.FUNC_ADD, t.glParameters.blendFunc = [vc.SRC_ALPHA, vc.ONE_MINUS_SRC_ALPHA, vc.ONE, vc.ONE_MINUS_SRC_ALPHA];
      break;
  }
}
function pj(r, e, t) {
  e.baseColorTexture && ag(r, e.baseColorTexture, "pbr_baseColorSampler", "HAS_BASECOLORMAP", t), t.uniforms.baseColorFactor = e.baseColorFactor || [1, 1, 1, 1], e.metallicRoughnessTexture && ag(r, e.metallicRoughnessTexture, "pbr_metallicRoughnessSampler", "HAS_METALROUGHNESSMAP", t);
  const {
    metallicFactor: n = 1,
    roughnessFactor: i = 1
  } = e;
  t.uniforms.metallicRoughnessValues = [n, i];
}
function ag(r, e, t) {
  var b, T;
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null, i = arguments.length > 4 ? arguments[4] : void 0;
  const s = ((T = (b = e == null ? void 0 : e.texture) == null ? void 0 : b.sampler) == null ? void 0 : T.parameters) || {}, l = e.texture.source.image;
  let o, d = {};
  l.compressed ? (o = l, d = {
    [vc.TEXTURE_MIN_FILTER]: l.data.length > 1 ? vc.LINEAR_MIPMAP_NEAREST : vc.LINEAR
  }) : o = {
    data: l
  };
  const m = r.createTexture({
    id: e.uniformName || e.id,
    parameters: {
      ...s,
      ...d
    },
    pixelStore: {
      [vc.UNPACK_FLIP_Y_WEBGL]: !1
    },
    ...o
  });
  i.bindings[t] = m, n && (i.defines[n] = 1), i.generatedTextures.push(m);
}
const gj = "4.3.2", $_ = {
  /** Basis transcoder, javascript wrapper part */
  TRANSCODER: "basis_transcoder.js",
  /** Basis transcoder, compiled web assembly part */
  TRANSCODER_WASM: "basis_transcoder.wasm",
  /** Basis encoder, javascript wrapper part */
  ENCODER: "basis_encoder.js",
  /** Basis encoder, compiled web assembly part */
  ENCODER_WASM: "basis_encoder.wasm"
};
let h3;
async function f3(r) {
  v4(r.modules);
  const e = x4("basis");
  return e || (h3 || (h3 = mj(r)), await h3);
}
async function mj(r) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await mf($_.TRANSCODER, "textures", r), await mf($_.TRANSCODER_WASM, "textures", r)]), e = e || globalThis.BASIS, await _j(e, t);
}
function _j(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((n) => {
    r(t).then((i) => {
      const {
        BasisFile: s,
        initializeBasis: l
      } = i;
      l(), n({
        BasisFile: s
      });
    });
  });
}
let bb;
async function d3(r) {
  const e = r.modules || {};
  return e.basisEncoder ? e.basisEncoder : (bb = bb || yj(r), await bb);
}
async function yj(r) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await mf($_.ENCODER, "textures", r), await mf($_.ENCODER_WASM, "textures", r)]), e = e || globalThis.BASIS, await bj(e, t);
}
function bj(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((n) => {
    r(t).then((i) => {
      const {
        BasisFile: s,
        KTX2File: l,
        initializeBasis: o,
        BasisEncoder: d
      } = i;
      o(), n({
        BasisFile: s,
        KTX2File: l,
        BasisEncoder: d
      });
    });
  });
}
const ad = {
  // WEBGL_compressed_texture_s3tc
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  // WEBGL_compressed_texture_pvrtc
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  // WEBGL_compressed_texture_etc1
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  // WEBGL_compressed_texture_astc
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808
}, vj = ["", "WEBKIT_", "MOZ_"], p3 = {
  /* eslint-disable camelcase */
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
  /* eslint-enable camelcase */
};
let Mm = null;
function xj(r) {
  if (!Mm) {
    r = r || wj() || void 0, Mm = /* @__PURE__ */ new Set();
    for (const e of vj)
      for (const t in p3)
        if (r && r.getExtension(`${e}${t}`)) {
          const n = p3[t];
          Mm.add(n);
        }
  }
  return Mm;
}
function wj() {
  try {
    return document.createElement("canvas").getContext("webgl");
  } catch {
    return null;
  }
}
const Wa = [
  // '', 'K', 'T', 'X', '2', '0', '', '\r', '\n', '\x1A', '\n'
  171,
  75,
  84,
  88,
  32,
  50,
  48,
  187,
  13,
  10,
  26,
  10
];
function Aj(r) {
  const e = new Uint8Array(r);
  return !(e.byteLength < Wa.length || e[0] !== Wa[0] || // ''
  e[1] !== Wa[1] || // 'K'
  e[2] !== Wa[2] || // 'T'
  e[3] !== Wa[3] || // 'X'
  e[4] !== Wa[4] || // ' '
  e[5] !== Wa[5] || // '2'
  e[6] !== Wa[6] || // '0'
  e[7] !== Wa[7] || // ''
  e[8] !== Wa[8] || // '\r'
  e[9] !== Wa[9] || // '\n'
  e[10] !== Wa[10] || // '\x1A'
  e[11] !== Wa[11]);
}
const Tj = {
  etc1: {
    basisFormat: 0,
    compressed: !0,
    format: ad.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: {
    basisFormat: 1,
    compressed: !0
  },
  bc1: {
    basisFormat: 2,
    compressed: !0,
    format: ad.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: !0,
    format: ad.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: {
    basisFormat: 4,
    compressed: !0
  },
  bc5: {
    basisFormat: 5,
    compressed: !0
  },
  "bc7-m6-opaque-only": {
    basisFormat: 6,
    compressed: !0
  },
  "bc7-m5": {
    basisFormat: 7,
    compressed: !0
  },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: !0,
    format: ad.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: !0,
    format: ad.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: !0,
    format: ad.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": {
    basisFormat: 11,
    compressed: !0
  },
  "atc-rgba-interpolated-alpha": {
    basisFormat: 12,
    compressed: !0
  },
  rgba32: {
    basisFormat: 13,
    compressed: !1
  },
  rgb565: {
    basisFormat: 14,
    compressed: !1
  },
  bgr565: {
    basisFormat: 15,
    compressed: !1
  },
  rgba4444: {
    basisFormat: 16,
    compressed: !1
  }
};
async function Sj(r, e) {
  if (e.basis.containerFormat === "auto") {
    if (Aj(r)) {
      const n = await d3(e);
      return g3(n.KTX2File, r, e);
    }
    const {
      BasisFile: t
    } = await f3(e);
    return vb(t, r, e);
  }
  switch (e.basis.module) {
    case "encoder":
      const t = await d3(e);
      switch (e.basis.containerFormat) {
        case "ktx2":
          return g3(t.KTX2File, r, e);
        case "basis":
        default:
          return vb(t.BasisFile, r, e);
      }
    case "transcoder":
    default:
      const {
        BasisFile: n
      } = await f3(e);
      return vb(n, r, e);
  }
}
function vb(r, e, t) {
  const n = new r(new Uint8Array(e));
  try {
    if (!n.startTranscoding())
      throw new Error("Failed to start basis transcoding");
    const i = n.getNumImages(), s = [];
    for (let l = 0; l < i; l++) {
      const o = n.getNumLevels(l), d = [];
      for (let m = 0; m < o; m++)
        d.push(Ej(n, l, m, t));
      s.push(d);
    }
    return s;
  } finally {
    n.close(), n.delete();
  }
}
function Ej(r, e, t, n) {
  const i = r.getImageWidth(e, t), s = r.getImageHeight(e, t), l = r.getHasAlpha(
    /* imageIndex, levelIndex */
  ), {
    compressed: o,
    format: d,
    basisFormat: m
  } = sI(n, l), b = r.getImageTranscodedSizeInBytes(e, t, m), T = new Uint8Array(b);
  if (!r.transcodeImage(T, e, t, m, 0, 0))
    throw new Error("failed to start Basis transcoding");
  return {
    // standard loaders.gl image category payload
    width: i,
    height: s,
    data: T,
    compressed: o,
    format: d,
    // Additional fields
    // Add levelSize field.
    hasAlpha: l
  };
}
function g3(r, e, t) {
  const n = new r(new Uint8Array(e));
  try {
    if (!n.startTranscoding())
      throw new Error("failed to start KTX2 transcoding");
    const i = n.getLevels(), s = [];
    for (let l = 0; l < i; l++)
      s.push(Cj(n, l, t));
    return [s];
  } finally {
    n.close(), n.delete();
  }
}
function Cj(r, e, t) {
  const {
    alphaFlag: n,
    height: i,
    width: s
  } = r.getImageLevelInfo(e, 0, 0), {
    compressed: l,
    format: o,
    basisFormat: d
  } = sI(t, n), m = r.getImageTranscodedSizeInBytes(e, 0, 0, d), b = new Uint8Array(m);
  if (!r.transcodeImage(
    b,
    e,
    0,
    0,
    d,
    0,
    -1,
    -1
    /* channel1 */
  ))
    throw new Error("Failed to transcode KTX2 image");
  return {
    // standard loaders.gl image category payload
    width: s,
    height: i,
    data: b,
    compressed: l,
    // Additional fields
    levelSize: m,
    hasAlpha: n,
    format: o
  };
}
function sI(r, e) {
  let t = r && r.basis && r.basis.format;
  return t === "auto" && (t = oI()), typeof t == "object" && (t = e ? t.alpha : t.noAlpha), t = t.toLowerCase(), Tj[t];
}
function oI() {
  const r = xj();
  return r.has("astc") ? "astc-4x4" : r.has("dxt") ? {
    alpha: "bc3",
    noAlpha: "bc1"
  } : r.has("pvrtc") ? {
    alpha: "pvrtc1-4-rgba",
    noAlpha: "pvrtc1-4-rgb"
  } : r.has("etc1") ? "etc1" : r.has("etc2") ? "etc2" : "rgb565";
}
const Ij = {
  dataType: null,
  batchType: null,
  name: "Basis",
  id: "basis",
  module: "textures",
  version: gj,
  worker: !0,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: !0,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
}, Mj = {
  ...Ij,
  parse: Sj
}, Pj = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Rj = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
class Bj {
  constructor(e) {
    H(this, "name");
    H(this, "startTime", 0);
    H(this, "playing", !0);
    H(this, "speed", 1);
    H(this, "channels", []);
    Object.assign(this, e);
  }
  animate(e) {
    if (!this.playing)
      return;
    const n = (e / 1e3 - this.startTime) * this.speed;
    this.channels.forEach((i) => {
      let {
        sampler: s,
        target: l,
        path: o
      } = i;
      Uj(n, s, l, o), Nj(l, l._node);
    });
  }
}
class Lj {
  constructor(e) {
    H(this, "animations");
    this.animations = e.animations.map((t, n) => {
      const i = t.name || `Animation-${n}`, s = t.samplers.map((o) => {
        let {
          input: d,
          interpolation: m = "LINEAR",
          output: b
        } = o;
        return {
          input: m3(e.accessors[d]),
          interpolation: m,
          output: m3(e.accessors[b])
        };
      }), l = t.channels.map((o) => {
        let {
          sampler: d,
          target: m
        } = o;
        return {
          sampler: s[d],
          target: e.nodes[m.node],
          path: m.path
        };
      });
      return new Bj({
        name: i,
        channels: l
      });
    });
  }
  /** @deprecated Use .setTime(). Will be removed (deck.gl is using this) */
  animate(e) {
    this.setTime(e);
  }
  setTime(e) {
    this.animations.forEach((t) => t.animate(e));
  }
  getAnimations() {
    return this.animations;
  }
}
function m3(r) {
  if (!r._animation) {
    const e = Rj[r.componentType], t = Pj[r.type], n = t * r.count, {
      buffer: i,
      byteOffset: s
    } = r.bufferView.data, l = new e(i, s + (r.byteOffset || 0), n);
    if (t === 1)
      r._animation = Array.from(l);
    else {
      const o = [];
      for (let d = 0; d < l.length; d += t)
        o.push(Array.from(l.slice(d, d + t)));
      r._animation = o;
    }
  }
  return r._animation;
}
const Oj = new Cn();
function Nj(r, e) {
  if (e.matrix.identity(), r.translation && e.matrix.translate(r.translation), r.rotation) {
    const t = Oj.fromQuaternion(r.rotation);
    e.matrix.multiplyRight(t);
  }
  r.scale && e.matrix.scale(r.scale);
}
const xb = new fg();
function Dj(r, e, t, n, i) {
  if (e === "rotation") {
    xb.slerp({
      start: t,
      target: n,
      ratio: i
    });
    for (let s = 0; s < xb.length; s++)
      r[e][s] = xb[s];
  } else
    for (let s = 0; s < t.length; s++)
      r[e][s] = i * n[s] + (1 - i) * t[s];
}
function kj(r, e, t) {
  let {
    p0: n,
    outTangent0: i,
    inTangent1: s,
    p1: l,
    tDiff: o,
    ratio: d
  } = t;
  for (let m = 0; m < r[e].length; m++) {
    const b = i[m] * o, T = s[m] * o;
    r[e][m] = (2 * Math.pow(d, 3) - 3 * Math.pow(d, 2) + 1) * n[m] + (Math.pow(d, 3) - 2 * Math.pow(d, 2) + d) * b + (-2 * Math.pow(d, 3) + 3 * Math.pow(d, 2)) * l[m] + (Math.pow(d, 3) - Math.pow(d, 2)) * T;
  }
}
function Fj(r, e, t) {
  for (let n = 0; n < t.length; n++)
    r[e][n] = t[n];
}
function Uj(r, e, t, n) {
  let {
    input: i,
    interpolation: s,
    output: l
  } = e;
  const o = i[i.length - 1], d = r % o, m = i.findIndex((E) => E >= d), b = Math.max(0, m - 1);
  if (!Array.isArray(t[n]))
    switch (n) {
      case "translation":
        t[n] = [0, 0, 0];
        break;
      case "rotation":
        t[n] = [0, 0, 0, 1];
        break;
      case "scale":
        t[n] = [1, 1, 1];
        break;
      default:
        lr.warn(`Bad animation path ${n}`)();
    }
  const T = i[b], M = i[m];
  switch (s) {
    case "STEP":
      Fj(t, n, l[b]);
      break;
    case "LINEAR":
      if (M > T) {
        const E = (d - T) / (M - T);
        Dj(t, n, l[b], l[m], E);
      }
      break;
    case "CUBICSPLINE":
      if (M > T) {
        const E = (d - T) / (M - T), D = M - T, U = l[3 * b + 1], q = l[3 * b + 2], G = l[3 * m + 0], Y = l[3 * m + 1];
        kj(t, n, {
          p0: U,
          outTangent0: q,
          inTangent1: G,
          p1: Y,
          tDiff: D,
          ratio: E
        });
      }
      break;
    default:
      lr.warn(`Interpolation ${s} not supported`)();
      break;
  }
}
const zj = (
  /* WGSL */
  `
layout(0) positions: vec4; // in vec4 POSITION;

  #ifdef HAS_NORMALS
    in vec4 normals; // in vec4 NORMAL;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

@vertex
  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }

@fragment
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
), jj = (
  /* glsl */
  `#version 300 es

  // in vec4 POSITION;
  in vec4 positions;

  #ifdef HAS_NORMALS
    // in vec4 NORMAL;
    in vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;
  }
`
), Vj = (
  /* glsl */
  `#version 300 es
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`
);
function qj(r, e) {
  const {
    id: t,
    geometry: n,
    material: i,
    vertexCount: s,
    materialOptions: l,
    modelOptions: o
  } = e, d = iI(r, i, n.attributes, l);
  lr.info(4, "createGLTFModel defines: ", d.defines)();
  const m = [], b = {
    depthWriteEnabled: !0,
    depthCompare: "less",
    depthFormat: "depth24plus",
    cullMode: "back"
  }, T = {
    id: t,
    source: zj,
    vs: jj,
    fs: Vj,
    geometry: n,
    topology: n.topology,
    vertexCount: s,
    modules: [_2],
    ...o,
    defines: {
      ...d.defines,
      ...o.defines
    },
    parameters: {
      ...b,
      ...d.parameters,
      ...o.parameters
    }
  }, M = new Lh(r, T), {
    camera: E,
    ...D
  } = {
    ...d.uniforms,
    ...o.uniforms,
    ...d.bindings,
    ...o.bindings
  };
  return M.shaderInputs.setProps({
    pbrMaterial: D,
    pbrProjection: {
      camera: E
    }
  }), new Z1({
    managedResources: m,
    model: M
  });
}
var of;
(function(r) {
  r[r.POINTS = 0] = "POINTS", r[r.LINES = 1] = "LINES", r[r.LINE_LOOP = 2] = "LINE_LOOP", r[r.LINE_STRIP = 3] = "LINE_STRIP", r[r.TRIANGLES = 4] = "TRIANGLES", r[r.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", r[r.TRIANGLE_FAN = 6] = "TRIANGLE_FAN";
})(of || (of = {}));
function Gj(r) {
  switch (r) {
    case of.POINTS:
      return "point-list";
    case of.LINES:
      return "line-list";
    case of.LINE_STRIP:
      return "line-strip";
    case of.TRIANGLES:
      return "triangle-list";
    case of.TRIANGLE_STRIP:
      return "triangle-strip";
    default:
      throw new Error(String(r));
  }
}
const $j = {
  modelOptions: {},
  pbrDebug: !1,
  imageBasedLightingEnvironment: null,
  lights: !0,
  useTangents: !1
};
class Hj {
  constructor(e) {
    H(this, "device");
    H(this, "options");
    H(this, "gltf");
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.device = e, this.options = {
      ...$j,
      ...t
    };
  }
  instantiate(e) {
    return this.gltf = lv(e), (this.gltf.scenes || []).map((n) => this.createScene(n));
  }
  createAnimator() {
    return Array.isArray(this.gltf.animations) ? new Lj(this.gltf) : null;
  }
  createScene(e) {
    const n = (e.nodes || []).map((s) => this.createNode(s));
    return new Md({
      id: e.name || e.id,
      children: n
    });
  }
  createNode(e) {
    if (!e._node) {
      const i = (e.children || []).map((l) => this.createNode(l));
      e.mesh && i.push(this.createMesh(e.mesh));
      const s = new Md({
        id: e.name || e.id,
        children: i
      });
      if (e.matrix)
        s.setMatrix(e.matrix);
      else {
        if (s.matrix.identity(), e.translation && s.matrix.translate(e.translation), e.rotation) {
          const l = new Cn().fromQuaternion(e.rotation);
          s.matrix.multiplyRight(l);
        }
        e.scale && s.matrix.scale(e.scale);
      }
      e._node = s;
    }
    const t = this.gltf.nodes.find((n) => n.id === e.id);
    return t._node = e._node, e._node;
  }
  createMesh(e) {
    if (!e._mesh) {
      const n = (e.primitives || []).map((s, l) => this.createPrimitive(s, l, e)), i = new Md({
        id: e.name || e.id,
        children: n
      });
      e._mesh = i;
    }
    return e._mesh;
  }
  createPrimitive(e, t, n) {
    const i = e.name || `${n.name || n.id}-primitive-${t}`, s = Gj(e.mode || 4), l = e.indices ? e.indices.count : this.getVertexCount(e.attributes), o = qj(this.device, {
      id: i,
      geometry: this.createGeometry(i, e, s),
      material: e.material,
      materialOptions: this.options,
      modelOptions: this.options.modelOptions,
      vertexCount: l
    });
    return o.bounds = [e.attributes.POSITION.min, e.attributes.POSITION.max], o;
  }
  getVertexCount(e) {
    throw new Error("getVertexCount not implemented");
  }
  createGeometry(e, t, n) {
    const i = {};
    for (const [s, l] of Object.entries(t.attributes)) {
      const {
        components: o,
        size: d,
        value: m
      } = l;
      i[s] = {
        size: d ?? o,
        value: m
      };
    }
    return new Id({
      id: e,
      topology: n,
      indices: t.indices.value,
      attributes: i
    });
  }
  createBuffer(e, t) {
    e.bufferView || (e.bufferView = {});
    const {
      bufferView: n
    } = e;
    return n.lumaBuffers || (n.lumaBuffers = {}), n.lumaBuffers[t] || (n.lumaBuffers[t] = this.device.createBuffer({
      id: `from-${n.id}`,
      // Draco decoded files have attribute.value
      data: n.data || e.value
    })), n.lumaBuffers[t];
  }
  // TODO - create sampler in WebGL2
  createSampler(e) {
    return e;
  }
  // Helper methods (move to GLTFLoader.resolve...?)
  needsPOT() {
    return !1;
  }
}
function lv(r) {
  if (ArrayBuffer.isView(r) || r instanceof ArrayBuffer || r instanceof ImageBitmap)
    return r;
  if (Array.isArray(r))
    return r.map(lv);
  if (r && typeof r == "object") {
    const e = {};
    for (const t in r)
      e[t] = lv(r[t]);
    return e;
  }
  return r;
}
function Wj(r, e, t) {
  const n = new Hj(r, t), i = n.instantiate(e), s = n.createAnimator();
  return {
    scenes: i,
    animator: s
  };
}
function Ja(r, e) {
  if (!r)
    throw new Error(e || "assert failed: gltf");
}
const aI = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, lI = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, Xj = 1.33, _3 = ["SCALAR", "VEC2", "VEC3", "VEC4"], Zj = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]], Yj = new Map(Zj), Kj = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Jj = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, Qj = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function cI(r) {
  return _3[r - 1] || _3[0];
}
function Ty(r) {
  const e = Yj.get(r.constructor);
  if (!e)
    throw new Error("Illegal typed array");
  return e;
}
function k2(r, e) {
  const t = Qj[r.componentType], n = Kj[r.type], i = Jj[r.componentType], s = r.count * n, l = r.count * n * i;
  Ja(l >= 0 && l <= e.byteLength);
  const o = lI[r.componentType], d = aI[r.type];
  return {
    ArrayType: t,
    length: s,
    byteLength: l,
    componentByteSize: o,
    numberOfComponentsInElement: d
  };
}
function uI(r) {
  let {
    images: e,
    bufferViews: t
  } = r;
  e = e || [], t = t || [];
  const n = e.map((l) => l.bufferView);
  t = t.filter((l) => !n.includes(l));
  const i = t.reduce((l, o) => l + o.byteLength, 0), s = e.reduce((l, o) => {
    const {
      width: d,
      height: m
    } = o.image;
    return l + d * m;
  }, 0);
  return i + Math.ceil(4 * s * Xj);
}
function eV(r, e, t) {
  const n = r.bufferViews[t];
  Ja(n);
  const i = n.buffer, s = e[i];
  Ja(s);
  const l = (n.byteOffset || 0) + s.byteOffset;
  return new Uint8Array(s.arrayBuffer, l, n.byteLength);
}
function tV(r, e, t) {
  var U, q;
  const n = typeof t == "number" ? (U = r.accessors) == null ? void 0 : U[t] : t;
  if (!n)
    throw new Error(`No gltf accessor ${JSON.stringify(t)}`);
  const i = (q = r.bufferViews) == null ? void 0 : q[n.bufferView || 0];
  if (!i)
    throw new Error(`No gltf buffer view for accessor ${i}`);
  const {
    arrayBuffer: s,
    byteOffset: l
  } = e[i.buffer], o = (l || 0) + (n.byteOffset || 0) + (i.byteOffset || 0), {
    ArrayType: d,
    length: m,
    componentByteSize: b,
    numberOfComponentsInElement: T
  } = k2(n, i), M = b * T, E = i.byteStride || M;
  if (typeof i.byteStride > "u" || i.byteStride === M)
    return new d(s, o, m);
  const D = new d(m);
  for (let G = 0; G < n.count; G++) {
    const Y = new d(s, o + G * E, T);
    D.set(Y, G * T);
  }
  return D;
}
function rV() {
  return {
    asset: {
      version: "2.0",
      generator: "loaders.gl"
    },
    buffers: [],
    extensions: {},
    extensionsRequired: [],
    extensionsUsed: []
  };
}
class lo {
  // TODO - why is this not GLTFWithBuffers - what happens to images?
  constructor(e) {
    // internal
    H(this, "gltf");
    H(this, "sourceBuffers");
    H(this, "byteLength");
    this.gltf = {
      json: (e == null ? void 0 : e.json) || rV(),
      buffers: (e == null ? void 0 : e.buffers) || [],
      images: (e == null ? void 0 : e.images) || []
    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);
  }
  // Accessors
  get json() {
    return this.gltf.json;
  }
  getApplicationData(e) {
    return this.json[e];
  }
  getExtraData(e) {
    return (this.json.extras || {})[e];
  }
  hasExtension(e) {
    const t = this.getUsedExtensions().find((i) => i === e), n = this.getRequiredExtensions().find((i) => i === e);
    return typeof t == "string" || typeof n == "string";
  }
  getExtension(e) {
    const t = this.getUsedExtensions().find((i) => i === e), n = this.json.extensions || {};
    return t ? n[e] : null;
  }
  getRequiredExtension(e) {
    return this.getRequiredExtensions().find((n) => n === e) ? this.getExtension(e) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(e, t) {
    return (e.extensions || {})[t];
  }
  getScene(e) {
    return this.getObject("scenes", e);
  }
  getNode(e) {
    return this.getObject("nodes", e);
  }
  getSkin(e) {
    return this.getObject("skins", e);
  }
  getMesh(e) {
    return this.getObject("meshes", e);
  }
  getMaterial(e) {
    return this.getObject("materials", e);
  }
  getAccessor(e) {
    return this.getObject("accessors", e);
  }
  // getCamera(index: number): object | null {
  //   return null; // TODO: fix thi: object  as null;
  // }
  getTexture(e) {
    return this.getObject("textures", e);
  }
  getSampler(e) {
    return this.getObject("samplers", e);
  }
  getImage(e) {
    return this.getObject("images", e);
  }
  getBufferView(e) {
    return this.getObject("bufferViews", e);
  }
  getBuffer(e) {
    return this.getObject("buffers", e);
  }
  getObject(e, t) {
    if (typeof t == "object")
      return t;
    const n = this.json[e] && this.json[e][t];
    if (!n)
      throw new Error(`glTF file error: Could not find ${e}[${t}]`);
    return n;
  }
  /**
   * Accepts buffer view index or buffer view object
   * @returns a `Uint8Array`
   */
  getTypedArrayForBufferView(e) {
    e = this.getBufferView(e);
    const t = e.buffer, n = this.gltf.buffers[t];
    Ja(n);
    const i = (e.byteOffset || 0) + n.byteOffset;
    return new Uint8Array(n.arrayBuffer, i, e.byteLength);
  }
  /** Accepts accessor index or accessor object
   * @returns a typed array with type that matches the types
   */
  getTypedArrayForAccessor(e) {
    const t = this.getAccessor(e);
    return tV(this.gltf.json, this.gltf.buffers, t);
  }
  /** accepts accessor index or accessor object
   * returns a `Uint8Array`
   */
  getTypedArrayForImageData(e) {
    e = this.getAccessor(e);
    const t = this.getBufferView(e.bufferView), i = this.getBuffer(t.buffer).data, s = t.byteOffset || 0;
    return new Uint8Array(i, s, t.byteLength);
  }
  // MODIFERS
  /**
   * Add an extra application-defined key to the top-level data structure
   */
  addApplicationData(e, t) {
    return this.json[e] = t, this;
  }
  /**
   * `extras` - Standard GLTF field for storing application specific data
   */
  addExtraData(e, t) {
    return this.json.extras = this.json.extras || {}, this.json.extras[e] = t, this;
  }
  addObjectExtension(e, t, n) {
    return e.extensions = e.extensions || {}, e.extensions[t] = n, this.registerUsedExtension(t), this;
  }
  setObjectExtension(e, t, n) {
    const i = e.extensions || {};
    i[t] = n;
  }
  removeObjectExtension(e, t) {
    const n = (e == null ? void 0 : e.extensions) || {};
    if (n[t]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const i = this.json.extensionsRemoved;
      i.includes(t) || i.push(t);
    }
    delete n[t];
  }
  /**
   * Add to standard GLTF top level extension object, mark as used
   */
  addExtension(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Ja(t), this.json.extensions = this.json.extensions || {}, this.json.extensions[e] = t, this.registerUsedExtension(e), t;
  }
  /**
   * Standard GLTF top level extension object, mark as used and required
   */
  addRequiredExtension(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Ja(t), this.addExtension(e, t), this.registerRequiredExtension(e), t;
  }
  /**
   * Add extensionName to list of used extensions
   */
  registerUsedExtension(e) {
    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((t) => t === e) || this.json.extensionsUsed.push(e);
  }
  /**
   * Add extensionName to list of required extensions
   */
  registerRequiredExtension(e) {
    this.registerUsedExtension(e), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((t) => t === e) || this.json.extensionsRequired.push(e);
  }
  /**
   * Removes an extension from the top-level list
   */
  removeExtension(e) {
    var t;
    if ((t = this.json.extensions) != null && t[e]) {
      this.json.extensionsRemoved = this.json.extensionsRemoved || [];
      const n = this.json.extensionsRemoved;
      n.includes(e) || n.push(e);
    }
    this.json.extensions && delete this.json.extensions[e], this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, e), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e);
  }
  /**
   *  Set default scene which is to be displayed at load time
   */
  setDefaultScene(e) {
    this.json.scene = e;
  }
  /**
   * @todo: add more properties for scene initialization:
   *   name`, `extensions`, `extras`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-scene
   */
  addScene(e) {
    const {
      nodeIndices: t
    } = e;
    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({
      nodes: t
    }), this.json.scenes.length - 1;
  }
  /**
   * @todo: add more properties for node initialization:
   *   `name`, `extensions`, `extras`, `camera`, `children`, `skin`, `rotation`, `scale`, `translation`, `weights`
   *   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#node
   */
  addNode(e) {
    const {
      meshIndex: t,
      matrix: n
    } = e;
    this.json.nodes = this.json.nodes || [];
    const i = {
      mesh: t
    };
    return n && (i.matrix = n), this.json.nodes.push(i), this.json.nodes.length - 1;
  }
  /** Adds a mesh to the json part */
  addMesh(e) {
    const {
      attributes: t,
      indices: n,
      material: i,
      mode: s = 4
    } = e, o = {
      primitives: [{
        attributes: this._addAttributes(t),
        mode: s
      }]
    };
    if (n) {
      const d = this._addIndices(n);
      o.primitives[0].indices = d;
    }
    return Number.isFinite(i) && (o.primitives[0].material = i), this.json.meshes = this.json.meshes || [], this.json.meshes.push(o), this.json.meshes.length - 1;
  }
  addPointCloud(e) {
    const n = {
      primitives: [{
        attributes: this._addAttributes(e),
        mode: 0
        // GL.POINTS
      }]
    };
    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(n), this.json.meshes.length - 1;
  }
  /**
   * Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes as glTF image
   * @param imageData
   * @param mimeType
   */
  addImage(e, t) {
    const n = Jv(e), i = t || (n == null ? void 0 : n.mimeType), l = {
      bufferView: this.addBufferView(e),
      mimeType: i
    };
    return this.json.images = this.json.images || [], this.json.images.push(l), this.json.images.length - 1;
  }
  /**
   * Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
   * @param buffer
   */
  addBufferView(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.byteLength;
    const i = e.byteLength;
    Ja(Number.isFinite(i)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(e);
    const s = {
      buffer: t,
      // Write offset from the start of the binary body
      byteOffset: n,
      byteLength: i
    };
    return this.byteLength += Cg(i, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(s), this.json.bufferViews.length - 1;
  }
  /**
   * Adds an accessor to a bufferView
   * @param bufferViewIndex
   * @param accessor
   */
  addAccessor(e, t) {
    const n = {
      bufferView: e,
      // @ts-ignore
      type: cI(t.size),
      // @ts-ignore
      componentType: t.componentType,
      // @ts-ignore
      count: t.count,
      // @ts-ignore
      max: t.max,
      // @ts-ignore
      min: t.min
    };
    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(n), this.json.accessors.length - 1;
  }
  /**
   * Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
   * Buffer will be copied into BIN chunk during "pack"
   * Currently encodes buffers as glTF accessors, but this could be optimized
   * @param sourceBuffer
   * @param accessor
   */
  addBinaryBuffer(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      size: 3
    };
    const n = this.addBufferView(e);
    let i = {
      min: t.min,
      max: t.max
    };
    (!i.min || !i.max) && (i = this._getAccessorMinMax(e, t.size));
    const s = {
      // @ts-ignore
      size: t.size,
      componentType: Ty(e),
      // @ts-ignore
      count: Math.round(e.length / t.size),
      min: i.min,
      max: i.max
    };
    return this.addAccessor(n, Object.assign(s, t));
  }
  /**
   * Adds a texture to the json part
   * @todo: add more properties for texture initialization
   * `sampler`, `name`, `extensions`, `extras`
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
   */
  addTexture(e) {
    const {
      imageIndex: t
    } = e, n = {
      source: t
    };
    return this.json.textures = this.json.textures || [], this.json.textures.push(n), this.json.textures.length - 1;
  }
  /** Adds a material to the json part */
  addMaterial(e) {
    return this.json.materials = this.json.materials || [], this.json.materials.push(e), this.json.materials.length - 1;
  }
  /** Pack the binary chunk */
  createBinaryChunk() {
    var s, l;
    const e = this.byteLength, t = new ArrayBuffer(e), n = new Uint8Array(t);
    let i = 0;
    for (const o of this.sourceBuffers || [])
      i = H4(o, n, i);
    (l = (s = this.json) == null ? void 0 : s.buffers) != null && l[0] ? this.json.buffers[0].byteLength = e : this.json.buffers = [{
      byteLength: e
    }], this.gltf.binary = t, this.sourceBuffers = [t], this.gltf.buffers = [{
      arrayBuffer: t,
      byteOffset: 0,
      byteLength: t.byteLength
    }];
  }
  // PRIVATE
  _removeStringFromArray(e, t) {
    let n = !0;
    for (; n; ) {
      const i = e.indexOf(t);
      i > -1 ? e.splice(i, 1) : n = !1;
    }
  }
  /**
   * Add attributes to buffers and create `attributes` object which is part of `mesh`
   */
  _addAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = {};
    for (const n in e) {
      const i = e[n], s = this._getGltfAttributeName(n), l = this.addBinaryBuffer(i.value, i);
      t[s] = l;
    }
    return t;
  }
  /**
   * Add indices to buffers
   */
  _addIndices(e) {
    return this.addBinaryBuffer(e, {
      size: 1
    });
  }
  /**
   * Deduce gltf specific attribue name from input attribute name
   */
  _getGltfAttributeName(e) {
    switch (e.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return e;
    }
  }
  /**
   * Calculate `min` and `max` arrays of accessor according to spec:
   * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#reference-accessor
   */
  _getAccessorMinMax(e, t) {
    const n = {
      min: null,
      max: null
    };
    if (e.length < t)
      return n;
    n.min = [], n.max = [];
    const i = e.subarray(0, t);
    for (const s of i)
      n.min.push(s), n.max.push(s);
    for (let s = t; s < e.length; s += t)
      for (let l = 0; l < t; l++)
        n.min[0 + l] = Math.min(
          // @ts-ignore
          n.min[0 + l],
          e[s + l]
        ), n.max[0 + l] = Math.max(
          // @ts-ignore
          n.max[0 + l],
          e[s + l]
        );
    return n;
  }
}
function y3(r) {
  return (r % 1 + 1) % 1;
}
const hI = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
  BOOLEAN: 1,
  STRING: 1,
  ENUM: 1
}, nV = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: BigInt64Array,
  UINT64: BigUint64Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
}, fI = {
  INT8: 1,
  UINT8: 1,
  INT16: 2,
  UINT16: 2,
  INT32: 4,
  UINT32: 4,
  INT64: 8,
  UINT64: 8,
  FLOAT32: 4,
  FLOAT64: 8
};
function F2(r, e) {
  return fI[e] * hI[r];
}
function Sy(r, e, t, n) {
  if (t !== "UINT8" && t !== "UINT16" && t !== "UINT32" && t !== "UINT64")
    return null;
  const i = r.getTypedArrayForBufferView(e), s = Ey(
    i,
    "SCALAR",
    // offsets consist of ONE component
    t,
    n + 1
    // The number of offsets is equal to the property table `count` plus one.
  );
  return s instanceof BigInt64Array || s instanceof BigUint64Array ? null : s;
}
function Ey(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  const i = hI[e], s = nV[t], l = fI[t], o = n * i, d = o * l;
  let m = r.buffer, b = r.byteOffset;
  return b % l !== 0 && (m = new Uint8Array(m).slice(b, b + d).buffer, b = 0), new s(m, b, o);
}
function U2(r, e, t) {
  var m, b, T, M, E;
  const n = `TEXCOORD_${e.texCoord || 0}`, i = t.attributes[n], s = r.getTypedArrayForAccessor(i), l = r.gltf.json, o = e.index, d = (b = (m = l.textures) == null ? void 0 : m[o]) == null ? void 0 : b.source;
  if (typeof d < "u") {
    const D = (M = (T = l.images) == null ? void 0 : T[d]) == null ? void 0 : M.mimeType, U = (E = r.gltf.images) == null ? void 0 : E[d];
    if (U && typeof U.width < "u") {
      const q = [];
      for (let G = 0; G < s.length; G += 2) {
        const Y = iV(U, D, s, G, e.channels);
        q.push(Y);
      }
      return q;
    }
  }
  return [];
}
function dI(r, e, t, n, i) {
  if (!(t != null && t.length))
    return;
  const s = [];
  for (const b of t) {
    let T = n.findIndex((M) => M === b);
    T === -1 && (T = n.push(b) - 1), s.push(T);
  }
  const l = new Uint32Array(s), o = r.gltf.buffers.push({
    arrayBuffer: l.buffer,
    byteOffset: l.byteOffset,
    byteLength: l.byteLength
  }) - 1, d = r.addBufferView(l, o, 0), m = r.addAccessor(d, {
    size: 1,
    componentType: Ty(l),
    count: l.length
  });
  i.attributes[e] = m;
}
function iV(r, e, t, n) {
  let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : [0];
  const s = {
    r: {
      offset: 0,
      shift: 0
    },
    g: {
      offset: 1,
      shift: 8
    },
    b: {
      offset: 2,
      shift: 16
    },
    a: {
      offset: 3,
      shift: 24
    }
  }, l = t[n], o = t[n + 1];
  let d = 1;
  e && (e.indexOf("image/jpeg") !== -1 || e.indexOf("image/png") !== -1) && (d = 4);
  const m = sV(l, o, r, d);
  let b = 0;
  for (const T of i) {
    const M = typeof T == "number" ? Object.values(s)[T] : s[T], E = m + M.offset, D = BE(r);
    if (D.data.length <= E)
      throw new Error(`${D.data.length} <= ${E}`);
    const U = D.data[E];
    b |= U << M.shift;
  }
  return b;
}
function sV(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  const i = t.width, s = y3(r) * (i - 1), l = Math.round(s), o = t.height, d = y3(e) * (o - 1), m = Math.round(d), b = t.components ? t.components : n;
  return (m * i + l) * b;
}
function pI(r, e, t, n, i) {
  const s = [];
  for (let l = 0; l < e; l++) {
    const o = t[l], d = t[l + 1] - t[l];
    if (d + o > n)
      break;
    const m = o / i, b = d / i;
    s.push(r.slice(m, m + b));
  }
  return s;
}
function gI(r, e, t) {
  const n = [];
  for (let i = 0; i < e; i++) {
    const s = i * t;
    n.push(r.slice(s, s + t));
  }
  return n;
}
function mI(r, e, t, n) {
  if (t)
    throw new Error("Not implemented - arrayOffsets for strings is specified");
  if (n) {
    const i = [], s = new TextDecoder("utf8");
    let l = 0;
    for (let o = 0; o < r; o++) {
      const d = n[o + 1] - n[o];
      if (d + l <= e.length) {
        const m = e.subarray(l, d + l), b = s.decode(m);
        i.push(b), l += d;
      }
    }
    return i;
  }
  return [];
}
const Rd = "EXT_mesh_features", oV = Rd;
async function aV(r, e) {
  const t = new lo(r);
  cV(t, e);
}
function lV(r, e) {
  const t = new lo(r);
  return hV(t), t.createBinaryChunk(), t.gltf;
}
function cV(r, e) {
  const t = r.gltf.json;
  if (t.meshes)
    for (const n of t.meshes)
      for (const i of n.primitives)
        uV(r, i, e);
}
function uV(r, e, t) {
  var s, l, o;
  if (!((s = t == null ? void 0 : t.gltf) != null && s.loadBuffers))
    return;
  const n = (l = e.extensions) == null ? void 0 : l[Rd], i = n == null ? void 0 : n.featureIds;
  if (i)
    for (const d of i) {
      let m;
      if (typeof d.attribute < "u") {
        const b = `_FEATURE_ID_${d.attribute}`, T = e.attributes[b];
        m = r.getTypedArrayForAccessor(T);
      } else typeof d.texture < "u" && ((o = t == null ? void 0 : t.gltf) != null && o.loadImages) ? m = U2(r, d.texture, e) : m = [];
      d.data = m;
    }
}
function hV(r, e) {
  const t = r.gltf.json.meshes;
  if (t)
    for (const n of t)
      for (const i of n.primitives)
        dV(r, i);
}
function fV(r, e, t, n) {
  e.extensions || (e.extensions = {});
  let i = e.extensions[Rd];
  i || (i = {
    featureIds: []
  }, e.extensions[Rd] = i);
  const {
    featureIds: s
  } = i, l = {
    featureCount: t.length,
    propertyTable: n,
    data: t
  };
  s.push(l), r.addObjectExtension(e, Rd, i);
}
function dV(r, e) {
  var i;
  const t = (i = e.extensions) == null ? void 0 : i[Rd];
  if (!t)
    return;
  const n = t.featureIds;
  n.forEach((s, l) => {
    if (s.data) {
      const {
        accessorKey: o,
        index: d
      } = pV(e.attributes), m = new Uint32Array(s.data);
      n[l] = {
        featureCount: m.length,
        propertyTable: s.propertyTable,
        attribute: d
      }, r.gltf.buffers.push({
        arrayBuffer: m.buffer,
        byteOffset: m.byteOffset,
        byteLength: m.byteLength
      });
      const b = r.addBufferView(m), T = r.addAccessor(b, {
        size: 1,
        componentType: Ty(m),
        count: m.length
      });
      e.attributes[o] = T;
    }
  });
}
function pV(r) {
  const e = "_FEATURE_ID_", t = Object.keys(r).filter((s) => s.indexOf(e) === 0);
  let n = -1;
  for (const s of t) {
    const l = Number(s.substring(e.length));
    l > n && (n = l);
  }
  return n++, {
    accessorKey: `${e}${n}`,
    index: n
  };
}
const gV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtMeshFeatures: fV,
  decode: aV,
  encode: lV,
  name: oV
}, Symbol.toStringTag, { value: "Module" })), qd = "EXT_structural_metadata", mV = qd;
async function _V(r, e) {
  const t = new lo(r);
  bV(t, e);
}
function yV(r, e) {
  const t = new lo(r);
  return NV(t), t.createBinaryChunk(), t.gltf;
}
function bV(r, e) {
  var n, i;
  if (!((n = e.gltf) != null && n.loadBuffers))
    return;
  const t = r.getExtension(qd);
  t && ((i = e.gltf) != null && i.loadImages && vV(r, t), xV(r, t));
}
function vV(r, e) {
  const t = e.propertyTextures, n = r.gltf.json;
  if (t && n.meshes)
    for (const i of n.meshes)
      for (const s of i.primitives)
        AV(r, t, s, e);
}
function xV(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const n = t.classes, i = e.propertyTables;
  if (n && i)
    for (const s in n) {
      const l = wV(i, s);
      l && SV(r, t, l);
    }
}
function wV(r, e) {
  for (const t of r)
    if (t.class === e)
      return t;
  return null;
}
function AV(r, e, t, n) {
  var l;
  if (!e)
    return;
  const i = (l = t.extensions) == null ? void 0 : l[qd], s = i == null ? void 0 : i.propertyTextures;
  if (s)
    for (const o of s) {
      const d = e[o];
      TV(r, d, t, n);
    }
}
function TV(r, e, t, n) {
  var s;
  if (!e.properties)
    return;
  n.dataAttributeNames || (n.dataAttributeNames = []);
  const i = e.class;
  for (const l in e.properties) {
    const o = `${i}_${l}`, d = (s = e.properties) == null ? void 0 : s[l];
    if (!d)
      continue;
    d.data || (d.data = []);
    const m = d.data, b = U2(r, d, t);
    b !== null && (dI(r, o, b, m, t), d.data = m, n.dataAttributeNames.push(o));
  }
}
function SV(r, e, t) {
  var s, l;
  const n = (s = e.classes) == null ? void 0 : s[t.class];
  if (!n)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${t.class}`);
  const i = t.count;
  for (const o in n.properties) {
    const d = n.properties[o], m = (l = t.properties) == null ? void 0 : l[o];
    if (m) {
      const b = EV(r, e, d, i, m);
      m.data = b;
    }
  }
}
function EV(r, e, t, n, i) {
  let s = [];
  const l = i.values, o = r.getTypedArrayForBufferView(l), d = CV(r, t, i, n), m = IV(r, i, n);
  switch (t.type) {
    case "SCALAR":
    case "VEC2":
    case "VEC3":
    case "VEC4":
    case "MAT2":
    case "MAT3":
    case "MAT4": {
      s = MV(t, n, o, d);
      break;
    }
    case "BOOLEAN":
      throw new Error(`Not implemented - classProperty.type=${t.type}`);
    case "STRING": {
      s = mI(n, o, d, m);
      break;
    }
    case "ENUM": {
      s = PV(e, t, n, o, d);
      break;
    }
    default:
      throw new Error(`Unknown classProperty type ${t.type}`);
  }
  return s;
}
function CV(r, e, t, n) {
  return e.array && // `count` is a number of array elements. May only be defined when `array` is true.
  // If `count` is NOT defined, it's a VARIABLE-length array
  typeof e.count > "u" && // `arrayOffsets` is an index of the buffer view containing offsets for variable-length arrays.
  typeof t.arrayOffsets < "u" ? Sy(r, t.arrayOffsets, t.arrayOffsetType || "UINT32", n) : null;
}
function IV(r, e, t) {
  return typeof e.stringOffsets < "u" ? Sy(r, e.stringOffsets, e.stringOffsetType || "UINT32", t) : null;
}
function MV(r, e, t, n) {
  const i = r.array, s = r.count, l = F2(r.type, r.componentType), o = t.byteLength / l;
  let d;
  return r.componentType ? d = Ey(
    t,
    r.type,
    // The datatype of the element's components. Only applicable to `SCALAR`, `VECN`, and `MATN` types.
    r.componentType,
    o
  ) : d = t, i ? n ? pI(d, e, n, t.length, l) : s ? gI(d, e, s) : [] : d;
}
function PV(r, e, t, n, i) {
  var T;
  const s = e.enumType;
  if (!s)
    throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");
  const l = (T = r.enums) == null ? void 0 : T[s];
  if (!l)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${s}`);
  const o = l.valueType || "UINT16", d = F2(e.type, o), m = n.byteLength / d;
  let b = Ey(n, e.type, o, m);
  if (b || (b = n), e.array) {
    if (i)
      return RV({
        valuesData: b,
        numberOfElements: t,
        arrayOffsets: i,
        valuesDataBytesLength: n.length,
        elementSize: d,
        enumEntry: l
      });
    const M = e.count;
    return M ? BV(b, t, M, l) : [];
  }
  return z2(b, 0, t, l);
}
function RV(r) {
  const {
    valuesData: e,
    numberOfElements: t,
    arrayOffsets: n,
    valuesDataBytesLength: i,
    elementSize: s,
    enumEntry: l
  } = r, o = [];
  for (let d = 0; d < t; d++) {
    const m = n[d], b = n[d + 1] - n[d];
    if (b + m > i)
      break;
    const T = m / s, M = b / s, E = z2(e, T, M, l);
    o.push(E);
  }
  return o;
}
function BV(r, e, t, n) {
  const i = [];
  for (let s = 0; s < e; s++) {
    const l = t * s, o = z2(r, l, t, n);
    i.push(o);
  }
  return i;
}
function z2(r, e, t, n) {
  const i = [];
  for (let s = 0; s < t; s++)
    if (r instanceof BigInt64Array || r instanceof BigUint64Array)
      i.push("");
    else {
      const l = r[e + s], o = LV(n, l);
      o ? i.push(o.name) : i.push("");
    }
  return i;
}
function LV(r, e) {
  for (const t of r.values)
    if (t.value === e)
      return t;
  return null;
}
const OV = "schemaClassId";
function NV(r, e) {
  var n, i;
  const t = r.getExtension(qd);
  if (t && t.propertyTables)
    for (const s of t.propertyTables) {
      const l = s.class, o = (i = (n = t.schema) == null ? void 0 : n.classes) == null ? void 0 : i[l];
      s.properties && o && DV(s, o, r);
    }
}
function DV(r, e, t) {
  for (const n in r.properties) {
    const i = r.properties[n].data;
    if (i) {
      const s = e.properties[n];
      if (s) {
        const l = zV(i, s, t);
        r.properties[n] = l;
      }
    }
  }
}
function kV(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : OV, n = r.getExtension(qd);
  n || (n = r.addExtension(qd)), n.schema = FV(e, t, n.schema);
  const i = UV(e, t, n.schema);
  return n.propertyTables || (n.propertyTables = []), n.propertyTables.push(i) - 1;
}
function FV(r, e, t) {
  const n = t ?? {
    id: "schema_id"
  }, i = {
    properties: {}
  };
  for (const s of r) {
    const l = {
      type: s.elementType,
      componentType: s.componentType
    };
    i.properties[s.name] = l;
  }
  return n.classes = {}, n.classes[e] = i, n;
}
function UV(r, e, t) {
  var l;
  const n = {
    class: e,
    count: 0
  };
  let i = 0;
  const s = (l = t.classes) == null ? void 0 : l[e];
  for (const o of r) {
    if (i === 0 && (i = o.values.length), i !== o.values.length && o.values.length)
      throw new Error("Illegal values in attributes");
    (s == null ? void 0 : s.properties[o.name]) && (n.properties || (n.properties = {}), n.properties[o.name] = {
      values: 0,
      data: o.values
    });
  }
  return n.count = i, n;
}
function zV(r, e, t) {
  const n = {
    values: 0
  };
  if (e.type === "STRING") {
    const {
      stringData: i,
      stringOffsets: s
    } = qV(r);
    n.stringOffsets = wb(s, t), n.values = wb(i, t);
  } else if (e.type === "SCALAR" && e.componentType) {
    const i = VV(r, e.componentType);
    n.values = wb(i, t);
  }
  return n;
}
const jV = {
  INT8: Int8Array,
  UINT8: Uint8Array,
  INT16: Int16Array,
  UINT16: Uint16Array,
  INT32: Int32Array,
  UINT32: Uint32Array,
  INT64: Int32Array,
  UINT64: Uint32Array,
  FLOAT32: Float32Array,
  FLOAT64: Float64Array
};
function VV(r, e) {
  const t = [];
  for (const i of r)
    t.push(Number(i));
  const n = jV[e];
  if (!n)
    throw new Error("Illegal component type");
  return new n(t);
}
function qV(r) {
  const e = new TextEncoder(), t = [];
  let n = 0;
  for (const d of r) {
    const m = e.encode(d);
    n += m.length, t.push(m);
  }
  const i = new Uint8Array(n), s = [];
  let l = 0;
  for (const d of t)
    i.set(d, l), s.push(l), l += d.length;
  s.push(l);
  const o = new Uint32Array(s);
  return {
    stringData: i,
    stringOffsets: o
  };
}
function wb(r, e) {
  return e.gltf.buffers.push({
    arrayBuffer: r.buffer,
    byteOffset: r.byteOffset,
    byteLength: r.byteLength
  }), e.addBufferView(r);
}
const GV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createExtStructuralMetadata: kV,
  decode: _V,
  encode: yV,
  name: mV
}, Symbol.toStringTag, { value: "Module" })), _I = "EXT_feature_metadata", $V = _I;
async function HV(r, e) {
  const t = new lo(r);
  WV(t, e);
}
function WV(r, e) {
  var n, i;
  if (!((n = e.gltf) != null && n.loadBuffers))
    return;
  const t = r.getExtension(_I);
  t && ((i = e.gltf) != null && i.loadImages && XV(r, t), ZV(r, t));
}
function XV(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const n = t.classes, {
    featureTextures: i
  } = e;
  if (n && i)
    for (const s in n) {
      const l = n[s], o = KV(i, s);
      o && QV(r, o, l);
    }
}
function ZV(r, e) {
  const t = e.schema;
  if (!t)
    return;
  const n = t.classes, i = e.featureTables;
  if (n && i)
    for (const s in n) {
      const l = YV(i, s);
      l && JV(r, t, l);
    }
}
function YV(r, e) {
  for (const t in r) {
    const n = r[t];
    if (n.class === e)
      return n;
  }
  return null;
}
function KV(r, e) {
  for (const t in r) {
    const n = r[t];
    if (n.class === e)
      return n;
  }
  return null;
}
function JV(r, e, t) {
  var s, l;
  if (!t.class)
    return;
  const n = (s = e.classes) == null ? void 0 : s[t.class];
  if (!n)
    throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${t.class}`);
  const i = t.count;
  for (const o in n.properties) {
    const d = n.properties[o], m = (l = t.properties) == null ? void 0 : l[o];
    if (m) {
      const b = eq(r, e, d, i, m);
      m.data = b;
    }
  }
}
function QV(r, e, t) {
  var i;
  const n = e.class;
  for (const s in t.properties) {
    const l = (i = e == null ? void 0 : e.properties) == null ? void 0 : i[s];
    if (l) {
      const o = sq(r, l, n);
      l.data = o;
    }
  }
}
function eq(r, e, t, n, i) {
  let s = [];
  const l = i.bufferView, o = r.getTypedArrayForBufferView(l), d = tq(r, t, i, n), m = rq(r, t, i, n);
  return t.type === "STRING" || t.componentType === "STRING" ? s = mI(n, o, d, m) : nq(t) && (s = iq(t, n, o, d)), s;
}
function tq(r, e, t, n) {
  return e.type === "ARRAY" && // `componentCount` is a number of fixed-length array elements.
  // If `componentCount` is NOT defined, it's a VARIABLE-length array
  typeof e.componentCount > "u" && // `arrayOffsetBufferView` is an index of the buffer view containing offsets for variable-length arrays.
  typeof t.arrayOffsetBufferView < "u" ? Sy(
    r,
    t.arrayOffsetBufferView,
    t.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    n
  ) : null;
}
function rq(r, e, t, n) {
  return typeof t.stringOffsetBufferView < "u" ? Sy(
    r,
    t.stringOffsetBufferView,
    t.offsetType || "UINT32",
    // offsetType is used both for stringOffsetBufferView and arrayOffsetBufferView
    n
  ) : null;
}
function nq(r) {
  const e = ["UINT8", "INT16", "UINT16", "INT32", "UINT32", "INT64", "UINT64", "FLOAT32", "FLOAT64"];
  return e.includes(r.type) || typeof r.componentType < "u" && e.includes(r.componentType);
}
function iq(r, e, t, n) {
  const i = r.type === "ARRAY", s = r.componentCount, l = "SCALAR", o = r.componentType || r.type, d = F2(l, o), m = t.byteLength / d, b = Ey(t, l, o, m);
  return i ? n ? pI(b, e, n, t.length, d) : s ? gI(b, e, s) : [] : b;
}
function sq(r, e, t) {
  const n = r.gltf.json;
  if (!n.meshes)
    return [];
  const i = [];
  for (const s of n.meshes)
    for (const l of s.primitives)
      oq(r, t, e, i, l);
  return i;
}
function oq(r, e, t, n, i) {
  const s = {
    channels: t.channels,
    ...t.texture
  }, l = U2(r, s, i);
  l && dI(r, e, l, n, i);
}
const aq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: HV,
  name: $V
}, Symbol.toStringTag, { value: "Module" })), lq = "4.3.2", Gd = !0, b3 = 1735152710, j2 = 12, H_ = 8, cq = 1313821514, uq = 5130562, hq = 0, fq = 0, dq = 1;
function pq(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return `${String.fromCharCode(r.getUint8(e + 0))}${String.fromCharCode(r.getUint8(e + 1))}${String.fromCharCode(r.getUint8(e + 2))}${String.fromCharCode(r.getUint8(e + 3))}`;
}
function gq(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const n = new DataView(r), {
    magic: i = b3
  } = t, s = n.getUint32(e, !1);
  return s === i || s === b3;
}
function mq(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const n = new DataView(e), i = pq(n, t + 0), s = n.getUint32(t + 4, Gd), l = n.getUint32(t + 8, Gd);
  switch (Object.assign(r, {
    // Put less important stuff in a header, to avoid clutter
    header: {
      byteOffset: t,
      // Byte offset into the initial arrayBuffer
      byteLength: l,
      hasBinChunk: !1
    },
    type: i,
    version: s,
    json: {},
    binChunks: []
  }), t += j2, r.version) {
    case 1:
      return _q(r, n, t);
    case 2:
      return yq(r, n, t, {});
    default:
      throw new Error(`Invalid GLB version ${r.version}. Only supports version 1 and 2.`);
  }
}
function _q(r, e, t) {
  xi(r.header.byteLength > j2 + H_);
  const n = e.getUint32(t + 0, Gd), i = e.getUint32(t + 4, Gd);
  return t += H_, xi(i === hq), cv(r, e, t, n), t += n, t += uv(r, e, t, r.header.byteLength), t;
}
function yq(r, e, t, n) {
  return xi(r.header.byteLength > j2 + H_), bq(r, e, t, n), t + r.header.byteLength;
}
function bq(r, e, t, n) {
  for (; t + 8 <= r.header.byteLength; ) {
    const i = e.getUint32(t + 0, Gd), s = e.getUint32(t + 4, Gd);
    switch (t += H_, s) {
      case cq:
        cv(r, e, t, i);
        break;
      case uq:
        uv(r, e, t, i);
        break;
      // Backward compatibility for very old xviz files
      case fq:
        n.strict || cv(r, e, t, i);
        break;
      case dq:
        n.strict || uv(r, e, t, i);
        break;
    }
    t += Cg(i, 4);
  }
  return t;
}
function cv(r, e, t, n) {
  const i = new Uint8Array(e.buffer, t, n), l = new TextDecoder("utf8").decode(i);
  return r.json = JSON.parse(l), Cg(n, 4);
}
function uv(r, e, t, n) {
  return r.header.hasBinChunk = !0, r.binChunks.push({
    byteOffset: t,
    byteLength: n,
    arrayBuffer: e.buffer
    // TODO - copy, or create typed array view?
  }), Cg(n, 4);
}
function yI(r, e) {
  if (r.startsWith("data:") || r.startsWith("http:") || r.startsWith("https:"))
    return r;
  const n = e.baseUri || e.uri;
  if (!n)
    throw new Error(`'baseUri' must be provided to resolve relative url ${r}`);
  return n.substr(0, n.lastIndexOf("/") + 1) + r;
}
const vq = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", xq = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", wq = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), Aq = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]), Tq = {
  // legacy index-based enums for glTF
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  // string-based enums for glTF
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
}, Sq = {
  // legacy index-based enums for glTF
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  // string-based enums for glTF
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function Eq(r, e, t, n, i) {
  let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "NONE";
  const l = await Cq();
  Pq(l, l.exports[Sq[i]], r, e, t, n, l.exports[Tq[s || "NONE"]]);
}
let Ab;
async function Cq() {
  return Ab || (Ab = Iq()), Ab;
}
async function Iq() {
  let r = vq;
  WebAssembly.validate(wq) && (r = xq, console.log("Warning: meshopt_decoder is using experimental SIMD support"));
  const e = await WebAssembly.instantiate(Mq(r), {});
  return await e.instance.exports.__wasm_call_ctors(), e.instance;
}
function Mq(r) {
  const e = new Uint8Array(r.length);
  for (let n = 0; n < r.length; ++n) {
    const i = r.charCodeAt(n);
    e[n] = i > 96 ? i - 71 : i > 64 ? i - 65 : i > 47 ? i + 4 : i > 46 ? 63 : 62;
  }
  let t = 0;
  for (let n = 0; n < r.length; ++n)
    e[t++] = e[n] < 60 ? Aq[e[n]] : (e[n] - 60) * 64 + e[++n];
  return e.buffer.slice(0, t);
}
function Pq(r, e, t, n, i, s, l) {
  const o = r.exports.sbrk, d = n + 3 & -4, m = o(d * i), b = o(s.length), T = new Uint8Array(r.exports.memory.buffer);
  T.set(s, b);
  const M = e(m, n, i, b, s.length);
  if (M === 0 && l && l(m, d, i), t.set(T.subarray(m, m + n * i)), o(m - o(0)), M !== 0)
    throw new Error(`Malformed buffer data: ${M}`);
}
const W_ = "EXT_meshopt_compression", Rq = W_;
async function Bq(r, e) {
  var i, s;
  const t = new lo(r);
  if (!((i = e == null ? void 0 : e.gltf) != null && i.decompressMeshes) || !((s = e.gltf) != null && s.loadBuffers))
    return;
  const n = [];
  for (const l of r.json.bufferViews || [])
    n.push(Lq(t, l));
  await Promise.all(n), t.removeExtension(W_);
}
async function Lq(r, e) {
  const t = r.getObjectExtension(e, W_);
  if (t) {
    const {
      byteOffset: n = 0,
      byteLength: i = 0,
      byteStride: s,
      count: l,
      mode: o,
      filter: d = "NONE",
      buffer: m
    } = t, b = r.gltf.buffers[m], T = new Uint8Array(b.arrayBuffer, b.byteOffset + n, i), M = new Uint8Array(r.gltf.buffers[e.buffer].arrayBuffer, e.byteOffset, e.byteLength);
    await Eq(M, l, s, T, o, d), r.removeObjectExtension(e, W_);
  }
}
const Oq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: Bq,
  name: Rq
}, Symbol.toStringTag, { value: "Module" })), dd = "EXT_texture_webp", Nq = dd;
function Dq(r, e) {
  const t = new lo(r);
  if (!jL("image/webp")) {
    if (t.getRequiredExtensions().includes(dd))
      throw new Error(`gltf: Required extension ${dd} not supported by browser`);
    return;
  }
  const {
    json: n
  } = t;
  for (const i of n.textures || []) {
    const s = t.getObjectExtension(i, dd);
    s && (i.source = s.source), t.removeObjectExtension(i, dd);
  }
  t.removeExtension(dd);
}
const kq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: Nq,
  preprocess: Dq
}, Symbol.toStringTag, { value: "Module" })), e_ = "KHR_texture_basisu", Fq = e_;
function Uq(r, e) {
  const t = new lo(r), {
    json: n
  } = t;
  for (const i of n.textures || []) {
    const s = t.getObjectExtension(i, e_);
    s && (i.source = s.source, t.removeObjectExtension(i, e_));
  }
  t.removeExtension(e_);
}
const zq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: Fq,
  preprocess: Uq
}, Symbol.toStringTag, { value: "Module" })), jq = "4.3.2", Vq = {
  dataType: null,
  batchType: null,
  name: "Draco",
  id: "draco",
  module: "draco",
  // shapes: ['mesh'],
  version: jq,
  worker: !0,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: !0,
  tests: ["DRACO"],
  options: {
    draco: {
      decoderType: typeof WebAssembly == "object" ? "wasm" : "js",
      // 'js' for IE11
      libraryPath: "libs/",
      extraAttributes: {},
      attributeNameEntry: void 0
    }
  }
};
function qq(r, e, t) {
  const n = bI(e.metadata), i = [], s = Gq(e.attributes);
  for (const l in r) {
    const o = r[l], d = v3(l, o, s[l]);
    i.push(d);
  }
  if (t) {
    const l = v3("indices", t);
    i.push(l);
  }
  return {
    fields: i,
    metadata: n
  };
}
function Gq(r) {
  const e = {};
  for (const t in r) {
    const n = r[t];
    e[n.name || "undefined"] = n;
  }
  return e;
}
function v3(r, e, t) {
  const n = t ? bI(t.metadata) : void 0;
  return aL(r, e, n);
}
function bI(r) {
  Object.entries(r);
  const e = {};
  for (const t in r)
    e[`${t}.string`] = JSON.stringify(r[t]);
  return e;
}
const x3 = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
}, $q = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  // 7: BigInt64Array,
  // 8: BigUint64Array,
  9: Float32Array
  // 10: Float64Array
  // 11: BOOL - What array type do we use for this?
}, Hq = 4;
class Wq {
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(e) {
    H(this, "draco");
    H(this, "decoder");
    H(this, "metadataQuerier");
    this.draco = e, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  /**
   * Destroy draco resources
   */
  destroy() {
    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);
  }
  /**
   * NOTE: caller must call `destroyGeometry` on the return value after using it
   * @param arrayBuffer
   * @param options
   */
  parseSync(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = new this.draco.DecoderBuffer();
    n.Init(new Int8Array(e), e.byteLength), this._disableAttributeTransforms(t);
    const i = this.decoder.GetEncodedGeometryType(n), s = i === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let l;
      switch (i) {
        case this.draco.TRIANGULAR_MESH:
          l = this.decoder.DecodeBufferToMesh(n, s);
          break;
        case this.draco.POINT_CLOUD:
          l = this.decoder.DecodeBufferToPointCloud(n, s);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!l.ok() || !s.ptr) {
        const M = `DRACO decompression failed: ${l.error_msg()}`;
        throw new Error(M);
      }
      const o = this._getDracoLoaderData(s, i, t), d = this._getMeshData(s, o, t), m = RE(d.attributes), b = qq(d.attributes, o, d.indices);
      return {
        loader: "draco",
        loaderData: o,
        header: {
          vertexCount: s.num_points(),
          boundingBox: m
        },
        ...d,
        schema: b
      };
    } finally {
      this.draco.destroy(n), s && this.draco.destroy(s);
    }
  }
  // Draco specific "loader data"
  /**
   * Extract
   * @param dracoGeometry
   * @param geometry_type
   * @param options
   * @returns
   */
  _getDracoLoaderData(e, t, n) {
    const i = this._getTopLevelMetadata(e), s = this._getDracoAttributes(e, n);
    return {
      geometry_type: t,
      num_attributes: e.num_attributes(),
      num_points: e.num_points(),
      num_faces: e instanceof this.draco.Mesh ? e.num_faces() : 0,
      metadata: i,
      attributes: s
    };
  }
  /**
   * Extract all draco provided information and metadata for each attribute
   * @param dracoGeometry
   * @param options
   * @returns
   */
  _getDracoAttributes(e, t) {
    const n = {};
    for (let i = 0; i < e.num_attributes(); i++) {
      const s = this.decoder.GetAttribute(e, i), l = this._getAttributeMetadata(e, i);
      n[s.unique_id()] = {
        unique_id: s.unique_id(),
        attribute_type: s.attribute_type(),
        data_type: s.data_type(),
        num_components: s.num_components(),
        byte_offset: s.byte_offset(),
        byte_stride: s.byte_stride(),
        normalized: s.normalized(),
        attribute_index: i,
        metadata: l
      };
      const o = this._getQuantizationTransform(s, t);
      o && (n[s.unique_id()].quantization_transform = o);
      const d = this._getOctahedronTransform(s, t);
      d && (n[s.unique_id()].octahedron_transform = d);
    }
    return n;
  }
  /**
   * Get standard loaders.gl mesh category data
   * Extracts the geometry from draco
   * @param dracoGeometry
   * @param options
   */
  _getMeshData(e, t, n) {
    const i = this._getMeshAttributes(t, e, n);
    if (!i.POSITION)
      throw new Error("DRACO: No position attribute found.");
    if (e instanceof this.draco.Mesh)
      switch (n.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            // GL.TRIANGLES
            attributes: i,
            indices: {
              value: this._getTriangleStripIndices(e),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            // GL.TRIANGLE_STRIP
            attributes: i,
            indices: {
              value: this._getTriangleListIndices(e),
              size: 1
            }
          };
      }
    return {
      topology: "point-list",
      mode: 0,
      // GL.POINTS
      attributes: i
    };
  }
  _getMeshAttributes(e, t, n) {
    const i = {};
    for (const s of Object.values(e.attributes)) {
      const l = this._deduceAttributeName(s, n);
      s.name = l;
      const o = this._getAttributeValues(t, s);
      if (o) {
        const {
          value: d,
          size: m
        } = o;
        i[l] = {
          value: d,
          size: m,
          byteOffset: s.byte_offset,
          byteStride: s.byte_stride,
          normalized: s.normalized
        };
      }
    }
    return i;
  }
  // MESH INDICES EXTRACTION
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleListIndices(e) {
    const n = e.num_faces() * 3, i = n * Hq, s = this.draco._malloc(i);
    try {
      return this.decoder.GetTrianglesUInt32Array(e, i, s), new Uint32Array(this.draco.HEAPF32.buffer, s, n).slice();
    } finally {
      this.draco._free(s);
    }
  }
  /**
   * For meshes, we need indices to define the faces.
   * @param dracoGeometry
   */
  _getTriangleStripIndices(e) {
    const t = new this.draco.DracoInt32Array();
    try {
      return this.decoder.GetTriangleStripsFromMesh(e, t), Yq(t);
    } finally {
      this.draco.destroy(t);
    }
  }
  /**
   *
   * @param dracoGeometry
   * @param dracoAttribute
   * @param attributeName
   */
  _getAttributeValues(e, t) {
    const n = $q[t.data_type];
    if (!n)
      return console.warn(`DRACO: Unsupported attribute type ${t.data_type}`), null;
    const i = t.num_components, l = e.num_points() * i, o = l * n.BYTES_PER_ELEMENT, d = Xq(this.draco, n);
    let m;
    const b = this.draco._malloc(o);
    try {
      const T = this.decoder.GetAttribute(e, t.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(e, T, d, o, b), m = new n(this.draco.HEAPF32.buffer, b, l).slice();
    } finally {
      this.draco._free(b);
    }
    return {
      value: m,
      size: i
    };
  }
  // Attribute names
  /**
   * DRACO does not store attribute names - We need to deduce an attribute name
   * for each attribute
  _getAttributeNames(
    dracoGeometry: Mesh | PointCloud,
    options: DracoParseOptions
  ): {[unique_id: number]: string} {
    const attributeNames: {[unique_id: number]: string} = {};
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = this.decoder.GetAttribute(dracoGeometry, attributeId);
      const attributeName = this._deduceAttributeName(dracoAttribute, options);
      attributeNames[attributeName] = attributeName;
    }
    return attributeNames;
  }
   */
  /**
   * Deduce an attribute name.
   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
   * types
   * @param attributeData
   */
  _deduceAttributeName(e, t) {
    const n = e.unique_id;
    for (const [l, o] of Object.entries(t.extraAttributes || {}))
      if (o === n)
        return l;
    const i = e.attribute_type;
    for (const l in x3)
      if (this.draco[l] === i)
        return x3[l];
    const s = t.attributeNameEntry || "name";
    return e.metadata[s] ? e.metadata[s].string : `CUSTOM_ATTRIBUTE_${n}`;
  }
  // METADATA EXTRACTION
  /** Get top level metadata */
  _getTopLevelMetadata(e) {
    const t = this.decoder.GetMetadata(e);
    return this._getDracoMetadata(t);
  }
  /** Get per attribute metadata */
  _getAttributeMetadata(e, t) {
    const n = this.decoder.GetAttributeMetadata(e, t);
    return this._getDracoMetadata(n);
  }
  /**
   * Extract metadata field values
   * @param dracoMetadata
   * @returns
   */
  _getDracoMetadata(e) {
    if (!e || !e.ptr)
      return {};
    const t = {}, n = this.metadataQuerier.NumEntries(e);
    for (let i = 0; i < n; i++) {
      const s = this.metadataQuerier.GetEntryName(e, i);
      t[s] = this._getDracoMetadataField(e, s);
    }
    return t;
  }
  /**
   * Extracts possible values for one metadata entry by name
   * @param dracoMetadata
   * @param entryName
   */
  _getDracoMetadataField(e, t) {
    const n = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(e, t, n);
      const i = Zq(n);
      return {
        int: this.metadataQuerier.GetIntEntry(e, t),
        string: this.metadataQuerier.GetStringEntry(e, t),
        double: this.metadataQuerier.GetDoubleEntry(e, t),
        intArray: i
      };
    } finally {
      this.draco.destroy(n);
    }
  }
  // QUANTIZED ATTRIBUTE SUPPORT (NO DECOMPRESSION)
  /** Skip transforms for specific attribute types */
  _disableAttributeTransforms(e) {
    const {
      quantizedAttributes: t = [],
      octahedronAttributes: n = []
    } = e, i = [...t, ...n];
    for (const s of i)
      this.decoder.SkipAttributeTransform(this.draco[s]);
  }
  /**
   * Extract (and apply?) Position Transform
   * @todo not used
   */
  _getQuantizationTransform(e, t) {
    const {
      quantizedAttributes: n = []
    } = t, i = e.attribute_type();
    if (n.map((l) => this.decoder[l]).includes(i)) {
      const l = new this.draco.AttributeQuantizationTransform();
      try {
        if (l.InitFromAttribute(e))
          return {
            quantization_bits: l.quantization_bits(),
            range: l.range(),
            min_values: new Float32Array([1, 2, 3]).map((o) => l.min_value(o))
          };
      } finally {
        this.draco.destroy(l);
      }
    }
    return null;
  }
  _getOctahedronTransform(e, t) {
    const {
      octahedronAttributes: n = []
    } = t, i = e.attribute_type();
    if (n.map((l) => this.decoder[l]).includes(i)) {
      const l = new this.draco.AttributeQuantizationTransform();
      try {
        if (l.InitFromAttribute(e))
          return {
            quantization_bits: l.quantization_bits()
          };
      } finally {
        this.draco.destroy(l);
      }
    }
    return null;
  }
}
function Xq(r, e) {
  switch (e) {
    case Float32Array:
      return r.DT_FLOAT32;
    case Int8Array:
      return r.DT_INT8;
    case Int16Array:
      return r.DT_INT16;
    case Int32Array:
      return r.DT_INT32;
    case Uint8Array:
      return r.DT_UINT8;
    case Uint16Array:
      return r.DT_UINT16;
    case Uint32Array:
      return r.DT_UINT32;
    default:
      return r.DT_INVALID;
  }
}
function Zq(r) {
  const e = r.size(), t = new Int32Array(e);
  for (let n = 0; n < e; n++)
    t[n] = r.GetValue(n);
  return t;
}
function Yq(r) {
  const e = r.size(), t = new Int32Array(e);
  for (let n = 0; n < e; n++)
    t[n] = r.GetValue(n);
  return t;
}
const Kq = "1.5.6", Jq = "1.4.1", Tb = `https://www.gstatic.com/draco/versioned/decoders/${Kq}`, Aa = {
  /** The primary Draco3D encoder, javascript wrapper part */
  DECODER: "draco_wasm_wrapper.js",
  /** The primary draco decoder, compiled web assembly part */
  DECODER_WASM: "draco_decoder.wasm",
  /** Fallback decoder for non-webassebly environments. Very big bundle, lower performance */
  FALLBACK_DECODER: "draco_decoder.js",
  /** Draco encoder */
  ENCODER: "draco_encoder.js"
}, Sb = {
  [Aa.DECODER]: `${Tb}/${Aa.DECODER}`,
  [Aa.DECODER_WASM]: `${Tb}/${Aa.DECODER_WASM}`,
  [Aa.FALLBACK_DECODER]: `${Tb}/${Aa.FALLBACK_DECODER}`,
  [Aa.ENCODER]: `https://raw.githubusercontent.com/google/draco/${Jq}/javascript/${Aa.ENCODER}`
};
let Eb;
async function Qq(r) {
  const e = r.modules || {};
  return e.draco3d ? Eb || (Eb = e.draco3d.createDecoderModule({}).then((t) => ({
    draco: t
  }))) : Eb || (Eb = eG(r)), await Eb;
}
async function eG(r) {
  let e, t;
  switch (r.draco && r.draco.decoderType) {
    case "js":
      e = await mf(Sb[Aa.FALLBACK_DECODER], "draco", r, Aa.FALLBACK_DECODER);
      break;
    case "wasm":
    default:
      [e, t] = await Promise.all([await mf(Sb[Aa.DECODER], "draco", r, Aa.DECODER), await mf(Sb[Aa.DECODER_WASM], "draco", r, Aa.DECODER_WASM)]);
  }
  return e = e || globalThis.DracoDecoderModule, await tG(e, t);
}
function tG(r, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((n) => {
    r({
      ...t,
      onModuleLoaded: (i) => n({
        draco: i
      })
      // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}
const vI = {
  ...Vq,
  parse: rG
};
async function rG(r, e) {
  const {
    draco: t
  } = await Qq(e), n = new Wq(t);
  try {
    return n.parseSync(r, e == null ? void 0 : e.draco);
  } finally {
    n.destroy();
  }
}
function nG(r) {
  const e = {};
  for (const t in r) {
    const n = r[t];
    if (t !== "indices") {
      const i = xI(n);
      e[t] = i;
    }
  }
  return e;
}
function xI(r) {
  const {
    buffer: e,
    size: t,
    count: n
  } = iG(r);
  return {
    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    // bufferView: null,
    // TODO: Deprecate `value` in favor of bufferView?
    // @ts-ignore
    value: e,
    size: t,
    // Decoded `type` (e.g. SCALAR)
    byteOffset: 0,
    count: n,
    type: cI(t),
    componentType: Ty(e)
  };
}
function iG(r) {
  let e = r, t = 1, n = 0;
  return r && r.value && (e = r.value, t = r.size || 1), e && (ArrayBuffer.isView(e) || (e = sG(e, Float32Array)), n = e.length / t), {
    buffer: e,
    size: t,
    count: n
  };
}
function sG(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return r ? Array.isArray(r) ? new e(r) : t && !(r instanceof e) ? new e(r) : r : null;
}
const Oh = "KHR_draco_mesh_compression", oG = Oh;
function aG(r, e, t) {
  const n = new lo(r);
  for (const i of wI(n))
    n.getObjectExtension(i, Oh);
}
async function lG(r, e, t) {
  var s;
  if (!((s = e == null ? void 0 : e.gltf) != null && s.decompressMeshes))
    return;
  const n = new lo(r), i = [];
  for (const l of wI(n))
    n.getObjectExtension(l, Oh) && i.push(uG(n, l, e, t));
  await Promise.all(i), n.removeExtension(Oh);
}
function cG(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = new lo(r);
  for (const n of t.json.meshes || [])
    hG(n, e), t.addRequiredExtension(Oh);
}
async function uG(r, e, t, n) {
  const i = r.getObjectExtension(e, Oh);
  if (!i)
    return;
  const s = r.getTypedArrayForBufferView(i.bufferView), l = $v(s.buffer, s.byteOffset), o = {
    ...t
  };
  delete o["3d-tiles"];
  const d = await Eg(l, vI, o, n), m = nG(d.attributes);
  for (const [b, T] of Object.entries(m))
    if (b in e.attributes) {
      const M = e.attributes[b], E = r.getAccessor(M);
      E != null && E.min && (E != null && E.max) && (T.min = E.min, T.max = E.max);
    }
  e.attributes = m, d.indices && (e.indices = xI(d.indices)), r.removeObjectExtension(e, Oh), fG(e);
}
function hG(r, e) {
  var b;
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4, n = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 ? arguments[4] : void 0;
  if (!n.DracoWriter)
    throw new Error("options.gltf.DracoWriter not provided");
  const s = n.DracoWriter.encodeSync({
    attributes: r
  }), l = (b = i == null ? void 0 : i.parseSync) == null ? void 0 : b.call(i, {
    attributes: r
  }), o = n._addFauxAttributes(l.attributes), d = n.addBufferView(s);
  return {
    primitives: [{
      attributes: o,
      // TODO - verify with spec
      mode: t,
      // GL.POINTS
      extensions: {
        [Oh]: {
          bufferView: d,
          attributes: o
          // TODO - verify with spec
        }
      }
    }]
  };
}
function fG(r) {
  if (!r.attributes && Object.keys(r.attributes).length > 0)
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
}
function* wI(r) {
  for (const e of r.json.meshes || [])
    for (const t of e.primitives)
      yield t;
}
const dG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: lG,
  encode: cG,
  name: oG,
  preprocess: aG
}, Symbol.toStringTag, { value: "Module" })), Cy = "KHR_texture_transform", pG = Cy, Pm = new Tt(), gG = new us(), mG = new us();
async function _G(r, e) {
  var s;
  if (!new lo(r).hasExtension(Cy) || !((s = e.gltf) != null && s.loadBuffers))
    return;
  const i = r.json.materials || [];
  for (let l = 0; l < i.length; l++)
    yG(l, r);
}
function yG(r, e) {
  var s, l, o, d;
  const t = (s = e.json.materials) == null ? void 0 : s[r], n = [(l = t == null ? void 0 : t.pbrMetallicRoughness) == null ? void 0 : l.baseColorTexture, t == null ? void 0 : t.emissiveTexture, t == null ? void 0 : t.normalTexture, t == null ? void 0 : t.occlusionTexture, (o = t == null ? void 0 : t.pbrMetallicRoughness) == null ? void 0 : o.metallicRoughnessTexture], i = [];
  for (const m of n)
    m && ((d = m == null ? void 0 : m.extensions) != null && d[Cy]) && bG(e, r, m, i);
}
function bG(r, e, t, n) {
  const i = vG(t, n);
  if (!i)
    return;
  const s = r.json.meshes || [];
  for (const l of s)
    for (const o of l.primitives) {
      const d = o.material;
      Number.isFinite(d) && e === d && xG(r, o, i);
    }
}
function vG(r, e) {
  var l;
  const t = (l = r.extensions) == null ? void 0 : l[Cy], {
    texCoord: n = 0
  } = r, {
    texCoord: i = n
  } = t;
  if (!(e.findIndex((o) => {
    let [d, m] = o;
    return d === n && m === i;
  }) !== -1)) {
    const o = TG(t);
    return n !== i && (r.texCoord = i), e.push([n, i]), {
      originalTexCoord: n,
      texCoord: i,
      matrix: o
    };
  }
  return null;
}
function xG(r, e, t) {
  var o, d;
  const {
    originalTexCoord: n,
    texCoord: i,
    matrix: s
  } = t, l = e.attributes[`TEXCOORD_${n}`];
  if (Number.isFinite(l)) {
    const m = (o = r.json.accessors) == null ? void 0 : o[l];
    if (m && m.bufferView) {
      const b = (d = r.json.bufferViews) == null ? void 0 : d[m.bufferView];
      if (b) {
        const {
          arrayBuffer: T,
          byteOffset: M
        } = r.buffers[b.buffer], E = (M || 0) + (m.byteOffset || 0) + (b.byteOffset || 0), {
          ArrayType: D,
          length: U
        } = k2(m, b), q = lI[m.componentType], G = aI[m.type], Y = b.byteStride || q * G, he = new Float32Array(U);
        for (let X = 0; X < m.count; X++) {
          const J = new D(T, E + X * Y, 2);
          Pm.set(J[0], J[1], 1), Pm.transformByMatrix3(s), he.set([Pm[0], Pm[1]], X * G);
        }
        n === i ? wG(m, b, r.buffers, he) : AG(i, m, e, r, he);
      }
    }
  }
}
function wG(r, e, t, n) {
  r.componentType = 5126, t.push({
    arrayBuffer: n.buffer,
    byteOffset: 0,
    byteLength: n.buffer.byteLength
  }), e.buffer = t.length - 1, e.byteLength = n.buffer.byteLength, e.byteOffset = 0, delete e.byteStride;
}
function AG(r, e, t, n, i) {
  n.buffers.push({
    arrayBuffer: i.buffer,
    byteOffset: 0,
    byteLength: i.buffer.byteLength
  });
  const s = n.json.bufferViews;
  if (!s)
    return;
  s.push({
    buffer: n.buffers.length - 1,
    byteLength: i.buffer.byteLength,
    byteOffset: 0
  });
  const l = n.json.accessors;
  l && (l.push({
    bufferView: (s == null ? void 0 : s.length) - 1,
    byteOffset: 0,
    componentType: 5126,
    count: e.count,
    type: "VEC2"
  }), t.attributes[`TEXCOORD_${r}`] = l.length - 1);
}
function TG(r) {
  const {
    offset: e = [0, 0],
    rotation: t = 0,
    scale: n = [1, 1]
  } = r, i = new us().set(1, 0, 0, 0, 1, 0, e[0], e[1], 1), s = gG.set(Math.cos(t), Math.sin(t), 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 1), l = mG.set(n[0], 0, 0, 0, n[1], 0, 0, 0, 1);
  return i.multiplyRight(s).multiplyRight(l);
}
const SG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: _G,
  name: pG
}, Symbol.toStringTag, { value: "Module" })), hf = "KHR_lights_punctual", EG = hf;
async function CG(r) {
  const e = new lo(r), {
    json: t
  } = e, n = e.getExtension(hf);
  n && (e.json.lights = n.lights, e.removeExtension(hf));
  for (const i of t.nodes || []) {
    const s = e.getObjectExtension(i, hf);
    s && (i.light = s.light), e.removeObjectExtension(i, hf);
  }
}
async function IG(r) {
  const e = new lo(r), {
    json: t
  } = e;
  if (t.lights) {
    const n = e.addExtension(hf);
    Ja(!n.lights), n.lights = t.lights, delete t.lights;
  }
  if (e.json.lights) {
    for (const n of e.json.lights) {
      const i = n.node;
      e.addObjectExtension(i, hf, n);
    }
    delete e.json.lights;
  }
}
const MG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: CG,
  encode: IG,
  name: EG
}, Symbol.toStringTag, { value: "Module" })), vg = "KHR_materials_unlit", PG = vg;
async function RG(r) {
  const e = new lo(r), {
    json: t
  } = e;
  for (const n of t.materials || [])
    n.extensions && n.extensions.KHR_materials_unlit && (n.unlit = !0), e.removeObjectExtension(n, vg);
  e.removeExtension(vg);
}
function BG(r) {
  const e = new lo(r), {
    json: t
  } = e;
  if (e.materials)
    for (const n of t.materials || [])
      n.unlit && (delete n.unlit, e.addObjectExtension(n, vg, {}), e.addExtension(vg));
}
const LG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: RG,
  encode: BG,
  name: PG
}, Symbol.toStringTag, { value: "Module" })), Yp = "KHR_techniques_webgl", OG = Yp;
async function NG(r) {
  const e = new lo(r), {
    json: t
  } = e, n = e.getExtension(Yp);
  if (n) {
    const i = kG(n, e);
    for (const s of t.materials || []) {
      const l = e.getObjectExtension(s, Yp);
      l && (s.technique = Object.assign(
        {},
        l,
        // @ts-ignore
        i[l.technique]
      ), s.technique.values = FG(s.technique, e)), e.removeObjectExtension(s, Yp);
    }
    e.removeExtension(Yp);
  }
}
async function DG(r, e) {
}
function kG(r, e) {
  const {
    programs: t = [],
    shaders: n = [],
    techniques: i = []
  } = r, s = new TextDecoder();
  return n.forEach((l) => {
    if (Number.isFinite(l.bufferView))
      l.code = s.decode(e.getTypedArrayForBufferView(l.bufferView));
    else
      throw new Error("KHR_techniques_webgl: no shader code");
  }), t.forEach((l) => {
    l.fragmentShader = n[l.fragmentShader], l.vertexShader = n[l.vertexShader];
  }), i.forEach((l) => {
    l.program = t[l.program];
  }), i;
}
function FG(r, e) {
  const t = Object.assign({}, r.values);
  return Object.keys(r.uniforms || {}).forEach((n) => {
    r.uniforms[n].value && !(n in t) && (t[n] = r.uniforms[n].value);
  }), Object.keys(t).forEach((n) => {
    typeof t[n] == "object" && t[n].index !== void 0 && (t[n].texture = e.getTexture(t[n].index));
  }), t;
}
const UG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: NG,
  encode: DG,
  name: OG
}, Symbol.toStringTag, { value: "Module" })), AI = [
  // 1.0
  // KHR_binary_gltf is handled separately - must be processed before other parsing starts
  // KHR_binary_gltf,
  // 2.0
  GV,
  gV,
  Oq,
  kq,
  // Basisu should come after webp, we want basisu to be preferred if both are provided
  zq,
  dG,
  MG,
  LG,
  UG,
  SG,
  aq
];
function zG(r) {
  var i;
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const n = AI.filter((s) => TI(s.name, e));
  for (const s of n)
    (i = s.preprocess) == null || i.call(s, r, e, t);
}
async function jG(r) {
  var i;
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const n = AI.filter((s) => TI(s.name, e));
  for (const s of n)
    await ((i = s.decode) == null ? void 0 : i.call(s, r, e, t));
}
function TI(r, e) {
  var i;
  const t = ((i = e == null ? void 0 : e.gltf) == null ? void 0 : i.excludeExtensions) || {};
  return !(r in t && !t[r]);
}
const Cb = "KHR_binary_glTF";
function VG(r) {
  const e = new lo(r), {
    json: t
  } = e;
  for (const n of t.images || []) {
    const i = e.getObjectExtension(n, Cb);
    i && Object.assign(n, i), e.removeObjectExtension(n, Cb);
  }
  t.buffers && t.buffers[0] && delete t.buffers[0].uri, e.removeExtension(Cb);
}
const w3 = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
}, qG = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
class GG {
  constructor() {
    H(this, "idToIndexMap", {
      animations: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      images: {},
      materials: {},
      meshes: {},
      nodes: {},
      samplers: {},
      scenes: {},
      skins: {},
      textures: {}
    });
    H(this, "json");
  }
  // constructor() {}
  /**
   * Convert (normalize) glTF < 2.0 to glTF 2.0
   * @param gltf - object with json and binChunks
   * @param options
   * @param options normalize Whether to actually normalize
   */
  normalize(e, t) {
    this.json = e.json;
    const n = e.json;
    switch (n.asset && n.asset.version) {
      // We are converting to v2 format. Return if there is nothing to do
      case "2.0":
        return;
      // This class is written to convert 1.0
      case void 0:
      case "1.0":
        break;
      default:
        console.warn(`glTF: Unknown version ${n.asset.version}`);
        return;
    }
    if (!t.normalize)
      throw new Error("glTF v1 is not supported.");
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."), this._addAsset(n), this._convertTopLevelObjectsToArrays(n), VG(e), this._convertObjectIdsToArrayIndices(n), this._updateObjects(n), this._updateMaterial(n);
  }
  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
  _addAsset(e) {
    e.asset = e.asset || {}, e.asset.version = "2.0", e.asset.generator = e.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(e) {
    for (const t in w3)
      this._convertTopLevelObjectToArray(e, t);
  }
  /** Convert one top level object to array */
  _convertTopLevelObjectToArray(e, t) {
    const n = e[t];
    if (!(!n || Array.isArray(n))) {
      e[t] = [];
      for (const i in n) {
        const s = n[i];
        s.id = s.id || i;
        const l = e[t].length;
        e[t].push(s), this.idToIndexMap[t][i] = l;
      }
    }
  }
  /** Go through all objects in all top-level arrays and replace ids with indices */
  _convertObjectIdsToArrayIndices(e) {
    for (const t in w3)
      this._convertIdsToIndices(e, t);
    "scene" in e && (e.scene = this._convertIdToIndex(e.scene, "scene"));
    for (const t of e.textures)
      this._convertTextureIds(t);
    for (const t of e.meshes)
      this._convertMeshIds(t);
    for (const t of e.nodes)
      this._convertNodeIds(t);
    for (const t of e.scenes)
      this._convertSceneIds(t);
  }
  _convertTextureIds(e) {
    e.source && (e.source = this._convertIdToIndex(e.source, "image"));
  }
  _convertMeshIds(e) {
    for (const t of e.primitives) {
      const {
        attributes: n,
        indices: i,
        material: s
      } = t;
      for (const l in n)
        n[l] = this._convertIdToIndex(n[l], "accessor");
      i && (t.indices = this._convertIdToIndex(i, "accessor")), s && (t.material = this._convertIdToIndex(s, "material"));
    }
  }
  _convertNodeIds(e) {
    e.children && (e.children = e.children.map((t) => this._convertIdToIndex(t, "node"))), e.meshes && (e.meshes = e.meshes.map((t) => this._convertIdToIndex(t, "mesh")));
  }
  _convertSceneIds(e) {
    e.nodes && (e.nodes = e.nodes.map((t) => this._convertIdToIndex(t, "node")));
  }
  /** Go through all objects in a top-level array and replace ids with indices */
  _convertIdsToIndices(e, t) {
    e[t] || (console.warn(`gltf v1: json doesn't contain attribute ${t}`), e[t] = []);
    for (const n of e[t])
      for (const i in n) {
        const s = n[i], l = this._convertIdToIndex(s, i);
        n[i] = l;
      }
  }
  _convertIdToIndex(e, t) {
    const n = qG[t];
    if (n in this.idToIndexMap) {
      const i = this.idToIndexMap[n][e];
      if (!Number.isFinite(i))
        throw new Error(`gltf v1: failed to resolve ${t} with id ${e}`);
      return i;
    }
    return e;
  }
  /**
   *
   * @param {*} json
   */
  _updateObjects(e) {
    for (const t of this.json.buffers)
      delete t.type;
  }
  /**
   * Update material (set pbrMetallicRoughness)
   * @param {*} json
   */
  _updateMaterial(e) {
    var t, n, i;
    for (const s of e.materials) {
      s.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const l = ((t = s.values) == null ? void 0 : t.tex) || ((n = s.values) == null ? void 0 : n.texture2d_0) || ((i = s.values) == null ? void 0 : i.diffuseTex), o = e.textures.findIndex((d) => d.id === l);
      o !== -1 && (s.pbrMetallicRoughness.baseColorTexture = {
        index: o
      });
    }
  }
}
function $G(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new GG().normalize(r, e);
}
async function HG(r, e) {
  var s, l, o;
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, n = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 ? arguments[4] : void 0;
  return WG(r, e, t, n), $G(r, {
    normalize: (s = n == null ? void 0 : n.gltf) == null ? void 0 : s.normalize
  }), zG(r, n, i), (l = n == null ? void 0 : n.gltf) != null && l.loadBuffers && r.json.buffers && await XG(r, n, i), (o = n == null ? void 0 : n.gltf) != null && o.loadImages && await ZG(r, n, i), await jG(r, n, i), r;
}
function WG(r, e, t, n) {
  if (n.uri && (r.baseUri = n.uri), e instanceof ArrayBuffer && !gq(e, t, n) && (e = new TextDecoder().decode(e)), typeof e == "string")
    r.json = V4(e);
  else if (e instanceof ArrayBuffer) {
    const l = {};
    t = mq(l, e, t, n.glb), Ja(l.type === "glTF", `Invalid GLB magic string ${l.type}`), r._glb = l, r.json = l.json;
  } else
    Ja(!1, "GLTF: must be ArrayBuffer or string");
  const i = r.json.buffers || [];
  if (r.buffers = new Array(i.length).fill(null), r._glb && r._glb.header.hasBinChunk) {
    const {
      binChunks: l
    } = r._glb;
    r.buffers[0] = {
      arrayBuffer: l[0].arrayBuffer,
      byteOffset: l[0].byteOffset,
      byteLength: l[0].byteLength
    };
  }
  const s = r.json.images || [];
  r.images = new Array(s.length).fill({});
}
async function XG(r, e, t) {
  var i, s;
  const n = r.json.buffers || [];
  for (let l = 0; l < n.length; ++l) {
    const o = n[l];
    if (o.uri) {
      const {
        fetch: d
      } = t;
      Ja(d);
      const m = yI(o.uri, e), b = await ((i = t == null ? void 0 : t.fetch) == null ? void 0 : i.call(t, m)), T = await ((s = b == null ? void 0 : b.arrayBuffer) == null ? void 0 : s.call(b));
      r.buffers[l] = {
        arrayBuffer: T,
        byteOffset: 0,
        byteLength: T.byteLength
      }, delete o.uri;
    } else r.buffers[l] === null && (r.buffers[l] = {
      arrayBuffer: new ArrayBuffer(o.byteLength),
      byteOffset: 0,
      byteLength: o.byteLength
    });
  }
}
async function ZG(r, e, t) {
  const n = YG(r), i = r.json.images || [], s = [];
  for (const l of n)
    s.push(KG(r, i[l], l, e, t));
  return await Promise.all(s);
}
function YG(r) {
  const e = /* @__PURE__ */ new Set(), t = r.json.textures || [];
  for (const n of t)
    n.source !== void 0 && e.add(n.source);
  return Array.from(e).sort();
}
async function KG(r, e, t, n, i) {
  let s;
  if (e.uri && !e.hasOwnProperty("bufferView")) {
    const o = yI(e.uri, n), {
      fetch: d
    } = i;
    s = await (await d(o)).arrayBuffer(), e.bufferView = {
      data: s
    };
  }
  if (Number.isFinite(e.bufferView)) {
    const o = eV(r.json, r.buffers, e.bufferView);
    s = $v(o.buffer, o.byteOffset, o.byteLength);
  }
  Ja(s, "glTF image has no data");
  let l = await Eg(s, [NE, Mj], {
    ...n,
    mimeType: e.mimeType,
    basis: n.basis || {
      format: oI()
    }
  }, i);
  l && l[0] && (l = {
    compressed: !0,
    // @ts-expect-error
    mipmaps: !1,
    width: l[0].width,
    height: l[0].height,
    data: l[0]
  }), r.images = r.images || [], r.images[t] = l;
}
const xg = {
  dataType: null,
  batchType: null,
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: lq,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: !0,
  binary: !0,
  tests: ["glTF"],
  parse: JG,
  options: {
    gltf: {
      normalize: !0,
      // Normalize glTF v1 to glTF v2 format (not yet stable)
      loadBuffers: !0,
      // Fetch any linked .BIN buffers, decode base64
      loadImages: !0,
      // Create image objects
      decompressMeshes: !0
      // Decompress Draco encoded meshes
    },
    // common?
    log: console
    // eslint-disable-line
  }
};
async function JG(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  e = {
    ...xg.options,
    ...e
  }, e.gltf = {
    ...xg.options.gltf,
    ...e.gltf
  };
  const {
    byteOffset: n = 0
  } = e;
  return await HG({}, r, n, e, t);
}
const QG = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, e$ = {
  5120: 1,
  // BYTE
  5121: 1,
  // UNSIGNED_BYTE
  5122: 2,
  // SHORT
  5123: 2,
  // UNSIGNED_SHORT
  5125: 4,
  // UNSIGNED_INT
  5126: 4
  // FLOAT
}, Al = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  // Sampler default values
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
}, t$ = {
  magFilter: Al.TEXTURE_MAG_FILTER,
  minFilter: Al.TEXTURE_MIN_FILTER,
  wrapS: Al.TEXTURE_WRAP_S,
  wrapT: Al.TEXTURE_WRAP_T
}, r$ = {
  [Al.TEXTURE_MAG_FILTER]: Al.LINEAR,
  [Al.TEXTURE_MIN_FILTER]: Al.NEAREST_MIPMAP_LINEAR,
  [Al.TEXTURE_WRAP_S]: Al.REPEAT,
  [Al.TEXTURE_WRAP_T]: Al.REPEAT
};
function n$() {
  return {
    id: "default-sampler",
    parameters: r$
  };
}
function i$(r) {
  return e$[r];
}
function s$(r) {
  return QG[r];
}
class o$ {
  constructor() {
    H(this, "baseUri", "");
    // @ts-expect-error
    H(this, "jsonUnprocessed");
    // @ts-expect-error
    H(this, "json");
    H(this, "buffers", []);
    H(this, "images", []);
  }
  postProcess(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      json: n,
      buffers: i = [],
      images: s = []
    } = e, {
      baseUri: l = ""
    } = e;
    return Ja(n), this.baseUri = l, this.buffers = i, this.images = s, this.jsonUnprocessed = n, this.json = this._resolveTree(e.json, t), this.json;
  }
  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity, max-statements
  _resolveTree(e) {
    const t = {
      ...e
    };
    return this.json = t, e.bufferViews && (t.bufferViews = e.bufferViews.map((n, i) => this._resolveBufferView(n, i))), e.images && (t.images = e.images.map((n, i) => this._resolveImage(n, i))), e.samplers && (t.samplers = e.samplers.map((n, i) => this._resolveSampler(n, i))), e.textures && (t.textures = e.textures.map((n, i) => this._resolveTexture(n, i))), e.accessors && (t.accessors = e.accessors.map((n, i) => this._resolveAccessor(n, i))), e.materials && (t.materials = e.materials.map((n, i) => this._resolveMaterial(n, i))), e.meshes && (t.meshes = e.meshes.map((n, i) => this._resolveMesh(n, i))), e.nodes && (t.nodes = e.nodes.map((n, i) => this._resolveNode(n, i)), t.nodes = t.nodes.map((n, i) => this._resolveNodeChildren(n))), e.skins && (t.skins = e.skins.map((n, i) => this._resolveSkin(n, i))), e.scenes && (t.scenes = e.scenes.map((n, i) => this._resolveScene(n, i))), typeof this.json.scene == "number" && t.scenes && (t.scene = t.scenes[this.json.scene]), t;
  }
  getScene(e) {
    return this._get(this.json.scenes, e);
  }
  getNode(e) {
    return this._get(this.json.nodes, e);
  }
  getSkin(e) {
    return this._get(this.json.skins, e);
  }
  getMesh(e) {
    return this._get(this.json.meshes, e);
  }
  getMaterial(e) {
    return this._get(this.json.materials, e);
  }
  getAccessor(e) {
    return this._get(this.json.accessors, e);
  }
  getCamera(e) {
    return this._get(this.json.cameras, e);
  }
  getTexture(e) {
    return this._get(this.json.textures, e);
  }
  getSampler(e) {
    return this._get(this.json.samplers, e);
  }
  getImage(e) {
    return this._get(this.json.images, e);
  }
  getBufferView(e) {
    return this._get(this.json.bufferViews, e);
  }
  getBuffer(e) {
    return this._get(this.json.buffers, e);
  }
  _get(e, t) {
    if (typeof t == "object")
      return t;
    const n = e && e[t];
    return n || console.warn(`glTF file error: Could not find ${e}[${t}]`), n;
  }
  // PARSING HELPERS
  _resolveScene(e, t) {
    return {
      ...e,
      // @ts-ignore
      id: e.id || `scene-${t}`,
      nodes: (e.nodes || []).map((n) => this.getNode(n))
    };
  }
  _resolveNode(e, t) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: (e == null ? void 0 : e.id) || `node-${t}`
    };
    return e.mesh !== void 0 && (n.mesh = this.getMesh(e.mesh)), e.camera !== void 0 && (n.camera = this.getCamera(e.camera)), e.skin !== void 0 && (n.skin = this.getSkin(e.skin)), e.meshes !== void 0 && e.meshes.length && (n.mesh = e.meshes.reduce((i, s) => {
      const l = this.getMesh(s);
      return i.id = l.id, i.primitives = i.primitives.concat(l.primitives), i;
    }, {
      primitives: []
    })), n;
  }
  _resolveNodeChildren(e) {
    return e.children && (e.children = e.children.map((t) => this.getNode(t))), e;
  }
  _resolveSkin(e, t) {
    const n = typeof e.inverseBindMatrices == "number" ? this.getAccessor(e.inverseBindMatrices) : void 0;
    return {
      ...e,
      id: e.id || `skin-${t}`,
      inverseBindMatrices: n
    };
  }
  _resolveMesh(e, t) {
    const n = {
      ...e,
      id: e.id || `mesh-${t}`,
      primitives: []
    };
    return e.primitives && (n.primitives = e.primitives.map((i) => {
      const s = {
        ...i,
        attributes: {},
        indices: void 0,
        material: void 0
      }, l = i.attributes;
      for (const o in l)
        s.attributes[o] = this.getAccessor(l[o]);
      return i.indices !== void 0 && (s.indices = this.getAccessor(i.indices)), i.material !== void 0 && (s.material = this.getMaterial(i.material)), s;
    })), n;
  }
  _resolveMaterial(e, t) {
    const n = {
      ...e,
      // @ts-expect-error
      id: e.id || `material-${t}`
    };
    if (n.normalTexture && (n.normalTexture = {
      ...n.normalTexture
    }, n.normalTexture.texture = this.getTexture(n.normalTexture.index)), n.occlusionTexture && (n.occlusionTexture = {
      ...n.occlusionTexture
    }, n.occlusionTexture.texture = this.getTexture(n.occlusionTexture.index)), n.emissiveTexture && (n.emissiveTexture = {
      ...n.emissiveTexture
    }, n.emissiveTexture.texture = this.getTexture(n.emissiveTexture.index)), n.emissiveFactor || (n.emissiveFactor = n.emissiveTexture ? [1, 1, 1] : [0, 0, 0]), n.pbrMetallicRoughness) {
      n.pbrMetallicRoughness = {
        ...n.pbrMetallicRoughness
      };
      const i = n.pbrMetallicRoughness;
      i.baseColorTexture && (i.baseColorTexture = {
        ...i.baseColorTexture
      }, i.baseColorTexture.texture = this.getTexture(i.baseColorTexture.index)), i.metallicRoughnessTexture && (i.metallicRoughnessTexture = {
        ...i.metallicRoughnessTexture
      }, i.metallicRoughnessTexture.texture = this.getTexture(i.metallicRoughnessTexture.index));
    }
    return n;
  }
  _resolveAccessor(e, t) {
    const n = i$(e.componentType), i = s$(e.type), s = n * i, l = {
      ...e,
      // @ts-expect-error
      id: e.id || `accessor-${t}`,
      bytesPerComponent: n,
      components: i,
      bytesPerElement: s,
      value: void 0,
      bufferView: void 0,
      sparse: void 0
    };
    if (e.bufferView !== void 0 && (l.bufferView = this.getBufferView(e.bufferView)), l.bufferView) {
      const o = l.bufferView.buffer, {
        ArrayType: d,
        byteLength: m
      } = k2(l, l.bufferView), b = (l.bufferView.byteOffset || 0) + (l.byteOffset || 0) + o.byteOffset;
      let T = o.arrayBuffer.slice(b, b + m);
      l.bufferView.byteStride && (T = this._getValueFromInterleavedBuffer(o, b, l.bufferView.byteStride, l.bytesPerElement, l.count)), l.value = new d(T);
    }
    return l;
  }
  /**
   * Take values of particular accessor from interleaved buffer
   * various parts of the buffer
   * @param buffer
   * @param byteOffset
   * @param byteStride
   * @param bytesPerElement
   * @param count
   * @returns
   */
  _getValueFromInterleavedBuffer(e, t, n, i, s) {
    const l = new Uint8Array(s * i);
    for (let o = 0; o < s; o++) {
      const d = t + o * n;
      l.set(new Uint8Array(e.arrayBuffer.slice(d, d + i)), o * i);
    }
    return l.buffer;
  }
  _resolveTexture(e, t) {
    return {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `texture-${t}`,
      sampler: typeof e.sampler == "number" ? this.getSampler(e.sampler) : n$(),
      source: typeof e.source == "number" ? this.getImage(e.source) : void 0
    };
  }
  _resolveSampler(e, t) {
    const n = {
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `sampler-${t}`,
      ...e,
      parameters: {}
    };
    for (const i in n) {
      const s = this._enumSamplerParameter(i);
      s !== void 0 && (n.parameters[s] = n[i]);
    }
    return n;
  }
  _enumSamplerParameter(e) {
    return t$[e];
  }
  _resolveImage(e, t) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `image-${t}`,
      image: null,
      bufferView: e.bufferView !== void 0 ? this.getBufferView(e.bufferView) : void 0
    }, i = this.images[t];
    return i && (n.image = i), n;
  }
  _resolveBufferView(e, t) {
    const n = e.buffer, i = this.buffers[n].arrayBuffer;
    let s = this.buffers[n].byteOffset || 0;
    return e.byteOffset && (s += e.byteOffset), {
      // // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: `bufferView-${t}`,
      ...e,
      // ...this.buffers[bufferIndex],
      buffer: this.buffers[n],
      data: new Uint8Array(i, s, e.byteLength)
    };
  }
  _resolveCamera(e, t) {
    const n = {
      ...e,
      // @ts-expect-error id could already be present, glTF standard does not prevent it
      id: e.id || `camera-${t}`
    };
    return n.perspective, n.orthographic, n;
  }
}
function V2(r, e) {
  return new o$().postProcess(r, e);
}
async function a$(r) {
  const e = [];
  return r.scenes.forEach((t) => {
    t.traverse((n) => {
      Object.values(n.model.uniforms).forEach((i) => {
        i.loaded === !1 && e.push(i);
      });
    });
  }), await l$(() => e.some((t) => !t.loaded));
}
async function l$(r) {
  for (; r(); )
    await new Promise((e) => requestAnimationFrame(e));
}
const A3 = `uniform scenegraphUniforms {
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  mat4 sceneModelMatrix;
  bool composeModelMatrix;
} scenegraph;
`, c$ = {
  name: "scenegraph",
  vs: A3,
  fs: A3,
  uniformTypes: {
    sizeScale: "f32",
    sizeMinPixels: "f32",
    sizeMaxPixels: "f32",
    sceneModelMatrix: "mat4x4<f32>",
    composeModelMatrix: "f32"
  }
}, u$ = `#version 300 es
#define SHADER_NAME scenegraph-layer-vertex-shader
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
in vec3 positions;
#ifdef HAS_UV
in vec2 texCoords;
#endif
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
in vec3 normals;
#endif
#endif
out vec4 vColor;
#ifndef LIGHTING_PBR
#ifdef HAS_UV
out vec2 vTEXCOORD_0;
#endif
#endif
void main(void) {
#if defined(HAS_UV) && !defined(LIGHTING_PBR)
vTEXCOORD_0 = texCoords;
geometry.uv = texCoords;
#endif
geometry.worldPosition = instancePositions;
geometry.pickingColor = instancePickingColors;
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 normal = vec3(0.0, 0.0, 1.0);
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
normal = instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(normals, 0.0)).xyz;
#endif
#endif
float originalSize = project_size_to_pixel(scenegraph.sizeScale);
float clampedSize = clamp(originalSize, scenegraph.sizeMinPixels, scenegraph.sizeMaxPixels);
vec3 pos = (instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(positions, 1.0)).xyz) * scenegraph.sizeScale * (clampedSize / originalSize) + instanceTranslation;
if(scenegraph.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
geometry.normal = project_normal(normal);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
geometry.normal = project_normal(normal);
}
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef LIGHTING_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = texCoords;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, h$ = `#version 300 es
#define SHADER_NAME scenegraph-layer-fragment-shader
in vec4 vColor;
out vec4 fragColor;
#ifndef LIGHTING_PBR
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
in vec2 vTEXCOORD_0;
uniform sampler2D pbr_baseColorSampler;
#endif
#endif
void main(void) {
#ifdef LIGHTING_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
#else
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
fragColor = vColor * texture(pbr_baseColorSampler, vTEXCOORD_0);
geometry.uv = vTEXCOORD_0;
#else
fragColor = vColor;
#endif
#endif
fragColor.a *= layer.opacity;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, SI = [255, 255, 255, 255], f$ = {
  scenegraph: {
    type: "object",
    value: null,
    async: !0
  },
  getScene: (r) => r && r.scenes ? typeof r.scene == "object" ? r.scene : r.scenes[r.scene || 0] : r,
  getAnimator: (r) => r && r.animator,
  _animations: null,
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  sizeMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  getPosition: {
    type: "accessor",
    value: (r) => r.position
  },
  getColor: {
    type: "accessor",
    value: SI
  },
  // flat or pbr
  _lighting: "flat",
  // _lighting must be pbr for this to work
  _imageBasedLightingEnvironment: void 0,
  // yaw, pitch and roll are in degrees
  // https://en.wikipedia.org/wiki/Euler_angles
  // [pitch, yaw, roll]
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  // 4x4 matrix
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  loaders: [xg]
};
class q2 extends tp {
  getShaders() {
    const e = {};
    let t;
    this.props._lighting === "pbr" ? (t = _2, e.LIGHTING_PBR = 1) : t = {
      name: "pbrMaterial"
    };
    const n = [b2, A2, c$, t];
    return super.getShaders({
      defines: e,
      vs: u$,
      fs: h$,
      modules: n
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: "float64",
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: !0
      },
      instanceColors: {
        type: "unorm8",
        size: this.props.colorFormat.length,
        accessor: "getColor",
        defaultValue: SI,
        transition: !0
      },
      instanceModelMatrix: rI
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: n
    } = e;
    t.scenegraph !== n.scenegraph ? this._updateScenegraph() : t._animations !== n._animations && this._applyAnimationsProp(this.state.animator, t._animations);
  }
  finalizeState(e) {
    var t;
    super.finalizeState(e), (t = this.state.scenegraph) == null || t.destroy();
  }
  get isLoaded() {
    var e;
    return !!((e = this.state) != null && e.scenegraph && super.isLoaded);
  }
  _updateScenegraph() {
    var o;
    const e = this.props, {
      device: t
    } = this.context;
    let n = null;
    if (e.scenegraph instanceof z_)
      n = {
        scenes: [e.scenegraph]
      };
    else if (e.scenegraph && typeof e.scenegraph == "object") {
      const d = e.scenegraph, m = d.json ? V2(d) : d, b = Wj(t, m, this._getModelOptions());
      n = {
        gltf: m,
        ...b
      }, a$(b).then(() => {
        this.setNeedsRedraw();
      }).catch((T) => {
        this.raiseError(T, "loading glTF");
      });
    }
    const i = {
      layer: this,
      device: this.context.device
    }, s = e.getScene(n, i), l = e.getAnimator(n, i);
    if (s instanceof Md) {
      (o = this.state.scenegraph) == null || o.destroy(), this._applyAnimationsProp(l, e._animations);
      const d = [];
      s.traverse((m) => {
        m instanceof Z1 && d.push(m.model);
      }), this.setState({
        scenegraph: s,
        animator: l,
        models: d
      }), this.getAttributeManager().invalidateAll();
    } else s !== null && qn.warn("invalid scenegraph:", s)();
  }
  _applyAnimationsProp(e, t) {
    if (!e || !t)
      return;
    const n = e.getAnimations();
    Object.keys(t).sort().forEach((i) => {
      const s = t[i];
      if (i === "*")
        n.forEach((l) => {
          Object.assign(l, s);
        });
      else if (Number.isFinite(Number(i))) {
        const l = Number(i);
        l >= 0 && l < n.length ? Object.assign(n[l], s) : qn.warn(`animation ${i} not found`)();
      } else {
        const l = n.find((o) => {
          let {
            name: d
          } = o;
          return d === i;
        });
        l ? Object.assign(l, s) : qn.warn(`animation ${i} not found`)();
      }
    });
  }
  _getModelOptions() {
    const {
      _imageBasedLightingEnvironment: e
    } = this.props;
    let t;
    return e && (typeof e == "function" ? t = e({
      gl: this.context.gl,
      layer: this
    }) : t = e), {
      imageBasedLightingEnvironment: t,
      modelOptions: {
        id: this.props.id,
        isInstanced: !0,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        ...this.getShaders()
      },
      // tangents are not supported
      useTangents: !1
    };
  }
  draw(e) {
    let {
      context: t
    } = e;
    if (!this.state.scenegraph) return;
    this.props._animations && this.state.animator && (this.state.animator.animate(t.timeline.getTime()), this.setNeedsRedraw());
    const {
      viewport: n,
      renderPass: i
    } = this.context, {
      sizeScale: s,
      sizeMinPixels: l,
      sizeMaxPixels: o,
      coordinateSystem: d
    } = this.props, m = this.getNumInstances();
    this.state.scenegraph.traverse((b, T) => {
      let {
        worldMatrix: M
      } = T;
      if (b instanceof Z1) {
        const {
          model: E
        } = b;
        E.setInstanceCount(m);
        const D = {
          // Needed for PBR (TODO: find better way to get it)
          camera: E.uniforms.cameraPosition
        }, U = {
          sizeScale: s,
          sizeMinPixels: l,
          sizeMaxPixels: o,
          composeModelMatrix: nI(n, d),
          sceneModelMatrix: M
        };
        E.shaderInputs.setProps({
          pbrProjection: D,
          scenegraph: U
        }), E.draw(i);
      }
    });
  }
}
q2.defaultProps = f$;
q2.layerName = "ScenegraphLayer";
const T3 = `uniform meshUniforms {
  bool pickFeatureIds;
} mesh;
`, d$ = {
  name: "mesh",
  vs: T3,
  fs: T3,
  uniformTypes: {
    pickFeatureIds: "f32"
  }
}, p$ = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
vec2 applyUVRegion(vec2 uv) {
#ifdef HAS_UV_REGIONS
return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
#else
return uv;
#endif
}
void main(void) {
vec2 uv = applyUVRegion(texCoords);
geometry.uv = uv;
if (mesh.pickFeatureIds) {
geometry.pickingColor = featureIdsPickingColors;
} else {
geometry.pickingColor = instancePickingColors;
}
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vTexCoord = uv;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale;
vec3 projectedPosition = project_position(positions);
position_commonspace = vec4(projectedPosition, 1.0);
gl_Position = project_common_position_to_clipspace(position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef MODULE_PBRMATERIAL
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = uv;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, g$ = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
#ifdef MODULE_PBRMATERIAL
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
fragColor.a *= layer.opacity;
#else
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
function m$(r) {
  const e = r.positions || r.POSITION, t = e.value.length / e.size;
  r.COLOR_0 || r.colors || (r.colors = {
    size: 4,
    value: new Uint8Array(t * 4).fill(255),
    normalized: !0
  });
}
const _$ = {
  pbrMaterial: {
    type: "object",
    value: null
  },
  featureIds: {
    type: "array",
    value: null,
    optional: !0
  }
};
class G2 extends D2 {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(_2, d$), {
      ...e,
      vs: p$,
      fs: g$
    };
  }
  initializeState() {
    const {
      featureIds: e
    } = this.props;
    super.initializeState();
    const t = this.getAttributeManager();
    e && t.add({
      featureIdsPickingColors: {
        type: "uint8",
        size: 3,
        noAlloc: !0,
        // eslint-disable-next-line @typescript-eslint/unbound-method
        update: this.calculateFeatureIdsPickingColors
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: n
    } = e;
    t.pbrMaterial !== n.pbrMaterial && this.updatePbrMaterialUniforms(t.pbrMaterial);
  }
  draw(e) {
    const {
      featureIds: t
    } = this.props, {
      model: n
    } = this.state;
    if (!n)
      return;
    const i = {
      pickFeatureIds: !!t
    }, s = {
      // Needed for PBR (TODO: find better way to get it)
      camera: n.uniforms.cameraPosition
    };
    n.shaderInputs.setProps({
      pbrProjection: s,
      mesh: i
    }), super.draw(e);
  }
  getModel(e) {
    const {
      id: t
    } = this.props, n = this.parseMaterial(this.props.pbrMaterial, e);
    this.setState({
      parsedPBRMaterial: n
    });
    const i = this.getShaders();
    return m$(e.attributes), new Lh(this.context.device, {
      ...this.getShaders(),
      id: t,
      geometry: e,
      bufferLayout: this.getAttributeManager().getBufferLayouts(),
      defines: {
        ...i.defines,
        ...n == null ? void 0 : n.defines,
        HAS_UV_REGIONS: e.attributes.uvRegions ? 1 : 0
      },
      parameters: n == null ? void 0 : n.parameters,
      isInstanced: !0
    });
  }
  updatePbrMaterialUniforms(e) {
    const {
      model: t
    } = this.state;
    if (t) {
      const {
        mesh: n
      } = this.props, i = this.parseMaterial(e, n);
      this.setState({
        parsedPBRMaterial: i
      });
      const {
        pbr_baseColorSampler: s
      } = i.bindings, {
        emptyTexture: l
      } = this.state, o = {
        sampler: s || l,
        hasTexture: !!s
      }, {
        camera: d,
        ...m
      } = {
        ...i.bindings,
        ...i.uniforms
      };
      t.shaderInputs.setProps({
        simpleMesh: o,
        pbrMaterial: m
      });
    }
  }
  parseMaterial(e, t) {
    const n = !!(e.pbrMetallicRoughness && e.pbrMetallicRoughness.baseColorTexture);
    return iI(this.context.device, {
      unlit: n,
      ...e
    }, {
      NORMAL: t.attributes.normals,
      TEXCOORD_0: t.attributes.texCoords
    }, {
      pbrDebug: !1,
      lights: !0,
      useTangents: !1
    });
  }
  calculateFeatureIdsPickingColors(e) {
    const t = this.props.featureIds, n = new Uint8ClampedArray(t.length * e.size), i = [];
    for (let s = 0; s < t.length; s++)
      this.encodePickingColor(t[s], i), n[s * 3] = i[0], n[s * 3 + 1] = i[1], n[s * 3 + 2] = i[2];
    e.value = n;
  }
  finalizeState(e) {
    var t;
    super.finalizeState(e), (t = this.state.parsedPBRMaterial) == null || t.generatedTextures.forEach((n) => n.destroy()), this.setState({
      parsedPBRMaterial: null
    });
  }
}
G2.layerName = "MeshLayer";
G2.defaultProps = _$;
const y$ = 6378137, b$ = 6378137, v$ = 6356752314245179e-9;
function Iy(r) {
  return r;
}
new Tt();
function x$(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Iy;
  return "longitude" in r ? (e[0] = t(r.longitude), e[1] = t(r.latitude), e[2] = r.height) : "x" in r ? (e[0] = t(r.x), e[1] = t(r.y), e[2] = r.z) : (e[0] = t(r[0]), e[1] = t(r[1]), e[2] = r[2]), e;
}
function w$(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return x$(r, e, Zs._cartographicRadians ? Iy : oN);
}
function A$(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Iy;
  return "longitude" in e ? (e.longitude = t(r[0]), e.latitude = t(r[1]), e.height = r[2]) : "x" in e ? (e.x = t(r[0]), e.y = t(r[1]), e.z = r[2]) : (e[0] = t(r[0]), e[1] = t(r[1]), e[2] = r[2]), e;
}
function T$(r, e) {
  return A$(r, e, Zs._cartographicRadians ? Iy : aN);
}
const S3 = 1e-14, S$ = new Tt(), E3 = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
}, Ib = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, Np = {
  east: new Tt(),
  north: new Tt(),
  up: new Tt(),
  west: new Tt(),
  south: new Tt(),
  down: new Tt()
}, E$ = new Tt(), C$ = new Tt(), I$ = new Tt();
function C3(r, e, t, n, i, s) {
  const l = E3[e] && E3[e][t];
  bc(l && (!n || n === l));
  let o, d, m;
  const b = S$.copy(i);
  if (Cc(b.x, 0, S3) && Cc(b.y, 0, S3)) {
    const M = Math.sign(b.z);
    o = E$.fromArray(Ib[e]), e !== "east" && e !== "west" && o.scale(M), d = C$.fromArray(Ib[t]), t !== "east" && t !== "west" && d.scale(M), m = I$.fromArray(Ib[n]), n !== "east" && n !== "west" && m.scale(M);
  } else {
    const {
      up: M,
      east: E,
      north: D
    } = Np;
    E.set(-b.y, b.x, 0).normalize(), r.geodeticSurfaceNormal(b, M), D.copy(M).cross(E);
    const {
      down: U,
      west: q,
      south: G
    } = Np;
    U.copy(M).scale(-1), q.copy(E).scale(-1), G.copy(D).scale(-1), o = Np[e], d = Np[t], m = Np[n];
  }
  return s[0] = o.x, s[1] = o.y, s[2] = o.z, s[3] = 0, s[4] = d.x, s[5] = d.y, s[6] = d.z, s[7] = 0, s[8] = m.x, s[9] = m.y, s[10] = m.z, s[11] = 0, s[12] = b.x, s[13] = b.y, s[14] = b.z, s[15] = 1, s;
}
const ld = new Tt(), M$ = new Tt(), P$ = new Tt();
function R$(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  const {
    oneOverRadii: n,
    oneOverRadiiSquared: i,
    centerToleranceSquared: s
  } = e;
  ld.from(r);
  const l = ld.x, o = ld.y, d = ld.z, m = n.x, b = n.y, T = n.z, M = l * l * m * m, E = o * o * b * b, D = d * d * T * T, U = M + E + D, q = Math.sqrt(1 / U);
  if (!Number.isFinite(q))
    return;
  const G = M$;
  if (G.copy(r).scale(q), U < s)
    return G.to(t);
  const Y = i.x, he = i.y, X = i.z, J = P$;
  J.set(G.x * Y * 2, G.y * he * 2, G.z * X * 2);
  let ie = (1 - q) * ld.len() / (0.5 * J.len()), ye = 0, oe, Re, Ne, me;
  do {
    ie -= ye, oe = 1 / (1 + ie * Y), Re = 1 / (1 + ie * he), Ne = 1 / (1 + ie * X);
    const _e = oe * oe, Fe = Re * Re, Me = Ne * Ne, Ct = _e * oe, ht = Fe * Re, Pt = Me * Ne;
    me = M * _e + E * Fe + D * Me - 1;
    const kt = -2 * (M * Ct * Y + E * ht * he + D * Pt * X);
    ye = me / kt;
  } while (Math.abs(me) > ED);
  return ld.scale([oe, Re, Ne]).to(t);
}
const Rm = new Tt(), I3 = new Tt(), B$ = new Tt(), uc = new Tt(), L$ = new Tt(), Bm = new Tt();
class wi {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    this.centerToleranceSquared = SD, bc(e >= 0), bc(t >= 0), bc(n >= 0), this.radii = new Tt(e, t, n), this.radiiSquared = new Tt(e * e, t * t, n * n), this.radiiToTheFourth = new Tt(e * e * e * e, t * t * t * t, n * n * n * n), this.oneOverRadii = new Tt(e === 0 ? 0 : 1 / e, t === 0 ? 0 : 1 / t, n === 0 ? 0 : 1 / n), this.oneOverRadiiSquared = new Tt(e === 0 ? 0 : 1 / (e * e), t === 0 ? 0 : 1 / (t * t), n === 0 ? 0 : 1 / (n * n)), this.minimumRadius = Math.min(e, t, n), this.maximumRadius = Math.max(e, t, n), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);
  }
  /** Compares this Ellipsoid against the provided Ellipsoid componentwise */
  equals(e) {
    return this === e || !!(e && this.radii.equals(e.radii));
  }
  /** Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'. */
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const n = I3, i = B$, [, , s] = e;
    this.geodeticSurfaceNormalCartographic(e, n), i.copy(this.radiiSquared).scale(n);
    const l = Math.sqrt(n.dot(i));
    return i.scale(1 / l), n.scale(s), i.add(n), i.to(t);
  }
  cartesianToCartographic(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    Bm.from(e);
    const n = this.scaleToGeodeticSurface(Bm, uc);
    if (!n)
      return;
    const i = this.geodeticSurfaceNormal(n, I3), s = L$;
    s.copy(Bm).subtract(n);
    const l = Math.atan2(i.y, i.x), o = Math.asin(i.z), d = Math.sign(f2(s, Bm)) * I5(s);
    return T$([l, o, d], t);
  }
  eastNorthUpToFixedFrame(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Cn();
    return C3(this, "east", "north", "up", e, t);
  }
  // Computes a 4x4 transformation matrix from a reference frame centered at
  // the provided origin to the ellipsoid's fixed reference frame.
  localFrameToFixedFrame(e, t, n, i) {
    let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new Cn();
    return C3(this, e, t, n, i, s);
  }
  geocentricSurfaceNormal(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return Rm.from(e).normalize().to(t);
  }
  geodeticSurfaceNormalCartographic(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const n = w$(e), i = n[0], s = n[1], l = Math.cos(s);
    return Rm.set(l * Math.cos(i), l * Math.sin(i), Math.sin(s)).normalize(), Rm.to(t);
  }
  geodeticSurfaceNormal(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return Rm.from(e).scale(this.oneOverRadiiSquared).normalize().to(t);
  }
  /** Scales the provided Cartesian position along the geodetic surface normal
   * so that it is on the surface of this ellipsoid.  If the position is
   * at the center of the ellipsoid, this function returns undefined. */
  scaleToGeodeticSurface(e, t) {
    return R$(e, this, t);
  }
  /** Scales the provided Cartesian position along the geocentric surface normal
   * so that it is on the surface of this ellipsoid. */
  scaleToGeocentricSurface(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    uc.from(e);
    const n = uc.x, i = uc.y, s = uc.z, l = this.oneOverRadiiSquared, o = 1 / Math.sqrt(n * n * l.x + i * i * l.y + s * s * l.z);
    return uc.multiplyScalar(o).to(t);
  }
  /** Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#oneOverRadii` */
  transformPositionToScaledSpace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return uc.from(e).scale(this.oneOverRadii).to(t);
  }
  /** Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
   * its components by the result of `Ellipsoid#radii`. */
  transformPositionFromScaledSpace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return uc.from(e).scale(this.radii).to(t);
  }
  /** Computes a point which is the intersection of the surface normal with the z-axis. */
  getSurfaceNormalIntersectionWithZAxis(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0, 0, 0];
    bc(Cc(this.radii.x, this.radii.y, U5)), bc(this.radii.z > 0), uc.from(e);
    const i = uc.z * (1 - this.squaredXOverSquaredZ);
    if (!(Math.abs(i) >= this.radii.z - t))
      return uc.set(0, 0, i).to(n);
  }
}
wi.WGS84 = new wi(y$, b$, v$);
class O$ {
  constructor(e, t, n) {
    H(this, "item");
    H(this, "previous");
    H(this, "next");
    this.item = e, this.previous = t, this.next = n;
  }
}
class N$ {
  constructor() {
    H(this, "head", null);
    H(this, "tail", null);
    H(this, "_length", 0);
  }
  get length() {
    return this._length;
  }
  /**
   * Adds the item to the end of the list
   * @param {*} [item]
   * @return {DoublyLinkedListNode}
   */
  add(e) {
    const t = new O$(e, this.tail, null);
    return this.tail ? (this.tail.next = t, this.tail = t) : (this.head = t, this.tail = t), ++this._length, t;
  }
  /**
   * Removes the given node from the list
   * @param {DoublyLinkedListNode} node
   */
  remove(e) {
    e && (e.previous && e.next ? (e.previous.next = e.next, e.next.previous = e.previous) : e.previous ? (e.previous.next = null, this.tail = e.previous) : e.next ? (e.next.previous = null, this.head = e.next) : (this.head = null, this.tail = null), e.next = null, e.previous = null, --this._length);
  }
  /**
   * Moves nextNode after node
   * @param {DoublyLinkedListNode} node
   * @param {DoublyLinkedListNode} nextNode
   */
  splice(e, t) {
    e !== t && (this.remove(t), this._insert(e, t));
  }
  _insert(e, t) {
    const n = e.next;
    e.next = t, this.tail === e ? this.tail = t : n.previous = t, t.next = n, t.previous = e, ++this._length;
  }
}
class D$ {
  constructor() {
    H(this, "_list");
    H(this, "_sentinel");
    H(this, "_trimTiles");
    this._list = new N$(), this._sentinel = this._list.add("sentinel"), this._trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(e) {
    const t = e._cacheNode;
    t && this._list.splice(this._sentinel, t);
  }
  add(e, t, n) {
    t._cacheNode || (t._cacheNode = this._list.add(t), n && n(e, t));
  }
  unloadTile(e, t, n) {
    const i = t._cacheNode;
    i && (this._list.remove(i), t._cacheNode = null, n && n(e, t));
  }
  unloadTiles(e, t) {
    const n = this._trimTiles;
    this._trimTiles = !1;
    const i = this._list, s = e.maximumMemoryUsage * 1024 * 1024, l = this._sentinel;
    let o = i.head;
    for (; o !== l && (e.gpuMemoryUsageInBytes > s || n); ) {
      const d = o.item;
      o = o.next, this.unloadTile(e, d, t);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
function k$(r, e) {
  xi(r), xi(e);
  const {
    rtcCenter: t,
    gltfUpAxis: n
  } = e, {
    computedTransform: i,
    boundingVolume: {
      center: s
    }
  } = r;
  let l = new Cn(i);
  switch (t && l.translate(t), n) {
    case "Z":
      break;
    case "Y":
      const T = new Cn().rotateX(Math.PI / 2);
      l = l.multiplyRight(T);
      break;
    case "X":
      const M = new Cn().rotateY(-Math.PI / 2);
      l = l.multiplyRight(M);
      break;
  }
  e.isQuantized && l.translate(e.quantizedVolumeOffset).scale(e.quantizedVolumeScale);
  const o = new Tt(s);
  e.cartesianModelMatrix = l, e.cartesianOrigin = o;
  const d = wi.WGS84.cartesianToCartographic(o, new Tt()), b = wi.WGS84.eastNorthUpToFixedFrame(o).invert();
  e.cartographicModelMatrix = b.multiplyRight(l), e.cartographicOrigin = d, e.coordinateSystem || (e.modelMatrix = e.cartographicModelMatrix);
}
const M3 = new Tt(), Mb = new Tt(), hv = new Tl([new iu(), new iu(), new iu(), new iu(), new iu(), new iu()]);
function F$(r, e) {
  const {
    cameraDirection: t,
    cameraUp: n,
    height: i
  } = r, {
    metersPerUnit: s
  } = r.distanceScales, l = t_(r, r.center), o = wi.WGS84.eastNorthUpToFixedFrame(l), d = r.unprojectPosition(r.cameraPosition), m = wi.WGS84.cartographicToCartesian(d, new Tt()), b = new Tt(
    // @ts-ignore
    o.transformAsVector(new Tt(t).scale(s))
  ).normalize(), T = new Tt(
    // @ts-ignore
    o.transformAsVector(new Tt(n).scale(s))
  ).normalize();
  z$(r);
  const M = r.constructor, {
    longitude: E,
    latitude: D,
    width: U,
    bearing: q,
    zoom: G
  } = r, Y = new M({
    longitude: E,
    latitude: D,
    height: i,
    width: U,
    bearing: q,
    zoom: G,
    pitch: 0
  });
  return {
    camera: {
      position: m,
      direction: b,
      up: T
    },
    viewport: r,
    topDownViewport: Y,
    height: i,
    cullingVolume: hv,
    frameNumber: e,
    // TODO: This can be the same between updates, what number is unique for between updates?
    sseDenominator: 1.15
    // Assumes fovy = 60 degrees
  };
}
function U$(r, e, t) {
  if (t === 0 || r.length <= t)
    return [r, []];
  const n = [], {
    longitude: i,
    latitude: s
  } = e.viewport;
  for (const [m, b] of r.entries()) {
    const [T, M] = b.header.mbs, E = Math.abs(i - T), D = Math.abs(s - M), U = Math.sqrt(D * D + E * E);
    n.push([m, U]);
  }
  const l = n.sort((m, b) => m[1] - b[1]), o = [];
  for (let m = 0; m < t; m++)
    o.push(r[l[m][0]]);
  const d = [];
  for (let m = t; m < l.length; m++)
    d.push(r[l[m][0]]);
  return [o, d];
}
function z$(r) {
  const e = r.getFrustumPlanes(), t = P3(e.near, r.cameraPosition), n = t_(r, t), i = t_(r, r.cameraPosition, Mb);
  let s = 0;
  hv.planes[s++].fromPointNormal(n, M3.copy(n).subtract(i));
  for (const l in e) {
    if (l === "near")
      continue;
    const o = e[l], d = P3(o, t, Mb), m = t_(r, d, Mb);
    hv.planes[s++].fromPointNormal(
      m,
      // Want the normal to point into the frustum since that's what culling expects
      M3.copy(n).subtract(m)
    );
  }
}
function P3(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Tt();
  const n = r.normal.dot(e);
  return t.copy(r.normal).scale(r.distance - n).add(e), t;
}
function t_(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Tt();
  const n = r.unprojectPosition(e);
  return wi.WGS84.cartographicToCartesian(n, t);
}
const j$ = 6378137, V$ = 6378137, fv = 6356752314245179e-9, wd = new Tt();
function q$(r, e) {
  if (r instanceof Lg) {
    const {
      halfAxes: t
    } = r, n = $$(t);
    return Math.log2(fv / (n + e[2]));
  } else if (r instanceof Bg) {
    const {
      radius: t
    } = r;
    return Math.log2(fv / (t + e[2]));
  } else if (r.width && r.height) {
    const {
      width: t,
      height: n
    } = r, i = Math.log2(j$ / t), s = Math.log2(V$ / n);
    return (i + s) / 2;
  }
  return 1;
}
function EI(r, e, t) {
  wi.WGS84.cartographicToCartesian([r.xmax, r.ymax, r.zmax], wd);
  const n = Math.sqrt(Math.pow(wd[0] - t[0], 2) + Math.pow(wd[1] - t[1], 2) + Math.pow(wd[2] - t[2], 2));
  return Math.log2(fv / (n + e[2]));
}
function G$(r, e, t) {
  const [n, i, s, l] = r;
  return EI({
    xmax: s,
    ymax: l,
    zmax: 0
  }, e, t);
}
function $$(r) {
  r.getColumn(0, wd);
  const e = r.getColumn(1), t = r.getColumn(2);
  return wd.add(e).add(t).len();
}
const Xa = {
  UNLOADED: 0,
  // Has never been requested
  LOADING: 1,
  // Is waiting on a pending request
  PROCESSING: 2,
  // Request received.  Contents are being processed for rendering.  Depending on the content, it might make its own requests for external data.
  READY: 3,
  // Ready to render.
  EXPIRED: 4,
  // Is expired and will be unloaded once new content is loaded.
  FAILED: 5
  // Request failed.
};
var Ic;
(function(r) {
  r[r.ADD = 1] = "ADD", r[r.REPLACE = 2] = "REPLACE";
})(Ic || (Ic = {}));
var Du;
(function(r) {
  r.EMPTY = "empty", r.SCENEGRAPH = "scenegraph", r.POINTCLOUD = "pointcloud", r.MESH = "mesh";
})(Du || (Du = {}));
var wa;
(function(r) {
  r.I3S = "I3S", r.TILES3D = "TILES3D";
})(wa || (wa = {}));
var $d;
(function(r) {
  r.GEOMETRIC_ERROR = "geometricError", r.MAX_SCREEN_THRESHOLD = "maxScreenThreshold";
})($d || ($d = {}));
const H$ = {
  USE_OPTIMIZATION: 1
};
function CI(r) {
  return r != null;
}
const qo = new Tt(), r_ = new Tt(), W$ = new Tt(), X$ = new Tt(), ef = new Tt(), R3 = new Tt(), B3 = new Tt(), L3 = new Tt();
function Pb(r, e, t) {
  if (xi(r, "3D Tile: boundingVolume must be defined"), r.box)
    return II(r.box, e, t);
  if (r.region)
    return K$(r.region);
  if (r.sphere)
    return Y$(r.sphere, e, t);
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function Z$(r, e) {
  if (r.box)
    return J$(e);
  if (r.region) {
    const [t, n, i, s, l, o] = r.region;
    return [[yc(t), yc(n), l], [yc(i), yc(s), o]];
  }
  if (r.sphere)
    return Q$(e);
  throw new Error("Unkown boundingVolume type");
}
function II(r, e, t) {
  const n = new Tt(r[0], r[1], r[2]);
  e.transform(n, n);
  let i = [];
  if (r.length === 10) {
    const m = r.slice(3, 6), b = new fg();
    b.fromArray(r, 6);
    const T = new Tt([1, 0, 0]), M = new Tt([0, 1, 0]), E = new Tt([0, 0, 1]);
    T.transformByQuaternion(b), T.scale(m[0]), M.transformByQuaternion(b), M.scale(m[1]), E.transformByQuaternion(b), E.scale(m[2]), i = [...T.toArray(), ...M.toArray(), ...E.toArray()];
  } else
    i = [...r.slice(3, 6), ...r.slice(6, 9), ...r.slice(9, 12)];
  const s = e.transformAsVector(i.slice(0, 3)), l = e.transformAsVector(i.slice(3, 6)), o = e.transformAsVector(i.slice(6, 9)), d = new us([s[0], s[1], s[2], l[0], l[1], l[2], o[0], o[1], o[2]]);
  return CI(t) ? (t.center = n, t.halfAxes = d, t) : new Lg(n, d);
}
function Y$(r, e, t) {
  const n = new Tt(r[0], r[1], r[2]);
  e.transform(n, n);
  const i = e.getScale(r_), s = Math.max(Math.max(i[0], i[1]), i[2]), l = r[3] * s;
  return CI(t) ? (t.center = n, t.radius = l, t) : new Bg(n, l);
}
function K$(r) {
  const [e, t, n, i, s, l] = r, o = wi.WGS84.cartographicToCartesian([yc(e), yc(i), s], W$), d = wi.WGS84.cartographicToCartesian([yc(n), yc(t), l], X$), m = new Tt().addVectors(o, d).multiplyByScalar(0.5);
  return wi.WGS84.cartesianToCartographic(m, ef), wi.WGS84.cartographicToCartesian([yc(n), ef[1], ef[2]], R3), wi.WGS84.cartographicToCartesian([ef[0], yc(i), ef[2]], B3), wi.WGS84.cartographicToCartesian([ef[0], ef[1], l], L3), II([...m, ...R3.subtract(m), ...B3.subtract(m), ...L3.subtract(m)], new Cn());
}
function J$(r) {
  const e = MI(), {
    halfAxes: t
  } = r, n = new Tt(t.getColumn(0)), i = new Tt(t.getColumn(1)), s = new Tt(t.getColumn(2));
  for (let l = 0; l < 2; l++) {
    for (let o = 0; o < 2; o++) {
      for (let d = 0; d < 2; d++)
        qo.copy(r.center), qo.add(n), qo.add(i), qo.add(s), PI(e, qo), s.negate();
      i.negate();
    }
    n.negate();
  }
  return e;
}
function Q$(r) {
  const e = MI(), {
    center: t,
    radius: n
  } = r, i = wi.WGS84.scaleToGeodeticSurface(t, qo);
  let s;
  i ? s = wi.WGS84.geodeticSurfaceNormal(i) : s = new Tt(0, 0, 1);
  let l = new Tt(s[2], -s[1], 0);
  l.len() > 0 ? l.normalize() : l = new Tt(0, 1, 0);
  const o = l.clone().cross(s);
  for (const d of [l, o, s]) {
    r_.copy(d).scale(n);
    for (let m = 0; m < 2; m++)
      qo.copy(t), qo.add(r_), PI(e, qo), r_.negate();
  }
  return e;
}
function MI() {
  return [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
}
function PI(r, e) {
  wi.WGS84.cartesianToCartographic(e, qo), r[0][0] = Math.min(r[0][0], qo[0]), r[0][1] = Math.min(r[0][1], qo[1]), r[0][2] = Math.min(r[0][2], qo[2]), r[1][0] = Math.max(r[1][0], qo[0]), r[1][1] = Math.max(r[1][1], qo[1]), r[1][2] = Math.max(r[1][2], qo[2]);
}
new Tt();
new Tt();
new Cn();
new Tt();
new Tt();
new Tt();
function eH(r, e) {
  const t = r * e;
  return 1 - Math.exp(-(t * t));
}
function tH(r, e) {
  if (r.dynamicScreenSpaceError && r.dynamicScreenSpaceErrorComputedDensity) {
    const t = r.dynamicScreenSpaceErrorComputedDensity, n = r.dynamicScreenSpaceErrorFactor;
    return eH(e, t) * n;
  }
  return 0;
}
function rH(r, e, t) {
  const n = r.tileset, i = r.parent && r.parent.lodMetricValue || r.lodMetricValue, s = t ? i : r.lodMetricValue;
  if (s === 0)
    return 0;
  const l = Math.max(r._distanceToCamera, 1e-7), {
    height: o,
    sseDenominator: d
  } = e, {
    viewDistanceScale: m
  } = n.options;
  let b = s * o * (m || 1) / (l * d);
  return b -= tH(n, l), b;
}
const Rb = new Tt(), O3 = new Tt(), dh = new Tt(), N3 = new Tt(), nH = new Tt(), Bb = new Cn(), D3 = new Cn();
function iH(r, e) {
  if (r.lodMetricValue === 0 || isNaN(r.lodMetricValue))
    return "DIG";
  const t = 2 * RI(r, e);
  return t < 2 ? "OUT" : !r.header.children || t <= r.lodMetricValue ? "DRAW" : r.header.children ? "DIG" : "OUT";
}
function RI(r, e) {
  const {
    topDownViewport: t
  } = e, n = r.header.mbs[1], i = r.header.mbs[0], s = r.header.mbs[2], l = r.header.mbs[3], o = [...r.boundingVolume.center], d = t.unprojectPosition(t.cameraPosition);
  wi.WGS84.cartographicToCartesian(d, Rb), O3.copy(Rb).subtract(o).normalize(), wi.WGS84.eastNorthUpToFixedFrame(o, Bb), D3.copy(Bb).invert(), dh.copy(Rb).transform(D3);
  const m = Math.sqrt(dh[0] * dh[0] + dh[1] * dh[1]), b = m * m / dh[2];
  N3.copy([dh[0], dh[1], b]);
  const M = N3.transform(Bb).subtract(o).normalize(), D = O3.cross(M).normalize().scale(l).add(o), U = wi.WGS84.cartesianToCartographic(D), q = t.project([i, n, s]), G = t.project(U);
  return nH.copy(q).subtract(G).magnitude();
}
function sH(r) {
  return {
    assetGltfUpAxis: r.asset && r.asset.gltfUpAxis || "Y"
  };
}
class k3 {
  constructor() {
    H(this, "_map", /* @__PURE__ */ new Map());
    H(this, "_array");
    H(this, "_length");
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    this._array = new Array(e), this._length = e;
  }
  /**
   * Gets or sets the length of the array.
   * If the set length is greater than the length of the internal array, the internal array is resized.
   *
   * @memberof ManagedArray.prototype
   * @type Number
   */
  get length() {
    return this._length;
  }
  set length(e) {
    this._length = e, e > this._array.length && (this._array.length = e);
  }
  /**
   * Gets the internal array.
   *
   * @memberof ManagedArray.prototype
   * @type Array
   * @readonly
   */
  get values() {
    return this._array;
  }
  /**
   * Gets the element at an index.
   *
   * @param {Number} index The index to get.
   */
  get(e) {
    return xi(e < this._array.length), this._array[e];
  }
  /**
   * Sets the element at an index. Resizes the array if index is greater than the length of the array.
   *
   * @param {Number} index The index to set.
   * @param {*} element The element to set at index.
   */
  set(e, t) {
    xi(e >= 0), e >= this.length && (this.length = e + 1), this._map.has(this._array[e]) && this._map.delete(this._array[e]), this._array[e] = t, this._map.set(t, e);
  }
  delete(e) {
    const t = this._map.get(e);
    t >= 0 && (this._array.splice(t, 1), this._map.delete(e), this.length--);
  }
  /**
   * Returns the last element in the array without modifying the array.
   *
   * @returns {*} The last element in the array.
   */
  peek() {
    return this._array[this._length - 1];
  }
  /**
   * Push an element into the array.
   *
   * @param {*} element The element to push.
   */
  push(e) {
    if (!this._map.has(e)) {
      const t = this.length++;
      this._array[t] = e, this._map.set(e, t);
    }
  }
  /**
   * Pop an element from the array.
   *
   * @returns {*} The last element in the array.
   */
  pop() {
    const e = this._array[--this.length];
    return this._map.delete(e), e;
  }
  /**
   * Resize the internal array if length > _array.length.
   *
   * @param {Number} length The length.
   */
  reserve(e) {
    xi(e >= 0), e > this._array.length && (this._array.length = e);
  }
  /**
   * Resize the array.
   *
   * @param {Number} length The length.
   */
  resize(e) {
    xi(e >= 0), this.length = e;
  }
  /**
   * Trim the internal array to the specified length. Defaults to the current length.
   *
   * @param {Number} [length] The length.
   */
  trim(e) {
    e == null && (e = this.length), this._array.length = e;
  }
  reset() {
    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;
  }
  find(e) {
    return this._map.has(e);
  }
}
const oH = {
  loadSiblings: !1,
  skipLevelOfDetail: !1,
  updateTransforms: !0,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
class My {
  // TODO nested props
  constructor(e) {
    H(this, "options");
    // fulfill in traverse call
    H(this, "root", null);
    // tiles should be rendered
    H(this, "selectedTiles", {});
    // tiles should be loaded from server
    H(this, "requestedTiles", {});
    // tiles does not have render content
    H(this, "emptyTiles", {});
    H(this, "lastUpdate", (/* @__PURE__ */ new Date()).getTime());
    H(this, "updateDebounceTime", 1e3);
    /** temporary storage to hold the traversed tiles during a traversal */
    H(this, "_traversalStack", new k3());
    H(this, "_emptyTraversalStack", new k3());
    /** set in every traverse cycle */
    H(this, "_frameNumber", null);
    this.options = {
      ...oH,
      ...e
    };
  }
  // RESULT
  traversalFinished(e) {
    return !0;
  }
  // tiles should be visible
  traverse(e, t, n) {
    this.root = e, this.options = {
      ...this.options,
      ...n
    }, this.reset(), this.updateTile(e, t), this._frameNumber = t.frameNumber, this.executeTraversal(e, t);
  }
  reset() {
    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();
  }
  /**
   * Execute traverse
   * Depth-first traversal that traverses all visible tiles and marks tiles for selection.
   * If skipLevelOfDetail is off then a tile does not refine until all children are loaded.
   * This is the traditional replacement refinement approach and is called the base traversal.
   * Tiles that have a greater screen space error than the base screen space error are part of the base traversal,
   * all other tiles are part of the skip traversal. The skip traversal allows for skipping levels of the tree
   * and rendering children and parent tiles simultaneously.
   */
  /* eslint-disable-next-line complexity, max-statements */
  executeTraversal(e, t) {
    const n = this._traversalStack;
    for (e._selectionDepth = 1, n.push(e); n.length > 0; ) {
      const s = n.pop();
      let l = !1;
      this.canTraverse(s, t) && (this.updateChildTiles(s, t), l = this.updateAndPushChildren(s, t, n, s.hasRenderContent ? s._selectionDepth + 1 : s._selectionDepth));
      const o = s.parent, d = !!(!o || o._shouldRefine), m = !l;
      s.hasRenderContent ? s.refine === Ic.ADD ? (this.loadTile(s, t), this.selectTile(s, t)) : s.refine === Ic.REPLACE && (this.loadTile(s, t), m && this.selectTile(s, t)) : (this.emptyTiles[s.id] = s, this.loadTile(s, t), m && this.selectTile(s, t)), this.touchTile(s, t), s._shouldRefine = l && d;
    }
    const i = (/* @__PURE__ */ new Date()).getTime();
    (this.traversalFinished(t) || i - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = i, this.options.onTraversalEnd(t));
  }
  updateChildTiles(e, t) {
    const n = e.children;
    for (const i of n)
      this.updateTile(i, t);
  }
  /* eslint-disable complexity, max-statements */
  updateAndPushChildren(e, t, n, i) {
    const {
      loadSiblings: s,
      skipLevelOfDetail: l
    } = this.options, o = e.children;
    o.sort(this.compareDistanceToCamera.bind(this));
    const d = e.refine === Ic.REPLACE && e.hasRenderContent && !l;
    let m = !1, b = !0;
    for (const T of o)
      if (T._selectionDepth = i, T.isVisibleAndInRequestVolume ? (n.find(T) && n.delete(T), n.push(T), m = !0) : (d || s) && (this.loadTile(T, t), this.touchTile(T, t)), d) {
        let M;
        if (T._inRequestVolume ? T.hasRenderContent ? M = T.contentAvailable : M = this.executeEmptyTraversal(T, t) : M = !1, b = b && M, !b)
          return !1;
      }
    return m || (b = !1), b;
  }
  /* eslint-enable complexity, max-statements */
  updateTile(e, t) {
    this.updateTileVisibility(e, t);
  }
  // tile to render in the browser
  selectTile(e, t) {
    this.shouldSelectTile(e) && (e._selectedFrame = t.frameNumber, this.selectedTiles[e.id] = e);
  }
  // tile to load from server
  loadTile(e, t) {
    this.shouldLoadTile(e) && (e._requestedFrame = t.frameNumber, e._priority = e._getPriority(), this.requestedTiles[e.id] = e);
  }
  // cache tile
  touchTile(e, t) {
    e.tileset._cache.touch(e), e._touchedFrame = t.frameNumber;
  }
  // tile should be visible
  // tile should have children
  // tile LoD (level of detail) is not sufficient under current viewport
  canTraverse(e, t) {
    return e.hasChildren ? e.hasTilesetContent ? !e.contentExpired : this.shouldRefine(e, t) : !1;
  }
  shouldLoadTile(e) {
    return e.hasUnloadedContent || e.contentExpired;
  }
  shouldSelectTile(e) {
    return e.contentAvailable && !this.options.skipLevelOfDetail;
  }
  /** Decide if tile LoD (level of detail) is not sufficient under current viewport */
  shouldRefine(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, i = e._screenSpaceError;
    return n && (i = e.getScreenSpaceError(t, !0)), i > e.tileset.memoryAdjustedScreenSpaceError;
  }
  updateTileVisibility(e, t) {
    const n = [];
    if (this.options.viewportTraversersMap)
      for (const i in this.options.viewportTraversersMap)
        this.options.viewportTraversersMap[i] === t.viewport.id && n.push(i);
    else
      n.push(t.viewport.id);
    e.updateVisibility(t, n);
  }
  // UTILITIES
  compareDistanceToCamera(e, t) {
    return e._distanceToCamera - t._distanceToCamera;
  }
  anyChildrenVisible(e, t) {
    let n = !1;
    for (const i of e.children)
      i.updateVisibility(t), n = n || i.isVisibleAndInRequestVolume;
    return n;
  }
  // Depth-first traversal that checks if all nearest descendants with content are loaded.
  // Ignores visibility.
  executeEmptyTraversal(e, t) {
    let n = !0;
    const i = this._emptyTraversalStack;
    for (i.push(e); i.length > 0; ) {
      const s = i.pop(), l = !s.hasRenderContent && this.canTraverse(s, t), o = !s.hasRenderContent && s.children.length === 0;
      if (!l && !s.contentAvailable && !o && (n = !1), this.updateTile(s, t), s.isVisibleAndInRequestVolume || (this.loadTile(s, t), this.touchTile(s, t)), l) {
        const d = s.children;
        for (const m of d)
          i.push(m);
      }
    }
    return n;
  }
}
const F3 = new Tt();
function aH(r) {
  return r != null;
}
class dv {
  // TODO i3s specific, needs to remove
  /**
   * @constructs
   * Create a Tile3D instance
   * @param tileset - Tileset3D instance
   * @param header - tile header - JSON loaded from a dataset
   * @param parentHeader - parent Tile3D instance
   * @param extendedId - optional ID to separate copies of a tile for different viewports.
   *    const extendedId = `${tile.id}-${frameState.viewport.id}`;
   */
  // eslint-disable-next-line max-statements
  constructor(e, t, n) {
    H(this, "tileset");
    H(this, "header");
    H(this, "id");
    H(this, "url");
    H(this, "parent");
    /* Specifies the type of refine that is used when traversing this tile for rendering. */
    H(this, "refine");
    H(this, "type");
    H(this, "contentUrl");
    /** Different refinement algorithms used by I3S and 3D tiles */
    H(this, "lodMetricType", "geometricError");
    /** The error, in meters, introduced if this tile is rendered and its children are not. */
    H(this, "lodMetricValue", 0);
    /** @todo math.gl is not exporting BoundingVolume base type? */
    H(this, "boundingVolume", null);
    /**
     * The tile's content.  This represents the actual tile's payload,
     * not the content's metadata in the tileset JSON file.
     */
    H(this, "content", null);
    H(this, "contentState", Xa.UNLOADED);
    H(this, "gpuMemoryUsageInBytes", 0);
    /** The tile's children - an array of Tile3D objects. */
    H(this, "children", []);
    H(this, "depth", 0);
    H(this, "viewportIds", []);
    H(this, "transform", new Cn());
    H(this, "extensions", null);
    /** TODO Cesium 3d tiles specific */
    H(this, "implicitTiling", null);
    /** Container to store application specific data */
    H(this, "userData", {});
    H(this, "computedTransform");
    H(this, "hasEmptyContent", !1);
    H(this, "hasTilesetContent", !1);
    H(this, "traverser", new My({}));
    /** Used by TilesetCache */
    H(this, "_cacheNode", null);
    H(this, "_frameNumber", null);
    // TODO Cesium 3d tiles specific
    H(this, "_expireDate", null);
    H(this, "_expiredContent", null);
    H(this, "_boundingBox", void 0);
    /** updated every frame for tree traversal and rendering optimizations: */
    H(this, "_distanceToCamera", 0);
    H(this, "_screenSpaceError", 0);
    H(this, "_visibilityPlaneMask");
    H(this, "_visible", void 0);
    H(this, "_contentBoundingVolume");
    H(this, "_viewerRequestVolume");
    H(this, "_initialTransform", new Cn());
    // Used by traverser, cannot be marked private
    H(this, "_priority", 0);
    H(this, "_selectedFrame", 0);
    H(this, "_requestedFrame", 0);
    H(this, "_selectionDepth", 0);
    H(this, "_touchedFrame", 0);
    H(this, "_centerZDepth", 0);
    H(this, "_shouldRefine", !1);
    H(this, "_stackLength", 0);
    H(this, "_visitedFrame", 0);
    H(this, "_inRequestVolume", !1);
    H(this, "_lodJudge", null);
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
    this.header = t, this.tileset = e, this.id = i || t.id, this.url = t.url, this.parent = n, this.refine = this._getRefine(t.refine), this.type = t.type, this.contentUrl = t.contentUrl, this._initializeLodMetric(t), this._initializeTransforms(t), this._initializeBoundingVolumes(t), this._initializeContent(t), this._initializeRenderingState(t), Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  /** Returns true if tile is not an empty tile and not an external tileset */
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  /** Returns true if tile has children */
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  /**
   * Determines if the tile's content is ready. This is automatically `true` for
   * tiles with empty content.
   */
  get contentReady() {
    return this.contentState === Xa.READY || this.hasEmptyContent;
  }
  /**
   * Determines if the tile has available content to render.  `true` if the tile's
   * content is ready or if it has expired content this renders while new content loads; otherwise,
   */
  get contentAvailable() {
    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  /** Returns true if tile has renderable content but it's unloaded */
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  /**
   * Determines if the tile's content has not be requested. `true` if tile's
   * content has not be requested; otherwise, `false`.
   */
  get contentUnloaded() {
    return this.contentState === Xa.UNLOADED;
  }
  /**
   * Determines if the tile's content is expired. `true` if tile's
   * content is expired; otherwise, `false`.
   */
  get contentExpired() {
    return this.contentState === Xa.EXPIRED;
  }
  // Determines if the tile's content failed to load.  `true` if the tile's
  // content failed to load; otherwise, `false`.
  get contentFailed() {
    return this.contentState === Xa.FAILED;
  }
  /**
   * Distance from the tile's bounding volume center to the camera
   */
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  /**
   * Screen space error for LOD selection
   */
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  /**
   * Get bounding box in cartographic coordinates
   * @returns [min, max] each in [longitude, latitude, altitude]
   */
  get boundingBox() {
    return this._boundingBox || (this._boundingBox = Z$(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;
  }
  /** Get the tile's screen space error. */
  getScreenSpaceError(e, t) {
    switch (this.tileset.type) {
      case wa.I3S:
        return RI(this, e);
      case wa.TILES3D:
        return rH(this, e, t);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  /**
   * Make tile unselected than means it won't be shown
   * but it can be still loaded in memory
   */
  unselect() {
    this._selectedFrame = 0;
  }
  /**
   * Memory usage of tile on GPU
   */
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  /*
   * If skipLevelOfDetail is off try to load child tiles as soon as possible so that their parent can refine sooner.
   * Tiles are prioritized by screen space error.
   */
  // eslint-disable-next-line complexity
  _getPriority() {
    const e = this.tileset._traverser, {
      skipLevelOfDetail: t
    } = e.options, n = this.refine === Ic.ADD || t;
    if (n && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === Xa.UNLOADED)
      return -1;
    const i = this.parent, l = i && (!n || this._screenSpaceError === 0 || i.hasTilesetContent) ? i._screenSpaceError : this._screenSpaceError, o = e.root ? e.root._screenSpaceError : 0;
    return Math.max(o - l, 0);
  }
  /**
   *  Requests the tile's content.
   * The request may not be made if the Request Scheduler can't prioritize it.
   */
  // eslint-disable-next-line max-statements, complexity
  async loadContent() {
    if (this.hasEmptyContent)
      return !1;
    if (this.content)
      return !0;
    this.contentExpired && (this._expireDate = null), this.contentState = Xa.LOADING;
    const t = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!t)
      return this.contentState = Xa.UNLOADED, !1;
    try {
      const n = this.tileset.getTileUrl(this.contentUrl), i = this.tileset.loader, s = {
        ...this.tileset.loadOptions,
        [i.id]: {
          // @ts-expect-error
          ...this.tileset.loadOptions[i.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(i.id)
        }
      };
      return this.content = await Ph(n, i, s), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = Xa.READY, this._onContentLoaded(), !0;
    } catch (n) {
      throw this.contentState = Xa.FAILED, n;
    } finally {
      t.done();
    }
  }
  // Unloads the tile's content.
  unloadContent() {
    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = Xa.UNLOADED, !0;
  }
  /**
   * Update the tile's visibility
   * @param {Object} frameState - frame state for tile culling
   * @param {string[]} viewportIds - a list of viewport ids that show this tile
   * @return {void}
   */
  updateVisibility(e, t) {
    if (this._frameNumber === e.frameNumber)
      return;
    const n = this.parent, i = n ? n._visibilityPlaneMask : Tl.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const s = n ? n.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(s);
    }
    this._distanceToCamera = this.distanceToTile(e), this._screenSpaceError = this.getScreenSpaceError(e, !1), this._visibilityPlaneMask = this.visibility(e, i), this._visible = this._visibilityPlaneMask !== Tl.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(e), this._frameNumber = e.frameNumber, this.viewportIds = t;
  }
  // Determines whether the tile's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @param {Number} parentVisibilityPlaneMask The parent's plane mask to speed up the visibility check.
  // @returns {Number} A plane mask as described above in {@link CullingVolume#computeVisibilityWithPlaneMask}.
  visibility(e, t) {
    const {
      cullingVolume: n
    } = e, {
      boundingVolume: i
    } = this;
    return n.computeVisibilityWithPlaneMask(i, t);
  }
  // Assuming the tile's bounding volume intersects the culling volume, determines
  // whether the tile's content's bounding volume intersects the culling volume.
  // @param {FrameState} frameState The frame state.
  // @returns {Intersect} The result of the intersection: the tile's content is completely outside, completely inside, or intersecting the culling volume.
  contentVisibility() {
    return !0;
  }
  /**
   * Computes the (potentially approximate) distance from the closest point of the tile's bounding volume to the camera.
   * @param frameState The frame state.
   * @returns {Number} The distance, in meters, or zero if the camera is inside the bounding volume.
   */
  distanceToTile(e) {
    const t = this.boundingVolume;
    return Math.sqrt(Math.max(t.distanceSquaredTo(e.camera.position), 0));
  }
  /**
   * Computes the tile's camera-space z-depth.
   * @param frameState The frame state.
   * @returns The distance, in meters.
   */
  cameraSpaceZDepth(e) {
    let {
      camera: t
    } = e;
    const n = this.boundingVolume;
    return F3.subVectors(n.center, t.position), t.direction.dot(F3);
  }
  /**
   * Checks if the camera is inside the viewer request volume.
   * @param {FrameState} frameState The frame state.
   * @returns {Boolean} Whether the camera is inside the volume.
   */
  insideViewerRequestVolume(e) {
    const t = this._viewerRequestVolume;
    return !t || t.distanceSquaredTo(e.camera.position) <= 0;
  }
  // TODO Cesium specific
  // Update whether the tile has expired.
  updateExpiration() {
    if (aH(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const e = Date.now();
      Date.lessThan(this._expireDate, e) && (this.contentState = Xa.EXPIRED, this._expiredContent = this.content);
    }
  }
  get extras() {
    return this.header.extras;
  }
  // INTERNAL METHODS
  _initializeLodMetric(e) {
    "lodMetricType" in e ? this.lodMetricType = e.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType")), "lodMetricValue" in e ? this.lodMetricValue = e.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue"));
  }
  _initializeTransforms(e) {
    this.transform = e.transform ? new Cn(e.transform) : new Cn();
    const t = this.parent, n = this.tileset, i = t && t.computedTransform ? t.computedTransform.clone() : n.modelMatrix.clone();
    this.computedTransform = new Cn(i).multiplyRight(this.transform);
    const s = t && t._initialTransform ? t._initialTransform.clone() : new Cn();
    this._initialTransform = new Cn(s).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(e) {
    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(e);
  }
  _initializeContent(e) {
    this.content = {
      _tileset: this.tileset,
      _tile: this
    }, this.hasEmptyContent = !0, this.contentState = Xa.UNLOADED, this.hasTilesetContent = !1, e.contentUrl && (this.content = null, this.hasEmptyContent = !1);
  }
  // TODO - remove anything not related to basic visibility detection
  _initializeRenderingState(e) {
    this.depth = e.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = Tl.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;
  }
  _getRefine(e) {
    return e || this.parent && this.parent.refine || Ic.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = !0;
        break;
    }
    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
  }
  _updateBoundingVolume(e) {
    this.boundingVolume = Pb(e.boundingVolume, this.computedTransform, this.boundingVolume);
    const t = e.content;
    t && (t.boundingVolume && (this._contentBoundingVolume = Pb(t.boundingVolume, this.computedTransform, this._contentBoundingVolume)), e.viewerRequestVolume && (this._viewerRequestVolume = Pb(e.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));
  }
  // Update the tile's transform. The transform is applied to the tile's bounding volumes.
  _updateTransform() {
    const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Cn()).clone().multiplyRight(this.transform);
    t.equals(this.computedTransform) || (this.computedTransform = t, this._updateBoundingVolume(this.header));
  }
  // Get options which are applicable only for the particular loader
  _getLoaderSpecificOptions(e) {
    switch (e) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: !1
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return sH(this.tileset.tileset);
    }
  }
}
class lH extends My {
  compareDistanceToCamera(e, t) {
    return t._distanceToCamera === 0 && e._distanceToCamera === 0 ? t._centerZDepth - e._centerZDepth : t._distanceToCamera - e._distanceToCamera;
  }
  updateTileVisibility(e, t) {
    if (super.updateTileVisibility(e, t), !e.isVisibleAndInRequestVolume)
      return;
    const n = e.children.length > 0;
    if (e.hasTilesetContent && n) {
      const l = e.children[0];
      this.updateTileVisibility(l, t), e._visible = l._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(e, t)) {
      e._visible = !1;
      return;
    }
    const i = e.refine === Ic.REPLACE, s = e._optimChildrenWithinParent === H$.USE_OPTIMIZATION;
    if (i && s && n && !this.anyChildrenVisible(e, t)) {
      e._visible = !1;
      return;
    }
  }
  meetsScreenSpaceErrorEarly(e, t) {
    const {
      parent: n
    } = e;
    return !n || n.hasTilesetContent || n.refine !== Ic.ADD ? !1 : !this.shouldRefine(e, t, !0);
  }
}
class cH {
  constructor() {
    H(this, "frameNumberMap", /* @__PURE__ */ new Map());
  }
  /**
   * Register a new pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  register(e, t) {
    const n = this.frameNumberMap.get(e) || /* @__PURE__ */ new Map(), i = n.get(t) || 0;
    n.set(t, i + 1), this.frameNumberMap.set(e, n);
  }
  /**
   * Deregister a pending tile header for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   */
  deregister(e, t) {
    const n = this.frameNumberMap.get(e);
    if (!n)
      return;
    const i = n.get(t) || 1;
    n.set(t, i - 1);
  }
  /**
   * Check is there are no pending tile headers registered for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  isZero(e, t) {
    var i;
    return (((i = this.frameNumberMap.get(e)) == null ? void 0 : i.get(t)) || 0) === 0;
  }
}
const Lb = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
class uH {
  constructor() {
    H(this, "_statusMap");
    H(this, "pendingTilesRegister", new cH());
    this._statusMap = {};
  }
  /**
   * Add request to map
   * @param request - node metadata request
   * @param key - unique key
   * @param callback - callback after request completed
   * @param frameState - frameState data
   */
  add(e, t, n, i) {
    if (!this._statusMap[t]) {
      const {
        frameNumber: s,
        viewport: {
          id: l
        }
      } = i;
      this._statusMap[t] = {
        request: e,
        callback: n,
        key: t,
        frameState: i,
        status: Lb.REQUESTED
      }, this.pendingTilesRegister.register(l, s), e().then((o) => {
        this._statusMap[t].status = Lb.COMPLETED;
        const {
          frameNumber: d,
          viewport: {
            id: m
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(m, d), this._statusMap[t].callback(o, i);
      }).catch((o) => {
        this._statusMap[t].status = Lb.ERROR;
        const {
          frameNumber: d,
          viewport: {
            id: m
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(m, d), n(o);
      });
    }
  }
  /**
   * Update request if it is still actual for the new frameState
   * @param key - unique key
   * @param frameState - frameState data
   */
  update(e, t) {
    if (this._statusMap[e]) {
      const {
        frameNumber: n,
        viewport: {
          id: i
        }
      } = this._statusMap[e].frameState;
      this.pendingTilesRegister.deregister(i, n);
      const {
        frameNumber: s,
        viewport: {
          id: l
        }
      } = t;
      this.pendingTilesRegister.register(l, s), this._statusMap[e].frameState = t;
    }
  }
  /**
   * Find request in the map
   * @param key - unique key
   * @returns
   */
  find(e) {
    return this._statusMap[e];
  }
  /**
   * Check it there are pending tile headers for the particular frameNumber
   * @param viewportId
   * @param frameNumber
   * @returns
   */
  hasPendingTiles(e, t) {
    return !this.pendingTilesRegister.isZero(e, t);
  }
}
class hH extends My {
  constructor(t) {
    super(t);
    H(this, "_tileManager");
    this._tileManager = new uH();
  }
  /**
   * Check if there are no penging tile header requests,
   * that means the traversal is finished and we can call
   * following-up callbacks.
   */
  traversalFinished(t) {
    return !this._tileManager.hasPendingTiles(t.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(t, n) {
    return t._lodJudge = iH(t, n), t._lodJudge === "DIG";
  }
  updateChildTiles(t, n) {
    const i = t.header.children || [], s = t.children, l = t.tileset;
    for (const o of i) {
      const d = `${o.id}-${n.viewport.id}`, m = s && s.find((b) => b.id === d);
      if (m)
        m && this.updateTile(m, n);
      else {
        let b = () => this._loadTile(o.id, l);
        this._tileManager.find(d) ? this._tileManager.update(d, n) : (l.tileset.nodePages && (b = () => l.tileset.nodePagesTile.formTileFromNodePages(o.id)), this._tileManager.add(b, d, (M) => this._onTileLoad(M, t, d), n));
      }
    }
    return !1;
  }
  async _loadTile(t, n) {
    const {
      loader: i
    } = n, s = n.getTileUrl(`${n.url}/nodes/${t}`), l = {
      ...n.loadOptions,
      i3s: {
        ...n.loadOptions.i3s,
        isTileHeader: !0
      }
    };
    return await Ph(s, i, l);
  }
  /**
   * The callback to init Tile3D instance after loading the tile JSON
   * @param {Object} header - the tile JSON from a dataset
   * @param {Tile3D} tile - the parent Tile3D instance
   * @param {string} extendedId - optional ID to separate copies of a tile for different viewports.
   *                              const extendedId = `${tile.id}-${frameState.viewport.id}`;
   * @return {void}
   */
  _onTileLoad(t, n, i) {
    const s = new dv(n.tileset, t, n, i);
    n.children.push(s);
    const l = this._tileManager.find(s.id).frameState;
    this.updateTile(s, l), this._frameNumber === l.frameNumber && (this.traversalFinished(l) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(s, l);
  }
}
const fH = {
  description: "",
  ellipsoid: wi.WGS84,
  modelMatrix: new Cn(),
  throttleRequests: !0,
  maxRequests: 64,
  /** Default memory values optimized for viewing mesh-based 3D Tiles on both mobile and desktop devices */
  maximumMemoryUsage: 32,
  memoryCacheOverflow: 1,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (r) => r,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  memoryAdjustedScreenSpaceError: !1,
  loadTiles: !0,
  updateTransforms: !0,
  viewportTraversersMap: null,
  loadOptions: {
    fetch: {}
  },
  attributions: [],
  basePath: "",
  i3s: {}
}, Lm = "Tiles In Tileset(s)", Ob = "Tiles In Memory", U3 = "Tiles In View", z3 = "Tiles To Render", j3 = "Tiles Loaded", Nb = "Tiles Loading", V3 = "Tiles Unloaded", q3 = "Failed Tile Loads", G3 = "Points/Vertices", Db = "Tile Memory Use", $3 = "Maximum Screen Space Error";
class dH {
  /**
   * Create a new Tileset3D
   * @param json
   * @param props
   */
  // eslint-disable-next-line max-statements
  constructor(e, t) {
    // props: Tileset3DProps;
    H(this, "options");
    H(this, "loadOptions");
    H(this, "type");
    H(this, "tileset");
    H(this, "loader");
    H(this, "url");
    H(this, "basePath");
    H(this, "modelMatrix");
    H(this, "ellipsoid");
    H(this, "lodMetricType");
    H(this, "lodMetricValue");
    H(this, "refine");
    H(this, "root", null);
    H(this, "roots", {});
    /** @todo any->unknown */
    H(this, "asset", {});
    // Metadata for the entire tileset
    H(this, "description", "");
    H(this, "properties");
    H(this, "extras", null);
    H(this, "attributions", {});
    H(this, "credits", {});
    H(this, "stats");
    /** flags that contain information about data types in nested tiles */
    H(this, "contentFormats", {
      draco: !1,
      meshopt: !1,
      dds: !1,
      ktx2: !1
    });
    // view props
    H(this, "cartographicCenter", null);
    H(this, "cartesianCenter", null);
    H(this, "zoom", 1);
    H(this, "boundingVolume", null);
    /** Updated based on the camera position and direction */
    H(this, "dynamicScreenSpaceErrorComputedDensity", 0);
    // METRICS
    /**
     * The maximum amount of GPU memory (in MB) that may be used to cache tiles
     * Tiles not in view are unloaded to enforce private
     */
    H(this, "maximumMemoryUsage", 32);
    /** The total amount of GPU memory in bytes used by the tileset. */
    H(this, "gpuMemoryUsageInBytes", 0);
    /**
     * If loading the level of detail required by maximumScreenSpaceError
     * results in the memory usage exceeding maximumMemoryUsage (GPU), level of detail refinement
     * will instead use this (larger) adjusted screen space error to achieve the
     * best possible visual quality within the available memory.
     */
    H(this, "memoryAdjustedScreenSpaceError", 0);
    H(this, "_cacheBytes", 0);
    H(this, "_cacheOverflowBytes", 0);
    /** Update tracker. increase in each update cycle. */
    H(this, "_frameNumber", 0);
    H(this, "_queryParams", {});
    H(this, "_extensionsUsed", []);
    H(this, "_tiles", {});
    /** counter for tracking tiles requests */
    H(this, "_pendingCount", 0);
    /** Hold traversal results */
    H(this, "selectedTiles", []);
    // TRAVERSAL
    H(this, "traverseCounter", 0);
    H(this, "geometricError", 0);
    H(this, "lastUpdatedVieports", null);
    H(this, "_requestedTiles", []);
    H(this, "_emptyTiles", []);
    H(this, "frameStateData", {});
    H(this, "_traverser");
    H(this, "_cache", new D$());
    H(this, "_requestScheduler");
    // Promise tracking
    H(this, "updatePromise", null);
    H(this, "tilesetInitializationPromise");
    this.options = {
      ...fH,
      ...t
    }, this.tileset = e, this.loader = e.loader, this.type = e.type, this.url = e.url, this.basePath = e.basePath || Hv(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = e.lodMetricType, this.lodMetricValue = e.lodMetricValue, this.refine = e.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new eB({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    }), this.memoryAdjustedScreenSpaceError = this.options.maximumScreenSpaceError, this._cacheBytes = this.options.maximumMemoryUsage * 1024 * 1024, this._cacheOverflowBytes = this.options.memoryCacheOverflow * 1024 * 1024, this.stats = new Yd({
      id: this.url
    }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(e);
  }
  /** Release resources */
  destroy() {
    this._destroy();
  }
  /** Is the tileset loaded (update needs to have been called at least once) */
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(e) {
    this.options = {
      ...this.options,
      ...e
    };
  }
  /** @deprecated */
  // setOptions(options: Tileset3DProps): void {
  //   this.options = {...this.options, ...options};
  // }
  /**
   * Return a loadable tile url for a specific tile subpath
   * @param tilePath a tile subpath
   */
  getTileUrl(e) {
    if (e.startsWith("data:"))
      return e;
    let n = e;
    return this.queryParams.length && (n = `${e}${e.includes("?") ? "&" : "?"}${this.queryParams}`), n;
  }
  // TODO CESIUM specific
  hasExtension(e) {
    return this._extensionsUsed.indexOf(e) > -1;
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports - list of viewports
   * @deprecated
   */
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    this.tilesetInitializationPromise.then(() => {
      !e && this.lastUpdatedVieports ? e = this.lastUpdatedVieports : this.lastUpdatedVieports = e, e && this.doUpdate(e);
    });
  }
  /**
   * Update visible tiles relying on a list of viewports.
   * Do it with debounce delay to prevent update spam
   * @param viewports viewports
   * @returns Promise of new frameNumber
   */
  async selectTiles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return await this.tilesetInitializationPromise, e && (this.lastUpdatedVieports = e), this.updatePromise || (this.updatePromise = new Promise((t) => {
      setTimeout(() => {
        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), t(this._frameNumber), this.updatePromise = null;
      }, this.options.debounceTime);
    })), this.updatePromise;
  }
  adjustScreenSpaceError() {
    this.gpuMemoryUsageInBytes < this._cacheBytes ? this.memoryAdjustedScreenSpaceError = Math.max(this.memoryAdjustedScreenSpaceError / 1.02, this.options.maximumScreenSpaceError) : this.gpuMemoryUsageInBytes > this._cacheBytes + this._cacheOverflowBytes && (this.memoryAdjustedScreenSpaceError *= 1.02);
  }
  /**
   * Update visible tiles relying on a list of viewports
   * @param viewports viewports
   */
  // eslint-disable-next-line max-statements, complexity
  doUpdate(e) {
    if ("loadTiles" in this.options && !this.options.loadTiles || this.traverseCounter > 0)
      return;
    const t = e instanceof Array ? e : [e];
    this._cache.reset(), this._frameNumber++, this.traverseCounter = t.length;
    const n = [];
    for (const i of t) {
      const s = i.id;
      this._needTraverse(s) ? n.push(s) : this.traverseCounter--;
    }
    for (const i of t) {
      const s = i.id;
      if (this.roots[s] || (this.roots[s] = this._initializeTileHeaders(this.tileset, null)), !n.includes(s))
        continue;
      const l = F$(i, this._frameNumber);
      this._traverser.traverse(this.roots[s], l, this.options);
    }
  }
  /**
   * Check if traversal is needed for particular viewport
   * @param {string} viewportId - id of a viewport
   * @return {boolean}
   */
  _needTraverse(e) {
    let t = e;
    return this.options.viewportTraversersMap && (t = this.options.viewportTraversersMap[e]), t === e;
  }
  /**
   * The callback to post-process tiles after traversal procedure
   * @param frameState - frame state for tile culling
   */
  _onTraversalEnd(e) {
    const t = e.viewport.id;
    this.frameStateData[t] || (this.frameStateData[t] = {
      selectedTiles: [],
      _requestedTiles: [],
      _emptyTiles: []
    });
    const n = this.frameStateData[t], i = Object.values(this._traverser.selectedTiles), [s, l] = U$(i, e, this.options.maximumTilesSelected);
    n.selectedTiles = s;
    for (const o of l)
      o.unselect();
    n._requestedTiles = Object.values(this._traverser.requestedTiles), n._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();
  }
  /**
   * Update tiles relying on data from all traversers
   */
  _updateTiles() {
    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];
    for (const e in this.frameStateData) {
      const t = this.frameStateData[e];
      this.selectedTiles = this.selectedTiles.concat(t.selectedTiles), this._requestedTiles = this._requestedTiles.concat(t._requestedTiles), this._emptyTiles = this._emptyTiles.concat(t._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const e of this.selectedTiles)
      this._tiles[e.id] = e;
    this._loadTiles(), this._unloadTiles(), this._updateStats();
  }
  _tilesChanged(e, t) {
    if (e.length !== t.length)
      return !0;
    const n = new Set(e.map((l) => l.id)), i = new Set(t.map((l) => l.id));
    let s = e.filter((l) => !i.has(l.id)).length > 0;
    return s = s || t.filter((l) => !n.has(l.id)).length > 0, s;
  }
  _loadTiles() {
    for (const e of this._requestedTiles)
      e.contentUnloaded && this._loadTile(e);
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (e, t) => e._unloadTile(t));
  }
  _updateStats() {
    let e = 0, t = 0;
    for (const n of this.selectedTiles)
      n.contentAvailable && n.content && (e++, n.content.pointCount ? t += n.content.pointCount : t += n.content.vertexCount);
    this.stats.get(U3).count = this.selectedTiles.length, this.stats.get(z3).count = e, this.stats.get(G3).count = t, this.stats.get($3).count = this.memoryAdjustedScreenSpaceError;
  }
  async _initializeTileSet(e) {
    this.type === wa.I3S && (this.calculateViewPropsI3S(), e.root = await e.root), this.root = this._initializeTileHeaders(e, null), this.type === wa.TILES3D && (this._initializeTiles3DTileset(e), this.calculateViewPropsTiles3D()), this.type === wa.I3S && this._initializeI3STileset();
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset
   * For I3S there is extent (<1.8 version) or fullExtent (>=1.8 version) to calculate view props
   * @returns
   */
  calculateViewPropsI3S() {
    var n;
    const e = this.tileset.fullExtent;
    if (e) {
      const {
        xmin: i,
        xmax: s,
        ymin: l,
        ymax: o,
        zmin: d,
        zmax: m
      } = e;
      this.cartographicCenter = new Tt(i + (s - i) / 2, l + (o - l) / 2, d + (m - d) / 2), this.cartesianCenter = new Tt(), wi.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = EI(e, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const t = (n = this.tileset.store) == null ? void 0 : n.extent;
    if (t) {
      const [i, s, l, o] = t;
      this.cartographicCenter = new Tt(i + (l - i) / 2, s + (o - s) / 2, 0), this.cartesianCenter = new Tt(), wi.WGS84.cartographicToCartesian(this.cartographicCenter, this.cartesianCenter), this.zoom = G$(t, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header"), this.cartographicCenter = new Tt(), this.zoom = 1;
  }
  /**
   * Called during initialize Tileset to initialize the tileset's cartographic center (longitude, latitude) and zoom.
   * These metrics help apps center view on tileset.
   * For 3DTiles the root tile data is used to calculate view props.
   * @returns
   */
  calculateViewPropsTiles3D() {
    const e = this.root, {
      center: t
    } = e.boundingVolume;
    if (!t) {
      console.warn("center was not pre-calculated for the root tile"), this.cartographicCenter = new Tt(), this.zoom = 1;
      return;
    }
    t[0] !== 0 || t[1] !== 0 || t[2] !== 0 ? (this.cartographicCenter = new Tt(), wi.WGS84.cartesianToCartographic(t, this.cartographicCenter)) : this.cartographicCenter = new Tt(0, 0, -wi.WGS84.radii[0]), this.cartesianCenter = t, this.zoom = q$(e.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(Lm), this.stats.get(Nb), this.stats.get(Ob), this.stats.get(U3), this.stats.get(z3), this.stats.get(j3), this.stats.get(V3), this.stats.get(q3), this.stats.get(G3), this.stats.get(Db, "memory"), this.stats.get($3);
  }
  // Installs the main tileset JSON file or a tileset JSON file referenced from a tile.
  // eslint-disable-next-line max-statements
  _initializeTileHeaders(e, t) {
    var i;
    const n = new dv(this, e.root, t);
    if (t && (t.children.push(n), n.depth = t.depth + 1), this.type === wa.TILES3D) {
      const s = [];
      for (s.push(n); s.length > 0; ) {
        const l = s.pop();
        this.stats.get(Lm).incrementCount();
        const o = l.header.children || [];
        for (const d of o) {
          const m = new dv(this, d, l);
          if ((i = m.contentUrl) != null && i.includes("?session=")) {
            const T = new URL(m.contentUrl).searchParams.get("session");
            T && (this._queryParams.session = T);
          }
          l.children.push(m), m.depth = l.depth + 1, s.push(m);
        }
      }
    }
    return n;
  }
  _initializeTraverser() {
    let e;
    switch (this.type) {
      case wa.TILES3D:
        e = lH;
        break;
      case wa.I3S:
        e = hH;
        break;
      default:
        e = My;
    }
    return new e({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(e) {
    this._destroySubtree(e);
  }
  async _loadTile(e) {
    let t;
    try {
      this._onStartTileLoading(), t = await e.loadContent();
    } catch (n) {
      this._onTileLoadError(e, n instanceof Error ? n : new Error("load failed"));
    } finally {
      this._onEndTileLoading(), this._onTileLoad(e, t);
    }
  }
  _onTileLoadError(e, t) {
    this.stats.get(q3).incrementCount();
    const n = t.message || t.toString(), i = e.url;
    console.error(`A 3D tile failed to load: ${e.url} ${n}`), this.options.onTileError(e, n, i);
  }
  _onTileLoad(e, t) {
    var n, i;
    if (t) {
      if (this.type === wa.I3S) {
        const s = ((i = (n = this.tileset) == null ? void 0 : n.nodePagesTile) == null ? void 0 : i.nodesInNodePages) || 0;
        this.stats.get(Lm).reset(), this.stats.get(Lm).addCount(s);
      }
      e && e.content && k$(e, e.content), this.updateContentTypes(e), this._addTileToCache(e), this.options.onTileLoad(e);
    }
  }
  /**
   * Update information about data types in nested tiles
   * @param tile instance of a nested Tile3D
   */
  updateContentTypes(e) {
    var t;
    if (this.type === wa.I3S)
      switch (e.header.isDracoGeometry && (this.contentFormats.draco = !0), e.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = !0;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = !0;
          break;
      }
    else if (this.type === wa.TILES3D) {
      const {
        extensionsRemoved: n = []
      } = ((t = e.content) == null ? void 0 : t.gltf) || {};
      n.includes("KHR_draco_mesh_compression") && (this.contentFormats.draco = !0), n.includes("EXT_meshopt_compression") && (this.contentFormats.meshopt = !0), n.includes("KHR_texture_basisu") && (this.contentFormats.ktx2 = !0);
    }
  }
  _onStartTileLoading() {
    this._pendingCount++, this.stats.get(Nb).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--, this.stats.get(Nb).decrementCount();
  }
  _addTileToCache(e) {
    this._cache.add(this, e, (t) => t._updateCacheStats(e));
  }
  _updateCacheStats(e) {
    this.stats.get(j3).incrementCount(), this.stats.get(Ob).incrementCount(), this.gpuMemoryUsageInBytes += e.gpuMemoryUsageInBytes || 0, this.stats.get(Db).count = this.gpuMemoryUsageInBytes, this.options.memoryAdjustedScreenSpaceError && this.adjustScreenSpaceError();
  }
  _unloadTile(e) {
    this.gpuMemoryUsageInBytes -= e.gpuMemoryUsageInBytes || 0, this.stats.get(Ob).decrementCount(), this.stats.get(V3).incrementCount(), this.stats.get(Db).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(e), e.unloadContent();
  }
  // Traverse the tree and destroy all tiles
  _destroy() {
    const e = [];
    for (this.root && e.push(this.root); e.length > 0; ) {
      const t = e.pop();
      for (const n of t.children)
        e.push(n);
      this._destroyTile(t);
    }
    this.root = null;
  }
  // Traverse the tree and destroy all sub tiles
  _destroySubtree(e) {
    const t = e, n = [];
    for (n.push(t); n.length > 0; ) {
      e = n.pop();
      for (const i of e.children)
        n.push(i);
      e !== t && this._destroyTile(e);
    }
    t.children = [];
  }
  _destroyTile(e) {
    this._cache.unloadTile(this, e), this._unloadTile(e), e.destroy();
  }
  _initializeTiles3DTileset(e) {
    if (e.queryString) {
      const t = new URLSearchParams(e.queryString), n = Object.fromEntries(t.entries());
      this._queryParams = {
        ...this._queryParams,
        ...n
      };
    }
    if (this.asset = e.asset, !this.asset)
      throw new Error("Tileset must have an asset property.");
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0" && this.asset.version !== "1.1")
      throw new Error("The tileset must be 3D Tiles version either 0.0 or 1.0 or 1.1.");
    "tilesetVersion" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {
      attributions: this.options.attributions || []
    }, this.description = this.options.description || "", this.properties = e.properties, this.geometricError = e.geometricError, this._extensionsUsed = e.extensionsUsed || [], this.extras = e.extras;
  }
  _initializeI3STileset() {
    this.loadOptions.i3s && "token" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);
  }
}
const BI = "4.3.2", Dp = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GLTF: "glTF"
};
function LI(r, e, t) {
  xi(r instanceof ArrayBuffer);
  const n = new TextDecoder("utf8"), i = new Uint8Array(r, e, t);
  return n.decode(i);
}
function pH(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const t = new DataView(r);
  return `${String.fromCharCode(t.getUint8(e + 0))}${String.fromCharCode(t.getUint8(e + 1))}${String.fromCharCode(t.getUint8(e + 2))}${String.fromCharCode(t.getUint8(e + 3))}`;
}
const gH = {
  POINTS: 0,
  // Points. single points.
  LINES: 1,
  // Lines. Each vertex connects to the one after it.
  LINE_LOOP: 2,
  // Lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 3,
  // Lines/ a connected group of line segments from the first vertex to the last
  TRIANGLES: 4,
  // Triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 5,
  // Triangles. A connected group of triangles.
  TRIANGLE_FAN: 6
  // Triangles. A connected group of triangles.
  // Each vertex connects to the previous and the first vertex in the fan.
}, ks = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
}, Vn = {
  ...gH,
  ...ks
}, kb = {
  [ks.DOUBLE]: Float64Array,
  [ks.FLOAT]: Float32Array,
  [ks.UNSIGNED_SHORT]: Uint16Array,
  [ks.UNSIGNED_INT]: Uint32Array,
  [ks.UNSIGNED_BYTE]: Uint8Array,
  [ks.BYTE]: Int8Array,
  [ks.SHORT]: Int16Array,
  [ks.INT]: Int32Array
}, mH = {
  DOUBLE: ks.DOUBLE,
  FLOAT: ks.FLOAT,
  UNSIGNED_SHORT: ks.UNSIGNED_SHORT,
  UNSIGNED_INT: ks.UNSIGNED_INT,
  UNSIGNED_BYTE: ks.UNSIGNED_BYTE,
  BYTE: ks.BYTE,
  SHORT: ks.SHORT,
  INT: ks.INT
}, Fb = "Failed to convert GL type";
class au {
  // Signature: fromTypedArray(new Uint8Array())
  // Signature: fromTypedArray(Uint8Array)
  /**
   * Returns the size, in bytes, of the corresponding datatype
   * @param arrayOrType
   * @returns glType a a string
   */
  static fromTypedArray(e) {
    e = ArrayBuffer.isView(e) ? e.constructor : e;
    for (const t in kb)
      if (kb[t] === e)
        return t;
    throw new Error(Fb);
  }
  /**
   * Extracts name for glType from array NAME_TO_GL_TYPE
   * @param name
   * @returns glType as a number
   */
  static fromName(e) {
    const t = mH[e];
    if (!t)
      throw new Error(Fb);
    return t;
  }
  // Converts GL constant to corresponding typed array type
  // eslint-disable-next-line complexity
  static getArrayType(e) {
    switch (e) {
      /*eslint-disable*/
      // @ts-ignore
      case ks.UNSIGNED_SHORT_5_6_5:
      // @ts-ignore
      case ks.UNSIGNED_SHORT_4_4_4_4:
      // @ts-ignore
      case ks.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const t = kb[e];
        if (!t)
          throw new Error(Fb);
        return t;
    }
  }
  /**
   * Returns the size in bytes of one element of the provided WebGL type
   * @param glType
   * @returns size of glType
   */
  static getByteSize(e) {
    return au.getArrayType(e).BYTES_PER_ELEMENT;
  }
  /**
   * Returns `true` if `glType` is a valid WebGL data type.
   * @param glType
   * @returns boolean
   */
  static validate(e) {
    return !!au.getArrayType(e);
  }
  /**
   * Creates a typed view of an array of bytes
   * @param glType The type of typed array (ArrayBuffer view) to create
   * @param buffer The buffer storage to use for the view.
   * @param byteOffset The offset, in bytes, to the first element in the view
   * @param length The number of elements in the view. Defaults to buffer length
   * @returns A typed array view of the buffer
   */
  static createTypedArray(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, i = arguments.length > 3 ? arguments[3] : void 0;
    i === void 0 && (i = (t.byteLength - n) / au.getByteSize(e));
    const s = au.getArrayType(e);
    return new s(t, n, i);
  }
}
function _H(r, e) {
  if (!r)
    throw new Error(`math.gl assertion failed. ${e}`);
}
function yH(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
  const t = r >> 11 & 31, n = r >> 5 & 63, i = r & 31;
  return e[0] = t << 3, e[1] = n << 2, e[2] = i << 3, e;
}
new h2();
new Tt();
new h2();
new h2();
function H3(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;
  return xc(r, 0, e) / e * 2 - 1;
}
function W3(r) {
  return r < 0 ? -1 : 1;
}
function bH(r, e, t, n) {
  if (_H(n), r < 0 || r > t || e < 0 || e > t)
    throw new Error(`x and y must be unsigned normalized integers between 0 and ${t}`);
  if (n.x = H3(r, t), n.y = H3(e, t), n.z = 1 - (Math.abs(n.x) + Math.abs(n.y)), n.z < 0) {
    const i = n.x;
    n.x = (1 - Math.abs(n.y)) * W3(i), n.y = (1 - Math.abs(i)) * W3(n.y);
  }
  return n.normalize();
}
function vH(r, e, t) {
  return bH(r, e, 255, t);
}
class $2 {
  constructor(e, t) {
    H(this, "json");
    H(this, "buffer");
    H(this, "featuresLength", 0);
    H(this, "_cachedTypedArrays", {});
    this.json = e, this.buffer = t;
  }
  getExtension(e) {
    return this.json.extensions && this.json.extensions[e];
  }
  hasProperty(e) {
    return !!this.json[e];
  }
  getGlobalProperty(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Vn.UNSIGNED_INT, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const i = this.json[e];
    return i && Number.isFinite(i.byteOffset) ? this._getTypedArrayFromBinary(e, t, n, 1, i.byteOffset) : i;
  }
  getPropertyArray(e, t, n) {
    const i = this.json[e];
    return i && Number.isFinite(i.byteOffset) ? ("componentType" in i && (t = au.fromName(i.componentType)), this._getTypedArrayFromBinary(e, t, n, this.featuresLength, i.byteOffset)) : this._getTypedArrayFromArray(e, t, i);
  }
  getProperty(e, t, n, i, s) {
    const l = this.json[e];
    if (!l)
      return l;
    const o = this.getPropertyArray(e, t, n);
    if (n === 1)
      return o[i];
    for (let d = 0; d < n; ++d)
      s[d] = o[n * i + d];
    return s;
  }
  // HELPERS
  _getTypedArrayFromBinary(e, t, n, i, s) {
    const l = this._cachedTypedArrays;
    let o = l[e];
    return o || (o = au.createTypedArray(t, this.buffer.buffer, this.buffer.byteOffset + s, i * n), l[e] = o), o;
  }
  _getTypedArrayFromArray(e, t, n) {
    const i = this._cachedTypedArrays;
    let s = i[e];
    return s || (s = au.createTypedArray(t, n), i[e] = s), s;
  }
}
const xH = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, wH = {
  SCALAR: (r, e) => r[e],
  VEC2: (r, e) => [r[2 * e + 0], r[2 * e + 1]],
  VEC3: (r, e) => [r[3 * e + 0], r[3 * e + 1], r[3 * e + 2]],
  VEC4: (r, e) => [r[4 * e + 0], r[4 * e + 1], r[4 * e + 2], r[4 * e + 3]],
  // TODO: check column major
  MAT2: (r, e) => [r[4 * e + 0], r[4 * e + 1], r[4 * e + 2], r[4 * e + 3]],
  MAT3: (r, e) => [r[9 * e + 0], r[9 * e + 1], r[9 * e + 2], r[9 * e + 3], r[9 * e + 4], r[9 * e + 5], r[9 * e + 6], r[9 * e + 7], r[9 * e + 8]],
  MAT4: (r, e) => [r[16 * e + 0], r[16 * e + 1], r[16 * e + 2], r[16 * e + 3], r[16 * e + 4], r[16 * e + 5], r[16 * e + 6], r[16 * e + 7], r[16 * e + 8], r[16 * e + 9], r[16 * e + 10], r[16 * e + 11], r[16 * e + 12], r[16 * e + 13], r[16 * e + 14], r[16 * e + 15]]
}, AH = {
  SCALAR: (r, e, t) => {
    e[t] = r;
  },
  VEC2: (r, e, t) => {
    e[2 * t + 0] = r[0], e[2 * t + 1] = r[1];
  },
  VEC3: (r, e, t) => {
    e[3 * t + 0] = r[0], e[3 * t + 1] = r[1], e[3 * t + 2] = r[2];
  },
  VEC4: (r, e, t) => {
    e[4 * t + 0] = r[0], e[4 * t + 1] = r[1], e[4 * t + 2] = r[2], e[4 * t + 3] = r[3];
  },
  // TODO: check column major correctness
  MAT2: (r, e, t) => {
    e[4 * t + 0] = r[0], e[4 * t + 1] = r[1], e[4 * t + 2] = r[2], e[4 * t + 3] = r[3];
  },
  MAT3: (r, e, t) => {
    e[9 * t + 0] = r[0], e[9 * t + 1] = r[1], e[9 * t + 2] = r[2], e[9 * t + 3] = r[3], e[9 * t + 4] = r[4], e[9 * t + 5] = r[5], e[9 * t + 6] = r[6], e[9 * t + 7] = r[7], e[9 * t + 8] = r[8], e[9 * t + 9] = r[9];
  },
  MAT4: (r, e, t) => {
    e[16 * t + 0] = r[0], e[16 * t + 1] = r[1], e[16 * t + 2] = r[2], e[16 * t + 3] = r[3], e[16 * t + 4] = r[4], e[16 * t + 5] = r[5], e[16 * t + 6] = r[6], e[16 * t + 7] = r[7], e[16 * t + 8] = r[8], e[16 * t + 9] = r[9], e[16 * t + 10] = r[10], e[16 * t + 11] = r[11], e[16 * t + 12] = r[12], e[16 * t + 13] = r[13], e[16 * t + 14] = r[14], e[16 * t + 15] = r[15];
  }
};
function TH(r, e, t, n) {
  const {
    componentType: i
  } = r;
  xi(r.componentType);
  const s = typeof i == "string" ? au.fromName(i) : i, l = xH[r.type], o = wH[r.type], d = AH[r.type];
  return t += r.byteOffset, {
    values: au.createTypedArray(s, e, t, l * n),
    type: s,
    size: l,
    unpacker: o,
    packer: d
  };
}
const ou = (r) => r !== void 0;
function SH(r, e, t) {
  if (!e)
    return null;
  let n = r.getExtension("3DTILES_batch_table_hierarchy");
  const i = e.HIERARCHY;
  return i && (console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy."), e.extensions = e.extensions || {}, e.extensions["3DTILES_batch_table_hierarchy"] = i, n = i), n ? EH(n, t) : null;
}
function EH(r, e) {
  let t, n, i;
  const s = r.instancesLength, l = r.classes;
  let o = r.classIds, d = r.parentCounts, m = r.parentIds, b = s;
  ou(o.byteOffset) && (o.componentType = defaultValue(o.componentType, GL.UNSIGNED_SHORT), o.type = AttributeType.SCALAR, i = getBinaryAccessor(o), o = i.createArrayBufferView(e.buffer, e.byteOffset + o.byteOffset, s));
  let T;
  if (ou(d))
    for (ou(d.byteOffset) && (d.componentType = defaultValue(d.componentType, GL.UNSIGNED_SHORT), d.type = AttributeType.SCALAR, i = getBinaryAccessor(d), d = i.createArrayBufferView(e.buffer, e.byteOffset + d.byteOffset, s)), T = new Uint16Array(s), b = 0, t = 0; t < s; ++t)
      T[t] = b, b += d[t];
  ou(m) && ou(m.byteOffset) && (m.componentType = defaultValue(m.componentType, GL.UNSIGNED_SHORT), m.type = AttributeType.SCALAR, i = getBinaryAccessor(m), m = i.createArrayBufferView(e.buffer, e.byteOffset + m.byteOffset, b));
  const M = l.length;
  for (t = 0; t < M; ++t) {
    const q = l[t].length, G = l[t].instances, Y = getBinaryProperties(q, G, e);
    l[t].instances = combine(Y, G);
  }
  const E = new Array(M).fill(0), D = new Uint16Array(s);
  for (t = 0; t < s; ++t)
    n = o[t], D[t] = E[n], ++E[n];
  const U = {
    classes: l,
    classIds: o,
    classIndexes: D,
    parentCounts: d,
    parentIndexes: T,
    parentIds: m
  };
  return MH(U), U;
}
function kp(r, e, t) {
  if (!r)
    return;
  const n = r.parentCounts;
  return r.parentIds ? t(r, e) : n > 0 ? CH(r, e, t) : IH(r, e, t);
}
function CH(r, e, t) {
  const n = r.classIds, i = r.parentCounts, s = r.parentIds, l = r.parentIndexes, o = n.length, d = scratchVisited;
  d.length = Math.max(d.length, o);
  const m = ++marker, b = scratchStack;
  for (b.length = 0, b.push(e); b.length > 0; ) {
    if (e = b.pop(), d[e] === m)
      continue;
    d[e] = m;
    const T = t(r, e);
    if (ou(T))
      return T;
    const M = i[e], E = l[e];
    for (let D = 0; D < M; ++D) {
      const U = s[E + D];
      U !== e && b.push(U);
    }
  }
  return null;
}
function IH(r, e, t) {
  let n = !0;
  for (; n; ) {
    const i = t(r, e);
    if (ou(i))
      return i;
    const s = r.parentIds[e];
    n = s !== e, e = s;
  }
  throw new Error("traverseHierarchySingleParent");
}
function MH(r) {
  const t = r.classIds.length;
  for (let n = 0; n < t; ++n)
    OI(r, n, stack);
}
function OI(r, e, t) {
  const n = r.parentCounts, i = r.parentIds, s = r.parentIndexes, o = r.classIds.length;
  if (!ou(i))
    return;
  assert(e < o, `Parent index ${e} exceeds the total number of instances: ${o}`), assert(t.indexOf(e) === -1, "Circular dependency detected in the batch table hierarchy."), t.push(e);
  const d = ou(n) ? n[e] : 1, m = ou(n) ? s[e] : e;
  for (let b = 0; b < d; ++b) {
    const T = i[m + b];
    T !== e && OI(r, T, t);
  }
  t.pop(e);
}
function va(r) {
  return r != null;
}
const Om = (r, e) => r, PH = {
  HIERARCHY: !0,
  // Deprecated HIERARCHY property
  extensions: !0,
  extras: !0
};
class NI {
  constructor(e, t, n) {
    H(this, "json");
    H(this, "binary");
    H(this, "featureCount");
    H(this, "_extensions");
    // Copy all top-level property fields from the json object, ignoring special fields
    H(this, "_properties");
    H(this, "_binaryProperties");
    // TODO: hierarchy support is only partially implemented and not tested
    H(this, "_hierarchy");
    var s;
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    xi(n >= 0), this.json = e || {}, this.binary = t, this.featureCount = n, this._extensions = ((s = this.json) == null ? void 0 : s.extensions) || {}, this._properties = {};
    for (const l in this.json)
      PH[l] || (this._properties[l] = this.json[l]);
    this._binaryProperties = this._initializeBinaryProperties(), i["3DTILES_batch_table_hierarchy"] && (this._hierarchy = SH(this, this.json, this.binary));
  }
  getExtension(e) {
    return this.json && this.json.extensions && this.json.extensions[e];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(e, t) {
    if (this._checkBatchId(e), xi(typeof t == "string", t), this._hierarchy) {
      const n = kp(this._hierarchy, e, (i, s) => {
        const l = i.classIds[s];
        return i.classes[l].name === t;
      });
      return va(n);
    }
    return !1;
  }
  isExactClass(e, t) {
    return xi(typeof t == "string", t), this.getExactClassName(e) === t;
  }
  getExactClassName(e) {
    if (this._checkBatchId(e), this._hierarchy) {
      const t = this._hierarchy.classIds[e];
      return this._hierarchy.classes[t].name;
    }
  }
  hasProperty(e, t) {
    return this._checkBatchId(e), xi(typeof t == "string", t), va(this._properties[t]) || this._hasPropertyInHierarchy(e, t);
  }
  getPropertyNames(e, t) {
    this._checkBatchId(e), t = va(t) ? t : [], t.length = 0;
    const n = Object.keys(this._properties);
    return t.push(...n), this._hierarchy && this._getPropertyNamesInHierarchy(e, t), t;
  }
  getProperty(e, t) {
    if (this._checkBatchId(e), xi(typeof t == "string", t), this._binaryProperties) {
      const i = this._binaryProperties[t];
      if (va(i))
        return this._getBinaryProperty(i, e);
    }
    const n = this._properties[t];
    if (va(n))
      return Om(n[e]);
    if (this._hierarchy) {
      const i = this._getHierarchyProperty(e, t);
      if (va(i))
        return i;
    }
  }
  setProperty(e, t, n) {
    const i = this.featureCount;
    if (this._checkBatchId(e), xi(typeof t == "string", t), this._binaryProperties) {
      const l = this._binaryProperties[t];
      if (l) {
        this._setBinaryProperty(l, e, n);
        return;
      }
    }
    if (this._hierarchy && this._setHierarchyProperty(this, e, t, n))
      return;
    let s = this._properties[t];
    va(s) || (this._properties[t] = new Array(i), s = this._properties[t]), s[e] = Om(n);
  }
  // PRIVATE METHODS
  _checkBatchId(e) {
    if (!(e >= 0 && e < this.featureCount))
      throw new Error("batchId not in range [0, featureCount - 1].");
  }
  _getBinaryProperty(e, t) {
    return e.unpack(e.typedArray, t);
  }
  _setBinaryProperty(e, t, n) {
    e.pack(n, e.typedArray, t);
  }
  _initializeBinaryProperties() {
    let e = null;
    for (const t in this._properties) {
      const n = this._properties[t], i = this._initializeBinaryProperty(t, n);
      i && (e = e || {}, e[t] = i);
    }
    return e;
  }
  _initializeBinaryProperty(e, t) {
    if ("byteOffset" in t) {
      const n = t;
      xi(this.binary, `Property ${e} requires a batch table binary.`), xi(n.type, `Property ${e} requires a type.`);
      const i = TH(n, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: i.values,
        componentCount: i.size,
        unpack: i.unpacker,
        pack: i.packer
      };
    }
    return null;
  }
  //  EXTENSION SUPPORT: 3DTILES_batch_table_hierarchy
  _hasPropertyInHierarchy(e, t) {
    if (!this._hierarchy)
      return !1;
    const n = kp(this._hierarchy, e, (i, s) => {
      const l = i.classIds[s], o = i.classes[l].instances;
      return va(o[t]);
    });
    return va(n);
  }
  _getPropertyNamesInHierarchy(e, t) {
    kp(this._hierarchy, e, (n, i) => {
      const s = n.classIds[i], l = n.classes[s].instances;
      for (const o in l)
        l.hasOwnProperty(o) && t.indexOf(o) === -1 && t.push(o);
    });
  }
  _getHierarchyProperty(e, t) {
    return kp(this._hierarchy, e, (n, i) => {
      const s = n.classIds[i], l = n.classes[s], o = n.classIndexes[i], d = l.instances[t];
      return va(d) ? va(d.typedArray) ? this._getBinaryProperty(d, o) : Om(d[o]) : null;
    });
  }
  _setHierarchyProperty(e, t, n, i) {
    const s = kp(this._hierarchy, t, (l, o) => {
      const d = l.classIds[o], m = l.classes[d], b = l.classIndexes[o], T = m.instances[n];
      return va(T) ? (xi(o === t, `Inherited property "${n}" is read-only.`), va(T.typedArray) ? this._setBinaryProperty(T, b, i) : T[b] = Om(i), !0) : !1;
    });
    return va(s);
  }
}
const Ub = 4;
function Py(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const n = new DataView(e);
  if (r.magic = n.getUint32(t, !0), t += Ub, r.version = n.getUint32(t, !0), t += Ub, r.byteLength = n.getUint32(t, !0), t += Ub, r.version !== 1)
    throw new Error(`3D Tile Version ${r.version} not supported`);
  return t;
}
const cd = 4, X3 = "b3dm tile in legacy format.";
function H2(r, e, t) {
  const n = new DataView(e);
  let i;
  r.header = r.header || {};
  let s = n.getUint32(t, !0);
  t += cd;
  let l = n.getUint32(t, !0);
  t += cd;
  let o = n.getUint32(t, !0);
  t += cd;
  let d = n.getUint32(t, !0);
  return t += cd, o >= 570425344 ? (t -= cd * 2, i = s, o = l, d = 0, s = 0, l = 0, console.warn(X3)) : d >= 570425344 && (t -= cd, i = o, o = s, d = l, s = 0, l = 0, console.warn(X3)), r.header.featureTableJsonByteLength = s, r.header.featureTableBinaryByteLength = l, r.header.batchTableJsonByteLength = o, r.header.batchTableBinaryByteLength = d, r.header.batchLength = i, t;
}
function W2(r, e, t, n) {
  return t = RH(r, e, t), t = BH(r, e, t), t;
}
function RH(r, e, t, n) {
  const {
    featureTableJsonByteLength: i,
    featureTableBinaryByteLength: s,
    batchLength: l
  } = r.header || {};
  if (r.featureTableJson = {
    BATCH_LENGTH: l || 0
  }, i && i > 0) {
    const o = LI(e, t, i);
    r.featureTableJson = JSON.parse(o);
  }
  return t += i || 0, r.featureTableBinary = new Uint8Array(e, t, s), t += s || 0, t;
}
function BH(r, e, t, n) {
  const {
    batchTableJsonByteLength: i,
    batchTableBinaryByteLength: s
  } = r.header || {};
  if (i && i > 0) {
    const l = LI(e, t, i);
    r.batchTableJson = JSON.parse(l), t += i, s && s > 0 && (r.batchTableBinary = new Uint8Array(e, t, s), r.batchTableBinary = new Uint8Array(r.batchTableBinary), t += s);
  }
  return t;
}
function DI(r, e, t) {
  if (!e && (!r || !r.batchIds || !t))
    return null;
  const {
    batchIds: n,
    isRGB565: i,
    pointCount: s = 0
  } = r;
  if (n && t) {
    const l = new Uint8ClampedArray(s * 3);
    for (let o = 0; o < s; o++) {
      const d = n[o], b = t.getProperty(d, "dimensions").map((T) => T * 255);
      l[o * 3] = b[0], l[o * 3 + 1] = b[1], l[o * 3 + 2] = b[2];
    }
    return {
      type: Vn.UNSIGNED_BYTE,
      value: l,
      size: 3,
      normalized: !0
    };
  }
  if (e && i) {
    const l = new Uint8ClampedArray(s * 3);
    for (let o = 0; o < s; o++) {
      const d = yH(e[o]);
      l[o * 3] = d[0], l[o * 3 + 1] = d[1], l[o * 3 + 2] = d[2];
    }
    return {
      type: Vn.UNSIGNED_BYTE,
      value: l,
      size: 3,
      normalized: !0
    };
  }
  return e && e.length === s * 3 ? {
    type: Vn.UNSIGNED_BYTE,
    value: e,
    size: 3,
    normalized: !0
  } : {
    type: Vn.UNSIGNED_BYTE,
    value: e || new Uint8ClampedArray(),
    size: 4,
    normalized: !0
  };
}
const Z3 = new Tt();
function LH(r, e) {
  if (!e)
    return null;
  if (r.isOctEncoded16P) {
    const t = new Float32Array((r.pointsLength || 0) * 3);
    for (let n = 0; n < (r.pointsLength || 0); n++)
      vH(e[n * 2], e[n * 2 + 1], Z3), Z3.toArray(t, n * 3);
    return {
      type: Vn.FLOAT,
      size: 2,
      value: t
    };
  }
  return {
    type: Vn.FLOAT,
    size: 2,
    value: e
  };
}
function OH(r, e, t) {
  return r.isQuantized ? t["3d-tiles"] && t["3d-tiles"].decodeQuantizedPositions ? (r.isQuantized = !1, NH(r, e)) : {
    type: Vn.UNSIGNED_SHORT,
    value: e,
    size: 3,
    normalized: !0
  } : e;
}
function NH(r, e) {
  const t = new Tt(), n = new Float32Array(r.pointCount * 3);
  for (let i = 0; i < r.pointCount; i++)
    t.set(e[i * 3], e[i * 3 + 1], e[i * 3 + 2]).scale(1 / r.quantizedRange).multiply(r.quantizedVolumeScale).add(r.quantizedVolumeOffset).toArray(n, i * 3);
  return n;
}
async function DH(r, e, t, n, i) {
  t = Py(r, e, t), t = H2(r, e, t), t = W2(r, e, t), kH(r);
  const {
    featureTable: s,
    batchTable: l
  } = FH(r);
  return await qH(r, s, l, n, i), UH(r, s, n), zH(r, s, l), jH(r, s), t;
}
function kH(r) {
  r.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, r.isQuantized = !1, r.isTranslucent = !1, r.isRGB565 = !1, r.isOctEncoded16P = !1;
}
function FH(r) {
  const e = new $2(r.featureTableJson, r.featureTableBinary), t = e.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(t))
    throw new Error("POINTS_LENGTH must be defined");
  e.featuresLength = t, r.featuresLength = t, r.pointsLength = t, r.pointCount = t, r.rtcCenter = e.getGlobalProperty("RTC_CENTER", Vn.FLOAT, 3);
  const n = VH(r, e);
  return {
    featureTable: e,
    batchTable: n
  };
}
function UH(r, e, t) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.positions) {
    if (e.hasProperty("POSITION"))
      r.attributes.positions = e.getPropertyArray("POSITION", Vn.FLOAT, 3);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      const n = e.getPropertyArray("POSITION_QUANTIZED", Vn.UNSIGNED_SHORT, 3);
      if (r.isQuantized = !0, r.quantizedRange = 65535, r.quantizedVolumeScale = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", Vn.FLOAT, 3), !r.quantizedVolumeScale)
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      if (r.quantizedVolumeOffset = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", Vn.FLOAT, 3), !r.quantizedVolumeOffset)
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      r.attributes.positions = OH(r, n, t);
    }
  }
  if (!r.attributes.positions)
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
}
function zH(r, e, t) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.colors) {
    let n = null;
    e.hasProperty("RGBA") ? (n = e.getPropertyArray("RGBA", Vn.UNSIGNED_BYTE, 4), r.isTranslucent = !0) : e.hasProperty("RGB") ? n = e.getPropertyArray("RGB", Vn.UNSIGNED_BYTE, 3) : e.hasProperty("RGB565") && (n = e.getPropertyArray("RGB565", Vn.UNSIGNED_SHORT, 1), r.isRGB565 = !0), r.attributes.colors = DI(r, n, t);
  }
  e.hasProperty("CONSTANT_RGBA") && (r.constantRGBA = e.getGlobalProperty("CONSTANT_RGBA", Vn.UNSIGNED_BYTE, 4));
}
function jH(r, e) {
  if (r.attributes = r.attributes || {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, !r.attributes.normals) {
    let t = null;
    e.hasProperty("NORMAL") ? t = e.getPropertyArray("NORMAL", Vn.FLOAT, 3) : e.hasProperty("NORMAL_OCT16P") && (t = e.getPropertyArray("NORMAL_OCT16P", Vn.UNSIGNED_BYTE, 2), r.isOctEncoded16P = !0), r.attributes.normals = LH(r, t);
  }
}
function VH(r, e) {
  let t = null;
  if (!r.batchIds && e.hasProperty("BATCH_ID") && (r.batchIds = e.getPropertyArray("BATCH_ID", Vn.UNSIGNED_SHORT, 1), r.batchIds)) {
    const n = e.getGlobalProperty("BATCH_LENGTH");
    if (!n)
      throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
    const {
      batchTableJson: i,
      batchTableBinary: s
    } = r;
    t = new NI(i, s, n);
  }
  return t;
}
async function qH(r, e, t, n, i) {
  let s, l, o;
  const d = r.batchTableJson && r.batchTableJson.extensions && r.batchTableJson.extensions["3DTILES_draco_point_compression"];
  d && (o = d.properties);
  const m = e.getExtension("3DTILES_draco_point_compression");
  if (m) {
    l = m.properties;
    const T = m.byteOffset, M = m.byteLength;
    if (!l || !Number.isFinite(T) || !M)
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    s = (r.featureTableBinary || []).slice(T, T + M), r.hasPositions = Number.isFinite(l.POSITION), r.hasColors = Number.isFinite(l.RGB) || Number.isFinite(l.RGBA), r.hasNormals = Number.isFinite(l.NORMAL), r.hasBatchIds = Number.isFinite(l.BATCH_ID), r.isTranslucent = Number.isFinite(l.RGBA);
  }
  if (!s)
    return !0;
  const b = {
    buffer: s,
    properties: {
      ...l,
      ...o
    },
    batchTableProperties: o
  };
  return await GH(r, b, n, i);
}
async function GH(r, e, t, n) {
  if (!n)
    return;
  const i = {
    ...t,
    draco: {
      ...t == null ? void 0 : t.draco,
      extraAttributes: e.batchTableProperties || {}
    }
  };
  delete i["3d-tiles"];
  const s = await Eg(e.buffer, vI, i, n), l = s.attributes.POSITION && s.attributes.POSITION.value, o = s.attributes.COLOR_0 && s.attributes.COLOR_0.value, d = s.attributes.NORMAL && s.attributes.NORMAL.value, m = s.attributes.BATCH_ID && s.attributes.BATCH_ID.value, b = l && s.attributes.POSITION.value.quantization, T = d && s.attributes.NORMAL.value.quantization;
  if (b) {
    const E = s.POSITION.data.quantization, D = E.range;
    r.quantizedVolumeScale = new Tt(D, D, D), r.quantizedVolumeOffset = new Tt(E.minValues), r.quantizedRange = (1 << E.quantizationBits) - 1, r.isQuantizedDraco = !0;
  }
  T && (r.octEncodedRange = (1 << s.NORMAL.data.quantization.quantizationBits) - 1, r.isOctEncodedDraco = !0);
  const M = {};
  if (e.batchTableProperties)
    for (const E of Object.keys(e.batchTableProperties))
      s.attributes[E] && s.attributes[E].value && (M[E.toLowerCase()] = s.attributes[E].value);
  r.attributes = {
    // @ts-expect-error
    positions: l,
    // @ts-expect-error
    colors: DI(r, o, void 0),
    // @ts-expect-error
    normals: d,
    // @ts-expect-error
    batchIds: m,
    ...M
  };
}
const pv = {
  URI: 0,
  EMBEDDED: 1
};
function kI(r, e, t, n) {
  r.rotateYtoZ = !0;
  const i = (r.byteOffset || 0) + (r.byteLength || 0) - t;
  if (i === 0)
    throw new Error("glTF byte length must be greater than 0.");
  return r.gltfUpAxis = n != null && n["3d-tiles"] && n["3d-tiles"].assetGltfUpAxis ? n["3d-tiles"].assetGltfUpAxis : "Y", r.gltfArrayBuffer = $v(e, t, i), r.gltfByteOffset = 0, r.gltfByteLength = i, t % 4 === 0 || console.warn(`${r.type}: embedded glb is not aligned to a 4-byte boundary.`), (r.byteOffset || 0) + (r.byteLength || 0);
}
async function FI(r, e, t, n) {
  const i = (t == null ? void 0 : t["3d-tiles"]) || {};
  if ($H(r, e), i.loadGLTF) {
    if (!n)
      return;
    if (r.gltfUrl) {
      const {
        fetch: s
      } = n, l = await s(r.gltfUrl, t);
      r.gltfArrayBuffer = await l.arrayBuffer(), r.gltfByteOffset = 0;
    }
    if (r.gltfArrayBuffer) {
      const s = await Eg(r.gltfArrayBuffer, xg, t, n);
      r.gltf = V2(s), r.gpuMemoryUsageInBytes = uI(r.gltf), delete r.gltfArrayBuffer, delete r.gltfByteOffset, delete r.gltfByteLength;
    }
  }
}
function $H(r, e, t) {
  switch (e) {
    case pv.URI:
      if (r.gltfArrayBuffer) {
        const n = new Uint8Array(r.gltfArrayBuffer, r.gltfByteOffset), s = new TextDecoder().decode(n);
        r.gltfUrl = s.replace(/[\s\0]+$/, "");
      }
      delete r.gltfArrayBuffer, delete r.gltfByteOffset, delete r.gltfByteLength;
      break;
    case pv.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}
async function HH(r, e, t, n, i) {
  var l;
  t = WH(r, e, t, n), await FI(r, pv.EMBEDDED, n, i);
  const s = (l = r == null ? void 0 : r.gltf) == null ? void 0 : l.extensions;
  return s && s.CESIUM_RTC && (r.rtcCenter = s.CESIUM_RTC.center), t;
}
function WH(r, e, t, n, i) {
  t = Py(r, e, t), t = H2(r, e, t), t = W2(r, e, t), t = kI(r, e, t, n);
  const s = new $2(r.featureTableJson, r.featureTableBinary);
  return r.rtcCenter = s.getGlobalProperty("RTC_CENTER", Vn.FLOAT, 3), t;
}
async function XH(r, e, t, n, i) {
  return t = ZH(r, e, t, n), await FI(r, r.gltfFormat || 0, n, i), t;
}
function ZH(r, e, t, n, i) {
  var m;
  if (t = Py(r, e, t), r.version !== 1)
    throw new Error(`Instanced 3D Model version ${r.version} is not supported`);
  t = H2(r, e, t);
  const s = new DataView(e);
  if (r.gltfFormat = s.getUint32(t, !0), t += 4, t = W2(r, e, t), t = kI(r, e, t, n), !((m = r == null ? void 0 : r.header) != null && m.featureTableJsonByteLength) || r.header.featureTableJsonByteLength === 0)
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  const l = new $2(r.featureTableJson, r.featureTableBinary), o = l.getGlobalProperty("INSTANCES_LENGTH");
  if (l.featuresLength = o, !Number.isFinite(o))
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  r.eastNorthUp = l.getGlobalProperty("EAST_NORTH_UP"), r.rtcCenter = l.getGlobalProperty("RTC_CENTER", Vn.FLOAT, 3);
  const d = new NI(r.batchTableJson, r.batchTableBinary, o);
  return YH(r, l, d, o), t;
}
function YH(r, e, t, n) {
  const i = new Array(n), s = new Tt();
  new Tt(), new Tt(), new Tt();
  const l = new us(), o = new fg(), d = new Tt(), m = {}, b = new Cn(), T = [], M = [], E = [], D = [];
  for (let U = 0; U < n; U++) {
    let q;
    if (e.hasProperty("POSITION"))
      q = e.getProperty("POSITION", Vn.FLOAT, 3, U, s);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      q = e.getProperty("POSITION_QUANTIZED", Vn.UNSIGNED_SHORT, 3, U, s);
      const ie = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", Vn.FLOAT, 3);
      if (!ie)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      const ye = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", Vn.FLOAT, 3);
      if (!ye)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      const oe = 65535;
      for (let Re = 0; Re < 3; Re++)
        q[Re] = q[Re] / oe * ye[Re] + ie[Re];
    }
    if (!q)
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    if (s.copy(q), m.translation = s, r.normalUp = e.getProperty("NORMAL_UP", Vn.FLOAT, 3, U, T), r.normalRight = e.getProperty("NORMAL_RIGHT", Vn.FLOAT, 3, U, M), r.normalUp) {
      if (!r.normalRight)
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      r.hasCustomOrientation = !0;
    } else {
      if (r.octNormalUp = e.getProperty("NORMAL_UP_OCT32P", Vn.UNSIGNED_SHORT, 2, U, T), r.octNormalRight = e.getProperty("NORMAL_RIGHT_OCT32P", Vn.UNSIGNED_SHORT, 2, U, M), r.octNormalUp)
        throw r.octNormalRight ? new Error("i3dm: oct-encoded orientation not implemented") : new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
      r.eastNorthUp ? (wi.WGS84.eastNorthUpToFixedFrame(s, b), b.getRotationMatrix3(l)) : l.identity();
    }
    o.fromMatrix3(l), m.rotation = o, d.set(1, 1, 1);
    const G = e.getProperty("SCALE", Vn.FLOAT, 1, U, E);
    Number.isFinite(G) && d.multiplyByScalar(G);
    const Y = e.getProperty("SCALE_NON_UNIFORM", Vn.FLOAT, 3, U, T);
    Y && d.scale(Y), m.scale = d;
    let he = e.getProperty("BATCH_ID", Vn.UNSIGNED_SHORT, 1, U, D);
    he === void 0 && (he = U);
    const X = new Cn().fromQuaternion(m.rotation);
    b.identity(), b.translate(m.translation), b.multiplyRight(X), b.scale(m.scale);
    const J = b.clone();
    i[U] = {
      modelMatrix: J,
      batchId: he
    };
  }
  r.instances = i;
}
async function KH(r, e, t, n, i, s) {
  t = Py(r, e, t);
  const l = new DataView(e);
  for (r.tilesLength = l.getUint32(t, !0), t += 4, r.tiles = []; r.tiles.length < r.tilesLength && (r.byteLength || 0) - t > 12; ) {
    const o = {
      shape: "tile3d"
    };
    r.tiles.push(o), t = await s(e, t, n, i, o);
  }
  return t;
}
async function JH(r, e, t, n) {
  var i, s;
  if (r.rotateYtoZ = !0, r.gltfUpAxis = (i = t == null ? void 0 : t["3d-tiles"]) != null && i.assetGltfUpAxis ? t["3d-tiles"].assetGltfUpAxis : "Y", (s = t == null ? void 0 : t["3d-tiles"]) != null && s.loadGLTF) {
    if (!n)
      return e.byteLength;
    const l = await Eg(e, xg, t, n);
    r.gltf = V2(l), r.gpuMemoryUsageInBytes = uI(r.gltf);
  } else
    r.gltfArrayBuffer = e;
  return e.byteLength;
}
async function UI(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 ? arguments[2] : void 0, n = arguments.length > 3 ? arguments[3] : void 0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
    shape: "tile3d"
  };
  switch (i.byteOffset = e, i.type = pH(r, e), i.type) {
    case Dp.COMPOSITE:
      return await KH(i, r, e, t, n, UI);
    case Dp.BATCHED_3D_MODEL:
      return await HH(i, r, e, t, n);
    case Dp.GLTF:
      return await JH(i, r, t, n);
    case Dp.INSTANCED_3D_MODEL:
      return await XH(i, r, e, t, n);
    case Dp.POINT_CLOUD:
      return await DH(i, r, e, t, n);
    default:
      throw new Error(`3DTileLoader: unknown type ${i.type}`);
  }
}
const QH = 1952609651, eW = 1;
async function tW(r, e, t) {
  if (new Uint32Array(r.slice(0, 4))[0] !== QH)
    throw new Error("Wrong subtree file magic number");
  if (new Uint32Array(r.slice(4, 8))[0] !== eW)
    throw new Error("Wrong subtree file verson, must be 1");
  const s = Y3(r.slice(8, 16)), l = new Uint8Array(r, 24, s), d = new TextDecoder("utf8").decode(l), m = JSON.parse(d), b = Y3(r.slice(16, 24));
  let T = new ArrayBuffer(0);
  if (b && (T = r.slice(24 + s)), await Nm(m, m.tileAvailability, T, t), Array.isArray(m.contentAvailability))
    for (const M of m.contentAvailability)
      await Nm(m, M, T, t);
  else
    await Nm(m, m.contentAvailability, T, t);
  return await Nm(m, m.childSubtreeAvailability, T, t), m;
}
async function Nm(r, e, t, n) {
  const i = Number.isFinite(e.bitstream) ? e.bitstream : e.bufferView;
  if (typeof i != "number")
    return;
  const s = r.bufferViews[i], l = r.buffers[s.buffer];
  if (!(n != null && n.baseUrl))
    throw new Error("Url is not provided");
  if (!n.fetch)
    throw new Error("fetch is not provided");
  if (l.uri) {
    const d = `${(n == null ? void 0 : n.baseUrl) || ""}/${l.uri}`, b = await (await n.fetch(d)).arrayBuffer();
    e.explicitBitstream = new Uint8Array(b, s.byteOffset, s.byteLength);
    return;
  }
  const o = r.buffers.slice(0, s.buffer).reduce((d, m) => d + m.byteLength, 0);
  e.explicitBitstream = new Uint8Array(t.slice(o, o + l.byteLength), s.byteOffset, s.byteLength);
}
function Y3(r) {
  const e = new DataView(r), t = e.getUint32(0, !0), n = e.getUint32(4, !0);
  return t + 2 ** 32 * n;
}
const zI = {
  dataType: null,
  batchType: null,
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: BI,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: tW,
  options: {}
};
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var Sl = null;
try {
  Sl = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch {
}
function si(r, e, t) {
  this.low = r | 0, this.high = e | 0, this.unsigned = !!t;
}
si.prototype.__isLong__;
Object.defineProperty(si.prototype, "__isLong__", {
  value: !0
});
function Ho(r) {
  return (r && r.__isLong__) === !0;
}
function K3(r) {
  var e = Math.clz32(r & -r);
  return r ? 31 - e : e;
}
si.isLong = Ho;
var J3 = {}, Q3 = {};
function Lf(r, e) {
  var t, n, i;
  return e ? (r >>>= 0, (i = 0 <= r && r < 256) && (n = Q3[r], n) ? n : (t = Wn(r, 0, !0), i && (Q3[r] = t), t)) : (r |= 0, (i = -128 <= r && r < 128) && (n = J3[r], n) ? n : (t = Wn(r, r < 0 ? -1 : 0, !1), i && (J3[r] = t), t));
}
si.fromInt = Lf;
function El(r, e) {
  if (isNaN(r)) return e ? ku : Sc;
  if (e) {
    if (r < 0) return ku;
    if (r >= jI) return GI;
  } else {
    if (r <= -9223372036854776e3) return Ta;
    if (r + 1 >= nW) return qI;
  }
  return r < 0 ? El(-r, e).neg() : Wn(r % Hd | 0, r / Hd | 0, e);
}
si.fromNumber = El;
function Wn(r, e, t) {
  return new si(r, e, t);
}
si.fromBits = Wn;
var X_ = Math.pow;
function X2(r, e, t) {
  if (r.length === 0) throw Error("empty string");
  if (typeof e == "number" ? (t = e, e = !1) : e = !!e, r === "NaN" || r === "Infinity" || r === "+Infinity" || r === "-Infinity") return e ? ku : Sc;
  if (t = t || 10, t < 2 || 36 < t) throw RangeError("radix");
  var n;
  if ((n = r.indexOf("-")) > 0) throw Error("interior hyphen");
  if (n === 0)
    return X2(r.substring(1), e, t).neg();
  for (var i = El(X_(t, 8)), s = Sc, l = 0; l < r.length; l += 8) {
    var o = Math.min(8, r.length - l), d = parseInt(r.substring(l, l + o), t);
    if (o < 8) {
      var m = El(X_(t, o));
      s = s.mul(m).add(El(d));
    } else
      s = s.mul(i), s = s.add(El(d));
  }
  return s.unsigned = e, s;
}
si.fromString = X2;
function Rc(r, e) {
  return typeof r == "number" ? El(r, e) : typeof r == "string" ? X2(r, e) : Wn(r.low, r.high, typeof e == "boolean" ? e : r.unsigned);
}
si.fromValue = Rc;
var eS = 65536, rW = 1 << 24, Hd = eS * eS, jI = Hd * Hd, nW = jI / 2, tS = Lf(rW), Sc = Lf(0);
si.ZERO = Sc;
var ku = Lf(0, !0);
si.UZERO = ku;
var Ad = Lf(1);
si.ONE = Ad;
var VI = Lf(1, !0);
si.UONE = VI;
var gv = Lf(-1);
si.NEG_ONE = gv;
var qI = Wn(-1, 2147483647, !1);
si.MAX_VALUE = qI;
var GI = Wn(-1, -1, !0);
si.MAX_UNSIGNED_VALUE = GI;
var Ta = Wn(0, -2147483648, !1);
si.MIN_VALUE = Ta;
var pr = si.prototype;
pr.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
pr.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * Hd + (this.low >>> 0) : this.high * Hd + (this.low >>> 0);
};
pr.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative())
    if (this.eq(Ta)) {
      var t = El(e), n = this.div(t), i = n.mul(t).sub(this);
      return n.toString(e) + i.toInt().toString(e);
    } else return "-" + this.neg().toString(e);
  for (var s = El(X_(e, 6), this.unsigned), l = this, o = ""; ; ) {
    var d = l.div(s), m = l.sub(d.mul(s)).toInt() >>> 0, b = m.toString(e);
    if (l = d, l.isZero()) return b + o;
    for (; b.length < 6; ) b = "0" + b;
    o = "" + b + o;
  }
};
pr.getHighBits = function() {
  return this.high;
};
pr.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
pr.getLowBits = function() {
  return this.low;
};
pr.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
pr.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(Ta) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, t = 31; t > 0 && (e & 1 << t) == 0; t--) ;
  return this.high != 0 ? t + 33 : t + 1;
};
pr.isZero = function() {
  return this.high === 0 && this.low === 0;
};
pr.eqz = pr.isZero;
pr.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
pr.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
pr.isOdd = function() {
  return (this.low & 1) === 1;
};
pr.isEven = function() {
  return (this.low & 1) === 0;
};
pr.equals = function(e) {
  return Ho(e) || (e = Rc(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
pr.eq = pr.equals;
pr.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
pr.neq = pr.notEquals;
pr.ne = pr.notEquals;
pr.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
pr.lt = pr.lessThan;
pr.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
pr.lte = pr.lessThanOrEqual;
pr.le = pr.lessThanOrEqual;
pr.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
pr.gt = pr.greaterThan;
pr.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
pr.gte = pr.greaterThanOrEqual;
pr.ge = pr.greaterThanOrEqual;
pr.compare = function(e) {
  if (Ho(e) || (e = Rc(e)), this.eq(e)) return 0;
  var t = this.isNegative(), n = e.isNegative();
  return t && !n ? -1 : !t && n ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
pr.comp = pr.compare;
pr.negate = function() {
  return !this.unsigned && this.eq(Ta) ? Ta : this.not().add(Ad);
};
pr.neg = pr.negate;
pr.add = function(e) {
  Ho(e) || (e = Rc(e));
  var t = this.high >>> 16, n = this.high & 65535, i = this.low >>> 16, s = this.low & 65535, l = e.high >>> 16, o = e.high & 65535, d = e.low >>> 16, m = e.low & 65535, b = 0, T = 0, M = 0, E = 0;
  return E += s + m, M += E >>> 16, E &= 65535, M += i + d, T += M >>> 16, M &= 65535, T += n + o, b += T >>> 16, T &= 65535, b += t + l, b &= 65535, Wn(M << 16 | E, b << 16 | T, this.unsigned);
};
pr.subtract = function(e) {
  return Ho(e) || (e = Rc(e)), this.add(e.neg());
};
pr.sub = pr.subtract;
pr.multiply = function(e) {
  if (this.isZero()) return this;
  if (Ho(e) || (e = Rc(e)), Sl) {
    var t = Sl.mul(this.low, this.high, e.low, e.high);
    return Wn(t, Sl.get_high(), this.unsigned);
  }
  if (e.isZero()) return this.unsigned ? ku : Sc;
  if (this.eq(Ta)) return e.isOdd() ? Ta : Sc;
  if (e.eq(Ta)) return this.isOdd() ? Ta : Sc;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative()) return this.mul(e.neg()).neg();
  if (this.lt(tS) && e.lt(tS)) return El(this.toNumber() * e.toNumber(), this.unsigned);
  var n = this.high >>> 16, i = this.high & 65535, s = this.low >>> 16, l = this.low & 65535, o = e.high >>> 16, d = e.high & 65535, m = e.low >>> 16, b = e.low & 65535, T = 0, M = 0, E = 0, D = 0;
  return D += l * b, E += D >>> 16, D &= 65535, E += s * b, M += E >>> 16, E &= 65535, E += l * m, M += E >>> 16, E &= 65535, M += i * b, T += M >>> 16, M &= 65535, M += s * m, T += M >>> 16, M &= 65535, M += l * d, T += M >>> 16, M &= 65535, T += n * b + i * m + s * d + l * o, T &= 65535, Wn(E << 16 | D, T << 16 | M, this.unsigned);
};
pr.mul = pr.multiply;
pr.divide = function(e) {
  if (Ho(e) || (e = Rc(e)), e.isZero()) throw Error("division by zero");
  if (Sl) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var t = (this.unsigned ? Sl.div_u : Sl.div_s)(this.low, this.high, e.low, e.high);
    return Wn(t, Sl.get_high(), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? ku : Sc;
  var n, i, s;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return ku;
    if (e.gt(this.shru(1)))
      return VI;
    s = ku;
  } else {
    if (this.eq(Ta)) {
      if (e.eq(Ad) || e.eq(gv)) return Ta;
      if (e.eq(Ta)) return Ad;
      var l = this.shr(1);
      return n = l.div(e).shl(1), n.eq(Sc) ? e.isNegative() ? Ad : gv : (i = this.sub(e.mul(n)), s = n.add(i.div(e)), s);
    } else if (e.eq(Ta)) return this.unsigned ? ku : Sc;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative()) return this.div(e.neg()).neg();
    s = Sc;
  }
  for (i = this; i.gte(e); ) {
    n = Math.max(1, Math.floor(i.toNumber() / e.toNumber()));
    for (var o = Math.ceil(Math.log(n) / Math.LN2), d = o <= 48 ? 1 : X_(2, o - 48), m = El(n), b = m.mul(e); b.isNegative() || b.gt(i); )
      n -= d, m = El(n, this.unsigned), b = m.mul(e);
    m.isZero() && (m = Ad), s = s.add(m), i = i.sub(b);
  }
  return s;
};
pr.div = pr.divide;
pr.modulo = function(e) {
  if (Ho(e) || (e = Rc(e)), Sl) {
    var t = (this.unsigned ? Sl.rem_u : Sl.rem_s)(this.low, this.high, e.low, e.high);
    return Wn(t, Sl.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
pr.mod = pr.modulo;
pr.rem = pr.modulo;
pr.not = function() {
  return Wn(~this.low, ~this.high, this.unsigned);
};
pr.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
pr.clz = pr.countLeadingZeros;
pr.countTrailingZeros = function() {
  return this.low ? K3(this.low) : K3(this.high) + 32;
};
pr.ctz = pr.countTrailingZeros;
pr.and = function(e) {
  return Ho(e) || (e = Rc(e)), Wn(this.low & e.low, this.high & e.high, this.unsigned);
};
pr.or = function(e) {
  return Ho(e) || (e = Rc(e)), Wn(this.low | e.low, this.high | e.high, this.unsigned);
};
pr.xor = function(e) {
  return Ho(e) || (e = Rc(e)), Wn(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
pr.shiftLeft = function(e) {
  return Ho(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Wn(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : Wn(0, this.low << e - 32, this.unsigned);
};
pr.shl = pr.shiftLeft;
pr.shiftRight = function(e) {
  return Ho(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Wn(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : Wn(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
pr.shr = pr.shiftRight;
pr.shiftRightUnsigned = function(e) {
  return Ho(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? Wn(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : e === 32 ? Wn(this.high, 0, this.unsigned) : Wn(this.high >>> e - 32, 0, this.unsigned);
};
pr.shru = pr.shiftRightUnsigned;
pr.shr_u = pr.shiftRightUnsigned;
pr.rotateLeft = function(e) {
  var t;
  return Ho(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Wn(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, Wn(this.low << e | this.high >>> t, this.high << e | this.low >>> t, this.unsigned)) : (e -= 32, t = 32 - e, Wn(this.high << e | this.low >>> t, this.low << e | this.high >>> t, this.unsigned));
};
pr.rotl = pr.rotateLeft;
pr.rotateRight = function(e) {
  var t;
  return Ho(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? Wn(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, Wn(this.high << t | this.low >>> e, this.low << t | this.high >>> e, this.unsigned)) : (e -= 32, t = 32 - e, Wn(this.low << t | this.high >>> e, this.high << t | this.low >>> e, this.unsigned));
};
pr.rotr = pr.rotateRight;
pr.toSigned = function() {
  return this.unsigned ? Wn(this.low, this.high, !1) : this;
};
pr.toUnsigned = function() {
  return this.unsigned ? this : Wn(this.low, this.high, !0);
};
pr.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
pr.toBytesLE = function() {
  var e = this.high, t = this.low;
  return [t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, e & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
};
pr.toBytesBE = function() {
  var e = this.high, t = this.low;
  return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, e & 255, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255];
};
si.fromBytes = function(e, t, n) {
  return n ? si.fromBytesLE(e, t) : si.fromBytesBE(e, t);
};
si.fromBytesLE = function(e, t) {
  return new si(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
};
si.fromBytesBE = function(e, t) {
  return new si(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
};
const iW = 16;
function $I(r) {
  r === "X" && (r = "");
  const e = r.padEnd(iW, "0");
  return si.fromString(e, !0, 16);
}
function sW(r) {
  if (r.isZero())
    return "X";
  let e = r.countTrailingZeros();
  const t = e % 4;
  e = (e - t) / 4;
  const n = e;
  e *= 4;
  const s = r.shiftRightUnsigned(e).toString(16).replace(/0+$/, "");
  return Array(17 - n - s.length).join("0") + s;
}
function oW(r, e) {
  const t = aW(r).shiftRightUnsigned(2);
  return r.add(si.fromNumber(2 * e + 1 - 4).multiply(t));
}
function aW(r) {
  return r.and(r.not().add(1));
}
const lW = 3, cW = 30, uW = 2 * cW + 1, rS = 180 / Math.PI;
function hW(r) {
  if (r.length === 0)
    throw new Error(`Invalid Hilbert quad key ${r}`);
  const e = r.split("/"), t = parseInt(e[0], 10), n = e[1], i = n.length;
  let s = 0;
  const l = [0, 0];
  for (let o = i - 1; o >= 0; o--) {
    s = i - o;
    const d = n[o];
    let m = 0, b = 0;
    d === "1" ? b = 1 : d === "2" ? (m = 1, b = 1) : d === "3" && (m = 1);
    const T = Math.pow(2, s - 1);
    dW(T, l, m, b), l[0] += T * m, l[1] += T * b;
  }
  if (t % 2 === 1) {
    const o = l[0];
    l[0] = l[1], l[1] = o;
  }
  return {
    face: t,
    ij: l,
    level: s
  };
}
function fW(r) {
  if (r.isZero())
    return "";
  let e = r.toString(2);
  for (; e.length < lW + uW; )
    e = "0" + e;
  const t = e.lastIndexOf("1"), n = e.substring(0, 3), i = e.substring(3, t), s = i.length / 2, l = si.fromString(n, !0, 2).toString(10);
  let o = "";
  if (s !== 0)
    for (o = si.fromString(i, !0, 2).toString(4); o.length < s; )
      o = "0" + o;
  return `${l}/${o}`;
}
function HI(r, e, t) {
  const n = 1 << e;
  return [(r[0] + t[0]) / n, (r[1] + t[1]) / n];
}
function nS(r) {
  return r >= 0.5 ? 1 / 3 * (4 * r * r - 1) : 1 / 3 * (1 - 4 * (1 - r) * (1 - r));
}
function WI(r) {
  return [nS(r[0]), nS(r[1])];
}
function XI(r, e) {
  let [t, n] = e;
  switch (r) {
    case 0:
      return [1, t, n];
    case 1:
      return [-t, 1, n];
    case 2:
      return [-t, -n, 1];
    case 3:
      return [-1, -n, -t];
    case 4:
      return [n, -1, -t];
    case 5:
      return [n, t, -1];
    default:
      throw new Error("Invalid face");
  }
}
function ZI(r) {
  let [e, t, n] = r;
  const i = Math.atan2(n, Math.sqrt(e * e + t * t));
  return [Math.atan2(t, e) * rS, i * rS];
}
function dW(r, e, t, n) {
  if (n === 0) {
    t === 1 && (e[0] = r - 1 - e[0], e[1] = r - 1 - e[1]);
    const i = e[0];
    e[0] = e[1], e[1] = i;
  }
}
function pW(r) {
  const e = HI(r.ij, r.level, [0.5, 0.5]), t = WI(e), n = XI(r.face, t);
  return ZI(n);
}
const gW = 100;
function iS(r) {
  const {
    face: e,
    ij: t,
    level: n
  } = r, i = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]], s = Math.max(1, Math.ceil(gW * Math.pow(2, -n))), l = new Float64Array(4 * s * 2 + 2);
  let o = 0, d = 0;
  for (let m = 0; m < 4; m++) {
    const b = i[m].slice(0), T = i[m + 1], M = (T[0] - b[0]) / s, E = (T[1] - b[1]) / s;
    for (let D = 0; D < s; D++) {
      b[0] += M, b[1] += E;
      const U = HI(t, n, b), q = WI(U), G = XI(e, q), Y = ZI(G);
      Math.abs(Y[1]) > 89.999 && (Y[0] = d);
      const he = Y[0] - d;
      Y[0] += he > 180 ? -360 : he < -180 ? 360 : 0, l[o++] = Y[0], l[o++] = Y[1], d = Y[0];
    }
  }
  return l[o++] = l[0], l[o++] = l[1], l;
}
function Z2(r) {
  const e = mW(r);
  return hW(e);
}
function mW(r) {
  if (r.indexOf("/") > 0)
    return r;
  const e = $I(r);
  return fW(e);
}
function _W(r) {
  const e = Z2(r);
  return pW(e);
}
function yW(r) {
  let e;
  if (r.face === 2 || r.face === 5) {
    let t = null, n = 0;
    for (let i = 0; i < 4; i++) {
      const s = `${r.face}/${i}`, l = Z2(s), o = iS(l);
      (typeof t > "u" || t === null) && (t = new Float64Array(4 * o.length)), t.set(o, n), n += o.length;
    }
    e = sS(t);
  } else {
    const t = iS(r);
    e = sS(t);
  }
  return e;
}
function sS(r) {
  if (r.length % 2 !== 0)
    throw new Error("Invalid corners");
  const e = [], t = [];
  for (let n = 0; n < r.length; n += 2)
    e.push(r[n]), t.push(r[n + 1]);
  return e.sort((n, i) => n - i), t.sort((n, i) => n - i), {
    west: e[0],
    east: e[e.length - 1],
    north: t[t.length - 1],
    south: t[0]
  };
}
function bW(r, e) {
  const t = (e == null ? void 0 : e.minimumHeight) || 0, n = (e == null ? void 0 : e.maximumHeight) || 0, i = Z2(r), s = yW(i), l = s.west, o = s.south, d = s.east, m = s.north, b = [];
  return b.push(new Tt(l, m, t)), b.push(new Tt(d, m, t)), b.push(new Tt(d, o, t)), b.push(new Tt(l, o, t)), b.push(new Tt(l, m, n)), b.push(new Tt(d, m, n)), b.push(new Tt(d, o, n)), b.push(new Tt(l, o, n)), b;
}
function YI(r) {
  const e = r.token, t = {
    minimumHeight: r.minimumHeight,
    maximumHeight: r.maximumHeight
  }, n = bW(e, t), i = _W(e), s = i[0], l = i[1], o = wi.WGS84.cartographicToCartesian([s, l, t.maximumHeight]), d = new Tt(o[0], o[1], o[2]);
  n.push(d);
  const m = aj(n);
  return [...m.center, ...m.halfAxes];
}
const vW = 4, xW = 8, wW = {
  QUADTREE: vW,
  OCTREE: xW
};
function AW(r, e, t) {
  if (r != null && r.box) {
    const n = $I(r.s2VolumeInfo.token), i = oW(n, e), s = sW(i), l = {
      ...r.s2VolumeInfo
    };
    switch (l.token = s, t) {
      case "OCTREE":
        const m = r.s2VolumeInfo, b = m.maximumHeight - m.minimumHeight, T = b / 2, M = m.minimumHeight + b / 2;
        m.minimumHeight = M - T, m.maximumHeight = M + T;
        break;
    }
    return {
      box: YI(l),
      s2VolumeInfo: l
    };
  }
}
async function KI(r) {
  const {
    subtree: e,
    subtreeData: t = {
      level: 0,
      x: 0,
      y: 0,
      z: 0
    },
    parentData: n = {
      mortonIndex: 0,
      localLevel: -1,
      localX: 0,
      localY: 0,
      localZ: 0
    },
    childIndex: i = 0,
    implicitOptions: s,
    loaderOptions: l,
    s2VolumeBox: o
  } = r, {
    subdivisionScheme: d,
    subtreeLevels: m,
    maximumLevel: b,
    contentUrlTemplate: T,
    subtreesUriTemplate: M,
    basePath: E
  } = s, D = {
    children: [],
    lodMetricValue: 0,
    contentUrl: ""
  };
  if (!b)
    return fE.once(`Missing 'maximumLevel' or 'availableLevels' property. The subtree ${T} won't be loaded...`), D;
  const U = n.localLevel + 1, q = t.level + U;
  if (q > b)
    return D;
  const G = wW[d], Y = Math.log2(G), he = i & 1, X = i >> 1 & 1, J = i >> 2 & 1, ie = tf(n.localX, he, 1), ye = tf(n.localY, X, 1), oe = tf(n.localZ, J, 1), Re = tf(t.x, ie, U), Ne = tf(t.y, ye, U), me = tf(t.z, oe, U), _e = tf(n.mortonIndex, i, Y), Fe = U === m && zb(e.childSubtreeAvailability, _e);
  let Me, Ct, ht, Pt;
  if (Fe) {
    const Nt = `${E}/${M}`, mr = mv(Nt, q, Re, Ne, me);
    Me = await Ph(mr, zI, l), Pt = 0, Ct = {
      level: q,
      x: Re,
      y: Ne,
      z: me
    }, ht = {
      mortonIndex: 0,
      localLevel: 0,
      localX: 0,
      localY: 0,
      localZ: 0
    };
  } else
    Me = e, Pt = (G ** U - 1) / (G - 1) + _e, Ct = t, ht = {
      mortonIndex: _e,
      localLevel: U,
      localX: ie,
      localY: ye,
      localZ: oe
    };
  if (!zb(Me.tileAvailability, Pt))
    return D;
  zb(Me.contentAvailability, Pt) && (D.contentUrl = mv(T, q, Re, Ne, me));
  for (let Nt = 0; Nt < G; Nt++) {
    const mr = AW(o, Nt, d), ce = await KI({
      subtree: Me,
      subtreeData: Ct,
      parentData: ht,
      childIndex: Nt,
      implicitOptions: s,
      loaderOptions: l,
      s2VolumeBox: mr
    });
    (ce.contentUrl || ce.children.length) && D.children.push(ce);
  }
  return D.contentUrl || D.children.length ? TW(D, {
    level: q,
    x: Re,
    y: Ne,
    z: me
  }, s, o) : D;
}
function zb(r, e) {
  let t;
  return Array.isArray(r) ? (t = r[0], r.length > 1 && fE.once('Not supported extension "3DTILES_multiple_contents" has been detected')) : t = r, "constant" in t ? !!t.constant : t.explicitBitstream ? CW(e, t.explicitBitstream) : !1;
}
function TW(r, e, t, n) {
  const {
    basePath: i,
    refine: s,
    getRefine: l,
    lodMetricType: o,
    getTileType: d,
    rootLodMetricValue: m,
    rootBoundingVolume: b
  } = t, T = r.contentUrl && r.contentUrl.replace(`${i}/`, ""), M = m / 2 ** e.level, E = n != null && n.box ? {
    box: n.box
  } : b, D = SW(E, e, t.subdivisionScheme);
  return {
    children: r.children,
    contentUrl: r.contentUrl,
    content: {
      uri: T
    },
    id: r.contentUrl,
    refine: l(s),
    type: d(r),
    lodMetricType: o,
    lodMetricValue: M,
    geometricError: M,
    transform: r.transform,
    boundingVolume: D
  };
}
function SW(r, e, t) {
  if (r.region) {
    const {
      level: n,
      x: i,
      y: s,
      z: l
    } = e, [o, d, m, b, T, M] = r.region, E = 2 ** n, D = (m - o) / E, [U, q] = [o + D * i, o + D * (i + 1)], G = (b - d) / E, [Y, he] = [d + G * s, d + G * (s + 1)];
    let X, J;
    if (t === "OCTREE") {
      const ie = (M - T) / E;
      [X, J] = [T + ie * l, T + ie * (l + 1)];
    } else
      [X, J] = [T, M];
    return {
      region: [U, Y, q, he, X, J]
    };
  }
  if (r.box)
    return r;
  throw new Error(`Unsupported bounding volume type ${JSON.stringify(r)}`);
}
function tf(r, e, t) {
  return (r << t) + e;
}
function mv(r, e, t, n, i) {
  const s = EW({
    level: e,
    x: t,
    y: n,
    z: i
  });
  return r.replace(/{level}|{x}|{y}|{z}/gi, (l) => s[l]);
}
function EW(r) {
  const e = {};
  for (const t in r)
    e[`{${t}}`] = r[t];
  return e;
}
function CW(r, e) {
  const t = Math.floor(r / 8), n = r % 8;
  return (e[t] >> n & 1) === 1;
}
function Y2(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  if (!e)
    return Du.EMPTY;
  const n = e.split("?")[0].split(".").pop();
  switch (n) {
    case "pnts":
      return Du.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return Du.SCENEGRAPH;
    default:
      return n || Du.EMPTY;
  }
}
function K2(r) {
  switch (r) {
    case "REPLACE":
    case "replace":
      return Ic.REPLACE;
    case "ADD":
    case "add":
      return Ic.ADD;
    default:
      return r;
  }
}
function _v(r, e) {
  if (/^[a-z][0-9a-z+.-]*:/i.test(e)) {
    const n = new URL(r, `${e}/`);
    return decodeURI(n.toString());
  } else if (r.startsWith("/"))
    return r;
  return sB(e, r);
}
function oS(r, e) {
  var i;
  if (!r)
    return null;
  let t;
  if (r.content) {
    const s = r.content.uri || ((i = r.content) == null ? void 0 : i.url);
    typeof s < "u" && (t = _v(s, e));
  }
  return {
    ...r,
    id: t,
    contentUrl: t,
    lodMetricType: $d.GEOMETRIC_ERROR,
    lodMetricValue: r.geometricError,
    transformMatrix: r.transform,
    type: Y2(r, t),
    refine: K2(r.refine)
  };
}
async function IW(r, e, t) {
  let n = null;
  const i = lS(r.root);
  i && r.root ? n = await aS(r.root, r, e, i, t) : n = oS(r.root, e);
  const s = [];
  for (s.push(n); s.length > 0; ) {
    const l = s.pop() || {}, o = l.children || [], d = [];
    for (const m of o) {
      const b = lS(m);
      let T;
      b ? T = await aS(m, r, e, b, t) : T = oS(m, e), T && (d.push(T), s.push(T));
    }
    l.children = d;
  }
  return n;
}
async function aS(r, e, t, n, i) {
  var X, J, ie;
  const {
    subdivisionScheme: s,
    maximumLevel: l,
    availableLevels: o,
    subtreeLevels: d,
    subtrees: {
      uri: m
    }
  } = n, b = mv(m, 0, 0, 0, 0), T = _v(b, t), M = await Ph(T, zI, i), E = (X = r.content) == null ? void 0 : X.uri, D = E ? _v(E, t) : "", U = (J = e == null ? void 0 : e.root) == null ? void 0 : J.refine, q = r.geometricError, G = (ie = r.boundingVolume.extensions) == null ? void 0 : ie["3DTILES_bounding_volume_S2"];
  if (G) {
    const oe = {
      box: YI(G),
      s2VolumeInfo: G
    };
    r.boundingVolume = oe;
  }
  const Y = r.boundingVolume, he = {
    contentUrlTemplate: D,
    subtreesUriTemplate: m,
    subdivisionScheme: s,
    subtreeLevels: d,
    maximumLevel: Number.isFinite(o) ? o - 1 : l,
    refine: U,
    basePath: t,
    lodMetricType: $d.GEOMETRIC_ERROR,
    rootLodMetricValue: q,
    rootBoundingVolume: Y,
    getTileType: Y2,
    getRefine: K2
  };
  return await MW(r, t, M, he, i);
}
async function MW(r, e, t, n, i) {
  if (!r)
    return null;
  const {
    children: s,
    contentUrl: l
  } = await KI({
    subtree: t,
    implicitOptions: n,
    loaderOptions: i
  });
  let o, d = null;
  return l && (o = l, d = {
    uri: l.replace(`${e}/`, "")
  }), {
    ...r,
    id: o,
    contentUrl: o,
    lodMetricType: $d.GEOMETRIC_ERROR,
    lodMetricValue: r.geometricError,
    transformMatrix: r.transform,
    type: Y2(r, o),
    refine: K2(r.refine),
    content: d || r.content,
    children: s
  };
}
function lS(r) {
  var e;
  return ((e = r == null ? void 0 : r.extensions) == null ? void 0 : e["3DTILES_implicit_tiling"]) || (r == null ? void 0 : r.implicitTiling);
}
const J2 = {
  dataType: null,
  batchType: null,
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: BI,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: PW,
  options: {
    "3d-tiles": {
      loadGLTF: !0,
      decodeQuantizedPositions: !1,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
async function PW(r) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const n = e["3d-tiles"] || {};
  let i;
  return n.isTileset === "auto" ? i = (t == null ? void 0 : t.url) && t.url.indexOf(".json") !== -1 : i = n.isTileset, i ? RW(r, e, t) : BW(r, e, t);
}
async function RW(r, e, t) {
  var d;
  const n = JSON.parse(new TextDecoder().decode(r)), i = (t == null ? void 0 : t.url) || "", s = LW(i), l = await IW(n, s, e || {});
  return {
    ...n,
    shape: "tileset3d",
    loader: J2,
    url: i,
    queryString: (t == null ? void 0 : t.queryString) || "",
    basePath: s,
    root: l || n.root,
    type: wa.TILES3D,
    lodMetricType: $d.GEOMETRIC_ERROR,
    lodMetricValue: ((d = n.root) == null ? void 0 : d.geometricError) || 0
  };
}
async function BW(r, e, t) {
  const n = {
    content: {
      shape: "tile3d",
      featureIds: null
    }
  };
  return await UI(r, 0, e, t, n.content), n.content;
}
function LW(r) {
  return Hv(r);
}
const cS = [0], OW = {
  getPointColor: {
    type: "accessor",
    value: [0, 0, 0, 255]
  },
  pointSize: 1,
  // Disable async data loading (handling it in _loadTileSet)
  data: "",
  loader: J2,
  onTilesetLoad: {
    type: "function",
    value: (r) => {
    }
  },
  onTileLoad: {
    type: "function",
    value: (r) => {
    }
  },
  onTileUnload: {
    type: "function",
    value: (r) => {
    }
  },
  onTileError: {
    type: "function",
    value: (r, e, t) => {
    }
  },
  _getMeshColor: {
    type: "function",
    value: (r) => [255, 255, 255]
  }
};
class Q2 extends XC {
  initializeState() {
    "onTileLoadFail" in this.props && qn.removed("onTileLoadFail", "onTileError")(), this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    var e, t;
    return !!((t = (e = this.state) == null ? void 0 : e.tileset3d) != null && t.isLoaded() && super.isLoaded);
  }
  shouldUpdateState(e) {
    let {
      changeFlags: t
    } = e;
    return t.somethingChanged;
  }
  updateState(e) {
    let {
      props: t,
      oldProps: n,
      changeFlags: i
    } = e;
    if (t.data && t.data !== n.data && this._loadTileset(t.data), i.viewportChanged) {
      const {
        activeViewports: s
      } = this.state;
      Object.keys(s).length && (this._updateTileset(s), this.state.lastUpdatedViewports = s, this.state.activeViewports = {});
    }
    if (i.propsChanged) {
      const {
        layerMap: s
      } = this.state;
      for (const l in s)
        s[l].needsUpdate = !0;
    }
  }
  activateViewport(e) {
    const {
      activeViewports: t,
      lastUpdatedViewports: n
    } = this.state;
    this.internalState.viewport = e, t[e.id] = e;
    const i = n == null ? void 0 : n[e.id];
    (!i || !e.equals(i)) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.setNeedsUpdate());
  }
  getPickingInfo(e) {
    let {
      info: t,
      sourceLayer: n
    } = e;
    const i = n && n.props.tile;
    return t.picked && (t.object = i), t.sourceTile = i, t;
  }
  filterSubLayer(e) {
    let {
      layer: t,
      viewport: n
    } = e;
    const {
      tile: i
    } = t.props, {
      id: s
    } = n;
    return i.selected && i.viewportIds.includes(s);
  }
  _updateAutoHighlight(e) {
    const t = e.sourceTile, n = this.state.layerMap[t == null ? void 0 : t.id];
    n && n.layer && n.layer.updateAutoHighlight(e);
  }
  async _loadTileset(e) {
    const {
      loadOptions: t = {}
    } = this.props, n = this.props.loader || this.props.loaders, i = Array.isArray(n) ? n[0] : n, s = {
      loadOptions: {
        ...t
      }
    };
    let l = e;
    if (i.preload) {
      const m = await i.preload(e, t);
      m.url && (l = m.url), m.headers && (s.loadOptions.fetch = {
        ...s.loadOptions.fetch,
        headers: m.headers
      }), Object.assign(s, m);
    }
    const o = await Ph(l, i, s.loadOptions), d = new dH(o, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...s
    });
    this.setState({
      tileset3d: d,
      layerMap: {}
    }), this._updateTileset(this.state.activeViewports), this.props.onTilesetLoad(d);
  }
  _onTileLoad(e) {
    const {
      lastUpdatedViewports: t
    } = this.state;
    this.props.onTileLoad(e), this._updateTileset(t), this.setNeedsUpdate();
  }
  _onTileUnload(e) {
    delete this.state.layerMap[e.id], this.props.onTileUnload(e);
  }
  _updateTileset(e) {
    if (!e)
      return;
    const {
      tileset3d: t
    } = this.state, {
      timeline: n
    } = this.context, i = Object.keys(e).length;
    !n || !i || !t || t.selectTiles(Object.values(e)).then((s) => {
      this.state.frameNumber !== s && this.setState({
        frameNumber: s
      });
    });
  }
  _getSubLayer(e, t) {
    if (!e.content)
      return null;
    switch (e.type) {
      case Du.POINTCLOUD:
        return this._makePointCloudLayer(e, t);
      case Du.SCENEGRAPH:
        return this._make3DModelLayer(e);
      case Du.MESH:
        return this._makeSimpleMeshLayer(e, t);
      default:
        throw new Error(`Tile3DLayer: Failed to render layer of type ${e.content.type}`);
    }
  }
  _makePointCloudLayer(e, t) {
    const {
      attributes: n,
      pointCount: i,
      constantRGBA: s,
      cartographicOrigin: l,
      modelMatrix: o
    } = e.content, {
      positions: d,
      normals: m,
      colors: b
    } = n;
    if (!d)
      return null;
    const T = t && t.props.data || {
      header: {
        vertexCount: i
      },
      attributes: {
        POSITION: d,
        NORMAL: m,
        COLOR_0: b
      }
    }, {
      pointSize: M,
      getPointColor: E
    } = this.props, D = this.getSubLayerClass("pointcloud", N2);
    return new D({
      pointSize: M
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: `${this.id}-pointcloud-${e.id}`,
      tile: e,
      data: T,
      coordinateSystem: Rn.METER_OFFSETS,
      coordinateOrigin: l,
      modelMatrix: o,
      getColor: s || E,
      _offset: 0
    });
  }
  _make3DModelLayer(e) {
    const {
      gltf: t,
      instances: n,
      cartographicOrigin: i,
      modelMatrix: s
    } = e.content, l = this.getSubLayerClass("scenegraph", q2);
    return new l({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: `${this.id}-scenegraph-${e.id}`,
      tile: e,
      data: n || cS,
      scenegraph: t,
      coordinateSystem: Rn.METER_OFFSETS,
      coordinateOrigin: i,
      modelMatrix: s,
      getTransformMatrix: (o) => o.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(e, t) {
    const n = e.content, {
      attributes: i,
      indices: s,
      modelMatrix: l,
      cartographicOrigin: o,
      coordinateSystem: d = Rn.METER_OFFSETS,
      material: m,
      featureIds: b
    } = n, {
      _getMeshColor: T
    } = this.props, M = t && t.props.mesh || new Id({
      topology: "triangle-list",
      attributes: NW(i),
      indices: s
    }), E = this.getSubLayerClass("mesh", G2);
    return new E(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: `${this.id}-mesh-${e.id}`,
      tile: e,
      mesh: M,
      data: cS,
      getColor: T(e),
      pbrMaterial: m,
      modelMatrix: l,
      coordinateOrigin: o,
      coordinateSystem: d,
      featureIds: b,
      _offset: 0
    });
  }
  renderLayers() {
    const {
      tileset3d: e,
      layerMap: t
    } = this.state;
    return e ? e.tiles.map((n) => {
      const i = t[n.id] = t[n.id] || {
        tile: n
      };
      let {
        layer: s
      } = i;
      return n.selected && (s ? i.needsUpdate && (s = this._getSubLayer(n, s), i.needsUpdate = !1) : s = this._getSubLayer(n)), i.layer = s, s;
    }).filter(Boolean) : null;
  }
}
Q2.defaultProps = OW;
Q2.layerName = "Tile3DLayer";
function NW(r) {
  const e = {};
  return e.positions = {
    ...r.positions,
    value: new Float32Array(r.positions.value)
  }, r.normals && (e.normals = r.normals), r.texCoords && (e.texCoords = r.texCoords), r.colors && (e.colors = r.colors), r.uvRegions && (e.uvRegions = r.uvRegions), e;
}
var DW = Object.defineProperty, kW = (r, e, t) => e in r ? DW(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, jn = (r, e, t) => kW(r, typeof e != "symbol" ? e + "" : e, t);
class FW {
  constructor(e) {
    jn(this, "map"), jn(this, "width"), jn(this, "height"), jn(this, "svgCanvas"), jn(this, "xLine"), jn(this, "yLine"), jn(this, "color", "#535353"), this.map = e, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    var e, t;
    this.width = (e = this.map) == null ? void 0 : e.getCanvas().clientWidth, this.height = (t = this.map) == null ? void 0 : t.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const e = this.width / 2, t = this.height / 2;
      this.yLine.setAttribute("x1", `${e}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${e}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${t}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${t}px`);
    } else console.error("element value is null");
  }
  createCanvas(e) {
    if (this.width !== void 0 && this.height !== void 0) {
      const t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t.style.position = "relative", t.setAttribute("width", `${this.width}px`), t.setAttribute("height", `${this.height}px`);
      const n = this.width / 2, i = this.height / 2;
      this.yLine = t.appendChild(this.createLine(n, 0, n, this.height, this.color, "2px")), this.xLine = t.appendChild(this.createLine(0, i, this.width, i, this.color, "2px")), e == null || e.appendChild(t), this.svgCanvas = t;
    }
  }
  createLine(e, t, n, i, s, l) {
    const o = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return o.setAttribute("x1", e), o.setAttribute("y1", t), o.setAttribute("x2", n), o.setAttribute("y2", i), o.setAttribute("stroke-dasharray", "5,5"), o.setAttribute("stroke", s), o.setAttribute("stroke-width", l), o;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const yv = { 72: 72, 96: 96, 200: 200, 300: 300, 400: 400 }, Ou = { JPEG: "jpg", PNG: "png", PDF: "pdf", SVG: "svg" }, Kp = { Landscape: "landscape", Portrait: "portrait" }, ff = {
  // A0, A1, B0, B1 are not working well.
  // A0: [1189, 841],
  // A1: [841, 594],
  LETTER: [279, 216],
  // 8.5x11 - works
  //TABLOID: [432,279] // 11x17 - not working currently prints to 11.68x8.27 in landscape
  A2: [594, 420],
  A3: [420, 297],
  A4: [297, 210],
  A5: [210, 148],
  A6: [148, 105],
  // B0: [1414, 1000],
  // B1: [1000, 707],
  B2: [707, 500],
  B3: [500, 353],
  B4: [353, 250],
  B5: [250, 176],
  B6: [176, 125]
}, Wd = {
  // don't use inch unit. because page size setting is using mm unit.
  mm: "mm"
};
class UW {
  constructor(e) {
    jn(this, "map"), jn(this, "width"), jn(this, "height"), jn(this, "unit"), jn(this, "svgCanvas"), jn(this, "svgPath");
    var t, n, i;
    if (this.map = e, this.map === void 0) return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const s = (t = this.map) == null ? void 0 : t.getCanvas().clientWidth, l = (n = this.map) == null ? void 0 : n.getCanvas().clientHeight, o = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    o.style.position = "absolute", o.style.top = "0px", o.style.left = "0px", o.setAttribute("width", `${s}px`), o.setAttribute("height", `${l}px`);
    const d = document.createElementNS("http://www.w3.org/2000/svg", "path");
    d.setAttribute("style", "fill:#888888;stroke-width:0"), d.setAttribute("fill-opacity", "0.5"), o.append(d), (i = this.map) == null || i.getCanvasContainer().appendChild(o), this.svgCanvas = o, this.svgPath = d;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(e, t) {
    this.width = e, this.height = t, this.unit = Wd.mm, this.generateCutOut();
  }
  generateCutOut() {
    var e, t;
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0) return;
    const n = this.toPixels(this.width), i = this.toPixels(this.height), s = (e = this.map) == null ? void 0 : e.getCanvas().clientWidth, l = (t = this.map) == null ? void 0 : t.getCanvas().clientHeight, o = s / 2 - n / 2, d = o + n, m = l / 2 - i / 2, b = m + i;
    this.svgCanvas.setAttribute("width", `${s}px`), this.svgCanvas.setAttribute("height", `${l}px`), this.svgPath.setAttribute("d", `M 0 0 L ${s} 0 L ${s} ${l} L 0 ${l} M ${o} ${m} L ${o} ${b} L ${d} ${b} L ${d} ${m}`);
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 96;
    return this.unit === Wd.mm && (t /= 25.4), t * e;
  }
}
const JI = { PageSize: "Page Size", PageOrientation: "Page Orientation", Format: "Format", DPI: "DPI", Generate: "Generate", LanguageName: "English", LanguageCode: "en" }, zW = { PageSize: "Taille de page", PageOrientation: "Orientation de la page", Format: "Format", DPI: "DPI", Generate: "Gnrer", LanguageName: "Franais", LanguageCode: "fr" }, jW = { PageSize: "Sivukoko", PageOrientation: "Sivun suunta", Format: "Muoto", DPI: "DPI", Generate: "Generoi", LanguageName: "Suomalainen", LanguageCode: "fi" }, VW = { PageSize: "Papierformat", PageOrientation: "Papierausrichtung", Format: "Dateiformat", DPI: "Druckauflsung", Generate: "Erstellen", LanguageName: "Deutsch", LanguageCode: "de" }, qW = { PageSize: "Sidstorlek", PageOrientation: "Sidorientering", Format: "Format", DPI: "DPI", Generate: "Generera", LanguageName: "Svenska", LanguageCode: "sv" }, GW = { PageSize: "Tamao de pgina", PageOrientation: "Orientacin de pgina", Format: "Formato", DPI: "DPI", Generate: "Generar", LanguageName: "Espaola", LanguageCode: "es" }, $W = { PageSize: "Mida", PageOrientation: "Orientaci", Format: "Format", DPI: "DPI", Generate: "Genera", LanguageName: "Catalan", LanguageCode: "ca" }, HW = { PageSize: "Kch thc trang", PageOrientation: "Loi trang", Format: "nh dng", DPI: "Mt  im nh (DPI)", Generate: "To", LanguageName: "Ting Vit", LanguageCode: "vi" }, WW = { PageSize: " ", PageOrientation: " ", Format: "", DPI: "DPI", Generate: "", LanguageName: "", LanguageCode: "uk" }, XW = { PageSize: "", PageOrientation: "", Format: "", DPI: "", Generate: "", LanguageName: "", LanguageCode: "zhHans" }, ZW = { PageSize: "", PageOrientation: "", Format: "", DPI: "", Generate: "", LanguageName: "", LanguageCode: "zhHant" }, YW = { PageSize: "", PageOrientation: "", Format: "", DPI: "DPI", Generate: "", LanguageName: "", LanguageCode: "ja" }, KW = { PageSize: "Tamanho da pgina", PageOrientation: "Orientao da pgina", Format: "Formato", DPI: "DPI", Generate: "Gerar", LanguageName: "Portugus", LanguageCode: "pt" }, JW = [JI, zW, jW, VW, qW, GW, $W, HW, WW, XW, ZW, YW, KW], QW = (r) => JW.find((e) => e.LanguageCode === r) ?? JI;
function ii(r) {
  "@babel/helpers - typeof";
  return ii = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ii(r);
}
var Go = Uint8Array, Qa = Uint16Array, ex = Int32Array, Ry = new Go([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), By = new Go([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), bv = new Go([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), QI = function(r, e) {
  for (var t = new Qa(31), n = 0; n < 31; ++n) t[n] = e += 1 << r[n - 1];
  for (var i = new ex(t[30]), n = 1; n < 30; ++n) for (var s = t[n]; s < t[n + 1]; ++s) i[s] = s - t[n] << 5 | n;
  return { b: t, r: i };
}, eM = QI(Ry, 2), tM = eM.b, vv = eM.r;
tM[28] = 258, vv[258] = 28;
var rM = QI(By, 0), eX = rM.b, uS = rM.r, xv = new Qa(32768);
for (var ki = 0; ki < 32768; ++ki) {
  var ph = (ki & 43690) >> 1 | (ki & 21845) << 1;
  ph = (ph & 52428) >> 2 | (ph & 13107) << 2, ph = (ph & 61680) >> 4 | (ph & 3855) << 4, xv[ki] = ((ph & 65280) >> 8 | (ph & 255) << 8) >> 1;
}
var cu = function(r, e, t) {
  for (var n = r.length, i = 0, s = new Qa(e); i < n; ++i) r[i] && ++s[r[i] - 1];
  var l = new Qa(e);
  for (i = 1; i < e; ++i) l[i] = l[i - 1] + s[i - 1] << 1;
  var o;
  if (t) {
    o = new Qa(1 << e);
    var d = 15 - e;
    for (i = 0; i < n; ++i) if (r[i]) for (var m = i << 4 | r[i], b = e - r[i], T = l[r[i] - 1]++ << b, M = T | (1 << b) - 1; T <= M; ++T) o[xv[T] >> d] = m;
  } else for (o = new Qa(n), i = 0; i < n; ++i) r[i] && (o[i] = xv[l[r[i] - 1]++] >> 15 - r[i]);
  return o;
}, Nh = new Go(288);
for (var ki = 0; ki < 144; ++ki) Nh[ki] = 8;
for (var ki = 144; ki < 256; ++ki) Nh[ki] = 9;
for (var ki = 256; ki < 280; ++ki) Nh[ki] = 7;
for (var ki = 280; ki < 288; ++ki) Nh[ki] = 8;
var wg = new Go(32);
for (var ki = 0; ki < 32; ++ki) wg[ki] = 5;
var tX = /* @__PURE__ */ cu(Nh, 9, 0), rX = /* @__PURE__ */ cu(Nh, 9, 1), nX = /* @__PURE__ */ cu(wg, 5, 0), iX = /* @__PURE__ */ cu(wg, 5, 1), jb = function(r) {
  for (var e = r[0], t = 1; t < r.length; ++t) r[t] > e && (e = r[t]);
  return e;
}, hc = function(r, e, t) {
  var n = e / 8 | 0;
  return (r[n] | r[n + 1] << 8) >> (e & 7) & t;
}, Vb = function(r, e) {
  var t = e / 8 | 0;
  return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7);
}, tx = function(r) {
  return (r + 7) / 8 | 0;
}, nM = function(r, e, t) {
  return (t == null || t > r.length) && (t = r.length), new Go(r.subarray(e, t));
}, sX = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], mc = function(r, e, t) {
  var n = new Error(e || sX[r]);
  if (n.code = r, Error.captureStackTrace && Error.captureStackTrace(n, mc), !t) throw n;
  return n;
}, oX = function(r, e, t, n) {
  var i = r.length, s = 0;
  if (!i || e.f && !e.l) return t || new Go(0);
  var l = !t, o = l || e.i != 2, d = e.i;
  l && (t = new Go(i * 3));
  var m = function(Yt) {
    var cr = t.length;
    if (Yt > cr) {
      var _r = new Go(Math.max(cr * 2, Yt));
      _r.set(t), t = _r;
    }
  }, b = e.f || 0, T = e.p || 0, M = e.b || 0, E = e.l, D = e.d, U = e.m, q = e.n, G = i * 8;
  do {
    if (!E) {
      b = hc(r, T, 1);
      var Y = hc(r, T + 1, 3);
      if (T += 3, Y)
        if (Y == 1) E = rX, D = iX, U = 9, q = 5;
        else if (Y == 2) {
          var he = hc(r, T, 31) + 257, X = hc(r, T + 10, 15) + 4, J = he + hc(r, T + 5, 31) + 1;
          T += 14;
          for (var ie = new Go(J), ye = new Go(19), oe = 0; oe < X; ++oe) ye[bv[oe]] = hc(r, T + oe * 3, 7);
          T += X * 3;
          for (var Re = jb(ye), Ne = (1 << Re) - 1, me = cu(ye, Re, 1), oe = 0; oe < J; ) {
            var _e = me[hc(r, T, Ne)];
            T += _e & 15;
            var Fe = _e >> 4;
            if (Fe < 16) ie[oe++] = Fe;
            else {
              var Me = 0, Ct = 0;
              for (Fe == 16 ? (Ct = 3 + hc(r, T, 3), T += 2, Me = ie[oe - 1]) : Fe == 17 ? (Ct = 3 + hc(r, T, 7), T += 3) : Fe == 18 && (Ct = 11 + hc(r, T, 127), T += 7); Ct--; ) ie[oe++] = Me;
            }
          }
          var ht = ie.subarray(0, he), Pt = ie.subarray(he);
          U = jb(ht), q = jb(Pt), E = cu(ht, U, 1), D = cu(Pt, q, 1);
        } else mc(1);
      else {
        var Fe = tx(T) + 4, bt = r[Fe - 4] | r[Fe - 3] << 8, kt = Fe + bt;
        if (kt > i) {
          d && mc(0);
          break;
        }
        o && m(M + bt), t.set(r.subarray(Fe, kt), M), e.b = M += bt, e.p = T = kt * 8, e.f = b;
        continue;
      }
      if (T > G) {
        d && mc(0);
        break;
      }
    }
    o && m(M + 131072);
    for (var Nt = (1 << U) - 1, mr = (1 << q) - 1, ce = T; ; ce = T) {
      var Me = E[Vb(r, T) & Nt], Be = Me >> 4;
      if (T += Me & 15, T > G) {
        d && mc(0);
        break;
      }
      if (Me || mc(2), Be < 256) t[M++] = Be;
      else if (Be == 256) {
        ce = T, E = null;
        break;
      } else {
        var Ue = Be - 254;
        if (Be > 264) {
          var oe = Be - 257, Xe = Ry[oe];
          Ue = hc(r, T, (1 << Xe) - 1) + tM[oe], T += Xe;
        }
        var it = D[Vb(r, T) & mr], ft = it >> 4;
        it || mc(3), T += it & 15;
        var Pt = eX[ft];
        if (ft > 3) {
          var Xe = By[ft];
          Pt += Vb(r, T) & (1 << Xe) - 1, T += Xe;
        }
        if (T > G) {
          d && mc(0);
          break;
        }
        o && m(M + 131072);
        var St = M + Ue;
        if (M < Pt) {
          var wt = s - Pt, ar = Math.min(Pt, St);
          for (wt + M < 0 && mc(3); M < ar; ++M) t[M] = n[wt + M];
        }
        for (; M < St; ++M) t[M] = t[M - Pt];
      }
    }
    e.l = E, e.p = ce, e.b = M, e.f = b, E && (b = 1, e.m = U, e.d = D, e.n = q);
  } while (!b);
  return M != t.length && l ? nM(t, 0, M) : t.subarray(0, M);
}, Lu = function(r, e, t) {
  t <<= e & 7;
  var n = e / 8 | 0;
  r[n] |= t, r[n + 1] |= t >> 8;
}, Fp = function(r, e, t) {
  t <<= e & 7;
  var n = e / 8 | 0;
  r[n] |= t, r[n + 1] |= t >> 8, r[n + 2] |= t >> 16;
}, qb = function(r, e) {
  for (var t = [], n = 0; n < r.length; ++n) r[n] && t.push({ s: n, f: r[n] });
  var i = t.length, s = t.slice();
  if (!i) return { t: sM, l: 0 };
  if (i == 1) {
    var l = new Go(t[0].s + 1);
    return l[t[0].s] = 1, { t: l, l: 1 };
  }
  t.sort(function(J, ie) {
    return J.f - ie.f;
  }), t.push({ s: -1, f: 25001 });
  var o = t[0], d = t[1], m = 0, b = 1, T = 2;
  for (t[0] = { s: -1, f: o.f + d.f, l: o, r: d }; b != i - 1; ) o = t[t[m].f < t[T].f ? m++ : T++], d = t[m != b && t[m].f < t[T].f ? m++ : T++], t[b++] = { s: -1, f: o.f + d.f, l: o, r: d };
  for (var M = s[0].s, n = 1; n < i; ++n) s[n].s > M && (M = s[n].s);
  var E = new Qa(M + 1), D = wv(t[b - 1], E, 0);
  if (D > e) {
    var n = 0, U = 0, q = D - e, G = 1 << q;
    for (s.sort(function(ie, ye) {
      return E[ye.s] - E[ie.s] || ie.f - ye.f;
    }); n < i; ++n) {
      var Y = s[n].s;
      if (E[Y] > e) U += G - (1 << D - E[Y]), E[Y] = e;
      else break;
    }
    for (U >>= q; U > 0; ) {
      var he = s[n].s;
      E[he] < e ? U -= 1 << e - E[he]++ - 1 : ++n;
    }
    for (; n >= 0 && U; --n) {
      var X = s[n].s;
      E[X] == e && (--E[X], ++U);
    }
    D = e;
  }
  return { t: new Go(E), l: D };
}, wv = function(r, e, t) {
  return r.s == -1 ? Math.max(wv(r.l, e, t + 1), wv(r.r, e, t + 1)) : e[r.s] = t;
}, hS = function(r) {
  for (var e = r.length; e && !r[--e]; ) ;
  for (var t = new Qa(++e), n = 0, i = r[0], s = 1, l = function(d) {
    t[n++] = d;
  }, o = 1; o <= e; ++o) if (r[o] == i && o != e) ++s;
  else {
    if (!i && s > 2) {
      for (; s > 138; s -= 138) l(32754);
      s > 2 && (l(s > 10 ? s - 11 << 5 | 28690 : s - 3 << 5 | 12305), s = 0);
    } else if (s > 3) {
      for (l(i), --s; s > 6; s -= 6) l(8304);
      s > 2 && (l(s - 3 << 5 | 8208), s = 0);
    }
    for (; s--; ) l(i);
    s = 1, i = r[o];
  }
  return { c: t.subarray(0, n), n: e };
}, Up = function(r, e) {
  for (var t = 0, n = 0; n < e.length; ++n) t += r[n] * e[n];
  return t;
}, iM = function(r, e, t) {
  var n = t.length, i = tx(e + 2);
  r[i] = n & 255, r[i + 1] = n >> 8, r[i + 2] = r[i] ^ 255, r[i + 3] = r[i + 1] ^ 255;
  for (var s = 0; s < n; ++s) r[i + s + 4] = t[s];
  return (i + 4 + n) * 8;
}, fS = function(r, e, t, n, i, s, l, o, d, m, b) {
  Lu(e, b++, t), ++i[256];
  for (var T = qb(i, 15), M = T.t, E = T.l, D = qb(s, 15), U = D.t, q = D.l, G = hS(M), Y = G.c, he = G.n, X = hS(U), J = X.c, ie = X.n, ye = new Qa(19), oe = 0; oe < Y.length; ++oe) ++ye[Y[oe] & 31];
  for (var oe = 0; oe < J.length; ++oe) ++ye[J[oe] & 31];
  for (var Re = qb(ye, 7), Ne = Re.t, me = Re.l, _e = 19; _e > 4 && !Ne[bv[_e - 1]]; --_e) ;
  var Fe = m + 5 << 3, Me = Up(i, Nh) + Up(s, wg) + l, Ct = Up(i, M) + Up(s, U) + l + 14 + 3 * _e + Up(ye, Ne) + 2 * ye[16] + 3 * ye[17] + 7 * ye[18];
  if (d >= 0 && Fe <= Me && Fe <= Ct) return iM(e, b, r.subarray(d, d + m));
  var ht, Pt, bt, kt;
  if (Lu(e, b, 1 + (Ct < Me)), b += 2, Ct < Me) {
    ht = cu(M, E, 0), Pt = M, bt = cu(U, q, 0), kt = U;
    var Nt = cu(Ne, me, 0);
    Lu(e, b, he - 257), Lu(e, b + 5, ie - 1), Lu(e, b + 10, _e - 4), b += 14;
    for (var oe = 0; oe < _e; ++oe) Lu(e, b + 3 * oe, Ne[bv[oe]]);
    b += 3 * _e;
    for (var mr = [Y, J], ce = 0; ce < 2; ++ce) for (var Be = mr[ce], oe = 0; oe < Be.length; ++oe) {
      var Ue = Be[oe] & 31;
      Lu(e, b, Nt[Ue]), b += Ne[Ue], Ue > 15 && (Lu(e, b, Be[oe] >> 5 & 127), b += Be[oe] >> 12);
    }
  } else ht = tX, Pt = Nh, bt = nX, kt = wg;
  for (var oe = 0; oe < o; ++oe) {
    var Xe = n[oe];
    if (Xe > 255) {
      var Ue = Xe >> 18 & 31;
      Fp(e, b, ht[Ue + 257]), b += Pt[Ue + 257], Ue > 7 && (Lu(e, b, Xe >> 23 & 31), b += Ry[Ue]);
      var it = Xe & 31;
      Fp(e, b, bt[it]), b += kt[it], it > 3 && (Fp(e, b, Xe >> 5 & 8191), b += By[it]);
    } else Fp(e, b, ht[Xe]), b += Pt[Xe];
  }
  return Fp(e, b, ht[256]), b + Pt[256];
}, aX = /* @__PURE__ */ new ex([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), sM = /* @__PURE__ */ new Go(0), lX = function(r, e, t, n, i, s) {
  var l = s.z || r.length, o = new Go(n + l + 5 * (1 + Math.ceil(l / 7e3)) + i), d = o.subarray(n, o.length - i), m = s.l, b = (s.r || 0) & 7;
  if (e) {
    b && (d[0] = s.r >> 3);
    for (var T = aX[e - 1], M = T >> 13, E = T & 8191, D = (1 << t) - 1, U = s.p || new Qa(32768), q = s.h || new Qa(D + 1), G = Math.ceil(t / 3), Y = 2 * G, he = function(Cr) {
      return (r[Cr] ^ r[Cr + 1] << G ^ r[Cr + 2] << Y) & D;
    }, X = new ex(25e3), J = new Qa(288), ie = new Qa(32), ye = 0, oe = 0, Re = s.i || 0, Ne = 0, me = s.w || 0, _e = 0; Re + 2 < l; ++Re) {
      var Fe = he(Re), Me = Re & 32767, Ct = q[Fe];
      if (U[Me] = Ct, q[Fe] = Me, me <= Re) {
        var ht = l - Re;
        if ((ye > 7e3 || Ne > 24576) && (ht > 423 || !m)) {
          b = fS(r, d, 0, X, J, ie, oe, Ne, _e, Re - _e, b), Ne = ye = oe = 0, _e = Re;
          for (var Pt = 0; Pt < 286; ++Pt) J[Pt] = 0;
          for (var Pt = 0; Pt < 30; ++Pt) ie[Pt] = 0;
        }
        var bt = 2, kt = 0, Nt = E, mr = Me - Ct & 32767;
        if (ht > 2 && Fe == he(Re - mr)) for (var ce = Math.min(M, ht) - 1, Be = Math.min(32767, Re), Ue = Math.min(258, ht); mr <= Be && --Nt && Me != Ct; ) {
          if (r[Re + bt] == r[Re + bt - mr]) {
            for (var Xe = 0; Xe < Ue && r[Re + Xe] == r[Re + Xe - mr]; ++Xe) ;
            if (Xe > bt) {
              if (bt = Xe, kt = mr, Xe > ce) break;
              for (var it = Math.min(mr, Xe - 2), ft = 0, Pt = 0; Pt < it; ++Pt) {
                var St = Re - mr + Pt & 32767, wt = U[St], ar = St - wt & 32767;
                ar > ft && (ft = ar, Ct = St);
              }
            }
          }
          Me = Ct, Ct = U[Me], mr += Me - Ct & 32767;
        }
        if (kt) {
          X[Ne++] = 268435456 | vv[bt] << 18 | uS[kt];
          var Yt = vv[bt] & 31, cr = uS[kt] & 31;
          oe += Ry[Yt] + By[cr], ++J[257 + Yt], ++ie[cr], me = Re + bt, ++ye;
        } else X[Ne++] = r[Re], ++J[r[Re]];
      }
    }
    for (Re = Math.max(Re, me); Re < l; ++Re) X[Ne++] = r[Re], ++J[r[Re]];
    b = fS(r, d, m, X, J, ie, oe, Ne, _e, Re - _e, b), m || (s.r = b & 7 | d[b / 8 | 0] << 3, b -= 7, s.h = q, s.p = U, s.i = Re, s.w = me);
  } else {
    for (var Re = s.w || 0; Re < l + m; Re += 65535) {
      var _r = Re + 65535;
      _r >= l && (d[b / 8 | 0] = m, _r = l), b = iM(d, b + 1, r.subarray(Re, _r));
    }
    s.i = l;
  }
  return nM(o, 0, n + tx(b) + i);
}, oM = function() {
  var r = 1, e = 0;
  return { p: function(t) {
    for (var n = r, i = e, s = t.length | 0, l = 0; l != s; ) {
      for (var o = Math.min(l + 2655, s); l < o; ++l) i += n += t[l];
      n = (n & 65535) + 15 * (n >> 16), i = (i & 65535) + 15 * (i >> 16);
    }
    r = n, e = i;
  }, d: function() {
    return r %= 65521, e %= 65521, (r & 255) << 24 | (r & 65280) << 8 | (e & 255) << 8 | e >> 8;
  } };
}, cX = function(r, e, t, n, i) {
  if (!i && (i = { l: 1 }, e.dictionary)) {
    var s = e.dictionary.subarray(-32768), l = new Go(s.length + r.length);
    l.set(s), l.set(r, s.length), r = l, i.w = s.length;
  }
  return lX(r, e.level == null ? 6 : e.level, e.mem == null ? i.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(r.length))) * 1.5) : 20 : 12 + e.mem, t, n, i);
}, aM = function(r, e, t) {
  for (; t; ++e) r[e] = t, t >>>= 8;
}, uX = function(r, e) {
  var t = e.level, n = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
  if (r[0] = 120, r[1] = n << 6 | (e.dictionary && 32), r[1] |= 31 - (r[0] << 8 | r[1]) % 31, e.dictionary) {
    var i = oM();
    i.p(e.dictionary), aM(r, 2, i.d());
  }
}, hX = function(r, e) {
  return ((r[0] & 15) != 8 || r[0] >> 4 > 7 || (r[0] << 8 | r[1]) % 31) && mc(6, "invalid zlib data"), (r[1] >> 5 & 1) == 1 && mc(6, "invalid zlib data: " + (r[1] & 32 ? "need" : "unexpected") + " dictionary"), (r[1] >> 3 & 4) + 2;
};
function Av(r, e) {
  e || (e = {});
  var t = oM();
  t.p(r);
  var n = cX(r, e, e.dictionary ? 6 : 2, 4);
  return uX(n, e), aM(n, n.length - 4, t.d()), n;
}
function fX(r, e) {
  return oX(r.subarray(hX(r), -4), { i: 2 }, e, e);
}
var dX = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), pX = 0;
try {
  dX.decode(sM, { stream: !0 }), pX = 1;
} catch {
}
/** @license
*
* jsPDF - PDF Document creation from JavaScript
* Version 2.5.2 Built on 2024-09-17T13:29:57.859Z
*                      CommitID 00000000
*
* Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
*               2015-2021 yWorks GmbH, http://www.yworks.com
*               2015-2021 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
*               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
*               2010 Aaron Spike, https://github.com/acspike
*               2012 Willow Systems Corporation, https://github.com/willowsystems
*               2012 Pablo Hess, https://github.com/pablohess
*               2012 Florian Jenett, https://github.com/fjenett
*               2013 Warren Weckesser, https://github.com/warrenweckesser
*               2013 Youssef Beddad, https://github.com/lifof
*               2013 Lee Driscoll, https://github.com/lsdriscoll
*               2013 Stefan Slonevskiy, https://github.com/stefslon
*               2013 Jeremy Morel, https://github.com/jmorel
*               2013 Christoph Hartmann, https://github.com/chris-rock
*               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
*               2014 James Makes, https://github.com/dollaruw
*               2014 Diego Casorran, https://github.com/diegocr
*               2014 Steven Spungin, https://github.com/Flamenco
*               2014 Kenneth Glassey, https://github.com/Gavvers
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
* Contributor(s):
*    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
*    kim3er, mfo, alnorth, Flamenco
*/
var Qr = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function Gb() {
  Qr.console && typeof Qr.console.log == "function" && Qr.console.log.apply(Qr.console, arguments);
}
var vi = { log: Gb, warn: function(r) {
  Qr.console && (typeof Qr.console.warn == "function" ? Qr.console.warn.apply(Qr.console, arguments) : Gb.call(null, arguments));
}, error: function(r) {
  Qr.console && (typeof Qr.console.error == "function" ? Qr.console.error.apply(Qr.console, arguments) : Gb(r));
} };
function $b(r, e, t) {
  var n = new XMLHttpRequest();
  n.open("GET", r), n.responseType = "blob", n.onload = function() {
    nf(n.response, e, t);
  }, n.onerror = function() {
    vi.error("could not download file");
  }, n.send();
}
function dS(r) {
  var e = new XMLHttpRequest();
  e.open("HEAD", r, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function Dm(r) {
  try {
    r.dispatchEvent(new MouseEvent("click"));
  } catch {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), r.dispatchEvent(e);
  }
}
var lg, Tv, nf = Qr.saveAs || ((typeof window > "u" ? "undefined" : ii(window)) !== "object" || window !== Qr ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(r, e, t) {
  var n = Qr.URL || Qr.webkitURL, i = document.createElement("a");
  e = e || r.name || "download", i.download = e, i.rel = "noopener", typeof r == "string" ? (i.href = r, i.origin !== location.origin ? dS(i.href) ? $b(r, e, t) : Dm(i, i.target = "_blank") : Dm(i)) : (i.href = n.createObjectURL(r), setTimeout(function() {
    n.revokeObjectURL(i.href);
  }, 4e4), setTimeout(function() {
    Dm(i);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(r, e, t) {
  if (e = e || r.name || "download", typeof r == "string")
    if (dS(r)) $b(r, e, t);
    else {
      var n = document.createElement("a");
      n.href = r, n.target = "_blank", setTimeout(function() {
        Dm(n);
      });
    }
  else navigator.msSaveOrOpenBlob(function(i, s) {
    return s === void 0 ? s = { autoBom: !1 } : ii(s) !== "object" && (vi.warn("Deprecated: Expected third argument to be a object"), s = { autoBom: !s }), s.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(i.type) ? new Blob(["\uFEFF", i], { type: i.type }) : i;
  }(r, t), e);
} : function(r, e, t, n) {
  if ((n = n || open("", "_blank")) && (n.document.title = n.document.body.innerText = "downloading..."), typeof r == "string") return $b(r, e, t);
  var i = r.type === "application/octet-stream", s = /constructor/i.test(Qr.HTMLElement) || Qr.safari, l = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((l || i && s) && (typeof FileReader > "u" ? "undefined" : ii(FileReader)) === "object") {
    var o = new FileReader();
    o.onloadend = function() {
      var b = o.result;
      b = l ? b : b.replace(/^data:[^;]*;/, "data:attachment/file;"), n ? n.location.href = b : location = b, n = null;
    }, o.readAsDataURL(r);
  } else {
    var d = Qr.URL || Qr.webkitURL, m = d.createObjectURL(r);
    n ? n.location = m : location.href = m, n = null, setTimeout(function() {
      d.revokeObjectURL(m);
    }, 4e4);
  }
});
/**
* A class to parse color values
* @author Stoyan Stefanov <sstoo@gmail.com>
* {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
* @license Use it if you like it
*/
function lM(r) {
  var e;
  r = r || "", this.ok = !1, r.charAt(0) == "#" && (r = r.substr(1, 6)), r = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[r = (r = r.replace(/ /g, "")).toLowerCase()] || r;
  for (var t = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(o) {
    return [parseInt(o[1]), parseInt(o[2]), parseInt(o[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(o) {
    return [parseInt(o[1], 16), parseInt(o[2], 16), parseInt(o[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(o) {
    return [parseInt(o[1] + o[1], 16), parseInt(o[2] + o[2], 16), parseInt(o[3] + o[3], 16)];
  } }], n = 0; n < t.length; n++) {
    var i = t[n].re, s = t[n].process, l = i.exec(r);
    l && (e = s(l), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var o = this.r.toString(16), d = this.g.toString(16), m = this.b.toString(16);
    return o.length == 1 && (o = "0" + o), d.length == 1 && (d = "0" + d), m.length == 1 && (m = "0" + m), "#" + o + d + m;
  };
}
/**
* @license
* Joseph Myers does not specify a particular license for his work.
*
* Author: Joseph Myers
* Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
*
* Modified by: Owen Leong
*/
function Hb(r, e) {
  var t = r[0], n = r[1], i = r[2], s = r[3];
  t = Do(t, n, i, s, e[0], 7, -680876936), s = Do(s, t, n, i, e[1], 12, -389564586), i = Do(i, s, t, n, e[2], 17, 606105819), n = Do(n, i, s, t, e[3], 22, -1044525330), t = Do(t, n, i, s, e[4], 7, -176418897), s = Do(s, t, n, i, e[5], 12, 1200080426), i = Do(i, s, t, n, e[6], 17, -1473231341), n = Do(n, i, s, t, e[7], 22, -45705983), t = Do(t, n, i, s, e[8], 7, 1770035416), s = Do(s, t, n, i, e[9], 12, -1958414417), i = Do(i, s, t, n, e[10], 17, -42063), n = Do(n, i, s, t, e[11], 22, -1990404162), t = Do(t, n, i, s, e[12], 7, 1804603682), s = Do(s, t, n, i, e[13], 12, -40341101), i = Do(i, s, t, n, e[14], 17, -1502002290), t = ko(t, n = Do(n, i, s, t, e[15], 22, 1236535329), i, s, e[1], 5, -165796510), s = ko(s, t, n, i, e[6], 9, -1069501632), i = ko(i, s, t, n, e[11], 14, 643717713), n = ko(n, i, s, t, e[0], 20, -373897302), t = ko(t, n, i, s, e[5], 5, -701558691), s = ko(s, t, n, i, e[10], 9, 38016083), i = ko(i, s, t, n, e[15], 14, -660478335), n = ko(n, i, s, t, e[4], 20, -405537848), t = ko(t, n, i, s, e[9], 5, 568446438), s = ko(s, t, n, i, e[14], 9, -1019803690), i = ko(i, s, t, n, e[3], 14, -187363961), n = ko(n, i, s, t, e[8], 20, 1163531501), t = ko(t, n, i, s, e[13], 5, -1444681467), s = ko(s, t, n, i, e[2], 9, -51403784), i = ko(i, s, t, n, e[7], 14, 1735328473), t = Fo(t, n = ko(n, i, s, t, e[12], 20, -1926607734), i, s, e[5], 4, -378558), s = Fo(s, t, n, i, e[8], 11, -2022574463), i = Fo(i, s, t, n, e[11], 16, 1839030562), n = Fo(n, i, s, t, e[14], 23, -35309556), t = Fo(t, n, i, s, e[1], 4, -1530992060), s = Fo(s, t, n, i, e[4], 11, 1272893353), i = Fo(i, s, t, n, e[7], 16, -155497632), n = Fo(n, i, s, t, e[10], 23, -1094730640), t = Fo(t, n, i, s, e[13], 4, 681279174), s = Fo(s, t, n, i, e[0], 11, -358537222), i = Fo(i, s, t, n, e[3], 16, -722521979), n = Fo(n, i, s, t, e[6], 23, 76029189), t = Fo(t, n, i, s, e[9], 4, -640364487), s = Fo(s, t, n, i, e[12], 11, -421815835), i = Fo(i, s, t, n, e[15], 16, 530742520), t = Uo(t, n = Fo(n, i, s, t, e[2], 23, -995338651), i, s, e[0], 6, -198630844), s = Uo(s, t, n, i, e[7], 10, 1126891415), i = Uo(i, s, t, n, e[14], 15, -1416354905), n = Uo(n, i, s, t, e[5], 21, -57434055), t = Uo(t, n, i, s, e[12], 6, 1700485571), s = Uo(s, t, n, i, e[3], 10, -1894986606), i = Uo(i, s, t, n, e[10], 15, -1051523), n = Uo(n, i, s, t, e[1], 21, -2054922799), t = Uo(t, n, i, s, e[8], 6, 1873313359), s = Uo(s, t, n, i, e[15], 10, -30611744), i = Uo(i, s, t, n, e[6], 15, -1560198380), n = Uo(n, i, s, t, e[13], 21, 1309151649), t = Uo(t, n, i, s, e[4], 6, -145523070), s = Uo(s, t, n, i, e[11], 10, -1120210379), i = Uo(i, s, t, n, e[2], 15, 718787259), n = Uo(n, i, s, t, e[9], 21, -343485551), r[0] = Sh(t, r[0]), r[1] = Sh(n, r[1]), r[2] = Sh(i, r[2]), r[3] = Sh(s, r[3]);
}
function Ly(r, e, t, n, i, s) {
  return e = Sh(Sh(e, r), Sh(n, s)), Sh(e << i | e >>> 32 - i, t);
}
function Do(r, e, t, n, i, s, l) {
  return Ly(e & t | ~e & n, r, e, i, s, l);
}
function ko(r, e, t, n, i, s, l) {
  return Ly(e & n | t & ~n, r, e, i, s, l);
}
function Fo(r, e, t, n, i, s, l) {
  return Ly(e ^ t ^ n, r, e, i, s, l);
}
function Uo(r, e, t, n, i, s, l) {
  return Ly(t ^ (e | ~n), r, e, i, s, l);
}
function cM(r) {
  var e, t = r.length, n = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= r.length; e += 64) Hb(n, gX(r.substring(e - 64, e)));
  r = r.substring(e - 64);
  var i = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < r.length; e++) i[e >> 2] |= r.charCodeAt(e) << (e % 4 << 3);
  if (i[e >> 2] |= 128 << (e % 4 << 3), e > 55) for (Hb(n, i), e = 0; e < 16; e++) i[e] = 0;
  return i[14] = 8 * t, Hb(n, i), n;
}
function gX(r) {
  var e, t = [];
  for (e = 0; e < 64; e += 4) t[e >> 2] = r.charCodeAt(e) + (r.charCodeAt(e + 1) << 8) + (r.charCodeAt(e + 2) << 16) + (r.charCodeAt(e + 3) << 24);
  return t;
}
lg = Qr.atob.bind(Qr), Tv = Qr.btoa.bind(Qr);
var pS = "0123456789abcdef".split("");
function mX(r) {
  for (var e = "", t = 0; t < 4; t++) e += pS[r >> 8 * t + 4 & 15] + pS[r >> 8 * t & 15];
  return e;
}
function _X(r) {
  return String.fromCharCode((255 & r) >> 0, (65280 & r) >> 8, (16711680 & r) >> 16, (4278190080 & r) >> 24);
}
function Sv(r) {
  return cM(r).map(_X).join("");
}
var yX = function(r) {
  for (var e = 0; e < r.length; e++) r[e] = mX(r[e]);
  return r.join("");
}(cM("hello")) != "5d41402abc4b2a76b9719d911017c592";
function Sh(r, e) {
  if (yX) {
    var t = (65535 & r) + (65535 & e);
    return (r >> 16) + (e >> 16) + (t >> 16) << 16 | 65535 & t;
  }
  return r + e & 4294967295;
}
/**
* @license
* FPDF is released under a permissive license: there is no usage restriction.
* You may embed it freely in your application (commercial or not), with or
* without modifications.
*
* Reference: http://www.fpdf.org/en/script/script37.php
*/
function Ev(r, e) {
  var t, n, i, s;
  if (r !== t) {
    for (var l = (i = r, s = 1 + (256 / r.length >> 0), new Array(s + 1).join(i)), o = [], d = 0; d < 256; d++) o[d] = d;
    var m = 0;
    for (d = 0; d < 256; d++) {
      var b = o[d];
      m = (m + b + l.charCodeAt(d)) % 256, o[d] = o[m], o[m] = b;
    }
    t = r, n = o;
  } else o = n;
  var T = e.length, M = 0, E = 0, D = "";
  for (d = 0; d < T; d++) E = (E + (b = o[M = (M + 1) % 256])) % 256, o[M] = o[E], o[E] = b, l = o[(o[M] + o[E]) % 256], D += String.fromCharCode(e.charCodeAt(d) ^ l);
  return D;
}
/**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
* Author: Owen Leong (@owenl131)
* Date: 15 Oct 2020
* References:
* https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
* https://github.com/foliojs/pdfkit/blob/master/lib/security.js
* http://www.fpdf.org/en/script/script37.php
*/
var gS = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function pd(r, e, t, n) {
  this.v = 1, this.r = 2;
  var i = 192;
  r.forEach(function(o) {
    if (gS.perm !== void 0) throw new Error("Invalid permission: " + o);
    i += gS[o];
  }), this.padding = "(N^NuAd\0NV\b..\0h>/\fdSiz";
  var s = (e + this.padding).substr(0, 32), l = (t + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(s, l), this.P = -(1 + (255 ^ i)), this.encryptionKey = Sv(s + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(n)).substr(0, 5), this.U = Ev(this.encryptionKey, this.padding);
}
function gd(r) {
  if (/[^\u0000-\u00ff]/.test(r)) throw new Error("Invalid PDF Name Object: " + r + ", Only accept ASCII characters.");
  for (var e = "", t = r.length, n = 0; n < t; n++) {
    var i = r.charCodeAt(n);
    i < 33 || i === 35 || i === 37 || i === 40 || i === 41 || i === 47 || i === 60 || i === 62 || i === 91 || i === 93 || i === 123 || i === 125 || i > 126 ? e += "#" + ("0" + i.toString(16)).slice(-2) : e += r[n];
  }
  return e;
}
function mS(r) {
  if (ii(r) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var e = {};
  this.subscribe = function(t, n, i) {
    if (i = i || !1, typeof t != "string" || typeof n != "function" || typeof i != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    e.hasOwnProperty(t) || (e[t] = {});
    var s = Math.random().toString(35);
    return e[t][s] = [n, !!i], s;
  }, this.unsubscribe = function(t) {
    for (var n in e) if (e[n][t]) return delete e[n][t], Object.keys(e[n]).length === 0 && delete e[n], !0;
    return !1;
  }, this.publish = function(t) {
    if (e.hasOwnProperty(t)) {
      var n = Array.prototype.slice.call(arguments, 1), i = [];
      for (var s in e[t]) {
        var l = e[t][s];
        try {
          l[0].apply(r, n);
        } catch (o) {
          Qr.console && vi.error("jsPDF PubSub Error", o.message, o);
        }
        l[1] && i.push(s);
      }
      i.length && i.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return e;
  };
}
function Z_(r) {
  if (!(this instanceof Z_)) return new Z_(r);
  var e = "opacity,stroke-opacity".split(",");
  for (var t in r) r.hasOwnProperty(t) && e.indexOf(t) >= 0 && (this[t] = r[t]);
  this.id = "", this.objectNumber = -1;
}
function uM(r, e) {
  this.gState = r, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function af(r, e, t, n, i) {
  if (!(this instanceof af)) return new af(r, e, t, n, i);
  this.type = r === "axial" ? 2 : 3, this.coords = e, this.colors = t, uM.call(this, n, i);
}
function Td(r, e, t, n, i) {
  if (!(this instanceof Td)) return new Td(r, e, t, n, i);
  this.boundingBox = r, this.xStep = e, this.yStep = t, this.stream = "", this.cloneIndex = 0, uM.call(this, n, i);
}
function Jr(r) {
  var e, t = typeof arguments[0] == "string" ? arguments[0] : "p", n = arguments[1], i = arguments[2], s = arguments[3], l = [], o = 1, d = 16, m = "S", b = null;
  ii(r = r || {}) === "object" && (t = r.orientation, n = r.unit || n, i = r.format || i, s = r.compress || r.compressPdf || s, (b = r.encryption || null) !== null && (b.userPassword = b.userPassword || "", b.ownerPassword = b.ownerPassword || "", b.userPermissions = b.userPermissions || []), o = typeof r.userUnit == "number" ? Math.abs(r.userUnit) : 1, r.precision !== void 0 && (e = r.precision), r.floatPrecision !== void 0 && (d = r.floatPrecision), m = r.defaultPathOperation || "S"), l = r.filters || (s === !0 ? ["FlateEncode"] : l), n = n || "mm", t = ("" + (t || "P")).toLowerCase();
  var T = r.putOnlyUsedFonts || !1, M = {}, E = { internal: {}, __private__: {} };
  E.__private__.PubSub = mS;
  var D = "1.3", U = E.__private__.getPdfVersion = function() {
    return D;
  };
  E.__private__.setPdfVersion = function(O) {
    D = O;
  };
  var q = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  E.__private__.getPageFormats = function() {
    return q;
  };
  var G = E.__private__.getPageFormat = function(O) {
    return q[O];
  };
  i = i || "a4";
  var Y = { COMPAT: "compat", ADVANCED: "advanced" }, he = Y.COMPAT;
  function X() {
    this.saveGraphicsState(), Ve(new Kt(Ar, 0, 0, -Ar, 0, So() * Ar).toString() + " cm"), this.setFontSize(this.getFontSize() / Ar), m = "n", he = Y.ADVANCED;
  }
  function J() {
    this.restoreGraphicsState(), m = "S", he = Y.COMPAT;
  }
  var ie = E.__private__.combineFontStyleAndFontWeight = function(O, ne) {
    if (O == "bold" && ne == "normal" || O == "bold" && ne == 400 || O == "normal" && ne == "italic" || O == "bold" && ne == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return ne && (O = ne == 400 || ne === "normal" ? O === "italic" ? "italic" : "normal" : ne != 700 && ne !== "bold" || O !== "normal" ? (ne == 700 ? "bold" : ne) + "" + O : "bold"), O;
  };
  E.advancedAPI = function(O) {
    var ne = he === Y.COMPAT;
    return ne && X.call(this), typeof O != "function" || (O(this), ne && J.call(this)), this;
  }, E.compatAPI = function(O) {
    var ne = he === Y.ADVANCED;
    return ne && J.call(this), typeof O != "function" || (O(this), ne && X.call(this)), this;
  }, E.isAdvancedAPI = function() {
    return he === Y.ADVANCED;
  };
  var ye, oe = function(O) {
    if (he !== Y.ADVANCED) throw new Error(O + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, Re = E.roundToPrecision = E.__private__.roundToPrecision = function(O, ne) {
    var De = e || ne;
    if (isNaN(O) || isNaN(De)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return O.toFixed(De).replace(/0+$/, "");
  };
  ye = E.hpf = E.__private__.hpf = typeof d == "number" ? function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Re(O, d);
  } : d === "smart" ? function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Re(O, O > -1 && O < 1 ? 16 : 5);
  } : function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Re(O, 16);
  };
  var Ne = E.f2 = E.__private__.f2 = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.f2");
    return Re(O, 2);
  }, me = E.__private__.f3 = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.f3");
    return Re(O, 3);
  }, _e = E.scale = E.__private__.scale = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.scale");
    return he === Y.COMPAT ? O * Ar : he === Y.ADVANCED ? O : void 0;
  }, Fe = function(O) {
    return he === Y.COMPAT ? So() - O : he === Y.ADVANCED ? O : void 0;
  }, Me = function(O) {
    return _e(Fe(O));
  };
  E.__private__.setPrecision = E.setPrecision = function(O) {
    typeof parseInt(O, 10) == "number" && (e = parseInt(O, 10));
  };
  var Ct, ht = "00000000000000000000000000000000", Pt = E.__private__.getFileId = function() {
    return ht;
  }, bt = E.__private__.setFileId = function(O) {
    return ht = O !== void 0 && /^[a-fA-F0-9]{32}$/.test(O) ? O.toUpperCase() : ht.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), b !== null && (an = new pd(b.userPermissions, b.userPassword, b.ownerPassword, ht)), ht;
  };
  E.setFileId = function(O) {
    return bt(O), this;
  }, E.getFileId = function() {
    return Pt();
  };
  var kt = E.__private__.convertDateToPDFDate = function(O) {
    var ne = O.getTimezoneOffset(), De = ne < 0 ? "+" : "-", Ke = Math.floor(Math.abs(ne / 60)), mt = Math.abs(ne % 60), zt = [De, Ue(Ke), "'", Ue(mt), "'"].join("");
    return ["D:", O.getFullYear(), Ue(O.getMonth() + 1), Ue(O.getDate()), Ue(O.getHours()), Ue(O.getMinutes()), Ue(O.getSeconds()), zt].join("");
  }, Nt = E.__private__.convertPDFDateToDate = function(O) {
    var ne = parseInt(O.substr(2, 4), 10), De = parseInt(O.substr(6, 2), 10) - 1, Ke = parseInt(O.substr(8, 2), 10), mt = parseInt(O.substr(10, 2), 10), zt = parseInt(O.substr(12, 2), 10), tr = parseInt(O.substr(14, 2), 10);
    return new Date(ne, De, Ke, mt, zt, tr, 0);
  }, mr = E.__private__.setCreationDate = function(O) {
    var ne;
    if (O === void 0 && (O = /* @__PURE__ */ new Date()), O instanceof Date) ne = kt(O);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(O)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      ne = O;
    }
    return Ct = ne;
  }, ce = E.__private__.getCreationDate = function(O) {
    var ne = Ct;
    return O === "jsDate" && (ne = Nt(Ct)), ne;
  };
  E.setCreationDate = function(O) {
    return mr(O), this;
  }, E.getCreationDate = function(O) {
    return ce(O);
  };
  var Be, Ue = E.__private__.padd2 = function(O) {
    return ("0" + parseInt(O)).slice(-2);
  }, Xe = E.__private__.padd2Hex = function(O) {
    return ("00" + (O = O.toString())).substr(O.length);
  }, it = 0, ft = [], St = [], wt = 0, ar = [], Yt = [], cr = !1, _r = St, Cr = function() {
    it = 0, wt = 0, St = [], ft = [], ar = [], gr = Lr(), Sn = Lr();
  };
  E.__private__.setCustomOutputDestination = function(O) {
    cr = !0, _r = O;
  };
  var Ut = function(O) {
    cr || (_r = O);
  };
  E.__private__.resetCustomOutputDestination = function() {
    cr = !1, _r = St;
  };
  var Ve = E.__private__.out = function(O) {
    return O = O.toString(), wt += O.length + 1, _r.push(O), _r;
  }, jr = E.__private__.write = function(O) {
    return Ve(arguments.length === 1 ? O.toString() : Array.prototype.join.call(arguments, " "));
  }, Ir = E.__private__.getArrayBuffer = function(O) {
    for (var ne = O.length, De = new ArrayBuffer(ne), Ke = new Uint8Array(De); ne--; ) Ke[ne] = O.charCodeAt(ne);
    return De;
  }, rr = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  E.__private__.getStandardFonts = function() {
    return rr;
  };
  var hr = r.fontSize || 16;
  E.__private__.setFontSize = E.setFontSize = function(O) {
    return hr = he === Y.ADVANCED ? O / Ar : O, this;
  };
  var wr, br = E.__private__.getFontSize = E.getFontSize = function() {
    return he === Y.COMPAT ? hr : hr * Ar;
  }, Rr = r.R2L || !1;
  E.__private__.setR2L = E.setR2L = function(O) {
    return Rr = O, this;
  }, E.__private__.getR2L = E.getR2L = function() {
    return Rr;
  };
  var $r, Wr = E.__private__.setZoomMode = function(O) {
    var ne = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(O)) wr = O;
    else if (isNaN(O)) {
      if (ne.indexOf(O) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + O + '" is not recognized.');
      wr = O;
    } else wr = parseInt(O, 10);
  };
  E.__private__.getZoomMode = function() {
    return wr;
  };
  var Zr, hn = E.__private__.setPageMode = function(O) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(O) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + O + '" is not recognized.');
    $r = O;
  };
  E.__private__.getPageMode = function() {
    return $r;
  };
  var yn = E.__private__.setLayoutMode = function(O) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(O) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + O + '" is not recognized.');
    Zr = O;
  };
  E.__private__.getLayoutMode = function() {
    return Zr;
  }, E.__private__.setDisplayMode = E.setDisplayMode = function(O, ne, De) {
    return Wr(O), yn(ne), hn(De), this;
  };
  var Vr = { title: "", subject: "", author: "", keywords: "", creator: "" };
  E.__private__.getDocumentProperty = function(O) {
    if (Object.keys(Vr).indexOf(O) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return Vr[O];
  }, E.__private__.getDocumentProperties = function() {
    return Vr;
  }, E.__private__.setDocumentProperties = E.setProperties = E.setDocumentProperties = function(O) {
    for (var ne in Vr) Vr.hasOwnProperty(ne) && O[ne] && (Vr[ne] = O[ne]);
    return this;
  }, E.__private__.setDocumentProperty = function(O, ne) {
    if (Object.keys(Vr).indexOf(O) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return Vr[O] = ne;
  };
  var en, Ar, Ii, bn, Xi, ve = {}, se = {}, de = [], pe = {}, Oe = {}, Ge = {}, rt = {}, gt = null, Ye = 0, lt = [], pt = new mS(E), ct = r.hotfixes || [], We = {}, or = {}, Jt = [], Kt = function O(ne, De, Ke, mt, zt, tr) {
    if (!(this instanceof O)) return new O(ne, De, Ke, mt, zt, tr);
    isNaN(ne) && (ne = 1), isNaN(De) && (De = 0), isNaN(Ke) && (Ke = 0), isNaN(mt) && (mt = 1), isNaN(zt) && (zt = 0), isNaN(tr) && (tr = 0), this._matrix = [ne, De, Ke, mt, zt, tr];
  };
  Object.defineProperty(Kt.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(O) {
    this._matrix[0] = O;
  } }), Object.defineProperty(Kt.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(O) {
    this._matrix[1] = O;
  } }), Object.defineProperty(Kt.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(O) {
    this._matrix[2] = O;
  } }), Object.defineProperty(Kt.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(O) {
    this._matrix[3] = O;
  } }), Object.defineProperty(Kt.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(O) {
    this._matrix[4] = O;
  } }), Object.defineProperty(Kt.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(O) {
    this._matrix[5] = O;
  } }), Object.defineProperty(Kt.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(O) {
    this._matrix[0] = O;
  } }), Object.defineProperty(Kt.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(O) {
    this._matrix[1] = O;
  } }), Object.defineProperty(Kt.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(O) {
    this._matrix[2] = O;
  } }), Object.defineProperty(Kt.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(O) {
    this._matrix[3] = O;
  } }), Object.defineProperty(Kt.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(O) {
    this._matrix[4] = O;
  } }), Object.defineProperty(Kt.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(O) {
    this._matrix[5] = O;
  } }), Object.defineProperty(Kt.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Kt.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Kt.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Kt.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), Kt.prototype.join = function(O) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(ye).join(O);
  }, Kt.prototype.multiply = function(O) {
    var ne = O.sx * this.sx + O.shy * this.shx, De = O.sx * this.shy + O.shy * this.sy, Ke = O.shx * this.sx + O.sy * this.shx, mt = O.shx * this.shy + O.sy * this.sy, zt = O.tx * this.sx + O.ty * this.shx + this.tx, tr = O.tx * this.shy + O.ty * this.sy + this.ty;
    return new Kt(ne, De, Ke, mt, zt, tr);
  }, Kt.prototype.decompose = function() {
    var O = this.sx, ne = this.shy, De = this.shx, Ke = this.sy, mt = this.tx, zt = this.ty, tr = Math.sqrt(O * O + ne * ne), Tr = (O /= tr) * De + (ne /= tr) * Ke;
    De -= O * Tr, Ke -= ne * Tr;
    var kr = Math.sqrt(De * De + Ke * Ke);
    return Tr /= kr, O * (Ke /= kr) < ne * (De /= kr) && (O = -O, ne = -ne, Tr = -Tr, tr = -tr), { scale: new Kt(tr, 0, 0, kr, 0, 0), translate: new Kt(1, 0, 0, 1, mt, zt), rotate: new Kt(O, ne, -ne, O, 0, 0), skew: new Kt(1, 0, Tr, 1, 0, 0) };
  }, Kt.prototype.toString = function(O) {
    return this.join(" ");
  }, Kt.prototype.inversed = function() {
    var O = this.sx, ne = this.shy, De = this.shx, Ke = this.sy, mt = this.tx, zt = this.ty, tr = 1 / (O * Ke - ne * De), Tr = Ke * tr, kr = -ne * tr, tn = -De * tr, Kr = O * tr;
    return new Kt(Tr, kr, tn, Kr, -Tr * mt - tn * zt, -kr * mt - Kr * zt);
  }, Kt.prototype.applyToPoint = function(O) {
    var ne = O.x * this.sx + O.y * this.shx + this.tx, De = O.x * this.shy + O.y * this.sy + this.ty;
    return new To(ne, De);
  }, Kt.prototype.applyToRectangle = function(O) {
    var ne = this.applyToPoint(O), De = this.applyToPoint(new To(O.x + O.w, O.y + O.h));
    return new ds(ne.x, ne.y, De.x - ne.x, De.y - ne.y);
  }, Kt.prototype.clone = function() {
    var O = this.sx, ne = this.shy, De = this.shx, Ke = this.sy, mt = this.tx, zt = this.ty;
    return new Kt(O, ne, De, Ke, mt, zt);
  }, E.Matrix = Kt;
  var Mr = E.matrixMult = function(O, ne) {
    return ne.multiply(O);
  }, Bt = new Kt(1, 0, 0, 1, 0, 0);
  E.unitMatrix = E.identityMatrix = Bt;
  var Qt = function(O, ne) {
    if (!Oe[O]) {
      var De = (ne instanceof af ? "Sh" : "P") + (Object.keys(pe).length + 1).toString(10);
      ne.id = De, Oe[O] = De, pe[De] = ne, pt.publish("addPattern", ne);
    }
  };
  E.ShadingPattern = af, E.TilingPattern = Td, E.addShadingPattern = function(O, ne) {
    return oe("addShadingPattern()"), Qt(O, ne), this;
  }, E.beginTilingPattern = function(O) {
    oe("beginTilingPattern()"), Pa(O.boundingBox[0], O.boundingBox[1], O.boundingBox[2] - O.boundingBox[0], O.boundingBox[3] - O.boundingBox[1], O.matrix);
  }, E.endTilingPattern = function(O, ne) {
    oe("endTilingPattern()"), ne.stream = Yt[Be].join(`
`), Qt(O, ne), pt.publish("endTilingPattern", ne), Jt.pop().restore();
  };
  var fr = E.__private__.newObject = function() {
    var O = Lr();
    return Hr(O, !0), O;
  }, Lr = E.__private__.newObjectDeferred = function() {
    return it++, ft[it] = function() {
      return wt;
    }, it;
  }, Hr = function(O, ne) {
    return ne = typeof ne == "boolean" && ne, ft[O] = wt, ne && Ve(O + " 0 obj"), O;
  }, Or = E.__private__.newAdditionalObject = function() {
    var O = { objId: Lr(), content: "" };
    return ar.push(O), O;
  }, gr = Lr(), Sn = Lr(), Zi = E.__private__.decodeColorString = function(O) {
    var ne = O.split(" ");
    if (ne.length !== 2 || ne[1] !== "g" && ne[1] !== "G") ne.length === 5 && (ne[4] === "k" || ne[4] === "K") && (ne = [(1 - ne[0]) * (1 - ne[3]), (1 - ne[1]) * (1 - ne[3]), (1 - ne[2]) * (1 - ne[3]), "r"]);
    else {
      var De = parseFloat(ne[0]);
      ne = [De, De, De, "r"];
    }
    for (var Ke = "#", mt = 0; mt < 3; mt++) Ke += ("0" + Math.floor(255 * parseFloat(ne[mt])).toString(16)).slice(-2);
    return Ke;
  }, Dn = E.__private__.encodeColorString = function(O) {
    var ne;
    typeof O == "string" && (O = { ch1: O });
    var De = O.ch1, Ke = O.ch2, mt = O.ch3, zt = O.ch4, tr = O.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof De == "string" && De.charAt(0) !== "#") {
      var Tr = new lM(De);
      if (Tr.ok) De = Tr.toHex();
      else if (!/^\d*\.?\d*$/.test(De)) throw new Error('Invalid color "' + De + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof De == "string" && /^#[0-9A-Fa-f]{3}$/.test(De) && (De = "#" + De[1] + De[1] + De[2] + De[2] + De[3] + De[3]), typeof De == "string" && /^#[0-9A-Fa-f]{6}$/.test(De)) {
      var kr = parseInt(De.substr(1), 16);
      De = kr >> 16 & 255, Ke = kr >> 8 & 255, mt = 255 & kr;
    }
    if (Ke === void 0 || zt === void 0 && De === Ke && Ke === mt)
      if (typeof De == "string") ne = De + " " + tr[0];
      else switch (O.precision) {
        case 2:
          ne = Ne(De / 255) + " " + tr[0];
          break;
        case 3:
        default:
          ne = me(De / 255) + " " + tr[0];
      }
    else if (zt === void 0 || ii(zt) === "object") {
      if (zt && !isNaN(zt.a) && zt.a === 0) return ne = ["1.", "1.", "1.", tr[1]].join(" ");
      if (typeof De == "string") ne = [De, Ke, mt, tr[1]].join(" ");
      else switch (O.precision) {
        case 2:
          ne = [Ne(De / 255), Ne(Ke / 255), Ne(mt / 255), tr[1]].join(" ");
          break;
        default:
        case 3:
          ne = [me(De / 255), me(Ke / 255), me(mt / 255), tr[1]].join(" ");
      }
    } else if (typeof De == "string") ne = [De, Ke, mt, zt, tr[2]].join(" ");
    else switch (O.precision) {
      case 2:
        ne = [Ne(De), Ne(Ke), Ne(mt), Ne(zt), tr[2]].join(" ");
        break;
      case 3:
      default:
        ne = [me(De), me(Ke), me(mt), me(zt), tr[2]].join(" ");
    }
    return ne;
  }, kn = E.__private__.getFilters = function() {
    return l;
  }, vn = E.__private__.putStream = function(O) {
    var ne = (O = O || {}).data || "", De = O.filters || kn(), Ke = O.alreadyAppliedFilters || [], mt = O.addLength1 || !1, zt = ne.length, tr = O.objectId, Tr = function(gs) {
      return gs;
    };
    if (b !== null && tr === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    b !== null && (Tr = an.encryptor(tr, 0));
    var kr = {};
    De === !0 && (De = ["FlateEncode"]);
    var tn = O.additionalKeyValues || [], Kr = (kr = Jr.API.processDataByFilters !== void 0 ? Jr.API.processDataByFilters(ne, De) : { data: ne, reverseChain: [] }).reverseChain + (Array.isArray(Ke) ? Ke.join(" ") : Ke.toString());
    if (kr.data.length !== 0 && (tn.push({ key: "Length", value: kr.data.length }), mt === !0 && tn.push({ key: "Length1", value: zt })), Kr.length != 0) if (Kr.split("/").length - 1 == 1) tn.push({ key: "Filter", value: Kr });
    else {
      tn.push({ key: "Filter", value: "[" + Kr + "]" });
      for (var xn = 0; xn < tn.length; xn += 1) if (tn[xn].key === "DecodeParms") {
        for (var ti = [], Gn = 0; Gn < kr.reverseChain.split("/").length - 1; Gn += 1) ti.push("null");
        ti.push(tn[xn].value), tn[xn].value = "[" + ti.join(" ") + "]";
      }
    }
    Ve("<<");
    for (var Pi = 0; Pi < tn.length; Pi++) Ve("/" + tn[Pi].key + " " + tn[Pi].value);
    Ve(">>"), kr.data.length !== 0 && (Ve("stream"), Ve(Tr(kr.data)), Ve("endstream"));
  }, Ai = E.__private__.putPage = function(O) {
    var ne = O.number, De = O.data, Ke = O.objId, mt = O.contentsObjId;
    Hr(Ke, !0), Ve("<</Type /Page"), Ve("/Parent " + O.rootDictionaryObjId + " 0 R"), Ve("/Resources " + O.resourceDictionaryObjId + " 0 R"), Ve("/MediaBox [" + parseFloat(ye(O.mediaBox.bottomLeftX)) + " " + parseFloat(ye(O.mediaBox.bottomLeftY)) + " " + ye(O.mediaBox.topRightX) + " " + ye(O.mediaBox.topRightY) + "]"), O.cropBox !== null && Ve("/CropBox [" + ye(O.cropBox.bottomLeftX) + " " + ye(O.cropBox.bottomLeftY) + " " + ye(O.cropBox.topRightX) + " " + ye(O.cropBox.topRightY) + "]"), O.bleedBox !== null && Ve("/BleedBox [" + ye(O.bleedBox.bottomLeftX) + " " + ye(O.bleedBox.bottomLeftY) + " " + ye(O.bleedBox.topRightX) + " " + ye(O.bleedBox.topRightY) + "]"), O.trimBox !== null && Ve("/TrimBox [" + ye(O.trimBox.bottomLeftX) + " " + ye(O.trimBox.bottomLeftY) + " " + ye(O.trimBox.topRightX) + " " + ye(O.trimBox.topRightY) + "]"), O.artBox !== null && Ve("/ArtBox [" + ye(O.artBox.bottomLeftX) + " " + ye(O.artBox.bottomLeftY) + " " + ye(O.artBox.topRightX) + " " + ye(O.artBox.topRightY) + "]"), typeof O.userUnit == "number" && O.userUnit !== 1 && Ve("/UserUnit " + O.userUnit), pt.publish("putPage", { objId: Ke, pageContext: lt[ne], pageNumber: ne, page: De }), Ve("/Contents " + mt + " 0 R"), Ve(">>"), Ve("endobj");
    var zt = De.join(`
`);
    return he === Y.ADVANCED && (zt += `
Q`), Hr(mt, !0), vn({ data: zt, filters: kn(), objectId: mt }), Ve("endobj"), Ke;
  }, In = E.__private__.putPages = function() {
    var O, ne, De = [];
    for (O = 1; O <= Ye; O++) lt[O].objId = Lr(), lt[O].contentsObjId = Lr();
    for (O = 1; O <= Ye; O++) De.push(Ai({ number: O, data: Yt[O], objId: lt[O].objId, contentsObjId: lt[O].contentsObjId, mediaBox: lt[O].mediaBox, cropBox: lt[O].cropBox, bleedBox: lt[O].bleedBox, trimBox: lt[O].trimBox, artBox: lt[O].artBox, userUnit: lt[O].userUnit, rootDictionaryObjId: gr, resourceDictionaryObjId: Sn }));
    Hr(gr, !0), Ve("<</Type /Pages");
    var Ke = "/Kids [";
    for (ne = 0; ne < Ye; ne++) Ke += De[ne] + " 0 R ";
    Ve(Ke + "]"), Ve("/Count " + Ye), Ve(">>"), Ve("endobj"), pt.publish("postPutPages");
  }, aa = function(O) {
    pt.publish("putFont", { font: O, out: Ve, newObject: fr, putStream: vn }), O.isAlreadyPutted !== !0 && (O.objectNumber = fr(), Ve("<<"), Ve("/Type /Font"), Ve("/BaseFont /" + gd(O.postScriptName)), Ve("/Subtype /Type1"), typeof O.encoding == "string" && Ve("/Encoding /" + O.encoding), Ve("/FirstChar 32"), Ve("/LastChar 255"), Ve(">>"), Ve("endobj"));
  }, Wo = function() {
    for (var O in ve) ve.hasOwnProperty(O) && (T === !1 || T === !0 && M.hasOwnProperty(O)) && aa(ve[O]);
  }, tl = function(O) {
    O.objectNumber = fr();
    var ne = [];
    ne.push({ key: "Type", value: "/XObject" }), ne.push({ key: "Subtype", value: "/Form" }), ne.push({ key: "BBox", value: "[" + [ye(O.x), ye(O.y), ye(O.x + O.width), ye(O.y + O.height)].join(" ") + "]" }), ne.push({ key: "Matrix", value: "[" + O.matrix.toString() + "]" });
    var De = O.pages[1].join(`
`);
    vn({ data: De, additionalKeyValues: ne, objectId: O.objectNumber }), Ve("endobj");
  }, wo = function() {
    for (var O in We) We.hasOwnProperty(O) && tl(We[O]);
  }, la = function(O, ne) {
    var De, Ke = [], mt = 1 / (ne - 1);
    for (De = 0; De < 1; De += mt) Ke.push(De);
    if (Ke.push(1), O[0].offset != 0) {
      var zt = { offset: 0, color: O[0].color };
      O.unshift(zt);
    }
    if (O[O.length - 1].offset != 1) {
      var tr = { offset: 1, color: O[O.length - 1].color };
      O.push(tr);
    }
    for (var Tr = "", kr = 0, tn = 0; tn < Ke.length; tn++) {
      for (De = Ke[tn]; De > O[kr + 1].offset; ) kr++;
      var Kr = O[kr].offset, xn = (De - Kr) / (O[kr + 1].offset - Kr), ti = O[kr].color, Gn = O[kr + 1].color;
      Tr += Xe(Math.round((1 - xn) * ti[0] + xn * Gn[0]).toString(16)) + Xe(Math.round((1 - xn) * ti[1] + xn * Gn[1]).toString(16)) + Xe(Math.round((1 - xn) * ti[2] + xn * Gn[2]).toString(16));
    }
    return Tr.trim();
  }, ju = function(O, ne) {
    ne || (ne = 21);
    var De = fr(), Ke = la(O.colors, ne), mt = [];
    mt.push({ key: "FunctionType", value: "0" }), mt.push({ key: "Domain", value: "[0.0 1.0]" }), mt.push({ key: "Size", value: "[" + ne + "]" }), mt.push({ key: "BitsPerSample", value: "8" }), mt.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), mt.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), vn({ data: Ke, additionalKeyValues: mt, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: De }), Ve("endobj"), O.objectNumber = fr(), Ve("<< /ShadingType " + O.type), Ve("/ColorSpace /DeviceRGB");
    var zt = "/Coords [" + ye(parseFloat(O.coords[0])) + " " + ye(parseFloat(O.coords[1])) + " ";
    O.type === 2 ? zt += ye(parseFloat(O.coords[2])) + " " + ye(parseFloat(O.coords[3])) : zt += ye(parseFloat(O.coords[2])) + " " + ye(parseFloat(O.coords[3])) + " " + ye(parseFloat(O.coords[4])) + " " + ye(parseFloat(O.coords[5])), Ve(zt += "]"), O.matrix && Ve("/Matrix [" + O.matrix.toString() + "]"), Ve("/Function " + De + " 0 R"), Ve("/Extend [true true]"), Ve(">>"), Ve("endobj");
  }, hu = function(O, ne) {
    var De = Lr(), Ke = fr();
    ne.push({ resourcesOid: De, objectOid: Ke }), O.objectNumber = Ke;
    var mt = [];
    mt.push({ key: "Type", value: "/Pattern" }), mt.push({ key: "PatternType", value: "1" }), mt.push({ key: "PaintType", value: "1" }), mt.push({ key: "TilingType", value: "1" }), mt.push({ key: "BBox", value: "[" + O.boundingBox.map(ye).join(" ") + "]" }), mt.push({ key: "XStep", value: ye(O.xStep) }), mt.push({ key: "YStep", value: ye(O.yStep) }), mt.push({ key: "Resources", value: De + " 0 R" }), O.matrix && mt.push({ key: "Matrix", value: "[" + O.matrix.toString() + "]" }), vn({ data: O.stream, additionalKeyValues: mt, objectId: O.objectNumber }), Ve("endobj");
  }, Pl = function(O) {
    var ne;
    for (ne in pe) pe.hasOwnProperty(ne) && (pe[ne] instanceof af ? ju(pe[ne]) : pe[ne] instanceof Td && hu(pe[ne], O));
  }, Ca = function(O) {
    for (var ne in O.objectNumber = fr(), Ve("<<"), O) switch (ne) {
      case "opacity":
        Ve("/ca " + Ne(O[ne]));
        break;
      case "stroke-opacity":
        Ve("/CA " + Ne(O[ne]));
    }
    Ve(">>"), Ve("endobj");
  }, Vu = function() {
    var O;
    for (O in Ge) Ge.hasOwnProperty(O) && Ca(Ge[O]);
  }, fu = function() {
    for (var O in Ve("/XObject <<"), We) We.hasOwnProperty(O) && We[O].objectNumber >= 0 && Ve("/" + O + " " + We[O].objectNumber + " 0 R");
    pt.publish("putXobjectDict"), Ve(">>");
  }, kh = function() {
    an.oid = fr(), Ve("<<"), Ve("/Filter /Standard"), Ve("/V " + an.v), Ve("/R " + an.r), Ve("/U <" + an.toHexString(an.U) + ">"), Ve("/O <" + an.toHexString(an.O) + ">"), Ve("/P " + an.P), Ve(">>"), Ve("endobj");
  }, qu = function() {
    for (var O in Ve("/Font <<"), ve) ve.hasOwnProperty(O) && (T === !1 || T === !0 && M.hasOwnProperty(O)) && Ve("/" + O + " " + ve[O].objectNumber + " 0 R");
    Ve(">>");
  }, Gu = function() {
    if (Object.keys(pe).length > 0) {
      for (var O in Ve("/Shading <<"), pe) pe.hasOwnProperty(O) && pe[O] instanceof af && pe[O].objectNumber >= 0 && Ve("/" + O + " " + pe[O].objectNumber + " 0 R");
      pt.publish("putShadingPatternDict"), Ve(">>");
    }
  }, rl = function(O) {
    if (Object.keys(pe).length > 0) {
      for (var ne in Ve("/Pattern <<"), pe) pe.hasOwnProperty(ne) && pe[ne] instanceof E.TilingPattern && pe[ne].objectNumber >= 0 && pe[ne].objectNumber < O && Ve("/" + ne + " " + pe[ne].objectNumber + " 0 R");
      pt.publish("putTilingPatternDict"), Ve(">>");
    }
  }, Ia = function() {
    if (Object.keys(Ge).length > 0) {
      var O;
      for (O in Ve("/ExtGState <<"), Ge) Ge.hasOwnProperty(O) && Ge[O].objectNumber >= 0 && Ve("/" + O + " " + Ge[O].objectNumber + " 0 R");
      pt.publish("putGStateDict"), Ve(">>");
    }
  }, pi = function(O) {
    Hr(O.resourcesOid, !0), Ve("<<"), Ve("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), qu(), Gu(), rl(O.objectOid), Ia(), fu(), Ve(">>"), Ve("endobj");
  }, du = function() {
    var O = [];
    Wo(), Vu(), wo(), Pl(O), pt.publish("putResources"), O.forEach(pi), pi({ resourcesOid: Sn, objectOid: Number.MAX_SAFE_INTEGER }), pt.publish("postPutResources");
  }, ca = function() {
    pt.publish("putAdditionalObjects");
    for (var O = 0; O < ar.length; O++) {
      var ne = ar[O];
      Hr(ne.objId, !0), Ve(ne.content), Ve("endobj");
    }
    pt.publish("postPutAdditionalObjects");
  }, Nc = function(O) {
    se[O.fontName] = se[O.fontName] || {}, se[O.fontName][O.fontStyle] = O.id;
  }, nl = function(O, ne, De, Ke, mt) {
    var zt = { id: "F" + (Object.keys(ve).length + 1).toString(10), postScriptName: O, fontName: ne, fontStyle: De, encoding: Ke, isStandardFont: mt || !1, metadata: {} };
    return pt.publish("addFont", { font: zt, instance: this }), ve[zt.id] = zt, Nc(zt), zt.id;
  }, $u = function(O) {
    for (var ne = 0, De = rr.length; ne < De; ne++) {
      var Ke = nl.call(this, O[ne][0], O[ne][1], O[ne][2], rr[ne][3], !0);
      T === !1 && (M[Ke] = !0);
      var mt = O[ne][0].split("-");
      Nc({ id: Ke, fontName: mt[0], fontStyle: mt[1] || "" });
    }
    pt.publish("addFonts", { fonts: ve, dictionary: se });
  }, hs = function(O) {
    return O.foo = function() {
      try {
        return O.apply(this, arguments);
      } catch (Ke) {
        var ne = Ke.stack || "";
        ~ne.indexOf(" at ") && (ne = ne.split(" at ")[1]);
        var De = "Error in function " + ne.split(`
`)[0].split("<")[0] + ": " + Ke.message;
        if (!Qr.console) throw new Error(De);
        Qr.console.error(De, Ke), Qr.alert && alert(De);
      }
    }, O.foo.bar = O, O.foo;
  }, il = function(O, ne) {
    var De, Ke, mt, zt, tr, Tr, kr, tn, Kr;
    if (mt = (ne = ne || {}).sourceEncoding || "Unicode", tr = ne.outputEncoding, (ne.autoencode || tr) && ve[en].metadata && ve[en].metadata[mt] && ve[en].metadata[mt].encoding && (zt = ve[en].metadata[mt].encoding, !tr && ve[en].encoding && (tr = ve[en].encoding), !tr && zt.codePages && (tr = zt.codePages[0]), typeof tr == "string" && (tr = zt[tr]), tr)) {
      for (kr = !1, Tr = [], De = 0, Ke = O.length; De < Ke; De++) (tn = tr[O.charCodeAt(De)]) ? Tr.push(String.fromCharCode(tn)) : Tr.push(O[De]), Tr[De].charCodeAt(0) >> 8 && (kr = !0);
      O = Tr.join("");
    }
    for (De = O.length; kr === void 0 && De !== 0; ) O.charCodeAt(De - 1) >> 8 && (kr = !0), De--;
    if (!kr) return O;
    for (Tr = ne.noBOM ? [] : [254, 255], De = 0, Ke = O.length; De < Ke; De++) {
      if ((Kr = (tn = O.charCodeAt(De)) >> 8) >> 8) throw new Error("Character at position " + De + " of string '" + O + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      Tr.push(Kr), Tr.push(tn - (Kr << 8));
    }
    return String.fromCharCode.apply(void 0, Tr);
  }, gi = E.__private__.pdfEscape = E.pdfEscape = function(O, ne) {
    return il(O, ne).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, Yr = E.__private__.beginPage = function(O) {
    Yt[++Ye] = [], lt[Ye] = { objId: 0, contentsObjId: 0, userUnit: Number(o), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(O[0]), topRightY: Number(O[1]) } }, Rl(Ye), Ut(Yt[Be]);
  }, co = function(O, ne) {
    var De, Ke, mt;
    switch (t = ne || t, typeof O == "string" && (De = G(O.toLowerCase()), Array.isArray(De) && (Ke = De[0], mt = De[1])), Array.isArray(O) && (Ke = O[0] * Ar, mt = O[1] * Ar), isNaN(Ke) && (Ke = i[0], mt = i[1]), (Ke > 14400 || mt > 14400) && (vi.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), Ke = Math.min(14400, Ke), mt = Math.min(14400, mt)), i = [Ke, mt], t.substr(0, 1)) {
      case "l":
        mt > Ke && (i = [mt, Ke]);
        break;
      case "p":
        Ke > mt && (i = [mt, Ke]);
    }
    Yr(i), Dc(Yo), Ve(Un), Fl !== 0 && Ve(Fl + " J"), _u !== 0 && Ve(_u + " j"), pt.publish("addPage", { pageNumber: Ye });
  }, nn = function(O) {
    O > 0 && O <= Ye && (Yt.splice(O, 1), lt.splice(O, 1), Ye--, Be > Ye && (Be = Ye), this.setPage(Be));
  }, Rl = function(O) {
    O > 0 && O <= Ye && (Be = O);
  }, Hu = E.__private__.getNumberOfPages = E.getNumberOfPages = function() {
    return Yt.length - 1;
  }, sl = function(O, ne, De) {
    var Ke, mt = void 0;
    return De = De || {}, O = O !== void 0 ? O : ve[en].fontName, ne = ne !== void 0 ? ne : ve[en].fontStyle, Ke = O.toLowerCase(), se[Ke] !== void 0 && se[Ke][ne] !== void 0 ? mt = se[Ke][ne] : se[O] !== void 0 && se[O][ne] !== void 0 ? mt = se[O][ne] : De.disableWarning === !1 && vi.warn("Unable to look up font label for font '" + O + "', '" + ne + "'. Refer to getFontList() for available fonts."), mt || De.noFallback || (mt = se.times[ne]) == null && (mt = se.times.normal), mt;
  }, oi = E.__private__.putInfo = function() {
    var O = fr(), ne = function(Ke) {
      return Ke;
    };
    for (var De in b !== null && (ne = an.encryptor(O, 0)), Ve("<<"), Ve("/Producer (" + gi(ne("jsPDF " + Jr.version)) + ")"), Vr) Vr.hasOwnProperty(De) && Vr[De] && Ve("/" + De.substr(0, 1).toUpperCase() + De.substr(1) + " (" + gi(ne(Vr[De])) + ")");
    Ve("/CreationDate (" + gi(ne(Ct)) + ")"), Ve(">>"), Ve("endobj");
  }, mi = E.__private__.putCatalog = function(O) {
    var ne = (O = O || {}).rootDictionaryObjId || gr;
    switch (fr(), Ve("<<"), Ve("/Type /Catalog"), Ve("/Pages " + ne + " 0 R"), wr || (wr = "fullwidth"), wr) {
      case "fullwidth":
        Ve("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        Ve("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        Ve("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        Ve("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var De = "" + wr;
        De.substr(De.length - 1) === "%" && (wr = parseInt(wr) / 100), typeof wr == "number" && Ve("/OpenAction [3 0 R /XYZ null null " + Ne(wr) + "]");
    }
    switch (Zr || (Zr = "continuous"), Zr) {
      case "continuous":
        Ve("/PageLayout /OneColumn");
        break;
      case "single":
        Ve("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        Ve("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        Ve("/PageLayout /TwoColumnRight");
    }
    $r && Ve("/PageMode /" + $r), pt.publish("putCatalog"), Ve(">>"), Ve("endobj");
  }, Kn = E.__private__.putTrailer = function() {
    Ve("trailer"), Ve("<<"), Ve("/Size " + (it + 1)), Ve("/Root " + it + " 0 R"), Ve("/Info " + (it - 1) + " 0 R"), b !== null && Ve("/Encrypt " + an.oid + " 0 R"), Ve("/ID [ <" + ht + "> <" + ht + "> ]"), Ve(">>");
  }, pu = E.__private__.putHeader = function() {
    Ve("%PDF-" + D), Ve("%");
  }, Yi = E.__private__.putXRef = function() {
    var O = "0000000000";
    Ve("xref"), Ve("0 " + (it + 1)), Ve("0000000000 65535 f ");
    for (var ne = 1; ne <= it; ne++) typeof ft[ne] == "function" ? Ve((O + ft[ne]()).slice(-10) + " 00000 n ") : ft[ne] !== void 0 ? Ve((O + ft[ne]).slice(-10) + " 00000 n ") : Ve("0000000000 00000 n ");
  }, ai = E.__private__.buildDocument = function() {
    Cr(), Ut(St), pt.publish("buildDocument"), pu(), In(), ca(), du(), b !== null && kh(), oi(), mi();
    var O = wt;
    return Yi(), Kn(), Ve("startxref"), Ve("" + O), Ve("%%EOF"), Ut(Yt[Be]), St.join(`
`);
  }, Mi = E.__private__.getBlob = function(O) {
    return new Blob([Ir(O)], { type: "application/pdf" });
  }, ol = E.output = E.__private__.output = hs(function(O, ne) {
    switch (typeof (ne = ne || {}) == "string" ? ne = { filename: ne } : ne.filename = ne.filename || "generated.pdf", O) {
      case void 0:
        return ai();
      case "save":
        E.save(ne.filename);
        break;
      case "arraybuffer":
        return Ir(ai());
      case "blob":
        return Mi(ai());
      case "bloburi":
      case "bloburl":
        if (Qr.URL !== void 0 && typeof Qr.URL.createObjectURL == "function") return Qr.URL && Qr.URL.createObjectURL(Mi(ai())) || void 0;
        vi.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var De = "", Ke = ai();
        try {
          De = Tv(Ke);
        } catch {
          De = Tv(unescape(encodeURIComponent(Ke)));
        }
        return "data:application/pdf;filename=" + ne.filename + ";base64," + De;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(Qr) === "[object Window]") {
          var mt = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", zt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          ne.pdfObjectUrl && (mt = ne.pdfObjectUrl, zt = "");
          var tr = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + mt + '"' + zt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(ne) + ");<\/script></body></html>", Tr = Qr.open();
          return Tr !== null && Tr.document.write(tr), Tr;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(Qr) === "[object Window]") {
          var kr = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (ne.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + ne.filename + '" width="500px" height="400px" /></body></html>', tn = Qr.open();
          if (tn !== null) {
            tn.document.write(kr);
            var Kr = this;
            tn.document.documentElement.querySelector("#pdfViewer").onload = function() {
              tn.document.title = ne.filename, tn.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Kr.output("bloburl"));
            };
          }
          return tn;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(Qr) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var xn = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", ne) + '"></iframe></body></html>', ti = Qr.open();
        if (ti !== null && (ti.document.write(xn), ti.document.title = ne.filename), ti || typeof safari > "u") return ti;
        break;
      case "datauri":
      case "dataurl":
        return Qr.document.location.href = this.output("datauristring", ne);
      default:
        return null;
    }
  }), ua = function(O) {
    return Array.isArray(ct) === !0 && ct.indexOf(O) > -1;
  };
  switch (n) {
    case "pt":
      Ar = 1;
      break;
    case "mm":
      Ar = 72 / 25.4;
      break;
    case "cm":
      Ar = 72 / 2.54;
      break;
    case "in":
      Ar = 72;
      break;
    case "px":
      Ar = ua("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      Ar = 12;
      break;
    case "ex":
      Ar = 6;
      break;
    default:
      if (typeof n != "number") throw new Error("Invalid unit: " + n);
      Ar = n;
  }
  var an = null;
  mr(), bt();
  var Bl = function(O) {
    return b !== null ? an.encryptor(O, 0) : function(ne) {
      return ne;
    };
  }, uo = E.__private__.getPageInfo = E.getPageInfo = function(O) {
    if (isNaN(O) || O % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: lt[O].objId, pageNumber: O, pageContext: lt[O] };
  }, qr = E.__private__.getPageInfoByObjId = function(O) {
    if (isNaN(O) || O % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var ne in lt) if (lt[ne].objId === O) break;
    return uo(ne);
  }, Ys = E.__private__.getCurrentPageInfo = E.getCurrentPageInfo = function() {
    return { objId: lt[Be].objId, pageNumber: Be, pageContext: lt[Be] };
  };
  E.addPage = function() {
    return co.apply(this, arguments), this;
  }, E.setPage = function() {
    return Rl.apply(this, arguments), Ut.call(this, Yt[Be]), this;
  }, E.insertPage = function(O) {
    return this.addPage(), this.movePage(Be, O), this;
  }, E.movePage = function(O, ne) {
    var De, Ke;
    if (O > ne) {
      De = Yt[O], Ke = lt[O];
      for (var mt = O; mt > ne; mt--) Yt[mt] = Yt[mt - 1], lt[mt] = lt[mt - 1];
      Yt[ne] = De, lt[ne] = Ke, this.setPage(ne);
    } else if (O < ne) {
      De = Yt[O], Ke = lt[O];
      for (var zt = O; zt < ne; zt++) Yt[zt] = Yt[zt + 1], lt[zt] = lt[zt + 1];
      Yt[ne] = De, lt[ne] = Ke, this.setPage(ne);
    }
    return this;
  }, E.deletePage = function() {
    return nn.apply(this, arguments), this;
  }, E.__private__.text = E.text = function(O, ne, De, Ke, mt) {
    var zt, tr, Tr, kr, tn, Kr, xn, ti, Gn, Pi = (Ke = Ke || {}).scope || this;
    if (typeof O == "number" && typeof ne == "number" && (typeof De == "string" || Array.isArray(De))) {
      var gs = De;
      De = ne, ne = O, O = gs;
    }
    if (arguments[3] instanceof Kt ? (oe("The transform parameter of text() with a Matrix value"), Gn = mt) : (Tr = arguments[4], kr = arguments[5], ii(xn = arguments[3]) === "object" && xn !== null || (typeof Tr == "string" && (kr = Tr, Tr = null), typeof xn == "string" && (kr = xn, xn = null), typeof xn == "number" && (Tr = xn, xn = null), Ke = { flags: xn, angle: Tr, align: kr })), isNaN(ne) || isNaN(De) || O == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (O.length === 0) return Pi;
    var Ti = "", fo = !1, Us = typeof Ke.lineHeightFactor == "number" ? Ke.lineHeightFactor : Zo, fa = Pi.internal.scaleFactor;
    function Xu(Bn) {
      return Bn = Bn.split("	").join(Array(Ke.TabLen || 9).join(" ")), gi(Bn, xn);
    }
    function Vl(Bn) {
      for (var $n, Ri = Bn.concat(), Ui = [], ka = Ri.length; ka--; ) typeof ($n = Ri.shift()) == "string" ? Ui.push($n) : Array.isArray(Bn) && ($n.length === 1 || $n[1] === void 0 && $n[2] === void 0) ? Ui.push($n[0]) : Ui.push([$n[0], $n[1], $n[2]]);
      return Ui;
    }
    function ql(Bn, $n) {
      var Ri;
      if (typeof Bn == "string") Ri = $n(Bn)[0];
      else if (Array.isArray(Bn)) {
        for (var Ui, ka, pl = Bn.concat(), Fa = [], Yl = pl.length; Yl--; ) typeof (Ui = pl.shift()) == "string" ? Fa.push($n(Ui)[0]) : Array.isArray(Ui) && typeof Ui[0] == "string" && (ka = $n(Ui[0], Ui[1], Ui[2]), Fa.push([ka[0], ka[1], ka[2]]));
        Ri = Fa;
      }
      return Ri;
    }
    var Gl = !1, $l = !0;
    if (typeof O == "string") Gl = !0;
    else if (Array.isArray(O)) {
      var Hl = O.concat();
      tr = [];
      for (var da, ri = Hl.length; ri--; ) (typeof (da = Hl.shift()) != "string" || Array.isArray(da) && typeof da[0] != "string") && ($l = !1);
      Gl = $l;
    }
    if (Gl === !1) throw new Error('Type of text must be string or Array. "' + O + '" is not recognized.');
    typeof O == "string" && (O = O.match(/[\r?\n]/) ? O.split(/\r\n|\r|\n/g) : [O]);
    var ll = hr / Pi.internal.scaleFactor, cl = ll * (Us - 1);
    switch (Ke.baseline) {
      case "bottom":
        De -= cl;
        break;
      case "top":
        De += ll - cl;
        break;
      case "hanging":
        De += ll - 2 * cl;
        break;
      case "middle":
        De += ll / 2 - cl;
    }
    if ((Kr = Ke.maxWidth || 0) > 0 && (typeof O == "string" ? O = Pi.splitTextToSize(O, Kr) : Object.prototype.toString.call(O) === "[object Array]" && (O = O.reduce(function(Bn, $n) {
      return Bn.concat(Pi.splitTextToSize($n, Kr));
    }, []))), zt = { text: O, x: ne, y: De, options: Ke, mutex: { pdfEscape: gi, activeFontKey: en, fonts: ve, activeFontSize: hr } }, pt.publish("preProcessText", zt), O = zt.text, Tr = (Ke = zt.options).angle, !(Gn instanceof Kt) && Tr && typeof Tr == "number") {
      Tr *= Math.PI / 180, Ke.rotationDirection === 0 && (Tr = -Tr), he === Y.ADVANCED && (Tr = -Tr);
      var Ba = Math.cos(Tr), zc = Math.sin(Tr);
      Gn = new Kt(Ba, zc, -zc, Ba, 0, 0);
    } else Tr && Tr instanceof Kt && (Gn = Tr);
    he !== Y.ADVANCED || Gn || (Gn = Bt), (tn = Ke.charSpace || Fc) !== void 0 && (Ti += ye(_e(tn)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (ti = Ke.horizontalScale) !== void 0 && (Ti += ye(100 * ti) + ` Tz
`), Ke.lang;
    var Cs = -1, La = Ke.renderingMode !== void 0 ? Ke.renderingMode : Ke.stroke, Wl = Pi.internal.getCurrentPageInfo().pageContext;
    switch (La) {
      case 0:
      case !1:
      case "fill":
        Cs = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        Cs = 1;
        break;
      case 2:
      case "fillThenStroke":
        Cs = 2;
        break;
      case 3:
      case "invisible":
        Cs = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        Cs = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        Cs = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        Cs = 6;
        break;
      case 7:
      case "addToPathForClipping":
        Cs = 7;
    }
    var An = Wl.usedRenderingMode !== void 0 ? Wl.usedRenderingMode : -1;
    Cs !== -1 ? Ti += Cs + ` Tr
` : An !== -1 && (Ti += `0 Tr
`), Cs !== -1 && (Wl.usedRenderingMode = Cs), kr = Ke.align || "left";
    var Eo, jc = hr * Us, Zu = Pi.internal.pageSize.getWidth(), bu = ve[en];
    tn = Ke.charSpace || Fc, Kr = Ke.maxWidth || 0, xn = Object.assign({ autoencode: !0, noBOM: !0 }, Ke.flags);
    var ul = [], hl = function(Bn) {
      return Pi.getStringUnitWidth(Bn, { font: bu, charSpace: tn, fontSize: hr, doKerning: !1 }) * hr / fa;
    };
    if (Object.prototype.toString.call(O) === "[object Array]") {
      var ms;
      tr = Vl(O), kr !== "left" && (Eo = tr.map(hl));
      var Ji, Ko = 0;
      if (kr === "right") {
        ne -= Eo[0], O = [], ri = tr.length;
        for (var Jo = 0; Jo < ri; Jo++) Jo === 0 ? (Ji = gn(ne), ms = Ks(De)) : (Ji = _e(Ko - Eo[Jo]), ms = -jc), O.push([tr[Jo], Ji, ms]), Ko = Eo[Jo];
      } else if (kr === "center") {
        ne -= Eo[0] / 2, O = [], ri = tr.length;
        for (var zs = 0; zs < ri; zs++) zs === 0 ? (Ji = gn(ne), ms = Ks(De)) : (Ji = _e((Ko - Eo[zs]) / 2), ms = -jc), O.push([tr[zs], Ji, ms]), Ko = Eo[zs];
      } else if (kr === "left") {
        O = [], ri = tr.length;
        for (var Qo = 0; Qo < ri; Qo++) O.push(tr[Qo]);
      } else if (kr === "justify" && bu.encoding === "Identity-H") {
        O = [], ri = tr.length, Kr = Kr !== 0 ? Kr : Zu;
        for (var Fi = 0, Si = 0; Si < ri; Si++) if (ms = Si === 0 ? Ks(De) : -jc, Ji = Si === 0 ? gn(ne) : Fi, Si < ri - 1) {
          var Vc = _e((Kr - Eo[Si]) / (tr[Si].split(" ").length - 1)), _s = tr[Si].split(" ");
          O.push([_s[0] + " ", Ji, ms]), Fi = 0;
          for (var Qi = 1; Qi < _s.length; Qi++) {
            var Oa = (hl(_s[Qi - 1] + " " + _s[Qi]) - hl(_s[Qi])) * fa + Vc;
            Qi == _s.length - 1 ? O.push([_s[Qi], Oa, 0]) : O.push([_s[Qi] + " ", Oa, 0]), Fi -= Oa;
          }
        } else O.push([tr[Si], Ji, ms]);
        O.push(["", Fi, 0]);
      } else {
        if (kr !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (O = [], ri = tr.length, Kr = Kr !== 0 ? Kr : Zu, Si = 0; Si < ri; Si++) ms = Si === 0 ? Ks(De) : -jc, Ji = Si === 0 ? gn(ne) : 0, Si < ri - 1 ? ul.push(ye(_e((Kr - Eo[Si]) / (tr[Si].split(" ").length - 1)))) : ul.push(0), O.push([tr[Si], Ji, ms]);
      }
    }
    var Xl = typeof Ke.R2L == "boolean" ? Ke.R2L : Rr;
    Xl === !0 && (O = ql(O, function(Bn, $n, Ri) {
      return [Bn.split("").reverse().join(""), $n, Ri];
    })), zt = { text: O, x: ne, y: De, options: Ke, mutex: { pdfEscape: gi, activeFontKey: en, fonts: ve, activeFontSize: hr } }, pt.publish("postProcessText", zt), O = zt.text, fo = zt.mutex.isHex || !1;
    var Na = ve[en].encoding;
    Na !== "WinAnsiEncoding" && Na !== "StandardEncoding" || (O = ql(O, function(Bn, $n, Ri) {
      return [Xu(Bn), $n, Ri];
    })), tr = Vl(O), O = [];
    for (var pa, fl, po, Co = 0, Zl = 1, Da = Array.isArray(tr[0]) ? Zl : Co, sn = "", dl = function(Bn, $n, Ri) {
      var Ui = "";
      return Ri instanceof Kt ? (Ri = typeof Ke.angle == "number" ? Mr(Ri, new Kt(1, 0, 0, 1, Bn, $n)) : Mr(new Kt(1, 0, 0, 1, Bn, $n), Ri), he === Y.ADVANCED && (Ri = Mr(new Kt(1, 0, 0, -1, 0, 0), Ri)), Ui = Ri.join(" ") + ` Tm
`) : Ui = ye(Bn) + " " + ye($n) + ` Td
`, Ui;
    }, Io = 0; Io < tr.length; Io++) {
      switch (sn = "", Da) {
        case Zl:
          po = (fo ? "<" : "(") + tr[Io][0] + (fo ? ">" : ")"), pa = parseFloat(tr[Io][1]), fl = parseFloat(tr[Io][2]);
          break;
        case Co:
          po = (fo ? "<" : "(") + tr[Io] + (fo ? ">" : ")"), pa = gn(ne), fl = Ks(De);
      }
      ul !== void 0 && ul[Io] !== void 0 && (sn = ul[Io] + ` Tw
`), Io === 0 ? O.push(sn + dl(pa, fl, Gn) + po) : Da === Co ? O.push(sn + po) : Da === Zl && O.push(sn + dl(pa, fl, Gn) + po);
    }
    O = Da === Co ? O.join(` Tj
T* `) : O.join(` Tj
`), O += ` Tj
`;
    var go = `BT
/`;
    return go += en + " " + hr + ` Tf
`, go += ye(hr * Us) + ` TL
`, go += Qs + `
`, go += Ti, go += O, Ve(go += "ET"), M[en] = !0, Pi;
  };
  var gu = E.__private__.clip = E.clip = function(O) {
    return Ve(O === "evenodd" ? "W*" : "W"), this;
  };
  E.clipEvenOdd = function() {
    return gu("evenodd");
  }, E.__private__.discardPath = E.discardPath = function() {
    return Ve("n"), this;
  };
  var Ki = E.__private__.isValidStyle = function(O) {
    var ne = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(O) !== -1 && (ne = !0), ne;
  };
  E.__private__.setDefaultPathOperation = E.setDefaultPathOperation = function(O) {
    return Ki(O) && (m = O), this;
  };
  var Ll = E.__private__.getStyle = E.getStyle = function(O) {
    var ne = m;
    switch (O) {
      case "D":
      case "S":
        ne = "S";
        break;
      case "F":
        ne = "f";
        break;
      case "FD":
      case "DF":
        ne = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        ne = O;
    }
    return ne;
  }, Fn = E.close = function() {
    return Ve("h"), this;
  };
  E.stroke = function() {
    return Ve("S"), this;
  }, E.fill = function(O) {
    return Xo("f", O), this;
  }, E.fillEvenOdd = function(O) {
    return Xo("f*", O), this;
  }, E.fillStroke = function(O) {
    return Xo("B", O), this;
  }, E.fillStrokeEvenOdd = function(O) {
    return Xo("B*", O), this;
  };
  var Xo = function(O, ne) {
    ii(ne) === "object" ? Ol(ne, O) : Ve(O);
  }, ln = function(O) {
    O === null || he === Y.ADVANCED && O === void 0 || (O = Ll(O), Ve(O));
  };
  function Xr(O, ne, De, Ke, mt) {
    var zt = new Td(ne || this.boundingBox, De || this.xStep, Ke || this.yStep, this.gState, mt || this.matrix);
    zt.stream = this.stream;
    var tr = O + "$$" + this.cloneIndex++ + "$$";
    return Qt(tr, zt), zt;
  }
  var Ol = function(O, ne) {
    var De = Oe[O.key], Ke = pe[De];
    if (Ke instanceof af) Ve("q"), Ve(dn(ne)), Ke.gState && E.setGState(Ke.gState), Ve(O.matrix.toString() + " cm"), Ve("/" + De + " sh"), Ve("Q");
    else if (Ke instanceof Td) {
      var mt = new Kt(1, 0, 0, -1, 0, So());
      O.matrix && (mt = mt.multiply(O.matrix || Bt), De = Xr.call(Ke, O.key, O.boundingBox, O.xStep, O.yStep, mt).id), Ve("q"), Ve("/Pattern cs"), Ve("/" + De + " scn"), Ke.gState && E.setGState(Ke.gState), Ve(ne), Ve("Q");
    }
  }, dn = function(O) {
    switch (O) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, ha = E.moveTo = function(O, ne) {
    return Ve(ye(_e(O)) + " " + ye(Me(ne)) + " m"), this;
  }, fs = E.lineTo = function(O, ne) {
    return Ve(ye(_e(O)) + " " + ye(Me(ne)) + " l"), this;
  }, Ao = E.curveTo = function(O, ne, De, Ke, mt, zt) {
    return Ve([ye(_e(O)), ye(Me(ne)), ye(_e(De)), ye(Me(Ke)), ye(_e(mt)), ye(Me(zt)), "c"].join(" ")), this;
  };
  E.__private__.line = E.line = function(O, ne, De, Ke, mt) {
    if (isNaN(O) || isNaN(ne) || isNaN(De) || isNaN(Ke) || !Ki(mt)) throw new Error("Invalid arguments passed to jsPDF.line");
    return he === Y.COMPAT ? this.lines([[De - O, Ke - ne]], O, ne, [1, 1], mt || "S") : this.lines([[De - O, Ke - ne]], O, ne, [1, 1]).stroke();
  }, E.__private__.lines = E.lines = function(O, ne, De, Ke, mt, zt) {
    var tr, Tr, kr, tn, Kr, xn, ti, Gn, Pi, gs, Ti, fo;
    if (typeof O == "number" && (fo = De, De = ne, ne = O, O = fo), Ke = Ke || [1, 1], zt = zt || !1, isNaN(ne) || isNaN(De) || !Array.isArray(O) || !Array.isArray(Ke) || !Ki(mt) || typeof zt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (ha(ne, De), tr = Ke[0], Tr = Ke[1], tn = O.length, gs = ne, Ti = De, kr = 0; kr < tn; kr++) (Kr = O[kr]).length === 2 ? (gs = Kr[0] * tr + gs, Ti = Kr[1] * Tr + Ti, fs(gs, Ti)) : (xn = Kr[0] * tr + gs, ti = Kr[1] * Tr + Ti, Gn = Kr[2] * tr + gs, Pi = Kr[3] * Tr + Ti, gs = Kr[4] * tr + gs, Ti = Kr[5] * Tr + Ti, Ao(xn, ti, Gn, Pi, gs, Ti));
    return zt && Fn(), ln(mt), this;
  }, E.path = function(O) {
    for (var ne = 0; ne < O.length; ne++) {
      var De = O[ne], Ke = De.c;
      switch (De.op) {
        case "m":
          ha(Ke[0], Ke[1]);
          break;
        case "l":
          fs(Ke[0], Ke[1]);
          break;
        case "c":
          Ao.apply(this, Ke);
          break;
        case "h":
          Fn();
      }
    }
    return this;
  }, E.__private__.rect = E.rect = function(O, ne, De, Ke, mt) {
    if (isNaN(O) || isNaN(ne) || isNaN(De) || isNaN(Ke) || !Ki(mt)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return he === Y.COMPAT && (Ke = -Ke), Ve([ye(_e(O)), ye(Me(ne)), ye(_e(De)), ye(_e(Ke)), "re"].join(" ")), ln(mt), this;
  }, E.__private__.triangle = E.triangle = function(O, ne, De, Ke, mt, zt, tr) {
    if (isNaN(O) || isNaN(ne) || isNaN(De) || isNaN(Ke) || isNaN(mt) || isNaN(zt) || !Ki(tr)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[De - O, Ke - ne], [mt - De, zt - Ke], [O - mt, ne - zt]], O, ne, [1, 1], tr, !0), this;
  }, E.__private__.roundedRect = E.roundedRect = function(O, ne, De, Ke, mt, zt, tr) {
    if (isNaN(O) || isNaN(ne) || isNaN(De) || isNaN(Ke) || isNaN(mt) || isNaN(zt) || !Ki(tr)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var Tr = 4 / 3 * (Math.SQRT2 - 1);
    return mt = Math.min(mt, 0.5 * De), zt = Math.min(zt, 0.5 * Ke), this.lines([[De - 2 * mt, 0], [mt * Tr, 0, mt, zt - zt * Tr, mt, zt], [0, Ke - 2 * zt], [0, zt * Tr, -mt * Tr, zt, -mt, zt], [2 * mt - De, 0], [-mt * Tr, 0, -mt, -zt * Tr, -mt, -zt], [0, 2 * zt - Ke], [0, -zt * Tr, mt * Tr, -zt, mt, -zt]], O + mt, ne, [1, 1], tr, !0), this;
  }, E.__private__.ellipse = E.ellipse = function(O, ne, De, Ke, mt) {
    if (isNaN(O) || isNaN(ne) || isNaN(De) || isNaN(Ke) || !Ki(mt)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var zt = 4 / 3 * (Math.SQRT2 - 1) * De, tr = 4 / 3 * (Math.SQRT2 - 1) * Ke;
    return ha(O + De, ne), Ao(O + De, ne - tr, O + zt, ne - Ke, O, ne - Ke), Ao(O - zt, ne - Ke, O - De, ne - tr, O - De, ne), Ao(O - De, ne + tr, O - zt, ne + Ke, O, ne + Ke), Ao(O + zt, ne + Ke, O + De, ne + tr, O + De, ne), ln(mt), this;
  }, E.__private__.circle = E.circle = function(O, ne, De, Ke) {
    if (isNaN(O) || isNaN(ne) || isNaN(De) || !Ki(Ke)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(O, ne, De, De, Ke);
  }, E.setFont = function(O, ne, De) {
    return De && (ne = ie(ne, De)), en = sl(O, ne, { disableWarning: !1 }), this;
  };
  var Nl = E.__private__.getFont = E.getFont = function() {
    return ve[sl.apply(E, arguments)];
  };
  E.__private__.getFontList = E.getFontList = function() {
    var O, ne, De = {};
    for (O in se) if (se.hasOwnProperty(O)) for (ne in De[O] = [], se[O]) se[O].hasOwnProperty(ne) && De[O].push(ne);
    return De;
  }, E.addFont = function(O, ne, De, Ke, mt) {
    var zt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && zt.indexOf(arguments[3]) !== -1 ? mt = arguments[3] : arguments[3] && zt.indexOf(arguments[3]) == -1 && (De = ie(De, Ke)), mt = mt || "Identity-H", nl.call(this, O, ne, De, mt);
  };
  var Zo, Yo = r.lineWidth || 0.200025, Dl = E.__private__.getLineWidth = E.getLineWidth = function() {
    return Yo;
  }, Dc = E.__private__.setLineWidth = E.setLineWidth = function(O) {
    return Yo = O, Ve(ye(_e(O)) + " w"), this;
  };
  E.__private__.setLineDash = Jr.API.setLineDash = Jr.API.setLineDashPattern = function(O, ne) {
    if (O = O || [], ne = ne || 0, isNaN(ne) || !Array.isArray(O)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return O = O.map(function(De) {
      return ye(_e(De));
    }).join(" "), ne = ye(_e(ne)), Ve("[" + O + "] " + ne + " d"), this;
  };
  var kc = E.__private__.getLineHeight = E.getLineHeight = function() {
    return hr * Zo;
  };
  E.__private__.getLineHeight = E.getLineHeight = function() {
    return hr * Zo;
  };
  var mu = E.__private__.setLineHeightFactor = E.setLineHeightFactor = function(O) {
    return typeof (O = O || 1.15) == "number" && (Zo = O), this;
  }, al = E.__private__.getLineHeightFactor = E.getLineHeightFactor = function() {
    return Zo;
  };
  mu(r.lineHeight);
  var gn = E.__private__.getHorizontalCoordinate = function(O) {
    return _e(O);
  }, Ks = E.__private__.getVerticalCoordinate = function(O) {
    return he === Y.ADVANCED ? O : lt[Be].mediaBox.topRightY - lt[Be].mediaBox.bottomLeftY - _e(O);
  }, ho = E.__private__.getHorizontalCoordinateString = E.getHorizontalCoordinateString = function(O) {
    return ye(gn(O));
  }, Js = E.__private__.getVerticalCoordinateString = E.getVerticalCoordinateString = function(O) {
    return ye(Ks(O));
  }, Un = r.strokeColor || "0 G";
  E.__private__.getStrokeColor = E.getDrawColor = function() {
    return Zi(Un);
  }, E.__private__.setStrokeColor = E.setDrawColor = function(O, ne, De, Ke) {
    return Un = Dn({ ch1: O, ch2: ne, ch3: De, ch4: Ke, pdfColorType: "draw", precision: 2 }), Ve(Un), this;
  };
  var kl = r.fillColor || "0 g";
  E.__private__.getFillColor = E.getFillColor = function() {
    return Zi(kl);
  }, E.__private__.setFillColor = E.setFillColor = function(O, ne, De, Ke) {
    return kl = Dn({ ch1: O, ch2: ne, ch3: De, ch4: Ke, pdfColorType: "fill", precision: 2 }), Ve(kl), this;
  };
  var Qs = r.textColor || "0 g", Wu = E.__private__.getTextColor = E.getTextColor = function() {
    return Zi(Qs);
  };
  E.__private__.setTextColor = E.setTextColor = function(O, ne, De, Ke) {
    return Qs = Dn({ ch1: O, ch2: ne, ch3: De, ch4: Ke, pdfColorType: "text", precision: 3 }), this;
  };
  var Fc = r.charSpace, Uc = E.__private__.getCharSpace = E.getCharSpace = function() {
    return parseFloat(Fc || 0);
  };
  E.__private__.setCharSpace = E.setCharSpace = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return Fc = O, this;
  };
  var Fl = 0;
  E.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, E.__private__.setLineCap = E.setLineCap = function(O) {
    var ne = E.CapJoinStyles[O];
    if (ne === void 0) throw new Error("Line cap style of '" + O + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Fl = ne, Ve(ne + " J"), this;
  };
  var _u = 0;
  E.__private__.setLineJoin = E.setLineJoin = function(O) {
    var ne = E.CapJoinStyles[O];
    if (ne === void 0) throw new Error("Line join style of '" + O + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return _u = ne, Ve(ne + " j"), this;
  }, E.__private__.setLineMiterLimit = E.__private__.setMiterLimit = E.setLineMiterLimit = E.setMiterLimit = function(O) {
    if (O = O || 0, isNaN(O)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return Ve(ye(_e(O)) + " M"), this;
  }, E.GState = Z_, E.setGState = function(O) {
    (O = typeof O == "string" ? Ge[rt[O]] : Ul(null, O)).equals(gt) || (Ve("/" + O.id + " gs"), gt = O);
  };
  var Ul = function(O, ne) {
    if (!O || !rt[O]) {
      var De = !1;
      for (var Ke in Ge) if (Ge.hasOwnProperty(Ke) && Ge[Ke].equals(ne)) {
        De = !0;
        break;
      }
      if (De) ne = Ge[Ke];
      else {
        var mt = "GS" + (Object.keys(Ge).length + 1).toString(10);
        Ge[mt] = ne, ne.id = mt;
      }
      return O && (rt[O] = ne.id), pt.publish("addGState", ne), ne;
    }
  };
  E.addGState = function(O, ne) {
    return Ul(O, ne), this;
  }, E.saveGraphicsState = function() {
    return Ve("q"), de.push({ key: en, size: hr, color: Qs }), this;
  }, E.restoreGraphicsState = function() {
    Ve("Q");
    var O = de.pop();
    return en = O.key, hr = O.size, Qs = O.color, gt = null, this;
  }, E.setCurrentTransformationMatrix = function(O) {
    return Ve(O.toString() + " cm"), this;
  }, E.comment = function(O) {
    return Ve("#" + O), this;
  };
  var To = function(O, ne) {
    var De = O || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return De;
    }, set: function(zt) {
      isNaN(zt) || (De = parseFloat(zt));
    } });
    var Ke = ne || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return Ke;
    }, set: function(zt) {
      isNaN(zt) || (Ke = parseFloat(zt));
    } });
    var mt = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return mt;
    }, set: function(zt) {
      mt = zt.toString();
    } }), this;
  }, ds = function(O, ne, De, Ke) {
    To.call(this, O, ne), this.type = "rect";
    var mt = De || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return mt;
    }, set: function(tr) {
      isNaN(tr) || (mt = parseFloat(tr));
    } });
    var zt = Ke || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return zt;
    }, set: function(tr) {
      isNaN(tr) || (zt = parseFloat(tr));
    } }), this;
  }, Ma = function() {
    this.page = Ye, this.currentPage = Be, this.pages = Yt.slice(0), this.pagesContext = lt.slice(0), this.x = Ii, this.y = bn, this.matrix = Xi, this.width = zl(Be), this.height = So(Be), this.outputDestination = _r, this.id = "", this.objectNumber = -1;
  };
  Ma.prototype.restore = function() {
    Ye = this.page, Be = this.currentPage, lt = this.pagesContext, Yt = this.pages, Ii = this.x, bn = this.y, Xi = this.matrix, jl(Be, this.width), Ra(Be, this.height), _r = this.outputDestination;
  };
  var Pa = function(O, ne, De, Ke, mt) {
    Jt.push(new Ma()), Ye = Be = 0, Yt = [], Ii = O, bn = ne, Xi = mt, Yr([De, Ke]);
  }, yu = function(O) {
    if (or[O]) Jt.pop().restore();
    else {
      var ne = new Ma(), De = "Xo" + (Object.keys(We).length + 1).toString(10);
      ne.id = De, or[O] = De, We[De] = ne, pt.publish("addFormObject", ne), Jt.pop().restore();
    }
  };
  for (var ps in E.beginFormObject = function(O, ne, De, Ke, mt) {
    return Pa(O, ne, De, Ke, mt), this;
  }, E.endFormObject = function(O) {
    return yu(O), this;
  }, E.doFormObject = function(O, ne) {
    var De = We[or[O]];
    return Ve("q"), Ve(ne.toString() + " cm"), Ve("/" + De.id + " Do"), Ve("Q"), this;
  }, E.getFormObject = function(O) {
    var ne = We[or[O]];
    return { x: ne.x, y: ne.y, width: ne.width, height: ne.height, matrix: ne.matrix };
  }, E.save = function(O, ne) {
    return O = O || "generated.pdf", (ne = ne || {}).returnPromise = ne.returnPromise || !1, ne.returnPromise === !1 ? (nf(Mi(ai()), O), typeof nf.unload == "function" && Qr.setTimeout && setTimeout(nf.unload, 911), this) : new Promise(function(De, Ke) {
      try {
        var mt = nf(Mi(ai()), O);
        typeof nf.unload == "function" && Qr.setTimeout && setTimeout(nf.unload, 911), De(mt);
      } catch (zt) {
        Ke(zt.message);
      }
    });
  }, Jr.API) Jr.API.hasOwnProperty(ps) && (ps === "events" && Jr.API.events.length ? function(O, ne) {
    var De, Ke, mt;
    for (mt = ne.length - 1; mt !== -1; mt--) De = ne[mt][0], Ke = ne[mt][1], O.subscribe.apply(O, [De].concat(typeof Ke == "function" ? [Ke] : Ke));
  }(pt, Jr.API.events) : E[ps] = Jr.API[ps]);
  var zl = E.getPageWidth = function(O) {
    return (lt[O = O || Be].mediaBox.topRightX - lt[O].mediaBox.bottomLeftX) / Ar;
  }, jl = E.setPageWidth = function(O, ne) {
    lt[O].mediaBox.topRightX = ne * Ar + lt[O].mediaBox.bottomLeftX;
  }, So = E.getPageHeight = function(O) {
    return (lt[O = O || Be].mediaBox.topRightY - lt[O].mediaBox.bottomLeftY) / Ar;
  }, Ra = E.setPageHeight = function(O, ne) {
    lt[O].mediaBox.topRightY = ne * Ar + lt[O].mediaBox.bottomLeftY;
  };
  return E.internal = { pdfEscape: gi, getStyle: Ll, getFont: Nl, getFontSize: br, getCharSpace: Uc, getTextColor: Wu, getLineHeight: kc, getLineHeightFactor: al, getLineWidth: Dl, write: jr, getHorizontalCoordinate: gn, getVerticalCoordinate: Ks, getCoordinateString: ho, getVerticalCoordinateString: Js, collections: {}, newObject: fr, newAdditionalObject: Or, newObjectDeferred: Lr, newObjectDeferredBegin: Hr, getFilters: kn, putStream: vn, events: pt, scaleFactor: Ar, pageSize: { getWidth: function() {
    return zl(Be);
  }, setWidth: function(O) {
    jl(Be, O);
  }, getHeight: function() {
    return So(Be);
  }, setHeight: function(O) {
    Ra(Be, O);
  } }, encryptionOptions: b, encryption: an, getEncryptor: Bl, output: ol, getNumberOfPages: Hu, pages: Yt, out: Ve, f2: Ne, f3: me, getPageInfo: uo, getPageInfoByObjId: qr, getCurrentPageInfo: Ys, getPDFVersion: U, Point: To, Rectangle: ds, Matrix: Kt, hasHotfix: ua }, Object.defineProperty(E.internal.pageSize, "width", { get: function() {
    return zl(Be);
  }, set: function(O) {
    jl(Be, O);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(E.internal.pageSize, "height", { get: function() {
    return So(Be);
  }, set: function(O) {
    Ra(Be, O);
  }, enumerable: !0, configurable: !0 }), $u.call(E, rr), en = "F1", co(i, t), pt.publish("initialized"), E;
}
pd.prototype.lsbFirstWord = function(r) {
  return String.fromCharCode(r >> 0 & 255, r >> 8 & 255, r >> 16 & 255, r >> 24 & 255);
}, pd.prototype.toHexString = function(r) {
  return r.split("").map(function(e) {
    return ("0" + (255 & e.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, pd.prototype.hexToBytes = function(r) {
  for (var e = [], t = 0; t < r.length; t += 2) e.push(String.fromCharCode(parseInt(r.substr(t, 2), 16)));
  return e.join("");
}, pd.prototype.processOwnerPassword = function(r, e) {
  return Ev(Sv(e).substr(0, 5), r);
}, pd.prototype.encryptor = function(r, e) {
  var t = Sv(this.encryptionKey + String.fromCharCode(255 & r, r >> 8 & 255, r >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(n) {
    return Ev(t, n);
  };
}, Z_.prototype.equals = function(r) {
  var e, t = "id,objectNumber,equals";
  if (!r || ii(r) !== ii(this)) return !1;
  var n = 0;
  for (e in this) if (!(t.indexOf(e) >= 0)) {
    if (this.hasOwnProperty(e) && !r.hasOwnProperty(e) || this[e] !== r[e]) return !1;
    n++;
  }
  for (e in r) r.hasOwnProperty(e) && t.indexOf(e) < 0 && n--;
  return n === 0;
}, Jr.API = { events: [] }, Jr.version = "2.5.2";
var cs = Jr.API, rx = 1, Of = function(r) {
  return r.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, ud = function(r) {
  return r.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, un = function(r) {
  return r.toFixed(2);
}, gh = function(r) {
  return r.toFixed(5);
};
cs.__acroform__ = {};
var Ea = function(r, e) {
  r.prototype = Object.create(e.prototype), r.prototype.constructor = r;
}, _S = function(r) {
  return r * rx;
}, nu = function(r) {
  var e = new fM(), t = Dr.internal.getHeight(r) || 0, n = Dr.internal.getWidth(r) || 0;
  return e.BBox = [0, 0, Number(un(n)), Number(un(t))], e;
}, bX = cs.__acroform__.setBit = function(r, e) {
  if (r = r || 0, e = e || 0, isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return r |= 1 << e;
}, vX = cs.__acroform__.clearBit = function(r, e) {
  if (r = r || 0, e = e || 0, isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return r &= ~(1 << e);
}, xX = cs.__acroform__.getBit = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return r & 1 << e ? 1 : 0;
}, ws = cs.__acroform__.getBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return xX(r, e - 1);
}, As = cs.__acroform__.setBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return bX(r, e - 1);
}, Ts = cs.__acroform__.clearBitForPdf = function(r, e) {
  if (isNaN(r) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return vX(r, e - 1);
}, wX = cs.__acroform__.calculateCoordinates = function(r, e) {
  var t = e.internal.getHorizontalCoordinate, n = e.internal.getVerticalCoordinate, i = r[0], s = r[1], l = r[2], o = r[3], d = {};
  return d.lowerLeft_X = t(i) || 0, d.lowerLeft_Y = n(s + o) || 0, d.upperRight_X = t(i + l) || 0, d.upperRight_Y = n(s) || 0, [Number(un(d.lowerLeft_X)), Number(un(d.lowerLeft_Y)), Number(un(d.upperRight_X)), Number(un(d.upperRight_Y))];
}, AX = function(r) {
  if (r.appearanceStreamContent) return r.appearanceStreamContent;
  if (r.V || r.DV) {
    var e = [], t = r._V || r.DV, n = Cv(r, t), i = r.scope.internal.getFont(r.fontName, r.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(r.scope.__private__.encodeColorString(r.color)), e.push("/" + i + " " + un(n.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(n.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var s = nu(r);
    return s.scope = r.scope, s.stream = e.join(`
`), s;
  }
}, Cv = function(r, e) {
  var t = r.fontSize === 0 ? r.maxFontSize : r.fontSize, n = { text: "", fontSize: "" }, i = (e = (e = e.substr(0, 1) == "(" ? e.substr(1) : e).substr(e.length - 1) == ")" ? e.substr(0, e.length - 1) : e).split(" ");
  i = r.multiline ? i.map(function(me) {
    return me.split(`
`);
  }) : i.map(function(me) {
    return [me];
  });
  var s = t, l = Dr.internal.getHeight(r) || 0;
  l = l < 0 ? -l : l;
  var o = Dr.internal.getWidth(r) || 0;
  o = o < 0 ? -o : o;
  var d = function(me, _e, Fe) {
    if (me + 1 < i.length) {
      var Me = _e + " " + i[me + 1][0];
      return km(Me, r, Fe).width <= o - 4;
    }
    return !1;
  };
  s++;
  e: for (; s > 0; ) {
    e = "", s--;
    var m, b, T = km("3", r, s).height, M = r.multiline ? l - s : (l - T) / 2, E = M += 2, D = 0, U = 0, q = 0;
    if (s <= 0) {
      e = `(...) Tj
`, e += "% Width of Text: " + km(e, r, s = 12).width + ", FieldWidth:" + o + `
`;
      break;
    }
    for (var G = "", Y = 0, he = 0; he < i.length; he++) if (i.hasOwnProperty(he)) {
      var X = !1;
      if (i[he].length !== 1 && q !== i[he].length - 1) {
        if ((T + 2) * (Y + 2) + 2 > l) continue e;
        G += i[he][q], X = !0, U = he, he--;
      } else {
        G = (G += i[he][q] + " ").substr(G.length - 1) == " " ? G.substr(0, G.length - 1) : G;
        var J = parseInt(he), ie = d(J, G, s), ye = he >= i.length - 1;
        if (ie && !ye) {
          G += " ", q = 0;
          continue;
        }
        if (ie || ye) {
          if (ye) U = J;
          else if (r.multiline && (T + 2) * (Y + 2) + 2 > l) continue e;
        } else {
          if (!r.multiline || (T + 2) * (Y + 2) + 2 > l) continue e;
          U = J;
        }
      }
      for (var oe = "", Re = D; Re <= U; Re++) {
        var Ne = i[Re];
        if (r.multiline) {
          if (Re === U) {
            oe += Ne[q] + " ", q = (q + 1) % Ne.length;
            continue;
          }
          if (Re === D) {
            oe += Ne[Ne.length - 1] + " ";
            continue;
          }
        }
        oe += Ne[0] + " ";
      }
      switch (oe = oe.substr(oe.length - 1) == " " ? oe.substr(0, oe.length - 1) : oe, b = km(oe, r, s).width, r.textAlign) {
        case "right":
          m = o - b - 2;
          break;
        case "center":
          m = (o - b) / 2;
          break;
        case "left":
        default:
          m = 2;
      }
      e += un(m) + " " + un(E) + ` Td
`, e += "(" + Of(oe) + `) Tj
`, e += -un(m) + ` 0 Td
`, E = -(s + 2), b = 0, D = X ? U : U + 1, Y++, G = "";
    }
    break;
  }
  return n.text = e, n.fontSize = s, n;
}, km = function(r, e, t) {
  var n = e.scope.internal.getFont(e.fontName, e.fontStyle), i = e.scope.getStringUnitWidth(r, { font: n, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t);
  return { height: e.scope.getStringUnitWidth("3", { font: n, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t) * 1.5, width: i };
}, TX = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, SX = function(r, e) {
  var t = { type: "reference", object: r };
  e.internal.getPageInfo(r.page).pageContext.annotations.find(function(n) {
    return n.type === t.type && n.object === t.object;
  }) === void 0 && e.internal.getPageInfo(r.page).pageContext.annotations.push(t);
}, EX = function(r, e) {
  for (var t in r) if (r.hasOwnProperty(t)) {
    var n = t, i = r[t];
    e.internal.newObjectDeferredBegin(i.objId, !0), ii(i) === "object" && typeof i.putStream == "function" && i.putStream(), delete r[n];
  }
}, CX = function(r, e) {
  if (e.scope = r, r.internal !== void 0 && (r.internal.acroformPlugin === void 0 || r.internal.acroformPlugin.isInitialized === !1)) {
    if (Bc.FieldNum = 0, r.internal.acroformPlugin = JSON.parse(JSON.stringify(TX)), r.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    rx = r.internal.scaleFactor, r.internal.acroformPlugin.acroFormDictionaryRoot = new dM(), r.internal.acroformPlugin.acroFormDictionaryRoot.scope = r, r.internal.acroformPlugin.acroFormDictionaryRoot._eventID = r.internal.events.subscribe("postPutResources", function() {
      (function(t) {
        t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t.internal.acroformPlugin.printedOut = !0;
      })(r);
    }), r.internal.events.subscribe("buildDocument", function() {
      (function(t) {
        t.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var n = t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var i in n) if (n.hasOwnProperty(i)) {
          var s = n[i];
          s.objId = void 0, s.hasAnnotation && SX(s, t);
        }
      })(r);
    }), r.internal.events.subscribe("putCatalog", function() {
      (function(t) {
        if (t.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        t.internal.write("/AcroForm " + t.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(r);
    }), r.internal.events.subscribe("postPutPages", function(t) {
      (function(n, i) {
        var s = !n;
        for (var l in n || (i.internal.newObjectDeferredBegin(i.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), i.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), n = n || i.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (n.hasOwnProperty(l)) {
          var o = n[l], d = [], m = o.Rect;
          if (o.Rect && (o.Rect = wX(o.Rect, i)), i.internal.newObjectDeferredBegin(o.objId, !0), o.DA = Dr.createDefaultAppearanceStream(o), ii(o) === "object" && typeof o.getKeyValueListForStream == "function" && (d = o.getKeyValueListForStream()), o.Rect = m, o.hasAppearanceStream && !o.appearanceStreamContent) {
            var b = AX(o);
            d.push({ key: "AP", value: "<</N " + b + ">>" }), i.internal.acroformPlugin.xForms.push(b);
          }
          if (o.appearanceStreamContent) {
            var T = "";
            for (var M in o.appearanceStreamContent) if (o.appearanceStreamContent.hasOwnProperty(M)) {
              var E = o.appearanceStreamContent[M];
              if (T += "/" + M + " ", T += "<<", Object.keys(E).length >= 1 || Array.isArray(E)) {
                for (var l in E) if (E.hasOwnProperty(l)) {
                  var D = E[l];
                  typeof D == "function" && (D = D.call(i, o)), T += "/" + l + " " + D + " ", i.internal.acroformPlugin.xForms.indexOf(D) >= 0 || i.internal.acroformPlugin.xForms.push(D);
                }
              } else typeof (D = E) == "function" && (D = D.call(i, o)), T += "/" + l + " " + D, i.internal.acroformPlugin.xForms.indexOf(D) >= 0 || i.internal.acroformPlugin.xForms.push(D);
              T += ">>";
            }
            d.push({ key: "AP", value: `<<
` + T + ">>" });
          }
          i.internal.putStream({ additionalKeyValues: d, objectId: o.objId }), i.internal.out("endobj");
        }
        s && EX(i.internal.acroformPlugin.xForms, i);
      })(t, r);
    }), r.internal.acroformPlugin.isInitialized = !0;
  }
}, hM = cs.__acroform__.arrayToPdfArray = function(r, e, t) {
  var n = function(l) {
    return l;
  };
  if (Array.isArray(r)) {
    for (var i = "[", s = 0; s < r.length; s++) switch (s !== 0 && (i += " "), ii(r[s])) {
      case "boolean":
      case "number":
      case "object":
        i += r[s].toString();
        break;
      case "string":
        r[s].substr(0, 1) !== "/" ? (e !== void 0 && t && (n = t.internal.getEncryptor(e)), i += "(" + Of(n(r[s].toString())) + ")") : i += r[s].toString();
    }
    return i += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, Wb = function(r, e, t) {
  var n = function(i) {
    return i;
  };
  return e !== void 0 && t && (n = t.internal.getEncryptor(e)), (r = r || "").toString(), r = "(" + Of(n(r)) + ")";
}, lu = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(r) {
    this._objId = r;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
lu.prototype.toString = function() {
  return this.objId + " 0 R";
}, lu.prototype.putStream = function() {
  var r = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: r, objectId: this.objId }), this.scope.internal.out("endobj");
}, lu.prototype.getKeyValueListForStream = function() {
  var r = [], e = Object.getOwnPropertyNames(this).filter(function(s) {
    return s != "content" && s != "appearanceStreamContent" && s != "scope" && s != "objId" && s.substring(0, 1) != "_";
  });
  for (var t in e) if (Object.getOwnPropertyDescriptor(this, e[t]).configurable === !1) {
    var n = e[t], i = this[n];
    i && (Array.isArray(i) ? r.push({ key: n, value: hM(i, this.objId, this.scope) }) : i instanceof lu ? (i.scope = this.scope, r.push({ key: n, value: i.objId + " 0 R" })) : typeof i != "function" && r.push({ key: n, value: i }));
  }
  return r;
};
var fM = function() {
  lu.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var r, e = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return e;
  }, set: function(t) {
    e = t;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(t) {
    r = t.trim();
  }, get: function() {
    return r || null;
  } });
};
Ea(fM, lu);
var dM = function() {
  lu.call(this);
  var r, e = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return e.length > 0 ? e : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return e;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (r) {
      var t = function(n) {
        return n;
      };
      return this.scope && (t = this.scope.internal.getEncryptor(this.objId)), "(" + Of(t(r)) + ")";
    }
  }, set: function(t) {
    r = t;
  } });
};
Ea(dM, lu);
var Bc = function r() {
  lu.call(this);
  var e = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(G) {
    if (isNaN(G)) throw new Error('Invalid value "' + G + '" for attribute F supplied.');
    e = G;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(e, 3);
  }, set: function(G) {
    G ? this.F = As(e, 3) : this.F = Ts(e, 3);
  } });
  var t = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(G) {
    if (isNaN(G)) throw new Error('Invalid value "' + G + '" for attribute Ff supplied.');
    t = G;
  } });
  var n = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (n.length !== 0) return n;
  }, set: function(G) {
    n = G !== void 0 ? G : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[0]) ? 0 : n[0];
  }, set: function(G) {
    n[0] = G;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[1]) ? 0 : n[1];
  }, set: function(G) {
    n[1] = G;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[2]) ? 0 : n[2];
  }, set: function(G) {
    n[2] = G;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !n || isNaN(n[3]) ? 0 : n[3];
  }, set: function(G) {
    n[3] = G;
  } });
  var i = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return i;
  }, set: function(G) {
    switch (G) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        i = G;
        break;
      default:
        throw new Error('Invalid value "' + G + '" for attribute FT supplied.');
    }
  } });
  var s = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!s || s.length < 1) {
      if (this instanceof Y_) return;
      s = "FieldObject" + r.FieldNum++;
    }
    var G = function(Y) {
      return Y;
    };
    return this.scope && (G = this.scope.internal.getEncryptor(this.objId)), "(" + Of(G(s)) + ")";
  }, set: function(G) {
    s = G.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return s;
  }, set: function(G) {
    s = G;
  } });
  var l = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return l;
  }, set: function(G) {
    l = G;
  } });
  var o = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return o;
  }, set: function(G) {
    o = G;
  } });
  var d = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return d;
  }, set: function(G) {
    d = G;
  } });
  var m = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return m === void 0 ? 50 / rx : m;
  }, set: function(G) {
    m = G;
  } });
  var b = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return b;
  }, set: function(G) {
    b = G;
  } });
  var T = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!T || this instanceof Y_ || this instanceof wf)) return Wb(T, this.objId, this.scope);
  }, set: function(G) {
    G = G.toString(), T = G;
  } });
  var M = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (M) return this instanceof ao ? M : Wb(M, this.objId, this.scope);
  }, set: function(G) {
    G = G.toString(), M = this instanceof ao ? G : G.substr(0, 1) === "(" ? ud(G.substr(1, G.length - 2)) : ud(G);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof ao ? ud(M.substr(1, M.length - 1)) : M;
  }, set: function(G) {
    G = G.toString(), M = this instanceof ao ? "/" + G : G;
  } });
  var E = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (E) return E;
  }, set: function(G) {
    this.V = G;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (E) return this instanceof ao ? E : Wb(E, this.objId, this.scope);
  }, set: function(G) {
    G = G.toString(), E = this instanceof ao ? G : G.substr(0, 1) === "(" ? ud(G.substr(1, G.length - 2)) : ud(G);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof ao ? ud(E.substr(1, E.length - 1)) : E;
  }, set: function(G) {
    G = G.toString(), E = this instanceof ao ? "/" + G : G;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var D, U = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return U;
  }, set: function(G) {
    G = !!G, U = G;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (D) return D;
  }, set: function(G) {
    D = G;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 1);
  }, set: function(G) {
    G ? this.Ff = As(this.Ff, 1) : this.Ff = Ts(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 2);
  }, set: function(G) {
    G ? this.Ff = As(this.Ff, 2) : this.Ff = Ts(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 3);
  }, set: function(G) {
    G ? this.Ff = As(this.Ff, 3) : this.Ff = Ts(this.Ff, 3);
  } });
  var q = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (q !== null) return q;
  }, set: function(G) {
    if ([0, 1, 2].indexOf(G) === -1) throw new Error('Invalid value "' + G + '" for attribute Q supplied.');
    q = G;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var G;
    switch (q) {
      case 0:
      default:
        G = "left";
        break;
      case 1:
        G = "center";
        break;
      case 2:
        G = "right";
    }
    return G;
  }, configurable: !0, enumerable: !0, set: function(G) {
    switch (G) {
      case "right":
      case 2:
        q = 2;
        break;
      case "center":
      case 1:
        q = 1;
        break;
      case "left":
      case 0:
      default:
        q = 0;
    }
  } });
};
Ea(Bc, lu);
var Bd = function() {
  Bc.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var r = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } });
  var e = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return hM(e, this.objId, this.scope);
  }, set: function(t) {
    var n, i;
    i = [], typeof (n = t) == "string" && (i = function(s, l, o) {
      o || (o = 1);
      for (var d, m = []; d = l.exec(s); ) m.push(d[o]);
      return m;
    }(n, /\((.*?)\)/g)), e = i;
  } }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t) {
    e = t, this.sort && e.sort();
  }, this.addOption = function(t) {
    t = (t = t || "").toString(), e.push(t), this.sort && e.sort();
  }, this.removeOption = function(t, n) {
    for (n = n || !1, t = (t = t || "").toString(); e.indexOf(t) !== -1 && (e.splice(e.indexOf(t), 1), n !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 18);
  }, set: function(t) {
    t ? this.Ff = As(this.Ff, 18) : this.Ff = Ts(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 19);
  }, set: function(t) {
    this.combo === !0 && (t ? this.Ff = As(this.Ff, 19) : this.Ff = Ts(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 20);
  }, set: function(t) {
    t ? (this.Ff = As(this.Ff, 20), e.sort()) : this.Ff = Ts(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 22);
  }, set: function(t) {
    t ? this.Ff = As(this.Ff, 22) : this.Ff = Ts(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = As(this.Ff, 23) : this.Ff = Ts(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 27);
  }, set: function(t) {
    t ? this.Ff = As(this.Ff, 27) : this.Ff = Ts(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
Ea(Bd, Bc);
var Ld = function() {
  Bd.call(this), this.fontName = "helvetica", this.combo = !1;
};
Ea(Ld, Bd);
var Od = function() {
  Ld.call(this), this.combo = !0;
};
Ea(Od, Ld);
var n_ = function() {
  Od.call(this), this.edit = !0;
};
Ea(n_, Od);
var ao = function() {
  Bc.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 15);
  }, set: function(t) {
    t ? this.Ff = As(this.Ff, 15) : this.Ff = Ts(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 16);
  }, set: function(t) {
    t ? this.Ff = As(this.Ff, 16) : this.Ff = Ts(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 17);
  }, set: function(t) {
    t ? this.Ff = As(this.Ff, 17) : this.Ff = Ts(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = As(this.Ff, 26) : this.Ff = Ts(this.Ff, 26);
  } });
  var r, e = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var t = function(s) {
      return s;
    };
    if (this.scope && (t = this.scope.internal.getEncryptor(this.objId)), Object.keys(e).length !== 0) {
      var n, i = [];
      for (n in i.push("<<"), e) i.push("/" + n + " (" + Of(t(e[n])) + ")");
      return i.push(">>"), i.join(`
`);
    }
  }, set: function(t) {
    ii(t) === "object" && (e = t);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return e.CA || "";
  }, set: function(t) {
    typeof t == "string" && (e.CA = t);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return r;
  }, set: function(t) {
    r = t;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return r.substr(1, r.length - 1);
  }, set: function(t) {
    r = "/" + t;
  } });
};
Ea(ao, Bc);
var i_ = function() {
  ao.call(this), this.pushButton = !0;
};
Ea(i_, ao);
var Nd = function() {
  ao.call(this), this.radio = !0, this.pushButton = !1;
  var r = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(e) {
    r = e !== void 0 ? e : [];
  } });
};
Ea(Nd, ao);
var Y_ = function() {
  var r, e;
  Bc.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return r;
  }, set: function(i) {
    r = i;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return e;
  }, set: function(i) {
    e = i;
  } });
  var t, n = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var i = function(o) {
      return o;
    };
    this.scope && (i = this.scope.internal.getEncryptor(this.objId));
    var s, l = [];
    for (s in l.push("<<"), n) l.push("/" + s + " (" + Of(i(n[s])) + ")");
    return l.push(">>"), l.join(`
`);
  }, set: function(i) {
    ii(i) === "object" && (n = i);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return n.CA || "";
  }, set: function(i) {
    typeof i == "string" && (n.CA = i);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(i) {
    t = i;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return t.substr(1, t.length - 1);
  }, set: function(i) {
    t = "/" + i;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = Dr.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
Ea(Y_, Bc), Nd.prototype.setAppearance = function(r) {
  if (!("createAppearanceStream" in r) || !("getCA" in r)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids) if (this.Kids.hasOwnProperty(e)) {
    var t = this.Kids[e];
    t.appearanceStreamContent = r.createAppearanceStream(t.optionName), t.caption = r.getCA();
  }
}, Nd.prototype.createOption = function(r) {
  var e = new Y_();
  return e.Parent = this, e.optionName = r, this.Kids.push(e), IX.call(this.scope, e), e;
};
var s_ = function() {
  ao.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = Dr.CheckBox.createAppearanceStream();
};
Ea(s_, ao);
var wf = function() {
  Bc.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 13);
  }, set: function(e) {
    e ? this.Ff = As(this.Ff, 13) : this.Ff = Ts(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 21);
  }, set: function(e) {
    e ? this.Ff = As(this.Ff, 21) : this.Ff = Ts(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = As(this.Ff, 23) : this.Ff = Ts(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 24);
  }, set: function(e) {
    e ? this.Ff = As(this.Ff, 24) : this.Ff = Ts(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 25);
  }, set: function(e) {
    e ? this.Ff = As(this.Ff, 25) : this.Ff = Ts(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = As(this.Ff, 26) : this.Ff = Ts(this.Ff, 26);
  } });
  var r = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(e) {
    r = e;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return r;
  }, set: function(e) {
    Number.isInteger(e) && (r = e);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
Ea(wf, Bc);
var o_ = function() {
  wf.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!ws(this.Ff, 14);
  }, set: function(r) {
    r ? this.Ff = As(this.Ff, 14) : this.Ff = Ts(this.Ff, 14);
  } }), this.password = !0;
};
Ea(o_, wf);
var Dr = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: Dr.CheckBox.YesNormal }, D: { On: Dr.CheckBox.YesPushDown, Off: Dr.CheckBox.OffPushDown } };
}, YesPushDown: function(r) {
  var e = nu(r);
  e.scope = r.scope;
  var t = [], n = r.scope.internal.getFont(r.fontName, r.fontStyle).id, i = r.scope.__private__.encodeColorString(r.color), s = Cv(r, r.caption);
  return t.push("0.749023 g"), t.push("0 0 " + un(Dr.internal.getWidth(r)) + " " + un(Dr.internal.getHeight(r)) + " re"), t.push("f"), t.push("BMC"), t.push("q"), t.push("0 0 1 rg"), t.push("/" + n + " " + un(s.fontSize) + " Tf " + i), t.push("BT"), t.push(s.text), t.push("ET"), t.push("Q"), t.push("EMC"), e.stream = t.join(`
`), e;
}, YesNormal: function(r) {
  var e = nu(r);
  e.scope = r.scope;
  var t = r.scope.internal.getFont(r.fontName, r.fontStyle).id, n = r.scope.__private__.encodeColorString(r.color), i = [], s = Dr.internal.getHeight(r), l = Dr.internal.getWidth(r), o = Cv(r, r.caption);
  return i.push("1 g"), i.push("0 0 " + un(l) + " " + un(s) + " re"), i.push("f"), i.push("q"), i.push("0 0 1 rg"), i.push("0 0 " + un(l - 1) + " " + un(s - 1) + " re"), i.push("W"), i.push("n"), i.push("0 g"), i.push("BT"), i.push("/" + t + " " + un(o.fontSize) + " Tf " + n), i.push(o.text), i.push("ET"), i.push("Q"), e.stream = i.join(`
`), e;
}, OffPushDown: function(r) {
  var e = nu(r);
  e.scope = r.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + un(Dr.internal.getWidth(r)) + " " + un(Dr.internal.getHeight(r)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} }, RadioButton: { Circle: { createAppearanceStream: function(r) {
  var e = { D: { Off: Dr.RadioButton.Circle.OffPushDown }, N: {} };
  return e.N[r] = Dr.RadioButton.Circle.YesNormal, e.D[r] = Dr.RadioButton.Circle.YesPushDown, e;
}, getCA: function() {
  return "l";
}, YesNormal: function(r) {
  var e = nu(r);
  e.scope = r.scope;
  var t = [], n = Dr.internal.getWidth(r) <= Dr.internal.getHeight(r) ? Dr.internal.getWidth(r) / 4 : Dr.internal.getHeight(r) / 4;
  n = Number((0.9 * n).toFixed(5));
  var i = Dr.internal.Bezier_C, s = Number((n * i).toFixed(5));
  return t.push("q"), t.push("1 0 0 1 " + gh(Dr.internal.getWidth(r) / 2) + " " + gh(Dr.internal.getHeight(r) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + s + " " + s + " " + n + " 0 " + n + " c"), t.push("-" + s + " " + n + " -" + n + " " + s + " -" + n + " 0 c"), t.push("-" + n + " -" + s + " -" + s + " -" + n + " 0 -" + n + " c"), t.push(s + " -" + n + " " + n + " -" + s + " " + n + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(r) {
  var e = nu(r);
  e.scope = r.scope;
  var t = [], n = Dr.internal.getWidth(r) <= Dr.internal.getHeight(r) ? Dr.internal.getWidth(r) / 4 : Dr.internal.getHeight(r) / 4;
  n = Number((0.9 * n).toFixed(5));
  var i = Number((2 * n).toFixed(5)), s = Number((i * Dr.internal.Bezier_C).toFixed(5)), l = Number((n * Dr.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + gh(Dr.internal.getWidth(r) / 2) + " " + gh(Dr.internal.getHeight(r) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), t.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), t.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), t.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), t.push("f"), t.push("Q"), t.push("0 g"), t.push("q"), t.push("1 0 0 1 " + gh(Dr.internal.getWidth(r) / 2) + " " + gh(Dr.internal.getHeight(r) / 2) + " cm"), t.push(n + " 0 m"), t.push(n + " " + l + " " + l + " " + n + " 0 " + n + " c"), t.push("-" + l + " " + n + " -" + n + " " + l + " -" + n + " 0 c"), t.push("-" + n + " -" + l + " -" + l + " -" + n + " 0 -" + n + " c"), t.push(l + " -" + n + " " + n + " -" + l + " " + n + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, OffPushDown: function(r) {
  var e = nu(r);
  e.scope = r.scope;
  var t = [], n = Dr.internal.getWidth(r) <= Dr.internal.getHeight(r) ? Dr.internal.getWidth(r) / 4 : Dr.internal.getHeight(r) / 4;
  n = Number((0.9 * n).toFixed(5));
  var i = Number((2 * n).toFixed(5)), s = Number((i * Dr.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + gh(Dr.internal.getWidth(r) / 2) + " " + gh(Dr.internal.getHeight(r) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + s + " " + s + " " + i + " 0 " + i + " c"), t.push("-" + s + " " + i + " -" + i + " " + s + " -" + i + " 0 c"), t.push("-" + i + " -" + s + " -" + s + " -" + i + " 0 -" + i + " c"), t.push(s + " -" + i + " " + i + " -" + s + " " + i + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
} }, Cross: { createAppearanceStream: function(r) {
  var e = { D: { Off: Dr.RadioButton.Cross.OffPushDown }, N: {} };
  return e.N[r] = Dr.RadioButton.Cross.YesNormal, e.D[r] = Dr.RadioButton.Cross.YesPushDown, e;
}, getCA: function() {
  return "8";
}, YesNormal: function(r) {
  var e = nu(r);
  e.scope = r.scope;
  var t = [], n = Dr.internal.calculateCross(r);
  return t.push("q"), t.push("1 1 " + un(Dr.internal.getWidth(r) - 2) + " " + un(Dr.internal.getHeight(r) - 2) + " re"), t.push("W"), t.push("n"), t.push(un(n.x1.x) + " " + un(n.x1.y) + " m"), t.push(un(n.x2.x) + " " + un(n.x2.y) + " l"), t.push(un(n.x4.x) + " " + un(n.x4.y) + " m"), t.push(un(n.x3.x) + " " + un(n.x3.y) + " l"), t.push("s"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(r) {
  var e = nu(r);
  e.scope = r.scope;
  var t = Dr.internal.calculateCross(r), n = [];
  return n.push("0.749023 g"), n.push("0 0 " + un(Dr.internal.getWidth(r)) + " " + un(Dr.internal.getHeight(r)) + " re"), n.push("f"), n.push("q"), n.push("1 1 " + un(Dr.internal.getWidth(r) - 2) + " " + un(Dr.internal.getHeight(r) - 2) + " re"), n.push("W"), n.push("n"), n.push(un(t.x1.x) + " " + un(t.x1.y) + " m"), n.push(un(t.x2.x) + " " + un(t.x2.y) + " l"), n.push(un(t.x4.x) + " " + un(t.x4.y) + " m"), n.push(un(t.x3.x) + " " + un(t.x3.y) + " l"), n.push("s"), n.push("Q"), e.stream = n.join(`
`), e;
}, OffPushDown: function(r) {
  var e = nu(r);
  e.scope = r.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + un(Dr.internal.getWidth(r)) + " " + un(Dr.internal.getHeight(r)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} } }, createDefaultAppearanceStream: function(r) {
  var e = r.scope.internal.getFont(r.fontName, r.fontStyle).id, t = r.scope.__private__.encodeColorString(r.color);
  return "/" + e + " " + r.fontSize + " Tf " + t;
} };
Dr.internal = { Bezier_C: 0.551915024494, calculateCross: function(r) {
  var e = Dr.internal.getWidth(r), t = Dr.internal.getHeight(r), n = Math.min(e, t);
  return { x1: { x: (e - n) / 2, y: (t - n) / 2 + n }, x2: { x: (e - n) / 2 + n, y: (t - n) / 2 }, x3: { x: (e - n) / 2, y: (t - n) / 2 }, x4: { x: (e - n) / 2 + n, y: (t - n) / 2 + n } };
} }, Dr.internal.getWidth = function(r) {
  var e = 0;
  return ii(r) === "object" && (e = _S(r.Rect[2])), e;
}, Dr.internal.getHeight = function(r) {
  var e = 0;
  return ii(r) === "object" && (e = _S(r.Rect[3])), e;
};
var IX = cs.addField = function(r) {
  if (CX(this, r), !(r instanceof Bc)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = r).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = !1, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), r.page = r.scope.internal.getCurrentPageInfo().pageNumber, this;
};
cs.AcroFormChoiceField = Bd, cs.AcroFormListBox = Ld, cs.AcroFormComboBox = Od, cs.AcroFormEditBox = n_, cs.AcroFormButton = ao, cs.AcroFormPushButton = i_, cs.AcroFormRadioButton = Nd, cs.AcroFormCheckBox = s_, cs.AcroFormTextField = wf, cs.AcroFormPasswordField = o_, cs.AcroFormAppearance = Dr, cs.AcroForm = { ChoiceField: Bd, ListBox: Ld, ComboBox: Od, EditBox: n_, Button: ao, PushButton: i_, RadioButton: Nd, CheckBox: s_, TextField: wf, PasswordField: o_, Appearance: Dr }, Jr.AcroForm = { ChoiceField: Bd, ListBox: Ld, ComboBox: Od, EditBox: n_, Button: ao, PushButton: i_, RadioButton: Nd, CheckBox: s_, TextField: wf, PasswordField: o_, Appearance: Dr };
function pM(r) {
  return r.reduce(function(e, t, n) {
    return e[t] = n, e;
  }, {});
}
(function(r) {
  r.__addimage__ = {};
  var e = "UNKNOWN", t = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, n = r.__addimage__.getImageFileTypeByImageData = function(me, _e) {
    var Fe, Me, Ct, ht, Pt, bt = e;
    if ((_e = _e || e) === "RGBA" || me.data !== void 0 && me.data instanceof Uint8ClampedArray && "height" in me && "width" in me) return "RGBA";
    if (ie(me)) for (Pt in t) for (Ct = t[Pt], Fe = 0; Fe < Ct.length; Fe += 1) {
      for (ht = !0, Me = 0; Me < Ct[Fe].length; Me += 1) if (Ct[Fe][Me] !== void 0 && Ct[Fe][Me] !== me[Me]) {
        ht = !1;
        break;
      }
      if (ht === !0) {
        bt = Pt;
        break;
      }
    }
    else for (Pt in t) for (Ct = t[Pt], Fe = 0; Fe < Ct.length; Fe += 1) {
      for (ht = !0, Me = 0; Me < Ct[Fe].length; Me += 1) if (Ct[Fe][Me] !== void 0 && Ct[Fe][Me] !== me.charCodeAt(Me)) {
        ht = !1;
        break;
      }
      if (ht === !0) {
        bt = Pt;
        break;
      }
    }
    return bt === e && _e !== e && (bt = _e), bt;
  }, i = function me(_e) {
    for (var Fe = this.internal.write, Me = this.internal.putStream, Ct = (0, this.internal.getFilters)(); Ct.indexOf("FlateEncode") !== -1; ) Ct.splice(Ct.indexOf("FlateEncode"), 1);
    _e.objectId = this.internal.newObject();
    var ht = [];
    if (ht.push({ key: "Type", value: "/XObject" }), ht.push({ key: "Subtype", value: "/Image" }), ht.push({ key: "Width", value: _e.width }), ht.push({ key: "Height", value: _e.height }), _e.colorSpace === q.INDEXED ? ht.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (_e.palette.length / 3 - 1) + " " + ("sMask" in _e && _e.sMask !== void 0 ? _e.objectId + 2 : _e.objectId + 1) + " 0 R]" }) : (ht.push({ key: "ColorSpace", value: "/" + _e.colorSpace }), _e.colorSpace === q.DEVICE_CMYK && ht.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), ht.push({ key: "BitsPerComponent", value: _e.bitsPerComponent }), "decodeParameters" in _e && _e.decodeParameters !== void 0 && ht.push({ key: "DecodeParms", value: "<<" + _e.decodeParameters + ">>" }), "transparency" in _e && Array.isArray(_e.transparency)) {
      for (var Pt = "", bt = 0, kt = _e.transparency.length; bt < kt; bt++) Pt += _e.transparency[bt] + " " + _e.transparency[bt] + " ";
      ht.push({ key: "Mask", value: "[" + Pt + "]" });
    }
    _e.sMask !== void 0 && ht.push({ key: "SMask", value: _e.objectId + 1 + " 0 R" });
    var Nt = _e.filter !== void 0 ? ["/" + _e.filter] : void 0;
    if (Me({ data: _e.data, additionalKeyValues: ht, alreadyAppliedFilters: Nt, objectId: _e.objectId }), Fe("endobj"), "sMask" in _e && _e.sMask !== void 0) {
      var mr = "/Predictor " + _e.predictor + " /Colors 1 /BitsPerComponent " + _e.bitsPerComponent + " /Columns " + _e.width, ce = { width: _e.width, height: _e.height, colorSpace: "DeviceGray", bitsPerComponent: _e.bitsPerComponent, decodeParameters: mr, data: _e.sMask };
      "filter" in _e && (ce.filter = _e.filter), me.call(this, ce);
    }
    if (_e.colorSpace === q.INDEXED) {
      var Be = this.internal.newObject();
      Me({ data: oe(new Uint8Array(_e.palette)), objectId: Be }), Fe("endobj");
    }
  }, s = function() {
    var me = this.internal.collections.addImage_images;
    for (var _e in me) i.call(this, me[_e]);
  }, l = function() {
    var me, _e = this.internal.collections.addImage_images, Fe = this.internal.write;
    for (var Me in _e) Fe("/I" + (me = _e[Me]).index, me.objectId, "0", "R");
  }, o = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", s), this.internal.events.subscribe("putXobjectDict", l));
  }, d = function() {
    var me = this.internal.collections.addImage_images;
    return o.call(this), me;
  }, m = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, b = function(me) {
    return typeof r["process" + me.toUpperCase()] == "function";
  }, T = function(me) {
    return ii(me) === "object" && me.nodeType === 1;
  }, M = function(me, _e) {
    if (me.nodeName === "IMG" && me.hasAttribute("src")) {
      var Fe = "" + me.getAttribute("src");
      if (Fe.indexOf("data:image/") === 0) return lg(unescape(Fe).split("base64,").pop());
      var Me = r.loadFile(Fe, !0);
      if (Me !== void 0) return Me;
    }
    if (me.nodeName === "CANVAS") {
      if (me.width === 0 || me.height === 0) throw new Error("Given canvas must have data. Canvas width: " + me.width + ", height: " + me.height);
      var Ct;
      switch (_e) {
        case "PNG":
          Ct = "image/png";
          break;
        case "WEBP":
          Ct = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          Ct = "image/jpeg";
      }
      return lg(me.toDataURL(Ct, 1).split("base64,").pop());
    }
  }, E = function(me) {
    var _e = this.internal.collections.addImage_images;
    if (_e) {
      for (var Fe in _e) if (me === _e[Fe].alias) return _e[Fe];
    }
  }, D = function(me, _e, Fe) {
    return me || _e || (me = -96, _e = -96), me < 0 && (me = -1 * Fe.width * 72 / me / this.internal.scaleFactor), _e < 0 && (_e = -1 * Fe.height * 72 / _e / this.internal.scaleFactor), me === 0 && (me = _e * Fe.width / Fe.height), _e === 0 && (_e = me * Fe.height / Fe.width), [me, _e];
  }, U = function(me, _e, Fe, Me, Ct, ht) {
    var Pt = D.call(this, Fe, Me, Ct), bt = this.internal.getCoordinateString, kt = this.internal.getVerticalCoordinateString, Nt = d.call(this);
    if (Fe = Pt[0], Me = Pt[1], Nt[Ct.index] = Ct, ht) {
      ht *= Math.PI / 180;
      var mr = Math.cos(ht), ce = Math.sin(ht), Be = function(Xe) {
        return Xe.toFixed(4);
      }, Ue = [Be(mr), Be(ce), Be(-1 * ce), Be(mr), 0, 0, "cm"];
    }
    this.internal.write("q"), ht ? (this.internal.write([1, "0", "0", 1, bt(me), kt(_e + Me), "cm"].join(" ")), this.internal.write(Ue.join(" ")), this.internal.write([bt(Fe), "0", "0", bt(Me), "0", "0", "cm"].join(" "))) : this.internal.write([bt(Fe), "0", "0", bt(Me), bt(me), kt(_e + Me), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + Ct.index + " Do"), this.internal.write("Q");
  }, q = r.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  r.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var G = r.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, Y = r.__addimage__.sHashCode = function(me) {
    var _e, Fe, Me = 0;
    if (typeof me == "string") for (Fe = me.length, _e = 0; _e < Fe; _e++) Me = (Me << 5) - Me + me.charCodeAt(_e), Me |= 0;
    else if (ie(me)) for (Fe = me.byteLength / 2, _e = 0; _e < Fe; _e++) Me = (Me << 5) - Me + me[_e], Me |= 0;
    return Me;
  }, he = r.__addimage__.validateStringAsBase64 = function(me) {
    (me = me || "").toString().trim();
    var _e = !0;
    return me.length === 0 && (_e = !1), me.length % 4 != 0 && (_e = !1), /^[A-Za-z0-9+/]+$/.test(me.substr(0, me.length - 2)) === !1 && (_e = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(me.substr(-2)) === !1 && (_e = !1), _e;
  }, X = r.__addimage__.extractImageFromDataUrl = function(me) {
    var _e = (me = me || "").split("base64,"), Fe = null;
    if (_e.length === 2) {
      var Me = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(_e[0]);
      Array.isArray(Me) && (Fe = { mimeType: Me[1], charset: Me[2], data: _e[1] });
    }
    return Fe;
  }, J = r.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  r.__addimage__.isArrayBuffer = function(me) {
    return J() && me instanceof ArrayBuffer;
  };
  var ie = r.__addimage__.isArrayBufferView = function(me) {
    return J() && typeof Uint32Array < "u" && (me instanceof Int8Array || me instanceof Uint8Array || typeof Uint8ClampedArray < "u" && me instanceof Uint8ClampedArray || me instanceof Int16Array || me instanceof Uint16Array || me instanceof Int32Array || me instanceof Uint32Array || me instanceof Float32Array || me instanceof Float64Array);
  }, ye = r.__addimage__.binaryStringToUint8Array = function(me) {
    for (var _e = me.length, Fe = new Uint8Array(_e), Me = 0; Me < _e; Me++) Fe[Me] = me.charCodeAt(Me);
    return Fe;
  }, oe = r.__addimage__.arrayBufferToBinaryString = function(me) {
    for (var _e = "", Fe = ie(me) ? me : new Uint8Array(me), Me = 0; Me < Fe.length; Me += 8192) _e += String.fromCharCode.apply(null, Fe.subarray(Me, Me + 8192));
    return _e;
  };
  r.addImage = function() {
    var me, _e, Fe, Me, Ct, ht, Pt, bt, kt;
    if (typeof arguments[1] == "number" ? (_e = e, Fe = arguments[1], Me = arguments[2], Ct = arguments[3], ht = arguments[4], Pt = arguments[5], bt = arguments[6], kt = arguments[7]) : (_e = arguments[1], Fe = arguments[2], Me = arguments[3], Ct = arguments[4], ht = arguments[5], Pt = arguments[6], bt = arguments[7], kt = arguments[8]), ii(me = arguments[0]) === "object" && !T(me) && "imageData" in me) {
      var Nt = me;
      me = Nt.imageData, _e = Nt.format || _e || e, Fe = Nt.x || Fe || 0, Me = Nt.y || Me || 0, Ct = Nt.w || Nt.width || Ct, ht = Nt.h || Nt.height || ht, Pt = Nt.alias || Pt, bt = Nt.compression || bt, kt = Nt.rotation || Nt.angle || kt;
    }
    var mr = this.internal.getFilters();
    if (bt === void 0 && mr.indexOf("FlateEncode") !== -1 && (bt = "SLOW"), isNaN(Fe) || isNaN(Me)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    o.call(this);
    var ce = Re.call(this, me, _e, Pt, bt);
    return U.call(this, Fe, Me, Ct, ht, ce, kt), this;
  };
  var Re = function(me, _e, Fe, Me) {
    var Ct, ht, Pt;
    if (typeof me == "string" && n(me) === e) {
      me = unescape(me);
      var bt = Ne(me, !1);
      (bt !== "" || (bt = r.loadFile(me, !0)) !== void 0) && (me = bt);
    }
    if (T(me) && (me = M(me, _e)), _e = n(me, _e), !b(_e)) throw new Error("addImage does not support files of type '" + _e + "', please ensure that a plugin for '" + _e + "' support is added.");
    if (((Pt = Fe) == null || Pt.length === 0) && (Fe = function(kt) {
      return typeof kt == "string" || ie(kt) ? Y(kt) : ie(kt.data) ? Y(kt.data) : null;
    }(me)), (Ct = E.call(this, Fe)) || (J() && (me instanceof Uint8Array || _e === "RGBA" || (ht = me, me = ye(me))), Ct = this["process" + _e.toUpperCase()](me, m.call(this), Fe, function(kt) {
      return kt && typeof kt == "string" && (kt = kt.toUpperCase()), kt in r.image_compression ? kt : G.NONE;
    }(Me), ht)), !Ct) throw new Error("An unknown error occurred whilst processing the image.");
    return Ct;
  }, Ne = r.__addimage__.convertBase64ToBinaryString = function(me, _e) {
    var Fe;
    _e = typeof _e != "boolean" || _e;
    var Me, Ct = "";
    if (typeof me == "string") {
      Me = (Fe = X(me)) !== null ? Fe.data : me;
      try {
        Ct = lg(Me);
      } catch (ht) {
        if (_e) throw he(Me) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + ht.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return Ct;
  };
  r.getImageProperties = function(me) {
    var _e, Fe, Me = "";
    if (T(me) && (me = M(me)), typeof me == "string" && n(me) === e && ((Me = Ne(me, !1)) === "" && (Me = r.loadFile(me) || ""), me = Me), Fe = n(me), !b(Fe)) throw new Error("addImage does not support files of type '" + Fe + "', please ensure that a plugin for '" + Fe + "' support is added.");
    if (!J() || me instanceof Uint8Array || (me = ye(me)), !(_e = this["process" + Fe.toUpperCase()](me))) throw new Error("An unknown error occurred whilst processing the image");
    return _e.fileType = Fe, _e;
  };
})(Jr.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function(t) {
    if (t !== void 0 && t != "") return !0;
  };
  Jr.API.events.push(["addPage", function(t) {
    this.internal.getPageInfo(t.pageNumber).pageContext.annotations = [];
  }]), r.events.push(["putPage", function(t) {
    for (var n, i, s, l = this.internal.getCoordinateString, o = this.internal.getVerticalCoordinateString, d = this.internal.getPageInfoByObjId(t.objId), m = t.pageContext.annotations, b = !1, T = 0; T < m.length && !b; T++) switch ((n = m[T]).type) {
      case "link":
        (e(n.options.url) || e(n.options.pageNumber)) && (b = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        b = !0;
    }
    if (b != 0) {
      this.internal.write("/Annots [");
      for (var M = 0; M < m.length; M++) {
        n = m[M];
        var E = this.internal.pdfEscape, D = this.internal.getEncryptor(t.objId);
        switch (n.type) {
          case "reference":
            this.internal.write(" " + n.object.objId + " 0 R ");
            break;
          case "text":
            var U = this.internal.newAdditionalObject(), q = this.internal.newAdditionalObject(), G = this.internal.getEncryptor(U.objId), Y = n.title || "Note";
            s = "<</Type /Annot /Subtype /Text " + (i = "/Rect [" + l(n.bounds.x) + " " + o(n.bounds.y + n.bounds.h) + " " + l(n.bounds.x + n.bounds.w) + " " + o(n.bounds.y) + "] ") + "/Contents (" + E(G(n.contents)) + ")", s += " /Popup " + q.objId + " 0 R", s += " /P " + d.objId + " 0 R", s += " /T (" + E(G(Y)) + ") >>", U.content = s;
            var he = U.objId + " 0 R";
            s = "<</Type /Annot /Subtype /Popup " + (i = "/Rect [" + l(n.bounds.x + 30) + " " + o(n.bounds.y + n.bounds.h) + " " + l(n.bounds.x + n.bounds.w + 30) + " " + o(n.bounds.y) + "] ") + " /Parent " + he, n.open && (s += " /Open true"), s += " >>", q.content = s, this.internal.write(U.objId, "0 R", q.objId, "0 R");
            break;
          case "freetext":
            i = "/Rect [" + l(n.bounds.x) + " " + o(n.bounds.y) + " " + l(n.bounds.x + n.bounds.w) + " " + o(n.bounds.y + n.bounds.h) + "] ";
            var X = n.color || "#000000";
            s = "<</Type /Annot /Subtype /FreeText " + i + "/Contents (" + E(D(n.contents)) + ")", s += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + X + ")", s += " /Border [0 0 0]", s += " >>", this.internal.write(s);
            break;
          case "link":
            if (n.options.name) {
              var J = this.annotations._nameMap[n.options.name];
              n.options.pageNumber = J.page, n.options.top = J.y;
            } else n.options.top || (n.options.top = 0);
            if (i = "/Rect [" + n.finalBounds.x + " " + n.finalBounds.y + " " + n.finalBounds.w + " " + n.finalBounds.h + "] ", s = "", n.options.url) s = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /A <</S /URI /URI (" + E(D(n.options.url)) + ") >>";
            else if (n.options.pageNumber) switch (s = "<</Type /Annot /Subtype /Link " + i + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(n.options.pageNumber).objId + " 0 R", n.options.magFactor = n.options.magFactor || "XYZ", n.options.magFactor) {
              case "Fit":
                s += " /Fit]";
                break;
              case "FitH":
                s += " /FitH " + n.options.top + "]";
                break;
              case "FitV":
                n.options.left = n.options.left || 0, s += " /FitV " + n.options.left + "]";
                break;
              case "XYZ":
              default:
                var ie = o(n.options.top);
                n.options.left = n.options.left || 0, n.options.zoom === void 0 && (n.options.zoom = 0), s += " /XYZ " + n.options.left + " " + ie + " " + n.options.zoom + "]";
            }
            s != "" && (s += " >>", this.internal.write(s));
        }
      }
      this.internal.write("]");
    }
  }]), r.createAnnotation = function(t) {
    var n = this.internal.getCurrentPageInfo();
    switch (t.type) {
      case "link":
        this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
        break;
      case "text":
      case "freetext":
        n.pageContext.annotations.push(t);
    }
  }, r.link = function(t, n, i, s, l) {
    var o = this.internal.getCurrentPageInfo(), d = this.internal.getCoordinateString, m = this.internal.getVerticalCoordinateString;
    o.pageContext.annotations.push({ finalBounds: { x: d(t), y: m(n), w: d(t + i), h: m(n + s) }, options: l, type: "link" });
  }, r.textWithLink = function(t, n, i, s) {
    var l, o, d = this.getTextWidth(t), m = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (s.maxWidth !== void 0) {
      o = s.maxWidth;
      var b = this.splitTextToSize(t, o).length;
      l = Math.ceil(m * b);
    } else o = d, l = m;
    return this.text(t, n, i, s), i += 0.2 * m, s.align === "center" && (n -= d / 2), s.align === "right" && (n -= d), this.link(n, i - m, o, l, s), d;
  }, r.getTextWidth = function(t) {
    var n = this.internal.getFontSize();
    return this.getStringUnitWidth(t) * n / this.internal.scaleFactor;
  };
}(Jr.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, t = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, n = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i = [1570, 1571, 1573, 1575];
  r.__arabicParser__ = {};
  var s = r.__arabicParser__.isInArabicSubstitutionA = function(U) {
    return e[U.charCodeAt(0)] !== void 0;
  }, l = r.__arabicParser__.isArabicLetter = function(U) {
    return typeof U == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(U);
  }, o = r.__arabicParser__.isArabicEndLetter = function(U) {
    return l(U) && s(U) && e[U.charCodeAt(0)].length <= 2;
  }, d = r.__arabicParser__.isArabicAlfLetter = function(U) {
    return l(U) && i.indexOf(U.charCodeAt(0)) >= 0;
  };
  r.__arabicParser__.arabicLetterHasIsolatedForm = function(U) {
    return l(U) && s(U) && e[U.charCodeAt(0)].length >= 1;
  };
  var m = r.__arabicParser__.arabicLetterHasFinalForm = function(U) {
    return l(U) && s(U) && e[U.charCodeAt(0)].length >= 2;
  };
  r.__arabicParser__.arabicLetterHasInitialForm = function(U) {
    return l(U) && s(U) && e[U.charCodeAt(0)].length >= 3;
  };
  var b = r.__arabicParser__.arabicLetterHasMedialForm = function(U) {
    return l(U) && s(U) && e[U.charCodeAt(0)].length == 4;
  }, T = r.__arabicParser__.resolveLigatures = function(U) {
    var q = 0, G = t, Y = "", he = 0;
    for (q = 0; q < U.length; q += 1) G[U.charCodeAt(q)] !== void 0 ? (he++, typeof (G = G[U.charCodeAt(q)]) == "number" && (Y += String.fromCharCode(G), G = t, he = 0), q === U.length - 1 && (G = t, Y += U.charAt(q - (he - 1)), q -= he - 1, he = 0)) : (G = t, Y += U.charAt(q - he), q -= he, he = 0);
    return Y;
  };
  r.__arabicParser__.isArabicDiacritic = function(U) {
    return U !== void 0 && n[U.charCodeAt(0)] !== void 0;
  };
  var M = r.__arabicParser__.getCorrectForm = function(U, q, G) {
    return l(U) ? s(U) === !1 ? -1 : !m(U) || !l(q) && !l(G) || !l(G) && o(q) || o(U) && !l(q) || o(U) && d(q) || o(U) && o(q) ? 0 : b(U) && l(q) && !o(q) && l(G) && m(G) ? 3 : o(U) || !l(G) ? 1 : 2 : -1;
  }, E = function(U) {
    var q = 0, G = 0, Y = 0, he = "", X = "", J = "", ie = (U = U || "").split("\\s+"), ye = [];
    for (q = 0; q < ie.length; q += 1) {
      for (ye.push(""), G = 0; G < ie[q].length; G += 1) he = ie[q][G], X = ie[q][G - 1], J = ie[q][G + 1], l(he) ? (Y = M(he, X, J), ye[q] += Y !== -1 ? String.fromCharCode(e[he.charCodeAt(0)][Y]) : he) : ye[q] += he;
      ye[q] = T(ye[q]);
    }
    return ye.join(" ");
  }, D = r.__arabicParser__.processArabic = r.processArabic = function() {
    var U, q = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, G = [];
    if (Array.isArray(q)) {
      var Y = 0;
      for (G = [], Y = 0; Y < q.length; Y += 1) Array.isArray(q[Y]) ? G.push([E(q[Y][0]), q[Y][1], q[Y][2]]) : G.push([E(q[Y])]);
      U = G;
    } else U = E(q);
    return typeof arguments[0] == "string" ? U : (arguments[0].text = U, arguments[0]);
  };
  r.events.push(["preProcessText", D]);
}(Jr.API), Jr.API.autoPrint = function(r) {
  var e;
  switch ((r = r || {}).variant = r.variant || "non-conform", r.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function() {
    var t = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t;
    }, set: function(o) {
      t = o;
    } });
    var n = 150;
    Object.defineProperty(this, "width", { get: function() {
      return n;
    }, set: function(o) {
      n = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 150 : o, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = n + 1);
    } });
    var i = 300;
    Object.defineProperty(this, "height", { get: function() {
      return i;
    }, set: function(o) {
      i = isNaN(o) || Number.isInteger(o) === !1 || o < 0 ? 300 : o, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = i + 1);
    } });
    var s = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return s;
    }, set: function(o) {
      s = o;
    } });
    var l = {};
    Object.defineProperty(this, "style", { get: function() {
      return l;
    }, set: function(o) {
      l = o;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e.prototype.getContext = function(t, n) {
    var i;
    if ((t = t || "2d") !== "2d") return null;
    for (i in n) this.pdf.context2d.hasOwnProperty(i) && (this.pdf.context2d[i] = n[i]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, r.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(Jr.API), function(r) {
  var e = { left: 0, top: 0, bottom: 0, right: 0 }, t = !1, n = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, e), this.internal.__cell__.margins.width = this.getPageWidth(), i.call(this));
  }, i = function() {
    this.internal.__cell__.lastCell = new s(), this.internal.__cell__.pages = 1;
  }, s = function() {
    var d = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return d;
    }, set: function(U) {
      d = U;
    } });
    var m = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return m;
    }, set: function(U) {
      m = U;
    } });
    var b = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return b;
    }, set: function(U) {
      b = U;
    } });
    var T = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return T;
    }, set: function(U) {
      T = U;
    } });
    var M = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return M;
    }, set: function(U) {
      M = U;
    } });
    var E = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return E;
    }, set: function(U) {
      E = U;
    } });
    var D = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return D;
    }, set: function(U) {
      D = U;
    } }), this;
  };
  s.prototype.clone = function() {
    return new s(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, s.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, r.setHeaderFunction = function(d) {
    return n.call(this), this.internal.__cell__.headerFunction = typeof d == "function" ? d : void 0, this;
  }, r.getTextDimensions = function(d, m) {
    n.call(this);
    var b = (m = m || {}).fontSize || this.getFontSize(), T = m.font || this.getFont(), M = m.scaleFactor || this.internal.scaleFactor, E = 0, D = 0, U = 0, q = this;
    if (!Array.isArray(d) && typeof d != "string") {
      if (typeof d != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      d = String(d);
    }
    var G = m.maxWidth;
    G > 0 ? typeof d == "string" ? d = this.splitTextToSize(d, G) : Object.prototype.toString.call(d) === "[object Array]" && (d = d.reduce(function(he, X) {
      return he.concat(q.splitTextToSize(X, G));
    }, [])) : d = Array.isArray(d) ? d : [d];
    for (var Y = 0; Y < d.length; Y++) E < (U = this.getStringUnitWidth(d[Y], { font: T }) * b) && (E = U);
    return E !== 0 && (D = d.length), { w: E /= M, h: Math.max((D * b * this.getLineHeightFactor() - b * (this.getLineHeightFactor() - 1)) / M, 0) };
  }, r.cellAddPage = function() {
    n.call(this), this.addPage();
    var d = this.internal.__cell__.margins || e;
    return this.internal.__cell__.lastCell = new s(d.left, d.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var l = r.cell = function() {
    var d;
    d = arguments[0] instanceof s ? arguments[0] : new s(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), n.call(this);
    var m = this.internal.__cell__.lastCell, b = this.internal.__cell__.padding, T = this.internal.__cell__.margins || e, M = this.internal.__cell__.tableHeaderRow, E = this.internal.__cell__.printHeaders;
    return m.lineNumber !== void 0 && (m.lineNumber === d.lineNumber ? (d.x = (m.x || 0) + (m.width || 0), d.y = m.y || 0) : m.y + m.height + d.height + T.bottom > this.getPageHeight() ? (this.cellAddPage(), d.y = T.top, E && M && (this.printHeaderRow(d.lineNumber, !0), d.y += M[0].height)) : d.y = m.y + m.height || d.y), d.text[0] !== void 0 && (this.rect(d.x, d.y, d.width, d.height, t === !0 ? "FD" : void 0), d.align === "right" ? this.text(d.text, d.x + d.width - b, d.y + b, { align: "right", baseline: "top" }) : d.align === "center" ? this.text(d.text, d.x + d.width / 2, d.y + b, { align: "center", baseline: "top", maxWidth: d.width - b - b }) : this.text(d.text, d.x + b, d.y + b, { align: "left", baseline: "top", maxWidth: d.width - b - b })), this.internal.__cell__.lastCell = d, this;
  };
  r.table = function(d, m, b, T, M) {
    if (n.call(this), !b) throw new Error("No data for PDF table.");
    var E, D, U, q, G = [], Y = [], he = [], X = {}, J = {}, ie = [], ye = [], oe = (M = M || {}).autoSize || !1, Re = M.printHeaders !== !1, Ne = M.css && M.css["font-size"] !== void 0 ? 16 * M.css["font-size"] : M.fontSize || 12, me = M.margins || Object.assign({ width: this.getPageWidth() }, e), _e = typeof M.padding == "number" ? M.padding : 3, Fe = M.headerBackgroundColor || "#c8c8c8", Me = M.headerTextColor || "#000";
    if (i.call(this), this.internal.__cell__.printHeaders = Re, this.internal.__cell__.margins = me, this.internal.__cell__.table_font_size = Ne, this.internal.__cell__.padding = _e, this.internal.__cell__.headerBackgroundColor = Fe, this.internal.__cell__.headerTextColor = Me, this.setFontSize(Ne), T == null) Y = G = Object.keys(b[0]), he = G.map(function() {
      return "left";
    });
    else if (Array.isArray(T) && ii(T[0]) === "object") for (G = T.map(function(Nt) {
      return Nt.name;
    }), Y = T.map(function(Nt) {
      return Nt.prompt || Nt.name || "";
    }), he = T.map(function(Nt) {
      return Nt.align || "left";
    }), E = 0; E < T.length; E += 1) J[T[E].name] = T[E].width * (19.049976 / 25.4);
    else Array.isArray(T) && typeof T[0] == "string" && (Y = G = T, he = G.map(function() {
      return "left";
    }));
    if (oe || Array.isArray(T) && typeof T[0] == "string") for (E = 0; E < G.length; E += 1) {
      for (X[q = G[E]] = b.map(function(Nt) {
        return Nt[q];
      }), this.setFont(void 0, "bold"), ie.push(this.getTextDimensions(Y[E], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), D = X[q], this.setFont(void 0, "normal"), U = 0; U < D.length; U += 1) ie.push(this.getTextDimensions(D[U], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      J[q] = Math.max.apply(null, ie) + _e + _e, ie = [];
    }
    if (Re) {
      var Ct = {};
      for (E = 0; E < G.length; E += 1) Ct[G[E]] = {}, Ct[G[E]].text = Y[E], Ct[G[E]].align = he[E];
      var ht = o.call(this, Ct, J);
      ye = G.map(function(Nt) {
        return new s(d, m, J[Nt], ht, Ct[Nt].text, void 0, Ct[Nt].align);
      }), this.setTableHeaderRow(ye), this.printHeaderRow(1, !1);
    }
    var Pt = T.reduce(function(Nt, mr) {
      return Nt[mr.name] = mr.align, Nt;
    }, {});
    for (E = 0; E < b.length; E += 1) {
      "rowStart" in M && M.rowStart instanceof Function && M.rowStart({ row: E, data: b[E] }, this);
      var bt = o.call(this, b[E], J);
      for (U = 0; U < G.length; U += 1) {
        var kt = b[E][G[U]];
        "cellStart" in M && M.cellStart instanceof Function && M.cellStart({ row: E, col: U, data: kt }, this), l.call(this, new s(d, m, J[G[U]], bt, kt, E + 2, Pt[G[U]]));
      }
    }
    return this.internal.__cell__.table_x = d, this.internal.__cell__.table_y = m, this;
  };
  var o = function(d, m) {
    var b = this.internal.__cell__.padding, T = this.internal.__cell__.table_font_size, M = this.internal.scaleFactor;
    return Object.keys(d).map(function(E) {
      var D = d[E];
      return this.splitTextToSize(D.hasOwnProperty("text") ? D.text : D, m[E] - b - b);
    }, this).map(function(E) {
      return this.getLineHeightFactor() * E.length * T / M + b + b;
    }, this).reduce(function(E, D) {
      return Math.max(E, D);
    }, 0);
  };
  r.setTableHeaderRow = function(d) {
    n.call(this), this.internal.__cell__.tableHeaderRow = d;
  }, r.printHeaderRow = function(d, m) {
    if (n.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var b;
    if (t = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var T = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new s(T[0], T[1], T[2], T[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var M = [], E = 0; E < this.internal.__cell__.tableHeaderRow.length; E += 1) {
      b = this.internal.__cell__.tableHeaderRow[E].clone(), m && (b.y = this.internal.__cell__.margins.top || 0, M.push(b)), b.lineNumber = d;
      var D = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), l.call(this, b), this.setTextColor(D);
    }
    M.length > 0 && this.setTableHeaderRow(M), this.setFont(void 0, "normal"), t = !1;
  };
}(Jr.API);
var gM = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, mM = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], Iv = pM(mM), _M = [100, 200, 300, 400, 500, 600, 700, 800, 900], MX = pM(_M);
function Mv(r) {
  var e = r.family.replace(/"|'/g, "").toLowerCase(), t = function(s) {
    return gM[s = s || "normal"] ? s : "normal";
  }(r.style), n = function(s) {
    if (!s) return 400;
    if (typeof s == "number") return s >= 100 && s <= 900 && s % 100 == 0 ? s : 400;
    if (/^\d00$/.test(s)) return parseInt(s);
    switch (s) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(r.weight), i = function(s) {
    return typeof Iv[s = s || "normal"] == "number" ? s : "normal";
  }(r.stretch);
  return { family: e, style: t, weight: n, stretch: i, src: r.src || [], ref: r.ref || { name: e, style: [i, t, n].join(" ") } };
}
function yS(r, e, t, n) {
  var i;
  for (i = t; i >= 0 && i < e.length; i += n) if (r[e[i]]) return r[e[i]];
  for (i = t; i >= 0 && i < e.length; i -= n) if (r[e[i]]) return r[e[i]];
}
var PX = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, bS = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function vS(r) {
  return [r.stretch, r.style, r.weight, r.family].join(" ");
}
function RX(r, e, t) {
  for (var n = (t = t || {}).defaultFontFamily || "times", i = Object.assign({}, PX, t.genericFontFamilies || {}), s = null, l = null, o = 0; o < e.length; ++o) if (i[(s = Mv(e[o])).family] && (s.family = i[s.family]), r.hasOwnProperty(s.family)) {
    l = r[s.family];
    break;
  }
  if (!(l = l || r[n])) throw new Error("Could not find a font-family for the rule '" + vS(s) + "' and default family '" + n + "'.");
  if (l = function(d, m) {
    if (m[d]) return m[d];
    var b = Iv[d], T = b <= Iv.normal ? -1 : 1, M = yS(m, mM, b, T);
    if (!M) throw new Error("Could not find a matching font-stretch value for " + d);
    return M;
  }(s.stretch, l), l = function(d, m) {
    if (m[d]) return m[d];
    for (var b = gM[d], T = 0; T < b.length; ++T) if (m[b[T]]) return m[b[T]];
    throw new Error("Could not find a matching font-style for " + d);
  }(s.style, l), !(l = function(d, m) {
    if (m[d]) return m[d];
    if (d === 400 && m[500]) return m[500];
    if (d === 500 && m[400]) return m[400];
    var b = MX[d], T = yS(m, _M, b, d < 400 ? -1 : 1);
    if (!T) throw new Error("Could not find a matching font-weight for value " + d);
    return T;
  }(s.weight, l))) throw new Error("Failed to resolve a font for the rule '" + vS(s) + "'.");
  return l;
}
function xS(r) {
  return r.trimLeft();
}
function BX(r, e) {
  for (var t = 0; t < r.length; ) {
    if (r.charAt(t) === e) return [r.substring(0, t), r.substring(t + 1)];
    t += 1;
  }
  return null;
}
function LX(r) {
  var e = r.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e === null ? null : [e[0], r.substring(e[0].length)];
}
var Fm, wS, AS, TS = ["times"];
(function(r) {
  var e, t, n, i, s, l, o, d, m, b = function(ce) {
    return ce = ce || {}, this.isStrokeTransparent = ce.isStrokeTransparent || !1, this.strokeOpacity = ce.strokeOpacity || 1, this.strokeStyle = ce.strokeStyle || "#000000", this.fillStyle = ce.fillStyle || "#000000", this.isFillTransparent = ce.isFillTransparent || !1, this.fillOpacity = ce.fillOpacity || 1, this.font = ce.font || "10px sans-serif", this.textBaseline = ce.textBaseline || "alphabetic", this.textAlign = ce.textAlign || "left", this.lineWidth = ce.lineWidth || 1, this.lineJoin = ce.lineJoin || "miter", this.lineCap = ce.lineCap || "butt", this.path = ce.path || [], this.transform = ce.transform !== void 0 ? ce.transform.clone() : new d(), this.globalCompositeOperation = ce.globalCompositeOperation || "normal", this.globalAlpha = ce.globalAlpha || 1, this.clip_path = ce.clip_path || [], this.currentPoint = ce.currentPoint || new l(), this.miterLimit = ce.miterLimit || 10, this.lastPoint = ce.lastPoint || new l(), this.lineDashOffset = ce.lineDashOffset || 0, this.lineDash = ce.lineDash || [], this.margin = ce.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = ce.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof ce.ignoreClearRect != "boolean" || ce.ignoreClearRect, this;
  };
  r.events.push(["initialized", function() {
    this.context2d = new T(this), e = this.internal.f2, t = this.internal.getCoordinateString, n = this.internal.getVerticalCoordinateString, i = this.internal.getHorizontalCoordinate, s = this.internal.getVerticalCoordinate, l = this.internal.Point, o = this.internal.Rectangle, d = this.internal.Matrix, m = new b();
  }]);
  var T = function(ce) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var Be = ce;
    Object.defineProperty(this, "pdf", { get: function() {
      return Be;
    } });
    var Ue = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return Ue;
    }, set: function(Ut) {
      Ue = !!Ut;
    } });
    var Xe = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Xe;
    }, set: function(Ut) {
      Xe = !!Ut;
    } });
    var it = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return it;
    }, set: function(Ut) {
      isNaN(Ut) || (it = Ut);
    } });
    var ft = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return ft;
    }, set: function(Ut) {
      isNaN(Ut) || (ft = Ut);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return m.margin;
    }, set: function(Ut) {
      var Ve;
      typeof Ut == "number" ? Ve = [Ut, Ut, Ut, Ut] : ((Ve = new Array(4))[0] = Ut[0], Ve[1] = Ut.length >= 2 ? Ut[1] : Ve[0], Ve[2] = Ut.length >= 3 ? Ut[2] : Ve[0], Ve[3] = Ut.length >= 4 ? Ut[3] : Ve[1]), m.margin = Ve;
    } });
    var St = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return St;
    }, set: function(Ut) {
      St = Ut;
    } });
    var wt = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return wt;
    }, set: function(Ut) {
      wt = Ut;
    } });
    var ar = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return ar;
    }, set: function(Ut) {
      ar = Ut;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return m;
    }, set: function(Ut) {
      Ut instanceof b && (m = Ut);
    } }), Object.defineProperty(this, "path", { get: function() {
      return m.path;
    }, set: function(Ut) {
      m.path = Ut;
    } });
    var Yt = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return Yt;
    }, set: function(Ut) {
      Yt = Ut;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(Ut) {
      var Ve;
      Ve = M(Ut), this.ctx.fillStyle = Ve.style, this.ctx.isFillTransparent = Ve.a === 0, this.ctx.fillOpacity = Ve.a, this.pdf.setFillColor(Ve.r, Ve.g, Ve.b, { a: Ve.a }), this.pdf.setTextColor(Ve.r, Ve.g, Ve.b, { a: Ve.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(Ut) {
      var Ve = M(Ut);
      this.ctx.strokeStyle = Ve.style, this.ctx.isStrokeTransparent = Ve.a === 0, this.ctx.strokeOpacity = Ve.a, Ve.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (Ve.a, this.pdf.setDrawColor(Ve.r, Ve.g, Ve.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(Ut) {
      ["butt", "round", "square"].indexOf(Ut) !== -1 && (this.ctx.lineCap = Ut, this.pdf.setLineCap(Ut));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(Ut) {
      isNaN(Ut) || (this.ctx.lineWidth = Ut, this.pdf.setLineWidth(Ut));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(Ut) {
      ["bevel", "round", "miter"].indexOf(Ut) !== -1 && (this.ctx.lineJoin = Ut, this.pdf.setLineJoin(Ut));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(Ut) {
      isNaN(Ut) || (this.ctx.miterLimit = Ut, this.pdf.setMiterLimit(Ut));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(Ut) {
      this.ctx.textBaseline = Ut;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(Ut) {
      ["right", "end", "center", "left", "start"].indexOf(Ut) !== -1 && (this.ctx.textAlign = Ut);
    } });
    var cr = null;
    function _r(Ut, Ve) {
      if (cr === null) {
        var jr = function(Ir) {
          var rr = [];
          return Object.keys(Ir).forEach(function(hr) {
            Ir[hr].forEach(function(wr) {
              var br = null;
              switch (wr) {
                case "bold":
                  br = { family: hr, weight: "bold" };
                  break;
                case "italic":
                  br = { family: hr, style: "italic" };
                  break;
                case "bolditalic":
                  br = { family: hr, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  br = { family: hr };
              }
              br !== null && (br.ref = { name: hr, style: wr }, rr.push(br));
            });
          }), rr;
        }(Ut.getFontList());
        cr = function(Ir) {
          for (var rr = {}, hr = 0; hr < Ir.length; ++hr) {
            var wr = Mv(Ir[hr]), br = wr.family, Rr = wr.stretch, $r = wr.style, Wr = wr.weight;
            rr[br] = rr[br] || {}, rr[br][Rr] = rr[br][Rr] || {}, rr[br][Rr][$r] = rr[br][Rr][$r] || {}, rr[br][Rr][$r][Wr] = wr;
          }
          return rr;
        }(jr.concat(Ve));
      }
      return cr;
    }
    var Cr = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return Cr;
    }, set: function(Ut) {
      cr = null, Cr = Ut;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(Ut) {
      var Ve;
      if (this.ctx.font = Ut, (Ve = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(Ut)) !== null) {
        var jr = Ve[1], Ir = (Ve[2], Ve[3]), rr = Ve[4], hr = (Ve[5], Ve[6]), wr = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(rr)[2];
        rr = Math.floor(wr === "px" ? parseFloat(rr) * this.pdf.internal.scaleFactor : wr === "em" ? parseFloat(rr) * this.pdf.getFontSize() : parseFloat(rr) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(rr);
        var br = function(Vr) {
          var en, Ar, Ii = [], bn = Vr.trim();
          if (bn === "") return TS;
          if (bn in bS) return [bS[bn]];
          for (; bn !== ""; ) {
            switch (Ar = null, en = (bn = xS(bn)).charAt(0)) {
              case '"':
              case "'":
                Ar = BX(bn.substring(1), en);
                break;
              default:
                Ar = LX(bn);
            }
            if (Ar === null || (Ii.push(Ar[0]), (bn = xS(Ar[1])) !== "" && bn.charAt(0) !== ",")) return TS;
            bn = bn.replace(/^,/, "");
          }
          return Ii;
        }(hr);
        if (this.fontFaces) {
          var Rr = RX(_r(this.pdf, this.fontFaces), br.map(function(Vr) {
            return { family: Vr, stretch: "normal", weight: Ir, style: jr };
          }));
          this.pdf.setFont(Rr.ref.name, Rr.ref.style);
        } else {
          var $r = "";
          (Ir === "bold" || parseInt(Ir, 10) >= 700 || jr === "bold") && ($r = "bold"), jr === "italic" && ($r += "italic"), $r.length === 0 && ($r = "normal");
          for (var Wr = "", Zr = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, hn = 0; hn < br.length; hn++) {
            if (this.pdf.internal.getFont(br[hn], $r, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Wr = br[hn];
              break;
            }
            if ($r === "bolditalic" && this.pdf.internal.getFont(br[hn], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) Wr = br[hn], $r = "bold";
            else if (this.pdf.internal.getFont(br[hn], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              Wr = br[hn], $r = "normal";
              break;
            }
          }
          if (Wr === "") {
            for (var yn = 0; yn < br.length; yn++) if (Zr[br[yn]]) {
              Wr = Zr[br[yn]];
              break;
            }
          }
          Wr = Wr === "" ? "Times" : Wr, this.pdf.setFont(Wr, $r);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(Ut) {
      this.ctx.globalCompositeOperation = Ut;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(Ut) {
      this.ctx.globalAlpha = Ut;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(Ut) {
      this.ctx.lineDashOffset = Ut, mr.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(Ut) {
      this.ctx.lineDash = Ut, mr.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(Ut) {
      this.ctx.ignoreClearRect = !!Ut;
    } });
  };
  T.prototype.setLineDash = function(ce) {
    this.lineDash = ce;
  }, T.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, T.prototype.fill = function() {
    X.call(this, "fill", !1);
  }, T.prototype.stroke = function() {
    X.call(this, "stroke", !1);
  }, T.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, T.prototype.moveTo = function(ce, Be) {
    if (isNaN(ce) || isNaN(Be)) throw vi.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var Ue = this.ctx.transform.applyToPoint(new l(ce, Be));
    this.path.push({ type: "mt", x: Ue.x, y: Ue.y }), this.ctx.lastPoint = new l(ce, Be);
  }, T.prototype.closePath = function() {
    var ce = new l(0, 0), Be = 0;
    for (Be = this.path.length - 1; Be !== -1; Be--) if (this.path[Be].type === "begin" && ii(this.path[Be + 1]) === "object" && typeof this.path[Be + 1].x == "number") {
      ce = new l(this.path[Be + 1].x, this.path[Be + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new l(ce.x, ce.y);
  }, T.prototype.lineTo = function(ce, Be) {
    if (isNaN(ce) || isNaN(Be)) throw vi.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var Ue = this.ctx.transform.applyToPoint(new l(ce, Be));
    this.path.push({ type: "lt", x: Ue.x, y: Ue.y }), this.ctx.lastPoint = new l(Ue.x, Ue.y);
  }, T.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), X.call(this, null, !0);
  }, T.prototype.quadraticCurveTo = function(ce, Be, Ue, Xe) {
    if (isNaN(Ue) || isNaN(Xe) || isNaN(ce) || isNaN(Be)) throw vi.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var it = this.ctx.transform.applyToPoint(new l(Ue, Xe)), ft = this.ctx.transform.applyToPoint(new l(ce, Be));
    this.path.push({ type: "qct", x1: ft.x, y1: ft.y, x: it.x, y: it.y }), this.ctx.lastPoint = new l(it.x, it.y);
  }, T.prototype.bezierCurveTo = function(ce, Be, Ue, Xe, it, ft) {
    if (isNaN(it) || isNaN(ft) || isNaN(ce) || isNaN(Be) || isNaN(Ue) || isNaN(Xe)) throw vi.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var St = this.ctx.transform.applyToPoint(new l(it, ft)), wt = this.ctx.transform.applyToPoint(new l(ce, Be)), ar = this.ctx.transform.applyToPoint(new l(Ue, Xe));
    this.path.push({ type: "bct", x1: wt.x, y1: wt.y, x2: ar.x, y2: ar.y, x: St.x, y: St.y }), this.ctx.lastPoint = new l(St.x, St.y);
  }, T.prototype.arc = function(ce, Be, Ue, Xe, it, ft) {
    if (isNaN(ce) || isNaN(Be) || isNaN(Ue) || isNaN(Xe) || isNaN(it)) throw vi.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (ft = !!ft, !this.ctx.transform.isIdentity) {
      var St = this.ctx.transform.applyToPoint(new l(ce, Be));
      ce = St.x, Be = St.y;
      var wt = this.ctx.transform.applyToPoint(new l(0, Ue)), ar = this.ctx.transform.applyToPoint(new l(0, 0));
      Ue = Math.sqrt(Math.pow(wt.x - ar.x, 2) + Math.pow(wt.y - ar.y, 2));
    }
    Math.abs(it - Xe) >= 2 * Math.PI && (Xe = 0, it = 2 * Math.PI), this.path.push({ type: "arc", x: ce, y: Be, radius: Ue, startAngle: Xe, endAngle: it, counterclockwise: ft });
  }, T.prototype.arcTo = function(ce, Be, Ue, Xe, it) {
    throw new Error("arcTo not implemented.");
  }, T.prototype.rect = function(ce, Be, Ue, Xe) {
    if (isNaN(ce) || isNaN(Be) || isNaN(Ue) || isNaN(Xe)) throw vi.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(ce, Be), this.lineTo(ce + Ue, Be), this.lineTo(ce + Ue, Be + Xe), this.lineTo(ce, Be + Xe), this.lineTo(ce, Be), this.lineTo(ce + Ue, Be), this.lineTo(ce, Be);
  }, T.prototype.fillRect = function(ce, Be, Ue, Xe) {
    if (isNaN(ce) || isNaN(Be) || isNaN(Ue) || isNaN(Xe)) throw vi.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!E.call(this)) {
      var it = {};
      this.lineCap !== "butt" && (it.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (it.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(ce, Be, Ue, Xe), this.fill(), it.hasOwnProperty("lineCap") && (this.lineCap = it.lineCap), it.hasOwnProperty("lineJoin") && (this.lineJoin = it.lineJoin);
    }
  }, T.prototype.strokeRect = function(ce, Be, Ue, Xe) {
    if (isNaN(ce) || isNaN(Be) || isNaN(Ue) || isNaN(Xe)) throw vi.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    D.call(this) || (this.beginPath(), this.rect(ce, Be, Ue, Xe), this.stroke());
  }, T.prototype.clearRect = function(ce, Be, Ue, Xe) {
    if (isNaN(ce) || isNaN(Be) || isNaN(Ue) || isNaN(Xe)) throw vi.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(ce, Be, Ue, Xe));
  }, T.prototype.save = function(ce) {
    ce = typeof ce != "boolean" || ce;
    for (var Be = this.pdf.internal.getCurrentPageInfo().pageNumber, Ue = 0; Ue < this.pdf.internal.getNumberOfPages(); Ue++) this.pdf.setPage(Ue + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(Be), ce) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Xe = new b(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Xe;
    }
  }, T.prototype.restore = function(ce) {
    ce = typeof ce != "boolean" || ce;
    for (var Be = this.pdf.internal.getCurrentPageInfo().pageNumber, Ue = 0; Ue < this.pdf.internal.getNumberOfPages(); Ue++) this.pdf.setPage(Ue + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(Be), ce && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, T.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var M = function(ce) {
    var Be, Ue, Xe, it;
    if (ce.isCanvasGradient === !0 && (ce = ce.getColor()), !ce) return { r: 0, g: 0, b: 0, a: 0, style: ce };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(ce)) Be = 0, Ue = 0, Xe = 0, it = 0;
    else {
      var ft = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(ce);
      if (ft !== null) Be = parseInt(ft[1]), Ue = parseInt(ft[2]), Xe = parseInt(ft[3]), it = 1;
      else if ((ft = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(ce)) !== null) Be = parseInt(ft[1]), Ue = parseInt(ft[2]), Xe = parseInt(ft[3]), it = parseFloat(ft[4]);
      else {
        if (it = 1, typeof ce == "string" && ce.charAt(0) !== "#") {
          var St = new lM(ce);
          ce = St.ok ? St.toHex() : "#000000";
        }
        ce.length === 4 ? (Be = ce.substring(1, 2), Be += Be, Ue = ce.substring(2, 3), Ue += Ue, Xe = ce.substring(3, 4), Xe += Xe) : (Be = ce.substring(1, 3), Ue = ce.substring(3, 5), Xe = ce.substring(5, 7)), Be = parseInt(Be, 16), Ue = parseInt(Ue, 16), Xe = parseInt(Xe, 16);
      }
    }
    return { r: Be, g: Ue, b: Xe, a: it, style: ce };
  }, E = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, D = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  T.prototype.fillText = function(ce, Be, Ue, Xe) {
    if (isNaN(Be) || isNaN(Ue) || typeof ce != "string") throw vi.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Xe = isNaN(Xe) ? void 0 : Xe, !E.call(this)) {
      var it = bt(this.ctx.transform.rotation), ft = this.ctx.transform.scaleX;
      _e.call(this, { text: ce, x: Be, y: Ue, scale: ft, angle: it, align: this.textAlign, maxWidth: Xe });
    }
  }, T.prototype.strokeText = function(ce, Be, Ue, Xe) {
    if (isNaN(Be) || isNaN(Ue) || typeof ce != "string") throw vi.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!D.call(this)) {
      Xe = isNaN(Xe) ? void 0 : Xe;
      var it = bt(this.ctx.transform.rotation), ft = this.ctx.transform.scaleX;
      _e.call(this, { text: ce, x: Be, y: Ue, scale: ft, renderingMode: "stroke", angle: it, align: this.textAlign, maxWidth: Xe });
    }
  }, T.prototype.measureText = function(ce) {
    if (typeof ce != "string") throw vi.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var Be = this.pdf, Ue = this.pdf.internal.scaleFactor, Xe = Be.internal.getFontSize(), it = Be.getStringUnitWidth(ce) * Xe / Be.internal.scaleFactor, ft = function(St) {
      var wt = (St = St || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return wt;
      } }), this;
    };
    return new ft({ width: it *= Math.round(96 * Ue / 72 * 1e4) / 1e4 });
  }, T.prototype.scale = function(ce, Be) {
    if (isNaN(ce) || isNaN(Be)) throw vi.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var Ue = new d(ce, 0, 0, Be, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(Ue);
  }, T.prototype.rotate = function(ce) {
    if (isNaN(ce)) throw vi.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var Be = new d(Math.cos(ce), Math.sin(ce), -Math.sin(ce), Math.cos(ce), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(Be);
  }, T.prototype.translate = function(ce, Be) {
    if (isNaN(ce) || isNaN(Be)) throw vi.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var Ue = new d(1, 0, 0, 1, ce, Be);
    this.ctx.transform = this.ctx.transform.multiply(Ue);
  }, T.prototype.transform = function(ce, Be, Ue, Xe, it, ft) {
    if (isNaN(ce) || isNaN(Be) || isNaN(Ue) || isNaN(Xe) || isNaN(it) || isNaN(ft)) throw vi.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var St = new d(ce, Be, Ue, Xe, it, ft);
    this.ctx.transform = this.ctx.transform.multiply(St);
  }, T.prototype.setTransform = function(ce, Be, Ue, Xe, it, ft) {
    ce = isNaN(ce) ? 1 : ce, Be = isNaN(Be) ? 0 : Be, Ue = isNaN(Ue) ? 0 : Ue, Xe = isNaN(Xe) ? 1 : Xe, it = isNaN(it) ? 0 : it, ft = isNaN(ft) ? 0 : ft, this.ctx.transform = new d(ce, Be, Ue, Xe, it, ft);
  };
  var U = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  T.prototype.drawImage = function(ce, Be, Ue, Xe, it, ft, St, wt, ar) {
    var Yt = this.pdf.getImageProperties(ce), cr = 1, _r = 1, Cr = 1, Ut = 1;
    Xe !== void 0 && wt !== void 0 && (Cr = wt / Xe, Ut = ar / it, cr = Yt.width / Xe * wt / Xe, _r = Yt.height / it * ar / it), ft === void 0 && (ft = Be, St = Ue, Be = 0, Ue = 0), Xe !== void 0 && wt === void 0 && (wt = Xe, ar = it), Xe === void 0 && wt === void 0 && (wt = Yt.width, ar = Yt.height);
    for (var Ve, jr = this.ctx.transform.decompose(), Ir = bt(jr.rotate.shx), rr = new d(), hr = (rr = (rr = (rr = rr.multiply(jr.translate)).multiply(jr.skew)).multiply(jr.scale)).applyToRectangle(new o(ft - Be * Cr, St - Ue * Ut, Xe * cr, it * _r)), wr = q.call(this, hr), br = [], Rr = 0; Rr < wr.length; Rr += 1) br.indexOf(wr[Rr]) === -1 && br.push(wr[Rr]);
    if (he(br), this.autoPaging) for (var $r = br[0], Wr = br[br.length - 1], Zr = $r; Zr < Wr + 1; Zr++) {
      this.pdf.setPage(Zr);
      var hn = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], yn = Zr === 1 ? this.posY + this.margin[0] : this.margin[0], Vr = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], en = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Ar = Zr === 1 ? 0 : Vr + (Zr - 2) * en;
      if (this.ctx.clip_path.length !== 0) {
        var Ii = this.path;
        Ve = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = Y(Ve, this.posX + this.margin[3], -Ar + yn + this.ctx.prevPageLastElemOffset), J.call(this, "fill", !0), this.path = Ii;
      }
      var bn = JSON.parse(JSON.stringify(hr));
      bn = Y([bn], this.posX + this.margin[3], -Ar + yn + this.ctx.prevPageLastElemOffset)[0];
      var Xi = (Zr > $r || Zr < Wr) && U.call(this);
      Xi && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], hn, en, null).clip().discardPath()), this.pdf.addImage(ce, "JPEG", bn.x, bn.y, bn.w, bn.h, null, null, Ir), Xi && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(ce, "JPEG", hr.x, hr.y, hr.w, hr.h, null, null, Ir);
  };
  var q = function(ce, Be, Ue) {
    var Xe = [];
    Be = Be || this.pdf.internal.pageSize.width, Ue = Ue || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var it = this.posY + this.ctx.prevPageLastElemOffset;
    switch (ce.type) {
      default:
      case "mt":
      case "lt":
        Xe.push(Math.floor((ce.y + it) / Ue) + 1);
        break;
      case "arc":
        Xe.push(Math.floor((ce.y + it - ce.radius) / Ue) + 1), Xe.push(Math.floor((ce.y + it + ce.radius) / Ue) + 1);
        break;
      case "qct":
        var ft = kt(this.ctx.lastPoint.x, this.ctx.lastPoint.y, ce.x1, ce.y1, ce.x, ce.y);
        Xe.push(Math.floor((ft.y + it) / Ue) + 1), Xe.push(Math.floor((ft.y + ft.h + it) / Ue) + 1);
        break;
      case "bct":
        var St = Nt(this.ctx.lastPoint.x, this.ctx.lastPoint.y, ce.x1, ce.y1, ce.x2, ce.y2, ce.x, ce.y);
        Xe.push(Math.floor((St.y + it) / Ue) + 1), Xe.push(Math.floor((St.y + St.h + it) / Ue) + 1);
        break;
      case "rect":
        Xe.push(Math.floor((ce.y + it) / Ue) + 1), Xe.push(Math.floor((ce.y + ce.h + it) / Ue) + 1);
    }
    for (var wt = 0; wt < Xe.length; wt += 1) for (; this.pdf.internal.getNumberOfPages() < Xe[wt]; ) G.call(this);
    return Xe;
  }, G = function() {
    var ce = this.fillStyle, Be = this.strokeStyle, Ue = this.font, Xe = this.lineCap, it = this.lineWidth, ft = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = ce, this.strokeStyle = Be, this.font = Ue, this.lineCap = Xe, this.lineWidth = it, this.lineJoin = ft;
  }, Y = function(ce, Be, Ue) {
    for (var Xe = 0; Xe < ce.length; Xe++) switch (ce[Xe].type) {
      case "bct":
        ce[Xe].x2 += Be, ce[Xe].y2 += Ue;
      case "qct":
        ce[Xe].x1 += Be, ce[Xe].y1 += Ue;
      case "mt":
      case "lt":
      case "arc":
      default:
        ce[Xe].x += Be, ce[Xe].y += Ue;
    }
    return ce;
  }, he = function(ce) {
    return ce.sort(function(Be, Ue) {
      return Be - Ue;
    });
  }, X = function(ce, Be) {
    for (var Ue, Xe, it = this.fillStyle, ft = this.strokeStyle, St = this.lineCap, wt = this.lineWidth, ar = Math.abs(wt * this.ctx.transform.scaleX), Yt = this.lineJoin, cr = JSON.parse(JSON.stringify(this.path)), _r = JSON.parse(JSON.stringify(this.path)), Cr = [], Ut = 0; Ut < _r.length; Ut++) if (_r[Ut].x !== void 0) for (var Ve = q.call(this, _r[Ut]), jr = 0; jr < Ve.length; jr += 1) Cr.indexOf(Ve[jr]) === -1 && Cr.push(Ve[jr]);
    for (var Ir = 0; Ir < Cr.length; Ir++) for (; this.pdf.internal.getNumberOfPages() < Cr[Ir]; ) G.call(this);
    if (he(Cr), this.autoPaging) for (var rr = Cr[0], hr = Cr[Cr.length - 1], wr = rr; wr < hr + 1; wr++) {
      this.pdf.setPage(wr), this.fillStyle = it, this.strokeStyle = ft, this.lineCap = St, this.lineWidth = ar, this.lineJoin = Yt;
      var br = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Rr = wr === 1 ? this.posY + this.margin[0] : this.margin[0], $r = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Wr = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Zr = wr === 1 ? 0 : $r + (wr - 2) * Wr;
      if (this.ctx.clip_path.length !== 0) {
        var hn = this.path;
        Ue = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = Y(Ue, this.posX + this.margin[3], -Zr + Rr + this.ctx.prevPageLastElemOffset), J.call(this, ce, !0), this.path = hn;
      }
      if (Xe = JSON.parse(JSON.stringify(cr)), this.path = Y(Xe, this.posX + this.margin[3], -Zr + Rr + this.ctx.prevPageLastElemOffset), Be === !1 || wr === 0) {
        var yn = (wr > rr || wr < hr) && U.call(this);
        yn && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], br, Wr, null).clip().discardPath()), J.call(this, ce, Be), yn && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = wt;
    }
    else this.lineWidth = ar, J.call(this, ce, Be), this.lineWidth = wt;
    this.path = cr;
  }, J = function(ce, Be) {
    if ((ce !== "stroke" || Be || !D.call(this)) && (ce === "stroke" || Be || !E.call(this))) {
      for (var Ue, Xe, it = [], ft = this.path, St = 0; St < ft.length; St++) {
        var wt = ft[St];
        switch (wt.type) {
          case "begin":
            it.push({ begin: !0 });
            break;
          case "close":
            it.push({ close: !0 });
            break;
          case "mt":
            it.push({ start: wt, deltas: [], abs: [] });
            break;
          case "lt":
            var ar = it.length;
            if (ft[St - 1] && !isNaN(ft[St - 1].x) && (Ue = [wt.x - ft[St - 1].x, wt.y - ft[St - 1].y], ar > 0)) {
              for (; ar >= 0; ar--) if (it[ar - 1].close !== !0 && it[ar - 1].begin !== !0) {
                it[ar - 1].deltas.push(Ue), it[ar - 1].abs.push(wt);
                break;
              }
            }
            break;
          case "bct":
            Ue = [wt.x1 - ft[St - 1].x, wt.y1 - ft[St - 1].y, wt.x2 - ft[St - 1].x, wt.y2 - ft[St - 1].y, wt.x - ft[St - 1].x, wt.y - ft[St - 1].y], it[it.length - 1].deltas.push(Ue);
            break;
          case "qct":
            var Yt = ft[St - 1].x + 2 / 3 * (wt.x1 - ft[St - 1].x), cr = ft[St - 1].y + 2 / 3 * (wt.y1 - ft[St - 1].y), _r = wt.x + 2 / 3 * (wt.x1 - wt.x), Cr = wt.y + 2 / 3 * (wt.y1 - wt.y), Ut = wt.x, Ve = wt.y;
            Ue = [Yt - ft[St - 1].x, cr - ft[St - 1].y, _r - ft[St - 1].x, Cr - ft[St - 1].y, Ut - ft[St - 1].x, Ve - ft[St - 1].y], it[it.length - 1].deltas.push(Ue);
            break;
          case "arc":
            it.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(it[it.length - 1].abs) && it[it.length - 1].abs.push(wt);
        }
      }
      Xe = Be ? null : ce === "stroke" ? "stroke" : "fill";
      for (var jr = !1, Ir = 0; Ir < it.length; Ir++) if (it[Ir].arc) for (var rr = it[Ir].abs, hr = 0; hr < rr.length; hr++) {
        var wr = rr[hr];
        wr.type === "arc" ? oe.call(this, wr.x, wr.y, wr.radius, wr.startAngle, wr.endAngle, wr.counterclockwise, void 0, Be, !jr) : Fe.call(this, wr.x, wr.y), jr = !0;
      }
      else if (it[Ir].close === !0) this.pdf.internal.out("h"), jr = !1;
      else if (it[Ir].begin !== !0) {
        var br = it[Ir].start.x, Rr = it[Ir].start.y;
        Me.call(this, it[Ir].deltas, br, Rr), jr = !0;
      }
      Xe && Re.call(this, Xe), Be && Ne.call(this);
    }
  }, ie = function(ce) {
    var Be = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, Ue = Be * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return ce - Ue;
      case "top":
        return ce + Be - Ue;
      case "hanging":
        return ce + Be - 2 * Ue;
      case "middle":
        return ce + Be / 2 - Ue;
      case "ideographic":
        return ce;
      case "alphabetic":
      default:
        return ce;
    }
  }, ye = function(ce) {
    return ce + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  T.prototype.createLinearGradient = function() {
    var ce = function() {
    };
    return ce.colorStops = [], ce.addColorStop = function(Be, Ue) {
      this.colorStops.push([Be, Ue]);
    }, ce.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, ce.isCanvasGradient = !0, ce;
  }, T.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, T.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var oe = function(ce, Be, Ue, Xe, it, ft, St, wt, ar) {
    for (var Yt = ht.call(this, Ue, Xe, it, ft), cr = 0; cr < Yt.length; cr++) {
      var _r = Yt[cr];
      cr === 0 && (ar ? me.call(this, _r.x1 + ce, _r.y1 + Be) : Fe.call(this, _r.x1 + ce, _r.y1 + Be)), Ct.call(this, ce, Be, _r.x2, _r.y2, _r.x3, _r.y3, _r.x4, _r.y4);
    }
    wt ? Ne.call(this) : Re.call(this, St);
  }, Re = function(ce) {
    switch (ce) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, Ne = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, me = function(ce, Be) {
    this.pdf.internal.out(t(ce) + " " + n(Be) + " m");
  }, _e = function(ce) {
    var Be;
    switch (ce.align) {
      case "right":
      case "end":
        Be = "right";
        break;
      case "center":
        Be = "center";
        break;
      case "left":
      case "start":
      default:
        Be = "left";
    }
    var Ue = this.pdf.getTextDimensions(ce.text), Xe = ie.call(this, ce.y), it = ye.call(this, Xe) - Ue.h, ft = this.ctx.transform.applyToPoint(new l(ce.x, Xe)), St = this.ctx.transform.decompose(), wt = new d();
    wt = (wt = (wt = wt.multiply(St.translate)).multiply(St.skew)).multiply(St.scale);
    for (var ar, Yt, cr, _r = this.ctx.transform.applyToRectangle(new o(ce.x, Xe, Ue.w, Ue.h)), Cr = wt.applyToRectangle(new o(ce.x, it, Ue.w, Ue.h)), Ut = q.call(this, Cr), Ve = [], jr = 0; jr < Ut.length; jr += 1) Ve.indexOf(Ut[jr]) === -1 && Ve.push(Ut[jr]);
    if (he(Ve), this.autoPaging) for (var Ir = Ve[0], rr = Ve[Ve.length - 1], hr = Ir; hr < rr + 1; hr++) {
      this.pdf.setPage(hr);
      var wr = hr === 1 ? this.posY + this.margin[0] : this.margin[0], br = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Rr = this.pdf.internal.pageSize.height - this.margin[2], $r = Rr - this.margin[0], Wr = this.pdf.internal.pageSize.width - this.margin[1], Zr = Wr - this.margin[3], hn = hr === 1 ? 0 : br + (hr - 2) * $r;
      if (this.ctx.clip_path.length !== 0) {
        var yn = this.path;
        ar = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = Y(ar, this.posX + this.margin[3], -1 * hn + wr), J.call(this, "fill", !0), this.path = yn;
      }
      var Vr = Y([JSON.parse(JSON.stringify(Cr))], this.posX + this.margin[3], -hn + wr + this.ctx.prevPageLastElemOffset)[0];
      ce.scale >= 0.01 && (Yt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Yt * ce.scale), cr = this.lineWidth, this.lineWidth = cr * ce.scale);
      var en = this.autoPaging !== "text";
      if (en || Vr.y + Vr.h <= Rr) {
        if (en || Vr.y >= wr && Vr.x <= Wr) {
          var Ar = en ? ce.text : this.pdf.splitTextToSize(ce.text, ce.maxWidth || Wr - Vr.x)[0], Ii = Y([JSON.parse(JSON.stringify(_r))], this.posX + this.margin[3], -hn + wr + this.ctx.prevPageLastElemOffset)[0], bn = en && (hr > Ir || hr < rr) && U.call(this);
          bn && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Zr, $r, null).clip().discardPath()), this.pdf.text(Ar, Ii.x, Ii.y, { angle: ce.angle, align: Be, renderingMode: ce.renderingMode }), bn && this.pdf.restoreGraphicsState();
        }
      } else Vr.y < Rr && (this.ctx.prevPageLastElemOffset += Rr - Vr.y);
      ce.scale >= 0.01 && (this.pdf.setFontSize(Yt), this.lineWidth = cr);
    }
    else ce.scale >= 0.01 && (Yt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Yt * ce.scale), cr = this.lineWidth, this.lineWidth = cr * ce.scale), this.pdf.text(ce.text, ft.x + this.posX, ft.y + this.posY, { angle: ce.angle, align: Be, renderingMode: ce.renderingMode, maxWidth: ce.maxWidth }), ce.scale >= 0.01 && (this.pdf.setFontSize(Yt), this.lineWidth = cr);
  }, Fe = function(ce, Be, Ue, Xe) {
    Ue = Ue || 0, Xe = Xe || 0, this.pdf.internal.out(t(ce + Ue) + " " + n(Be + Xe) + " l");
  }, Me = function(ce, Be, Ue) {
    return this.pdf.lines(ce, Be, Ue, null, null);
  }, Ct = function(ce, Be, Ue, Xe, it, ft, St, wt) {
    this.pdf.internal.out([e(i(Ue + ce)), e(s(Xe + Be)), e(i(it + ce)), e(s(ft + Be)), e(i(St + ce)), e(s(wt + Be)), "c"].join(" "));
  }, ht = function(ce, Be, Ue, Xe) {
    for (var it = 2 * Math.PI, ft = Math.PI / 2; Be > Ue; ) Be -= it;
    var St = Math.abs(Ue - Be);
    St < it && Xe && (St = it - St);
    for (var wt = [], ar = Xe ? -1 : 1, Yt = Be; St > 1e-5; ) {
      var cr = Yt + ar * Math.min(St, ft);
      wt.push(Pt.call(this, ce, Yt, cr)), St -= Math.abs(cr - Yt), Yt = cr;
    }
    return wt;
  }, Pt = function(ce, Be, Ue) {
    var Xe = (Ue - Be) / 2, it = ce * Math.cos(Xe), ft = ce * Math.sin(Xe), St = it, wt = -ft, ar = St * St + wt * wt, Yt = ar + St * it + wt * ft, cr = 4 / 3 * (Math.sqrt(2 * ar * Yt) - Yt) / (St * ft - wt * it), _r = St - cr * wt, Cr = wt + cr * St, Ut = _r, Ve = -Cr, jr = Xe + Be, Ir = Math.cos(jr), rr = Math.sin(jr);
    return { x1: ce * Math.cos(Be), y1: ce * Math.sin(Be), x2: _r * Ir - Cr * rr, y2: _r * rr + Cr * Ir, x3: Ut * Ir - Ve * rr, y3: Ut * rr + Ve * Ir, x4: ce * Math.cos(Ue), y4: ce * Math.sin(Ue) };
  }, bt = function(ce) {
    return 180 * ce / Math.PI;
  }, kt = function(ce, Be, Ue, Xe, it, ft) {
    var St = ce + 0.5 * (Ue - ce), wt = Be + 0.5 * (Xe - Be), ar = it + 0.5 * (Ue - it), Yt = ft + 0.5 * (Xe - ft), cr = Math.min(ce, it, St, ar), _r = Math.max(ce, it, St, ar), Cr = Math.min(Be, ft, wt, Yt), Ut = Math.max(Be, ft, wt, Yt);
    return new o(cr, Cr, _r - cr, Ut - Cr);
  }, Nt = function(ce, Be, Ue, Xe, it, ft, St, wt) {
    var ar, Yt, cr, _r, Cr, Ut, Ve, jr, Ir, rr, hr, wr, br, Rr, $r = Ue - ce, Wr = Xe - Be, Zr = it - Ue, hn = ft - Xe, yn = St - it, Vr = wt - ft;
    for (Yt = 0; Yt < 41; Yt++) Ir = (Ve = (cr = ce + (ar = Yt / 40) * $r) + ar * ((Cr = Ue + ar * Zr) - cr)) + ar * (Cr + ar * (it + ar * yn - Cr) - Ve), rr = (jr = (_r = Be + ar * Wr) + ar * ((Ut = Xe + ar * hn) - _r)) + ar * (Ut + ar * (ft + ar * Vr - Ut) - jr), Yt == 0 ? (hr = Ir, wr = rr, br = Ir, Rr = rr) : (hr = Math.min(hr, Ir), wr = Math.min(wr, rr), br = Math.max(br, Ir), Rr = Math.max(Rr, rr));
    return new o(Math.round(hr), Math.round(wr), Math.round(br - hr), Math.round(Rr - wr));
  }, mr = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var ce, Be, Ue = (ce = this.ctx.lineDash, Be = this.ctx.lineDashOffset, JSON.stringify({ lineDash: ce, lineDashOffset: Be }));
      this.prevLineDash !== Ue && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = Ue);
    }
  };
})(Jr.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function(s) {
    var l, o, d, m, b, T, M, E, D, U;
    for (o = [], d = 0, m = (s += l = "\0\0\0\0".slice(s.length % 4 || 4)).length; m > d; d += 4) (b = (s.charCodeAt(d) << 24) + (s.charCodeAt(d + 1) << 16) + (s.charCodeAt(d + 2) << 8) + s.charCodeAt(d + 3)) !== 0 ? (T = (b = ((b = ((b = ((b = (b - (U = b % 85)) / 85) - (D = b % 85)) / 85) - (E = b % 85)) / 85) - (M = b % 85)) / 85) % 85, o.push(T + 33, M + 33, E + 33, D + 33, U + 33)) : o.push(122);
    return function(q, G) {
      for (var Y = G; Y > 0; Y--) q.pop();
    }(o, l.length), String.fromCharCode.apply(String, o) + "~>";
  }, t = function(s) {
    var l, o, d, m, b, T = String, M = "length", E = 255, D = "charCodeAt", U = "slice", q = "replace";
    for (s[U](-2), s = s[U](0, -2)[q](/\s/g, "")[q]("z", "!!!!!"), d = [], m = 0, b = (s += l = "uuuuu"[U](s[M] % 5 || 5))[M]; b > m; m += 5) o = 52200625 * (s[D](m) - 33) + 614125 * (s[D](m + 1) - 33) + 7225 * (s[D](m + 2) - 33) + 85 * (s[D](m + 3) - 33) + (s[D](m + 4) - 33), d.push(E & o >> 24, E & o >> 16, E & o >> 8, E & o);
    return function(G, Y) {
      for (var he = Y; he > 0; he--) G.pop();
    }(d, l[M]), T.fromCharCode.apply(T, d);
  }, n = function(s) {
    var l = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((s = s.replace(/\s/g, "")).indexOf(">") !== -1 && (s = s.substr(0, s.indexOf(">"))), s.length % 2 && (s += "0"), l.test(s) === !1) return "";
    for (var o = "", d = 0; d < s.length; d += 2) o += String.fromCharCode("0x" + (s[d] + s[d + 1]));
    return o;
  }, i = function(s) {
    for (var l = new Uint8Array(s.length), o = s.length; o--; ) l[o] = s.charCodeAt(o);
    return s = (l = Av(l)).reduce(function(d, m) {
      return d + String.fromCharCode(m);
    }, "");
  };
  r.processDataByFilters = function(s, l) {
    var o = 0, d = s || "", m = [];
    for (typeof (l = l || []) == "string" && (l = [l]), o = 0; o < l.length; o += 1) switch (l[o]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        d = t(d), m.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        d = e(d), m.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        d = n(d), m.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        d = d.split("").map(function(b) {
          return ("0" + b.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", m.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        d = i(d), m.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + l[o] + '" is not implemented');
    }
    return { data: d, reverseChain: m.reverse().join(" ") };
  };
}(Jr.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  r.loadFile = function(e, t, n) {
    return function(i, s, l) {
      s = s !== !1, l = typeof l == "function" ? l : function() {
      };
      var o = void 0;
      try {
        o = function(d, m, b) {
          var T = new XMLHttpRequest(), M = 0, E = function(D) {
            var U = D.length, q = [], G = String.fromCharCode;
            for (M = 0; M < U; M += 1) q.push(G(255 & D.charCodeAt(M)));
            return q.join("");
          };
          if (T.open("GET", d, !m), T.overrideMimeType("text/plain; charset=x-user-defined"), m === !1 && (T.onload = function() {
            T.status === 200 ? b(E(this.responseText)) : b(void 0);
          }), T.send(null), m && T.status === 200) return E(T.responseText);
        }(i, s, l);
      } catch {
      }
      return o;
    }(e, t, n);
  }, r.loadImageFile = r.loadFile;
}(Jr.API), function(r) {
  function e() {
    return (Qr.html2canvas ? Promise.resolve(Qr.html2canvas) : import("./html2canvas.esm-Dr4iCOK6-BS3gXER4.mjs")).catch(function(l) {
      return Promise.reject(new Error("Could not load html2canvas: " + l));
    }).then(function(l) {
      return l.default ? l.default : l;
    });
  }
  function t() {
    return (Qr.DOMPurify ? Promise.resolve(Qr.DOMPurify) : import("./purify.es-CKk_t3XZ-36JobE0O.mjs")).catch(function(l) {
      return Promise.reject(new Error("Could not load dompurify: " + l));
    }).then(function(l) {
      return l.default ? l.default : l;
    });
  }
  var n = function(l) {
    var o = ii(l);
    return o === "undefined" ? "undefined" : o === "string" || l instanceof String ? "string" : o === "number" || l instanceof Number ? "number" : o === "function" || l instanceof Function ? "function" : l && l.constructor === Array ? "array" : l && l.nodeType === 1 ? "element" : o === "object" ? "object" : "unknown";
  }, i = function(l, o) {
    var d = document.createElement(l);
    for (var m in o.className && (d.className = o.className), o.innerHTML && o.dompurify && (d.innerHTML = o.dompurify.sanitize(o.innerHTML)), o.style) d.style[m] = o.style[m];
    return d;
  }, s = function l(o) {
    var d = Object.assign(l.convert(Promise.resolve()), JSON.parse(JSON.stringify(l.template))), m = l.convert(Promise.resolve(), d);
    return m = (m = m.setProgress(1, l, 1, [l])).set(o);
  };
  (s.prototype = Object.create(Promise.prototype)).constructor = s, s.convert = function(l, o) {
    return l.__proto__ = o || s.prototype, l;
  }, s.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, s.prototype.from = function(l, o) {
    return this.then(function() {
      switch (o = o || function(d) {
        switch (n(d)) {
          case "string":
            return "string";
          case "element":
            return d.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(l)) {
        case "string":
          return this.then(t).then(function(d) {
            return this.set({ src: i("div", { innerHTML: l, dompurify: d }) });
          });
        case "element":
          return this.set({ src: l });
        case "canvas":
          return this.set({ canvas: l });
        case "img":
          return this.set({ img: l });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, s.prototype.to = function(l) {
    switch (l) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, s.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var l = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, o = function d(m, b) {
        for (var T = m.nodeType === 3 ? document.createTextNode(m.nodeValue) : m.cloneNode(!1), M = m.firstChild; M; M = M.nextSibling) b !== !0 && M.nodeType === 1 && M.nodeName === "SCRIPT" || T.appendChild(d(M, b));
        return m.nodeType === 1 && (m.nodeName === "CANVAS" ? (T.width = m.width, T.height = m.height, T.getContext("2d").drawImage(m, 0, 0)) : m.nodeName !== "TEXTAREA" && m.nodeName !== "SELECT" || (T.value = m.value), T.addEventListener("load", function() {
          T.scrollTop = m.scrollTop, T.scrollLeft = m.scrollLeft;
        }, !0)), T;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      o.tagName === "BODY" && (l.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = i("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = i("div", { className: "html2pdf__container", style: l }), this.prop.container.appendChild(o), this.prop.container.firstChild.appendChild(i("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, s.prototype.toCanvas = function() {
    var l = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(l).then(e).then(function(o) {
      var d = Object.assign({}, this.opt.html2canvas);
      return delete d.onrendered, o(this.prop.container, d);
    }).then(function(o) {
      (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toContext2d = function() {
    var l = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(l).then(e).then(function(o) {
      var d = this.opt.jsPDF, m = this.opt.fontFaces, b = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, T = Object.assign({ async: !0, allowTaint: !0, scale: b, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete T.onrendered, d.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, d.context2d.posX = this.opt.x, d.context2d.posY = this.opt.y, d.context2d.margin = this.opt.margin, d.context2d.fontFaces = m, m) for (var M = 0; M < m.length; ++M) {
        var E = m[M], D = E.src.find(function(U) {
          return U.format === "truetype";
        });
        D && d.addFont(D.url, E.ref.name, E.ref.style);
      }
      return T.windowHeight = T.windowHeight || 0, T.windowHeight = T.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : T.windowHeight, d.context2d.save(!0), o(this.prop.container, T);
    }).then(function(o) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(o), this.prop.canvas = o, document.body.removeChild(this.prop.overlay);
    });
  }, s.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var l = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = l;
    });
  }, s.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, s.prototype.output = function(l, o, d) {
    return (d = d || "pdf").toLowerCase() === "img" || d.toLowerCase() === "image" ? this.outputImg(l, o) : this.outputPdf(l, o);
  }, s.prototype.outputPdf = function(l, o) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(l, o);
    });
  }, s.prototype.outputImg = function(l) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (l) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + l + '" is not supported.';
      }
    });
  }, s.prototype.save = function(l) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(l ? { filename: l } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, s.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, s.prototype.set = function(l) {
    if (n(l) !== "object") return this;
    var o = Object.keys(l || {}).map(function(d) {
      if (d in s.template.prop) return function() {
        this.prop[d] = l[d];
      };
      switch (d) {
        case "margin":
          return this.setMargin.bind(this, l.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = l.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, l.pageSize);
        default:
          return function() {
            this.opt[d] = l[d];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(o);
    });
  }, s.prototype.get = function(l, o) {
    return this.then(function() {
      var d = l in s.template.prop ? this.prop[l] : this.opt[l];
      return o ? o(d) : d;
    });
  }, s.prototype.setMargin = function(l) {
    return this.then(function() {
      switch (n(l)) {
        case "number":
          l = [l, l, l, l];
        case "array":
          if (l.length === 2 && (l = [l[0], l[1], l[0], l[1]]), l.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = l;
    }).then(this.setPageSize);
  }, s.prototype.setPageSize = function(l) {
    function o(d, m) {
      return Math.floor(d * m / 72 * 96);
    }
    return this.then(function() {
      (l = l || Jr.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (l.inner = { width: l.width - this.opt.margin[1] - this.opt.margin[3], height: l.height - this.opt.margin[0] - this.opt.margin[2] }, l.inner.px = { width: o(l.inner.width, l.k), height: o(l.inner.height, l.k) }, l.inner.ratio = l.inner.height / l.inner.width), this.prop.pageSize = l;
    });
  }, s.prototype.setProgress = function(l, o, d, m) {
    return l != null && (this.progress.val = l), o != null && (this.progress.state = o), d != null && (this.progress.n = d), m != null && (this.progress.stack = m), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, s.prototype.updateProgress = function(l, o, d, m) {
    return this.setProgress(l ? this.progress.val + l : null, o || null, d ? this.progress.n + d : null, m ? this.progress.stack.concat(m) : null);
  }, s.prototype.then = function(l, o) {
    var d = this;
    return this.thenCore(l, o, function(m, b) {
      return d.updateProgress(null, null, 1, [m]), Promise.prototype.then.call(this, function(T) {
        return d.updateProgress(null, m), T;
      }).then(m, b).then(function(T) {
        return d.updateProgress(1), T;
      });
    });
  }, s.prototype.thenCore = function(l, o, d) {
    d = d || Promise.prototype.then, l && (l = l.bind(this)), o && (o = o.bind(this));
    var m = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : s.convert(Object.assign({}, this), Promise.prototype), b = d.call(m, l, o);
    return s.convert(b, this.__proto__);
  }, s.prototype.thenExternal = function(l, o) {
    return Promise.prototype.then.call(this, l, o);
  }, s.prototype.thenList = function(l) {
    var o = this;
    return l.forEach(function(d) {
      o = o.thenCore(d);
    }), o;
  }, s.prototype.catch = function(l) {
    l && (l = l.bind(this));
    var o = Promise.prototype.catch.call(this, l);
    return s.convert(o, this);
  }, s.prototype.catchExternal = function(l) {
    return Promise.prototype.catch.call(this, l);
  }, s.prototype.error = function(l) {
    return this.then(function() {
      throw new Error(l);
    });
  }, s.prototype.using = s.prototype.set, s.prototype.saveAs = s.prototype.save, s.prototype.export = s.prototype.output, s.prototype.run = s.prototype.then, Jr.getPageSize = function(l, o, d) {
    if (ii(l) === "object") {
      var m = l;
      l = m.orientation, o = m.unit || o, d = m.format || d;
    }
    o = o || "mm", d = d || "a4", l = ("" + (l || "P")).toLowerCase();
    var b, T = ("" + d).toLowerCase(), M = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (o) {
      case "pt":
        b = 1;
        break;
      case "mm":
        b = 72 / 25.4;
        break;
      case "cm":
        b = 72 / 2.54;
        break;
      case "in":
        b = 72;
        break;
      case "px":
        b = 0.75;
        break;
      case "pc":
      case "em":
        b = 12;
        break;
      case "ex":
        b = 6;
        break;
      default:
        throw "Invalid unit: " + o;
    }
    var E, D = 0, U = 0;
    if (M.hasOwnProperty(T)) D = M[T][1] / b, U = M[T][0] / b;
    else try {
      D = d[1], U = d[0];
    } catch {
      throw new Error("Invalid format: " + d);
    }
    if (l === "p" || l === "portrait") l = "p", U > D && (E = U, U = D, D = E);
    else {
      if (l !== "l" && l !== "landscape") throw "Invalid orientation: " + l;
      l = "l", D > U && (E = U, U = D, D = E);
    }
    return { width: U, height: D, unit: o, k: b, orientation: l };
  }, r.html = function(l, o) {
    (o = o || {}).callback = o.callback || function() {
    }, o.html2canvas = o.html2canvas || {}, o.html2canvas.canvas = o.html2canvas.canvas || this.canvas, o.jsPDF = o.jsPDF || this, o.fontFaces = o.fontFaces ? o.fontFaces.map(Mv) : null;
    var d = new s(o);
    return o.worker ? d : d.from(l).doCallback();
  };
}(Jr.API), Jr.API.addJS = function(r) {
  return AS = r, this.internal.events.subscribe("postPutResources", function() {
    Fm = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Fm + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), wS = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + AS + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Fm !== void 0 && wS !== void 0 && this.internal.out("/Names <</JavaScript " + Fm + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e;
  r.events.push(["postPutResources", function() {
    var t = this, n = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var i = t.outline.render().split(/\r\n/), s = 0; s < i.length; s++) {
      var l = i[s], o = n.exec(l);
      if (o != null) {
        var d = o[1];
        t.internal.newObjectDeferredBegin(d, !1);
      }
      t.internal.write(l);
    }
    if (this.outline.createNamedDestinations) {
      var m = this.internal.pages.length, b = [];
      for (s = 0; s < m; s++) {
        var T = t.internal.newObject();
        b.push(T);
        var M = t.internal.getPageInfo(s + 1);
        t.internal.write("<< /D[" + M.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var E = t.internal.newObject();
      for (t.internal.write("<< /Names [ "), s = 0; s < b.length; s++) t.internal.write("(page_" + (s + 1) + ")" + b[s] + " 0 R");
      t.internal.write(" ] >>", "endobj"), e = t.internal.newObject(), t.internal.write("<< /Dests " + E + " 0 R"), t.internal.write(">>", "endobj");
    }
  }]), r.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
  }]), r.events.push(["initialized", function() {
    var t = this;
    t.outline = { createNamedDestinations: !1, root: { children: [] } }, t.outline.add = function(n, i, s) {
      var l = { title: i, options: s, children: [] };
      return n == null && (n = this.root), n.children.push(l), l;
    }, t.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t.outline.genIds_r = function(n) {
      n.id = t.internal.newObjectDeferred();
      for (var i = 0; i < n.children.length; i++) this.genIds_r(n.children[i]);
    }, t.outline.renderRoot = function(n) {
      this.objStart(n), this.line("/Type /Outlines"), n.children.length > 0 && (this.line("/First " + this.makeRef(n.children[0])), this.line("/Last " + this.makeRef(n.children[n.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, n)), this.objEnd();
    }, t.outline.renderItems = function(n) {
      for (var i = this.ctx.pdf.internal.getVerticalCoordinateString, s = 0; s < n.children.length; s++) {
        var l = n.children[s];
        this.objStart(l), this.line("/Title " + this.makeString(l.title)), this.line("/Parent " + this.makeRef(n)), s > 0 && this.line("/Prev " + this.makeRef(n.children[s - 1])), s < n.children.length - 1 && this.line("/Next " + this.makeRef(n.children[s + 1])), l.children.length > 0 && (this.line("/First " + this.makeRef(l.children[0])), this.line("/Last " + this.makeRef(l.children[l.children.length - 1])));
        var o = this.count = this.count_r({ count: 0 }, l);
        if (o > 0 && this.line("/Count " + o), l.options && l.options.pageNumber) {
          var d = t.internal.getPageInfo(l.options.pageNumber);
          this.line("/Dest [" + d.objId + " 0 R /XYZ 0 " + i(0) + " 0]");
        }
        this.objEnd();
      }
      for (var m = 0; m < n.children.length; m++) this.renderItems(n.children[m]);
    }, t.outline.line = function(n) {
      this.ctx.val += n + `\r
`;
    }, t.outline.makeRef = function(n) {
      return n.id + " 0 R";
    }, t.outline.makeString = function(n) {
      return "(" + t.internal.pdfEscape(n) + ")";
    }, t.outline.objStart = function(n) {
      this.ctx.val += `\r
` + n.id + ` 0 obj\r
<<\r
`;
    }, t.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, t.outline.count_r = function(n, i) {
      for (var s = 0; s < i.children.length; s++) n.count++, this.count_r(n, i.children[s]);
      return n.count;
    };
  }]);
}(Jr.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  r.processJPEG = function(t, n, i, s, l, o) {
    var d, m = this.decode.DCT_DECODE, b = null;
    if (typeof t == "string" || this.__addimage__.isArrayBuffer(t) || this.__addimage__.isArrayBufferView(t)) {
      switch (t = l || t, t = this.__addimage__.isArrayBuffer(t) ? new Uint8Array(t) : t, (d = function(T) {
        for (var M, E = 256 * T.charCodeAt(4) + T.charCodeAt(5), D = T.length, U = { width: 0, height: 0, numcomponents: 1 }, q = 4; q < D; q += 2) {
          if (q += E, e.indexOf(T.charCodeAt(q + 1)) !== -1) {
            M = 256 * T.charCodeAt(q + 5) + T.charCodeAt(q + 6), U = { width: 256 * T.charCodeAt(q + 7) + T.charCodeAt(q + 8), height: M, numcomponents: T.charCodeAt(q + 9) };
            break;
          }
          E = 256 * T.charCodeAt(q + 2) + T.charCodeAt(q + 3);
        }
        return U;
      }(t = this.__addimage__.isArrayBufferView(t) ? this.__addimage__.arrayBufferToBinaryString(t) : t)).numcomponents) {
        case 1:
          o = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          o = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          o = this.color_spaces.DEVICE_RGB;
      }
      b = { data: t, width: d.width, height: d.height, colorSpace: o, bitsPerComponent: 8, filter: m, index: n, alias: i };
    }
    return b;
  };
}(Jr.API);
var hd, Um, SS, ES, CS, OX = function() {
  var r, e, t;
  function n(s) {
    var l, o, d, m, b, T, M, E, D, U, q, G, Y, he;
    for (this.data = s, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, T = null; ; ) {
      switch (l = this.readUInt32(), D = (function() {
        var X, J;
        for (J = [], X = 0; X < 4; ++X) J.push(String.fromCharCode(this.data[this.pos++]));
        return J;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(l);
          break;
        case "fcTL":
          T && this.animation.frames.push(T), this.pos += 4, T = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, b = this.readUInt16(), m = this.readUInt16() || 100, T.delay = 1e3 * b / m, T.disposeOp = this.data[this.pos++], T.blendOp = this.data[this.pos++], T.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (D === "fdAT" && (this.pos += 4, l -= 4), s = (T != null ? T.data : void 0) || this.imgData, G = 0; 0 <= l ? G < l : G > l; 0 <= l ? ++G : --G) s.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (d = this.palette.length / 3, this.transparency.indexed = this.read(l), this.transparency.indexed.length > d) throw new Error("More transparent colors than palette size");
              if ((U = d - this.transparency.indexed.length) > 0) for (Y = 0; 0 <= U ? Y < U : Y > U; 0 <= U ? ++Y : --Y) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(l)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(l);
          }
          break;
        case "tEXt":
          M = (q = this.read(l)).indexOf(0), E = String.fromCharCode.apply(String, q.slice(0, M)), this.text[E] = String.fromCharCode.apply(String, q.slice(M + 1));
          break;
        case "IEND":
          return T && this.animation.frames.push(T), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (he = this.colorType) === 4 || he === 6, o = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * o, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += l;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  n.prototype.read = function(s) {
    var l, o;
    for (o = [], l = 0; 0 <= s ? l < s : l > s; 0 <= s ? ++l : --l) o.push(this.data[this.pos++]);
    return o;
  }, n.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, n.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, n.prototype.decodePixels = function(s) {
    var l = this.pixelBitlength / 8, o = new Uint8Array(this.width * this.height * l), d = 0, m = this;
    if (s == null && (s = this.imgData), s.length === 0) return new Uint8Array(0);
    function b(T, M, E, D) {
      var U, q, G, Y, he, X, J, ie, ye, oe, Re, Ne, me, _e, Fe, Me, Ct, ht, Pt, bt, kt, Nt = Math.ceil((m.width - T) / E), mr = Math.ceil((m.height - M) / D), ce = m.width == Nt && m.height == mr;
      for (_e = l * Nt, Ne = ce ? o : new Uint8Array(_e * mr), X = s.length, me = 0, q = 0; me < mr && d < X; ) {
        switch (s[d++]) {
          case 0:
            for (Y = Ct = 0; Ct < _e; Y = Ct += 1) Ne[q++] = s[d++];
            break;
          case 1:
            for (Y = ht = 0; ht < _e; Y = ht += 1) U = s[d++], he = Y < l ? 0 : Ne[q - l], Ne[q++] = (U + he) % 256;
            break;
          case 2:
            for (Y = Pt = 0; Pt < _e; Y = Pt += 1) U = s[d++], G = (Y - Y % l) / l, Fe = me && Ne[(me - 1) * _e + G * l + Y % l], Ne[q++] = (Fe + U) % 256;
            break;
          case 3:
            for (Y = bt = 0; bt < _e; Y = bt += 1) U = s[d++], G = (Y - Y % l) / l, he = Y < l ? 0 : Ne[q - l], Fe = me && Ne[(me - 1) * _e + G * l + Y % l], Ne[q++] = (U + Math.floor((he + Fe) / 2)) % 256;
            break;
          case 4:
            for (Y = kt = 0; kt < _e; Y = kt += 1) U = s[d++], G = (Y - Y % l) / l, he = Y < l ? 0 : Ne[q - l], me === 0 ? Fe = Me = 0 : (Fe = Ne[(me - 1) * _e + G * l + Y % l], Me = G && Ne[(me - 1) * _e + (G - 1) * l + Y % l]), J = he + Fe - Me, ie = Math.abs(J - he), oe = Math.abs(J - Fe), Re = Math.abs(J - Me), ye = ie <= oe && ie <= Re ? he : oe <= Re ? Fe : Me, Ne[q++] = (U + ye) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + s[d - 1]);
        }
        if (!ce) {
          var Be = ((M + me * D) * m.width + T) * l, Ue = me * _e;
          for (Y = 0; Y < Nt; Y += 1) {
            for (var Xe = 0; Xe < l; Xe += 1) o[Be++] = Ne[Ue++];
            Be += (E - 1) * l;
          }
        }
        me++;
      }
    }
    return s = fX(s), m.interlaceMethod == 1 ? (b(0, 0, 8, 8), b(4, 0, 8, 8), b(0, 4, 4, 8), b(2, 0, 4, 4), b(0, 2, 2, 4), b(1, 0, 2, 2), b(0, 1, 1, 2)) : b(0, 0, 1, 1), o;
  }, n.prototype.decodePalette = function() {
    var s, l, o, d, m, b, T, M, E;
    for (o = this.palette, b = this.transparency.indexed || [], m = new Uint8Array((b.length || 0) + o.length), d = 0, s = 0, l = T = 0, M = o.length; T < M; l = T += 3) m[d++] = o[l], m[d++] = o[l + 1], m[d++] = o[l + 2], m[d++] = (E = b[s++]) != null ? E : 255;
    return m;
  }, n.prototype.copyToImageData = function(s, l) {
    var o, d, m, b, T, M, E, D, U, q, G;
    if (d = this.colors, U = null, o = this.hasAlphaChannel, this.palette.length && (U = (G = this._decodedPalette) != null ? G : this._decodedPalette = this.decodePalette(), d = 4, o = !0), D = (m = s.data || s).length, T = U || l, b = M = 0, d === 1) for (; b < D; ) E = U ? 4 * l[b / 4] : M, q = T[E++], m[b++] = q, m[b++] = q, m[b++] = q, m[b++] = o ? T[E++] : 255, M = E;
    else for (; b < D; ) E = U ? 4 * l[b / 4] : M, m[b++] = T[E++], m[b++] = T[E++], m[b++] = T[E++], m[b++] = o ? T[E++] : 255, M = E;
  }, n.prototype.decode = function() {
    var s;
    return s = new Uint8Array(this.width * this.height * 4), this.copyToImageData(s, this.decodePixels()), s;
  };
  var i = function() {
    if (Object.prototype.toString.call(Qr) === "[object Window]") {
      try {
        e = Qr.document.createElement("canvas"), t = e.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return i(), r = function(s) {
    var l;
    if (i() === !0) return t.width = s.width, t.height = s.height, t.clearRect(0, 0, s.width, s.height), t.putImageData(s, 0, 0), (l = new Image()).src = e.toDataURL(), l;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, n.prototype.decodeFrames = function(s) {
    var l, o, d, m, b, T, M, E;
    if (this.animation) {
      for (E = [], o = b = 0, T = (M = this.animation.frames).length; b < T; o = ++b) l = M[o], d = s.createImageData(l.width, l.height), m = this.decodePixels(new Uint8Array(l.data)), this.copyToImageData(d, m), l.imageData = d, E.push(l.image = r(d));
      return E;
    }
  }, n.prototype.renderFrame = function(s, l) {
    var o, d, m;
    return o = (d = this.animation.frames)[l], m = d[l - 1], l === 0 && s.clearRect(0, 0, this.width, this.height), (m != null ? m.disposeOp : void 0) === 1 ? s.clearRect(m.xOffset, m.yOffset, m.width, m.height) : (m != null ? m.disposeOp : void 0) === 2 && s.putImageData(m.imageData, m.xOffset, m.yOffset), o.blendOp === 0 && s.clearRect(o.xOffset, o.yOffset, o.width, o.height), s.drawImage(o.image, o.xOffset, o.yOffset);
  }, n.prototype.animate = function(s) {
    var l, o, d, m, b, T, M = this;
    return o = 0, T = this.animation, m = T.numFrames, d = T.frames, b = T.numPlays, (l = function() {
      var E, D;
      if (E = o++ % m, D = d[E], M.renderFrame(s, E), m > 1 && o / m < b) return M.animation._timeout = setTimeout(l, D.delay);
    })();
  }, n.prototype.stopAnimation = function() {
    var s;
    return clearTimeout((s = this.animation) != null ? s._timeout : void 0);
  }, n.prototype.render = function(s) {
    var l, o;
    return s._png && s._png.stopAnimation(), s._png = this, s.width = this.width, s.height = this.height, l = s.getContext("2d"), this.animation ? (this.decodeFrames(l), this.animate(l)) : (o = l.createImageData(this.width, this.height), this.copyToImageData(o, this.decodePixels()), l.putImageData(o, 0, 0));
  }, n;
}();
/**
* @license
*
* Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
/**
* @license
* (c) Dean McNamee <dean@gmail.com>, 2013.
*
* https://github.com/deanm/omggif
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
* including animation and compression.  It does not rely on any specific
* underlying system, so should run in the browser, Node, or Plask.
*/
function NX(r) {
  var e = 0;
  if (r[e++] !== 71 || r[e++] !== 73 || r[e++] !== 70 || r[e++] !== 56 || (r[e++] + 1 & 253) != 56 || r[e++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var t = r[e++] | r[e++] << 8, n = r[e++] | r[e++] << 8, i = r[e++], s = i >> 7, l = 1 << (7 & i) + 1;
  r[e++], r[e++];
  var o = null, d = null;
  s && (o = e, d = l, e += 3 * l);
  var m = !0, b = [], T = 0, M = null, E = 0, D = null;
  for (this.width = t, this.height = n; m && e < r.length; ) switch (r[e++]) {
    case 33:
      switch (r[e++]) {
        case 255:
          if (r[e] !== 11 || r[e + 1] == 78 && r[e + 2] == 69 && r[e + 3] == 84 && r[e + 4] == 83 && r[e + 5] == 67 && r[e + 6] == 65 && r[e + 7] == 80 && r[e + 8] == 69 && r[e + 9] == 50 && r[e + 10] == 46 && r[e + 11] == 48 && r[e + 12] == 3 && r[e + 13] == 1 && r[e + 16] == 0) e += 14, D = r[e++] | r[e++] << 8, e++;
          else for (e += 12; ; ) {
            if (!((me = r[e++]) >= 0)) throw Error("Invalid block size");
            if (me === 0) break;
            e += me;
          }
          break;
        case 249:
          if (r[e++] !== 4 || r[e + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var U = r[e++];
          T = r[e++] | r[e++] << 8, M = r[e++], !(1 & U) && (M = null), E = U >> 2 & 7, e++;
          break;
        case 254:
          for (; ; ) {
            if (!((me = r[e++]) >= 0)) throw Error("Invalid block size");
            if (me === 0) break;
            e += me;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + r[e - 1].toString(16));
      }
      break;
    case 44:
      var q = r[e++] | r[e++] << 8, G = r[e++] | r[e++] << 8, Y = r[e++] | r[e++] << 8, he = r[e++] | r[e++] << 8, X = r[e++], J = X >> 6 & 1, ie = 1 << (7 & X) + 1, ye = o, oe = d, Re = !1;
      X >> 7 && (Re = !0, ye = e, oe = ie, e += 3 * ie);
      var Ne = e;
      for (e++; ; ) {
        var me;
        if (!((me = r[e++]) >= 0)) throw Error("Invalid block size");
        if (me === 0) break;
        e += me;
      }
      b.push({ x: q, y: G, width: Y, height: he, has_local_palette: Re, palette_offset: ye, palette_size: oe, data_offset: Ne, data_length: e - Ne, transparent_index: M, interlaced: !!J, delay: T, disposal: E });
      break;
    case 59:
      m = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + r[e - 1].toString(16));
  }
  this.numFrames = function() {
    return b.length;
  }, this.loopCount = function() {
    return D;
  }, this.frameInfo = function(_e) {
    if (_e < 0 || _e >= b.length) throw new Error("Frame index out of range.");
    return b[_e];
  }, this.decodeAndBlitFrameBGRA = function(_e, Fe) {
    var Me = this.frameInfo(_e), Ct = Me.width * Me.height, ht = new Uint8Array(Ct);
    IS(r, Me.data_offset, ht, Ct);
    var Pt = Me.palette_offset, bt = Me.transparent_index;
    bt === null && (bt = 256);
    var kt = Me.width, Nt = t - kt, mr = kt, ce = 4 * (Me.y * t + Me.x), Be = 4 * ((Me.y + Me.height) * t + Me.x), Ue = ce, Xe = 4 * Nt;
    Me.interlaced === !0 && (Xe += 4 * t * 7);
    for (var it = 8, ft = 0, St = ht.length; ft < St; ++ft) {
      var wt = ht[ft];
      if (mr === 0 && (mr = kt, (Ue += Xe) >= Be && (Xe = 4 * Nt + 4 * t * (it - 1), Ue = ce + (kt + Nt) * (it << 1), it >>= 1)), wt === bt) Ue += 4;
      else {
        var ar = r[Pt + 3 * wt], Yt = r[Pt + 3 * wt + 1], cr = r[Pt + 3 * wt + 2];
        Fe[Ue++] = cr, Fe[Ue++] = Yt, Fe[Ue++] = ar, Fe[Ue++] = 255;
      }
      --mr;
    }
  }, this.decodeAndBlitFrameRGBA = function(_e, Fe) {
    var Me = this.frameInfo(_e), Ct = Me.width * Me.height, ht = new Uint8Array(Ct);
    IS(r, Me.data_offset, ht, Ct);
    var Pt = Me.palette_offset, bt = Me.transparent_index;
    bt === null && (bt = 256);
    var kt = Me.width, Nt = t - kt, mr = kt, ce = 4 * (Me.y * t + Me.x), Be = 4 * ((Me.y + Me.height) * t + Me.x), Ue = ce, Xe = 4 * Nt;
    Me.interlaced === !0 && (Xe += 4 * t * 7);
    for (var it = 8, ft = 0, St = ht.length; ft < St; ++ft) {
      var wt = ht[ft];
      if (mr === 0 && (mr = kt, (Ue += Xe) >= Be && (Xe = 4 * Nt + 4 * t * (it - 1), Ue = ce + (kt + Nt) * (it << 1), it >>= 1)), wt === bt) Ue += 4;
      else {
        var ar = r[Pt + 3 * wt], Yt = r[Pt + 3 * wt + 1], cr = r[Pt + 3 * wt + 2];
        Fe[Ue++] = ar, Fe[Ue++] = Yt, Fe[Ue++] = cr, Fe[Ue++] = 255;
      }
      --mr;
    }
  };
}
function IS(r, e, t, n) {
  for (var i = r[e++], s = 1 << i, l = s + 1, o = l + 1, d = i + 1, m = (1 << d) - 1, b = 0, T = 0, M = 0, E = r[e++], D = new Int32Array(4096), U = null; ; ) {
    for (; b < 16 && E !== 0; ) T |= r[e++] << b, b += 8, E === 1 ? E = r[e++] : --E;
    if (b < d) break;
    var q = T & m;
    if (T >>= d, b -= d, q !== s) {
      if (q === l) break;
      for (var G = q < o ? q : U, Y = 0, he = G; he > s; ) he = D[he] >> 8, ++Y;
      var X = he;
      if (M + Y + (G !== q ? 1 : 0) > n) return void vi.log("Warning, gif stream longer than expected.");
      t[M++] = X;
      var J = M += Y;
      for (G !== q && (t[M++] = X), he = G; Y--; ) he = D[he], t[--J] = 255 & he, he >>= 8;
      U !== null && o < 4096 && (D[o++] = U << 8 | X, o >= m + 1 && d < 12 && (++d, m = m << 1 | 1)), U = q;
    } else o = l + 1, m = (1 << (d = i + 1)) - 1, U = null;
  }
  return M !== n && vi.log("Warning, gif stream shorter than expected."), t;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function Xb(r) {
  var e, t, n, i, s, l = Math.floor, o = new Array(64), d = new Array(64), m = new Array(64), b = new Array(64), T = new Array(65535), M = new Array(65535), E = new Array(64), D = new Array(64), U = [], q = 0, G = 7, Y = new Array(64), he = new Array(64), X = new Array(64), J = new Array(256), ie = new Array(2048), ye = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], oe = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], Re = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Ne = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], me = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], _e = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], Fe = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Me = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], Ct = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function ht(ce, Be) {
    for (var Ue = 0, Xe = 0, it = new Array(), ft = 1; ft <= 16; ft++) {
      for (var St = 1; St <= ce[ft]; St++) it[Be[Xe]] = [], it[Be[Xe]][0] = Ue, it[Be[Xe]][1] = ft, Xe++, Ue++;
      Ue *= 2;
    }
    return it;
  }
  function Pt(ce) {
    for (var Be = ce[0], Ue = ce[1] - 1; Ue >= 0; ) Be & 1 << Ue && (q |= 1 << G), Ue--, --G < 0 && (q == 255 ? (bt(255), bt(0)) : bt(q), G = 7, q = 0);
  }
  function bt(ce) {
    U.push(ce);
  }
  function kt(ce) {
    bt(ce >> 8 & 255), bt(255 & ce);
  }
  function Nt(ce, Be, Ue, Xe, it) {
    for (var ft, St = it[0], wt = it[240], ar = function(rr, hr) {
      var wr, br, Rr, $r, Wr, Zr, hn, yn, Vr, en, Ar = 0;
      for (Vr = 0; Vr < 8; ++Vr) {
        wr = rr[Ar], br = rr[Ar + 1], Rr = rr[Ar + 2], $r = rr[Ar + 3], Wr = rr[Ar + 4], Zr = rr[Ar + 5], hn = rr[Ar + 6];
        var Ii = wr + (yn = rr[Ar + 7]), bn = wr - yn, Xi = br + hn, ve = br - hn, se = Rr + Zr, de = Rr - Zr, pe = $r + Wr, Oe = $r - Wr, Ge = Ii + pe, rt = Ii - pe, gt = Xi + se, Ye = Xi - se;
        rr[Ar] = Ge + gt, rr[Ar + 4] = Ge - gt;
        var lt = 0.707106781 * (Ye + rt);
        rr[Ar + 2] = rt + lt, rr[Ar + 6] = rt - lt;
        var pt = 0.382683433 * ((Ge = Oe + de) - (Ye = ve + bn)), ct = 0.5411961 * Ge + pt, We = 1.306562965 * Ye + pt, or = 0.707106781 * (gt = de + ve), Jt = bn + or, Kt = bn - or;
        rr[Ar + 5] = Kt + ct, rr[Ar + 3] = Kt - ct, rr[Ar + 1] = Jt + We, rr[Ar + 7] = Jt - We, Ar += 8;
      }
      for (Ar = 0, Vr = 0; Vr < 8; ++Vr) {
        wr = rr[Ar], br = rr[Ar + 8], Rr = rr[Ar + 16], $r = rr[Ar + 24], Wr = rr[Ar + 32], Zr = rr[Ar + 40], hn = rr[Ar + 48];
        var Mr = wr + (yn = rr[Ar + 56]), Bt = wr - yn, Qt = br + hn, fr = br - hn, Lr = Rr + Zr, Hr = Rr - Zr, Or = $r + Wr, gr = $r - Wr, Sn = Mr + Or, Zi = Mr - Or, Dn = Qt + Lr, kn = Qt - Lr;
        rr[Ar] = Sn + Dn, rr[Ar + 32] = Sn - Dn;
        var vn = 0.707106781 * (kn + Zi);
        rr[Ar + 16] = Zi + vn, rr[Ar + 48] = Zi - vn;
        var Ai = 0.382683433 * ((Sn = gr + Hr) - (kn = fr + Bt)), In = 0.5411961 * Sn + Ai, aa = 1.306562965 * kn + Ai, Wo = 0.707106781 * (Dn = Hr + fr), tl = Bt + Wo, wo = Bt - Wo;
        rr[Ar + 40] = wo + In, rr[Ar + 24] = wo - In, rr[Ar + 8] = tl + aa, rr[Ar + 56] = tl - aa, Ar++;
      }
      for (Vr = 0; Vr < 64; ++Vr) en = rr[Vr] * hr[Vr], E[Vr] = en > 0 ? en + 0.5 | 0 : en - 0.5 | 0;
      return E;
    }(ce, Be), Yt = 0; Yt < 64; ++Yt) D[ye[Yt]] = ar[Yt];
    var cr = D[0] - Ue;
    Ue = D[0], cr == 0 ? Pt(Xe[0]) : (Pt(Xe[M[ft = 32767 + cr]]), Pt(T[ft]));
    for (var _r = 63; _r > 0 && D[_r] == 0; ) _r--;
    if (_r == 0) return Pt(St), Ue;
    for (var Cr, Ut = 1; Ut <= _r; ) {
      for (var Ve = Ut; D[Ut] == 0 && Ut <= _r; ) ++Ut;
      var jr = Ut - Ve;
      if (jr >= 16) {
        Cr = jr >> 4;
        for (var Ir = 1; Ir <= Cr; ++Ir) Pt(wt);
        jr &= 15;
      }
      ft = 32767 + D[Ut], Pt(it[(jr << 4) + M[ft]]), Pt(T[ft]), Ut++;
    }
    return _r != 63 && Pt(St), Ue;
  }
  function mr(ce) {
    ce = Math.min(Math.max(ce, 1), 100), s != ce && (function(Be) {
      for (var Ue = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Xe = 0; Xe < 64; Xe++) {
        var it = l((Ue[Xe] * Be + 50) / 100);
        it = Math.min(Math.max(it, 1), 255), o[ye[Xe]] = it;
      }
      for (var ft = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], St = 0; St < 64; St++) {
        var wt = l((ft[St] * Be + 50) / 100);
        wt = Math.min(Math.max(wt, 1), 255), d[ye[St]] = wt;
      }
      for (var ar = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Yt = 0, cr = 0; cr < 8; cr++) for (var _r = 0; _r < 8; _r++) m[Yt] = 1 / (o[ye[Yt]] * ar[cr] * ar[_r] * 8), b[Yt] = 1 / (d[ye[Yt]] * ar[cr] * ar[_r] * 8), Yt++;
    }(ce < 50 ? Math.floor(5e3 / ce) : Math.floor(200 - 2 * ce)), s = ce);
  }
  this.encode = function(ce, Be) {
    Be && mr(Be), U = new Array(), q = 0, G = 7, kt(65496), kt(65504), kt(16), bt(74), bt(70), bt(73), bt(70), bt(0), bt(1), bt(1), bt(0), kt(1), kt(1), bt(0), bt(0), function() {
      kt(65499), kt(132), bt(0);
      for (var br = 0; br < 64; br++) bt(o[br]);
      bt(1);
      for (var Rr = 0; Rr < 64; Rr++) bt(d[Rr]);
    }(), function(br, Rr) {
      kt(65472), kt(17), bt(8), kt(Rr), kt(br), bt(3), bt(1), bt(17), bt(0), bt(2), bt(17), bt(1), bt(3), bt(17), bt(1);
    }(ce.width, ce.height), function() {
      kt(65476), kt(418), bt(0);
      for (var br = 0; br < 16; br++) bt(oe[br + 1]);
      for (var Rr = 0; Rr <= 11; Rr++) bt(Re[Rr]);
      bt(16);
      for (var $r = 0; $r < 16; $r++) bt(Ne[$r + 1]);
      for (var Wr = 0; Wr <= 161; Wr++) bt(me[Wr]);
      bt(1);
      for (var Zr = 0; Zr < 16; Zr++) bt(_e[Zr + 1]);
      for (var hn = 0; hn <= 11; hn++) bt(Fe[hn]);
      bt(17);
      for (var yn = 0; yn < 16; yn++) bt(Me[yn + 1]);
      for (var Vr = 0; Vr <= 161; Vr++) bt(Ct[Vr]);
    }(), kt(65498), kt(12), bt(3), bt(1), bt(0), bt(2), bt(17), bt(3), bt(17), bt(0), bt(63), bt(0);
    var Ue = 0, Xe = 0, it = 0;
    q = 0, G = 7, this.encode.displayName = "_encode_";
    for (var ft, St, wt, ar, Yt, cr, _r, Cr, Ut, Ve = ce.data, jr = ce.width, Ir = ce.height, rr = 4 * jr, hr = 0; hr < Ir; ) {
      for (ft = 0; ft < rr; ) {
        for (Yt = rr * hr + ft, _r = -1, Cr = 0, Ut = 0; Ut < 64; Ut++) cr = Yt + (Cr = Ut >> 3) * rr + (_r = 4 * (7 & Ut)), hr + Cr >= Ir && (cr -= rr * (hr + 1 + Cr - Ir)), ft + _r >= rr && (cr -= ft + _r - rr + 4), St = Ve[cr++], wt = Ve[cr++], ar = Ve[cr++], Y[Ut] = (ie[St] + ie[wt + 256 >> 0] + ie[ar + 512 >> 0] >> 16) - 128, he[Ut] = (ie[St + 768 >> 0] + ie[wt + 1024 >> 0] + ie[ar + 1280 >> 0] >> 16) - 128, X[Ut] = (ie[St + 1280 >> 0] + ie[wt + 1536 >> 0] + ie[ar + 1792 >> 0] >> 16) - 128;
        Ue = Nt(Y, m, Ue, e, n), Xe = Nt(he, b, Xe, t, i), it = Nt(X, b, it, t, i), ft += 32;
      }
      hr += 8;
    }
    if (G >= 0) {
      var wr = [];
      wr[1] = G + 1, wr[0] = (1 << G + 1) - 1, Pt(wr);
    }
    return kt(65497), new Uint8Array(U);
  }, r = r || 50, function() {
    for (var ce = String.fromCharCode, Be = 0; Be < 256; Be++) J[Be] = ce(Be);
  }(), e = ht(oe, Re), t = ht(_e, Fe), n = ht(Ne, me), i = ht(Me, Ct), function() {
    for (var ce = 1, Be = 2, Ue = 1; Ue <= 15; Ue++) {
      for (var Xe = ce; Xe < Be; Xe++) M[32767 + Xe] = Ue, T[32767 + Xe] = [], T[32767 + Xe][1] = Ue, T[32767 + Xe][0] = Xe;
      for (var it = -(Be - 1); it <= -ce; it++) M[32767 + it] = Ue, T[32767 + it] = [], T[32767 + it][1] = Ue, T[32767 + it][0] = Be - 1 + it;
      ce <<= 1, Be <<= 1;
    }
  }(), function() {
    for (var ce = 0; ce < 256; ce++) ie[ce] = 19595 * ce, ie[ce + 256 >> 0] = 38470 * ce, ie[ce + 512 >> 0] = 7471 * ce + 32768, ie[ce + 768 >> 0] = -11059 * ce, ie[ce + 1024 >> 0] = -21709 * ce, ie[ce + 1280 >> 0] = 32768 * ce + 8421375, ie[ce + 1536 >> 0] = -27439 * ce, ie[ce + 1792 >> 0] = -5329 * ce;
  }(), mr(r);
}
/**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function fc(r, e) {
  if (this.pos = 0, this.buffer = r, this.datav = new DataView(r.buffer), this.is_with_alpha = !!e, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function MS(r) {
  function e(oe) {
    if (!oe) throw Error("assert :P");
  }
  function t(oe, Re, Ne) {
    for (var me = 0; 4 > me; me++) if (oe[Re + me] != Ne.charCodeAt(me)) return !0;
    return !1;
  }
  function n(oe, Re, Ne, me, _e) {
    for (var Fe = 0; Fe < _e; Fe++) oe[Re + Fe] = Ne[me + Fe];
  }
  function i(oe, Re, Ne, me) {
    for (var _e = 0; _e < me; _e++) oe[Re + _e] = Ne;
  }
  function s(oe) {
    return new Int32Array(oe);
  }
  function l(oe, Re) {
    for (var Ne = [], me = 0; me < oe; me++) Ne.push(new Re());
    return Ne;
  }
  function o(oe, Re) {
    var Ne = [];
    return function me(_e, Fe, Me) {
      for (var Ct = Me[Fe], ht = 0; ht < Ct && (_e.push(Me.length > Fe + 1 ? [] : new Re()), !(Me.length < Fe + 1)); ht++) me(_e[ht], Fe + 1, Me);
    }(Ne, 0, oe), Ne;
  }
  var d = function() {
    var oe = this;
    function Re(S, P) {
      for (var F = 1 << P - 1 >>> 0; S & F; ) F >>>= 1;
      return F ? (S & F - 1) + F : S;
    }
    function Ne(S, P, F, $, re) {
      e(!($ % F));
      do
        S[P + ($ -= F)] = re;
      while (0 < $);
    }
    function me(S, P, F, $, re) {
      if (e(2328 >= re), 512 >= re) var fe = s(512);
      else if ((fe = s(re)) == null) return 0;
      return function(ge, be, we, Pe, et, ot) {
        var xt, st, Wt = be, Ot = 1 << we, tt = s(16), nt = s(16);
        for (e(et != 0), e(Pe != null), e(ge != null), e(0 < we), st = 0; st < et; ++st) {
          if (15 < Pe[st]) return 0;
          ++tt[Pe[st]];
        }
        if (tt[0] == et) return 0;
        for (nt[1] = 0, xt = 1; 15 > xt; ++xt) {
          if (tt[xt] > 1 << xt) return 0;
          nt[xt + 1] = nt[xt] + tt[xt];
        }
        for (st = 0; st < et; ++st) xt = Pe[st], 0 < Pe[st] && (ot[nt[xt]++] = st);
        if (nt[15] == 1) return (Pe = new _e()).g = 0, Pe.value = ot[0], Ne(ge, Wt, 1, Ot, Pe), Ot;
        var qt, Zt = -1, dt = Ot - 1, Vt = 0, yr = 1, Ur = 1, xr = 1 << we;
        for (st = 0, xt = 1, et = 2; xt <= we; ++xt, et <<= 1) {
          if (yr += Ur <<= 1, 0 > (Ur -= tt[xt])) return 0;
          for (; 0 < tt[xt]; --tt[xt]) (Pe = new _e()).g = xt, Pe.value = ot[st++], Ne(ge, Wt + Vt, et, xr, Pe), Vt = Re(Vt, xt);
        }
        for (xt = we + 1, et = 2; 15 >= xt; ++xt, et <<= 1) {
          if (yr += Ur <<= 1, 0 > (Ur -= tt[xt])) return 0;
          for (; 0 < tt[xt]; --tt[xt]) {
            if (Pe = new _e(), (Vt & dt) != Zt) {
              for (Wt += xr, qt = 1 << (Zt = xt) - we; 15 > Zt && !(0 >= (qt -= tt[Zt])); ) ++Zt, qt <<= 1;
              Ot += xr = 1 << (qt = Zt - we), ge[be + (Zt = Vt & dt)].g = qt + we, ge[be + Zt].value = Wt - be - Zt;
            }
            Pe.g = xt - we, Pe.value = ot[st++], Ne(ge, Wt + (Vt >> we), et, xr, Pe), Vt = Re(Vt, xt);
          }
        }
        return yr != 2 * nt[15] - 1 ? 0 : Ot;
      }(S, P, F, $, re, fe);
    }
    function _e() {
      this.value = this.g = 0;
    }
    function Fe() {
      this.value = this.g = 0;
    }
    function Me() {
      this.G = l(5, _e), this.H = s(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = l(ri, Fe);
    }
    function Ct(S, P, F, $) {
      e(S != null), e(P != null), e(2147483648 > $), S.Ca = 254, S.I = 0, S.b = -8, S.Ka = 0, S.oa = P, S.pa = F, S.Jd = P, S.Yc = F + $, S.Zc = 4 <= $ ? F + $ - 4 + 1 : F, ft(S);
    }
    function ht(S, P) {
      for (var F = 0; 0 < P--; ) F |= wt(S, 128) << P;
      return F;
    }
    function Pt(S, P) {
      var F = ht(S, P);
      return St(S) ? -F : F;
    }
    function bt(S, P, F, $) {
      var re, fe = 0;
      for (e(S != null), e(P != null), e(4294967288 > $), S.Sb = $, S.Ra = 0, S.u = 0, S.h = 0, 4 < $ && ($ = 4), re = 0; re < $; ++re) fe += P[F + re] << 8 * re;
      S.Ra = fe, S.bb = $, S.oa = P, S.pa = F;
    }
    function kt(S) {
      for (; 8 <= S.u && S.bb < S.Sb; ) S.Ra >>>= 8, S.Ra += S.oa[S.pa + S.bb] << Ba - 8 >>> 0, ++S.bb, S.u -= 8;
      Ue(S) && (S.h = 1, S.u = 0);
    }
    function Nt(S, P) {
      if (e(0 <= P), !S.h && P <= cl) {
        var F = Be(S) & ll[P];
        return S.u += P, kt(S), F;
      }
      return S.h = 1, S.u = 0;
    }
    function mr() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function ce() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function Be(S) {
      return S.Ra >>> (S.u & Ba - 1) >>> 0;
    }
    function Ue(S) {
      return e(S.bb <= S.Sb), S.h || S.bb == S.Sb && S.u > Ba;
    }
    function Xe(S, P) {
      S.u = P, S.h = Ue(S);
    }
    function it(S) {
      S.u >= zc && (e(S.u >= zc), kt(S));
    }
    function ft(S) {
      e(S != null && S.oa != null), S.pa < S.Zc ? (S.I = (S.oa[S.pa++] | S.I << 8) >>> 0, S.b += 8) : (e(S != null && S.oa != null), S.pa < S.Yc ? (S.b += 8, S.I = S.oa[S.pa++] | S.I << 8) : S.Ka ? S.b = 0 : (S.I <<= 8, S.b += 8, S.Ka = 1));
    }
    function St(S) {
      return ht(S, 1);
    }
    function wt(S, P) {
      var F = S.Ca;
      0 > S.b && ft(S);
      var $ = S.b, re = F * P >>> 8, fe = (S.I >>> $ > re) + 0;
      for (fe ? (F -= re, S.I -= re + 1 << $ >>> 0) : F = re + 1, $ = F, re = 0; 256 <= $; ) re += 8, $ >>= 8;
      return $ = 7 ^ re + Cs[$], S.b -= $, S.Ca = (F << $) - 1, fe;
    }
    function ar(S, P, F) {
      S[P + 0] = F >> 24 & 255, S[P + 1] = F >> 16 & 255, S[P + 2] = F >> 8 & 255, S[P + 3] = F >> 0 & 255;
    }
    function Yt(S, P) {
      return S[P + 0] << 0 | S[P + 1] << 8;
    }
    function cr(S, P) {
      return Yt(S, P) | S[P + 2] << 16;
    }
    function _r(S, P) {
      return Yt(S, P) | Yt(S, P + 2) << 16;
    }
    function Cr(S, P) {
      var F = 1 << P;
      return e(S != null), e(0 < P), S.X = s(F), S.X == null ? 0 : (S.Mb = 32 - P, S.Xa = P, 1);
    }
    function Ut(S, P) {
      e(S != null), e(P != null), e(S.Xa == P.Xa), n(P.X, 0, S.X, 0, 1 << P.Xa);
    }
    function Ve() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function jr(S, P, F, $) {
      e(F != null), e($ != null);
      var re = F[0], fe = $[0];
      return re == 0 && (re = (S * fe + P / 2) / P), fe == 0 && (fe = (P * re + S / 2) / S), 0 >= re || 0 >= fe ? 0 : (F[0] = re, $[0] = fe, 1);
    }
    function Ir(S, P) {
      return S + (1 << P) - 1 >>> P;
    }
    function rr(S, P) {
      return ((4278255360 & S) + (4278255360 & P) >>> 0 & 4278255360) + ((16711935 & S) + (16711935 & P) >>> 0 & 16711935) >>> 0;
    }
    function hr(S, P) {
      oe[P] = function(F, $, re, fe, ge, be, we) {
        var Pe;
        for (Pe = 0; Pe < ge; ++Pe) {
          var et = oe[S](be[we + Pe - 1], re, fe + Pe);
          be[we + Pe] = rr(F[$ + Pe], et);
        }
      };
    }
    function wr() {
      this.ud = this.hd = this.jd = 0;
    }
    function br(S, P) {
      return ((4278124286 & (S ^ P)) >>> 1) + (S & P) >>> 0;
    }
    function Rr(S) {
      return 0 <= S && 256 > S ? S : 0 > S ? 0 : 255 < S ? 255 : void 0;
    }
    function $r(S, P) {
      return Rr(S + (S - P + 0.5 >> 1));
    }
    function Wr(S, P, F) {
      return Math.abs(P - F) - Math.abs(S - F);
    }
    function Zr(S, P, F, $, re, fe, ge) {
      for ($ = fe[ge - 1], F = 0; F < re; ++F) fe[ge + F] = $ = rr(S[P + F], $);
    }
    function hn(S, P, F, $, re) {
      var fe;
      for (fe = 0; fe < F; ++fe) {
        var ge = S[P + fe], be = ge >> 8 & 255, we = 16711935 & (we = (we = 16711935 & ge) + ((be << 16) + be));
        $[re + fe] = (4278255360 & ge) + we >>> 0;
      }
    }
    function yn(S, P) {
      P.jd = S >> 0 & 255, P.hd = S >> 8 & 255, P.ud = S >> 16 & 255;
    }
    function Vr(S, P, F, $, re, fe) {
      var ge;
      for (ge = 0; ge < $; ++ge) {
        var be = P[F + ge], we = be >>> 8, Pe = be, et = 255 & (et = (et = be >>> 16) + ((S.jd << 24 >> 24) * (we << 24 >> 24) >>> 5));
        Pe = 255 & (Pe = (Pe = Pe + ((S.hd << 24 >> 24) * (we << 24 >> 24) >>> 5)) + ((S.ud << 24 >> 24) * (et << 24 >> 24) >>> 5)), re[fe + ge] = (4278255360 & be) + (et << 16) + Pe;
      }
    }
    function en(S, P, F, $, re) {
      oe[P] = function(fe, ge, be, we, Pe, et, ot, xt, st) {
        for (we = ot; we < xt; ++we) for (ot = 0; ot < st; ++ot) Pe[et++] = re(be[$(fe[ge++])]);
      }, oe[S] = function(fe, ge, be, we, Pe, et, ot) {
        var xt = 8 >> fe.b, st = fe.Ea, Wt = fe.K[0], Ot = fe.w;
        if (8 > xt) for (fe = (1 << fe.b) - 1, Ot = (1 << xt) - 1; ge < be; ++ge) {
          var tt, nt = 0;
          for (tt = 0; tt < st; ++tt) tt & fe || (nt = $(we[Pe++])), et[ot++] = re(Wt[nt & Ot]), nt >>= xt;
        }
        else oe["VP8LMapColor" + F](we, Pe, Wt, Ot, et, ot, ge, be, st);
      };
    }
    function Ar(S, P, F, $, re) {
      for (F = P + F; P < F; ) {
        var fe = S[P++];
        $[re++] = fe >> 16 & 255, $[re++] = fe >> 8 & 255, $[re++] = fe >> 0 & 255;
      }
    }
    function Ii(S, P, F, $, re) {
      for (F = P + F; P < F; ) {
        var fe = S[P++];
        $[re++] = fe >> 16 & 255, $[re++] = fe >> 8 & 255, $[re++] = fe >> 0 & 255, $[re++] = fe >> 24 & 255;
      }
    }
    function bn(S, P, F, $, re) {
      for (F = P + F; P < F; ) {
        var fe = (ge = S[P++]) >> 16 & 240 | ge >> 12 & 15, ge = ge >> 0 & 240 | ge >> 28 & 15;
        $[re++] = fe, $[re++] = ge;
      }
    }
    function Xi(S, P, F, $, re) {
      for (F = P + F; P < F; ) {
        var fe = (ge = S[P++]) >> 16 & 248 | ge >> 13 & 7, ge = ge >> 5 & 224 | ge >> 3 & 31;
        $[re++] = fe, $[re++] = ge;
      }
    }
    function ve(S, P, F, $, re) {
      for (F = P + F; P < F; ) {
        var fe = S[P++];
        $[re++] = fe >> 0 & 255, $[re++] = fe >> 8 & 255, $[re++] = fe >> 16 & 255;
      }
    }
    function se(S, P, F, $, re, fe) {
      if (fe == 0) for (F = P + F; P < F; ) ar($, ((fe = S[P++])[0] >> 24 | fe[1] >> 8 & 65280 | fe[2] << 8 & 16711680 | fe[3] << 24) >>> 0), re += 32;
      else n($, re, S, P, F);
    }
    function de(S, P) {
      oe[P][0] = oe[S + "0"], oe[P][1] = oe[S + "1"], oe[P][2] = oe[S + "2"], oe[P][3] = oe[S + "3"], oe[P][4] = oe[S + "4"], oe[P][5] = oe[S + "5"], oe[P][6] = oe[S + "6"], oe[P][7] = oe[S + "7"], oe[P][8] = oe[S + "8"], oe[P][9] = oe[S + "9"], oe[P][10] = oe[S + "10"], oe[P][11] = oe[S + "11"], oe[P][12] = oe[S + "12"], oe[P][13] = oe[S + "13"], oe[P][14] = oe[S + "0"], oe[P][15] = oe[S + "0"];
    }
    function pe(S) {
      return S == Gc || S == wu || S == $c || S == ec;
    }
    function Oe() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function Ge() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function rt() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new Oe(), this.f.kb = new Ge(), this.sd = null;
    }
    function gt() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function Ye() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function lt(S) {
      return alert("todo:WebPSamplerProcessPlane"), S.T;
    }
    function pt(S, P) {
      var F = S.T, $ = P.ba.f.RGBA, re = $.eb, fe = $.fb + S.ka * $.A, ge = mo[P.ba.S], be = S.y, we = S.O, Pe = S.f, et = S.N, ot = S.ea, xt = S.W, st = P.cc, Wt = P.dc, Ot = P.Mc, tt = P.Nc, nt = S.ka, qt = S.ka + S.T, Zt = S.U, dt = Zt + 1 >> 1;
      for (nt == 0 ? ge(be, we, null, null, Pe, et, ot, xt, Pe, et, ot, xt, re, fe, null, null, Zt) : (ge(P.ec, P.fc, be, we, st, Wt, Ot, tt, Pe, et, ot, xt, re, fe - $.A, re, fe, Zt), ++F); nt + 2 < qt; nt += 2) st = Pe, Wt = et, Ot = ot, tt = xt, et += S.Rc, xt += S.Rc, fe += 2 * $.A, ge(be, (we += 2 * S.fa) - S.fa, be, we, st, Wt, Ot, tt, Pe, et, ot, xt, re, fe - $.A, re, fe, Zt);
      return we += S.fa, S.j + qt < S.o ? (n(P.ec, P.fc, be, we, Zt), n(P.cc, P.dc, Pe, et, dt), n(P.Mc, P.Nc, ot, xt, dt), F--) : 1 & qt || ge(be, we, null, null, Pe, et, ot, xt, Pe, et, ot, xt, re, fe + $.A, null, null, Zt), F;
    }
    function ct(S, P, F) {
      var $ = S.F, re = [S.J];
      if ($ != null) {
        var fe = S.U, ge = P.ba.S, be = ge == vu || ge == $c;
        P = P.ba.f.RGBA;
        var we = [0], Pe = S.ka;
        we[0] = S.T, S.Kb && (Pe == 0 ? --we[0] : (--Pe, re[0] -= S.width), S.j + S.ka + S.T == S.o && (we[0] = S.o - S.j - Pe));
        var et = P.eb;
        Pe = P.fb + Pe * P.A, S = $n($, re[0], S.width, fe, we, et, Pe + (be ? 0 : 3), P.A), e(F == we), S && pe(ge) && go(et, Pe, be, fe, we, P.A);
      }
      return 0;
    }
    function We(S) {
      var P = S.ma, F = P.ba.S, $ = 11 > F, re = F == qc || F == Ql || F == vu || F == Yu || F == 12 || pe(F);
      if (P.memory = null, P.Ib = null, P.Jb = null, P.Nd = null, !$l(P.Oa, S, re ? 11 : 12)) return 0;
      if (re && pe(F) && tr(), S.da) alert("todo:use_scaling");
      else {
        if ($) {
          if (P.Ib = lt, S.Kb) {
            if (F = S.U + 1 >> 1, P.memory = s(S.U + 2 * F), P.memory == null) return 0;
            P.ec = P.memory, P.fc = 0, P.cc = P.ec, P.dc = P.fc + S.U, P.Mc = P.cc, P.Nc = P.dc + F, P.Ib = pt, tr();
          }
        } else alert("todo:EmitYUV");
        re && (P.Jb = ct, $ && mt());
      }
      if ($ && !bl) {
        for (S = 0; 256 > S; ++S) za[S] = 89858 * (S - 128) + yl >> eh, nc[S] = -22014 * (S - 128) + yl, Uf[S] = -45773 * (S - 128), vr[S] = 113618 * (S - 128) + yl >> eh;
        for (S = Xc; S < Eu; ++S) P = 76283 * (S - 16) + yl >> eh, zf[S - Xc] = Us(P, 255), Cu[S - Xc] = Us(P + 8 >> 4, 15);
        bl = 1;
      }
      return 1;
    }
    function or(S) {
      var P = S.ma, F = S.U, $ = S.T;
      return e(!(1 & S.ka)), 0 >= F || 0 >= $ ? 0 : (F = P.Ib(S, P), P.Jb != null && P.Jb(S, P, F), P.Dc += F, 1);
    }
    function Jt(S) {
      S.ma.memory = null;
    }
    function Kt(S, P, F, $) {
      return Nt(S, 8) != 47 ? 0 : (P[0] = Nt(S, 14) + 1, F[0] = Nt(S, 14) + 1, $[0] = Nt(S, 1), Nt(S, 3) != 0 ? 0 : !S.h);
    }
    function Mr(S, P) {
      if (4 > S) return S + 1;
      var F = S - 2 >> 1;
      return (2 + (1 & S) << F) + Nt(P, F) + 1;
    }
    function Bt(S, P) {
      return 120 < P ? P - 120 : 1 <= (F = ((F = Mo[P - 1]) >> 4) * S + (8 - (15 & F))) ? F : 1;
      var F;
    }
    function Qt(S, P, F) {
      var $ = Be(F), re = S[P += 255 & $].g - 8;
      return 0 < re && (Xe(F, F.u + 8), $ = Be(F), P += S[P].value, P += $ & (1 << re) - 1), Xe(F, F.u + S[P].g), S[P].value;
    }
    function fr(S, P, F) {
      return F.g += S.g, F.value += S.value << P >>> 0, e(8 >= F.g), S.g;
    }
    function Lr(S, P, F) {
      var $ = S.xc;
      return e((P = $ == 0 ? 0 : S.vc[S.md * (F >> $) + (P >> $)]) < S.Wb), S.Ya[P];
    }
    function Hr(S, P, F, $) {
      var re = S.ab, fe = S.c * P, ge = S.C;
      P = ge + P;
      var be = F, we = $;
      for ($ = S.Ta, F = S.Ua; 0 < re--; ) {
        var Pe = S.gc[re], et = ge, ot = P, xt = be, st = we, Wt = (we = $, be = F, Pe.Ea);
        switch (e(et < ot), e(ot <= Pe.nc), Pe.hc) {
          case 2:
            An(xt, st, (ot - et) * Wt, we, be);
            break;
          case 0:
            var Ot = et, tt = ot, nt = we, qt = be, Zt = (xr = Pe).Ea;
            Ot == 0 && (La(xt, st, null, null, 1, nt, qt), Zr(xt, st + 1, 0, 0, Zt - 1, nt, qt + 1), st += Zt, qt += Zt, ++Ot);
            for (var dt = 1 << xr.b, Vt = dt - 1, yr = Ir(Zt, xr.b), Ur = xr.K, xr = xr.w + (Ot >> xr.b) * yr; Ot < tt; ) {
              var rn = Ur, Ln = xr, on = 1;
              for (Wl(xt, st, nt, qt - Zt, 1, nt, qt); on < Zt; ) {
                var wn = (on & ~Vt) + dt;
                wn > Zt && (wn = Zt), (0, ul[rn[Ln++] >> 8 & 15])(xt, st + +on, nt, qt + on - Zt, wn - on, nt, qt + on), on = wn;
              }
              st += Zt, qt += Zt, ++Ot & Vt || (xr += yr);
            }
            ot != Pe.nc && n(we, be - Wt, we, be + (ot - et - 1) * Wt, Wt);
            break;
          case 1:
            for (Wt = xt, tt = st, Zt = (xt = Pe.Ea) - (qt = xt & ~(nt = (st = 1 << Pe.b) - 1)), Ot = Ir(xt, Pe.b), dt = Pe.K, Pe = Pe.w + (et >> Pe.b) * Ot; et < ot; ) {
              for (Vt = dt, yr = Pe, Ur = new wr(), xr = tt + qt, rn = tt + xt; tt < xr; ) yn(Vt[yr++], Ur), hl(Ur, Wt, tt, st, we, be), tt += st, be += st;
              tt < rn && (yn(Vt[yr++], Ur), hl(Ur, Wt, tt, Zt, we, be), tt += Zt, be += Zt), ++et & nt || (Pe += Ot);
            }
            break;
          case 3:
            if (xt == we && st == be && 0 < Pe.b) {
              for (tt = we, xt = Wt = be + (ot - et) * Wt - (qt = (ot - et) * Ir(Pe.Ea, Pe.b)), st = we, nt = be, Ot = [], qt = (Zt = qt) - 1; 0 <= qt; --qt) Ot[qt] = st[nt + qt];
              for (qt = Zt - 1; 0 <= qt; --qt) tt[xt + qt] = Ot[qt];
              Eo(Pe, et, ot, we, Wt, we, be);
            } else Eo(Pe, et, ot, xt, st, we, be);
        }
        be = $, we = F;
      }
      we != F && n($, F, be, we, fe);
    }
    function Or(S, P) {
      var F = S.V, $ = S.Ba + S.c * S.C, re = P - S.C;
      if (e(P <= S.l.o), e(16 >= re), 0 < re) {
        var fe = S.l, ge = S.Ta, be = S.Ua, we = fe.width;
        if (Hr(S, re, F, $), re = be = [be], e((F = S.C) < ($ = P)), e(fe.v < fe.va), $ > fe.o && ($ = fe.o), F < fe.j) {
          var Pe = fe.j - F;
          F = fe.j, re[0] += Pe * we;
        }
        if (F >= $ ? F = 0 : (re[0] += 4 * fe.v, fe.ka = F - fe.j, fe.U = fe.va - fe.v, fe.T = $ - F, F = 1), F) {
          if (be = be[0], 11 > (F = S.ca).S) {
            var et = F.f.RGBA, ot = ($ = F.S, re = fe.U, fe = fe.T, Pe = et.eb, et.A), xt = fe;
            for (et = et.fb + S.Ma * et.A; 0 < xt--; ) {
              var st = ge, Wt = be, Ot = re, tt = Pe, nt = et;
              switch ($) {
                case Jl:
                  ms(st, Wt, Ot, tt, nt);
                  break;
                case qc:
                  Ji(st, Wt, Ot, tt, nt);
                  break;
                case Gc:
                  Ji(st, Wt, Ot, tt, nt), go(tt, nt, 0, Ot, 1, 0);
                  break;
                case Nf:
                  zs(st, Wt, Ot, tt, nt);
                  break;
                case Ql:
                  se(st, Wt, Ot, tt, nt, 1);
                  break;
                case wu:
                  se(st, Wt, Ot, tt, nt, 1), go(tt, nt, 0, Ot, 1, 0);
                  break;
                case vu:
                  se(st, Wt, Ot, tt, nt, 0);
                  break;
                case $c:
                  se(st, Wt, Ot, tt, nt, 0), go(tt, nt, 1, Ot, 1, 0);
                  break;
                case Yu:
                  Ko(st, Wt, Ot, tt, nt);
                  break;
                case ec:
                  Ko(st, Wt, Ot, tt, nt), Bn(tt, nt, Ot, 1, 0);
                  break;
                case xu:
                  Jo(st, Wt, Ot, tt, nt);
                  break;
                default:
                  e(0);
              }
              be += we, et += ot;
            }
            S.Ma += fe;
          } else alert("todo:EmitRescaledRowsYUVA");
          e(S.Ma <= F.height);
        }
      }
      S.C = P, e(S.C <= S.i);
    }
    function gr(S) {
      var P;
      if (0 < S.ua) return 0;
      for (P = 0; P < S.Wb; ++P) {
        var F = S.Ya[P].G, $ = S.Ya[P].H;
        if (0 < F[1][$[1] + 0].g || 0 < F[2][$[2] + 0].g || 0 < F[3][$[3] + 0].g) return 0;
      }
      return 1;
    }
    function Sn(S, P, F, $, re, fe) {
      if (S.Z != 0) {
        var ge = S.qd, be = S.rd;
        for (e(Ua[S.Z] != null); P < F; ++P) Ua[S.Z](ge, be, $, re, $, re, fe), ge = $, be = re, re += fe;
        S.qd = ge, S.rd = be;
      }
    }
    function Zi(S, P) {
      var F = S.l.ma, $ = F.Z == 0 || F.Z == 1 ? S.l.j : S.C;
      if ($ = S.C < $ ? $ : S.C, e(P <= S.l.o), P > $) {
        var re = S.l.width, fe = F.ca, ge = F.tb + re * $, be = S.V, we = S.Ba + S.c * $, Pe = S.gc;
        e(S.ab == 1), e(Pe[0].hc == 3), Zu(Pe[0], $, P, be, we, fe, ge), Sn(F, $, P, fe, ge, re);
      }
      S.C = S.Ma = P;
    }
    function Dn(S, P, F, $, re, fe, ge) {
      var be = S.$ / $, we = S.$ % $, Pe = S.m, et = S.s, ot = F + S.$, xt = ot;
      re = F + $ * re;
      var st = F + $ * fe, Wt = 280 + et.ua, Ot = S.Pb ? be : 16777216, tt = 0 < et.ua ? et.Wa : null, nt = et.wc, qt = ot < st ? Lr(et, we, be) : null;
      e(S.C < fe), e(st <= re);
      var Zt = !1;
      e: for (; ; ) {
        for (; Zt || ot < st; ) {
          var dt = 0;
          if (be >= Ot) {
            var Vt = ot - F;
            e((Ot = S).Pb), Ot.wd = Ot.m, Ot.xd = Vt, 0 < Ot.s.ua && Ut(Ot.s.Wa, Ot.s.vb), Ot = be + zh;
          }
          if (we & nt || (qt = Lr(et, we, be)), e(qt != null), qt.Qb && (P[ot] = qt.qb, Zt = !0), !Zt) if (it(Pe), qt.jc) {
            dt = Pe, Vt = P;
            var yr = ot, Ur = qt.pd[Be(dt) & ri - 1];
            e(qt.jc), 256 > Ur.g ? (Xe(dt, dt.u + Ur.g), Vt[yr] = Ur.value, dt = 0) : (Xe(dt, dt.u + Ur.g - 256), e(256 <= Ur.value), dt = Ur.value), dt == 0 && (Zt = !0);
          } else dt = Qt(qt.G[0], qt.H[0], Pe);
          if (Pe.h) break;
          if (Zt || 256 > dt) {
            if (!Zt) if (qt.nd) P[ot] = (qt.qb | dt << 8) >>> 0;
            else {
              if (it(Pe), Zt = Qt(qt.G[1], qt.H[1], Pe), it(Pe), Vt = Qt(qt.G[2], qt.H[2], Pe), yr = Qt(qt.G[3], qt.H[3], Pe), Pe.h) break;
              P[ot] = (yr << 24 | Zt << 16 | dt << 8 | Vt) >>> 0;
            }
            if (Zt = !1, ++ot, ++we >= $ && (we = 0, ++be, ge != null && be <= fe && !(be % 16) && ge(S, be), tt != null)) for (; xt < ot; ) dt = P[xt++], tt.X[(506832829 * dt & 4294967295) >>> tt.Mb] = dt;
          } else if (280 > dt) {
            if (dt = Mr(dt - 256, Pe), Vt = Qt(qt.G[4], qt.H[4], Pe), it(Pe), Vt = Bt($, Vt = Mr(Vt, Pe)), Pe.h) break;
            if (ot - F < Vt || re - ot < dt) break e;
            for (yr = 0; yr < dt; ++yr) P[ot + yr] = P[ot + yr - Vt];
            for (ot += dt, we += dt; we >= $; ) we -= $, ++be, ge != null && be <= fe && !(be % 16) && ge(S, be);
            if (e(ot <= re), we & nt && (qt = Lr(et, we, be)), tt != null) for (; xt < ot; ) dt = P[xt++], tt.X[(506832829 * dt & 4294967295) >>> tt.Mb] = dt;
          } else {
            if (!(dt < Wt)) break e;
            for (Zt = dt - 280, e(tt != null); xt < ot; ) dt = P[xt++], tt.X[(506832829 * dt & 4294967295) >>> tt.Mb] = dt;
            dt = ot, e(!(Zt >>> (Vt = tt).Xa)), P[dt] = Vt.X[Zt], Zt = !0;
          }
          Zt || e(Pe.h == Ue(Pe));
        }
        if (S.Pb && Pe.h && ot < re) e(S.m.h), S.a = 5, S.m = S.wd, S.$ = S.xd, 0 < S.s.ua && Ut(S.s.vb, S.s.Wa);
        else {
          if (Pe.h) break e;
          ge != null && ge(S, be > fe ? fe : be), S.a = 0, S.$ = ot - F;
        }
        return 1;
      }
      return S.a = 3, 0;
    }
    function kn(S) {
      e(S != null), S.vc = null, S.yc = null, S.Ya = null;
      var P = S.Wa;
      P != null && (P.X = null), S.vb = null, e(S != null);
    }
    function vn() {
      var S = new yu();
      return S == null ? null : (S.a = 0, S.xb = Gh, de("Predictor", "VP8LPredictors"), de("Predictor", "VP8LPredictors_C"), de("PredictorAdd", "VP8LPredictorsAdd"), de("PredictorAdd", "VP8LPredictorsAdd_C"), An = hn, hl = Vr, ms = Ar, Ji = Ii, Ko = bn, Jo = Xi, zs = ve, oe.VP8LMapColor32b = jc, oe.VP8LMapColor8b = bu, S);
    }
    function Ai(S, P, F, $, re) {
      var fe = 1, ge = [S], be = [P], we = $.m, Pe = $.s, et = null, ot = 0;
      e: for (; ; ) {
        if (F) for (; fe && Nt(we, 1); ) {
          var xt = ge, st = be, Wt = $, Ot = 1, tt = Wt.m, nt = Wt.gc[Wt.ab], qt = Nt(tt, 2);
          if (Wt.Oc & 1 << qt) fe = 0;
          else {
            switch (Wt.Oc |= 1 << qt, nt.hc = qt, nt.Ea = xt[0], nt.nc = st[0], nt.K = [null], ++Wt.ab, e(4 >= Wt.ab), qt) {
              case 0:
              case 1:
                nt.b = Nt(tt, 3) + 2, Ot = Ai(Ir(nt.Ea, nt.b), Ir(nt.nc, nt.b), 0, Wt, nt.K), nt.K = nt.K[0];
                break;
              case 3:
                var Zt, dt = Nt(tt, 8) + 1, Vt = 16 < dt ? 0 : 4 < dt ? 1 : 2 < dt ? 2 : 3;
                if (xt[0] = Ir(nt.Ea, Vt), nt.b = Vt, Zt = Ot = Ai(dt, 1, 0, Wt, nt.K)) {
                  var yr, Ur = dt, xr = nt, rn = 1 << (8 >> xr.b), Ln = s(rn);
                  if (Ln == null) Zt = 0;
                  else {
                    var on = xr.K[0], wn = xr.w;
                    for (Ln[0] = xr.K[0][0], yr = 1; yr < 1 * Ur; ++yr) Ln[yr] = rr(on[wn + yr], Ln[yr - 1]);
                    for (; yr < 4 * rn; ++yr) Ln[yr] = 0;
                    xr.K[0] = null, xr.K[0] = Ln, Zt = 1;
                  }
                }
                Ot = Zt;
                break;
              case 2:
                break;
              default:
                e(0);
            }
            fe = Ot;
          }
        }
        if (ge = ge[0], be = be[0], fe && Nt(we, 1) && !(fe = 1 <= (ot = Nt(we, 4)) && 11 >= ot)) {
          $.a = 3;
          break e;
        }
        var Mn;
        if (Mn = fe) t: {
          var zr, Br, Bi, es = $, li = ge, Ps = be, Pn = ot, Li = F, ts = es.m, Ei = es.s, zi = [null], Gi = 1, to = 0, Vs = Uh[Pn];
          r: for (; ; ) {
            if (Li && Nt(ts, 1)) {
              var ci = Nt(ts, 3) + 2, ea = Ir(li, ci), ya = Ir(Ps, ci), _o = ea * ya;
              if (!Ai(ea, ya, 0, es, zi)) break r;
              for (zi = zi[0], Ei.xc = ci, zr = 0; zr < _o; ++zr) {
                var ba = zi[zr] >> 8 & 65535;
                zi[zr] = ba, ba >= Gi && (Gi = ba + 1);
              }
            }
            if (ts.h) break r;
            for (Br = 0; 5 > Br; ++Br) {
              var ui = Tu[Br];
              !Br && 0 < Pn && (ui += 1 << Pn), to < ui && (to = ui);
            }
            var ic = l(Gi * Vs, _e), th = Gi, v = l(th, Me);
            if (v == null) var a = null;
            else e(65536 >= th), a = v;
            var u = s(to);
            if (a == null || u == null || ic == null) {
              es.a = 1;
              break r;
            }
            var g = ic;
            for (zr = Bi = 0; zr < Gi; ++zr) {
              var _ = a[zr], w = _.G, C = _.H, R = 0, L = 1, k = 0;
              for (Br = 0; 5 > Br; ++Br) {
                ui = Tu[Br], w[Br] = g, C[Br] = Bi, !Br && 0 < Pn && (ui += 1 << Pn);
                i: {
                  var V, W = ui, Z = es, ae = u, ue = g, Ce = Bi, Se = 0, Ie = Z.m, Le = Nt(Ie, 1);
                  if (i(ae, 0, 0, W), Le) {
                    var qe = Nt(Ie, 1) + 1, $e = Nt(Ie, 1), He = Nt(Ie, $e == 0 ? 1 : 8);
                    ae[He] = 1, qe == 2 && (ae[He = Nt(Ie, 8)] = 1);
                    var Ze = 1;
                  } else {
                    var Je = s(19), vt = Nt(Ie, 4) + 4;
                    if (19 < vt) {
                      Z.a = 3;
                      var _t = 0;
                      break i;
                    }
                    for (V = 0; V < vt; ++V) Je[tc[V]] = Nt(Ie, 3);
                    var Rt = void 0, Ft = void 0, Mt = Z, sr = Je, nr = W, Gt = ae, dr = 0, Gr = Mt.m, mn = 8, Jn = l(128, _e);
                    n: for (; me(Jn, 0, 7, sr, 19); ) {
                      if (Nt(Gr, 1)) {
                        var zn = 2 + 2 * Nt(Gr, 3);
                        if ((Rt = 2 + Nt(Gr, zn)) > nr) break n;
                      } else Rt = nr;
                      for (Ft = 0; Ft < nr && Rt--; ) {
                        it(Gr);
                        var Qn = Jn[0 + (127 & Be(Gr))];
                        Xe(Gr, Gr.u + Qn.g);
                        var Tn = Qn.value;
                        if (16 > Tn) Gt[Ft++] = Tn, Tn != 0 && (mn = Tn);
                        else {
                          var On = Tn == 16, Nn = Tn - 16, ys = Fh[Nn], Oi = Nt(Gr, Au[Nn]) + ys;
                          if (Ft + Oi > nr) break n;
                          for (var ji = On ? mn : 0; 0 < Oi--; ) Gt[Ft++] = ji;
                        }
                      }
                      dr = 1;
                      break n;
                    }
                    dr || (Mt.a = 3), Ze = dr;
                  }
                  (Ze = Ze && !Ie.h) && (Se = me(ue, Ce, 8, ae, W)), Ze && Se != 0 ? _t = Se : (Z.a = 3, _t = 0);
                }
                if (_t == 0) break r;
                if (L && ni[Br] == 1 && (L = g[Bi].g == 0), R += g[Bi].g, Bi += _t, 3 >= Br) {
                  var $i, ta = u[0];
                  for ($i = 1; $i < ui; ++$i) u[$i] > ta && (ta = u[$i]);
                  k += ta;
                }
              }
              if (_.nd = L, _.Qb = 0, L && (_.qb = (w[3][C[3] + 0].value << 24 | w[1][C[1] + 0].value << 16 | w[2][C[2] + 0].value) >>> 0, R == 0 && 256 > w[0][C[0] + 0].value && (_.Qb = 1, _.qb += w[0][C[0] + 0].value << 8)), _.jc = !_.Qb && 6 > k, _.jc) {
                var yo, Ni = _;
                for (yo = 0; yo < ri; ++yo) {
                  var Rs = yo, Ro = Ni.pd[Rs], vl = Ni.G[0][Ni.H[0] + Rs];
                  256 <= vl.value ? (Ro.g = vl.g + 256, Ro.value = vl.value) : (Ro.g = 0, Ro.value = 0, Rs >>= fr(vl, 8, Ro), Rs >>= fr(Ni.G[1][Ni.H[1] + Rs], 16, Ro), Rs >>= fr(Ni.G[2][Ni.H[2] + Rs], 0, Ro), fr(Ni.G[3][Ni.H[3] + Rs], 24, Ro));
                }
              }
            }
            Ei.vc = zi, Ei.Wb = Gi, Ei.Ya = a, Ei.yc = ic, Mn = 1;
            break t;
          }
          Mn = 0;
        }
        if (!(fe = Mn)) {
          $.a = 3;
          break e;
        }
        if (0 < ot) {
          if (Pe.ua = 1 << ot, !Cr(Pe.Wa, ot)) {
            $.a = 1, fe = 0;
            break e;
          }
        } else Pe.ua = 0;
        var xl = $, qs = ge, Bo = be, ro = xl.s, Gs = ro.xc;
        if (xl.c = qs, xl.i = Bo, ro.md = Ir(qs, Gs), ro.wc = Gs == 0 ? -1 : (1 << Gs) - 1, F) {
          $.xb = kf;
          break e;
        }
        if ((et = s(ge * be)) == null) {
          $.a = 1, fe = 0;
          break e;
        }
        fe = (fe = Dn($, et, 0, ge, be, be, null)) && !we.h;
        break e;
      }
      return fe ? (re != null ? re[0] = et : (e(et == null), e(F)), $.$ = 0, F || kn(Pe)) : kn(Pe), fe;
    }
    function In(S, P) {
      var F = S.c * S.i, $ = F + P + 16 * P;
      return e(S.c <= P), S.V = s($), S.V == null ? (S.Ta = null, S.Ua = 0, S.a = 1, 0) : (S.Ta = S.V, S.Ua = S.Ba + F + P, 1);
    }
    function aa(S, P) {
      var F = S.C, $ = P - F, re = S.V, fe = S.Ba + S.c * F;
      for (e(P <= S.l.o); 0 < $; ) {
        var ge = 16 < $ ? 16 : $, be = S.l.ma, we = S.l.width, Pe = we * ge, et = be.ca, ot = be.tb + we * F, xt = S.Ta, st = S.Ua;
        Hr(S, ge, re, fe), Ri(xt, st, et, ot, Pe), Sn(be, F, F + ge, et, ot, we), $ -= ge, re += ge * S.c, F += ge;
      }
      e(F == P), S.C = S.Ma = P;
    }
    function Wo() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function tl() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function wo() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = s(4), this.Lb = s(4);
    }
    function la() {
      this.Yb = function() {
        var S = [];
        return function P(F, $, re) {
          for (var fe = re[$], ge = 0; ge < fe && (F.push(re.length > $ + 1 ? [] : 0), !(re.length < $ + 1)); ge++) P(F[ge], $ + 1, re);
        }(S, 0, [3, 11]), S;
      }();
    }
    function ju() {
      this.jb = s(3), this.Wc = o([4, 8], la), this.Xc = o([4, 17], la);
    }
    function hu() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new s(4), this.od = new s(4);
    }
    function Pl() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Ca() {
      this.Na = this.la = 0;
    }
    function Vu() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function fu() {
      this.ad = s(384), this.Za = 0, this.Ob = s(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function kh() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Pl()), this.Y = 0, this.ya = Array(new fu()), this.aa = 0, this.l = new rl();
    }
    function qu() {
      this.y = s(16), this.f = s(8), this.ea = s(8);
    }
    function Gu() {
      this.cb = this.a = 0, this.sc = "", this.m = new mr(), this.Od = new Wo(), this.Kc = new tl(), this.ed = new hu(), this.Qa = new wo(), this.Ic = this.$c = this.Aa = 0, this.D = new kh(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = l(8, mr), this.ia = 0, this.pb = l(4, Vu), this.Pa = new ju(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new qu()), this.Hd = 0, this.rb = Array(new Ca()), this.sb = 0, this.wa = Array(new Pl()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new fu()), this.L = this.aa = 0, this.gd = o([4, 2], Pl), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function rl() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Ia() {
      var S = new Gu();
      return S != null && (S.a = 0, S.sc = "OK", S.cb = 0, S.Xb = 0, ga || (ga = Nc)), S;
    }
    function pi(S, P, F) {
      return S.a == 0 && (S.a = P, S.sc = F, S.cb = 0), 0;
    }
    function du(S, P, F) {
      return 3 <= F && S[P + 0] == 157 && S[P + 1] == 1 && S[P + 2] == 42;
    }
    function ca(S, P) {
      if (S == null) return 0;
      if (S.a = 0, S.sc = "OK", P == null) return pi(S, 2, "null VP8Io passed to VP8GetHeaders()");
      var F = P.data, $ = P.w, re = P.ha;
      if (4 > re) return pi(S, 7, "Truncated header.");
      var fe = F[$ + 0] | F[$ + 1] << 8 | F[$ + 2] << 16, ge = S.Od;
      if (ge.Rb = !(1 & fe), ge.td = fe >> 1 & 7, ge.yd = fe >> 4 & 1, ge.ub = fe >> 5, 3 < ge.td) return pi(S, 3, "Incorrect keyframe parameters.");
      if (!ge.yd) return pi(S, 4, "Frame not displayable.");
      $ += 3, re -= 3;
      var be = S.Kc;
      if (ge.Rb) {
        if (7 > re) return pi(S, 7, "cannot parse picture header");
        if (!du(F, $, re)) return pi(S, 3, "Bad code word");
        be.c = 16383 & (F[$ + 4] << 8 | F[$ + 3]), be.Td = F[$ + 4] >> 6, be.i = 16383 & (F[$ + 6] << 8 | F[$ + 5]), be.Ud = F[$ + 6] >> 6, $ += 7, re -= 7, S.za = be.c + 15 >> 4, S.Ub = be.i + 15 >> 4, P.width = be.c, P.height = be.i, P.Da = 0, P.j = 0, P.v = 0, P.va = P.width, P.o = P.height, P.da = 0, P.ib = P.width, P.hb = P.height, P.U = P.width, P.T = P.height, i((fe = S.Pa).jb, 0, 255, fe.jb.length), e((fe = S.Qa) != null), fe.Cb = 0, fe.Bb = 0, fe.Fb = 1, i(fe.Zb, 0, 0, fe.Zb.length), i(fe.Lb, 0, 0, fe.Lb);
      }
      if (ge.ub > re) return pi(S, 7, "bad partition length");
      Ct(fe = S.m, F, $, ge.ub), $ += ge.ub, re -= ge.ub, ge.Rb && (be.Ld = St(fe), be.Kd = St(fe)), be = S.Qa;
      var we, Pe = S.Pa;
      if (e(fe != null), e(be != null), be.Cb = St(fe), be.Cb) {
        if (be.Bb = St(fe), St(fe)) {
          for (be.Fb = St(fe), we = 0; 4 > we; ++we) be.Zb[we] = St(fe) ? Pt(fe, 7) : 0;
          for (we = 0; 4 > we; ++we) be.Lb[we] = St(fe) ? Pt(fe, 6) : 0;
        }
        if (be.Bb) for (we = 0; 3 > we; ++we) Pe.jb[we] = St(fe) ? ht(fe, 8) : 255;
      } else be.Bb = 0;
      if (fe.Ka) return pi(S, 3, "cannot parse segment header");
      if ((be = S.ed).zd = St(fe), be.Tb = ht(fe, 6), be.wb = ht(fe, 3), be.Pc = St(fe), be.Pc && St(fe)) {
        for (Pe = 0; 4 > Pe; ++Pe) St(fe) && (be.vd[Pe] = Pt(fe, 6));
        for (Pe = 0; 4 > Pe; ++Pe) St(fe) && (be.od[Pe] = Pt(fe, 6));
      }
      if (S.L = be.Tb == 0 ? 0 : be.zd ? 1 : 2, fe.Ka) return pi(S, 3, "cannot parse filter header");
      var et = re;
      if (re = we = $, $ = we + et, be = et, S.Xb = (1 << ht(S.m, 2)) - 1, et < 3 * (Pe = S.Xb)) F = 7;
      else {
        for (we += 3 * Pe, be -= 3 * Pe, et = 0; et < Pe; ++et) {
          var ot = F[re + 0] | F[re + 1] << 8 | F[re + 2] << 16;
          ot > be && (ot = be), Ct(S.Jc[+et], F, we, ot), we += ot, be -= ot, re += 3;
        }
        Ct(S.Jc[+Pe], F, we, be), F = we < $ ? 0 : 5;
      }
      if (F != 0) return pi(S, F, "cannot parse partitions");
      for (F = ht(we = S.m, 7), re = St(we) ? Pt(we, 4) : 0, $ = St(we) ? Pt(we, 4) : 0, be = St(we) ? Pt(we, 4) : 0, Pe = St(we) ? Pt(we, 4) : 0, we = St(we) ? Pt(we, 4) : 0, et = S.Qa, ot = 0; 4 > ot; ++ot) {
        if (et.Cb) {
          var xt = et.Zb[ot];
          et.Fb || (xt += F);
        } else {
          if (0 < ot) {
            S.pb[ot] = S.pb[0];
            continue;
          }
          xt = F;
        }
        var st = S.pb[ot];
        st.Sc[0] = Ku[Us(xt + re, 127)], st.Sc[1] = ml[Us(xt + 0, 127)], st.Eb[0] = 2 * Ku[Us(xt + $, 127)], st.Eb[1] = 101581 * ml[Us(xt + be, 127)] >> 16, 8 > st.Eb[1] && (st.Eb[1] = 8), st.Qc[0] = Ku[Us(xt + Pe, 117)], st.Qc[1] = ml[Us(xt + we, 127)], st.lc = xt + we;
      }
      if (!ge.Rb) return pi(S, 4, "Not a key frame.");
      for (St(fe), ge = S.Pa, F = 0; 4 > F; ++F) {
        for (re = 0; 8 > re; ++re) for ($ = 0; 3 > $; ++$) for (be = 0; 11 > be; ++be) Pe = wt(fe, Df[F][re][$][be]) ? ht(fe, 8) : Vh[F][re][$][be], ge.Wc[F][re].Yb[$][be] = Pe;
        for (re = 0; 17 > re; ++re) ge.Xc[F][re] = ge.Wc[F][_l[re]];
      }
      return S.kc = St(fe), S.kc && (S.Bd = ht(fe, 8)), S.cb = 1;
    }
    function Nc(S, P, F, $, re, fe, ge) {
      var be = P[re].Yb[F];
      for (F = 0; 16 > re; ++re) {
        if (!wt(S, be[F + 0])) return re;
        for (; !wt(S, be[F + 1]); ) if (be = P[++re].Yb[0], F = 0, re == 16) return 16;
        var we = P[re + 1].Yb;
        if (wt(S, be[F + 2])) {
          var Pe = S, et = 0;
          if (wt(Pe, (xt = be)[(ot = F) + 3]))
            if (wt(Pe, xt[ot + 6])) {
              for (be = 0, ot = 2 * (et = wt(Pe, xt[ot + 8])) + (xt = wt(Pe, xt[ot + 9 + et])), et = 0, xt = Ju[ot]; xt[be]; ++be) et += et + wt(Pe, xt[be]);
              et += 3 + (8 << ot);
            } else wt(Pe, xt[ot + 7]) ? (et = 7 + 2 * wt(Pe, 165), et += wt(Pe, 145)) : et = 5 + wt(Pe, 159);
          else et = wt(Pe, xt[ot + 4]) ? 3 + wt(Pe, xt[ot + 5]) : 2;
          be = we[2];
        } else et = 1, be = we[1];
        we = ge + Su[re], 0 > (Pe = S).b && ft(Pe);
        var ot, xt = Pe.b, st = (ot = Pe.Ca >> 1) - (Pe.I >> xt) >> 31;
        --Pe.b, Pe.Ca += st, Pe.Ca |= 1, Pe.I -= (ot + 1 & st) << xt, fe[we] = ((et ^ st) - st) * $[(0 < re) + 0];
      }
      return 16;
    }
    function nl(S) {
      var P = S.rb[S.sb - 1];
      P.la = 0, P.Na = 0, i(S.zc, 0, 0, S.zc.length), S.ja = 0;
    }
    function $u(S, P) {
      if (S == null) return 0;
      if (P == null) return pi(S, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!S.cb && !ca(S, P)) return 0;
      if (e(S.cb), P.ac == null || P.ac(P)) {
        P.ob && (S.L = 0);
        var F = Iu[S.L];
        if (S.L == 2 ? (S.yb = 0, S.zb = 0) : (S.yb = P.v - F >> 4, S.zb = P.j - F >> 4, 0 > S.yb && (S.yb = 0), 0 > S.zb && (S.zb = 0)), S.Va = P.o + 15 + F >> 4, S.Hb = P.va + 15 + F >> 4, S.Hb > S.za && (S.Hb = S.za), S.Va > S.Ub && (S.Va = S.Ub), 0 < S.L) {
          var $ = S.ed;
          for (F = 0; 4 > F; ++F) {
            var re;
            if (S.Qa.Cb) {
              var fe = S.Qa.Lb[F];
              S.Qa.Fb || (fe += $.Tb);
            } else fe = $.Tb;
            for (re = 0; 1 >= re; ++re) {
              var ge = S.gd[F][re], be = fe;
              if ($.Pc && (be += $.vd[0], re && (be += $.od[0])), 0 < (be = 0 > be ? 0 : 63 < be ? 63 : be)) {
                var we = be;
                0 < $.wb && (we = 4 < $.wb ? we >> 2 : we >> 1) > 9 - $.wb && (we = 9 - $.wb), 1 > we && (we = 1), ge.dd = we, ge.tc = 2 * be + we, ge.ld = 40 <= be ? 2 : 15 <= be ? 1 : 0;
              } else ge.tc = 0;
              ge.La = re;
            }
          }
        }
        F = 0;
      } else pi(S, 6, "Frame setup failed"), F = S.a;
      if (F = F == 0) {
        if (F) {
          S.$c = 0, 0 < S.Aa || (S.Ic = Zc);
          e: {
            F = S.Ic, $ = 4 * (we = S.za);
            var Pe = 32 * we, et = we + 1, ot = 0 < S.L ? we * (0 < S.Aa ? 2 : 1) : 0, xt = (S.Aa == 2 ? 2 : 1) * we;
            if ((ge = $ + 832 + (re = 3 * (16 * F + Iu[S.L]) / 2 * Pe) + (fe = S.Fa != null && 0 < S.Fa.length ? S.Kc.c * S.Kc.i : 0)) != ge) F = 0;
            else {
              if (ge > S.Vb) {
                if (S.Vb = 0, S.Ec = s(ge), S.Fc = 0, S.Ec == null) {
                  F = pi(S, 1, "no memory during frame initialization.");
                  break e;
                }
                S.Vb = ge;
              }
              ge = S.Ec, be = S.Fc, S.Ac = ge, S.Bc = be, be += $, S.Gd = l(Pe, qu), S.Hd = 0, S.rb = l(et + 1, Ca), S.sb = 1, S.wa = ot ? l(ot, Pl) : null, S.Y = 0, S.D.Nb = 0, S.D.wa = S.wa, S.D.Y = S.Y, 0 < S.Aa && (S.D.Y += we), e(!0), S.oc = ge, S.pc = be, be += 832, S.ya = l(xt, fu), S.aa = 0, S.D.ya = S.ya, S.D.aa = S.aa, S.Aa == 2 && (S.D.aa += we), S.R = 16 * we, S.B = 8 * we, we = (Pe = Iu[S.L]) * S.R, Pe = Pe / 2 * S.B, S.sa = ge, S.ta = be + we, S.qa = S.sa, S.ra = S.ta + 16 * F * S.R + Pe, S.Ha = S.qa, S.Ia = S.ra + 8 * F * S.B + Pe, S.$c = 0, be += re, S.mb = fe ? ge : null, S.nb = fe ? be : null, e(be + fe <= S.Fc + S.Vb), nl(S), i(S.Ac, S.Bc, 0, $), F = 1;
            }
          }
          if (F) {
            if (P.ka = 0, P.y = S.sa, P.O = S.ta, P.f = S.qa, P.N = S.ra, P.ea = S.Ha, P.Vd = S.Ia, P.fa = S.R, P.Rc = S.B, P.F = null, P.J = 0, !Yl) {
              for (F = -255; 255 >= F; ++F) Ui[255 + F] = 0 > F ? -F : F;
              for (F = -1020; 1020 >= F; ++F) ka[1020 + F] = -128 > F ? -128 : 127 < F ? 127 : F;
              for (F = -112; 112 >= F; ++F) pl[112 + F] = -16 > F ? -16 : 15 < F ? 15 : F;
              for (F = -255; 510 >= F; ++F) Fa[255 + F] = 0 > F ? 0 : 255 < F ? 255 : F;
              Yl = 1;
            }
            Qo = oi, Fi = nn, Vc = Rl, _s = Hu, Qi = sl, Si = co, Oa = kl, Xl = Qs, Na = Uc, pa = Fl, fl = Wu, po = Fc, Co = _u, Zl = Ul, Da = al, sn = gn, dl = Ks, Io = ho, Is[0] = Ki, Is[1] = Kn, Is[2] = Ys, Is[3] = gu, Is[4] = Ll, Is[5] = Xo, Is[6] = Fn, Is[7] = ln, Is[8] = Ol, Is[9] = Xr, ma[0] = ua, ma[1] = Yi, ma[2] = ai, ma[3] = Mi, ma[4] = an, ma[5] = Bl, ma[6] = uo, _a[0] = Ao, _a[1] = pu, _a[2] = dn, _a[3] = ha, _a[4] = Zo, _a[5] = Nl, _a[6] = Yo, F = 1;
          } else F = 0;
        }
        F && (F = function(st, Wt) {
          for (st.M = 0; st.M < st.Va; ++st.M) {
            var Ot, tt = st.Jc[st.M & st.Xb], nt = st.m, qt = st;
            for (Ot = 0; Ot < qt.za; ++Ot) {
              var Zt = nt, dt = qt, Vt = dt.Ac, yr = dt.Bc + 4 * Ot, Ur = dt.zc, xr = dt.ya[dt.aa + Ot];
              if (dt.Qa.Bb ? xr.$b = wt(Zt, dt.Pa.jb[0]) ? 2 + wt(Zt, dt.Pa.jb[2]) : wt(Zt, dt.Pa.jb[1]) : xr.$b = 0, dt.kc && (xr.Ad = wt(Zt, dt.Bd)), xr.Za = !wt(Zt, 145) + 0, xr.Za) {
                var rn = xr.Ob, Ln = 0;
                for (dt = 0; 4 > dt; ++dt) {
                  var on, wn = Ur[0 + dt];
                  for (on = 0; 4 > on; ++on) {
                    wn = qh[Vt[yr + on]][wn];
                    for (var Mn = jh[wt(Zt, wn[0])]; 0 < Mn; ) Mn = jh[2 * Mn + wt(Zt, wn[Mn])];
                    wn = -Mn, Vt[yr + on] = wn;
                  }
                  n(rn, Ln, Vt, yr, 4), Ln += 4, Ur[0 + dt] = wn;
                }
              } else wn = wt(Zt, 156) ? wt(Zt, 128) ? 1 : 3 : wt(Zt, 163) ? 2 : 0, xr.Ob[0] = wn, i(Vt, yr, wn, 4), i(Ur, 0, wn, 4);
              xr.Dd = wt(Zt, 142) ? wt(Zt, 114) ? wt(Zt, 183) ? 1 : 3 : 2 : 0;
            }
            if (qt.m.Ka) return pi(st, 7, "Premature end-of-partition0 encountered.");
            for (; st.ja < st.za; ++st.ja) {
              if (qt = tt, Zt = (nt = st).rb[nt.sb - 1], Vt = nt.rb[nt.sb + nt.ja], Ot = nt.ya[nt.aa + nt.ja], yr = nt.kc ? Ot.Ad : 0) Zt.la = Vt.la = 0, Ot.Za || (Zt.Na = Vt.Na = 0), Ot.Hc = 0, Ot.Gc = 0, Ot.ia = 0;
              else {
                var zr, Br;
                if (Zt = Vt, Vt = qt, yr = nt.Pa.Xc, Ur = nt.ya[nt.aa + nt.ja], xr = nt.pb[Ur.$b], dt = Ur.ad, rn = 0, Ln = nt.rb[nt.sb - 1], wn = on = 0, i(dt, rn, 0, 384), Ur.Za) var Bi = 0, es = yr[3];
                else {
                  Mn = s(16);
                  var li = Zt.Na + Ln.Na;
                  if (li = ga(Vt, yr[1], li, xr.Eb, 0, Mn, 0), Zt.Na = Ln.Na = (0 < li) + 0, 1 < li) Qo(Mn, 0, dt, rn);
                  else {
                    var Ps = Mn[0] + 3 >> 3;
                    for (Mn = 0; 256 > Mn; Mn += 16) dt[rn + Mn] = Ps;
                  }
                  Bi = 1, es = yr[0];
                }
                var Pn = 15 & Zt.la, Li = 15 & Ln.la;
                for (Mn = 0; 4 > Mn; ++Mn) {
                  var ts = 1 & Li;
                  for (Ps = Br = 0; 4 > Ps; ++Ps) Pn = Pn >> 1 | (ts = (li = ga(Vt, es, li = ts + (1 & Pn), xr.Sc, Bi, dt, rn)) > Bi) << 7, Br = Br << 2 | (3 < li ? 3 : 1 < li ? 2 : dt[rn + 0] != 0), rn += 16;
                  Pn >>= 4, Li = Li >> 1 | ts << 7, on = (on << 8 | Br) >>> 0;
                }
                for (es = Pn, Bi = Li >> 4, zr = 0; 4 > zr; zr += 2) {
                  for (Br = 0, Pn = Zt.la >> 4 + zr, Li = Ln.la >> 4 + zr, Mn = 0; 2 > Mn; ++Mn) {
                    for (ts = 1 & Li, Ps = 0; 2 > Ps; ++Ps) li = ts + (1 & Pn), Pn = Pn >> 1 | (ts = 0 < (li = ga(Vt, yr[2], li, xr.Qc, 0, dt, rn))) << 3, Br = Br << 2 | (3 < li ? 3 : 1 < li ? 2 : dt[rn + 0] != 0), rn += 16;
                    Pn >>= 2, Li = Li >> 1 | ts << 5;
                  }
                  wn |= Br << 4 * zr, es |= Pn << 4 << zr, Bi |= (240 & Li) << zr;
                }
                Zt.la = es, Ln.la = Bi, Ur.Hc = on, Ur.Gc = wn, Ur.ia = 43690 & wn ? 0 : xr.ia, yr = !(on | wn);
              }
              if (0 < nt.L && (nt.wa[nt.Y + nt.ja] = nt.gd[Ot.$b][Ot.Za], nt.wa[nt.Y + nt.ja].La |= !yr), qt.Ka) return pi(st, 7, "Premature end-of-file encountered.");
            }
            if (nl(st), nt = Wt, qt = 1, Ot = (tt = st).D, Zt = 0 < tt.L && tt.M >= tt.zb && tt.M <= tt.Va, tt.Aa == 0) e: {
              if (Ot.M = tt.M, Ot.uc = Zt, ql(tt, Ot), qt = 1, Ot = (Br = tt.D).Nb, Zt = (wn = Iu[tt.L]) * tt.R, Vt = wn / 2 * tt.B, Mn = 16 * Ot * tt.R, Ps = 8 * Ot * tt.B, yr = tt.sa, Ur = tt.ta - Zt + Mn, xr = tt.qa, dt = tt.ra - Vt + Ps, rn = tt.Ha, Ln = tt.Ia - Vt + Ps, Li = (Pn = Br.M) == 0, on = Pn >= tt.Va - 1, tt.Aa == 2 && ql(tt, Br), Br.uc) for (ts = (li = tt).D.M, e(li.D.uc), Br = li.yb; Br < li.Hb; ++Br) {
                Bi = Br, es = ts;
                var Ei = (zi = (ui = li).D).Nb;
                zr = ui.R;
                var zi = zi.wa[zi.Y + Bi], Gi = ui.sa, to = ui.ta + 16 * Ei * zr + 16 * Bi, Vs = zi.dd, ci = zi.tc;
                if (ci != 0) if (e(3 <= ci), ui.L == 1) 0 < Bi && sn(Gi, to, zr, ci + 4), zi.La && Io(Gi, to, zr, ci), 0 < es && Da(Gi, to, zr, ci + 4), zi.La && dl(Gi, to, zr, ci);
                else {
                  var ea = ui.B, ya = ui.qa, _o = ui.ra + 8 * Ei * ea + 8 * Bi, ba = ui.Ha, ui = ui.Ia + 8 * Ei * ea + 8 * Bi;
                  Ei = zi.ld, 0 < Bi && (Xl(Gi, to, zr, ci + 4, Vs, Ei), pa(ya, _o, ba, ui, ea, ci + 4, Vs, Ei)), zi.La && (po(Gi, to, zr, ci, Vs, Ei), Zl(ya, _o, ba, ui, ea, ci, Vs, Ei)), 0 < es && (Oa(Gi, to, zr, ci + 4, Vs, Ei), Na(ya, _o, ba, ui, ea, ci + 4, Vs, Ei)), zi.La && (fl(Gi, to, zr, ci, Vs, Ei), Co(ya, _o, ba, ui, ea, ci, Vs, Ei));
                }
              }
              if (tt.ia && alert("todo:DitherRow"), nt.put != null) {
                if (Br = 16 * Pn, Pn = 16 * (Pn + 1), Li ? (nt.y = tt.sa, nt.O = tt.ta + Mn, nt.f = tt.qa, nt.N = tt.ra + Ps, nt.ea = tt.Ha, nt.W = tt.Ia + Ps) : (Br -= wn, nt.y = yr, nt.O = Ur, nt.f = xr, nt.N = dt, nt.ea = rn, nt.W = Ln), on || (Pn -= wn), Pn > nt.o && (Pn = nt.o), nt.F = null, nt.J = null, tt.Fa != null && 0 < tt.Fa.length && Br < Pn && (nt.J = Ra(tt, nt, Br, Pn - Br), nt.F = tt.mb, nt.F == null && nt.F.length == 0)) {
                  qt = pi(tt, 3, "Could not decode alpha data.");
                  break e;
                }
                Br < nt.j && (wn = nt.j - Br, Br = nt.j, e(!(1 & wn)), nt.O += tt.R * wn, nt.N += tt.B * (wn >> 1), nt.W += tt.B * (wn >> 1), nt.F != null && (nt.J += nt.width * wn)), Br < Pn && (nt.O += nt.v, nt.N += nt.v >> 1, nt.W += nt.v >> 1, nt.F != null && (nt.J += nt.v), nt.ka = Br - nt.j, nt.U = nt.va - nt.v, nt.T = Pn - Br, qt = nt.put(nt));
              }
              Ot + 1 != tt.Ic || on || (n(tt.sa, tt.ta - Zt, yr, Ur + 16 * tt.R, Zt), n(tt.qa, tt.ra - Vt, xr, dt + 8 * tt.B, Vt), n(tt.Ha, tt.Ia - Vt, rn, Ln + 8 * tt.B, Vt));
            }
            if (!qt) return pi(st, 6, "Output aborted.");
          }
          return 1;
        }(S, P)), P.bc != null && P.bc(P), F &= 1;
      }
      return F ? (S.cb = 0, F) : 0;
    }
    function hs(S, P, F, $, re) {
      re = S[P + F + 32 * $] + (re >> 3), S[P + F + 32 * $] = -256 & re ? 0 > re ? 0 : 255 : re;
    }
    function il(S, P, F, $, re, fe) {
      hs(S, P, 0, F, $ + re), hs(S, P, 1, F, $ + fe), hs(S, P, 2, F, $ - fe), hs(S, P, 3, F, $ - re);
    }
    function gi(S) {
      return (20091 * S >> 16) + S;
    }
    function Yr(S, P, F, $) {
      var re, fe = 0, ge = s(16);
      for (re = 0; 4 > re; ++re) {
        var be = S[P + 0] + S[P + 8], we = S[P + 0] - S[P + 8], Pe = (35468 * S[P + 4] >> 16) - gi(S[P + 12]), et = gi(S[P + 4]) + (35468 * S[P + 12] >> 16);
        ge[fe + 0] = be + et, ge[fe + 1] = we + Pe, ge[fe + 2] = we - Pe, ge[fe + 3] = be - et, fe += 4, P++;
      }
      for (re = fe = 0; 4 > re; ++re) be = (S = ge[fe + 0] + 4) + ge[fe + 8], we = S - ge[fe + 8], Pe = (35468 * ge[fe + 4] >> 16) - gi(ge[fe + 12]), hs(F, $, 0, 0, be + (et = gi(ge[fe + 4]) + (35468 * ge[fe + 12] >> 16))), hs(F, $, 1, 0, we + Pe), hs(F, $, 2, 0, we - Pe), hs(F, $, 3, 0, be - et), fe++, $ += 32;
    }
    function co(S, P, F, $) {
      var re = S[P + 0] + 4, fe = 35468 * S[P + 4] >> 16, ge = gi(S[P + 4]), be = 35468 * S[P + 1] >> 16;
      il(F, $, 0, re + ge, S = gi(S[P + 1]), be), il(F, $, 1, re + fe, S, be), il(F, $, 2, re - fe, S, be), il(F, $, 3, re - ge, S, be);
    }
    function nn(S, P, F, $, re) {
      Yr(S, P, F, $), re && Yr(S, P + 16, F, $ + 4);
    }
    function Rl(S, P, F, $) {
      Fi(S, P + 0, F, $, 1), Fi(S, P + 32, F, $ + 128, 1);
    }
    function Hu(S, P, F, $) {
      var re;
      for (S = S[P + 0] + 4, re = 0; 4 > re; ++re) for (P = 0; 4 > P; ++P) hs(F, $, P, re, S);
    }
    function sl(S, P, F, $) {
      S[P + 0] && _s(S, P + 0, F, $), S[P + 16] && _s(S, P + 16, F, $ + 4), S[P + 32] && _s(S, P + 32, F, $ + 128), S[P + 48] && _s(S, P + 48, F, $ + 128 + 4);
    }
    function oi(S, P, F, $) {
      var re, fe = s(16);
      for (re = 0; 4 > re; ++re) {
        var ge = S[P + 0 + re] + S[P + 12 + re], be = S[P + 4 + re] + S[P + 8 + re], we = S[P + 4 + re] - S[P + 8 + re], Pe = S[P + 0 + re] - S[P + 12 + re];
        fe[0 + re] = ge + be, fe[8 + re] = ge - be, fe[4 + re] = Pe + we, fe[12 + re] = Pe - we;
      }
      for (re = 0; 4 > re; ++re) ge = (S = fe[0 + 4 * re] + 3) + fe[3 + 4 * re], be = fe[1 + 4 * re] + fe[2 + 4 * re], we = fe[1 + 4 * re] - fe[2 + 4 * re], Pe = S - fe[3 + 4 * re], F[$ + 0] = ge + be >> 3, F[$ + 16] = Pe + we >> 3, F[$ + 32] = ge - be >> 3, F[$ + 48] = Pe - we >> 3, $ += 64;
    }
    function mi(S, P, F) {
      var $, re = P - 32, fe = eo, ge = 255 - S[re - 1];
      for ($ = 0; $ < F; ++$) {
        var be, we = fe, Pe = ge + S[P - 1];
        for (be = 0; be < F; ++be) S[P + be] = we[Pe + S[re + be]];
        P += 32;
      }
    }
    function Kn(S, P) {
      mi(S, P, 4);
    }
    function pu(S, P) {
      mi(S, P, 8);
    }
    function Yi(S, P) {
      mi(S, P, 16);
    }
    function ai(S, P) {
      var F;
      for (F = 0; 16 > F; ++F) n(S, P + 32 * F, S, P - 32, 16);
    }
    function Mi(S, P) {
      var F;
      for (F = 16; 0 < F; --F) i(S, P, S[P - 1], 16), P += 32;
    }
    function ol(S, P, F) {
      var $;
      for ($ = 0; 16 > $; ++$) i(P, F + 32 * $, S, 16);
    }
    function ua(S, P) {
      var F, $ = 16;
      for (F = 0; 16 > F; ++F) $ += S[P - 1 + 32 * F] + S[P + F - 32];
      ol($ >> 5, S, P);
    }
    function an(S, P) {
      var F, $ = 8;
      for (F = 0; 16 > F; ++F) $ += S[P - 1 + 32 * F];
      ol($ >> 4, S, P);
    }
    function Bl(S, P) {
      var F, $ = 8;
      for (F = 0; 16 > F; ++F) $ += S[P + F - 32];
      ol($ >> 4, S, P);
    }
    function uo(S, P) {
      ol(128, S, P);
    }
    function qr(S, P, F) {
      return S + 2 * P + F + 2 >> 2;
    }
    function Ys(S, P) {
      var F, $ = P - 32;
      for ($ = new Uint8Array([qr(S[$ - 1], S[$ + 0], S[$ + 1]), qr(S[$ + 0], S[$ + 1], S[$ + 2]), qr(S[$ + 1], S[$ + 2], S[$ + 3]), qr(S[$ + 2], S[$ + 3], S[$ + 4])]), F = 0; 4 > F; ++F) n(S, P + 32 * F, $, 0, $.length);
    }
    function gu(S, P) {
      var F = S[P - 1], $ = S[P - 1 + 32], re = S[P - 1 + 64], fe = S[P - 1 + 96];
      ar(S, P + 0, 16843009 * qr(S[P - 1 - 32], F, $)), ar(S, P + 32, 16843009 * qr(F, $, re)), ar(S, P + 64, 16843009 * qr($, re, fe)), ar(S, P + 96, 16843009 * qr(re, fe, fe));
    }
    function Ki(S, P) {
      var F, $ = 4;
      for (F = 0; 4 > F; ++F) $ += S[P + F - 32] + S[P - 1 + 32 * F];
      for ($ >>= 3, F = 0; 4 > F; ++F) i(S, P + 32 * F, $, 4);
    }
    function Ll(S, P) {
      var F = S[P - 1 + 0], $ = S[P - 1 + 32], re = S[P - 1 + 64], fe = S[P - 1 - 32], ge = S[P + 0 - 32], be = S[P + 1 - 32], we = S[P + 2 - 32], Pe = S[P + 3 - 32];
      S[P + 0 + 96] = qr($, re, S[P - 1 + 96]), S[P + 1 + 96] = S[P + 0 + 64] = qr(F, $, re), S[P + 2 + 96] = S[P + 1 + 64] = S[P + 0 + 32] = qr(fe, F, $), S[P + 3 + 96] = S[P + 2 + 64] = S[P + 1 + 32] = S[P + 0 + 0] = qr(ge, fe, F), S[P + 3 + 64] = S[P + 2 + 32] = S[P + 1 + 0] = qr(be, ge, fe), S[P + 3 + 32] = S[P + 2 + 0] = qr(we, be, ge), S[P + 3 + 0] = qr(Pe, we, be);
    }
    function Fn(S, P) {
      var F = S[P + 1 - 32], $ = S[P + 2 - 32], re = S[P + 3 - 32], fe = S[P + 4 - 32], ge = S[P + 5 - 32], be = S[P + 6 - 32], we = S[P + 7 - 32];
      S[P + 0 + 0] = qr(S[P + 0 - 32], F, $), S[P + 1 + 0] = S[P + 0 + 32] = qr(F, $, re), S[P + 2 + 0] = S[P + 1 + 32] = S[P + 0 + 64] = qr($, re, fe), S[P + 3 + 0] = S[P + 2 + 32] = S[P + 1 + 64] = S[P + 0 + 96] = qr(re, fe, ge), S[P + 3 + 32] = S[P + 2 + 64] = S[P + 1 + 96] = qr(fe, ge, be), S[P + 3 + 64] = S[P + 2 + 96] = qr(ge, be, we), S[P + 3 + 96] = qr(be, we, we);
    }
    function Xo(S, P) {
      var F = S[P - 1 + 0], $ = S[P - 1 + 32], re = S[P - 1 + 64], fe = S[P - 1 - 32], ge = S[P + 0 - 32], be = S[P + 1 - 32], we = S[P + 2 - 32], Pe = S[P + 3 - 32];
      S[P + 0 + 0] = S[P + 1 + 64] = fe + ge + 1 >> 1, S[P + 1 + 0] = S[P + 2 + 64] = ge + be + 1 >> 1, S[P + 2 + 0] = S[P + 3 + 64] = be + we + 1 >> 1, S[P + 3 + 0] = we + Pe + 1 >> 1, S[P + 0 + 96] = qr(re, $, F), S[P + 0 + 64] = qr($, F, fe), S[P + 0 + 32] = S[P + 1 + 96] = qr(F, fe, ge), S[P + 1 + 32] = S[P + 2 + 96] = qr(fe, ge, be), S[P + 2 + 32] = S[P + 3 + 96] = qr(ge, be, we), S[P + 3 + 32] = qr(be, we, Pe);
    }
    function ln(S, P) {
      var F = S[P + 0 - 32], $ = S[P + 1 - 32], re = S[P + 2 - 32], fe = S[P + 3 - 32], ge = S[P + 4 - 32], be = S[P + 5 - 32], we = S[P + 6 - 32], Pe = S[P + 7 - 32];
      S[P + 0 + 0] = F + $ + 1 >> 1, S[P + 1 + 0] = S[P + 0 + 64] = $ + re + 1 >> 1, S[P + 2 + 0] = S[P + 1 + 64] = re + fe + 1 >> 1, S[P + 3 + 0] = S[P + 2 + 64] = fe + ge + 1 >> 1, S[P + 0 + 32] = qr(F, $, re), S[P + 1 + 32] = S[P + 0 + 96] = qr($, re, fe), S[P + 2 + 32] = S[P + 1 + 96] = qr(re, fe, ge), S[P + 3 + 32] = S[P + 2 + 96] = qr(fe, ge, be), S[P + 3 + 64] = qr(ge, be, we), S[P + 3 + 96] = qr(be, we, Pe);
    }
    function Xr(S, P) {
      var F = S[P - 1 + 0], $ = S[P - 1 + 32], re = S[P - 1 + 64], fe = S[P - 1 + 96];
      S[P + 0 + 0] = F + $ + 1 >> 1, S[P + 2 + 0] = S[P + 0 + 32] = $ + re + 1 >> 1, S[P + 2 + 32] = S[P + 0 + 64] = re + fe + 1 >> 1, S[P + 1 + 0] = qr(F, $, re), S[P + 3 + 0] = S[P + 1 + 32] = qr($, re, fe), S[P + 3 + 32] = S[P + 1 + 64] = qr(re, fe, fe), S[P + 3 + 64] = S[P + 2 + 64] = S[P + 0 + 96] = S[P + 1 + 96] = S[P + 2 + 96] = S[P + 3 + 96] = fe;
    }
    function Ol(S, P) {
      var F = S[P - 1 + 0], $ = S[P - 1 + 32], re = S[P - 1 + 64], fe = S[P - 1 + 96], ge = S[P - 1 - 32], be = S[P + 0 - 32], we = S[P + 1 - 32], Pe = S[P + 2 - 32];
      S[P + 0 + 0] = S[P + 2 + 32] = F + ge + 1 >> 1, S[P + 0 + 32] = S[P + 2 + 64] = $ + F + 1 >> 1, S[P + 0 + 64] = S[P + 2 + 96] = re + $ + 1 >> 1, S[P + 0 + 96] = fe + re + 1 >> 1, S[P + 3 + 0] = qr(be, we, Pe), S[P + 2 + 0] = qr(ge, be, we), S[P + 1 + 0] = S[P + 3 + 32] = qr(F, ge, be), S[P + 1 + 32] = S[P + 3 + 64] = qr($, F, ge), S[P + 1 + 64] = S[P + 3 + 96] = qr(re, $, F), S[P + 1 + 96] = qr(fe, re, $);
    }
    function dn(S, P) {
      var F;
      for (F = 0; 8 > F; ++F) n(S, P + 32 * F, S, P - 32, 8);
    }
    function ha(S, P) {
      var F;
      for (F = 0; 8 > F; ++F) i(S, P, S[P - 1], 8), P += 32;
    }
    function fs(S, P, F) {
      var $;
      for ($ = 0; 8 > $; ++$) i(P, F + 32 * $, S, 8);
    }
    function Ao(S, P) {
      var F, $ = 8;
      for (F = 0; 8 > F; ++F) $ += S[P + F - 32] + S[P - 1 + 32 * F];
      fs($ >> 4, S, P);
    }
    function Nl(S, P) {
      var F, $ = 4;
      for (F = 0; 8 > F; ++F) $ += S[P + F - 32];
      fs($ >> 3, S, P);
    }
    function Zo(S, P) {
      var F, $ = 4;
      for (F = 0; 8 > F; ++F) $ += S[P - 1 + 32 * F];
      fs($ >> 3, S, P);
    }
    function Yo(S, P) {
      fs(128, S, P);
    }
    function Dl(S, P, F) {
      var $ = S[P - F], re = S[P + 0], fe = 3 * (re - $) + gl[1020 + S[P - 2 * F] - S[P + F]], ge = Kl[112 + (fe + 4 >> 3)];
      S[P - F] = eo[255 + $ + Kl[112 + (fe + 3 >> 3)]], S[P + 0] = eo[255 + re - ge];
    }
    function Dc(S, P, F, $) {
      var re = S[P + 0], fe = S[P + F];
      return js[255 + S[P - 2 * F] - S[P - F]] > $ || js[255 + fe - re] > $;
    }
    function kc(S, P, F, $) {
      return 4 * js[255 + S[P - F] - S[P + 0]] + js[255 + S[P - 2 * F] - S[P + F]] <= $;
    }
    function mu(S, P, F, $, re) {
      var fe = S[P - 3 * F], ge = S[P - 2 * F], be = S[P - F], we = S[P + 0], Pe = S[P + F], et = S[P + 2 * F], ot = S[P + 3 * F];
      return 4 * js[255 + be - we] + js[255 + ge - Pe] > $ ? 0 : js[255 + S[P - 4 * F] - fe] <= re && js[255 + fe - ge] <= re && js[255 + ge - be] <= re && js[255 + ot - et] <= re && js[255 + et - Pe] <= re && js[255 + Pe - we] <= re;
    }
    function al(S, P, F, $) {
      var re = 2 * $ + 1;
      for ($ = 0; 16 > $; ++$) kc(S, P + $, F, re) && Dl(S, P + $, F);
    }
    function gn(S, P, F, $) {
      var re = 2 * $ + 1;
      for ($ = 0; 16 > $; ++$) kc(S, P + $ * F, 1, re) && Dl(S, P + $ * F, 1);
    }
    function Ks(S, P, F, $) {
      var re;
      for (re = 3; 0 < re; --re) al(S, P += 4 * F, F, $);
    }
    function ho(S, P, F, $) {
      var re;
      for (re = 3; 0 < re; --re) gn(S, P += 4, F, $);
    }
    function Js(S, P, F, $, re, fe, ge, be) {
      for (fe = 2 * fe + 1; 0 < re--; ) {
        if (mu(S, P, F, fe, ge)) if (Dc(S, P, F, be)) Dl(S, P, F);
        else {
          var we = S, Pe = P, et = F, ot = we[Pe - 2 * et], xt = we[Pe - et], st = we[Pe + 0], Wt = we[Pe + et], Ot = we[Pe + 2 * et], tt = 27 * (qt = gl[1020 + 3 * (st - xt) + gl[1020 + ot - Wt]]) + 63 >> 7, nt = 18 * qt + 63 >> 7, qt = 9 * qt + 63 >> 7;
          we[Pe - 3 * et] = eo[255 + we[Pe - 3 * et] + qt], we[Pe - 2 * et] = eo[255 + ot + nt], we[Pe - et] = eo[255 + xt + tt], we[Pe + 0] = eo[255 + st - tt], we[Pe + et] = eo[255 + Wt - nt], we[Pe + 2 * et] = eo[255 + Ot - qt];
        }
        P += $;
      }
    }
    function Un(S, P, F, $, re, fe, ge, be) {
      for (fe = 2 * fe + 1; 0 < re--; ) {
        if (mu(S, P, F, fe, ge)) if (Dc(S, P, F, be)) Dl(S, P, F);
        else {
          var we = S, Pe = P, et = F, ot = we[Pe - et], xt = we[Pe + 0], st = we[Pe + et], Wt = Kl[112 + ((Ot = 3 * (xt - ot)) + 4 >> 3)], Ot = Kl[112 + (Ot + 3 >> 3)], tt = Wt + 1 >> 1;
          we[Pe - 2 * et] = eo[255 + we[Pe - 2 * et] + tt], we[Pe - et] = eo[255 + ot + Ot], we[Pe + 0] = eo[255 + xt - Wt], we[Pe + et] = eo[255 + st - tt];
        }
        P += $;
      }
    }
    function kl(S, P, F, $, re, fe) {
      Js(S, P, F, 1, 16, $, re, fe);
    }
    function Qs(S, P, F, $, re, fe) {
      Js(S, P, 1, F, 16, $, re, fe);
    }
    function Wu(S, P, F, $, re, fe) {
      var ge;
      for (ge = 3; 0 < ge; --ge) Un(S, P += 4 * F, F, 1, 16, $, re, fe);
    }
    function Fc(S, P, F, $, re, fe) {
      var ge;
      for (ge = 3; 0 < ge; --ge) Un(S, P += 4, 1, F, 16, $, re, fe);
    }
    function Uc(S, P, F, $, re, fe, ge, be) {
      Js(S, P, re, 1, 8, fe, ge, be), Js(F, $, re, 1, 8, fe, ge, be);
    }
    function Fl(S, P, F, $, re, fe, ge, be) {
      Js(S, P, 1, re, 8, fe, ge, be), Js(F, $, 1, re, 8, fe, ge, be);
    }
    function _u(S, P, F, $, re, fe, ge, be) {
      Un(S, P + 4 * re, re, 1, 8, fe, ge, be), Un(F, $ + 4 * re, re, 1, 8, fe, ge, be);
    }
    function Ul(S, P, F, $, re, fe, ge, be) {
      Un(S, P + 4, 1, re, 8, fe, ge, be), Un(F, $ + 4, 1, re, 8, fe, ge, be);
    }
    function To() {
      this.ba = new rt(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new Ye(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function ds() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function Ma() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function Pa() {
      this.ua = 0, this.Wa = new Ve(), this.vb = new Ve(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new Me(), this.yc = new _e();
    }
    function yu() {
      this.xb = this.a = 0, this.l = new rl(), this.ca = new rt(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new ce(), this.Pb = 0, this.wd = new ce(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new Pa(), this.ab = 0, this.gc = l(4, Ma), this.Oc = 0;
    }
    function ps() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new rl(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function zl(S, P, F, $, re, fe, ge) {
      for (S = S == null ? 0 : S[P + 0], P = 0; P < ge; ++P) re[fe + P] = S + F[$ + P] & 255, S = re[fe + P];
    }
    function jl(S, P, F, $, re, fe, ge) {
      var be;
      if (S == null) zl(null, null, F, $, re, fe, ge);
      else for (be = 0; be < ge; ++be) re[fe + be] = S[P + be] + F[$ + be] & 255;
    }
    function So(S, P, F, $, re, fe, ge) {
      if (S == null) zl(null, null, F, $, re, fe, ge);
      else {
        var be, we = S[P + 0], Pe = we, et = we;
        for (be = 0; be < ge; ++be) Pe = et + (we = S[P + be]) - Pe, et = F[$ + be] + (-256 & Pe ? 0 > Pe ? 0 : 255 : Pe) & 255, Pe = we, re[fe + be] = et;
      }
    }
    function Ra(S, P, F, $) {
      var re = P.width, fe = P.o;
      if (e(S != null && P != null), 0 > F || 0 >= $ || F + $ > fe) return null;
      if (!S.Cc) {
        if (S.ga == null) {
          var ge;
          if (S.ga = new ps(), (ge = S.ga == null) || (ge = P.width * P.o, e(S.Gb.length == 0), S.Gb = s(ge), S.Uc = 0, S.Gb == null ? ge = 0 : (S.mb = S.Gb, S.nb = S.Uc, S.rc = null, ge = 1), ge = !ge), !ge) {
            ge = S.ga;
            var be = S.Fa, we = S.P, Pe = S.qc, et = S.mb, ot = S.nb, xt = we + 1, st = Pe - 1, Wt = ge.l;
            if (e(be != null && et != null && P != null), Ua[0] = null, Ua[1] = zl, Ua[2] = jl, Ua[3] = So, ge.ca = et, ge.tb = ot, ge.c = P.width, ge.i = P.height, e(0 < ge.c && 0 < ge.i), 1 >= Pe) P = 0;
            else if (ge.$a = be[we + 0] >> 0 & 3, ge.Z = be[we + 0] >> 2 & 3, ge.Lc = be[we + 0] >> 4 & 3, we = be[we + 0] >> 6 & 3, 0 > ge.$a || 1 < ge.$a || 4 <= ge.Z || 1 < ge.Lc || we) P = 0;
            else if (Wt.put = or, Wt.ac = We, Wt.bc = Jt, Wt.ma = ge, Wt.width = P.width, Wt.height = P.height, Wt.Da = P.Da, Wt.v = P.v, Wt.va = P.va, Wt.j = P.j, Wt.o = P.o, ge.$a) e: {
              e(ge.$a == 1), P = vn();
              t: for (; ; ) {
                if (P == null) {
                  P = 0;
                  break e;
                }
                if (e(ge != null), ge.mc = P, P.c = ge.c, P.i = ge.i, P.l = ge.l, P.l.ma = ge, P.l.width = ge.c, P.l.height = ge.i, P.a = 0, bt(P.m, be, xt, st), !Ai(ge.c, ge.i, 1, P, null) || (P.ab == 1 && P.gc[0].hc == 3 && gr(P.s) ? (ge.ic = 1, be = P.c * P.i, P.Ta = null, P.Ua = 0, P.V = s(be), P.Ba = 0, P.V == null ? (P.a = 1, P = 0) : P = 1) : (ge.ic = 0, P = In(P, ge.c)), !P)) break t;
                P = 1;
                break e;
              }
              ge.mc = null, P = 0;
            }
            else P = st >= ge.c * ge.i;
            ge = !P;
          }
          if (ge) return null;
          S.ga.Lc != 1 ? S.Ga = 0 : $ = fe - F;
        }
        e(S.ga != null), e(F + $ <= fe);
        e: {
          if (P = (be = S.ga).c, fe = be.l.o, be.$a == 0) {
            if (xt = S.rc, st = S.Vc, Wt = S.Fa, we = S.P + 1 + F * P, Pe = S.mb, et = S.nb + F * P, e(we <= S.P + S.qc), be.Z != 0) for (e(Ua[be.Z] != null), ge = 0; ge < $; ++ge) Ua[be.Z](xt, st, Wt, we, Pe, et, P), xt = Pe, st = et, et += P, we += P;
            else for (ge = 0; ge < $; ++ge) n(Pe, et, Wt, we, P), xt = Pe, st = et, et += P, we += P;
            S.rc = xt, S.Vc = st;
          } else {
            if (e(be.mc != null), P = F + $, e((ge = be.mc) != null), e(P <= ge.i), ge.C >= P) P = 1;
            else if (be.ic || mt(), be.ic) {
              be = ge.V, xt = ge.Ba, st = ge.c;
              var Ot = ge.i, tt = (Wt = 1, we = ge.$ / st, Pe = ge.$ % st, et = ge.m, ot = ge.s, ge.$), nt = st * Ot, qt = st * P, Zt = ot.wc, dt = tt < qt ? Lr(ot, Pe, we) : null;
              e(tt <= nt), e(P <= Ot), e(gr(ot));
              t: for (; ; ) {
                for (; !et.h && tt < qt; ) {
                  if (Pe & Zt || (dt = Lr(ot, Pe, we)), e(dt != null), it(et), 256 > (Ot = Qt(dt.G[0], dt.H[0], et))) be[xt + tt] = Ot, ++tt, ++Pe >= st && (Pe = 0, ++we <= P && !(we % 16) && Zi(ge, we));
                  else {
                    if (!(280 > Ot)) {
                      Wt = 0;
                      break t;
                    }
                    Ot = Mr(Ot - 256, et);
                    var Vt, yr = Qt(dt.G[4], dt.H[4], et);
                    if (it(et), !(tt >= (yr = Bt(st, yr = Mr(yr, et))) && nt - tt >= Ot)) {
                      Wt = 0;
                      break t;
                    }
                    for (Vt = 0; Vt < Ot; ++Vt) be[xt + tt + Vt] = be[xt + tt + Vt - yr];
                    for (tt += Ot, Pe += Ot; Pe >= st; ) Pe -= st, ++we <= P && !(we % 16) && Zi(ge, we);
                    tt < qt && Pe & Zt && (dt = Lr(ot, Pe, we));
                  }
                  e(et.h == Ue(et));
                }
                Zi(ge, we > P ? P : we);
                break t;
              }
              !Wt || et.h && tt < nt ? (Wt = 0, ge.a = et.h ? 5 : 3) : ge.$ = tt, P = Wt;
            } else P = Dn(ge, ge.V, ge.Ba, ge.c, ge.i, P, aa);
            if (!P) {
              $ = 0;
              break e;
            }
          }
          F + $ >= fe && (S.Cc = 1), $ = 1;
        }
        if (!$) return null;
        if (S.Cc && (($ = S.ga) != null && ($.mc = null), S.ga = null, 0 < S.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return S.nb + F * re;
    }
    function O(S, P, F, $, re, fe) {
      for (; 0 < re--; ) {
        var ge, be = S, we = P + (F ? 1 : 0), Pe = S, et = P + (F ? 0 : 3);
        for (ge = 0; ge < $; ++ge) {
          var ot = Pe[et + 4 * ge];
          ot != 255 && (ot *= 32897, be[we + 4 * ge + 0] = be[we + 4 * ge + 0] * ot >> 23, be[we + 4 * ge + 1] = be[we + 4 * ge + 1] * ot >> 23, be[we + 4 * ge + 2] = be[we + 4 * ge + 2] * ot >> 23);
        }
        P += fe;
      }
    }
    function ne(S, P, F, $, re) {
      for (; 0 < $--; ) {
        var fe;
        for (fe = 0; fe < F; ++fe) {
          var ge = S[P + 2 * fe + 0], be = 15 & (Pe = S[P + 2 * fe + 1]), we = 4369 * be, Pe = (240 & Pe | Pe >> 4) * we >> 16;
          S[P + 2 * fe + 0] = (240 & ge | ge >> 4) * we >> 16 & 240 | (15 & ge | ge << 4) * we >> 16 >> 4 & 15, S[P + 2 * fe + 1] = 240 & Pe | be;
        }
        P += re;
      }
    }
    function De(S, P, F, $, re, fe, ge, be) {
      var we, Pe, et = 255;
      for (Pe = 0; Pe < re; ++Pe) {
        for (we = 0; we < $; ++we) {
          var ot = S[P + we];
          fe[ge + 4 * we] = ot, et &= ot;
        }
        P += F, ge += be;
      }
      return et != 255;
    }
    function Ke(S, P, F, $, re) {
      var fe;
      for (fe = 0; fe < re; ++fe) F[$ + fe] = S[P + fe] >> 8;
    }
    function mt() {
      go = O, Bn = ne, $n = De, Ri = Ke;
    }
    function zt(S, P, F) {
      oe[S] = function($, re, fe, ge, be, we, Pe, et, ot, xt, st, Wt, Ot, tt, nt, qt, Zt) {
        var dt, Vt = Zt - 1 >> 1, yr = be[we + 0] | Pe[et + 0] << 16, Ur = ot[xt + 0] | st[Wt + 0] << 16;
        e($ != null);
        var xr = 3 * yr + Ur + 131074 >> 2;
        for (P($[re + 0], 255 & xr, xr >> 16, Ot, tt), fe != null && (xr = 3 * Ur + yr + 131074 >> 2, P(fe[ge + 0], 255 & xr, xr >> 16, nt, qt)), dt = 1; dt <= Vt; ++dt) {
          var rn = be[we + dt] | Pe[et + dt] << 16, Ln = ot[xt + dt] | st[Wt + dt] << 16, on = yr + rn + Ur + Ln + 524296, wn = on + 2 * (rn + Ur) >> 3;
          xr = wn + yr >> 1, yr = (on = on + 2 * (yr + Ln) >> 3) + rn >> 1, P($[re + 2 * dt - 1], 255 & xr, xr >> 16, Ot, tt + (2 * dt - 1) * F), P($[re + 2 * dt - 0], 255 & yr, yr >> 16, Ot, tt + (2 * dt - 0) * F), fe != null && (xr = on + Ur >> 1, yr = wn + Ln >> 1, P(fe[ge + 2 * dt - 1], 255 & xr, xr >> 16, nt, qt + (2 * dt - 1) * F), P(fe[ge + 2 * dt + 0], 255 & yr, yr >> 16, nt, qt + (2 * dt + 0) * F)), yr = rn, Ur = Ln;
        }
        1 & Zt || (xr = 3 * yr + Ur + 131074 >> 2, P($[re + Zt - 1], 255 & xr, xr >> 16, Ot, tt + (Zt - 1) * F), fe != null && (xr = 3 * Ur + yr + 131074 >> 2, P(fe[ge + Zt - 1], 255 & xr, xr >> 16, nt, qt + (Zt - 1) * F)));
      };
    }
    function tr() {
      mo[Jl] = Qu, mo[qc] = Ms, mo[Nf] = Hc, mo[Ql] = _i, mo[vu] = rc, mo[Yu] = Po, mo[xu] = Wc, mo[Gc] = Ms, mo[wu] = _i, mo[$c] = rc, mo[ec] = Po;
    }
    function Tr(S) {
      return S & -16384 ? 0 > S ? 0 : 255 : S >> Ff;
    }
    function kr(S, P) {
      return Tr((19077 * S >> 8) + (26149 * P >> 8) - 14234);
    }
    function tn(S, P, F) {
      return Tr((19077 * S >> 8) - (6419 * P >> 8) - (13320 * F >> 8) + 8708);
    }
    function Kr(S, P) {
      return Tr((19077 * S >> 8) + (33050 * P >> 8) - 17685);
    }
    function xn(S, P, F, $, re) {
      $[re + 0] = kr(S, F), $[re + 1] = tn(S, P, F), $[re + 2] = Kr(S, P);
    }
    function ti(S, P, F, $, re) {
      $[re + 0] = Kr(S, P), $[re + 1] = tn(S, P, F), $[re + 2] = kr(S, F);
    }
    function Gn(S, P, F, $, re) {
      var fe = tn(S, P, F);
      P = fe << 3 & 224 | Kr(S, P) >> 3, $[re + 0] = 248 & kr(S, F) | fe >> 5, $[re + 1] = P;
    }
    function Pi(S, P, F, $, re) {
      var fe = 240 & Kr(S, P) | 15;
      $[re + 0] = 240 & kr(S, F) | tn(S, P, F) >> 4, $[re + 1] = fe;
    }
    function gs(S, P, F, $, re) {
      $[re + 0] = 255, xn(S, P, F, $, re + 1);
    }
    function Ti(S, P, F, $, re) {
      ti(S, P, F, $, re), $[re + 3] = 255;
    }
    function fo(S, P, F, $, re) {
      xn(S, P, F, $, re), $[re + 3] = 255;
    }
    function Us(S, P) {
      return 0 > S ? 0 : S > P ? P : S;
    }
    function fa(S, P, F) {
      oe[S] = function($, re, fe, ge, be, we, Pe, et, ot) {
        for (var xt = et + (-2 & ot) * F; et != xt; ) P($[re + 0], fe[ge + 0], be[we + 0], Pe, et), P($[re + 1], fe[ge + 0], be[we + 0], Pe, et + F), re += 2, ++ge, ++we, et += 2 * F;
        1 & ot && P($[re + 0], fe[ge + 0], be[we + 0], Pe, et);
      };
    }
    function Xu(S, P, F) {
      return F == 0 ? S == 0 ? P == 0 ? 6 : 5 : P == 0 ? 4 : 0 : F;
    }
    function Vl(S, P, F, $, re) {
      switch (S >>> 30) {
        case 3:
          Fi(P, F, $, re, 0);
          break;
        case 2:
          Si(P, F, $, re);
          break;
        case 1:
          _s(P, F, $, re);
      }
    }
    function ql(S, P) {
      var F, $, re = P.M, fe = P.Nb, ge = S.oc, be = S.pc + 40, we = S.oc, Pe = S.pc + 584, et = S.oc, ot = S.pc + 600;
      for (F = 0; 16 > F; ++F) ge[be + 32 * F - 1] = 129;
      for (F = 0; 8 > F; ++F) we[Pe + 32 * F - 1] = 129, et[ot + 32 * F - 1] = 129;
      for (0 < re ? ge[be - 1 - 32] = we[Pe - 1 - 32] = et[ot - 1 - 32] = 129 : (i(ge, be - 32 - 1, 127, 21), i(we, Pe - 32 - 1, 127, 9), i(et, ot - 32 - 1, 127, 9)), $ = 0; $ < S.za; ++$) {
        var xt = P.ya[P.aa + $];
        if (0 < $) {
          for (F = -1; 16 > F; ++F) n(ge, be + 32 * F - 4, ge, be + 32 * F + 12, 4);
          for (F = -1; 8 > F; ++F) n(we, Pe + 32 * F - 4, we, Pe + 32 * F + 4, 4), n(et, ot + 32 * F - 4, et, ot + 32 * F + 4, 4);
        }
        var st = S.Gd, Wt = S.Hd + $, Ot = xt.ad, tt = xt.Hc;
        if (0 < re && (n(ge, be - 32, st[Wt].y, 0, 16), n(we, Pe - 32, st[Wt].f, 0, 8), n(et, ot - 32, st[Wt].ea, 0, 8)), xt.Za) {
          var nt = ge, qt = be - 32 + 16;
          for (0 < re && ($ >= S.za - 1 ? i(nt, qt, st[Wt].y[15], 4) : n(nt, qt, st[Wt + 1].y, 0, 4)), F = 0; 4 > F; F++) nt[qt + 128 + F] = nt[qt + 256 + F] = nt[qt + 384 + F] = nt[qt + 0 + F];
          for (F = 0; 16 > F; ++F, tt <<= 2) nt = ge, qt = be + ja[F], Is[xt.Ob[F]](nt, qt), Vl(tt, Ot, 16 * +F, nt, qt);
        } else if (nt = Xu($, re, xt.Ob[0]), ma[nt](ge, be), tt != 0) for (F = 0; 16 > F; ++F, tt <<= 2) Vl(tt, Ot, 16 * +F, ge, be + ja[F]);
        for (F = xt.Gc, nt = Xu($, re, xt.Dd), _a[nt](we, Pe), _a[nt](et, ot), tt = Ot, nt = we, qt = Pe, 255 & (xt = F >> 0) && (170 & xt ? Vc(tt, 256, nt, qt) : Qi(tt, 256, nt, qt)), xt = et, tt = ot, 255 & (F >>= 8) && (170 & F ? Vc(Ot, 320, xt, tt) : Qi(Ot, 320, xt, tt)), re < S.Ub - 1 && (n(st[Wt].y, 0, ge, be + 480, 16), n(st[Wt].f, 0, we, Pe + 224, 8), n(st[Wt].ea, 0, et, ot + 224, 8)), F = 8 * fe * S.B, st = S.sa, Wt = S.ta + 16 * $ + 16 * fe * S.R, Ot = S.qa, xt = S.ra + 8 * $ + F, tt = S.Ha, nt = S.Ia + 8 * $ + F, F = 0; 16 > F; ++F) n(st, Wt + F * S.R, ge, be + 32 * F, 16);
        for (F = 0; 8 > F; ++F) n(Ot, xt + F * S.B, we, Pe + 32 * F, 8), n(tt, nt + F * S.B, et, ot + 32 * F, 8);
      }
    }
    function Gl(S, P, F, $, re, fe, ge, be, we) {
      var Pe = [0], et = [0], ot = 0, xt = we != null ? we.kd : 0, st = we ?? new ds();
      if (S == null || 12 > F) return 7;
      st.data = S, st.w = P, st.ha = F, P = [P], F = [F], st.gb = [st.gb];
      e: {
        var Wt = P, Ot = F, tt = st.gb;
        if (e(S != null), e(Ot != null), e(tt != null), tt[0] = 0, 12 <= Ot[0] && !t(S, Wt[0], "RIFF")) {
          if (t(S, Wt[0] + 8, "WEBP")) {
            tt = 3;
            break e;
          }
          var nt = _r(S, Wt[0] + 4);
          if (12 > nt || 4294967286 < nt) {
            tt = 3;
            break e;
          }
          if (xt && nt > Ot[0] - 8) {
            tt = 7;
            break e;
          }
          tt[0] = nt, Wt[0] += 12, Ot[0] -= 12;
        }
        tt = 0;
      }
      if (tt != 0) return tt;
      for (nt = 0 < st.gb[0], F = F[0]; ; ) {
        e: {
          var qt = S;
          Ot = P, tt = F;
          var Zt = Pe, dt = et, Vt = Wt = [0];
          if ((xr = ot = [ot])[0] = 0, 8 > tt[0]) tt = 7;
          else {
            if (!t(qt, Ot[0], "VP8X")) {
              if (_r(qt, Ot[0] + 4) != 10) {
                tt = 3;
                break e;
              }
              if (18 > tt[0]) {
                tt = 7;
                break e;
              }
              var yr = _r(qt, Ot[0] + 8), Ur = 1 + cr(qt, Ot[0] + 12);
              if (2147483648 <= Ur * (qt = 1 + cr(qt, Ot[0] + 15))) {
                tt = 3;
                break e;
              }
              Vt != null && (Vt[0] = yr), Zt != null && (Zt[0] = Ur), dt != null && (dt[0] = qt), Ot[0] += 18, tt[0] -= 18, xr[0] = 1;
            }
            tt = 0;
          }
        }
        if (ot = ot[0], Wt = Wt[0], tt != 0) return tt;
        if (Ot = !!(2 & Wt), !nt && ot) return 3;
        if (fe != null && (fe[0] = !!(16 & Wt)), ge != null && (ge[0] = Ot), be != null && (be[0] = 0), ge = Pe[0], Wt = et[0], ot && Ot && we == null) {
          tt = 0;
          break;
        }
        if (4 > F) {
          tt = 7;
          break;
        }
        if (nt && ot || !nt && !ot && !t(S, P[0], "ALPH")) {
          F = [F], st.na = [st.na], st.P = [st.P], st.Sa = [st.Sa];
          e: {
            yr = S, tt = P, nt = F;
            var xr = st.gb;
            Zt = st.na, dt = st.P, Vt = st.Sa, Ur = 22, e(yr != null), e(nt != null), qt = tt[0];
            var rn = nt[0];
            for (e(Zt != null), e(Vt != null), Zt[0] = null, dt[0] = null, Vt[0] = 0; ; ) {
              if (tt[0] = qt, nt[0] = rn, 8 > rn) {
                tt = 7;
                break e;
              }
              var Ln = _r(yr, qt + 4);
              if (4294967286 < Ln) {
                tt = 3;
                break e;
              }
              var on = 8 + Ln + 1 & -2;
              if (Ur += on, 0 < xr && Ur > xr) {
                tt = 3;
                break e;
              }
              if (!t(yr, qt, "VP8 ") || !t(yr, qt, "VP8L")) {
                tt = 0;
                break e;
              }
              if (rn[0] < on) {
                tt = 7;
                break e;
              }
              t(yr, qt, "ALPH") || (Zt[0] = yr, dt[0] = qt + 8, Vt[0] = Ln), qt += on, rn -= on;
            }
          }
          if (F = F[0], st.na = st.na[0], st.P = st.P[0], st.Sa = st.Sa[0], tt != 0) break;
        }
        F = [F], st.Ja = [st.Ja], st.xa = [st.xa];
        e: if (xr = S, tt = P, nt = F, Zt = st.gb[0], dt = st.Ja, Vt = st.xa, yr = tt[0], qt = !t(xr, yr, "VP8 "), Ur = !t(xr, yr, "VP8L"), e(xr != null), e(nt != null), e(dt != null), e(Vt != null), 8 > nt[0]) tt = 7;
        else {
          if (qt || Ur) {
            if (xr = _r(xr, yr + 4), 12 <= Zt && xr > Zt - 12) {
              tt = 3;
              break e;
            }
            if (xt && xr > nt[0] - 8) {
              tt = 7;
              break e;
            }
            dt[0] = xr, tt[0] += 8, nt[0] -= 8, Vt[0] = Ur;
          } else Vt[0] = 5 <= nt[0] && xr[yr + 0] == 47 && !(xr[yr + 4] >> 5), dt[0] = nt[0];
          tt = 0;
        }
        if (F = F[0], st.Ja = st.Ja[0], st.xa = st.xa[0], P = P[0], tt != 0) break;
        if (4294967286 < st.Ja) return 3;
        if (be == null || Ot || (be[0] = st.xa ? 2 : 1), ge = [ge], Wt = [Wt], st.xa) {
          if (5 > F) {
            tt = 7;
            break;
          }
          be = ge, xt = Wt, Ot = fe, S == null || 5 > F ? S = 0 : 5 <= F && S[P + 0] == 47 && !(S[P + 4] >> 5) ? (nt = [0], xr = [0], Zt = [0], bt(dt = new ce(), S, P, F), Kt(dt, nt, xr, Zt) ? (be != null && (be[0] = nt[0]), xt != null && (xt[0] = xr[0]), Ot != null && (Ot[0] = Zt[0]), S = 1) : S = 0) : S = 0;
        } else {
          if (10 > F) {
            tt = 7;
            break;
          }
          be = Wt, S == null || 10 > F || !du(S, P + 3, F - 3) ? S = 0 : (xt = S[P + 0] | S[P + 1] << 8 | S[P + 2] << 16, Ot = 16383 & (S[P + 7] << 8 | S[P + 6]), S = 16383 & (S[P + 9] << 8 | S[P + 8]), 1 & xt || 3 < (xt >> 1 & 7) || !(xt >> 4 & 1) || xt >> 5 >= st.Ja || !Ot || !S ? S = 0 : (ge && (ge[0] = Ot), be && (be[0] = S), S = 1));
        }
        if (!S || (ge = ge[0], Wt = Wt[0], ot && (Pe[0] != ge || et[0] != Wt))) return 3;
        we != null && (we[0] = st, we.offset = P - we.w, e(4294967286 > P - we.w), e(we.offset == we.ha - F));
        break;
      }
      return tt == 0 || tt == 7 && ot && we == null ? (fe != null && (fe[0] |= st.na != null && 0 < st.na.length), $ != null && ($[0] = ge), re != null && (re[0] = Wt), 0) : tt;
    }
    function $l(S, P, F) {
      var $ = P.width, re = P.height, fe = 0, ge = 0, be = $, we = re;
      if (P.Da = S != null && 0 < S.Da, P.Da && (be = S.cd, we = S.bd, fe = S.v, ge = S.j, 11 > F || (fe &= -2, ge &= -2), 0 > fe || 0 > ge || 0 >= be || 0 >= we || fe + be > $ || ge + we > re)) return 0;
      if (P.v = fe, P.j = ge, P.va = fe + be, P.o = ge + we, P.U = be, P.T = we, P.da = S != null && 0 < S.da, P.da) {
        if (!jr(be, we, F = [S.ib], fe = [S.hb])) return 0;
        P.ib = F[0], P.hb = fe[0];
      }
      return P.ob = S != null && S.ob, P.Kb = S == null || !S.Sd, P.da && (P.ob = P.ib < 3 * $ / 4 && P.hb < 3 * re / 4, P.Kb = 0), 1;
    }
    function Hl(S) {
      if (S == null) return 2;
      if (11 > S.S) {
        var P = S.f.RGBA;
        P.fb += (S.height - 1) * P.A, P.A = -P.A;
      } else P = S.f.kb, S = S.height, P.O += (S - 1) * P.fa, P.fa = -P.fa, P.N += (S - 1 >> 1) * P.Ab, P.Ab = -P.Ab, P.W += (S - 1 >> 1) * P.Db, P.Db = -P.Db, P.F != null && (P.J += (S - 1) * P.lb, P.lb = -P.lb);
      return 0;
    }
    function da(S, P, F, $) {
      if ($ == null || 0 >= S || 0 >= P) return 2;
      if (F != null) {
        if (F.Da) {
          var re = F.cd, fe = F.bd, ge = -2 & F.v, be = -2 & F.j;
          if (0 > ge || 0 > be || 0 >= re || 0 >= fe || ge + re > S || be + fe > P) return 2;
          S = re, P = fe;
        }
        if (F.da) {
          if (!jr(S, P, re = [F.ib], fe = [F.hb])) return 2;
          S = re[0], P = fe[0];
        }
      }
      $.width = S, $.height = P;
      e: {
        var we = $.width, Pe = $.height;
        if (S = $.S, 0 >= we || 0 >= Pe || !(S >= Jl && 13 > S)) S = 2;
        else {
          if (0 >= $.Rd && $.sd == null) {
            ge = fe = re = P = 0;
            var et = (be = we * $h[S]) * Pe;
            if (11 > S || (fe = (Pe + 1) / 2 * (P = (we + 1) / 2), S == 12 && (ge = (re = we) * Pe)), (Pe = s(et + 2 * fe + ge)) == null) {
              S = 1;
              break e;
            }
            $.sd = Pe, 11 > S ? ((we = $.f.RGBA).eb = Pe, we.fb = 0, we.A = be, we.size = et) : ((we = $.f.kb).y = Pe, we.O = 0, we.fa = be, we.Fd = et, we.f = Pe, we.N = 0 + et, we.Ab = P, we.Cd = fe, we.ea = Pe, we.W = 0 + et + fe, we.Db = P, we.Ed = fe, S == 12 && (we.F = Pe, we.J = 0 + et + 2 * fe), we.Tc = ge, we.lb = re);
          }
          if (P = 1, re = $.S, fe = $.width, ge = $.height, re >= Jl && 13 > re)
            if (11 > re) S = $.f.RGBA, P &= (be = Math.abs(S.A)) * (ge - 1) + fe <= S.size, P &= be >= fe * $h[re], P &= S.eb != null;
            else {
              S = $.f.kb, be = (fe + 1) / 2, et = (ge + 1) / 2, we = Math.abs(S.fa), Pe = Math.abs(S.Ab);
              var ot = Math.abs(S.Db), xt = Math.abs(S.lb), st = xt * (ge - 1) + fe;
              P &= we * (ge - 1) + fe <= S.Fd, P &= Pe * (et - 1) + be <= S.Cd, P = (P &= ot * (et - 1) + be <= S.Ed) & we >= fe & Pe >= be & ot >= be, P &= S.y != null, P &= S.f != null, P &= S.ea != null, re == 12 && (P &= xt >= fe, P &= st <= S.Tc, P &= S.F != null);
            }
          else P = 0;
          S = P ? 0 : 2;
        }
      }
      return S != 0 || F != null && F.fd && (S = Hl($)), S;
    }
    var ri = 64, ll = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], cl = 24, Ba = 32, zc = 8, Cs = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    hr("Predictor0", "PredictorAdd0"), oe.Predictor0 = function() {
      return 4278190080;
    }, oe.Predictor1 = function(S) {
      return S;
    }, oe.Predictor2 = function(S, P, F) {
      return P[F + 0];
    }, oe.Predictor3 = function(S, P, F) {
      return P[F + 1];
    }, oe.Predictor4 = function(S, P, F) {
      return P[F - 1];
    }, oe.Predictor5 = function(S, P, F) {
      return br(br(S, P[F + 1]), P[F + 0]);
    }, oe.Predictor6 = function(S, P, F) {
      return br(S, P[F - 1]);
    }, oe.Predictor7 = function(S, P, F) {
      return br(S, P[F + 0]);
    }, oe.Predictor8 = function(S, P, F) {
      return br(P[F - 1], P[F + 0]);
    }, oe.Predictor9 = function(S, P, F) {
      return br(P[F + 0], P[F + 1]);
    }, oe.Predictor10 = function(S, P, F) {
      return br(br(S, P[F - 1]), br(P[F + 0], P[F + 1]));
    }, oe.Predictor11 = function(S, P, F) {
      var $ = P[F + 0];
      return 0 >= Wr($ >> 24 & 255, S >> 24 & 255, (P = P[F - 1]) >> 24 & 255) + Wr($ >> 16 & 255, S >> 16 & 255, P >> 16 & 255) + Wr($ >> 8 & 255, S >> 8 & 255, P >> 8 & 255) + Wr(255 & $, 255 & S, 255 & P) ? $ : S;
    }, oe.Predictor12 = function(S, P, F) {
      var $ = P[F + 0];
      return (Rr((S >> 24 & 255) + ($ >> 24 & 255) - ((P = P[F - 1]) >> 24 & 255)) << 24 | Rr((S >> 16 & 255) + ($ >> 16 & 255) - (P >> 16 & 255)) << 16 | Rr((S >> 8 & 255) + ($ >> 8 & 255) - (P >> 8 & 255)) << 8 | Rr((255 & S) + (255 & $) - (255 & P))) >>> 0;
    }, oe.Predictor13 = function(S, P, F) {
      var $ = P[F - 1];
      return ($r((S = br(S, P[F + 0])) >> 24 & 255, $ >> 24 & 255) << 24 | $r(S >> 16 & 255, $ >> 16 & 255) << 16 | $r(S >> 8 & 255, $ >> 8 & 255) << 8 | $r(S >> 0 & 255, $ >> 0 & 255)) >>> 0;
    };
    var La = oe.PredictorAdd0;
    oe.PredictorAdd1 = Zr, hr("Predictor2", "PredictorAdd2"), hr("Predictor3", "PredictorAdd3"), hr("Predictor4", "PredictorAdd4"), hr("Predictor5", "PredictorAdd5"), hr("Predictor6", "PredictorAdd6"), hr("Predictor7", "PredictorAdd7"), hr("Predictor8", "PredictorAdd8"), hr("Predictor9", "PredictorAdd9"), hr("Predictor10", "PredictorAdd10"), hr("Predictor11", "PredictorAdd11"), hr("Predictor12", "PredictorAdd12"), hr("Predictor13", "PredictorAdd13");
    var Wl = oe.PredictorAdd2;
    en("ColorIndexInverseTransform", "MapARGB", "32b", function(S) {
      return S >> 8 & 255;
    }, function(S) {
      return S;
    }), en("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(S) {
      return S;
    }, function(S) {
      return S >> 8 & 255;
    });
    var An, Eo = oe.ColorIndexInverseTransform, jc = oe.MapARGB, Zu = oe.VP8LColorIndexInverseTransformAlpha, bu = oe.MapAlpha, ul = oe.VP8LPredictorsAdd = [];
    ul.length = 16, (oe.VP8LPredictors = []).length = 16, (oe.VP8LPredictorsAdd_C = []).length = 16, (oe.VP8LPredictors_C = []).length = 16;
    var hl, ms, Ji, Ko, Jo, zs, Qo, Fi, Si, Vc, _s, Qi, Oa, Xl, Na, pa, fl, po, Co, Zl, Da, sn, dl, Io, go, Bn, $n, Ri, Ui = s(511), ka = s(2041), pl = s(225), Fa = s(767), Yl = 0, gl = ka, Kl = pl, eo = Fa, js = Ui, Jl = 0, qc = 1, Nf = 2, Ql = 3, vu = 4, Yu = 5, xu = 6, Gc = 7, wu = 8, $c = 9, ec = 10, Au = [2, 3, 7], Fh = [3, 3, 11], Tu = [280, 256, 256, 256, 40], ni = [0, 1, 1, 1, 0], tc = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Mo = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], Uh = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], zh = 8, Ku = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ml = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ga = null, Ju = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Su = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], jh = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], Vh = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], qh = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], Df = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], _l = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], ma = [], Is = [], _a = [], kf = 1, Gh = 2, Ua = [], mo = [];
    zt("UpsampleRgbLinePair", xn, 3), zt("UpsampleBgrLinePair", ti, 3), zt("UpsampleRgbaLinePair", fo, 4), zt("UpsampleBgraLinePair", Ti, 4), zt("UpsampleArgbLinePair", gs, 4), zt("UpsampleRgba4444LinePair", Pi, 2), zt("UpsampleRgb565LinePair", Gn, 2);
    var Qu = oe.UpsampleRgbLinePair, Hc = oe.UpsampleBgrLinePair, Ms = oe.UpsampleRgbaLinePair, _i = oe.UpsampleBgraLinePair, rc = oe.UpsampleArgbLinePair, Po = oe.UpsampleRgba4444LinePair, Wc = oe.UpsampleRgb565LinePair, eh = 16, yl = 1 << eh - 1, Xc = -227, Eu = 482, Ff = 6, bl = 0, za = s(256), vr = s(256), Uf = s(256), nc = s(256), zf = s(Eu - Xc), Cu = s(Eu - Xc);
    fa("YuvToRgbRow", xn, 3), fa("YuvToBgrRow", ti, 3), fa("YuvToRgbaRow", fo, 4), fa("YuvToBgraRow", Ti, 4), fa("YuvToArgbRow", gs, 4), fa("YuvToRgba4444Row", Pi, 2), fa("YuvToRgb565Row", Gn, 2);
    var ja = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Iu = [0, 2, 8], cn = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Zc = 1;
    this.WebPDecodeRGBA = function(S, P, F, $, re) {
      var fe = qc, ge = new To(), be = new rt();
      ge.ba = be, be.S = fe, be.width = [be.width], be.height = [be.height];
      var we = be.width, Pe = be.height, et = new gt();
      if (et == null || S == null) var ot = 2;
      else e(et != null), ot = Gl(S, P, F, et.width, et.height, et.Pd, et.Qd, et.format, null);
      if (ot != 0 ? we = 0 : (we != null && (we[0] = et.width[0]), Pe != null && (Pe[0] = et.height[0]), we = 1), we) {
        be.width = be.width[0], be.height = be.height[0], $ != null && ($[0] = be.width), re != null && (re[0] = be.height);
        e: {
          if ($ = new rl(), (re = new ds()).data = S, re.w = P, re.ha = F, re.kd = 1, P = [0], e(re != null), ((S = Gl(re.data, re.w, re.ha, null, null, null, P, null, re)) == 0 || S == 7) && P[0] && (S = 4), (P = S) == 0) {
            if (e(ge != null), $.data = re.data, $.w = re.w + re.offset, $.ha = re.ha - re.offset, $.put = or, $.ac = We, $.bc = Jt, $.ma = ge, re.xa) {
              if ((S = vn()) == null) {
                ge = 1;
                break e;
              }
              if (function(xt, st) {
                var Wt = [0], Ot = [0], tt = [0];
                t: for (; ; ) {
                  if (xt == null) return 0;
                  if (st == null) return xt.a = 2, 0;
                  if (xt.l = st, xt.a = 0, bt(xt.m, st.data, st.w, st.ha), !Kt(xt.m, Wt, Ot, tt)) {
                    xt.a = 3;
                    break t;
                  }
                  if (xt.xb = Gh, st.width = Wt[0], st.height = Ot[0], !Ai(Wt[0], Ot[0], 1, xt, null)) break t;
                  return 1;
                }
                return e(xt.a != 0), 0;
              }(S, $)) {
                if ($ = (P = da($.width, $.height, ge.Oa, ge.ba)) == 0) {
                  t: {
                    $ = S;
                    r: for (; ; ) {
                      if ($ == null) {
                        $ = 0;
                        break t;
                      }
                      if (e($.s.yc != null), e($.s.Ya != null), e(0 < $.s.Wb), e((F = $.l) != null), e((re = F.ma) != null), $.xb != 0) {
                        if ($.ca = re.ba, $.tb = re.tb, e($.ca != null), !$l(re.Oa, F, Ql)) {
                          $.a = 2;
                          break r;
                        }
                        if (!In($, F.width) || F.da) break r;
                        if ((F.da || pe($.ca.S)) && mt(), 11 > $.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), $.ca.f.kb.F != null && mt()), $.Pb && 0 < $.s.ua && $.s.vb.X == null && !Cr($.s.vb, $.s.Wa.Xa)) {
                          $.a = 1;
                          break r;
                        }
                        $.xb = 0;
                      }
                      if (!Dn($, $.V, $.Ba, $.c, $.i, F.o, Or)) break r;
                      re.Dc = $.Ma, $ = 1;
                      break t;
                    }
                    e($.a != 0), $ = 0;
                  }
                  $ = !$;
                }
                $ && (P = S.a);
              } else P = S.a;
            } else {
              if ((S = new Ia()) == null) {
                ge = 1;
                break e;
              }
              if (S.Fa = re.na, S.P = re.P, S.qc = re.Sa, ca(S, $)) {
                if ((P = da($.width, $.height, ge.Oa, ge.ba)) == 0) {
                  if (S.Aa = 0, F = ge.Oa, e((re = S) != null), F != null) {
                    if (0 < (we = 0 > (we = F.Md) ? 0 : 100 < we ? 255 : 255 * we / 100)) {
                      for (Pe = et = 0; 4 > Pe; ++Pe) 12 > (ot = re.pb[Pe]).lc && (ot.ia = we * cn[0 > ot.lc ? 0 : ot.lc] >> 3), et |= ot.ia;
                      et && (alert("todo:VP8InitRandom"), re.ia = 1);
                    }
                    re.Ga = F.Id, 100 < re.Ga ? re.Ga = 100 : 0 > re.Ga && (re.Ga = 0);
                  }
                  $u(S, $) || (P = S.a);
                }
              } else P = S.a;
            }
            P == 0 && ge.Oa != null && ge.Oa.fd && (P = Hl(ge.ba));
          }
          ge = P;
        }
        fe = ge != 0 ? null : 11 > fe ? be.f.RGBA.eb : be.f.kb.y;
      } else fe = null;
      return fe;
    };
    var $h = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function m(oe, Re) {
    for (var Ne = "", me = 0; me < 4; me++) Ne += String.fromCharCode(oe[Re++]);
    return Ne;
  }
  function b(oe, Re) {
    return (oe[Re + 0] << 0 | oe[Re + 1] << 8 | oe[Re + 2] << 16) >>> 0;
  }
  function T(oe, Re) {
    return (oe[Re + 0] << 0 | oe[Re + 1] << 8 | oe[Re + 2] << 16 | oe[Re + 3] << 24) >>> 0;
  }
  new d();
  var M = [0], E = [0], D = [], U = new d(), q = r, G = function(oe, Re) {
    var Ne = {}, me = 0, _e = !1, Fe = 0, Me = 0;
    if (Ne.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(Be, Ue, Xe, it) {
      for (var ft = 0; ft < it; ft++) if (Be[Ue + ft] != Xe.charCodeAt(ft)) return !0;
      return !1;
    }(oe, Re, "RIFF", 4)) {
      var Ct, ht;
      for (T(oe, Re += 4), Re += 8; Re < oe.length; ) {
        var Pt = m(oe, Re), bt = T(oe, Re += 4);
        Re += 4;
        var kt = bt + (1 & bt);
        switch (Pt) {
          case "VP8 ":
          case "VP8L":
            Ne.frames[me] === void 0 && (Ne.frames[me] = {}), (ce = Ne.frames[me]).src_off = _e ? Me : Re - 8, ce.src_size = Fe + bt + 8, me++, _e && (_e = !1, Fe = 0, Me = 0);
            break;
          case "VP8X":
            (ce = Ne.header = {}).feature_flags = oe[Re];
            var Nt = Re + 4;
            ce.canvas_width = 1 + b(oe, Nt), Nt += 3, ce.canvas_height = 1 + b(oe, Nt), Nt += 3;
            break;
          case "ALPH":
            _e = !0, Fe = kt + 8, Me = Re - 8;
            break;
          case "ANIM":
            (ce = Ne.header).bgcolor = T(oe, Re), Nt = Re + 4, ce.loop_count = (Ct = oe)[(ht = Nt) + 0] << 0 | Ct[ht + 1] << 8, Nt += 2;
            break;
          case "ANMF":
            var mr, ce;
            (ce = Ne.frames[me] = {}).offset_x = 2 * b(oe, Re), Re += 3, ce.offset_y = 2 * b(oe, Re), Re += 3, ce.width = 1 + b(oe, Re), Re += 3, ce.height = 1 + b(oe, Re), Re += 3, ce.duration = b(oe, Re), Re += 3, mr = oe[Re++], ce.dispose = 1 & mr, ce.blend = mr >> 1 & 1;
        }
        Pt != "ANMF" && (Re += kt);
      }
      return Ne;
    }
  }(q, 0);
  G.response = q, G.rgbaoutput = !0, G.dataurl = !1;
  var Y = G.header ? G.header : null, he = G.frames ? G.frames : null;
  if (Y) {
    Y.loop_counter = Y.loop_count, M = [Y.canvas_height], E = [Y.canvas_width];
    for (var X = 0; X < he.length && he[X].blend != 0; X++) ;
  }
  var J = he[0], ie = U.WebPDecodeRGBA(q, J.src_off, J.src_size, E, M);
  J.rgba = ie, J.imgwidth = E[0], J.imgheight = M[0];
  for (var ye = 0; ye < E[0] * M[0] * 4; ye++) D[ye] = ie[ye];
  return this.width = E, this.height = M, this.data = D, this;
}
(function(r) {
  var e = function() {
    return typeof Av == "function";
  }, t = function(M, E, D, U) {
    var q = 4, G = l;
    switch (U) {
      case r.image_compression.FAST:
        q = 1, G = s;
        break;
      case r.image_compression.MEDIUM:
        q = 6, G = o;
        break;
      case r.image_compression.SLOW:
        q = 9, G = d;
    }
    M = n(M, E, D, G);
    var Y = Av(M, { level: q });
    return r.__addimage__.arrayBufferToBinaryString(Y);
  }, n = function(M, E, D, U) {
    for (var q, G, Y, he = M.length / E, X = new Uint8Array(M.length + he), J = b(), ie = 0; ie < he; ie += 1) {
      if (Y = ie * E, q = M.subarray(Y, Y + E), U) X.set(U(q, D, G), Y + ie);
      else {
        for (var ye, oe = J.length, Re = []; ye < oe; ye += 1) Re[ye] = J[ye](q, D, G);
        var Ne = T(Re.concat());
        X.set(Re[Ne], Y + ie);
      }
      G = q;
    }
    return X;
  }, i = function(M) {
    var E = Array.apply([], M);
    return E.unshift(0), E;
  }, s = function(M, E) {
    var D, U = [], q = M.length;
    U[0] = 1;
    for (var G = 0; G < q; G += 1) D = M[G - E] || 0, U[G + 1] = M[G] - D + 256 & 255;
    return U;
  }, l = function(M, E, D) {
    var U, q = [], G = M.length;
    q[0] = 2;
    for (var Y = 0; Y < G; Y += 1) U = D && D[Y] || 0, q[Y + 1] = M[Y] - U + 256 & 255;
    return q;
  }, o = function(M, E, D) {
    var U, q, G = [], Y = M.length;
    G[0] = 3;
    for (var he = 0; he < Y; he += 1) U = M[he - E] || 0, q = D && D[he] || 0, G[he + 1] = M[he] + 256 - (U + q >>> 1) & 255;
    return G;
  }, d = function(M, E, D) {
    var U, q, G, Y, he = [], X = M.length;
    he[0] = 4;
    for (var J = 0; J < X; J += 1) U = M[J - E] || 0, q = D && D[J] || 0, G = D && D[J - E] || 0, Y = m(U, q, G), he[J + 1] = M[J] - Y + 256 & 255;
    return he;
  }, m = function(M, E, D) {
    if (M === E && E === D) return M;
    var U = Math.abs(E - D), q = Math.abs(M - D), G = Math.abs(M + E - D - D);
    return U <= q && U <= G ? M : q <= G ? E : D;
  }, b = function() {
    return [i, s, l, o, d];
  }, T = function(M) {
    var E = M.map(function(D) {
      return D.reduce(function(U, q) {
        return U + Math.abs(q);
      }, 0);
    });
    return E.indexOf(Math.min.apply(null, E));
  };
  r.processPNG = function(M, E, D, U) {
    var q, G, Y, he, X, J, ie, ye, oe, Re, Ne, me, _e, Fe, Me, Ct = this.decode.FLATE_DECODE, ht = "";
    if (this.__addimage__.isArrayBuffer(M) && (M = new Uint8Array(M)), this.__addimage__.isArrayBufferView(M)) {
      if (M = (Y = new OX(M)).imgData, G = Y.bits, q = Y.colorSpace, X = Y.colors, [4, 6].indexOf(Y.colorType) !== -1) {
        if (Y.bits === 8) {
          oe = (ye = Y.pixelBitlength == 32 ? new Uint32Array(Y.decodePixels().buffer) : Y.pixelBitlength == 16 ? new Uint16Array(Y.decodePixels().buffer) : new Uint8Array(Y.decodePixels().buffer)).length, Ne = new Uint8Array(oe * Y.colors), Re = new Uint8Array(oe);
          var Pt, bt = Y.pixelBitlength - Y.bits;
          for (Fe = 0, Me = 0; Fe < oe; Fe++) {
            for (_e = ye[Fe], Pt = 0; Pt < bt; ) Ne[Me++] = _e >>> Pt & 255, Pt += Y.bits;
            Re[Fe] = _e >>> Pt & 255;
          }
        }
        if (Y.bits === 16) {
          oe = (ye = new Uint32Array(Y.decodePixels().buffer)).length, Ne = new Uint8Array(oe * (32 / Y.pixelBitlength) * Y.colors), Re = new Uint8Array(oe * (32 / Y.pixelBitlength)), me = Y.colors > 1, Fe = 0, Me = 0;
          for (var kt = 0; Fe < oe; ) _e = ye[Fe++], Ne[Me++] = _e >>> 0 & 255, me && (Ne[Me++] = _e >>> 16 & 255, _e = ye[Fe++], Ne[Me++] = _e >>> 0 & 255), Re[kt++] = _e >>> 16 & 255;
          G = 8;
        }
        U !== r.image_compression.NONE && e() ? (M = t(Ne, Y.width * Y.colors, Y.colors, U), ie = t(Re, Y.width, 1, U)) : (M = Ne, ie = Re, Ct = void 0);
      }
      if (Y.colorType === 3 && (q = this.color_spaces.INDEXED, J = Y.palette, Y.transparency.indexed)) {
        var Nt = Y.transparency.indexed, mr = 0;
        for (Fe = 0, oe = Nt.length; Fe < oe; ++Fe) mr += Nt[Fe];
        if ((mr /= 255) === oe - 1 && Nt.indexOf(0) !== -1) he = [Nt.indexOf(0)];
        else if (mr !== oe) {
          for (ye = Y.decodePixels(), Re = new Uint8Array(ye.length), Fe = 0, oe = ye.length; Fe < oe; Fe++) Re[Fe] = Nt[ye[Fe]];
          ie = t(Re, Y.width, 1);
        }
      }
      var ce = function(Be) {
        var Ue;
        switch (Be) {
          case r.image_compression.FAST:
            Ue = 11;
            break;
          case r.image_compression.MEDIUM:
            Ue = 13;
            break;
          case r.image_compression.SLOW:
            Ue = 14;
            break;
          default:
            Ue = 12;
        }
        return Ue;
      }(U);
      return Ct === this.decode.FLATE_DECODE && (ht = "/Predictor " + ce + " "), ht += "/Colors " + X + " /BitsPerComponent " + G + " /Columns " + Y.width, (this.__addimage__.isArrayBuffer(M) || this.__addimage__.isArrayBufferView(M)) && (M = this.__addimage__.arrayBufferToBinaryString(M)), (ie && this.__addimage__.isArrayBuffer(ie) || this.__addimage__.isArrayBufferView(ie)) && (ie = this.__addimage__.arrayBufferToBinaryString(ie)), { alias: D, data: M, index: E, filter: Ct, decodeParameters: ht, transparency: he, palette: J, sMask: ie, predictor: ce, width: Y.width, height: Y.height, bitsPerComponent: G, colorSpace: q };
    }
  };
})(Jr.API), function(r) {
  r.processGIF89A = function(e, t, n, i) {
    var s = new NX(e), l = s.width, o = s.height, d = [];
    s.decodeAndBlitFrameRGBA(0, d);
    var m = { data: d, width: l, height: o }, b = new Xb(100).encode(m, 100);
    return r.processJPEG.call(this, b, t, n, i);
  }, r.processGIF87A = r.processGIF89A;
}(Jr.API), fc.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var r = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(r);
    for (var e = 0; e < r; e++) {
      var t = this.datav.getUint8(this.pos++, !0), n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0);
      this.palette[e] = { red: i, green: n, blue: t, quad: s };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, fc.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var r = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[r]();
  } catch (t) {
    vi.log("bit decode error:" + t);
  }
}, fc.prototype.bit1 = function() {
  var r, e = Math.ceil(this.width / 8), t = e % 4;
  for (r = this.height - 1; r >= 0; r--) {
    for (var n = this.bottom_up ? r : this.height - 1 - r, i = 0; i < e; i++) for (var s = this.datav.getUint8(this.pos++, !0), l = n * this.width * 4 + 8 * i * 4, o = 0; o < 8 && 8 * i + o < this.width; o++) {
      var d = this.palette[s >> 7 - o & 1];
      this.data[l + 4 * o] = d.blue, this.data[l + 4 * o + 1] = d.green, this.data[l + 4 * o + 2] = d.red, this.data[l + 4 * o + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, fc.prototype.bit4 = function() {
  for (var r = Math.ceil(this.width / 2), e = r % 4, t = this.height - 1; t >= 0; t--) {
    for (var n = this.bottom_up ? t : this.height - 1 - t, i = 0; i < r; i++) {
      var s = this.datav.getUint8(this.pos++, !0), l = n * this.width * 4 + 2 * i * 4, o = s >> 4, d = 15 & s, m = this.palette[o];
      if (this.data[l] = m.blue, this.data[l + 1] = m.green, this.data[l + 2] = m.red, this.data[l + 3] = 255, 2 * i + 1 >= this.width) break;
      m = this.palette[d], this.data[l + 4] = m.blue, this.data[l + 4 + 1] = m.green, this.data[l + 4 + 2] = m.red, this.data[l + 4 + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, fc.prototype.bit8 = function() {
  for (var r = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var t = this.bottom_up ? e : this.height - 1 - e, n = 0; n < this.width; n++) {
      var i = this.datav.getUint8(this.pos++, !0), s = t * this.width * 4 + 4 * n;
      if (i < this.palette.length) {
        var l = this.palette[i];
        this.data[s] = l.red, this.data[s + 1] = l.green, this.data[s + 2] = l.blue, this.data[s + 3] = 255;
      } else this.data[s] = 255, this.data[s + 1] = 255, this.data[s + 2] = 255, this.data[s + 3] = 255;
    }
    r !== 0 && (this.pos += 4 - r);
  }
}, fc.prototype.bit15 = function() {
  for (var r = this.width % 3, e = parseInt("11111", 2), t = this.height - 1; t >= 0; t--) {
    for (var n = this.bottom_up ? t : this.height - 1 - t, i = 0; i < this.width; i++) {
      var s = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var l = (s & e) / e * 255 | 0, o = (s >> 5 & e) / e * 255 | 0, d = (s >> 10 & e) / e * 255 | 0, m = s >> 15 ? 255 : 0, b = n * this.width * 4 + 4 * i;
      this.data[b] = d, this.data[b + 1] = o, this.data[b + 2] = l, this.data[b + 3] = m;
    }
    this.pos += r;
  }
}, fc.prototype.bit16 = function() {
  for (var r = this.width % 3, e = parseInt("11111", 2), t = parseInt("111111", 2), n = this.height - 1; n >= 0; n--) {
    for (var i = this.bottom_up ? n : this.height - 1 - n, s = 0; s < this.width; s++) {
      var l = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var o = (l & e) / e * 255 | 0, d = (l >> 5 & t) / t * 255 | 0, m = (l >> 11) / e * 255 | 0, b = i * this.width * 4 + 4 * s;
      this.data[b] = m, this.data[b + 1] = d, this.data[b + 2] = o, this.data[b + 3] = 255;
    }
    this.pos += r;
  }
}, fc.prototype.bit24 = function() {
  for (var r = this.height - 1; r >= 0; r--) {
    for (var e = this.bottom_up ? r : this.height - 1 - r, t = 0; t < this.width; t++) {
      var n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), l = e * this.width * 4 + 4 * t;
      this.data[l] = s, this.data[l + 1] = i, this.data[l + 2] = n, this.data[l + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, fc.prototype.bit32 = function() {
  for (var r = this.height - 1; r >= 0; r--) for (var e = this.bottom_up ? r : this.height - 1 - r, t = 0; t < this.width; t++) {
    var n = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), s = this.datav.getUint8(this.pos++, !0), l = this.datav.getUint8(this.pos++, !0), o = e * this.width * 4 + 4 * t;
    this.data[o] = s, this.data[o + 1] = i, this.data[o + 2] = n, this.data[o + 3] = l;
  }
}, fc.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  r.processBMP = function(e, t, n, i) {
    var s = new fc(e, !1), l = s.width, o = s.height, d = { data: s.getData(), width: l, height: o }, m = new Xb(100).encode(d, 100);
    return r.processJPEG.call(this, m, t, n, i);
  };
}(Jr.API), MS.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  r.processWEBP = function(e, t, n, i) {
    var s = new MS(e), l = s.width, o = s.height, d = { data: s.getData(), width: l, height: o }, m = new Xb(100).encode(d, 100);
    return r.processJPEG.call(this, m, t, n, i);
  };
}(Jr.API), Jr.API.processRGBA = function(r, e, t) {
  for (var n = r.data, i = n.length, s = new Uint8Array(i / 4 * 3), l = new Uint8Array(i / 4), o = 0, d = 0, m = 0; m < i; m += 4) {
    var b = n[m], T = n[m + 1], M = n[m + 2], E = n[m + 3];
    s[o++] = b, s[o++] = T, s[o++] = M, l[d++] = E;
  }
  var D = this.__addimage__.arrayBufferToBinaryString(s);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(l), data: D, index: e, alias: t, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: r.width, height: r.height };
}, Jr.API.setLanguage = function(r) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[r] !== void 0 && (this.internal.languageSettings.languageCode = r, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, hd = Jr.API, Um = hd.getCharWidthsArray = function(r, e) {
  var t, n, i = (e = e || {}).font || this.internal.getFont(), s = e.fontSize || this.internal.getFontSize(), l = e.charSpace || this.internal.getCharSpace(), o = e.widths ? e.widths : i.metadata.Unicode.widths, d = o.fof ? o.fof : 1, m = e.kerning ? e.kerning : i.metadata.Unicode.kerning, b = m.fof ? m.fof : 1, T = e.doKerning !== !1, M = 0, E = r.length, D = 0, U = o[0] || d, q = [];
  for (t = 0; t < E; t++) n = r.charCodeAt(t), typeof i.metadata.widthOfString == "function" ? q.push((i.metadata.widthOfGlyph(i.metadata.characterToGlyph(n)) + l * (1e3 / s) || 0) / 1e3) : (M = T && ii(m[n]) === "object" && !isNaN(parseInt(m[n][D], 10)) ? m[n][D] / b : 0, q.push((o[n] || U) / d + M)), D = n;
  return q;
}, SS = hd.getStringUnitWidth = function(r, e) {
  var t = (e = e || {}).fontSize || this.internal.getFontSize(), n = e.font || this.internal.getFont(), i = e.charSpace || this.internal.getCharSpace();
  return hd.processArabic && (r = hd.processArabic(r)), typeof n.metadata.widthOfString == "function" ? n.metadata.widthOfString(r, t, i) / t : Um.apply(this, arguments).reduce(function(s, l) {
    return s + l;
  }, 0);
}, ES = function(r, e, t, n) {
  for (var i = [], s = 0, l = r.length, o = 0; s !== l && o + e[s] < t; ) o += e[s], s++;
  i.push(r.slice(0, s));
  var d = s;
  for (o = 0; s !== l; ) o + e[s] > n && (i.push(r.slice(d, s)), o = 0, d = s), o += e[s], s++;
  return d !== s && i.push(r.slice(d, s)), i;
}, CS = function(r, e, t) {
  t || (t = {});
  var n, i, s, l, o, d, m, b = [], T = [b], M = t.textIndent || 0, E = 0, D = 0, U = r.split(" "), q = Um.apply(this, [" ", t])[0];
  if (d = t.lineIndent === -1 ? U[0].length + 2 : t.lineIndent || 0) {
    var G = Array(d).join(" "), Y = [];
    U.map(function(X) {
      (X = X.split(/\s*\n/)).length > 1 ? Y = Y.concat(X.map(function(J, ie) {
        return (ie && J.length ? `
` : "") + J;
      })) : Y.push(X[0]);
    }), U = Y, d = SS.apply(this, [G, t]);
  }
  for (s = 0, l = U.length; s < l; s++) {
    var he = 0;
    if (n = U[s], d && n[0] == `
` && (n = n.substr(1), he = 1), M + E + (D = (i = Um.apply(this, [n, t])).reduce(function(X, J) {
      return X + J;
    }, 0)) > e || he) {
      if (D > e) {
        for (o = ES.apply(this, [n, i, e - (M + E), e]), b.push(o.shift()), b = [o.pop()]; o.length; ) T.push([o.shift()]);
        D = i.slice(n.length - (b[0] ? b[0].length : 0)).reduce(function(X, J) {
          return X + J;
        }, 0);
      } else b = [n];
      T.push(b), M = D + d, E = q;
    } else b.push(n), M += E + D, E = q;
  }
  return m = d ? function(X, J) {
    return (J ? G : "") + X.join(" ");
  } : function(X) {
    return X.join(" ");
  }, T.map(m);
}, hd.splitTextToSize = function(r, e, t) {
  var n, i = (t = t || {}).fontSize || this.internal.getFontSize(), s = (function(b) {
    if (b.widths && b.kerning) return { widths: b.widths, kerning: b.kerning };
    var T = this.internal.getFont(b.fontName, b.fontStyle);
    return T.metadata.Unicode ? { widths: T.metadata.Unicode.widths || { 0: 1 }, kerning: T.metadata.Unicode.kerning || {} } : { font: T.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, t);
  n = Array.isArray(r) ? r : String(r).split(/\r?\n/);
  var l = 1 * this.internal.scaleFactor * e / i;
  s.textIndent = t.textIndent ? 1 * t.textIndent * this.internal.scaleFactor / i : 0, s.lineIndent = t.lineIndent;
  var o, d, m = [];
  for (o = 0, d = n.length; o < d; o++) m = m.concat(CS.apply(this, [n[o], l, s]));
  return m;
}, function(r) {
  r.__fontmetrics__ = r.__fontmetrics__ || {};
  for (var e = "klmnopqrstuvwxyz", t = {}, n = {}, i = 0; i < e.length; i++) t[e[i]] = "0123456789abcdef"[i], n["0123456789abcdef"[i]] = e[i];
  var s = function(T) {
    return "0x" + parseInt(T, 10).toString(16);
  }, l = r.__fontmetrics__.compress = function(T) {
    var M, E, D, U, q = ["{"];
    for (var G in T) {
      if (M = T[G], isNaN(parseInt(G, 10)) ? E = "'" + G + "'" : (G = parseInt(G, 10), E = (E = s(G).slice(2)).slice(0, -1) + n[E.slice(-1)]), typeof M == "number") M < 0 ? (D = s(M).slice(3), U = "-") : (D = s(M).slice(2), U = ""), D = U + D.slice(0, -1) + n[D.slice(-1)];
      else {
        if (ii(M) !== "object") throw new Error("Don't know what to do with value type " + ii(M) + ".");
        D = l(M);
      }
      q.push(E + D);
    }
    return q.push("}"), q.join("");
  }, o = r.__fontmetrics__.uncompress = function(T) {
    if (typeof T != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var M, E, D, U, q = {}, G = 1, Y = q, he = [], X = "", J = "", ie = T.length - 1, ye = 1; ye < ie; ye += 1) (U = T[ye]) == "'" ? M ? (D = M.join(""), M = void 0) : M = [] : M ? M.push(U) : U == "{" ? (he.push([Y, D]), Y = {}, D = void 0) : U == "}" ? ((E = he.pop())[0][E[1]] = Y, D = void 0, Y = E[0]) : U == "-" ? G = -1 : D === void 0 ? t.hasOwnProperty(U) ? (X += t[U], D = parseInt(X, 16) * G, G = 1, X = "") : X += U : t.hasOwnProperty(U) ? (J += t[U], Y[D] = parseInt(J, 16) * G, G = 1, D = void 0, J = "") : J += U;
    return q;
  }, d = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: o("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, m = { Unicode: { Courier: d, "Courier-Bold": d, "Courier-BoldOblique": d, "Courier-Oblique": d, Helvetica: d, "Helvetica-Bold": d, "Helvetica-BoldOblique": d, "Helvetica-Oblique": d, "Times-Roman": d, "Times-Bold": d, "Times-BoldItalic": d, "Times-Italic": d } }, b = { Unicode: { "Courier-Oblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": o("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": o("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: o("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": o("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: o("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": o("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": o("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": o("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": o("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  r.events.push(["addFont", function(T) {
    var M = T.font, E = b.Unicode[M.postScriptName];
    E && (M.metadata.Unicode = {}, M.metadata.Unicode.widths = E.widths, M.metadata.Unicode.kerning = E.kerning);
    var D = m.Unicode[M.postScriptName];
    D && (M.metadata.Unicode.encoding = D, M.encoding = D.codePages[0]);
  }]);
}(Jr.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function(t) {
    for (var n = t.length, i = new Uint8Array(n), s = 0; s < n; s++) i[s] = t.charCodeAt(s);
    return i;
  };
  r.API.events.push(["addFont", function(t) {
    var n = void 0, i = t.font, s = t.instance;
    if (!i.isStandardFont) {
      if (s === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      if (typeof (n = s.existsFileInVFS(i.postScriptName) === !1 ? s.loadFile(i.postScriptName) : s.getFileFromVFS(i.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i.postScriptName + "').");
      (function(l, o) {
        o = /^\x00\x01\x00\x00/.test(o) ? e(o) : e(lg(o)), l.metadata = r.API.TTFFont.open(o), l.metadata.Unicode = l.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, l.metadata.glyIdsUsed = [0];
      })(i, n);
    }
  }]);
}(Jr), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(r) {
  function e() {
    return (Qr.canvg ? Promise.resolve(Qr.canvg) : import("./index.es-BMA8JOAQ-B9k0csPF.mjs")).catch(function(t) {
      return Promise.reject(new Error("Could not load canvg: " + t));
    }).then(function(t) {
      return t.default ? t.default : t;
    });
  }
  Jr.API.addSvgAsImage = function(t, n, i, s, l, o, d, m) {
    if (isNaN(n) || isNaN(i)) throw vi.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(s) || isNaN(l)) throw vi.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var b = document.createElement("canvas");
    b.width = s, b.height = l;
    var T = b.getContext("2d");
    T.fillStyle = "#fff", T.fillRect(0, 0, b.width, b.height);
    var M = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, E = this;
    return e().then(function(D) {
      return D.fromString(T, t, M);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(D) {
      return D.render(M);
    }).then(function() {
      E.addImage(b.toDataURL("image/jpeg", 1), n, i, s, l, d, m);
    });
  };
}(), Jr.API.putTotalPages = function(r) {
  var e, t = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(r, "g"), t = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(r, this.internal.getFont()), "g"), t = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var n = 1; n <= this.internal.getNumberOfPages(); n++) for (var i = 0; i < this.internal.pages[n].length; i++) this.internal.pages[n][i] = this.internal.pages[n][i].replace(e, t);
  return this;
}, Jr.API.viewerPreferences = function(r, e) {
  var t;
  r = r || {}, e = e || !1;
  var n, i, s, l = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, o = Object.keys(l), d = [], m = 0, b = 0, T = 0;
  function M(D, U) {
    var q, G = !1;
    for (q = 0; q < D.length; q += 1) D[q] === U && (G = !0);
    return G;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(l)), this.internal.viewerpreferences.isSubscribed = !1), t = this.internal.viewerpreferences.configuration, r === "reset" || e === !0) {
    var E = o.length;
    for (T = 0; T < E; T += 1) t[o[T]].value = t[o[T]].defaultValue, t[o[T]].explicitSet = !1;
  }
  if (ii(r) === "object") {
    for (i in r) if (s = r[i], M(o, i) && s !== void 0) {
      if (t[i].type === "boolean" && typeof s == "boolean") t[i].value = s;
      else if (t[i].type === "name" && M(t[i].valueSet, s)) t[i].value = s;
      else if (t[i].type === "integer" && Number.isInteger(s)) t[i].value = s;
      else if (t[i].type === "array") {
        for (m = 0; m < s.length; m += 1) if (n = !0, s[m].length === 1 && typeof s[m][0] == "number") d.push(String(s[m] - 1));
        else if (s[m].length > 1) {
          for (b = 0; b < s[m].length; b += 1) typeof s[m][b] != "number" && (n = !1);
          n === !0 && d.push([s[m][0] - 1, s[m][1] - 1].join(" "));
        }
        t[i].value = "[" + d.join(" ") + "]";
      } else t[i].value = t[i].defaultValue;
      t[i].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var D, U = [];
    for (D in t) t[D].explicitSet === !0 && (t[D].type === "name" ? U.push("/" + D + " /" + t[D].value) : U.push("/" + D + " " + t[D].value));
    U.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + U.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = t, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(r) {
  var e = function() {
    var n = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', i = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), s = unescape(encodeURIComponent(n)), l = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), o = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), d = unescape(encodeURIComponent("</x:xmpmeta>")), m = s.length + l.length + o.length + i.length + d.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + m + " >>"), this.internal.write("stream"), this.internal.write(i + s + l + o + d), this.internal.write("endstream"), this.internal.write("endobj");
  }, t = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  r.addMetadata = function(n, i) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: n, namespaceuri: i || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", t), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(Jr.API), function(r) {
  var e = r.API, t = e.pdfEscape16 = function(s, l) {
    for (var o, d = l.metadata.Unicode.widths, m = ["", "0", "00", "000", "0000"], b = [""], T = 0, M = s.length; T < M; ++T) {
      if (o = l.metadata.characterToGlyph(s.charCodeAt(T)), l.metadata.glyIdsUsed.push(o), l.metadata.toUnicode[o] = s.charCodeAt(T), d.indexOf(o) == -1 && (d.push(o), d.push([parseInt(l.metadata.widthOfGlyph(o), 10)])), o == "0") return b.join("");
      o = o.toString(16), b.push(m[4 - o.length], o);
    }
    return b.join("");
  }, n = function(s) {
    var l, o, d, m, b, T, M;
    for (b = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, d = [], T = 0, M = (o = Object.keys(s).sort(function(E, D) {
      return E - D;
    })).length; T < M; T++) l = o[T], d.length >= 100 && (b += `
` + d.length + ` beginbfchar
` + d.join(`
`) + `
endbfchar`, d = []), s[l] !== void 0 && s[l] !== null && typeof s[l].toString == "function" && (m = ("0000" + s[l].toString(16)).slice(-4), l = ("0000" + (+l).toString(16)).slice(-4), d.push("<" + l + "><" + m + ">"));
    return d.length && (b += `
` + d.length + ` beginbfchar
` + d.join(`
`) + `
endbfchar
`), b += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  e.events.push(["putFont", function(s) {
    (function(l) {
      var o = l.font, d = l.out, m = l.newObject, b = l.putStream;
      if (o.metadata instanceof r.API.TTFFont && o.encoding === "Identity-H") {
        for (var T = o.metadata.Unicode.widths, M = o.metadata.subset.encode(o.metadata.glyIdsUsed, 1), E = "", D = 0; D < M.length; D++) E += String.fromCharCode(M[D]);
        var U = m();
        b({ data: E, addLength1: !0, objectId: U }), d("endobj");
        var q = m();
        b({ data: n(o.metadata.toUnicode), addLength1: !0, objectId: q }), d("endobj");
        var G = m();
        d("<<"), d("/Type /FontDescriptor"), d("/FontName /" + gd(o.fontName)), d("/FontFile2 " + U + " 0 R"), d("/FontBBox " + r.API.PDFObject.convert(o.metadata.bbox)), d("/Flags " + o.metadata.flags), d("/StemV " + o.metadata.stemV), d("/ItalicAngle " + o.metadata.italicAngle), d("/Ascent " + o.metadata.ascender), d("/Descent " + o.metadata.decender), d("/CapHeight " + o.metadata.capHeight), d(">>"), d("endobj");
        var Y = m();
        d("<<"), d("/Type /Font"), d("/BaseFont /" + gd(o.fontName)), d("/FontDescriptor " + G + " 0 R"), d("/W " + r.API.PDFObject.convert(T)), d("/CIDToGIDMap /Identity"), d("/DW 1000"), d("/Subtype /CIDFontType2"), d("/CIDSystemInfo"), d("<<"), d("/Supplement 0"), d("/Registry (Adobe)"), d("/Ordering (" + o.encoding + ")"), d(">>"), d(">>"), d("endobj"), o.objectNumber = m(), d("<<"), d("/Type /Font"), d("/Subtype /Type0"), d("/ToUnicode " + q + " 0 R"), d("/BaseFont /" + gd(o.fontName)), d("/Encoding /" + o.encoding), d("/DescendantFonts [" + Y + " 0 R]"), d(">>"), d("endobj"), o.isAlreadyPutted = !0;
      }
    })(s);
  }]), e.events.push(["putFont", function(s) {
    (function(l) {
      var o = l.font, d = l.out, m = l.newObject, b = l.putStream;
      if (o.metadata instanceof r.API.TTFFont && o.encoding === "WinAnsiEncoding") {
        for (var T = o.metadata.rawData, M = "", E = 0; E < T.length; E++) M += String.fromCharCode(T[E]);
        var D = m();
        b({ data: M, addLength1: !0, objectId: D }), d("endobj");
        var U = m();
        b({ data: n(o.metadata.toUnicode), addLength1: !0, objectId: U }), d("endobj");
        var q = m();
        d("<<"), d("/Descent " + o.metadata.decender), d("/CapHeight " + o.metadata.capHeight), d("/StemV " + o.metadata.stemV), d("/Type /FontDescriptor"), d("/FontFile2 " + D + " 0 R"), d("/Flags 96"), d("/FontBBox " + r.API.PDFObject.convert(o.metadata.bbox)), d("/FontName /" + gd(o.fontName)), d("/ItalicAngle " + o.metadata.italicAngle), d("/Ascent " + o.metadata.ascender), d(">>"), d("endobj"), o.objectNumber = m();
        for (var G = 0; G < o.metadata.hmtx.widths.length; G++) o.metadata.hmtx.widths[G] = parseInt(o.metadata.hmtx.widths[G] * (1e3 / o.metadata.head.unitsPerEm));
        d("<</Subtype/TrueType/Type/Font/ToUnicode " + U + " 0 R/BaseFont/" + gd(o.fontName) + "/FontDescriptor " + q + " 0 R/Encoding/" + o.encoding + " /FirstChar 29 /LastChar 255 /Widths " + r.API.PDFObject.convert(o.metadata.hmtx.widths) + ">>"), d("endobj"), o.isAlreadyPutted = !0;
      }
    })(s);
  }]);
  var i = function(s) {
    var l, o = s.text || "", d = s.x, m = s.y, b = s.options || {}, T = s.mutex || {}, M = T.pdfEscape, E = T.activeFontKey, D = T.fonts, U = E, q = "", G = 0, Y = "", he = D[U].encoding;
    if (D[U].encoding !== "Identity-H") return { text: o, x: d, y: m, options: b, mutex: T };
    for (Y = o, U = E, Array.isArray(o) && (Y = o[0]), G = 0; G < Y.length; G += 1) D[U].metadata.hasOwnProperty("cmap") && (l = D[U].metadata.cmap.unicode.codeMap[Y[G].charCodeAt(0)]), l || Y[G].charCodeAt(0) < 256 && D[U].metadata.hasOwnProperty("Unicode") ? q += Y[G] : q += "";
    var X = "";
    return parseInt(U.slice(1)) < 14 || he === "WinAnsiEncoding" ? X = M(q, U).split("").map(function(J) {
      return J.charCodeAt(0).toString(16);
    }).join("") : he === "Identity-H" && (X = t(q, D[U])), T.isHex = !0, { text: X, x: d, y: m, options: b, mutex: T };
  };
  e.events.push(["postProcessText", function(s) {
    var l = s.text || "", o = [], d = { text: l, x: s.x, y: s.y, options: s.options, mutex: s.mutex };
    if (Array.isArray(l)) {
      var m = 0;
      for (m = 0; m < l.length; m += 1) Array.isArray(l[m]) && l[m].length === 3 ? o.push([i(Object.assign({}, d, { text: l[m][0] })).text, l[m][1], l[m][2]]) : o.push(i(Object.assign({}, d, { text: l[m] })).text);
      s.text = o;
    } else s.text = i(Object.assign({}, d, { text: l })).text;
  }]);
}(Jr), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(r) {
  var e = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  r.existsFileInVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0;
  }, r.addFileToVFS = function(t, n) {
    return e.call(this), this.internal.vFS[t] = n, this;
  }, r.getFileFromVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0 ? this.internal.vFS[t] : null;
  };
}(Jr.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(r) {
  r.__bidiEngine__ = r.prototype.__bidiEngine__ = function(n) {
    var i, s, l, o, d, m, b, T = e, M = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], E = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], D = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, U = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, q = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], G = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), Y = !1, he = 0;
    this.__bidiEngine__ = {};
    var X = function(me) {
      var _e = me.charCodeAt(), Fe = _e >> 8, Me = U[Fe];
      return Me !== void 0 ? T[256 * Me + (255 & _e)] : Fe === 252 || Fe === 253 ? "AL" : G.test(Fe) ? "L" : Fe === 8 ? "R" : "N";
    }, J = function(me) {
      for (var _e, Fe = 0; Fe < me.length; Fe++) {
        if ((_e = X(me.charAt(Fe))) === "L") return !1;
        if (_e === "R") return !0;
      }
      return !1;
    }, ie = function(me, _e, Fe, Me) {
      var Ct, ht, Pt, bt, kt = _e[Me];
      switch (kt) {
        case "L":
        case "R":
          Y = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          Y && (kt = "AN");
          break;
        case "AL":
          Y = !0, kt = "R";
          break;
        case "WS":
          kt = "N";
          break;
        case "CS":
          Me < 1 || Me + 1 >= _e.length || (Ct = Fe[Me - 1]) !== "EN" && Ct !== "AN" || (ht = _e[Me + 1]) !== "EN" && ht !== "AN" ? kt = "N" : Y && (ht = "AN"), kt = ht === Ct ? ht : "N";
          break;
        case "ES":
          kt = (Ct = Me > 0 ? Fe[Me - 1] : "B") === "EN" && Me + 1 < _e.length && _e[Me + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (Me > 0 && Fe[Me - 1] === "EN") {
            kt = "EN";
            break;
          }
          if (Y) {
            kt = "N";
            break;
          }
          for (Pt = Me + 1, bt = _e.length; Pt < bt && _e[Pt] === "ET"; ) Pt++;
          kt = Pt < bt && _e[Pt] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (l && !o) {
            for (bt = _e.length, Pt = Me + 1; Pt < bt && _e[Pt] === "NSM"; ) Pt++;
            if (Pt < bt) {
              var Nt = me[Me], mr = Nt >= 1425 && Nt <= 2303 || Nt === 64286;
              if (Ct = _e[Pt], mr && (Ct === "R" || Ct === "AL")) {
                kt = "R";
                break;
              }
            }
          }
          kt = Me < 1 || (Ct = _e[Me - 1]) === "B" ? "N" : Fe[Me - 1];
          break;
        case "B":
          Y = !1, i = !0, kt = he;
          break;
        case "S":
          s = !0, kt = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          Y = !1;
          break;
        case "BN":
          kt = "N";
      }
      return kt;
    }, ye = function(me, _e, Fe) {
      var Me = me.split("");
      return Fe && oe(Me, Fe, { hiLevel: he }), Me.reverse(), _e && _e.reverse(), Me.join("");
    }, oe = function(me, _e, Fe) {
      var Me, Ct, ht, Pt, bt, kt = -1, Nt = me.length, mr = 0, ce = [], Be = he ? E : M, Ue = [];
      for (Y = !1, i = !1, s = !1, Ct = 0; Ct < Nt; Ct++) Ue[Ct] = X(me[Ct]);
      for (ht = 0; ht < Nt; ht++) {
        if (bt = mr, ce[ht] = ie(me, Ue, ce, ht), Me = 240 & (mr = Be[bt][D[ce[ht]]]), mr &= 15, _e[ht] = Pt = Be[mr][5], Me > 0) if (Me === 16) {
          for (Ct = kt; Ct < ht; Ct++) _e[Ct] = 1;
          kt = -1;
        } else kt = -1;
        if (Be[mr][6]) kt === -1 && (kt = ht);
        else if (kt > -1) {
          for (Ct = kt; Ct < ht; Ct++) _e[Ct] = Pt;
          kt = -1;
        }
        Ue[ht] === "B" && (_e[ht] = 0), Fe.hiLevel |= Pt;
      }
      s && function(Xe, it, ft) {
        for (var St = 0; St < ft; St++) if (Xe[St] === "S") {
          it[St] = he;
          for (var wt = St - 1; wt >= 0 && Xe[wt] === "WS"; wt--) it[wt] = he;
        }
      }(Ue, _e, Nt);
    }, Re = function(me, _e, Fe, Me, Ct) {
      if (!(Ct.hiLevel < me)) {
        if (me === 1 && he === 1 && !i) return _e.reverse(), void (Fe && Fe.reverse());
        for (var ht, Pt, bt, kt, Nt = _e.length, mr = 0; mr < Nt; ) {
          if (Me[mr] >= me) {
            for (bt = mr + 1; bt < Nt && Me[bt] >= me; ) bt++;
            for (kt = mr, Pt = bt - 1; kt < Pt; kt++, Pt--) ht = _e[kt], _e[kt] = _e[Pt], _e[Pt] = ht, Fe && (ht = Fe[kt], Fe[kt] = Fe[Pt], Fe[Pt] = ht);
            mr = bt;
          }
          mr++;
        }
      }
    }, Ne = function(me, _e, Fe) {
      var Me = me.split(""), Ct = { hiLevel: he };
      return Fe || (Fe = []), oe(Me, Fe, Ct), function(ht, Pt, bt) {
        if (bt.hiLevel !== 0 && b) for (var kt, Nt = 0; Nt < ht.length; Nt++) Pt[Nt] === 1 && (kt = q.indexOf(ht[Nt])) >= 0 && (ht[Nt] = q[kt + 1]);
      }(Me, Fe, Ct), Re(2, Me, _e, Fe, Ct), Re(1, Me, _e, Fe, Ct), Me.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(me, _e, Fe) {
      if (function(Ct, ht) {
        if (ht) for (var Pt = 0; Pt < Ct.length; Pt++) ht[Pt] = Pt;
        o === void 0 && (o = J(Ct)), m === void 0 && (m = J(Ct));
      }(me, _e), l || !d || m)
        if (l && d && o ^ m) he = o ? 1 : 0, me = ye(me, _e, Fe);
        else if (!l && d && m) he = o ? 1 : 0, me = Ne(me, _e, Fe), me = ye(me, _e);
        else if (!l || o || d || m) {
          if (l && !d && o ^ m) me = ye(me, _e), o ? (he = 0, me = Ne(me, _e, Fe)) : (he = 1, me = Ne(me, _e, Fe), me = ye(me, _e));
          else if (l && o && !d && m) he = 1, me = Ne(me, _e, Fe), me = ye(me, _e);
          else if (!l && !d && o ^ m) {
            var Me = b;
            o ? (he = 1, me = Ne(me, _e, Fe), he = 0, b = !1, me = Ne(me, _e, Fe), b = Me) : (he = 0, me = Ne(me, _e, Fe), me = ye(me, _e), he = 1, b = !1, me = Ne(me, _e, Fe), b = Me, me = ye(me, _e));
          }
        } else he = 0, me = Ne(me, _e, Fe);
      else he = o ? 1 : 0, me = Ne(me, _e, Fe);
      return me;
    }, this.__bidiEngine__.setOptions = function(me) {
      me && (l = me.isInputVisual, d = me.isOutputVisual, o = me.isInputRtl, m = me.isOutputRtl, b = me.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(n), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], t = new r.__bidiEngine__({ isInputVisual: !0 });
  r.API.events.push(["postProcessText", function(n) {
    var i = n.text, s = (n.x, n.y, n.options || {}), l = (n.mutex, s.lang, []);
    if (s.isInputVisual = typeof s.isInputVisual != "boolean" || s.isInputVisual, t.setOptions(s), Object.prototype.toString.call(i) === "[object Array]") {
      var o = 0;
      for (l = [], o = 0; o < i.length; o += 1) Object.prototype.toString.call(i[o]) === "[object Array]" ? l.push([t.doBidiReorder(i[o][0]), i[o][1], i[o][2]]) : l.push([t.doBidiReorder(i[o])]);
      n.text = l;
    } else n.text = t.doBidiReorder(i);
    t.setOptions({ isInputVisual: !0 });
  }]);
}(Jr), Jr.API.TTFFont = function() {
  function r(e) {
    var t;
    if (this.rawData = e, t = this.contents = new Dh(e), this.contents.pos = 4, t.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    t.pos = 0, this.parse(), this.subset = new YX(this), this.registerTTF();
  }
  return r.open = function(e) {
    return new r(e);
  }, r.prototype.parse = function() {
    return this.directory = new DX(this.contents), this.head = new FX(this), this.name = new qX(this), this.cmap = new yM(this), this.toUnicode = {}, this.hhea = new UX(this), this.maxp = new GX(this), this.hmtx = new $X(this), this.post = new jX(this), this.os2 = new zX(this), this.loca = new ZX(this), this.glyf = new HX(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, r.prototype.registerTTF = function() {
    var e, t, n, i, s;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var l, o, d, m;
      for (m = [], l = 0, o = (d = this.bbox).length; l < o; l++) e = d[l], m.push(Math.round(e * this.scaleFactor));
      return m;
    }).call(this), this.stemV = 0, this.post.exists ? (n = 255 & (i = this.post.italic_angle), 32768 & (t = i >> 16) && (t = -(1 + (65535 ^ t))), this.italicAngle = +(t + "." + n)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (s = this.familyClass) === 1 || s === 2 || s === 3 || s === 4 || s === 5 || s === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, r.prototype.characterToGlyph = function(e) {
    var t;
    return ((t = this.cmap.unicode) != null ? t.codeMap[e] : void 0) || 0;
  }, r.prototype.widthOfGlyph = function(e) {
    var t;
    return t = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(e).advance * t;
  }, r.prototype.widthOfString = function(e, t, n) {
    var i, s, l, o;
    for (l = 0, s = 0, o = (e = "" + e).length; 0 <= o ? s < o : s > o; s = 0 <= o ? ++s : --s) i = e.charCodeAt(s), l += this.widthOfGlyph(this.characterToGlyph(i)) + n * (1e3 / t) || 0;
    return l * (t / 1e3);
  }, r.prototype.lineHeight = function(e, t) {
    var n;
    return t == null && (t = !1), n = t ? this.lineGap : 0, (this.ascender + n - this.decender) / 1e3 * e;
  }, r;
}();
var Lc, Dh = function() {
  function r(e) {
    this.data = e ?? [], this.pos = 0, this.length = this.data.length;
  }
  return r.prototype.readByte = function() {
    return this.data[this.pos++];
  }, r.prototype.writeByte = function(e) {
    return this.data[this.pos++] = e;
  }, r.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, r.prototype.writeUInt32 = function(e) {
    return this.writeByte(e >>> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, r.prototype.readInt32 = function() {
    var e;
    return (e = this.readUInt32()) >= 2147483648 ? e - 4294967296 : e;
  }, r.prototype.writeInt32 = function(e) {
    return e < 0 && (e += 4294967296), this.writeUInt32(e);
  }, r.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, r.prototype.writeUInt16 = function(e) {
    return this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, r.prototype.readInt16 = function() {
    var e;
    return (e = this.readUInt16()) >= 32768 ? e - 65536 : e;
  }, r.prototype.writeInt16 = function(e) {
    return e < 0 && (e += 65536), this.writeUInt16(e);
  }, r.prototype.readString = function(e) {
    var t, n;
    for (n = [], t = 0; 0 <= e ? t < e : t > e; t = 0 <= e ? ++t : --t) n[t] = String.fromCharCode(this.readByte());
    return n.join("");
  }, r.prototype.writeString = function(e) {
    var t, n, i;
    for (i = [], t = 0, n = e.length; 0 <= n ? t < n : t > n; t = 0 <= n ? ++t : --t) i.push(this.writeByte(e.charCodeAt(t)));
    return i;
  }, r.prototype.readShort = function() {
    return this.readInt16();
  }, r.prototype.writeShort = function(e) {
    return this.writeInt16(e);
  }, r.prototype.readLongLong = function() {
    var e, t, n, i, s, l, o, d;
    return e = this.readByte(), t = this.readByte(), n = this.readByte(), i = this.readByte(), s = this.readByte(), l = this.readByte(), o = this.readByte(), d = this.readByte(), 128 & e ? -1 * (72057594037927940 * (255 ^ e) + 281474976710656 * (255 ^ t) + 1099511627776 * (255 ^ n) + 4294967296 * (255 ^ i) + 16777216 * (255 ^ s) + 65536 * (255 ^ l) + 256 * (255 ^ o) + (255 ^ d) + 1) : 72057594037927940 * e + 281474976710656 * t + 1099511627776 * n + 4294967296 * i + 16777216 * s + 65536 * l + 256 * o + d;
  }, r.prototype.writeLongLong = function(e) {
    var t, n;
    return t = Math.floor(e / 4294967296), n = 4294967295 & e, this.writeByte(t >> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t), this.writeByte(n >> 24 & 255), this.writeByte(n >> 16 & 255), this.writeByte(n >> 8 & 255), this.writeByte(255 & n);
  }, r.prototype.readInt = function() {
    return this.readInt32();
  }, r.prototype.writeInt = function(e) {
    return this.writeInt32(e);
  }, r.prototype.read = function(e) {
    var t, n;
    for (t = [], n = 0; 0 <= e ? n < e : n > e; n = 0 <= e ? ++n : --n) t.push(this.readByte());
    return t;
  }, r.prototype.write = function(e) {
    var t, n, i, s;
    for (s = [], n = 0, i = e.length; n < i; n++) t = e[n], s.push(this.writeByte(t));
    return s;
  }, r;
}(), DX = function() {
  var r;
  function e(t) {
    var n, i, s;
    for (this.scalarType = t.readInt(), this.tableCount = t.readShort(), this.searchRange = t.readShort(), this.entrySelector = t.readShort(), this.rangeShift = t.readShort(), this.tables = {}, i = 0, s = this.tableCount; 0 <= s ? i < s : i > s; i = 0 <= s ? ++i : --i) n = { tag: t.readString(4), checksum: t.readInt(), offset: t.readInt(), length: t.readInt() }, this.tables[n.tag] = n;
  }
  return e.prototype.encode = function(t) {
    var n, i, s, l, o, d, m, b, T, M, E, D, U;
    for (U in E = Object.keys(t).length, d = Math.log(2), T = 16 * Math.floor(Math.log(E) / d), l = Math.floor(T / d), b = 16 * E - T, (i = new Dh()).writeInt(this.scalarType), i.writeShort(E), i.writeShort(T), i.writeShort(l), i.writeShort(b), s = 16 * E, m = i.pos + s, o = null, D = [], t) for (M = t[U], i.writeString(U), i.writeInt(r(M)), i.writeInt(m), i.writeInt(M.length), D = D.concat(M), U === "head" && (o = m), m += M.length; m % 4; ) D.push(0), m++;
    return i.write(D), n = 2981146554 - r(i.data), i.pos = o + 8, i.writeUInt32(n), i.data;
  }, r = function(t) {
    var n, i, s, l;
    for (t = bM.call(t); t.length % 4; ) t.push(0);
    for (s = new Dh(t), i = 0, n = 0, l = t.length; n < l; n = n += 4) i += s.readUInt32();
    return 4294967295 & i;
  }, e;
}(), kX = {}.hasOwnProperty, uu = function(r, e) {
  for (var t in e) kX.call(e, t) && (r[t] = e[t]);
  function n() {
    this.constructor = r;
  }
  return n.prototype = e.prototype, r.prototype = new n(), r.__super__ = e.prototype, r;
};
Lc = function() {
  function r(e) {
    var t;
    this.file = e, t = this.file.directory.tables[this.tag], this.exists = !!t, t && (this.offset = t.offset, this.length = t.length, this.parse(this.file.contents));
  }
  return r.prototype.parse = function() {
  }, r.prototype.encode = function() {
  }, r.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, r;
}();
var FX = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return uu(e, Lc), e.prototype.tag = "head", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.revision = t.readInt(), this.checkSumAdjustment = t.readInt(), this.magicNumber = t.readInt(), this.flags = t.readShort(), this.unitsPerEm = t.readShort(), this.created = t.readLongLong(), this.modified = t.readLongLong(), this.xMin = t.readShort(), this.yMin = t.readShort(), this.xMax = t.readShort(), this.yMax = t.readShort(), this.macStyle = t.readShort(), this.lowestRecPPEM = t.readShort(), this.fontDirectionHint = t.readShort(), this.indexToLocFormat = t.readShort(), this.glyphDataFormat = t.readShort();
  }, e.prototype.encode = function(t) {
    var n;
    return (n = new Dh()).writeInt(this.version), n.writeInt(this.revision), n.writeInt(this.checkSumAdjustment), n.writeInt(this.magicNumber), n.writeShort(this.flags), n.writeShort(this.unitsPerEm), n.writeLongLong(this.created), n.writeLongLong(this.modified), n.writeShort(this.xMin), n.writeShort(this.yMin), n.writeShort(this.xMax), n.writeShort(this.yMax), n.writeShort(this.macStyle), n.writeShort(this.lowestRecPPEM), n.writeShort(this.fontDirectionHint), n.writeShort(t), n.writeShort(this.glyphDataFormat), n.data;
  }, e;
}(), PS = function() {
  function r(e, t) {
    var n, i, s, l, o, d, m, b, T, M, E, D, U, q, G, Y, he;
    switch (this.platformID = e.readUInt16(), this.encodingID = e.readShort(), this.offset = t + e.readInt(), T = e.pos, e.pos = this.offset, this.format = e.readUInt16(), this.length = e.readUInt16(), this.language = e.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (d = 0; d < 256; ++d) this.codeMap[d] = e.readByte();
        break;
      case 4:
        for (E = e.readUInt16(), M = E / 2, e.pos += 6, s = function() {
          var X, J;
          for (J = [], d = X = 0; 0 <= M ? X < M : X > M; d = 0 <= M ? ++X : --X) J.push(e.readUInt16());
          return J;
        }(), e.pos += 2, U = function() {
          var X, J;
          for (J = [], d = X = 0; 0 <= M ? X < M : X > M; d = 0 <= M ? ++X : --X) J.push(e.readUInt16());
          return J;
        }(), m = function() {
          var X, J;
          for (J = [], d = X = 0; 0 <= M ? X < M : X > M; d = 0 <= M ? ++X : --X) J.push(e.readUInt16());
          return J;
        }(), b = function() {
          var X, J;
          for (J = [], d = X = 0; 0 <= M ? X < M : X > M; d = 0 <= M ? ++X : --X) J.push(e.readUInt16());
          return J;
        }(), i = (this.length - e.pos + this.offset) / 2, o = function() {
          var X, J;
          for (J = [], d = X = 0; 0 <= i ? X < i : X > i; d = 0 <= i ? ++X : --X) J.push(e.readUInt16());
          return J;
        }(), d = G = 0, he = s.length; G < he; d = ++G) for (q = s[d], n = Y = D = U[d]; D <= q ? Y <= q : Y >= q; n = D <= q ? ++Y : --Y) b[d] === 0 ? l = n + m[d] : (l = o[b[d] / 2 + (n - D) - (M - d)] || 0) !== 0 && (l += m[d]), this.codeMap[n] = 65535 & l;
    }
    e.pos = T;
  }
  return r.encode = function(e, t) {
    var n, i, s, l, o, d, m, b, T, M, E, D, U, q, G, Y, he, X, J, ie, ye, oe, Re, Ne, me, _e, Fe, Me, Ct, ht, Pt, bt, kt, Nt, mr, ce, Be, Ue, Xe, it, ft, St, wt, ar, Yt, cr;
    switch (Me = new Dh(), l = Object.keys(e).sort(function(_r, Cr) {
      return _r - Cr;
    }), t) {
      case "macroman":
        for (U = 0, q = function() {
          var _r = [];
          for (D = 0; D < 256; ++D) _r.push(0);
          return _r;
        }(), Y = { 0: 0 }, s = {}, Ct = 0, kt = l.length; Ct < kt; Ct++) Y[wt = e[i = l[Ct]]] == null && (Y[wt] = ++U), s[i] = { old: e[i], new: Y[e[i]] }, q[i] = Y[e[i]];
        return Me.writeUInt16(1), Me.writeUInt16(0), Me.writeUInt32(12), Me.writeUInt16(0), Me.writeUInt16(262), Me.writeUInt16(0), Me.write(q), { charMap: s, subtable: Me.data, maxGlyphID: U + 1 };
      case "unicode":
        for (_e = [], T = [], he = 0, Y = {}, n = {}, G = m = null, ht = 0, Nt = l.length; ht < Nt; ht++) Y[J = e[i = l[ht]]] == null && (Y[J] = ++he), n[i] = { old: J, new: Y[J] }, o = Y[J] - i, G != null && o === m || (G && T.push(G), _e.push(i), m = o), G = i;
        for (G && T.push(G), T.push(65535), _e.push(65535), Ne = 2 * (Re = _e.length), oe = 2 * Math.pow(Math.log(Re) / Math.LN2, 2), M = Math.log(oe / 2) / Math.LN2, ye = 2 * Re - oe, d = [], ie = [], E = [], D = Pt = 0, mr = _e.length; Pt < mr; D = ++Pt) {
          if (me = _e[D], b = T[D], me === 65535) {
            d.push(0), ie.push(0);
            break;
          }
          if (me - (Fe = n[me].new) >= 32768) for (d.push(0), ie.push(2 * (E.length + Re - D)), i = bt = me; me <= b ? bt <= b : bt >= b; i = me <= b ? ++bt : --bt) E.push(n[i].new);
          else d.push(Fe - me), ie.push(0);
        }
        for (Me.writeUInt16(3), Me.writeUInt16(1), Me.writeUInt32(12), Me.writeUInt16(4), Me.writeUInt16(16 + 8 * Re + 2 * E.length), Me.writeUInt16(0), Me.writeUInt16(Ne), Me.writeUInt16(oe), Me.writeUInt16(M), Me.writeUInt16(ye), ft = 0, ce = T.length; ft < ce; ft++) i = T[ft], Me.writeUInt16(i);
        for (Me.writeUInt16(0), St = 0, Be = _e.length; St < Be; St++) i = _e[St], Me.writeUInt16(i);
        for (ar = 0, Ue = d.length; ar < Ue; ar++) o = d[ar], Me.writeUInt16(o);
        for (Yt = 0, Xe = ie.length; Yt < Xe; Yt++) X = ie[Yt], Me.writeUInt16(X);
        for (cr = 0, it = E.length; cr < it; cr++) U = E[cr], Me.writeUInt16(U);
        return { charMap: n, subtable: Me.data, maxGlyphID: he + 1 };
    }
  }, r;
}(), yM = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return uu(e, Lc), e.prototype.tag = "cmap", e.prototype.parse = function(t) {
    var n, i, s;
    for (t.pos = this.offset, this.version = t.readUInt16(), s = t.readUInt16(), this.tables = [], this.unicode = null, i = 0; 0 <= s ? i < s : i > s; i = 0 <= s ? ++i : --i) n = new PS(t, this.offset), this.tables.push(n), n.isUnicode && this.unicode == null && (this.unicode = n);
    return !0;
  }, e.encode = function(t, n) {
    var i, s;
    return n == null && (n = "macroman"), i = PS.encode(t, n), (s = new Dh()).writeUInt16(0), s.writeUInt16(1), i.table = s.data.concat(i.subtable), i;
  }, e;
}(), UX = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return uu(e, Lc), e.prototype.tag = "hhea", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.ascender = t.readShort(), this.decender = t.readShort(), this.lineGap = t.readShort(), this.advanceWidthMax = t.readShort(), this.minLeftSideBearing = t.readShort(), this.minRightSideBearing = t.readShort(), this.xMaxExtent = t.readShort(), this.caretSlopeRise = t.readShort(), this.caretSlopeRun = t.readShort(), this.caretOffset = t.readShort(), t.pos += 8, this.metricDataFormat = t.readShort(), this.numberOfMetrics = t.readUInt16();
  }, e;
}(), zX = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return uu(e, Lc), e.prototype.tag = "OS/2", e.prototype.parse = function(t) {
    if (t.pos = this.offset, this.version = t.readUInt16(), this.averageCharWidth = t.readShort(), this.weightClass = t.readUInt16(), this.widthClass = t.readUInt16(), this.type = t.readShort(), this.ySubscriptXSize = t.readShort(), this.ySubscriptYSize = t.readShort(), this.ySubscriptXOffset = t.readShort(), this.ySubscriptYOffset = t.readShort(), this.ySuperscriptXSize = t.readShort(), this.ySuperscriptYSize = t.readShort(), this.ySuperscriptXOffset = t.readShort(), this.ySuperscriptYOffset = t.readShort(), this.yStrikeoutSize = t.readShort(), this.yStrikeoutPosition = t.readShort(), this.familyClass = t.readShort(), this.panose = function() {
      var n, i;
      for (i = [], n = 0; n < 10; ++n) i.push(t.readByte());
      return i;
    }(), this.charRange = function() {
      var n, i;
      for (i = [], n = 0; n < 4; ++n) i.push(t.readInt());
      return i;
    }(), this.vendorID = t.readString(4), this.selection = t.readShort(), this.firstCharIndex = t.readShort(), this.lastCharIndex = t.readShort(), this.version > 0 && (this.ascent = t.readShort(), this.descent = t.readShort(), this.lineGap = t.readShort(), this.winAscent = t.readShort(), this.winDescent = t.readShort(), this.codePageRange = function() {
      var n, i;
      for (i = [], n = 0; n < 2; n = ++n) i.push(t.readInt());
      return i;
    }(), this.version > 1)) return this.xHeight = t.readShort(), this.capHeight = t.readShort(), this.defaultChar = t.readShort(), this.breakChar = t.readShort(), this.maxContext = t.readShort();
  }, e;
}(), jX = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return uu(e, Lc), e.prototype.tag = "post", e.prototype.parse = function(t) {
    var n, i, s;
    switch (t.pos = this.offset, this.format = t.readInt(), this.italicAngle = t.readInt(), this.underlinePosition = t.readShort(), this.underlineThickness = t.readShort(), this.isFixedPitch = t.readInt(), this.minMemType42 = t.readInt(), this.maxMemType42 = t.readInt(), this.minMemType1 = t.readInt(), this.maxMemType1 = t.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var l;
        for (i = t.readUInt16(), this.glyphNameIndex = [], l = 0; 0 <= i ? l < i : l > i; l = 0 <= i ? ++l : --l) this.glyphNameIndex.push(t.readUInt16());
        for (this.names = [], s = []; t.pos < this.offset + this.length; ) n = t.readByte(), s.push(this.names.push(t.readString(n)));
        return s;
      case 151552:
        return i = t.readUInt16(), this.offsets = t.read(i);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var o, d, m;
          for (m = [], l = o = 0, d = this.file.maxp.numGlyphs; 0 <= d ? o < d : o > d; l = 0 <= d ? ++o : --o) m.push(t.readUInt32());
          return m;
        }).call(this);
    }
  }, e;
}(), VX = function(r, e) {
  this.raw = r, this.length = r.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
}, qX = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return uu(e, Lc), e.prototype.tag = "name", e.prototype.parse = function(t) {
    var n, i, s, l, o, d, m, b, T, M, E;
    for (t.pos = this.offset, t.readShort(), n = t.readShort(), d = t.readShort(), i = [], l = 0; 0 <= n ? l < n : l > n; l = 0 <= n ? ++l : --l) i.push({ platformID: t.readShort(), encodingID: t.readShort(), languageID: t.readShort(), nameID: t.readShort(), length: t.readShort(), offset: this.offset + d + t.readShort() });
    for (m = {}, l = T = 0, M = i.length; T < M; l = ++T) s = i[l], t.pos = s.offset, b = t.readString(s.length), o = new VX(b, s), m[E = s.nameID] == null && (m[E] = []), m[s.nameID].push(o);
    this.strings = m, this.copyright = m[0], this.fontFamily = m[1], this.fontSubfamily = m[2], this.uniqueSubfamily = m[3], this.fontName = m[4], this.version = m[5];
    try {
      this.postscriptName = m[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = m[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = m[7], this.manufacturer = m[8], this.designer = m[9], this.description = m[10], this.vendorUrl = m[11], this.designerUrl = m[12], this.license = m[13], this.licenseUrl = m[14], this.preferredFamily = m[15], this.preferredSubfamily = m[17], this.compatibleFull = m[18], this.sampleText = m[19];
  }, e;
}(), GX = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return uu(e, Lc), e.prototype.tag = "maxp", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.numGlyphs = t.readUInt16(), this.maxPoints = t.readUInt16(), this.maxContours = t.readUInt16(), this.maxCompositePoints = t.readUInt16(), this.maxComponentContours = t.readUInt16(), this.maxZones = t.readUInt16(), this.maxTwilightPoints = t.readUInt16(), this.maxStorage = t.readUInt16(), this.maxFunctionDefs = t.readUInt16(), this.maxInstructionDefs = t.readUInt16(), this.maxStackElements = t.readUInt16(), this.maxSizeOfInstructions = t.readUInt16(), this.maxComponentElements = t.readUInt16(), this.maxComponentDepth = t.readUInt16();
  }, e;
}(), $X = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return uu(e, Lc), e.prototype.tag = "hmtx", e.prototype.parse = function(t) {
    var n, i, s, l, o, d, m;
    for (t.pos = this.offset, this.metrics = [], n = 0, d = this.file.hhea.numberOfMetrics; 0 <= d ? n < d : n > d; n = 0 <= d ? ++n : --n) this.metrics.push({ advance: t.readUInt16(), lsb: t.readInt16() });
    for (s = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var b, T;
      for (T = [], n = b = 0; 0 <= s ? b < s : b > s; n = 0 <= s ? ++b : --b) T.push(t.readInt16());
      return T;
    }(), this.widths = (function() {
      var b, T, M, E;
      for (E = [], b = 0, T = (M = this.metrics).length; b < T; b++) l = M[b], E.push(l.advance);
      return E;
    }).call(this), i = this.widths[this.widths.length - 1], m = [], n = o = 0; 0 <= s ? o < s : o > s; n = 0 <= s ? ++o : --o) m.push(this.widths.push(i));
    return m;
  }, e.prototype.forGlyph = function(t) {
    return t in this.metrics ? this.metrics[t] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t - this.metrics.length] };
  }, e;
}(), bM = [].slice, HX = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return uu(e, Lc), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t) {
    var n, i, s, l, o, d, m, b, T, M;
    return t in this.cache ? this.cache[t] : (l = this.file.loca, n = this.file.contents, i = l.indexOf(t), (s = l.lengthOf(t)) === 0 ? this.cache[t] = null : (n.pos = this.offset + i, o = (d = new Dh(n.read(s))).readShort(), b = d.readShort(), M = d.readShort(), m = d.readShort(), T = d.readShort(), this.cache[t] = o === -1 ? new XX(d, b, M, m, T) : new WX(d, o, b, M, m, T), this.cache[t]));
  }, e.prototype.encode = function(t, n, i) {
    var s, l, o, d, m;
    for (o = [], l = [], d = 0, m = n.length; d < m; d++) s = t[n[d]], l.push(o.length), s && (o = o.concat(s.encode(i)));
    return l.push(o.length), { table: o, offsets: l };
  }, e;
}(), WX = function() {
  function r(e, t, n, i, s, l) {
    this.raw = e, this.numberOfContours = t, this.xMin = n, this.yMin = i, this.xMax = s, this.yMax = l, this.compound = !1;
  }
  return r.prototype.encode = function() {
    return this.raw.data;
  }, r;
}(), XX = function() {
  function r(e, t, n, i, s) {
    var l, o;
    for (this.raw = e, this.xMin = t, this.yMin = n, this.xMax = i, this.yMax = s, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], l = this.raw; o = l.readShort(), this.glyphOffsets.push(l.pos), this.glyphIDs.push(l.readUInt16()), 32 & o; ) l.pos += 1 & o ? 4 : 2, 128 & o ? l.pos += 8 : 64 & o ? l.pos += 4 : 8 & o && (l.pos += 2);
  }
  return r.prototype.encode = function() {
    var e, t, n;
    for (t = new Dh(bM.call(this.raw.data)), e = 0, n = this.glyphIDs.length; e < n; ++e) t.pos = this.glyphOffsets[e];
    return t.data;
  }, r;
}(), ZX = function(r) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return uu(e, Lc), e.prototype.tag = "loca", e.prototype.parse = function(t) {
    var n, i;
    return t.pos = this.offset, n = this.file.head.indexToLocFormat, this.offsets = n === 0 ? (function() {
      var s, l;
      for (l = [], i = 0, s = this.length; i < s; i += 2) l.push(2 * t.readUInt16());
      return l;
    }).call(this) : (function() {
      var s, l;
      for (l = [], i = 0, s = this.length; i < s; i += 4) l.push(t.readUInt32());
      return l;
    }).call(this);
  }, e.prototype.indexOf = function(t) {
    return this.offsets[t];
  }, e.prototype.lengthOf = function(t) {
    return this.offsets[t + 1] - this.offsets[t];
  }, e.prototype.encode = function(t, n) {
    for (var i = new Uint32Array(this.offsets.length), s = 0, l = 0, o = 0; o < i.length; ++o) if (i[o] = s, l < n.length && n[l] == o) {
      ++l, i[o] = s;
      var d = this.offsets[o], m = this.offsets[o + 1] - d;
      m > 0 && (s += m);
    }
    for (var b = new Array(4 * i.length), T = 0; T < i.length; ++T) b[4 * T + 3] = 255 & i[T], b[4 * T + 2] = (65280 & i[T]) >> 8, b[4 * T + 1] = (16711680 & i[T]) >> 16, b[4 * T] = (4278190080 & i[T]) >> 24;
    return b;
  }, e;
}(), YX = function() {
  function r(e) {
    this.font = e, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return r.prototype.generateCmap = function() {
    var e, t, n, i, s;
    for (t in i = this.font.cmap.tables[0].codeMap, e = {}, s = this.subset) n = s[t], e[t] = i[n];
    return e;
  }, r.prototype.glyphsFor = function(e) {
    var t, n, i, s, l, o, d;
    for (i = {}, l = 0, o = e.length; l < o; l++) i[s = e[l]] = this.font.glyf.glyphFor(s);
    for (s in t = [], i) (n = i[s]) != null && n.compound && t.push.apply(t, n.glyphIDs);
    if (t.length > 0) for (s in d = this.glyphsFor(t)) n = d[s], i[s] = n;
    return i;
  }, r.prototype.encode = function(e, t) {
    var n, i, s, l, o, d, m, b, T, M, E, D, U, q, G;
    for (i in n = yM.encode(this.generateCmap(), "unicode"), l = this.glyphsFor(e), E = { 0: 0 }, G = n.charMap) E[(d = G[i]).old] = d.new;
    for (D in M = n.maxGlyphID, l) D in E || (E[D] = M++);
    return b = function(Y) {
      var he, X;
      for (he in X = {}, Y) X[Y[he]] = he;
      return X;
    }(E), T = Object.keys(b).sort(function(Y, he) {
      return Y - he;
    }), U = function() {
      var Y, he, X;
      for (X = [], Y = 0, he = T.length; Y < he; Y++) o = T[Y], X.push(b[o]);
      return X;
    }(), s = this.font.glyf.encode(l, U, E), m = this.font.loca.encode(s.offsets, U), q = { cmap: this.font.cmap.raw(), glyf: s.table, loca: m, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(t) }, this.font.os2.exists && (q["OS/2"] = this.font.os2.raw()), this.font.directory.encode(q);
  }, r;
}();
Jr.API.PDFObject = function() {
  var r;
  function e() {
  }
  return r = function(t, n) {
    return (Array(n + 1).join("0") + t).slice(-n);
  }, e.convert = function(t) {
    var n, i, s, l;
    if (Array.isArray(t)) return "[" + function() {
      var o, d, m;
      for (m = [], o = 0, d = t.length; o < d; o++) n = t[o], m.push(e.convert(n));
      return m;
    }().join(" ") + "]";
    if (typeof t == "string") return "/" + t;
    if (t != null && t.isString) return "(" + t + ")";
    if (t instanceof Date) return "(D:" + r(t.getUTCFullYear(), 4) + r(t.getUTCMonth(), 2) + r(t.getUTCDate(), 2) + r(t.getUTCHours(), 2) + r(t.getUTCMinutes(), 2) + r(t.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(t) === "[object Object]") {
      for (i in s = ["<<"], t) l = t[i], s.push("/" + i + " " + e.convert(l));
      return s.push(">>"), s.join(`
`);
    }
    return "" + t;
  }, e;
}();
const nx = { "circle-radius": 8, "circle-color": "red", "circle-stroke-width": 1, "circle-stroke-color": "black" }, K_ = { style: { textSize: 16, textHaloColor: "#FFFFFF", textHaloWidth: 0.8, textColor: "#000000", fallbackTextFont: ["Open Sans Regular"] }, visibility: "visible", position: "bottom-right" }, J_ = { image: '<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="none" stroke="white" stroke-width="1.5"/><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="#000000" fill-rule="evenodd"></path></svg>', imageName: "gl-export-north-icon", imageSizeFraction: 0.05, visibility: "visible", position: "top-right" };
class KX {
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. default is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ff.A4, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Ou.PNG, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Wd.mm, l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "map", o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : "maplibregl-marker", d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : nx, m = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : "maplibregl-ctrl-attrib-inner", b = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : K_, T = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : J_;
    jn(this, "map"), jn(this, "width"), jn(this, "height"), jn(this, "dpi"), jn(this, "format"), jn(this, "unit"), jn(this, "fileName"), jn(this, "markerClassName"), jn(this, "markerCirclePaint"), jn(this, "attributionClassName"), jn(this, "attributionOptions"), jn(this, "northIconOptions"), this.map = e, this.width = t[0], this.height = t[1], this.dpi = n, this.format = i, this.unit = s, this.fileName = l, this.markerClassName = o, this.markerCirclePaint = d, this.attributionClassName = m, this.attributionOptions = b, this.northIconOptions = T;
  }
  renderMapPost(e) {
    return e;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(e) {
    const t = this.getMarkers();
    for (let n = 0; n < t.length; n++) {
      const i = t.item(n);
      if (!i) continue;
      const s = i.getAttribute("style");
      if (!s) continue;
      const l = /translate\(([^,]+)px,\s*([^,]+)px\)/, o = s.match(l);
      if (!o) continue;
      const d = parseInt(o[1]), m = parseInt(o[2]), b = this.map.unproject([d, m]), T = `point${n}`;
      e.addSource(T, { type: "geojson", data: { type: "Point", coordinates: [b.lng, b.lat] } }), e.addLayer({ id: T, source: T, type: "circle", paint: this.markerCirclePaint });
    }
    return e;
  }
  /**
  * Generate and download Map image
  */
  generate() {
    const e = this;
    this.addLoader(), this.showLoader();
    const t = window.devicePixelRatio;
    Object.defineProperty(window, "devicePixelRatio", { get() {
      return e.dpi / 96;
    } });
    const n = document.createElement("div");
    n.className = "hidden-map", document.body.appendChild(n);
    const i = document.createElement("div");
    i.style.width = this.toPixels(this.width), i.style.height = this.toPixels(this.height), n.appendChild(i);
    const s = this.map.getStyle();
    if (s && s.sources) {
      const o = s.sources;
      Object.keys(o).forEach((d) => {
        const m = o[d];
        Object.keys(m).forEach((b) => {
          m[b] || delete m[b];
        });
      });
    }
    let l = this.getRenderedMap(i, s);
    l.on("load", () => {
      this.addNorthIconToMap(l).then(() => {
        l.once("idle", () => {
          this.addAttributions(l) ? l.once("idle", () => {
            l = this.renderMapPost(l), this.getMarkers().length === 0 ? this.exportImage(l, n, t) : (l = this.renderMarkers(l), l.once("idle", () => {
              this.exportImage(l, n, t);
            }));
          }) : (l = this.renderMapPost(l), this.getMarkers().length === 0 ? this.exportImage(l, n, t) : (l = this.renderMarkers(l), l.once("idle", () => {
            this.exportImage(l, n, t);
          })));
        });
      });
    });
  }
  stripHtml(e) {
    const t = document.createElement("div");
    return t.innerHTML = e, t.textContent || t.innerText || "";
  }
  /**
  * Get icon width against exported map size by using fraction rate
  * @param renderMap Map object
  * @param fraction adjust icon size by using this fraction rate. Default is 8%
  * @returns Icon width calculated
  */
  getIconWidth(e, t) {
    const n = e.getContainer(), i = parseInt(n.style.width.replace("px", ""));
    return parseInt(`${i * t}`);
  }
  /**
  * Get element position's pixel values based on selected position setting
  * @param renderMap Map object
  * @param position Position of element inserted
  * @param offset Offset value to adjust position
  * @returns Pixels [width, height]
  */
  getElementPosition(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const i = e.getContainer();
    let s = 0, l = 0;
    switch (t) {
      case "top-left":
        s = 0 + n, l = 0 + n;
        break;
      case "top-right":
        s = parseInt(i.style.width.replace("px", "")) - n, l = 0 + n;
        break;
      case "bottom-left":
        s = 0 + n, l = parseInt(i.style.height.replace("px", "")) - n;
        break;
      case "bottom-right":
        s = parseInt(i.style.width.replace("px", "")) - n, l = parseInt(i.style.height.replace("px", "")) - n;
        break;
    }
    return [s, l];
  }
  /**
  * Add North Icon SVG to map object
  * @param renderMap Map object
  * @returns void
  */
  addNorthIconImage(e) {
    const t = this.getIconWidth(e, this.northIconOptions.imageSizeFraction ?? 0.08);
    return new Promise((n) => {
      const i = new Image(t, t);
      i.onload = () => {
        this.northIconOptions.imageName && e.addImage(this.northIconOptions.imageName, i), n();
      };
      function s(l) {
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(l);
      }
      this.northIconOptions.image && (i.src = s(this.northIconOptions.image));
    });
  }
  /**
  * Add North Icon Symbol layer to renderMap object
  * @param renderMap Map object
  * @returns
  */
  addNorthIconToMap(e) {
    let t = this.northIconOptions.visibility ?? "visible";
    return e.getZoom() < 2 && this.width > this.height && (t = "none"), new Promise((n) => {
      this.addNorthIconImage(e).then(() => {
        const i = this.getIconWidth(e, this.northIconOptions.imageSizeFraction ?? 0.08) * 0.8, s = this.getElementPosition(e, this.northIconOptions.position ?? "top-right", i), l = e.unproject(s), o = this.northIconOptions.imageName ?? "gl-export-north-icon";
        e.addSource(o, { type: "geojson", data: { type: "Feature", geometry: { type: "Point", coordinates: [l.lng, l.lat] }, properties: {} } }), e.addLayer({ id: o, source: o, type: "symbol", layout: { "icon-image": o, "icon-size": 1, "icon-rotate": e.getBearing() * -1, "icon-allow-overlap": !0, "icon-ignore-placement": !0, visibility: t }, paint: {} }), n();
      });
    });
  }
  addAttributions(e) {
    var t;
    if (!this.map.getStyle().glyphs) return !1;
    const n = e.getContainer(), i = this.attributionOptions.position ?? "bottom-right", s = this.getElementPosition(e, i, 5), l = s[0], o = e.unproject(s), d = n.getElementsByClassName(this.attributionClassName), m = [];
    if ((d == null ? void 0 : d.length) > 0) {
      const q = d.item(0);
      if (q) for (let G = 0; G < q.children.length; G++) {
        const Y = q.children.item(G);
        Y && m.push(this.stripHtml(Y.outerHTML));
      }
    } else {
      const q = this.map.getStyle().sources;
      Object.keys(q).forEach((G) => {
        const Y = q[G];
        if ("attribution" in Y) {
          const he = Y.attribution;
          m.push(this.stripHtml(he));
        }
      });
    }
    if (m.length === 0) return !1;
    const b = m.join(" | "), T = "attribution";
    e.addSource(T, { type: "geojson", data: { type: "Feature", geometry: { type: "Point", coordinates: [o.lng, o.lat] }, properties: { attribution: b } } });
    const M = this.map.getStyle().layers.filter((q) => q.type === "symbol" && q.layout && "text-font" in q.layout), E = M.length > 0 && M[0].layout ? M[0].layout["text-font"] : (t = this.attributionOptions.style) == null ? void 0 : t.fallbackTextFont;
    let D = this.attributionOptions.visibility ?? "visible";
    e.getZoom() < 2 && this.width > this.height && (D = "none");
    const U = this.attributionOptions.style;
    return e.addLayer({ id: T, source: T, type: "symbol", layout: { "text-field": ["get", "attribution"], "text-font": E, "text-max-width": parseInt(`${l / U.textSize}`), "text-anchor": i, "text-justify": ["top-right", "bottom-right"].includes(i) ? "right" : "left", "text-size": U.textSize, "text-allow-overlap": !0, visibility: D }, paint: { "text-halo-color": U.textHaloColor, "text-halo-width": U.textHaloWidth, "text-color": U.textColor } }), !0;
  }
  exportImage(e, t, n) {
    var i;
    const s = e.getCanvas(), l = `${this.fileName}.${this.format}`;
    switch (this.format) {
      case Ou.PNG:
        this.toPNG(s, l);
        break;
      case Ou.JPEG:
        this.toJPEG(s, l);
        break;
      case Ou.PDF:
        this.toPDF(e, l);
        break;
      case Ou.SVG:
        this.toSVG(s, l);
        break;
      default:
        console.error(`Invalid file format: ${this.format}`);
        break;
    }
    e.remove(), (i = t.parentNode) == null || i.removeChild(t), Object.defineProperty(window, "devicePixelRatio", { get() {
      return n;
    } }), t.remove(), this.hideLoader();
  }
  /**
  * Convert canvas to PNG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toPNG(e, t) {
    const n = document.createElement("a");
    n.href = e.toDataURL(), n.download = t, n.click(), n.remove();
  }
  /**
  * Convert canvas to JPEG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toJPEG(e, t) {
    const n = e.toDataURL("image/jpeg", 0.85), i = document.createElement("a");
    i.href = n, i.download = t, i.click(), i.remove();
  }
  /**
  * Convert Map object to PDF
  * @param map Map object
  * @param fileName file name
  */
  toPDF(e, t) {
    const n = e.getCanvas(), i = new Jr({ orientation: this.width > this.height ? "l" : "p", unit: this.unit, compress: !0, format: [this.width, this.height] });
    i.addImage(n.toDataURL("image/png"), "png", 0, 0, this.width, this.height, void 0, "FAST");
    const { lng: s, lat: l } = e.getCenter();
    i.setProperties({ title: e.getStyle().name, subject: `center: [${s}, ${l}], zoom: ${e.getZoom()}`, creator: "Mapbox GL Export Plugin", author: "(c)Mapbox, (c)OpenStreetMap" }), i.save(t);
  }
  /**
  * Convert canvas to SVG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toSVG(e, t) {
    const n = e.toDataURL("image/png"), i = Number(this.toPixels(this.width, this.dpi).replace("px", "")), s = Number(this.toPixels(this.height, this.dpi).replace("px", "")), l = `
    <svg xmlns="http://www.w3.org/2000/svg" 
      xmlns:xlink="http://www.w3.org/1999/xlink" 
      version="1.1" 
      width="${i}" 
      height="${s}" 
      viewBox="0 0 ${i} ${s}" 
      xml:space="preserve">
        <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
      xlink:href="${n}" width="${i}" height="${s}"></image>
    </svg>`, o = document.createElement("a");
    o.href = `data:application/xml,${encodeURIComponent(l)}`, o.download = t, o.click(), o.remove();
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 96;
    return this.unit === Wd.mm && (t /= 25.4), `${t * e}px`;
  }
  /**
  * Add loader in the parent element of maplibre map.
  */
  addLoader() {
    var e;
    const t = (e = this.map.getCanvas().parentElement) == null ? void 0 : e.parentElement;
    if (!t || t.getElementsByClassName("map-export-loader").length > 0) return;
    const n = document.createElement("span");
    n.classList.add("map-export-loader"), n.classList.add("loader-default"), t.appendChild(n);
  }
  /**
  * Show loader
  */
  showLoader() {
    var e, t;
    const n = (e = this.map.getCanvas().parentElement) == null ? void 0 : e.parentElement;
    if (!n) return;
    const i = n.getElementsByClassName("map-export-loader");
    i && i.length > 0 && ((t = i.item(0)) == null || t.classList.add("is-active"));
  }
  /**
  * Hide loader
  */
  hideLoader() {
    var e, t;
    const n = (e = this.map.getCanvas().parentElement) == null ? void 0 : e.parentElement;
    if (!n) return;
    const i = n.getElementsByClassName("map-export-loader");
    i && i.length > 0 && ((t = i.item(0)) == null || t.classList.remove("is-active"));
  }
}
class JX extends KX {
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. default is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ff.A4, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300, i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Ou.PNG, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : Wd.mm, l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "map", o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : nx, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : K_, m = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : J_;
    super(e, t, n, i, s, l, "maplibregl-marker", o, "maplibregl-ctrl-attrib-inner", d, m);
  }
  getRenderedMap(e, t) {
    const n = new oE.Map({
      container: e,
      style: t,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      canvasContextAttributes: { preserveDrawingBuffer: !0 },
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transform request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (n.setMaxPitch(85), n.setPitch(this.map.getPitch()));
    const i = (this.map.style.imageManager || {}).images || [];
    return Object.keys(i).forEach((s) => {
      i[s].data && n.addImage(s, i[s].data);
    }), n;
  }
  renderMapPost(e) {
    const t = this.map.getTerrain();
    return t && e.setTerrain({ source: t.source, exaggeration: t.exaggeration }), e;
  }
}
class QX {
  constructor(e) {
    jn(this, "controlContainer"), jn(this, "exportContainer"), jn(this, "crosshair"), jn(this, "printableArea"), jn(this, "map"), jn(this, "exportButton"), jn(this, "options", { PageSize: ff.A4, PageOrientation: Kp.Landscape, Format: Ou.PDF, DPI: yv[300], Crosshair: !1, PrintableArea: !1, Local: "en", AllowedSizes: Object.keys(ff), Filename: "map", markerCirclePaint: nx, attributionOptions: K_, northIconOptions: J_ }), jn(this, "MAPLIB_CSS_PREFIX", "maplibregl"), e && (e.attributionOptions = Object.assign(K_, e.attributionOptions), e.northIconOptions = Object.assign(J_, e.northIconOptions), this.options = Object.assign(this.options, e)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const e = this.options.Local ?? "en";
    return QW(e);
  }
  onAdd(e) {
    var t;
    this.map = e, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const n = document.createElement("TABLE");
    n.className = "print-table";
    const i = {};
    (t = this.options.AllowedSizes) == null || t.forEach((b) => {
      ff[b] && (i[b] = ff[b]);
    });
    const s = this.createSelection(i, this.getTranslation().PageSize, "page-size", this.options.PageSize, (b, T) => JSON.stringify(b[T]));
    n.appendChild(s);
    const l = this.createSelection(Kp, this.getTranslation().PageOrientation, "page-orientation", this.options.PageOrientation, (b, T) => b[T]);
    n.appendChild(l);
    const o = this.createSelection(Ou, this.getTranslation().Format, "format-type", this.options.Format, (b, T) => b[T]);
    n.appendChild(o);
    const d = this.createSelection(yv, this.getTranslation().DPI, "dpi-type", this.options.DPI, (b, T) => b[T]);
    n.appendChild(d), this.exportContainer.appendChild(n);
    const m = document.createElement("button");
    return m.type = "button", m.textContent = this.getTranslation().Generate, m.classList.add("generate-button"), m.addEventListener("click", () => {
      const b = document.getElementById("mapbox-gl-export-page-size"), T = document.getElementById("mapbox-gl-export-page-orientation"), M = document.getElementById("mapbox-gl-export-format-type"), E = document.getElementById("mapbox-gl-export-dpi-type"), D = T.value;
      let U = JSON.parse(b.value);
      D === Kp.Portrait && (U = U.reverse()), this.generateMap(e, U, Number(E.value), M.value, Wd.mm, this.options.Filename);
    }), this.exportContainer.appendChild(m), this.controlContainer;
  }
  generateMap(e, t, n, i, s, l) {
    new JX(e, t, n, i, s, l, this.options.markerCirclePaint, this.options.attributionOptions, this.options.northIconOptions).generate();
  }
  createSelection(e, t, n, i, s) {
    const l = document.createElement("label");
    l.textContent = t;
    const o = document.createElement("select");
    o.setAttribute("id", `mapbox-gl-export-${n}`), o.style.width = "100%", Object.keys(e).forEach((T) => {
      const M = document.createElement("option");
      M.setAttribute("value", s(e, T)), M.appendChild(document.createTextNode(T)), M.setAttribute("name", n), i === e[T] && (M.selected = !0), o.appendChild(M);
    }), o.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const d = document.createElement("TR"), m = document.createElement("TD"), b = document.createElement("TD");
    return m.appendChild(l), b.appendChild(o), d.appendChild(m), d.appendChild(b), d;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(e) {
    this.controlContainer && !this.controlContainer.contains(e.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(e) {
    this.options.Crosshair === !0 && (e === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new FW(this.map), this.crosshair.create()));
  }
  togglePrintableArea(e) {
    this.options.PrintableArea === !0 && (e === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new UW(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0) return;
    const e = document.getElementById("mapbox-gl-export-page-size"), t = document.getElementById("mapbox-gl-export-page-orientation").value;
    let n = JSON.parse(e.value);
    t === Kp.Portrait && (n = n.reverse()), this.printableArea.updateArea(n[0], n[1]);
  }
}
function Zb(r, e, t, n) {
  function i(s) {
    return s instanceof t ? s : new t(function(l) {
      l(s);
    });
  }
  return new (t || (t = Promise))(function(s, l) {
    function o(b) {
      try {
        m(n.next(b));
      } catch (T) {
        l(T);
      }
    }
    function d(b) {
      try {
        m(n.throw(b));
      } catch (T) {
        l(T);
      }
    }
    function m(b) {
      b.done ? s(b.value) : i(b.value).then(o, d);
    }
    m((n = n.apply(r, e || [])).next());
  });
}
var zm = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Oy(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Yb, RS;
function vM() {
  if (RS) return Yb;
  RS = 1, Yb = e;
  var r = Object.prototype.hasOwnProperty;
  function e() {
    for (var t = {}, n = 0; n < arguments.length; n++) {
      var i = arguments[n];
      for (var s in i)
        r.call(i, s) && (t[s] = i[s]);
    }
    return t;
  }
  return Yb;
}
var Kb = {
  exports: {}
}, BS;
function eZ() {
  return BS || (BS = 1, function(r, e) {
    (function() {
      var t = {};
      r.exports = t, t.simpleFilter = function(n, i) {
        return i.filter(function(s) {
          return t.test(n, s);
        });
      }, t.test = function(n, i) {
        return t.match(n, i) !== null;
      }, t.match = function(n, i, s) {
        s = s || {};
        var l = 0, o = [], d = i.length, m = 0, b = 0, T = s.pre || "", M = s.post || "", E = s.caseSensitive && i || i.toLowerCase(), D;
        n = s.caseSensitive && n || n.toLowerCase();
        for (var U = 0; U < d; U++)
          D = i[U], E[U] === n[l] ? (D = T + D + M, l += 1, b += 1 + b) : b = 0, m += b, o[o.length] = D;
        return l === n.length ? (m = E === n ? 1 / 0 : m, {
          rendered: o.join(""),
          score: m
        }) : null;
      }, t.filter = function(n, i, s) {
        return !i || i.length === 0 ? [] : typeof n != "string" ? i : (s = s || {}, i.reduce(function(l, o, d, m) {
          var b = o;
          s.extract && (b = s.extract(o));
          var T = t.match(n, b, s);
          return T != null && (l[l.length] = {
            string: T.rendered,
            score: T.score,
            index: d,
            original: o
          }), l;
        }, []).sort(function(l, o) {
          var d = o.score - l.score;
          return d || l.index - o.index;
        }));
      };
    })();
  }(Kb)), Kb.exports;
}
var Jb, LS;
function tZ() {
  if (LS) return Jb;
  LS = 1;
  var r = function(e) {
    return this.component = e, this.items = [], this.active = e.options.noInitialSelection ? -1 : 0, this.wrapper = document.createElement("div"), this.wrapper.className = "suggestions-wrapper", this.element = document.createElement("ul"), this.element.className = "suggestions", this.wrapper.appendChild(this.element), this.selectingListItem = !1, e.el.parentNode.insertBefore(this.wrapper, e.el.nextSibling), this;
  };
  return r.prototype.show = function() {
    this.element.style.display = "block";
  }, r.prototype.hide = function() {
    this.element.style.display = "none";
  }, r.prototype.add = function(e) {
    this.items.push(e);
  }, r.prototype.clear = function() {
    this.items = [], this.active = this.component.options.noInitialSelection ? -1 : 0;
  }, r.prototype.isEmpty = function() {
    return !this.items.length;
  }, r.prototype.isVisible = function() {
    return this.element.style.display === "block";
  }, r.prototype.draw = function() {
    if (this.element.innerHTML = "", this.items.length === 0) {
      this.hide();
      return;
    }
    for (var e = 0; e < this.items.length; e++)
      this.drawItem(this.items[e], this.active === e);
    this.show();
  }, r.prototype.drawItem = function(e, t) {
    var n = document.createElement("li"), i = document.createElement("a");
    t && (n.className += " active"), i.innerHTML = e.string, n.appendChild(i), this.element.appendChild(n), n.addEventListener("mousedown", (function() {
      this.selectingListItem = !0;
    }).bind(this)), n.addEventListener("mouseup", (function() {
      this.handleMouseUp.call(this, e);
    }).bind(this));
  }, r.prototype.handleMouseUp = function(e) {
    this.selectingListItem = !1, this.component.value(e.original), this.clear(), this.draw();
  }, r.prototype.move = function(e) {
    this.active = e, this.draw();
  }, r.prototype.previous = function() {
    this.move(this.active <= 0 ? this.items.length - 1 : this.active - 1);
  }, r.prototype.next = function() {
    this.move(this.active >= this.items.length - 1 ? 0 : this.active + 1);
  }, r.prototype.drawError = function(e) {
    var t = document.createElement("li");
    t.innerHTML = e, this.element.appendChild(t), this.show();
  }, Jb = r, Jb;
}
var Qb, OS;
function rZ() {
  if (OS) return Qb;
  OS = 1;
  var r = vM(), e = eZ(), t = tZ(), n = function(i, s, l) {
    return l = l || {}, this.options = r({
      minLength: 2,
      limit: 5,
      filter: !0,
      hideOnBlur: !0,
      noInitialSelection: !0
    }, l), this.el = i, this.data = s || [], this.list = new t(this), this.query = "", this.selected = null, this.list.draw(), this.el.addEventListener("keyup", (function(o) {
      this.handleKeyUp(o.keyCode, o);
    }).bind(this), !1), this.el.addEventListener("keydown", (function(o) {
      this.handleKeyDown(o);
    }).bind(this)), this.el.addEventListener("focus", (function() {
      this.handleFocus();
    }).bind(this)), this.el.addEventListener("blur", (function() {
      this.handleBlur();
    }).bind(this)), this.el.addEventListener("paste", (function(o) {
      this.handlePaste(o);
    }).bind(this)), this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this), this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this), this;
  };
  return n.prototype.handleKeyUp = function(i, s) {
    if (!(i === 40 || i === 38 || i === 27 || i === 9)) {
      if (i === 13) {
        this.list.items[this.list.active] && (this.list.handleMouseUp(this.list.items[this.list.active]), s.stopPropagation());
        return;
      }
      this.handleInputChange(this.el.value);
    }
  }, n.prototype.handleKeyDown = function(i) {
    switch (i.keyCode) {
      case 13:
        this.list.active >= 0 && (this.list.selectingListItem = !0);
        break;
      case 9:
        this.list.isEmpty() || (this.list.isVisible() && i.preventDefault(), this.value(this.list.active >= 0 ? this.list.items[this.list.active].original : null), this.list.hide());
        break;
      case 27:
        this.list.isEmpty() || this.list.hide();
        break;
      case 38:
        this.list.previous();
        break;
      case 40:
        this.list.next();
        break;
    }
  }, n.prototype.handleBlur = function() {
    !this.list.selectingListItem && this.options.hideOnBlur && this.list.hide();
  }, n.prototype.handlePaste = function(i) {
    if (i.clipboardData)
      this.handleInputChange(i.clipboardData.getData("Text"));
    else {
      var s = this;
      setTimeout(function() {
        s.handleInputChange(i.target.value);
      }, 100);
    }
  }, n.prototype.handleInputChange = function(i) {
    if (this.query = this.normalize(i), this.list.clear(), this.query.length < this.options.minLength) {
      this.list.draw();
      return;
    }
    this.getCandidates((function(s) {
      for (var l = 0; l < s.length && (this.list.add(s[l]), l !== this.options.limit - 1); l++)
        ;
      this.list.draw();
    }).bind(this));
  }, n.prototype.handleFocus = function() {
    this.list.isEmpty() || this.list.show(), this.list.selectingListItem = !1;
  }, n.prototype.update = function(i) {
    this.data = i, this.handleKeyUp();
  }, n.prototype.clear = function() {
    this.data = [], this.list.clear();
  }, n.prototype.normalize = function(i) {
    return i = i.toLowerCase(), i;
  }, n.prototype.match = function(i, s) {
    return i.indexOf(s) > -1;
  }, n.prototype.value = function(i) {
    if (this.selected = i, this.el.value = this.getItemValue(i || {
      place_name: this.query
    }), document.createEvent) {
      var s = document.createEvent("HTMLEvents");
      s.initEvent("change", !0, !1), this.el.dispatchEvent(s);
    } else
      this.el.fireEvent("onchange");
  }, n.prototype.getCandidates = function(i) {
    var s = {
      pre: "<strong>",
      post: "</strong>",
      extract: (function(o) {
        return this.getItemValue(o);
      }).bind(this)
    }, l;
    this.options.filter ? (l = e.filter(this.query, this.data, s), l = l.map((function(o) {
      return {
        original: o.original,
        string: this.render(o.original, o.string)
      };
    }).bind(this))) : l = this.data.map((function(o) {
      var d = this.render(o);
      return {
        original: o,
        string: d
      };
    }).bind(this)), i(l);
  }, n.prototype.getItemValue = function(i) {
    return i;
  }, n.prototype.render = function(i, s) {
    if (s)
      return s;
    for (var l = i.original ? this.getItemValue(i.original) : this.getItemValue(i), o = this.normalize(l), d = o.lastIndexOf(this.query); d > -1; ) {
      var m = d + this.query.length;
      l = l.slice(0, d) + "<strong>" + l.slice(d, m) + "</strong>" + l.slice(m), d = o.slice(0, d).lastIndexOf(this.query);
    }
    return l;
  }, n.prototype.renderError = function(i) {
    this.list.drawError(i);
  }, Qb = n, Qb;
}
var e1, NS;
function nZ() {
  if (NS) return e1;
  NS = 1;
  var r = rZ();
  return e1 = r, typeof window < "u" && (window.Suggestions = r), e1;
}
var iZ = nZ(), sZ = /* @__PURE__ */ Oy(iZ), a_ = {
  exports: {}
}, oZ = a_.exports, DS;
function aZ() {
  return DS || (DS = 1, function(r) {
    (function(e, t, n) {
      r.exports ? r.exports = n() : e[t] = n();
    })(oZ, "subtag", function() {
      var e = "", t = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
      function n(d) {
        return d.match(t) || [];
      }
      function i(d) {
        return n(d).filter(function(m, b) {
          return m && b;
        });
      }
      function s(d) {
        return d = n(d), {
          language: d[1] || e,
          extlang: d[2] || e,
          script: d[3] || e,
          region: d[4] || e
        };
      }
      function l(d, m, b) {
        Object.defineProperty(d, m, {
          value: b,
          enumerable: !0
        });
      }
      function o(d, m, b) {
        function T(M) {
          return n(M)[d] || e;
        }
        l(T, "pattern", m), l(s, b, T);
      }
      return o(1, /^[a-zA-Z]{2,3}$/, "language"), o(2, /^[a-zA-Z]{3}$/, "extlang"), o(3, /^[a-zA-Z]{4}$/, "script"), o(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region"), l(s, "split", i), s;
    });
  }(a_)), a_.exports;
}
var lZ = aZ(), cZ = /* @__PURE__ */ Oy(lZ), t1, kS;
function uZ() {
  if (kS) return t1;
  kS = 1;
  var r = "Expected a function", e = NaN, t = "[object Symbol]", n = /^\s+|\s+$/g, i = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, l = /^0o[0-7]+$/i, o = parseInt, d = typeof zm == "object" && zm && zm.Object === Object && zm, m = typeof self == "object" && self && self.Object === Object && self, b = d || m || Function("return this")(), T = Object.prototype, M = T.toString, E = Math.max, D = Math.min, U = function() {
    return b.Date.now();
  };
  function q(J, ie, ye) {
    var oe, Re, Ne, me, _e, Fe, Me = 0, Ct = !1, ht = !1, Pt = !0;
    if (typeof J != "function")
      throw new TypeError(r);
    ie = X(ie) || 0, G(ye) && (Ct = !!ye.leading, ht = "maxWait" in ye, Ne = ht ? E(X(ye.maxWait) || 0, ie) : Ne, Pt = "trailing" in ye ? !!ye.trailing : Pt);
    function bt(ft) {
      var St = oe, wt = Re;
      return oe = Re = void 0, Me = ft, me = J.apply(wt, St), me;
    }
    function kt(ft) {
      return Me = ft, _e = setTimeout(ce, ie), Ct ? bt(ft) : me;
    }
    function Nt(ft) {
      var St = ft - Fe, wt = ft - Me, ar = ie - St;
      return ht ? D(ar, Ne - wt) : ar;
    }
    function mr(ft) {
      var St = ft - Fe, wt = ft - Me;
      return Fe === void 0 || St >= ie || St < 0 || ht && wt >= Ne;
    }
    function ce() {
      var ft = U();
      if (mr(ft))
        return Be(ft);
      _e = setTimeout(ce, Nt(ft));
    }
    function Be(ft) {
      return _e = void 0, Pt && oe ? bt(ft) : (oe = Re = void 0, me);
    }
    function Ue() {
      _e !== void 0 && clearTimeout(_e), Me = 0, oe = Fe = Re = _e = void 0;
    }
    function Xe() {
      return _e === void 0 ? me : Be(U());
    }
    function it() {
      var ft = U(), St = mr(ft);
      if (oe = arguments, Re = this, Fe = ft, St) {
        if (_e === void 0)
          return kt(Fe);
        if (ht)
          return _e = setTimeout(ce, ie), bt(Fe);
      }
      return _e === void 0 && (_e = setTimeout(ce, ie)), me;
    }
    return it.cancel = Ue, it.flush = Xe, it;
  }
  function G(J) {
    var ie = typeof J;
    return !!J && (ie == "object" || ie == "function");
  }
  function Y(J) {
    return !!J && typeof J == "object";
  }
  function he(J) {
    return typeof J == "symbol" || Y(J) && M.call(J) == t;
  }
  function X(J) {
    if (typeof J == "number")
      return J;
    if (he(J))
      return e;
    if (G(J)) {
      var ie = typeof J.valueOf == "function" ? J.valueOf() : J;
      J = G(ie) ? ie + "" : ie;
    }
    if (typeof J != "string")
      return J === 0 ? J : +J;
    J = J.replace(n, "");
    var ye = s.test(J);
    return ye || l.test(J) ? o(J.slice(2), ye ? 2 : 8) : i.test(J) ? e : +J;
  }
  return t1 = q, t1;
}
var hZ = uZ(), fZ = /* @__PURE__ */ Oy(hZ), dZ = vM(), dc = /* @__PURE__ */ Oy(dZ), jm = {
  exports: {}
}, FS;
function pZ() {
  if (FS) return jm.exports;
  FS = 1;
  var r = typeof Reflect == "object" ? Reflect : null, e = r && typeof r.apply == "function" ? r.apply : function(J, ie, ye) {
    return Function.prototype.apply.call(J, ie, ye);
  }, t;
  r && typeof r.ownKeys == "function" ? t = r.ownKeys : Object.getOwnPropertySymbols ? t = function(J) {
    return Object.getOwnPropertyNames(J).concat(Object.getOwnPropertySymbols(J));
  } : t = function(J) {
    return Object.getOwnPropertyNames(J);
  };
  function n(X) {
    console && console.warn && console.warn(X);
  }
  var i = Number.isNaN || function(J) {
    return J !== J;
  };
  function s() {
    s.init.call(this);
  }
  jm.exports = s, jm.exports.once = G, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
  var l = 10;
  function o(X) {
    if (typeof X != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof X);
  }
  Object.defineProperty(s, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return l;
    },
    set: function(X) {
      if (typeof X != "number" || X < 0 || i(X))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + X + ".");
      l = X;
    }
  }), s.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, s.prototype.setMaxListeners = function(J) {
    if (typeof J != "number" || J < 0 || i(J))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + J + ".");
    return this._maxListeners = J, this;
  };
  function d(X) {
    return X._maxListeners === void 0 ? s.defaultMaxListeners : X._maxListeners;
  }
  s.prototype.getMaxListeners = function() {
    return d(this);
  }, s.prototype.emit = function(J) {
    for (var ie = [], ye = 1; ye < arguments.length; ye++) ie.push(arguments[ye]);
    var oe = J === "error", Re = this._events;
    if (Re !== void 0) oe = oe && Re.error === void 0;
    else if (!oe) return !1;
    if (oe) {
      var Ne;
      if (ie.length > 0 && (Ne = ie[0]), Ne instanceof Error)
        throw Ne;
      var me = new Error("Unhandled error." + (Ne ? " (" + Ne.message + ")" : ""));
      throw me.context = Ne, me;
    }
    var _e = Re[J];
    if (_e === void 0) return !1;
    if (typeof _e == "function")
      e(_e, this, ie);
    else
      for (var Fe = _e.length, Me = D(_e, Fe), ye = 0; ye < Fe; ++ye) e(Me[ye], this, ie);
    return !0;
  };
  function m(X, J, ie, ye) {
    var oe, Re, Ne;
    if (o(ie), Re = X._events, Re === void 0 ? (Re = X._events = /* @__PURE__ */ Object.create(null), X._eventsCount = 0) : (Re.newListener !== void 0 && (X.emit("newListener", J, ie.listener ? ie.listener : ie), Re = X._events), Ne = Re[J]), Ne === void 0)
      Ne = Re[J] = ie, ++X._eventsCount;
    else if (typeof Ne == "function" ? Ne = Re[J] = ye ? [ie, Ne] : [Ne, ie] : ye ? Ne.unshift(ie) : Ne.push(ie), oe = d(X), oe > 0 && Ne.length > oe && !Ne.warned) {
      Ne.warned = !0;
      var me = new Error("Possible EventEmitter memory leak detected. " + Ne.length + " " + String(J) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      me.name = "MaxListenersExceededWarning", me.emitter = X, me.type = J, me.count = Ne.length, n(me);
    }
    return X;
  }
  s.prototype.addListener = function(J, ie) {
    return m(this, J, ie, !1);
  }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(J, ie) {
    return m(this, J, ie, !0);
  };
  function b() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function T(X, J, ie) {
    var ye = {
      fired: !1,
      wrapFn: void 0,
      target: X,
      type: J,
      listener: ie
    }, oe = b.bind(ye);
    return oe.listener = ie, ye.wrapFn = oe, oe;
  }
  s.prototype.once = function(J, ie) {
    return o(ie), this.on(J, T(this, J, ie)), this;
  }, s.prototype.prependOnceListener = function(J, ie) {
    return o(ie), this.prependListener(J, T(this, J, ie)), this;
  }, s.prototype.removeListener = function(J, ie) {
    var ye, oe, Re, Ne, me;
    if (o(ie), oe = this._events, oe === void 0) return this;
    if (ye = oe[J], ye === void 0) return this;
    if (ye === ie || ye.listener === ie)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete oe[J], oe.removeListener && this.emit("removeListener", J, ye.listener || ie));
    else if (typeof ye != "function") {
      for (Re = -1, Ne = ye.length - 1; Ne >= 0; Ne--)
        if (ye[Ne] === ie || ye[Ne].listener === ie) {
          me = ye[Ne].listener, Re = Ne;
          break;
        }
      if (Re < 0) return this;
      Re === 0 ? ye.shift() : U(ye, Re), ye.length === 1 && (oe[J] = ye[0]), oe.removeListener !== void 0 && this.emit("removeListener", J, me || ie);
    }
    return this;
  }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(J) {
    var ie, ye, oe;
    if (ye = this._events, ye === void 0) return this;
    if (ye.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : ye[J] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete ye[J]), this;
    if (arguments.length === 0) {
      var Re = Object.keys(ye), Ne;
      for (oe = 0; oe < Re.length; ++oe)
        Ne = Re[oe], Ne !== "removeListener" && this.removeAllListeners(Ne);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (ie = ye[J], typeof ie == "function")
      this.removeListener(J, ie);
    else if (ie !== void 0)
      for (oe = ie.length - 1; oe >= 0; oe--)
        this.removeListener(J, ie[oe]);
    return this;
  };
  function M(X, J, ie) {
    var ye = X._events;
    if (ye === void 0) return [];
    var oe = ye[J];
    return oe === void 0 ? [] : typeof oe == "function" ? ie ? [oe.listener || oe] : [oe] : ie ? q(oe) : D(oe, oe.length);
  }
  s.prototype.listeners = function(J) {
    return M(this, J, !0);
  }, s.prototype.rawListeners = function(J) {
    return M(this, J, !1);
  }, s.listenerCount = function(X, J) {
    return typeof X.listenerCount == "function" ? X.listenerCount(J) : E.call(X, J);
  }, s.prototype.listenerCount = E;
  function E(X) {
    var J = this._events;
    if (J !== void 0) {
      var ie = J[X];
      if (typeof ie == "function")
        return 1;
      if (ie !== void 0)
        return ie.length;
    }
    return 0;
  }
  s.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function D(X, J) {
    for (var ie = new Array(J), ye = 0; ye < J; ++ye) ie[ye] = X[ye];
    return ie;
  }
  function U(X, J) {
    for (; J + 1 < X.length; J++) X[J] = X[J + 1];
    X.pop();
  }
  function q(X) {
    for (var J = new Array(X.length), ie = 0; ie < J.length; ++ie)
      J[ie] = X[ie].listener || X[ie];
    return J;
  }
  function G(X, J) {
    return new Promise(function(ie, ye) {
      function oe(Ne) {
        X.removeListener(J, Re), ye(Ne);
      }
      function Re() {
        typeof X.removeListener == "function" && X.removeListener("error", oe), ie([].slice.call(arguments));
      }
      he(X, J, Re, {
        once: !0
      }), J !== "error" && Y(X, oe, {
        once: !0
      });
    });
  }
  function Y(X, J, ie) {
    typeof X.on == "function" && he(X, "error", J, ie);
  }
  function he(X, J, ie, ye) {
    if (typeof X.on == "function")
      ye.once ? X.once(J, ie) : X.on(J, ie);
    else if (typeof X.addEventListener == "function")
      X.addEventListener(J, function oe(Re) {
        ye.once && X.removeEventListener(J, oe), ie(Re);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof X);
  }
  return jm.exports;
}
var gZ = pZ();
const US = {
  fr: {
    name: "France",
    bbox: [[-4.59235, 41.380007], [9.560016, 51.148506]]
  },
  us: {
    name: "United States",
    bbox: [[-171.791111, 18.91619], [-66.96466, 71.357764]]
  },
  ru: {
    name: "Russia",
    bbox: [[19.66064, 41.151416], [190.10042, 81.2504]]
  },
  ca: {
    name: "Canada",
    bbox: [[-140.99778, 41.675105], [-52.648099, 83.23324]]
  }
}, mZ = {
  // list drawn from https://docs.mapbox.com/api/search/#language-coverage
  de: "Suche",
  // german
  it: "Ricerca",
  //italian
  en: "Search",
  // english
  nl: "Zoeken",
  //dutch
  fr: "Chercher",
  //french
  ca: "Cerca",
  //catalan
  he: "",
  //hebrew
  ja: "",
  //japanese
  lv: "Meklt",
  //latvian
  pt: "Procurar",
  //portuguese 
  sr: "",
  //serbian
  zh: "",
  //chinese-simplified
  cs: "Vyhledvn",
  //czech
  hu: "Keress",
  //hungarian
  ka: "",
  // georgian
  nb: "Ske",
  //norwegian
  sk: "Vyhadvanie",
  //slovak
  th: "",
  //thai
  fi: "Hae",
  //finnish
  is: "Leita",
  //icelandic
  ko: "",
  //korean
  pl: "Szukaj",
  //polish
  sl: "Iskanje",
  //slovenian
  fa: "",
  //persian(aka farsi)
  ru: ""
  //russian
}, _Z = {
  en: "No results found",
  de: "Keine Ergebnisse gefunden"
}, yZ = {
  en: "There was an error reaching the server",
  de: "Verbindung fehlgeschlagen"
};
var zp = {
  placeholder: mZ,
  errorNoResults: _Z,
  errorConnectionFailed: yZ
};
const bZ = /(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)[ ]*$/;
class vZ {
  constructor(e, t) {
    this.options = {
      zoom: 16,
      flyTo: !0,
      trackProximity: !0,
      showResultsWhileTyping: !1,
      minLength: 2,
      reverseGeocode: !1,
      limit: 5,
      enableEventLogging: !0,
      marker: !0,
      popup: !1,
      maplibregl: void 0,
      collapsed: !1,
      clearAndBlurOnEsc: !1,
      clearOnBlur: !1,
      proximityMinZoom: 9,
      getItemValue: (n) => n.text !== void 0 ? n.text : n.place_name,
      render: function(n) {
        if (!n.geometry) {
          const s = n.text, l = s.toLowerCase().indexOf(this.query.toLowerCase()), o = this.query.length, d = s.substring(0, l), m = s.substring(l, l + o), b = s.substring(l + o);
          return '<div class="maplibregl-ctrl-geocoder--suggestion"><svg class="maplibregl-ctrl-geocoder--suggestion-icon" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M22.8702 20.1258H21.4248L20.9125 19.6318C22.7055 17.546 23.785 14.8382 23.785 11.8925C23.785 5.32419 18.4608 0 11.8925 0C5.32419 0 0 5.32419 0 11.8925C0 18.4608 5.32419 23.785 11.8925 23.785C14.8382 23.785 17.546 22.7055 19.6318 20.9125L20.1258 21.4248V22.8702L29.2739 32L32 29.2739L22.8702 20.1258ZM11.8925 20.1258C7.33676 20.1258 3.65923 16.4483 3.65923 11.8925C3.65923 7.33676 7.33676 3.65923 11.8925 3.65923C16.4483 3.65923 20.1258 7.33676 20.1258 11.8925C20.1258 16.4483 16.4483 20.1258 11.8925 20.1258Z" fill="#687078"/></svg><div class="maplibregl-ctrl-geocoder--suggestion-info"><div class="maplibregl-ctrl-geocoder--suggestion-title">' + d + '<span class="maplibregl-ctrl-geocoder--suggestion-match">' + m + "</span>" + b + "</div></div></div>";
        }
        const i = n.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--result"><svg class="maplibregl-ctrl-geocoder--result-icon" viewBox="0 0 24 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.36571 0 0 5.38676 0 12.0471C0 21.0824 12 32 12 32C12 32 24 21.0824 24 12.0471C24 5.38676 18.6343 0 12 0ZM12 16.3496C9.63428 16.3496 7.71429 14.4221 7.71429 12.0471C7.71429 9.67207 9.63428 7.74454 12 7.74454C14.3657 7.74454 16.2857 9.67207 16.2857 12.0471C16.2857 14.4221 14.3657 16.3496 12 16.3496Z" fill="#687078"/></svg><div><div class="maplibregl-ctrl-geocoder--result-title">' + i[0] + '</div><div class="maplibregl-ctrl-geocoder--result-address">' + i.splice(1, i.length).join(",") + "</div></div></div>";
      },
      popupRender: (n) => {
        const i = n.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--suggestion popup-suggestion"><div class="maplibregl-ctrl-geocoder--suggestion-title popup-suggestion-title">' + i[0] + '</div><div class="maplibregl-ctrl-geocoder--suggestion-address popup-suggestion-address">' + i.splice(1, i.length).join(",") + "</div></div>";
      },
      showResultMarkers: !0,
      debounceSearch: 200
    }, this._eventEmitter = new gZ.EventEmitter(), this.options = dc({}, this.options, t), this.fresh = !0, this.lastSelected = null, this.geocoderApi = e;
  }
  /**
   * Add the geocoder to a container. The container can be either a `Map`, an `HTMLElement` or a CSS selector string.
   *
   * If the container is a [`Map`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map), this function will behave identically to [`Map.addControl(geocoder)`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#addcontrol).
   * If the container is an instance of [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), then the geocoder will be appended as a child of that [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
   * If the container is a [CSS selector string](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors), the geocoder will be appended to the element returned from the query.
   *
   * This function will throw an error if the container is none of the above.
   * It will also throw an error if the referenced HTML element cannot be found in the `document.body`.
   *
   * For example, if the HTML body contains the element `<div id='geocoder-container'></div>`, the following script will append the geocoder to `#geocoder-container`:
   * @example
   * ```js
   * const GeoApi = {
   *   forwardGeocode: (config) => { return { features: [] } },
   *   reverseGeocode: (config) => { return { features: [] } }
   * }
   * const geocoder = new MaplibreGeocoder(GeoAPI, {});
   * geocoder.addTo('#geocoder-container');
   * ```
   * @param container - A reference to the container to which to add the geocoder
   */
  addTo(e) {
    function t(n, i) {
      if (!document.body.contains(i))
        throw new Error("Element provided to #addTo() exists, but is not in the DOM");
      const s = n.onAdd();
      i.appendChild(s);
    }
    if (e instanceof HTMLElement)
      t(this, e);
    else if (typeof e == "string") {
      const n = document.querySelectorAll(e);
      if (n.length === 0)
        throw new Error("Element " + e + "not found.");
      if (n.length > 1)
        throw new Error("Geocoder can only be added to a single html element");
      t(this, n[0]);
    } else if ("addControl" in e)
      e.addControl(this);
    else
      throw new Error("Error: addTo must be a maplibre-gl-js map, an html element, or a CSS selector query for a single html element");
  }
  onAdd(e) {
    if (e && typeof e != "string" && (this._map = e), this.setLanguage(), this.options.localGeocoderOnly && !this.options.localGeocoder)
      throw new Error("A localGeocoder function must be specified to use localGeocoderOnly mode");
    this._onChange = this._onChange.bind(this), this._onKeyDown = this._onKeyDown.bind(this), this._onPaste = this._onPaste.bind(this), this._onBlur = this._onBlur.bind(this), this._showButton = this._showButton.bind(this), this._hideButton = this._hideButton.bind(this), this._onQueryResult = this._onQueryResult.bind(this), this.clear = this.clear.bind(this), this._updateProximity = this._updateProximity.bind(this), this._collapse = this._collapse.bind(this), this._unCollapse = this._unCollapse.bind(this), this._clear = this._clear.bind(this), this._clearOnBlur = this._clearOnBlur.bind(this);
    const t = this.container = document.createElement("div");
    t.className = "maplibregl-ctrl-geocoder maplibregl-ctrl maplibregl-ctrl-geocoder maplibregl-ctrl";
    const n = this.createIcon("search", '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>');
    this._inputEl = document.createElement("input"), this._inputEl.type = "text", this._inputEl.className = "maplibregl-ctrl-geocoder--input", this.setPlaceholder(), this.options.collapsed && (this._collapse(), this.container.addEventListener("mouseenter", this._unCollapse), this.container.addEventListener("mouseleave", this._collapse), this._inputEl.addEventListener("focus", this._unCollapse)), (this.options.collapsed || this.options.clearOnBlur) && this._inputEl.addEventListener("blur", this._onBlur), this._inputEl.addEventListener("keydown", fZ(this._onKeyDown, this.options.debounceSearch)), this._inputEl.addEventListener("paste", this._onPaste), this._inputEl.addEventListener("change", this._onChange), this.container.addEventListener("mouseenter", this._showButton), this.container.addEventListener("mouseleave", this._hideButton);
    const i = document.createElement("div");
    i.classList.add("maplibregl-ctrl-geocoder--pin-right"), this._clearEl = document.createElement("button"), this._clearEl.setAttribute("type", "button"), this._clearEl.setAttribute("aria-label", "Clear"), this._clearEl.addEventListener("click", this.clear), this._clearEl.className = "maplibregl-ctrl-geocoder--button";
    const s = this.createIcon("close", '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>');
    return this._clearEl.appendChild(s), this._loadingEl = this.createIcon("loading", '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>'), i.appendChild(this._clearEl), i.appendChild(this._loadingEl), t.appendChild(n), t.appendChild(this._inputEl), t.appendChild(i), this._typeahead = new sZ(this._inputEl, [], {
      filter: !1,
      minLength: this.options.minLength,
      limit: this.options.limit,
      noInitialSelection: !0
    }), this.setRenderFunction(this.options.render), this._typeahead.getItemValue = this.options.getItemValue, this.mapMarker = null, this.resultMarkers = [], this._handleMarker = this._handleMarker.bind(this), this._handleResultMarkers = this._handleResultMarkers.bind(this), this._map && (this.options.trackProximity && (this._updateProximity(), this._map.on("moveend", this._updateProximity)), this._maplibregl = this.options.maplibregl, !this._maplibregl && this.options.marker && (console.error("No maplibregl detected in options. Map markers are disabled. Please set options.maplibregl."), this.options.marker = !1)), t;
  }
  createIcon(e, t) {
    const n = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (n.setAttribute("class", "maplibregl-ctrl-geocoder--icon maplibregl-ctrl-geocoder--icon-" + e), n.setAttribute("viewBox", "0 0 18 18"), n.setAttribute("xml:space", "preserve"), n.setAttribute("width", "18"), n.setAttribute("height", "18"), "innerHTML" in n)
      n.innerHTML = t;
    else {
      const i = document.createElement("div");
      i.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>";
      const s = i.firstChild, l = s.firstChild;
      n.appendChild(l);
    }
    return n;
  }
  onRemove() {
    return this.container.remove(), this.options.trackProximity && this._map && this._map.off("moveend", this._updateProximity), this._removeMarker(), this._map = null, this;
  }
  _onPaste(e) {
    const t = (e.clipboardData || window.clipboardData).getData("text");
    t.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(t);
  }
  _onKeyDown(e) {
    if (e.keyCode === 27 && this.options.clearAndBlurOnEsc)
      return this._clear(e), this._inputEl.blur();
    const s = this._inputEl.value;
    if (!s)
      return this.fresh = !0, e.keyCode !== 9 && this.clear(e), this._clearEl.style.display = "none";
    if (!(e.metaKey || [9, 27, 37, 39, 38, 40].indexOf(e.keyCode) !== -1)) {
      if (e.keyCode === 13)
        if (!this.options.showResultsWhileTyping)
          this._typeahead.selected || this._geocode(s);
        else {
          this._typeahead.selected == null && this.geocoderApi.getSuggestions ? this._geocode(s, !0) : this._typeahead.selected == null && this.options.showResultMarkers && this._fitBoundsForMarkers();
          return;
        }
      s.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(s);
    }
  }
  _showButton() {
    this._inputEl.value.length > 0 && (this._clearEl.style.display = "block");
  }
  _hideButton() {
    this._typeahead.selected && (this._clearEl.style.display = "none");
  }
  _onBlur(e) {
    this.options.clearOnBlur && this._clearOnBlur(e), this.options.collapsed && this._collapse();
  }
  // Change events are fire by suggestions library whenever the enter key is pressed or input is blurred
  // This can sometimes cause strange behavior as this function is called before our own onKeyDown handler and thus
  //  we cannot depend on some internal values of the suggestion state like `selected` as those will change or before
  //  our onKeyDown handler.
  _onChange() {
    const e = this._typeahead.selected;
    if (e && !e.geometry)
      e.placeId ? this._geocode(e.placeId, !0, !0) : this._geocode(e.text, !0);
    else if (e && JSON.stringify(e) !== this.lastSelected) {
      if (this._clearEl.style.display = "none", this.options.flyTo) {
        let t;
        if (this._removeResultMarkers(), e.properties && US[e.properties.short_code])
          t = dc({}, this.options.flyTo), this._map && this._map.fitBounds(US[e.properties.short_code].bbox, t);
        else if (e.bbox) {
          const n = e.bbox;
          t = dc({}, this.options.flyTo), this._map && this._map.fitBounds([[n[0], n[1]], [n[2], n[3]]], t);
        } else {
          const n = {
            zoom: this.options.zoom
          };
          t = dc({}, n, this.options.flyTo), e.center ? t.center = e.center : e.geometry && e.geometry.type && e.geometry.type === "Point" && e.geometry.coordinates && (t.center = e.geometry.coordinates), this._map && this._map.flyTo(t);
        }
      }
      this.options.marker && this._maplibregl && this._handleMarker(e), this._inputEl.focus(), this._inputEl.scrollLeft = 0, this._inputEl.setSelectionRange(0, 0), this.lastSelected = JSON.stringify(e), this._typeahead.selected = null, this._eventEmitter.emit("result", {
        result: e
      });
    }
  }
  _getConfigForRequest() {
    return ["bbox", "limit", "proximity", "countries", "types", "language", "reverseMode"].reduce((n, i) => (this.options[i] && (["countries", "types", "language"].indexOf(i) > -1 ? n[i] = this.options[i].split(/[\s,]+/) : n[i] = this.options[i], i === "proximity" && this.options[i] && typeof this.options[i].longitude == "number" && typeof this.options[i].latitude == "number" && (n[i] = [this.options[i].longitude, this.options[i].latitude])), n), {});
  }
  _geocode(e) {
    return Zb(this, arguments, void 0, function(t) {
      var n = this;
      let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      return function* () {
        n._loadingEl.style.display = "block", n._eventEmitter.emit("loading", {
          query: t
        });
        const l = n._getConfigForRequest(), o = n._createGeocodeRequest(l, t, i, s), d = n.options.localGeocoder ? n.options.localGeocoder(t) || [] : [];
        try {
          const m = yield o;
          yield n._handleGeocodeResponse(m, l, t, i, d);
        } catch (m) {
          n._handleGeocodeErrorResponse(m, d);
        }
        return o;
      }();
    });
  }
  _createGeocodeRequest(e, t, n, i) {
    return this.options.localGeocoderOnly ? Promise.resolve({}) : this.options.reverseGeocode && bZ.test(t) ? this._createReverseGeocodeRequest(t, e) : (e.query = t, this.geocoderApi.getSuggestions ? n ? this.geocoderApi.searchByPlaceId && i ? this.geocoderApi.searchByPlaceId(e) : this.geocoderApi.forwardGeocode(e) : this.geocoderApi.getSuggestions(e) : this.geocoderApi.forwardGeocode(e));
  }
  _createReverseGeocodeRequest(e, t) {
    const n = e.split(/[\s(,)?]+/).map((i) => parseFloat(i)).reverse();
    return t.query = n, t.limit = 1, "proximity" in t && delete t.proximity, this.geocoderApi.reverseGeocode(t);
  }
  _handleGeocodeResponse(e, t, n, i, s) {
    return Zb(this, void 0, void 0, function* () {
      this._loadingEl.style.display = "none";
      let l = {};
      e ? l = e : l = {
        type: "FeatureCollection",
        features: []
      }, l.config = t, this.fresh && (this.fresh = !1), l.features = l.features ? s.concat(l.features) : s;
      const o = this.options.externalGeocoder ? this.options.externalGeocoder(n, l.features, t) || Promise.resolve([]) : Promise.resolve([]);
      try {
        const m = yield o;
        l.features = l.features ? m.concat(l.features) : m;
      } catch {
      }
      this.options.filter && l.features.length && (l.features = l.features.filter(this.options.filter));
      let d = [];
      "suggestions" in l ? d = l.suggestions : "place" in l ? d = [l.place] : d = l.features, d.length ? (this._clearEl.style.display = "block", this._typeahead.update(d), (!this.options.showResultsWhileTyping || i) && this.options.showResultMarkers && (l.features.length > 0 || "place" in l) && this._fitBoundsForMarkers(), this._eventEmitter.emit("results", l)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderNoResults(), this._eventEmitter.emit("results", l));
    });
  }
  _handleGeocodeErrorResponse(e, t) {
    this._loadingEl.style.display = "none", t.length && this.options.localGeocoder ? (this._clearEl.style.display = "block", this._typeahead.update(t)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderError()), this._eventEmitter.emit("results", {
      features: t
    }), this._eventEmitter.emit("error", {
      error: e
    });
  }
  /**
   * Shared logic for clearing input
   * @param ev - the event that triggered the clear, if available
   */
  _clear(e) {
    e && e.preventDefault(), this._inputEl.value = "", this._typeahead.selected = null, this._typeahead.clear(), this._onChange(), this._clearEl.style.display = "none", this._removeMarker(), this._removeResultMarkers(), this.lastSelected = null, this._eventEmitter.emit("clear"), this.fresh = !0;
  }
  /**
   * Clear and then focus the input.
   * @param ev - the event that triggered the clear, if available
   *
   */
  clear(e) {
    this._clear(e), this._inputEl.focus();
  }
  /**
   * Clear the input, without refocusing it. Used to implement clearOnBlur
   * constructor option.
   * @param ev - the blur event
   */
  _clearOnBlur(e) {
    e.relatedTarget && this._clear(e);
  }
  _onQueryResult(e) {
    if (!("features" in e) || !e.features.length) return;
    const t = e.features[0];
    this._typeahead.selected = t, this._inputEl.value = t.place_name, this._onChange();
  }
  _updateProximity() {
    if (this._map)
      if (this._map.getZoom() > this.options.proximityMinZoom) {
        const e = this._map.getCenter().wrap();
        this.setProximity({
          longitude: e.lng,
          latitude: e.lat
        });
      } else
        this.setProximity(null);
  }
  _collapse() {
    !this._inputEl.value && this._inputEl !== document.activeElement && this.container.classList.add("maplibregl-ctrl-geocoder--collapsed");
  }
  _unCollapse() {
    this.container.classList.remove("maplibregl-ctrl-geocoder--collapsed");
  }
  /**
   * Set & query the input
   * @param searchInput - location name or other search input
   */
  query(e) {
    return Zb(this, void 0, void 0, function* () {
      const t = yield this._geocode(e);
      this._onQueryResult(t);
    });
  }
  _renderError() {
    const e = `<div class='maplibre-gl-geocoder--error'>${this._localize("errorConnectionFailed")}</div>`;
    this._renderMessage(e);
  }
  _renderNoResults() {
    const e = `<div class='maplibre-gl-geocoder--error maplibre-gl-geocoder--no-results'>
        ${this._localize("errorNoResults")}</div>`;
    this._renderMessage(e);
  }
  _renderMessage(e) {
    this._typeahead.update([]), this._typeahead.selected = null, this._typeahead.clear(), this._typeahead.renderError(e);
  }
  /**
   * Get a localised string for a given key
   *
   * If language is provided in options, attempt to return localized string (defaults to English)
   * @param key - key in the localization object
   * @returns localized string
   */
  _localize(e) {
    const t = cZ.language(this.options.language.split(",")[0]);
    return this.options.language && (zp != null && zp[e][t]) ? zp[e][t] : zp[e].en;
  }
  /**
   * Fits the map to the current bounds for the searched results
   */
  _fitBoundsForMarkers() {
    if (this._typeahead.data.length < 1) return;
    const e = this._typeahead.data.filter((t) => typeof t != "string").slice(0, this.options.limit);
    if (this._clearEl.style.display = "none", this.options.flyTo && this._maplibregl && this._map) {
      const n = dc({}, {
        padding: 100
      }, this.options.flyTo), i = new this._maplibregl.LngLatBounds();
      for (const s of e)
        i.extend(s.geometry.coordinates);
      this._map.fitBounds(i, n);
    }
    return e.length > 0 && this._maplibregl && this._handleResultMarkers(e), this;
  }
  /**
   * Set input
   * @param searchInput - location name or other search input
   */
  setInput(e) {
    return this._inputEl.value = e, this._typeahead.selected = null, this._typeahead.clear(), e.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(e), this;
  }
  /**
   * Set proximity
   * @param proximity - The new `options.proximity` value. This is a geographical point given as an object with `latitude` and `longitude` properties.
   */
  setProximity(e) {
    return this.options.proximity = e, this;
  }
  /**
   * Get proximity
   * @returns The geocoder proximity
   */
  getProximity() {
    return this.options.proximity;
  }
  /**
   * Set the render function used in the results dropdown
   * @param fn - The function to use as a render function. This function accepts a single {@link CarmenGeojsonFeature} object as input and returns a string.
   */
  setRenderFunction(e) {
    return e && typeof e == "function" && (this._typeahead.render = e), this;
  }
  /**
   * Get the function used to render the results dropdown
   *
   * @returns the render function
   */
  getRenderFunction() {
    return this._typeahead.render;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   *
   * Look first at the explicitly set options otherwise use the browser's language settings
   * @param language - Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas.
   */
  setLanguage(e) {
    return this.options.language = e || this.options.language || navigator.language, this;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   * @returns The language(s) used by the plugin, if any
   */
  getLanguage() {
    return this.options.language;
  }
  /**
   * Get the zoom level the map will move to when there is no bounding box on the selected result
   * @returns the map zoom
   */
  getZoom() {
    return this.options.zoom;
  }
  /**
   * Set the zoom level
   * @param zoom - The zoom level that the map should animate to when a `bbox` isn't found in the response. If a `bbox` is found the map will fit to the `bbox`.
   * @returns this
   */
  setZoom(e) {
    return this.options.zoom = e, this;
  }
  /**
   * Get the parameters used to fly to the selected response, if any
   * @returns The `flyTo` option
   */
  getFlyTo() {
    return this.options.flyTo;
  }
  /**
   * Set the flyTo options
   * @param flyTo - If false, animating the map to a selected result is disabled. If true, animating the map will use the default animation parameters. If an object, it will be passed as `options` to the map [`flyTo`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#flyto) or [`fitBounds`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#fitbounds) method providing control over the animation of the transition.
   */
  setFlyTo(e) {
    return this.options.flyTo = e, this;
  }
  /**
   * Get the value of the placeholder string
   * @returns The input element's placeholder value
   */
  getPlaceholder() {
    return this.options.placeholder;
  }
  /**
   * Set the value of the input element's placeholder
   * @param placeholder - the text to use as the input element's placeholder
   */
  setPlaceholder(e) {
    return this.placeholder = e || this.options.placeholder || this._localize("placeholder"), this._inputEl.placeholder = this.placeholder, this._inputEl.setAttribute("aria-label", this.placeholder), this;
  }
  /**
   * Get the bounding box used by the plugin
   * @returns the bounding box, if any
   */
  getBbox() {
    return this.options.bbox;
  }
  /**
   * Set the bounding box to limit search results to
   * @param bbox - a bounding box given as an array in the format [minX, minY, maxX, maxY].
   */
  setBbox(e) {
    return this.options.bbox = e, this;
  }
  /**
   * Get a list of the countries to limit search results to
   * @returns a comma separated list of countries to limit to, if any
   */
  getCountries() {
    return this.options.countries;
  }
  /**
   * Set the countries to limit search results to
   * @param countries - a comma separated list of countries to limit to
   */
  setCountries(e) {
    return this.options.countries = e, this;
  }
  /**
   * Get a list of the types to limit search results to
   * @returns a comma separated list of types to limit to
   */
  getTypes() {
    return this.options.types;
  }
  /**
   * Set the types to limit search results to
   * @param types - a comma separated list of types to limit to
   */
  setTypes(e) {
    return this.options.types = e, this;
  }
  /**
   * Get the minimum number of characters typed to trigger results used in the plugin
   * @returns The minimum length in characters before a search is triggered
   */
  getMinLength() {
    return this.options.minLength;
  }
  /**
   * Set the minimum number of characters typed to trigger results used by the plugin
   * @param minLength - the minimum length in characters
   */
  setMinLength(e) {
    return this.options.minLength = e, this._typeahead && (this._typeahead.options.minLength = e), this;
  }
  /**
   * Get the limit value for the number of results to display used by the plugin
   * @returns The limit value for the number of results to display used by the plugin
   */
  getLimit() {
    return this.options.limit;
  }
  /**
   * Set the limit value for the number of results to display used by the plugin
   * @param limit - the number of search results to return
   */
  setLimit(e) {
    return this.options.limit = e, this._typeahead && (this._typeahead.options.limit = e), this;
  }
  /**
   * Get the filter function used by the plugin
   * @returns the filter function
   */
  getFilter() {
    return this.options.filter;
  }
  /**
   * Set the filter function used by the plugin.
   * @param filter - A function which accepts a {@link CarmenGeojsonFeature} to filter out results from the Geocoding API response before they are included in the suggestions list. Return `true` to keep the item, `false` otherwise.
   */
  setFilter(e) {
    return this.options.filter = e, this;
  }
  /**
   * Set the geocoding api used by the plugin.
   */
  setGeocoderApi(e) {
    return this.geocoderApi = e, this;
  }
  /**
   * Get the geocoding endpoint the plugin is currently set to
   * @returns the geocoding API
   */
  getGeocoderApi() {
    return this.geocoderApi;
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param selected - the selected geojson feature
   */
  _handleMarker(e) {
    if (!this._map)
      return;
    this._removeMarker();
    const n = dc({}, {
      color: "#4668F2"
    }, this.options.marker);
    this.mapMarker = new this._maplibregl.Marker(n);
    let i;
    if (this.options.popup) {
      const l = dc({}, {}, this.options.popup);
      i = new this._maplibregl.Popup(l).setHTML(this.options.popupRender(e));
    }
    return e.center ? (this.mapMarker.setLngLat(e.center).addTo(this._map), this.options.popup && this.mapMarker.setPopup(i)) : e.geometry && e.geometry.type && e.geometry.type === "Point" && e.geometry.coordinates && (this.mapMarker.setLngLat(e.geometry.coordinates).addTo(this._map), this.options.popup && this.mapMarker.setPopup(i)), this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeMarker() {
    this.mapMarker && (this.mapMarker.remove(), this.mapMarker = null);
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param results - the top results to display on the map
   */
  _handleResultMarkers(e) {
    if (!this._map)
      return;
    this._removeResultMarkers();
    let n = dc({}, {
      color: "#4668F2"
    }, this.options.showResultMarkers);
    for (const i of e) {
      let s;
      if (this.options.showResultMarkers) {
        this.options.showResultMarkers && this.options.showResultMarkers.element && (s = this.options.showResultMarkers.element.cloneNode(!0), n = dc(n, {
          element: s
        }));
        const l = new this._maplibregl.Marker(dc({}, n, {
          element: s
        }));
        let o;
        if (this.options.popup) {
          const m = dc({}, {}, this.options.popup);
          o = new this._maplibregl.Popup(m).setHTML(this.options.popupRender(i));
        }
        i.center ? (l.setLngLat(i.center).addTo(this._map), this.options.popup && l.setPopup(o)) : i.geometry && i.geometry.type && i.geometry.type === "Point" && i.geometry.coordinates && (l.setLngLat(i.geometry.coordinates).addTo(this._map), this.options.popup && l.setPopup(o)), this.resultMarkers.push(l);
      }
    }
    return this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeResultMarkers() {
    this.resultMarkers && this.resultMarkers.length > 0 && (this.resultMarkers.forEach(function(e) {
      e.remove();
    }), this.resultMarkers = []);
  }
  /**
   * Subscribe to events that happen within the plugin.
   * @param type - name of event. Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @param fn - function that's called when the event is emitted.
   */
  on(e, t) {
    return this._eventEmitter.on(e, t), this;
  }
  /**
   * Subscribe to events that happen within the plugin only once.
   * @param type - Event name.
   * Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @returns a Promise that resolves when the event is emitted.
   */
  once(e) {
    return new Promise((t) => {
      this._eventEmitter.once(e, t);
    });
  }
  /**
   * Remove an event
   * @param type - Event name.
   * @param fn - Function that should unsubscribe to the event emitted.
   */
  off(e, t) {
    return this._eventEmitter.removeListener(e, t), this;
  }
}
const xZ = /* @__PURE__ */ JSON.parse('{"limitsUrl":"https://tilemaps.icgc.cat/vt/limits-tilejsonV3.json","geocoder":{"peliasUrl1":"https://eines.icgc.cat/geocodificador/autocompletar?text=","peliasUrl2":"&layers=topo1%2Ctopo2%2Caddress&size=5"},"mapOptions":{"container":"map","center":{"0":1.537786,"1":41.837539},"zoom":7.5,"bearing":0,"pitch":0,"hash":false,"style":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json.json","maxZoom":18,"maxPitch":85},"logoIcgcOptions":{"logoUrlColor":"https://eines.icgc.cat/recursos/logos/icgc_logo_color.png","logoUrlWhite":"https://eines.icgc.cat/recursos/logos/icgc_logo_blanc.svg","logoLink":"https://www.icgc.cat","logoTitle":"Institut Cartogrfic i Geolgic de Catalunya","logoWidth":100,"logoOpacity":0.6},"logoGencatOptions":{"logoUrlColor":"https://eines.icgc.cat/recursos/logos/gencat_logo_color.png","logoUrlWhite":"https://eines.icgc.cat/recursos/logos/gencat_logo_blanc.png","logoLink":"https://web.gencat.cat/","logoTitle":"Generalitat de Catalunya","logoWidth":100,"logoOpacity":0.6},"map3dOptions":{"spaceErrorFactor":2,"exaggeration":1,"zfactor":48,"minZoomRange":15.5,"maxZoomRange":22,"urlTilesetCities":"https://geoserveis.icgc.cat/servei/catalunya/ciutats/3dtiles/v1/tilesetV1.0.json","layerIdOrder":"place-isolated","sourceLayerFilterId":"place","minZoomFilter":14,"layerId3d":"edificisMapboxLayer","terrainSource":"ICGC5M","style3dName":"orto3d","imageIcon":"https://eines.icgc.cat/recursos//images/stick.png"},"baseStyles":[{"key":"TOPO","url":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_estandard.png"},{"key":"ORTO","url":"https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"},{"key":"ORTO3D","url":"https://eines.icgc.cat/recursos//styles/icgc_orto_3d.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"},{"key":"ORTOHYBRID","url":"https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_hibrida.png"},{"key":"ADMIN","url":"https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_delimitacio_limits_administratius.png"},{"key":"DARK","url":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_fosc.png"},{"key":"LIGHT","url":"https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_gris.png"},{"key":"GEOLOGY","url":"https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json","image":"https://visors.icgc.cat/contextmaps/imatges_estil/icgc_geologic_informacio.png"},{"key":"RASTER","substyles":{"TOPO":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_topo.jpg"},"ADMIN":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_administratiu.jpg"},"LIGHT":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic-gris/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_topo_gris.jpg"},"STANDARD":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/estandard/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_estandard_0.jpg"},"Simplified":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_simplificat.jpg"},"ORTO":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto.jpg"},"ORTOGREY":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-gris/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto_gris.jpg"},"ORTOHYBRID":{"url":"https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-hibrida/MON3857NW/{z}/{x}/{y}.png","image":"https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto_hibida.jpg"}}}],"urlTerrainICGC":[{"name":"ICGC5M","url":"https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png"},{"name":"WORLD30M","url":"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png","encoding":"terrarium"}],"ortoLayersICGC":[{"name":"ortofotoColorProvisional","key":"ortofoto_color_provisional","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional"},{"name":"ortofotoColor2023","key":"ortofoto_color_2023","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023"},{"name":"ortofotoColor2022","key":"ortofoto_color_2022","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022"},{"name":"ortofotoColor2021","key":"ortofoto_color_2021","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021"},{"name":"ortofotoColor2020","key":"ortofoto_color_2020","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020"},{"name":"ortofotoColor2019","key":"ortofoto_color_2019","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019"},{"name":"ortofotoColor2018","key":"ortofoto_color_2018","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018"},{"name":"ortofotoColor2017","key":"ortofoto_color_2017","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017"},{"name":"ortofotoColor2016","key":"ortofoto_color_2016","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016"},{"name":"ortofotoColor2015","key":"ortofoto_color_2015","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015"},{"name":"ortofotoColor2014","key":"ortofoto_color_2014","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014"},{"name":"ortofotoColor2013","key":"ortofoto_color_2013","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013"},{"name":"ortofotoColor2012","key":"ortofoto_color_2012","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012"},{"name":"ortofotoColor2011","key":"ortofoto_color_2011","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011"},{"name":"ortofotoColor2010","key":"ortofoto_color_2010","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010"},{"name":"ortofotoColor2009","key":"ortofoto_color_2009","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009"},{"name":"ortofotoColor2008","key":"ortofoto_color_2008","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008"},{"name":"ortofotoColor20062007","key":"ortofoto_color_2006-2007","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007"},{"name":"ortofotoColor20042005","key":"ortofoto_color_2004-2005","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005"},{"name":"ortofotoColor20002003","key":"ortofoto_color_2000-2003","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003"},{"name":"ortofotoBlancINegre1998","key":"ortofoto_blanc_i_negre_1998","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998"},{"name":"ortofotoBlancINegre19941997","key":"ortofoto_blanc_i_negre_1994-1997","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997"},{"name":"ortofotoColor1993","key":"ortofoto_color_1993","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993"},{"name":"ortofotoBlancINegre19831992","key":"ortofoto_blanc_i_negre_1983-1992","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992"},{"name":"ortofotoBlancINegre19701977","key":"ortofoto_blanc_i_negre_1970-1977","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977"},{"name":"ortofotoBlancINegre1956","key":"ortofoto_blanc_i_negre_1956","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956"},{"name":"ortofotoBlancINegre1945","key":"ortofoto_blanc_i_negre_1945","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945"},{"name":"ortofotoColorSerieAnual","key":"ortofoto_color_serie_anual","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual"},{"name":"ortofotoInfraroigProvisional","key":"ortofoto_infraroig_provisional","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional"},{"name":"ortofotoInfraroig2023","key":"ortofoto_infraroig_2023","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023"},{"name":"ortofotoInfraroig2022","key":"ortofoto_infraroig_2022","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022"},{"name":"ortofotoInfraroig2021","key":"ortofoto_infraroig_2021","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021"},{"name":"ortofotoInfraroig2020","key":"ortofoto_infraroig_2020","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020"},{"name":"ortofotoInfraroig2019","key":"ortofoto_infraroig_2019","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019"},{"name":"ortofotoInfraroig2018","key":"ortofoto_infraroig_2018","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018"},{"name":"ortofotoInfraroig2017","key":"ortofoto_infraroig_2017","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017"},{"name":"ortofotoInfraroig2016","key":"ortofoto_infraroig_2016","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016"},{"name":"ortofotoInfraroig2015","key":"ortofoto_infraroig_2015","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015"},{"name":"ortofotoInfraroig2014","key":"ortofoto_infraroig_2014","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014"},{"name":"ortofotoInfraroig2013","key":"ortofoto_infraroig_2013","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013"},{"name":"ortofotoInfraroig2012","key":"ortofoto_infraroig_2012","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012"},{"name":"ortofotoInfraroig2011","key":"ortofoto_infraroig_2011","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011"},{"name":"ortofotoInfraroig2010","key":"ortofoto_infraroig_2010","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010"},{"name":"ortofotoInfraroig2009","key":"ortofoto_infraroig_2009","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009"},{"name":"ortofotoInfraroig2008","key":"ortofoto_infraroig_2008","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008"},{"name":"ortofotoInfraroig20062007","key":"ortofoto_infraroig_2006-2007","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007"},{"name":"ortofotoInfraroig19961997","key":"ortofoto_infraroig_1996-1997","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997"},{"name":"ortofotoInfraroigSerieAnual","key":"ortofoto_infraroig_serie_anual","url":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"}],"vectorLayersICGC":[{"name":"agrupacionsCensals2015","key":"agrupacions_censals_2015"},{"name":"agrupacionsCensals2016","key":"agrupacions_censals_2016"},{"name":"agrupacionsCensals2017","key":"agrupacions_censals_2017"},{"name":"agrupacionsCensals2018","key":"agrupacions_censals_2018"},{"name":"agrupacionsCensals2019","key":"agrupacions_censals_2019"},{"name":"agrupacionsCensals2020","key":"agrupacions_censals_2020"},{"name":"agrupacionsCensals2021","key":"agrupacions_censals_2021"},{"name":"agrupacionsCensalsVigent","key":"agrupacions_censals_vigent"},{"name":"agrupacionsCensalsVigentText","key":"agrupacions_censals_vigent_text"},{"name":"areesBasiquesPolicials2019","key":"arees_basiques_policials_2019"},{"name":"areesBasiquesPolicials2020","key":"arees_basiques_policials_2020"},{"name":"areesBasiquesPolicials2022","key":"arees_basiques_policials_2022"},{"name":"areesBasiquesPolicialsVigent","key":"arees_basiques_policials_vigent"},{"name":"areesBasiquesPolicialsVigentText","key":"arees_basiques_policials_vigent_text"},{"name":"areesBasiquesSalutVigent","key":"arees_basiques_salut_vigent"},{"name":"areesBasiquesServeisSocialsVigent","key":"arees_basiques_serveis_socials_vigent"},{"name":"areesBasiquesServeisSocialsVigentText","key":"arees_basiques_serveis_socials_vigent_text"},{"name":"areesGestioAssistencialVigent","key":"arees_gestio_assistencial_vigent"},{"name":"areesHidrogeologiquesAquifersVigent","key":"arees_hidrogeologiques_aquifers_vigent"},{"name":"catalunyaVigent","key":"catalunya_vigent"},{"name":"catalunyaVigentText","key":"catalunya_vigent_text"},{"name":"comarques2022","key":"comarques_2022"},{"name":"comarquesVigent","key":"comarques_vigent"},{"name":"comarquesVigentText","key":"comarques_vigent_text"},{"name":"districtesCensals2015","key":"districtes_censals_2015"},{"name":"districtesCensals2016","key":"districtes_censals_2016"},{"name":"districtesCensals2017","key":"districtes_censals_2017"},{"name":"districtesCensals2018","key":"districtes_censals_2018"},{"name":"districtesCensals2019","key":"districtes_censals_2019"},{"name":"districtesCensals2020","key":"districtes_censals_2020"},{"name":"districtesCensals2021","key":"districtes_censals_2021"},{"name":"districtesCensals2022","key":"districtes_censals_2022"},{"name":"districtesCensals2023","key":"districtes_censals_2023"},{"name":"districtesCensalsVigent","key":"districtes_censals_vigent"},{"name":"districtesCensalsVigentText","key":"districtes_censals_vigent_text"},{"name":"incendisForestalsVigent","key":"incendis_forestals_vigent"},{"name":"incendisForestalsVigentText","key":"incendis_forestals_vigent_text"},{"name":"municipis2022","key":"municipis_2022"},{"name":"municipis2022Text","key":"municipis_2022_text"},{"name":"municipisVigent","key":"municipis_vigent"},{"name":"municipisVigentText","key":"municipis_vigent_text"},{"name":"partitsJudicialsVigent","key":"partits_judicials_vigent"},{"name":"partitsJudicialsVigentText","key":"partits_judicials_vigent_text"},{"name":"plaTerritorial2015","key":"pla_territorial_2015"},{"name":"plaTerritorialVigent","key":"pla_territorial_vigent"},{"name":"plaTerritorialVigentText","key":"pla_territorial_vigent_text"},{"name":"provinciesVigent","key":"provincies_vigent"},{"name":"provinciesVigentText","key":"provincies_vigent_text"},{"name":"regionsPolicialsVigent","key":"regions_policials_vigent"},{"name":"regionsPolicialsVigentText","key":"regions_policials_vigent_text"},{"name":"regionsSanitariesVigent","key":"regions_sanitaries_vigent"},{"name":"regionsSanitariesVigentText","key":"regions_sanitaries_vigent_text"},{"name":"seccionsCensals2015","key":"seccions_censals_2015"},{"name":"seccionsCensals2016","key":"seccions_censals_2016"},{"name":"seccionsCensals2017","key":"seccions_censals_2017"},{"name":"seccionsCensals2018","key":"seccions_censals_2018"},{"name":"seccionsCensals2019","key":"seccions_censals_2019"},{"name":"seccionsCensals2020","key":"seccions_censals_2020"},{"name":"seccionsCensals2021","key":"seccions_censals_2021"},{"name":"seccionsCensals2022","key":"seccions_censals_2022"},{"name":"seccionsCensals2023","key":"seccions_censals_2023"},{"name":"seccionsCensalsVigent","key":"seccions_censals_vigent"},{"name":"seccionsCensalsVigentText","key":"seccions_censals_vigent_text"},{"name":"sectorsSanitarisVigent","key":"sectors_sanitaris_vigent"},{"name":"vegueriesVigent","key":"vegueries_vigent"},{"name":"vegueriesVigentText","key":"vegueries_vigent_text"}],"vectorLayers":[{"key":"cobertes2018","url":"https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json","legend":"https://eines.icgc.cat/recursos//images/llegendaCobertesSol2018.jpg"}],"wmsLayers":[{"key":"espaisInteresGeologic","layer":"","url":"https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"},{"key":"gravimetriaBouguer500000","layer":"","url":"https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"},{"key":"cobertesSol2018","layer":"","url":"https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"},{"key":"administratiu","layer":"","url":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png"},{"key":"simplificat","layer":"","url":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png"},{"key":"cims","layer":"","url":"https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455"},{"key":"cobertesSol","layer":"","url":"http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"}],"fgbLayers":[{"name":"agrupacionsCensalsVigent","key":"agrupacions_censals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb"},{"name":"agrupacionsCensalsVigentText","key":"agrupacions_censals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb"},{"name":"areesBasiquesPolicialsVigent","key":"arees_basiques_policials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb"},{"name":"areesBasiquesPolicialsVigentText","key":"arees_basiques_policials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb"},{"name":"areesBasiquesSalutVigent","key":"arees_basiques_salut_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb"},{"name":"areesBasiquesServeisSocialsVigent","key":"arees_basiques_serveis_socials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb"},{"name":"areesBasiquesServeisSocialsVigentText","key":"arees_basiques_serveis_socials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb"},{"name":"areesGestioAssistencialVigent","key":"arees_gestio_assistencial_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb"},{"name":"areesHidrogeologiquesAquifersVigent","key":"arees_hidrogeologiques_aquifers_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb"},{"name":"catalunyaVigent","key":"catalunya_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb"},{"name":"catalunyaVigentText","key":"catalunya_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb"},{"name":"comarquesVigent","key":"comarques_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb"},{"name":"comarquesVigentText","key":"comarques_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb"},{"name":"districtesCensalsVigent","key":"districtes_censals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb"},{"name":"districtesCensalsVigentText","key":"districtes_censals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb"},{"name":"incendisForestalsVigent","key":"incendis_forestals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb"},{"name":"incendisForestalsVigentText","key":"incendis_forestals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb"},{"name":"municipisVigent","key":"municipis_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb"},{"name":"municipisVigentText","key":"municipis_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb"},{"name":"partitsJudicialsVigent","key":"partits_judicials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb"},{"name":"partitsJudicialsVigentText","key":"partits_judicials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb"},{"name":"plaTerritorialVigent","key":"pla_territorial_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb"},{"name":"plaTerritorialVigentText","key":"pla_territorial_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb"},{"name":"provinciesVigent","key":"provincies_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb"},{"name":"provinciesVigentText","key":"provincies_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb"},{"name":"regionsPolicialsVigent","key":"regions_policials_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb"},{"name":"regionsPolicialsVigentText","key":"regions_policials_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb"},{"name":"regionsSanitariesVigent","key":"regions_sanitaries_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb"},{"name":"regionsSanitariesVigentText","key":"regions_sanitaries_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb"},{"name":"seccionsCensalsVigent","key":"seccions_censals_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb"},{"name":"seccionsCensalsVigentText","key":"seccions_censals_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb"},{"name":"sectorsSanitarisVigent","key":"sectors_sanitaris_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb"},{"name":"vegueriesVigent","key":"vegueries_vigent","url":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb"},{"name":"vegueriesVigentText","key":"vegueries_vigent_text","url":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"}]}'), wZ = { TOPO: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json", ORTO: "https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json", ORTO3D: "https://eines.icgc.cat/recursos//styles/icgc_orto_3d.json", ORTOHYBRID: "https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json", ADMIN: "https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json", DARK: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json", LIGHT: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json", GEOLOGY: "https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json", RASTER: { TOPO: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic/MON3857NW/{z}/{x}/{y}.png", ADMIN: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png", LIGHT: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic-gris/MON3857NW/{z}/{x}/{y}.png", STANDARD: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/estandard/MON3857NW/{z}/{x}/{y}.png", SIMPLIFIED: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png", ORTO: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto/MON3857NW/{z}/{x}/{y}.png", ORTOGREY: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-gris/MON3857NW/{z}/{x}/{y}.png", ORTOHYBRID: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-hibrida/MON3857NW/{z}/{x}/{y}.png" } }, AZ = { ICGC5M: "https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png", WORLD30M: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png" }, TZ = /* @__PURE__ */ JSON.parse('{"Orto":{"ortofotoColorProvisional":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional","ortofotoColor2023":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023","ortofotoColor2022":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022","ortofotoColor2021":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021","ortofotoColor2020":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020","ortofotoColor2019":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019","ortofotoColor2018":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018","ortofotoColor2017":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017","ortofotoColor2016":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016","ortofotoColor2015":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015","ortofotoColor2014":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014","ortofotoColor2013":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013","ortofotoColor2012":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012","ortofotoColor2011":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011","ortofotoColor2010":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010","ortofotoColor2009":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009","ortofotoColor2008":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008","ortofotoColor20062007":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007","ortofotoColor20042005":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005","ortofotoColor20002003":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003","ortofotoBlancINegre1998":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998","ortofotoBlancINegre19941997":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997","ortofotoColor1993":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993","ortofotoBlancINegre19831992":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992","ortofotoBlancINegre19701977":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977","ortofotoBlancINegre1956":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956","ortofotoBlancINegre1945":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945","ortofotoColorSerieAnual":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual","ortofotoInfraroigProvisional":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional","ortofotoInfraroig2023":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023","ortofotoInfraroig2022":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022","ortofotoInfraroig2021":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021","ortofotoInfraroig2020":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020","ortofotoInfraroig2019":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019","ortofotoInfraroig2018":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018","ortofotoInfraroig2017":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017","ortofotoInfraroig2016":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016","ortofotoInfraroig2015":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015","ortofotoInfraroig2014":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014","ortofotoInfraroig2013":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013","ortofotoInfraroig2012":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012","ortofotoInfraroig2011":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011","ortofotoInfraroig2010":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010","ortofotoInfraroig2009":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009","ortofotoInfraroig2008":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008","ortofotoInfraroig20062007":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007","ortofotoInfraroig19961997":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997","ortofotoInfraroigSerieAnual":"https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"},"VectorAdmin":{"agrupacionsCensals2015":"agrupacions_censals_2015","agrupacionsCensals2016":"agrupacions_censals_2016","agrupacionsCensals2017":"agrupacions_censals_2017","agrupacionsCensals2018":"agrupacions_censals_2018","agrupacionsCensals2019":"agrupacions_censals_2019","agrupacionsCensals2020":"agrupacions_censals_2020","agrupacionsCensals2021":"agrupacions_censals_2021","agrupacionsCensalsVigent":"agrupacions_censals_vigent","agrupacionsCensalsVigentText":"agrupacions_censals_vigent_text","areesBasiquesPolicials2019":"arees_basiques_policials_2019","areesBasiquesPolicials2020":"arees_basiques_policials_2020","areesBasiquesPolicials2022":"arees_basiques_policials_2022","areesBasiquesPolicialsVigent":"arees_basiques_policials_vigent","areesBasiquesPolicialsVigentText":"arees_basiques_policials_vigent_text","areesBasiquesSalutVigent":"arees_basiques_salut_vigent","areesBasiquesServeisSocialsVigent":"arees_basiques_serveis_socials_vigent","areesBasiquesServeisSocialsVigentText":"arees_basiques_serveis_socials_vigent_text","areesGestioAssistencialVigent":"arees_gestio_assistencial_vigent","areesHidrogeologiquesAquifersVigent":"arees_hidrogeologiques_aquifers_vigent","catalunyaVigent":"catalunya_vigent","catalunyaVigentText":"catalunya_vigent_text","comarques2022":"comarques_2022","comarquesVigent":"comarques_vigent","comarquesVigentText":"comarques_vigent_text","districtesCensals2015":"districtes_censals_2015","districtesCensals2016":"districtes_censals_2016","districtesCensals2017":"districtes_censals_2017","districtesCensals2018":"districtes_censals_2018","districtesCensals2019":"districtes_censals_2019","districtesCensals2020":"districtes_censals_2020","districtesCensals2021":"districtes_censals_2021","districtesCensals2022":"districtes_censals_2022","districtesCensals2023":"districtes_censals_2023","districtesCensalsVigent":"districtes_censals_vigent","districtesCensalsVigentText":"districtes_censals_vigent_text","incendisForestalsVigent":"incendis_forestals_vigent","incendisForestalsVigentText":"incendis_forestals_vigent_text","municipis2022":"municipis_2022","municipis2022Text":"municipis_2022_text","municipisVigent":"municipis_vigent","municipisVigentText":"municipis_vigent_text","partitsJudicialsVigent":"partits_judicials_vigent","partitsJudicialsVigentText":"partits_judicials_vigent_text","plaTerritorial2015":"pla_territorial_2015","plaTerritorialVigent":"pla_territorial_vigent","plaTerritorialVigentText":"pla_territorial_vigent_text","provinciesVigent":"provincies_vigent","provinciesVigentText":"provincies_vigent_text","regionsPolicialsVigent":"regions_policials_vigent","regionsPolicialsVigentText":"regions_policials_vigent_text","regionsSanitariesVigent":"regions_sanitaries_vigent","regionsSanitariesVigentText":"regions_sanitaries_vigent_text","seccionsCensals2015":"seccions_censals_2015","seccionsCensals2016":"seccions_censals_2016","seccionsCensals2017":"seccions_censals_2017","seccionsCensals2018":"seccions_censals_2018","seccionsCensals2019":"seccions_censals_2019","seccionsCensals2020":"seccions_censals_2020","seccionsCensals2021":"seccions_censals_2021","seccionsCensals2022":"seccions_censals_2022","seccionsCensals2023":"seccions_censals_2023","seccionsCensalsVigent":"seccions_censals_vigent","seccionsCensalsVigentText":"seccions_censals_vigent_text","sectorsSanitarisVigent":"sectors_sanitaris_vigent","vegueriesVigent":"vegueries_vigent","vegueriesVigentText":"vegueries_vigent_text"},"FGBAdmin":{"agrupacionsCensalsVigent":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb","agrupacionsCensalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb","areesBasiquesPolicialsVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb","areesBasiquesPolicialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb","areesBasiquesSalutVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb","areesBasiquesServeisSocialsVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb","areesBasiquesServeisSocialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb","areesGestioAssistencialVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb","areesHidrogeologiquesAquifersVigent":"https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb","catalunyaVigent":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb","catalunyaVigentText":"https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb","comarquesVigent":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb","comarquesVigentText":"https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb","districtesCensalsVigent":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb","districtesCensalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb","incendisForestalsVigent":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb","incendisForestalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb","municipisVigent":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb","municipisVigentText":"https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb","partitsJudicialsVigent":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb","partitsJudicialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb","plaTerritorialVigent":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb","plaTerritorialVigentText":"https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb","provinciesVigent":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb","provinciesVigentText":"https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb","regionsPolicialsVigent":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb","regionsPolicialsVigentText":"https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb","regionsSanitariesVigent":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb","regionsSanitariesVigentText":"https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb","seccionsCensalsVigent":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb","seccionsCensalsVigentText":"https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb","sectorsSanitarisVigent":"https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb","vegueriesVigent":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb","vegueriesVigentText":"https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"},"Vector":{"cobertes2018":"https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json"},"WMS":{"espaisInteresGeologic":"https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}","gravimetriaBouguer500000":"https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}","cobertesSol2018":"https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}","administratiu":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png","simplificat":"http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png","cims":"https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455","cobertesSol":"http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"}}'), df = {
  defaultOptions: xZ,
  Styles: wZ,
  Terrains: AZ,
  Layers: TZ
};
class SZ {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    let t = df.defaultOptions;
    return this._map = e, this._img1 = document.createElement("img"), this._img1.className = "maplibregl-ctrl", this._img1.src = this.options.color ? t.logoIcgcOptions.logoUrlColor : t.logoIcgcOptions.logoUrlWhite, this._img1.width = t.logoIcgcOptions.logoWidth, this._img1.title = t.logoIcgcOptions.logoTitle, this._img1.style.opacity = t.logoIcgcOptions.logoOpacity, this.link1 = document.createElement("a"), this.link1.href = t.logoIcgcOptions.logoLink, this.link1.target = "_blank", this.link1.appendChild(this._img1), this._container1 = document.createElement("div"), this._container1.className = "maplibregl-ctrl", this._container1.style.width = `${t.logoIcgcOptions.logoWidth}px`, this._container1.appendChild(this.link1), this._img2 = document.createElement("img"), this._img2.className = "maplibregl-ctrl", this._img2.src = this.options.color ? t.logoGencatOptions.logoUrlColor : t.logoGencatOptions.logoUrlWhite, this._img2.width = t.logoGencatOptions.logoWidth, this._img2.title = t.logoGencatOptions.logoTitle, this._img2.style.opacity = t.logoGencatOptions.logoOpacity, this.link2 = document.createElement("a"), this.link2.href = t.logoGencatOptions.logoLink, this.link2.target = "_blank", this.link2.appendChild(this._img2), this._container2 = document.createElement("div"), this._container2.className = "maplibregl-ctrl", this._container2.style.width = `${t.logoGencatOptions.logoWidth}px`, this._container2.appendChild(this.link2), this._mainContainer = document.createElement("div"), this._mainContainer.className = "divLogos", this._mainContainer.style = "display: flex", this._mainContainer.appendChild(this._container1), this._mainContainer.appendChild(this._container2), this._mainContainer;
  }
}
class EZ {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    this._map = e, this._img1 = document.createElement("img"), this._img1.src = this.options.url, this._img1.width = 150, this._img1.title = 300, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add("maplibregl-ctrl"), this.controlContainer.classList.add("maplibregl-ctrl-group"), this.legendContainer = document.createElement("div"), this.legendContainer.classList.add("maplibregl-legend-list"), this.legendButton = document.createElement("button"), this.legendButton.classList.add("maplibregl-ctrl-icon"), this.legendButton.classList.add("maplibregl-legend-switcher"), this.legendButton.addEventListener("click", () => {
      this.legendButton.style.display = "none", this.legendContainer.style.display = "block";
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.legendButton), this.controlContainer.appendChild(this.legendContainer), this.closeButton = document.createElement("button"), this.closeButton.textContent = "x", this.closeButton.classList.add("maplibregl-legend-close-button"), this.closeButton.addEventListener("click", () => {
      this.legendButton.style.display = "block", this.legendContainer.style.display = "none";
    }), this.legendContainer.appendChild(this.closeButton);
    const t = document.createElement("label");
    return t.classList.add("maplibregl-legend-title-label"), t.textContent = this.options.idLayer || "Llegenda", this.legendContainer.appendChild(t), this.legendContainer.appendChild(document.createElement("br")), this.legendContainer.appendChild(this._img1), this.controlContainer;
  }
}
var r1, zS;
function CZ() {
  if (zS) return r1;
  zS = 1;
  var r = t.prototype, e = "WGS 84";
  function t(i) {
    i !== void 0 && (e = i), this.setEllipsoid(e);
  }
  r.convertLatLngToUtm = function(i, s, l) {
    var o;
    if (this.status)
      return "No ecclipsoid data associated with unknown datum: " + e;
    if (!Number.isInteger(l))
      return "Precision is not integer number.";
    i = parseFloat(i), s = parseFloat(s);
    var d = s, m = this.toRadians(i), b = this.toRadians(d);
    d >= 8 && d <= 13 && i > 54.5 && i < 58 || i >= 56 && i < 64 && d >= 3 && d < 12 ? o = 32 : (o = (d + 180) / 6 + 1, i >= 72 && i < 84 && (d >= 0 && d < 9 ? o = 31 : d >= 9 && d < 21 ? o = 33 : d >= 21 && d < 33 ? o = 35 : d >= 33 && d < 42 && (o = 37))), o = parseInt(o);
    var T = (o - 1) * 6 - 180 + 3, M = this.toRadians(T), E = this.getUtmLetterDesignator(i), D = this.eccSquared / (1 - this.eccSquared), U = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(m) * Math.sin(m)), q = Math.tan(m) * Math.tan(m), G = D * Math.cos(m) * Math.cos(m), Y = Math.cos(m) * (b - M), he = this.a * ((1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256) * m - (3 * this.eccSquared / 8 + 3 * this.eccSquared * this.eccSquared / 32 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(2 * m) + (15 * this.eccSquared * this.eccSquared / 256 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(4 * m) - 35 * this.eccSquared * this.eccSquared * this.eccSquared / 3072 * Math.sin(6 * m)), X = parseFloat(0.9996 * U * (Y + (1 - q + G) * Y * Y * Y / 6 + (5 - 18 * q + q * q + 72 * G - 58 * D) * Y * Y * Y * Y * Y / 120) + 5e5), J = parseFloat(0.9996 * (he + U * Math.tan(m) * (Y * Y / 2 + (5 - q + 9 * G + 4 * G * G) * Y * Y * Y * Y / 24 + (61 - 58 * q + q * q + 600 * G - 330 * D) * Y * Y * Y * Y * Y * Y / 720)));
    return i < 0 && (J += 1e7), J = n(J, l), X = n(X, l), {
      Easting: X,
      Northing: J,
      ZoneNumber: parseInt(o),
      ZoneLetter: E
    };
  }, r.convertUtmToLatLng = function(i, s, l, o) {
    var d = (1 - Math.sqrt(1 - this.eccSquared)) / (1 + Math.sqrt(1 - this.eccSquared)), m = i - 5e5, b = s, T = l, M = o;
    if (i === void 0)
      return "Please pass the UTMEasting!";
    if (s === void 0)
      return "Please pass the UTMNorthing!";
    if (l === void 0)
      return "Please pass the UTMZoneNumber!";
    if (o === void 0)
      return "Please pass the UTMZoneLetter!";
    ["N", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"].indexOf(M) !== -1 || (b -= 1e7);
    var E = (T - 1) * 6 - 180 + 3, D = this.eccSquared / (1 - this.eccSquared), U = b / 0.9996, q = U / (this.a * (1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256)), G = q + (3 * d / 2 - 27 * d * d * d / 32) * Math.sin(2 * q) + (21 * d * d / 16 - 55 * d * d * d * d / 32) * Math.sin(4 * q) + 151 * d * d * d / 96 * Math.sin(6 * q);
    this.toDegrees(G);
    var Y = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(G) * Math.sin(G)), he = Math.tan(G) * Math.tan(G), X = D * Math.cos(G) * Math.cos(G), J = this.a * (1 - this.eccSquared) / Math.pow(1 - this.eccSquared * Math.sin(G) * Math.sin(G), 1.5), ie = m / (Y * 0.9996), ye = G - Y * Math.tan(G) / J * (ie * ie / 2 - (5 + 3 * he + 10 * X - 4 * X * X - 9 * D) * ie * ie * ie * ie / 24 + (61 + 90 * he + 298 * X + 45 * he * he - 252 * D - 3 * X * X) * ie * ie * ie * ie * ie * ie / 720);
    ye = this.toDegrees(ye);
    var oe = (ie - (1 + 2 * he + X) * ie * ie * ie / 6 + (5 - 2 * X + 28 * he - 3 * X * X + 8 * D + 24 * he * he) * ie * ie * ie * ie * ie / 120) / Math.cos(G);
    return oe = E + this.toDegrees(oe), {
      lat: ye,
      lng: oe
    };
  }, r.getUtmLetterDesignator = function(i) {
    return i = parseFloat(i), 84 >= i && i >= 72 ? "X" : 72 > i && i >= 64 ? "W" : 64 > i && i >= 56 ? "V" : 56 > i && i >= 48 ? "U" : 48 > i && i >= 40 ? "T" : 40 > i && i >= 32 ? "S" : 32 > i && i >= 24 ? "R" : 24 > i && i >= 16 ? "Q" : 16 > i && i >= 8 ? "P" : 8 > i && i >= 0 ? "N" : 0 > i && i >= -8 ? "M" : -8 > i && i >= -16 ? "L" : -16 > i && i >= -24 ? "K" : -24 > i && i >= -32 ? "J" : -32 > i && i >= -40 ? "H" : -40 > i && i >= -48 ? "G" : -48 > i && i >= -56 ? "F" : -56 > i && i >= -64 ? "E" : -64 > i && i >= -72 ? "D" : -72 > i && i >= -80 ? "C" : "Z";
  }, r.setEllipsoid = function(i) {
    switch (i) {
      case "Airy":
        this.a = 6377563, this.eccSquared = 667054e-8;
        break;
      case "Australian National":
        this.a = 6378160, this.eccSquared = 6694542e-9;
        break;
      case "Bessel 1841":
        this.a = 6377397, this.eccSquared = 6674372e-9;
        break;
      case "Bessel 1841 Nambia":
        this.a = 6377484, this.eccSquared = 6674372e-9;
        break;
      case "Clarke 1866":
        this.a = 6378206, this.eccSquared = 6768658e-9;
        break;
      case "Clarke 1880":
        this.a = 6378249, this.eccSquared = 6803511e-9;
        break;
      case "Everest":
        this.a = 6377276, this.eccSquared = 6637847e-9;
        break;
      case "Fischer 1960 Mercury":
        this.a = 6378166, this.eccSquared = 6693422e-9;
        break;
      case "Fischer 1968":
        this.a = 6378150, this.eccSquared = 6693422e-9;
        break;
      case "GRS 1967":
        this.a = 6378160, this.eccSquared = 6694605e-9;
        break;
      case "GRS 1980":
        this.a = 6378137, this.eccSquared = 669438e-8;
        break;
      case "Helmert 1906":
        this.a = 6378200, this.eccSquared = 6693422e-9;
        break;
      case "Hough":
        this.a = 6378270, this.eccSquared = 672267e-8;
        break;
      case "International":
        this.a = 6378388, this.eccSquared = 672267e-8;
        break;
      case "Krassovsky":
        this.a = 6378245, this.eccSquared = 6693422e-9;
        break;
      case "Modified Airy":
        this.a = 6377340, this.eccSquared = 667054e-8;
        break;
      case "Modified Everest":
        this.a = 6377304, this.eccSquared = 6637847e-9;
        break;
      case "Modified Fischer 1960":
        this.a = 6378155, this.eccSquared = 6693422e-9;
        break;
      case "South American 1969":
        this.a = 6378160, this.eccSquared = 6694542e-9;
        break;
      case "WGS 60":
        this.a = 6378165, this.eccSquared = 6693422e-9;
        break;
      case "WGS 66":
        this.a = 6378145, this.eccSquared = 6694542e-9;
        break;
      case "WGS 72":
        this.a = 6378135, this.eccSquared = 6694318e-9;
        break;
      case "ED50":
        this.a = 6378388, this.eccSquared = 672267e-8;
        break;
      // International Ellipsoid
      case "WGS 84":
      case "EUREF89":
      // Max deviation from WGS 84 is 40 cm/km see http://ocq.dk/euref89 (in danish)
      case "ETRS89":
        this.a = 6378137, this.eccSquared = 669438e-8;
        break;
      default:
        this.status = !0;
    }
  }, r.toDegrees = function(i) {
    return i / Math.PI * 180;
  }, r.toRadians = function(i) {
    return i * Math.PI / 180;
  };
  function n(i, s) {
    var l = Math.pow(10, s);
    return Math.round(i * l) / l;
  }
  return r1 = t, r1;
}
var IZ = CZ();
const MZ = /* @__PURE__ */ Dv(IZ);
class PZ {
  constructor(e) {
    this.options = e || {}, this.options.utm = this.options.hasOwnProperty("utm") ? this.options.utm : !0, this.options.lonlat = this.options.hasOwnProperty("lonlat") ? this.options.lonlat : !0;
  }
  onAdd(e) {
    const t = new MZ();
    return this._map = e, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl coordControl", this._container.style.width = `${this.options.width || "225px"}`, this._map.on("mousemove", (n) => {
      const i = n.lngLat.lat, s = n.lngLat.lng;
      let l = "", o = "";
      const d = t.convertLatLngToUtm(i, s, 2), m = i > 0 ? "N" : "S";
      this.options.utm && (l = `ETRS89 UTM ${d.ZoneNumber}${m} X:<b> ${d.Easting}</b> Y:<b> ${d.Northing}</b> <br>`), this.options.lonlat && (o = `WGS 84 Lon:<b> ${s.toFixed(5)}</b>  Lat:<b> ${i.toFixed(5)}</b>`);
      const b = `${l}${o}`;
      this._container.innerHTML = b;
    }), this._container;
  }
  _lookUTM31(e, t) {
    var n = 0, i = 0, s = 6, l = 84;
    return e >= n && e <= s && t >= i && t <= l;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
function xM(r, e) {
  return function() {
    return r.apply(e, arguments);
  };
}
const {
  toString: RZ
} = Object.prototype, {
  getPrototypeOf: ix
} = Object, Ny = /* @__PURE__ */ ((r) => (e) => {
  const t = RZ.call(e);
  return r[t] || (r[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Oc = (r) => (r = r.toLowerCase(), (e) => Ny(e) === r), Dy = (r) => (e) => typeof e === r, {
  isArray: rp
} = Array, Ag = Dy("undefined");
function BZ(r) {
  return r !== null && !Ag(r) && r.constructor !== null && !Ag(r.constructor) && el(r.constructor.isBuffer) && r.constructor.isBuffer(r);
}
const wM = Oc("ArrayBuffer");
function LZ(r) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(r) : e = r && r.buffer && wM(r.buffer), e;
}
const OZ = Dy("string"), el = Dy("function"), AM = Dy("number"), ky = (r) => r !== null && typeof r == "object", NZ = (r) => r === !0 || r === !1, l_ = (r) => {
  if (Ny(r) !== "object")
    return !1;
  const e = ix(r);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in r) && !(Symbol.iterator in r);
}, DZ = Oc("Date"), kZ = Oc("File"), FZ = Oc("Blob"), UZ = Oc("FileList"), zZ = (r) => ky(r) && el(r.pipe), jZ = (r) => {
  let e;
  return r && (typeof FormData == "function" && r instanceof FormData || el(r.append) && ((e = Ny(r)) === "formdata" || // detect form-data instance
  e === "object" && el(r.toString) && r.toString() === "[object FormData]"));
}, VZ = Oc("URLSearchParams"), [qZ, GZ, $Z, HZ] = ["ReadableStream", "Request", "Response", "Headers"].map(Oc), WZ = (r) => r.trim ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Og(r, e) {
  let {
    allOwnKeys: t = !1
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (r === null || typeof r > "u")
    return;
  let n, i;
  if (typeof r != "object" && (r = [r]), rp(r))
    for (n = 0, i = r.length; n < i; n++)
      e.call(null, r[n], n, r);
  else {
    const s = t ? Object.getOwnPropertyNames(r) : Object.keys(r), l = s.length;
    let o;
    for (n = 0; n < l; n++)
      o = s[n], e.call(null, r[o], o, r);
  }
}
function TM(r, e) {
  e = e.toLowerCase();
  const t = Object.keys(r);
  let n = t.length, i;
  for (; n-- > 0; )
    if (i = t[n], e === i.toLowerCase())
      return i;
  return null;
}
const pf = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, SM = (r) => !Ag(r) && r !== pf;
function Pv() {
  const {
    caseless: r
  } = SM(this) && this || {}, e = {}, t = (n, i) => {
    const s = r && TM(e, i) || i;
    l_(e[s]) && l_(n) ? e[s] = Pv(e[s], n) : l_(n) ? e[s] = Pv({}, n) : rp(n) ? e[s] = n.slice() : e[s] = n;
  };
  for (let n = 0, i = arguments.length; n < i; n++)
    arguments[n] && Og(arguments[n], t);
  return e;
}
const XZ = function(r, e, t) {
  let {
    allOwnKeys: n
  } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  return Og(e, (i, s) => {
    t && el(i) ? r[s] = xM(i, t) : r[s] = i;
  }, {
    allOwnKeys: n
  }), r;
}, ZZ = (r) => (r.charCodeAt(0) === 65279 && (r = r.slice(1)), r), YZ = (r, e, t, n) => {
  r.prototype = Object.create(e.prototype, n), r.prototype.constructor = r, Object.defineProperty(r, "super", {
    value: e.prototype
  }), t && Object.assign(r.prototype, t);
}, KZ = (r, e, t, n) => {
  let i, s, l;
  const o = {};
  if (e = e || {}, r == null) return e;
  do {
    for (i = Object.getOwnPropertyNames(r), s = i.length; s-- > 0; )
      l = i[s], (!n || n(l, r, e)) && !o[l] && (e[l] = r[l], o[l] = !0);
    r = t !== !1 && ix(r);
  } while (r && (!t || t(r, e)) && r !== Object.prototype);
  return e;
}, JZ = (r, e, t) => {
  r = String(r), (t === void 0 || t > r.length) && (t = r.length), t -= e.length;
  const n = r.indexOf(e, t);
  return n !== -1 && n === t;
}, QZ = (r) => {
  if (!r) return null;
  if (rp(r)) return r;
  let e = r.length;
  if (!AM(e)) return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = r[e];
  return t;
}, eY = /* @__PURE__ */ ((r) => (e) => r && e instanceof r)(typeof Uint8Array < "u" && ix(Uint8Array)), tY = (r, e) => {
  const n = (r && r[Symbol.iterator]).call(r);
  let i;
  for (; (i = n.next()) && !i.done; ) {
    const s = i.value;
    e.call(r, s[0], s[1]);
  }
}, rY = (r, e) => {
  let t;
  const n = [];
  for (; (t = r.exec(e)) !== null; )
    n.push(t);
  return n;
}, nY = Oc("HTMLFormElement"), iY = (r) => r.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(t, n, i) {
  return n.toUpperCase() + i;
}), jS = ((r) => {
  let {
    hasOwnProperty: e
  } = r;
  return (t, n) => e.call(t, n);
})(Object.prototype), sY = Oc("RegExp"), EM = (r, e) => {
  const t = Object.getOwnPropertyDescriptors(r), n = {};
  Og(t, (i, s) => {
    let l;
    (l = e(i, s, r)) !== !1 && (n[s] = l || i);
  }), Object.defineProperties(r, n);
}, oY = (r) => {
  EM(r, (e, t) => {
    if (el(r) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const n = r[t];
    if (el(n)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, aY = (r, e) => {
  const t = {}, n = (i) => {
    i.forEach((s) => {
      t[s] = !0;
    });
  };
  return rp(r) ? n(r) : n(String(r).split(e)), t;
}, lY = () => {
}, cY = (r, e) => r != null && Number.isFinite(r = +r) ? r : e, n1 = "abcdefghijklmnopqrstuvwxyz", VS = "0123456789", CM = {
  DIGIT: VS,
  ALPHA: n1,
  ALPHA_DIGIT: n1 + n1.toUpperCase() + VS
}, uY = function() {
  let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CM.ALPHA_DIGIT, t = "";
  const {
    length: n
  } = e;
  for (; r--; )
    t += e[Math.random() * n | 0];
  return t;
};
function hY(r) {
  return !!(r && el(r.append) && r[Symbol.toStringTag] === "FormData" && r[Symbol.iterator]);
}
const fY = (r) => {
  const e = new Array(10), t = (n, i) => {
    if (ky(n)) {
      if (e.indexOf(n) >= 0)
        return;
      if (!("toJSON" in n)) {
        e[i] = n;
        const s = rp(n) ? [] : {};
        return Og(n, (l, o) => {
          const d = t(l, i + 1);
          !Ag(d) && (s[o] = d);
        }), e[i] = void 0, s;
      }
    }
    return n;
  };
  return t(r, 0);
}, dY = Oc("AsyncFunction"), pY = (r) => r && (ky(r) || el(r)) && el(r.then) && el(r.catch), IM = ((r, e) => r ? setImmediate : e ? ((t, n) => (pf.addEventListener("message", (i) => {
  let {
    source: s,
    data: l
  } = i;
  s === pf && l === t && n.length && n.shift()();
}, !1), (i) => {
  n.push(i), pf.postMessage(t, "*");
}))(`axios@${Math.random()}`, []) : (t) => setTimeout(t))(typeof setImmediate == "function", el(pf.postMessage)), gY = typeof queueMicrotask < "u" ? queueMicrotask.bind(pf) : typeof process < "u" && process.nextTick || IM, jt = {
  isArray: rp,
  isArrayBuffer: wM,
  isBuffer: BZ,
  isFormData: jZ,
  isArrayBufferView: LZ,
  isString: OZ,
  isNumber: AM,
  isBoolean: NZ,
  isObject: ky,
  isPlainObject: l_,
  isReadableStream: qZ,
  isRequest: GZ,
  isResponse: $Z,
  isHeaders: HZ,
  isUndefined: Ag,
  isDate: DZ,
  isFile: kZ,
  isBlob: FZ,
  isRegExp: sY,
  isFunction: el,
  isStream: zZ,
  isURLSearchParams: VZ,
  isTypedArray: eY,
  isFileList: UZ,
  forEach: Og,
  merge: Pv,
  extend: XZ,
  trim: WZ,
  stripBOM: ZZ,
  inherits: YZ,
  toFlatObject: KZ,
  kindOf: Ny,
  kindOfTest: Oc,
  endsWith: JZ,
  toArray: QZ,
  forEachEntry: tY,
  matchAll: rY,
  isHTMLForm: nY,
  hasOwnProperty: jS,
  hasOwnProp: jS,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: EM,
  freezeMethods: oY,
  toObjectSet: aY,
  toCamelCase: iY,
  noop: lY,
  toFiniteNumber: cY,
  findKey: TM,
  global: pf,
  isContextDefined: SM,
  ALPHABET: CM,
  generateString: uY,
  isSpecCompliantForm: hY,
  toJSONObject: fY,
  isAsyncFn: dY,
  isThenable: pY,
  setImmediate: IM,
  asap: gY
};
function pn(r, e, t, n, i) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = r, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null);
}
jt.inherits(pn, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: jt.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const MM = pn.prototype, PM = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((r) => {
  PM[r] = {
    value: r
  };
});
Object.defineProperties(pn, PM);
Object.defineProperty(MM, "isAxiosError", {
  value: !0
});
pn.from = (r, e, t, n, i, s) => {
  const l = Object.create(MM);
  return jt.toFlatObject(r, l, function(d) {
    return d !== Error.prototype;
  }, (o) => o !== "isAxiosError"), pn.call(l, r.message, e, t, n, i), l.cause = r, l.name = r.name, s && Object.assign(l, s), l;
};
const mY = null;
function Rv(r) {
  return jt.isPlainObject(r) || jt.isArray(r);
}
function RM(r) {
  return jt.endsWith(r, "[]") ? r.slice(0, -2) : r;
}
function qS(r, e, t) {
  return r ? r.concat(e).map(function(i, s) {
    return i = RM(i), !t && s ? "[" + i + "]" : i;
  }).join(t ? "." : "") : e;
}
function _Y(r) {
  return jt.isArray(r) && !r.some(Rv);
}
const yY = jt.toFlatObject(jt, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function Fy(r, e, t) {
  if (!jt.isObject(r))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = jt.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(U, q) {
    return !jt.isUndefined(q[U]);
  });
  const n = t.metaTokens, i = t.visitor || b, s = t.dots, l = t.indexes, d = (t.Blob || typeof Blob < "u" && Blob) && jt.isSpecCompliantForm(e);
  if (!jt.isFunction(i))
    throw new TypeError("visitor must be a function");
  function m(D) {
    if (D === null) return "";
    if (jt.isDate(D))
      return D.toISOString();
    if (!d && jt.isBlob(D))
      throw new pn("Blob is not supported. Use a Buffer instead.");
    return jt.isArrayBuffer(D) || jt.isTypedArray(D) ? d && typeof Blob == "function" ? new Blob([D]) : Buffer.from(D) : D;
  }
  function b(D, U, q) {
    let G = D;
    if (D && !q && typeof D == "object") {
      if (jt.endsWith(U, "{}"))
        U = n ? U : U.slice(0, -2), D = JSON.stringify(D);
      else if (jt.isArray(D) && _Y(D) || (jt.isFileList(D) || jt.endsWith(U, "[]")) && (G = jt.toArray(D)))
        return U = RM(U), G.forEach(function(he, X) {
          !(jt.isUndefined(he) || he === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            l === !0 ? qS([U], X, s) : l === null ? U : U + "[]",
            m(he)
          );
        }), !1;
    }
    return Rv(D) ? !0 : (e.append(qS(q, U, s), m(D)), !1);
  }
  const T = [], M = Object.assign(yY, {
    defaultVisitor: b,
    convertValue: m,
    isVisitable: Rv
  });
  function E(D, U) {
    if (!jt.isUndefined(D)) {
      if (T.indexOf(D) !== -1)
        throw Error("Circular reference detected in " + U.join("."));
      T.push(D), jt.forEach(D, function(G, Y) {
        (!(jt.isUndefined(G) || G === null) && i.call(e, G, jt.isString(Y) ? Y.trim() : Y, U, M)) === !0 && E(G, U ? U.concat(Y) : [Y]);
      }), T.pop();
    }
  }
  if (!jt.isObject(r))
    throw new TypeError("data must be an object");
  return E(r), e;
}
function GS(r) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(r).replace(/[!'()~]|%20|%00/g, function(n) {
    return e[n];
  });
}
function sx(r, e) {
  this._pairs = [], r && Fy(r, this, e);
}
const BM = sx.prototype;
BM.append = function(e, t) {
  this._pairs.push([e, t]);
};
BM.toString = function(e) {
  const t = e ? function(n) {
    return e.call(this, n, GS);
  } : GS;
  return this._pairs.map(function(i) {
    return t(i[0]) + "=" + t(i[1]);
  }, "").join("&");
};
function bY(r) {
  return encodeURIComponent(r).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function LM(r, e, t) {
  if (!e)
    return r;
  const n = t && t.encode || bY;
  jt.isFunction(t) && (t = {
    serialize: t
  });
  const i = t && t.serialize;
  let s;
  if (i ? s = i(e, t) : s = jt.isURLSearchParams(e) ? e.toString() : new sx(e, t).toString(n), s) {
    const l = r.indexOf("#");
    l !== -1 && (r = r.slice(0, l)), r += (r.indexOf("?") === -1 ? "?" : "&") + s;
  }
  return r;
}
class $S {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, t, n) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: n ? n.synchronous : !1,
      runWhen: n ? n.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    jt.forEach(this.handlers, function(n) {
      n !== null && e(n);
    });
  }
}
const OM = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, vY = typeof URLSearchParams < "u" ? URLSearchParams : sx, xY = typeof FormData < "u" ? FormData : null, wY = typeof Blob < "u" ? Blob : null, AY = {
  isBrowser: !0,
  classes: {
    URLSearchParams: vY,
    FormData: xY,
    Blob: wY
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, ox = typeof window < "u" && typeof document < "u", Bv = typeof navigator == "object" && navigator || void 0, TY = ox && (!Bv || ["ReactNative", "NativeScript", "NS"].indexOf(Bv.product) < 0), SY = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", EY = ox && window.location.href || "http://localhost", CY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: ox,
  hasStandardBrowserEnv: TY,
  hasStandardBrowserWebWorkerEnv: SY,
  navigator: Bv,
  origin: EY
}, Symbol.toStringTag, { value: "Module" })), $o = {
  ...CY,
  ...AY
};
function IY(r, e) {
  return Fy(r, new $o.classes.URLSearchParams(), Object.assign({
    visitor: function(t, n, i, s) {
      return $o.isNode && jt.isBuffer(t) ? (this.append(n, t.toString("base64")), !1) : s.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function MY(r) {
  return jt.matchAll(/\w+|\[(\w*)]/g, r).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function PY(r) {
  const e = {}, t = Object.keys(r);
  let n;
  const i = t.length;
  let s;
  for (n = 0; n < i; n++)
    s = t[n], e[s] = r[s];
  return e;
}
function NM(r) {
  function e(t, n, i, s) {
    let l = t[s++];
    if (l === "__proto__") return !0;
    const o = Number.isFinite(+l), d = s >= t.length;
    return l = !l && jt.isArray(i) ? i.length : l, d ? (jt.hasOwnProp(i, l) ? i[l] = [i[l], n] : i[l] = n, !o) : ((!i[l] || !jt.isObject(i[l])) && (i[l] = []), e(t, n, i[l], s) && jt.isArray(i[l]) && (i[l] = PY(i[l])), !o);
  }
  if (jt.isFormData(r) && jt.isFunction(r.entries)) {
    const t = {};
    return jt.forEachEntry(r, (n, i) => {
      e(MY(n), i, t, 0);
    }), t;
  }
  return null;
}
function RY(r, e, t) {
  if (jt.isString(r))
    try {
      return (e || JSON.parse)(r), jt.trim(r);
    } catch (n) {
      if (n.name !== "SyntaxError")
        throw n;
    }
  return (t || JSON.stringify)(r);
}
const Ng = {
  transitional: OM,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const n = t.getContentType() || "", i = n.indexOf("application/json") > -1, s = jt.isObject(e);
    if (s && jt.isHTMLForm(e) && (e = new FormData(e)), jt.isFormData(e))
      return i ? JSON.stringify(NM(e)) : e;
    if (jt.isArrayBuffer(e) || jt.isBuffer(e) || jt.isStream(e) || jt.isFile(e) || jt.isBlob(e) || jt.isReadableStream(e))
      return e;
    if (jt.isArrayBufferView(e))
      return e.buffer;
    if (jt.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let o;
    if (s) {
      if (n.indexOf("application/x-www-form-urlencoded") > -1)
        return IY(e, this.formSerializer).toString();
      if ((o = jt.isFileList(e)) || n.indexOf("multipart/form-data") > -1) {
        const d = this.env && this.env.FormData;
        return Fy(o ? {
          "files[]": e
        } : e, d && new d(), this.formSerializer);
      }
    }
    return s || i ? (t.setContentType("application/json", !1), RY(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || Ng.transitional, n = t && t.forcedJSONParsing, i = this.responseType === "json";
    if (jt.isResponse(e) || jt.isReadableStream(e))
      return e;
    if (e && jt.isString(e) && (n && !this.responseType || i)) {
      const l = !(t && t.silentJSONParsing) && i;
      try {
        return JSON.parse(e);
      } catch (o) {
        if (l)
          throw o.name === "SyntaxError" ? pn.from(o, pn.ERR_BAD_RESPONSE, this, null, this.response) : o;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: $o.classes.FormData,
    Blob: $o.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
jt.forEach(["delete", "get", "head", "post", "put", "patch"], (r) => {
  Ng.headers[r] = {};
});
const BY = jt.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), LY = (r) => {
  const e = {};
  let t, n, i;
  return r && r.split(`
`).forEach(function(l) {
    i = l.indexOf(":"), t = l.substring(0, i).trim().toLowerCase(), n = l.substring(i + 1).trim(), !(!t || e[t] && BY[t]) && (t === "set-cookie" ? e[t] ? e[t].push(n) : e[t] = [n] : e[t] = e[t] ? e[t] + ", " + n : n);
  }), e;
}, HS = Symbol("internals");
function jp(r) {
  return r && String(r).trim().toLowerCase();
}
function c_(r) {
  return r === !1 || r == null ? r : jt.isArray(r) ? r.map(c_) : String(r);
}
function OY(r) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let n;
  for (; n = t.exec(r); )
    e[n[1]] = n[2];
  return e;
}
const NY = (r) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(r.trim());
function i1(r, e, t, n, i) {
  if (jt.isFunction(n))
    return n.call(this, e, t);
  if (i && (e = t), !!jt.isString(e)) {
    if (jt.isString(n))
      return e.indexOf(n) !== -1;
    if (jt.isRegExp(n))
      return n.test(e);
  }
}
function DY(r) {
  return r.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n);
}
function kY(r, e) {
  const t = jt.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((n) => {
    Object.defineProperty(r, n + t, {
      value: function(i, s, l) {
        return this[n].call(this, e, i, s, l);
      },
      configurable: !0
    });
  });
}
let Sa = class {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, n) {
    const i = this;
    function s(o, d, m) {
      const b = jp(d);
      if (!b)
        throw new Error("header name must be a non-empty string");
      const T = jt.findKey(i, b);
      (!T || i[T] === void 0 || m === !0 || m === void 0 && i[T] !== !1) && (i[T || d] = c_(o));
    }
    const l = (o, d) => jt.forEach(o, (m, b) => s(m, b, d));
    if (jt.isPlainObject(e) || e instanceof this.constructor)
      l(e, t);
    else if (jt.isString(e) && (e = e.trim()) && !NY(e))
      l(LY(e), t);
    else if (jt.isHeaders(e))
      for (const [o, d] of e.entries())
        s(d, o, n);
    else
      e != null && s(t, e, n);
    return this;
  }
  get(e, t) {
    if (e = jp(e), e) {
      const n = jt.findKey(this, e);
      if (n) {
        const i = this[n];
        if (!t)
          return i;
        if (t === !0)
          return OY(i);
        if (jt.isFunction(t))
          return t.call(this, i, n);
        if (jt.isRegExp(t))
          return t.exec(i);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = jp(e), e) {
      const n = jt.findKey(this, e);
      return !!(n && this[n] !== void 0 && (!t || i1(this, this[n], n, t)));
    }
    return !1;
  }
  delete(e, t) {
    const n = this;
    let i = !1;
    function s(l) {
      if (l = jp(l), l) {
        const o = jt.findKey(n, l);
        o && (!t || i1(n, n[o], o, t)) && (delete n[o], i = !0);
      }
    }
    return jt.isArray(e) ? e.forEach(s) : s(e), i;
  }
  clear(e) {
    const t = Object.keys(this);
    let n = t.length, i = !1;
    for (; n--; ) {
      const s = t[n];
      (!e || i1(this, this[s], s, e, !0)) && (delete this[s], i = !0);
    }
    return i;
  }
  normalize(e) {
    const t = this, n = {};
    return jt.forEach(this, (i, s) => {
      const l = jt.findKey(n, s);
      if (l) {
        t[l] = c_(i), delete t[s];
        return;
      }
      const o = e ? DY(s) : String(s).trim();
      o !== s && delete t[s], t[o] = c_(i), n[o] = !0;
    }), this;
  }
  concat() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.constructor.concat(this, ...t);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return jt.forEach(this, (n, i) => {
      n != null && n !== !1 && (t[i] = e && jt.isArray(n) ? n.join(", ") : n);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map((e) => {
      let [t, n] = e;
      return t + ": " + n;
    }).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e) {
    const t = new this(e);
    for (var n = arguments.length, i = new Array(n > 1 ? n - 1 : 0), s = 1; s < n; s++)
      i[s - 1] = arguments[s];
    return i.forEach((l) => t.set(l)), t;
  }
  static accessor(e) {
    const n = (this[HS] = this[HS] = {
      accessors: {}
    }).accessors, i = this.prototype;
    function s(l) {
      const o = jp(l);
      n[o] || (kY(i, l), n[o] = !0);
    }
    return jt.isArray(e) ? e.forEach(s) : s(e), this;
  }
};
Sa.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
jt.reduceDescriptors(Sa.prototype, (r, e) => {
  let {
    value: t
  } = r, n = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(i) {
      this[n] = i;
    }
  };
});
jt.freezeMethods(Sa);
function s1(r, e) {
  const t = this || Ng, n = e || t, i = Sa.from(n.headers);
  let s = n.data;
  return jt.forEach(r, function(o) {
    s = o.call(t, s, i.normalize(), e ? e.status : void 0);
  }), i.normalize(), s;
}
function DM(r) {
  return !!(r && r.__CANCEL__);
}
function np(r, e, t) {
  pn.call(this, r ?? "canceled", pn.ERR_CANCELED, e, t), this.name = "CanceledError";
}
jt.inherits(np, pn, {
  __CANCEL__: !0
});
function kM(r, e, t) {
  const n = t.config.validateStatus;
  !t.status || !n || n(t.status) ? r(t) : e(new pn("Request failed with status code " + t.status, [pn.ERR_BAD_REQUEST, pn.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4], t.config, t.request, t));
}
function FY(r) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(r);
  return e && e[1] || "";
}
function UY(r, e) {
  r = r || 10;
  const t = new Array(r), n = new Array(r);
  let i = 0, s = 0, l;
  return e = e !== void 0 ? e : 1e3, function(d) {
    const m = Date.now(), b = n[s];
    l || (l = m), t[i] = d, n[i] = m;
    let T = s, M = 0;
    for (; T !== i; )
      M += t[T++], T = T % r;
    if (i = (i + 1) % r, i === s && (s = (s + 1) % r), m - l < e)
      return;
    const E = b && m - b;
    return E ? Math.round(M * 1e3 / E) : void 0;
  };
}
function zY(r, e) {
  let t = 0, n = 1e3 / e, i, s;
  const l = function(m) {
    t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now(), i = null, s && (clearTimeout(s), s = null), r.apply(null, m);
  };
  return [function() {
    const m = Date.now(), b = m - t;
    for (var T = arguments.length, M = new Array(T), E = 0; E < T; E++)
      M[E] = arguments[E];
    b >= n ? l(M, m) : (i = M, s || (s = setTimeout(() => {
      s = null, l(i);
    }, n - b)));
  }, () => i && l(i)];
}
const Q_ = function(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3, n = 0;
  const i = UY(50, 250);
  return zY((s) => {
    const l = s.loaded, o = s.lengthComputable ? s.total : void 0, d = l - n, m = i(d), b = l <= o;
    n = l;
    const T = {
      loaded: l,
      total: o,
      progress: o ? l / o : void 0,
      bytes: d,
      rate: m || void 0,
      estimated: m && o && b ? (o - l) / m : void 0,
      event: s,
      lengthComputable: o != null,
      [e ? "download" : "upload"]: !0
    };
    r(T);
  }, t);
}, WS = (r, e) => {
  const t = r != null;
  return [(n) => e[0]({
    lengthComputable: t,
    total: r,
    loaded: n
  }), e[1]];
}, XS = (r) => function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return jt.asap(() => r(...t));
}, jY = $o.hasStandardBrowserEnv ? /* @__PURE__ */ ((r, e) => (t) => (t = new URL(t, $o.origin), r.protocol === t.protocol && r.host === t.host && (e || r.port === t.port)))(new URL($o.origin), $o.navigator && /(msie|trident)/i.test($o.navigator.userAgent)) : () => !0, VY = $o.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(r, e, t, n, i, s) {
      const l = [r + "=" + encodeURIComponent(e)];
      jt.isNumber(t) && l.push("expires=" + new Date(t).toGMTString()), jt.isString(n) && l.push("path=" + n), jt.isString(i) && l.push("domain=" + i), s === !0 && l.push("secure"), document.cookie = l.join("; ");
    },
    read(r) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + r + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(r) {
      this.write(r, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function qY(r) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(r);
}
function GY(r, e) {
  return e ? r.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : r;
}
function FM(r, e) {
  return r && !qY(e) ? GY(r, e) : e;
}
const ZS = (r) => r instanceof Sa ? {
  ...r
} : r;
function Mf(r, e) {
  e = e || {};
  const t = {};
  function n(m, b, T, M) {
    return jt.isPlainObject(m) && jt.isPlainObject(b) ? jt.merge.call({
      caseless: M
    }, m, b) : jt.isPlainObject(b) ? jt.merge({}, b) : jt.isArray(b) ? b.slice() : b;
  }
  function i(m, b, T, M) {
    if (jt.isUndefined(b)) {
      if (!jt.isUndefined(m))
        return n(void 0, m, T, M);
    } else return n(m, b, T, M);
  }
  function s(m, b) {
    if (!jt.isUndefined(b))
      return n(void 0, b);
  }
  function l(m, b) {
    if (jt.isUndefined(b)) {
      if (!jt.isUndefined(m))
        return n(void 0, m);
    } else return n(void 0, b);
  }
  function o(m, b, T) {
    if (T in e)
      return n(m, b);
    if (T in r)
      return n(void 0, m);
  }
  const d = {
    url: s,
    method: s,
    data: s,
    baseURL: l,
    transformRequest: l,
    transformResponse: l,
    paramsSerializer: l,
    timeout: l,
    timeoutMessage: l,
    withCredentials: l,
    withXSRFToken: l,
    adapter: l,
    responseType: l,
    xsrfCookieName: l,
    xsrfHeaderName: l,
    onUploadProgress: l,
    onDownloadProgress: l,
    decompress: l,
    maxContentLength: l,
    maxBodyLength: l,
    beforeRedirect: l,
    transport: l,
    httpAgent: l,
    httpsAgent: l,
    cancelToken: l,
    socketPath: l,
    responseEncoding: l,
    validateStatus: o,
    headers: (m, b, T) => i(ZS(m), ZS(b), T, !0)
  };
  return jt.forEach(Object.keys(Object.assign({}, r, e)), function(b) {
    const T = d[b] || i, M = T(r[b], e[b], b);
    jt.isUndefined(M) && T !== o || (t[b] = M);
  }), t;
}
const UM = (r) => {
  const e = Mf({}, r);
  let {
    data: t,
    withXSRFToken: n,
    xsrfHeaderName: i,
    xsrfCookieName: s,
    headers: l,
    auth: o
  } = e;
  e.headers = l = Sa.from(l), e.url = LM(FM(e.baseURL, e.url), r.params, r.paramsSerializer), o && l.set("Authorization", "Basic " + btoa((o.username || "") + ":" + (o.password ? unescape(encodeURIComponent(o.password)) : "")));
  let d;
  if (jt.isFormData(t)) {
    if ($o.hasStandardBrowserEnv || $o.hasStandardBrowserWebWorkerEnv)
      l.setContentType(void 0);
    else if ((d = l.getContentType()) !== !1) {
      const [m, ...b] = d ? d.split(";").map((T) => T.trim()).filter(Boolean) : [];
      l.setContentType([m || "multipart/form-data", ...b].join("; "));
    }
  }
  if ($o.hasStandardBrowserEnv && (n && jt.isFunction(n) && (n = n(e)), n || n !== !1 && jY(e.url))) {
    const m = i && s && VY.read(s);
    m && l.set(i, m);
  }
  return e;
}, $Y = typeof XMLHttpRequest < "u", HY = $Y && function(r) {
  return new Promise(function(t, n) {
    const i = UM(r);
    let s = i.data;
    const l = Sa.from(i.headers).normalize();
    let {
      responseType: o,
      onUploadProgress: d,
      onDownloadProgress: m
    } = i, b, T, M, E, D;
    function U() {
      E && E(), D && D(), i.cancelToken && i.cancelToken.unsubscribe(b), i.signal && i.signal.removeEventListener("abort", b);
    }
    let q = new XMLHttpRequest();
    q.open(i.method.toUpperCase(), i.url, !0), q.timeout = i.timeout;
    function G() {
      if (!q)
        return;
      const he = Sa.from("getAllResponseHeaders" in q && q.getAllResponseHeaders()), J = {
        data: !o || o === "text" || o === "json" ? q.responseText : q.response,
        status: q.status,
        statusText: q.statusText,
        headers: he,
        config: r,
        request: q
      };
      kM(function(ye) {
        t(ye), U();
      }, function(ye) {
        n(ye), U();
      }, J), q = null;
    }
    "onloadend" in q ? q.onloadend = G : q.onreadystatechange = function() {
      !q || q.readyState !== 4 || q.status === 0 && !(q.responseURL && q.responseURL.indexOf("file:") === 0) || setTimeout(G);
    }, q.onabort = function() {
      q && (n(new pn("Request aborted", pn.ECONNABORTED, r, q)), q = null);
    }, q.onerror = function() {
      n(new pn("Network Error", pn.ERR_NETWORK, r, q)), q = null;
    }, q.ontimeout = function() {
      let X = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded";
      const J = i.transitional || OM;
      i.timeoutErrorMessage && (X = i.timeoutErrorMessage), n(new pn(X, J.clarifyTimeoutError ? pn.ETIMEDOUT : pn.ECONNABORTED, r, q)), q = null;
    }, s === void 0 && l.setContentType(null), "setRequestHeader" in q && jt.forEach(l.toJSON(), function(X, J) {
      q.setRequestHeader(J, X);
    }), jt.isUndefined(i.withCredentials) || (q.withCredentials = !!i.withCredentials), o && o !== "json" && (q.responseType = i.responseType), m && ([M, D] = Q_(m, !0), q.addEventListener("progress", M)), d && q.upload && ([T, E] = Q_(d), q.upload.addEventListener("progress", T), q.upload.addEventListener("loadend", E)), (i.cancelToken || i.signal) && (b = (he) => {
      q && (n(!he || he.type ? new np(null, r, q) : he), q.abort(), q = null);
    }, i.cancelToken && i.cancelToken.subscribe(b), i.signal && (i.signal.aborted ? b() : i.signal.addEventListener("abort", b)));
    const Y = FY(i.url);
    if (Y && $o.protocols.indexOf(Y) === -1) {
      n(new pn("Unsupported protocol " + Y + ":", pn.ERR_BAD_REQUEST, r));
      return;
    }
    q.send(s || null);
  });
}, WY = (r, e) => {
  const {
    length: t
  } = r = r ? r.filter(Boolean) : [];
  if (e || t) {
    let n = new AbortController(), i;
    const s = function(m) {
      if (!i) {
        i = !0, o();
        const b = m instanceof Error ? m : this.reason;
        n.abort(b instanceof pn ? b : new np(b instanceof Error ? b.message : b));
      }
    };
    let l = e && setTimeout(() => {
      l = null, s(new pn(`timeout ${e} of ms exceeded`, pn.ETIMEDOUT));
    }, e);
    const o = () => {
      r && (l && clearTimeout(l), l = null, r.forEach((m) => {
        m.unsubscribe ? m.unsubscribe(s) : m.removeEventListener("abort", s);
      }), r = null);
    };
    r.forEach((m) => m.addEventListener("abort", s));
    const {
      signal: d
    } = n;
    return d.unsubscribe = () => jt.asap(o), d;
  }
}, XY = function* (r, e) {
  let t = r.byteLength;
  if (t < e) {
    yield r;
    return;
  }
  let n = 0, i;
  for (; n < t; )
    i = n + e, yield r.slice(n, i), n = i;
}, ZY = async function* (r, e) {
  for await (const t of YY(r))
    yield* XY(t, e);
}, YY = async function* (r) {
  if (r[Symbol.asyncIterator]) {
    yield* r;
    return;
  }
  const e = r.getReader();
  try {
    for (; ; ) {
      const {
        done: t,
        value: n
      } = await e.read();
      if (t)
        break;
      yield n;
    }
  } finally {
    await e.cancel();
  }
}, YS = (r, e, t, n) => {
  const i = ZY(r, e);
  let s = 0, l, o = (d) => {
    l || (l = !0, n && n(d));
  };
  return new ReadableStream({
    async pull(d) {
      try {
        const {
          done: m,
          value: b
        } = await i.next();
        if (m) {
          o(), d.close();
          return;
        }
        let T = b.byteLength;
        if (t) {
          let M = s += T;
          t(M);
        }
        d.enqueue(new Uint8Array(b));
      } catch (m) {
        throw o(m), m;
      }
    },
    cancel(d) {
      return o(d), i.return();
    }
  }, {
    highWaterMark: 2
  });
}, Uy = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", zM = Uy && typeof ReadableStream == "function", KY = Uy && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((r) => (e) => r.encode(e))(new TextEncoder()) : async (r) => new Uint8Array(await new Response(r).arrayBuffer())), jM = function(r) {
  try {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), n = 1; n < e; n++)
      t[n - 1] = arguments[n];
    return !!r(...t);
  } catch {
    return !1;
  }
}, JY = zM && jM(() => {
  let r = !1;
  const e = new Request($o.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return r = !0, "half";
    }
  }).headers.has("Content-Type");
  return r && !e;
}), KS = 64 * 1024, Lv = zM && jM(() => jt.isReadableStream(new Response("").body)), ey = {
  stream: Lv && ((r) => r.body)
};
Uy && ((r) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !ey[e] && (ey[e] = jt.isFunction(r[e]) ? (t) => t[e]() : (t, n) => {
      throw new pn(`Response type '${e}' is not supported`, pn.ERR_NOT_SUPPORT, n);
    });
  });
})(new Response());
const QY = async (r) => {
  if (r == null)
    return 0;
  if (jt.isBlob(r))
    return r.size;
  if (jt.isSpecCompliantForm(r))
    return (await new Request($o.origin, {
      method: "POST",
      body: r
    }).arrayBuffer()).byteLength;
  if (jt.isArrayBufferView(r) || jt.isArrayBuffer(r))
    return r.byteLength;
  if (jt.isURLSearchParams(r) && (r = r + ""), jt.isString(r))
    return (await KY(r)).byteLength;
}, eK = async (r, e) => {
  const t = jt.toFiniteNumber(r.getContentLength());
  return t ?? QY(e);
}, tK = Uy && (async (r) => {
  let {
    url: e,
    method: t,
    data: n,
    signal: i,
    cancelToken: s,
    timeout: l,
    onDownloadProgress: o,
    onUploadProgress: d,
    responseType: m,
    headers: b,
    withCredentials: T = "same-origin",
    fetchOptions: M
  } = UM(r);
  m = m ? (m + "").toLowerCase() : "text";
  let E = WY([i, s && s.toAbortSignal()], l), D;
  const U = E && E.unsubscribe && (() => {
    E.unsubscribe();
  });
  let q;
  try {
    if (d && JY && t !== "get" && t !== "head" && (q = await eK(b, n)) !== 0) {
      let J = new Request(e, {
        method: "POST",
        body: n,
        duplex: "half"
      }), ie;
      if (jt.isFormData(n) && (ie = J.headers.get("content-type")) && b.setContentType(ie), J.body) {
        const [ye, oe] = WS(q, Q_(XS(d)));
        n = YS(J.body, KS, ye, oe);
      }
    }
    jt.isString(T) || (T = T ? "include" : "omit");
    const G = "credentials" in Request.prototype;
    D = new Request(e, {
      ...M,
      signal: E,
      method: t.toUpperCase(),
      headers: b.normalize().toJSON(),
      body: n,
      duplex: "half",
      credentials: G ? T : void 0
    });
    let Y = await fetch(D);
    const he = Lv && (m === "stream" || m === "response");
    if (Lv && (o || he && U)) {
      const J = {};
      ["status", "statusText", "headers"].forEach((Re) => {
        J[Re] = Y[Re];
      });
      const ie = jt.toFiniteNumber(Y.headers.get("content-length")), [ye, oe] = o && WS(ie, Q_(XS(o), !0)) || [];
      Y = new Response(YS(Y.body, KS, ye, () => {
        oe && oe(), U && U();
      }), J);
    }
    m = m || "text";
    let X = await ey[jt.findKey(ey, m) || "text"](Y, r);
    return !he && U && U(), await new Promise((J, ie) => {
      kM(J, ie, {
        data: X,
        headers: Sa.from(Y.headers),
        status: Y.status,
        statusText: Y.statusText,
        config: r,
        request: D
      });
    });
  } catch (G) {
    throw U && U(), G && G.name === "TypeError" && /fetch/i.test(G.message) ? Object.assign(new pn("Network Error", pn.ERR_NETWORK, r, D), {
      cause: G.cause || G
    }) : pn.from(G, G && G.code, r, D);
  }
}), Ov = {
  http: mY,
  xhr: HY,
  fetch: tK
};
jt.forEach(Ov, (r, e) => {
  if (r) {
    try {
      Object.defineProperty(r, "name", {
        value: e
      });
    } catch {
    }
    Object.defineProperty(r, "adapterName", {
      value: e
    });
  }
});
const JS = (r) => `- ${r}`, rK = (r) => jt.isFunction(r) || r === null || r === !1, VM = {
  getAdapter: (r) => {
    r = jt.isArray(r) ? r : [r];
    const {
      length: e
    } = r;
    let t, n;
    const i = {};
    for (let s = 0; s < e; s++) {
      t = r[s];
      let l;
      if (n = t, !rK(t) && (n = Ov[(l = String(t)).toLowerCase()], n === void 0))
        throw new pn(`Unknown adapter '${l}'`);
      if (n)
        break;
      i[l || "#" + s] = n;
    }
    if (!n) {
      const s = Object.entries(i).map((o) => {
        let [d, m] = o;
        return `adapter ${d} ` + (m === !1 ? "is not supported by the environment" : "is not available in the build");
      });
      let l = e ? s.length > 1 ? `since :
` + s.map(JS).join(`
`) : " " + JS(s[0]) : "as no adapter specified";
      throw new pn("There is no suitable adapter to dispatch the request " + l, "ERR_NOT_SUPPORT");
    }
    return n;
  },
  adapters: Ov
};
function o1(r) {
  if (r.cancelToken && r.cancelToken.throwIfRequested(), r.signal && r.signal.aborted)
    throw new np(null, r);
}
function QS(r) {
  return o1(r), r.headers = Sa.from(r.headers), r.data = s1.call(r, r.transformRequest), ["post", "put", "patch"].indexOf(r.method) !== -1 && r.headers.setContentType("application/x-www-form-urlencoded", !1), VM.getAdapter(r.adapter || Ng.adapter)(r).then(function(n) {
    return o1(r), n.data = s1.call(r, r.transformResponse, n), n.headers = Sa.from(n.headers), n;
  }, function(n) {
    return DM(n) || (o1(r), n && n.response && (n.response.data = s1.call(r, r.transformResponse, n.response), n.response.headers = Sa.from(n.response.headers))), Promise.reject(n);
  });
}
const qM = "1.7.9", zy = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((r, e) => {
  zy[r] = function(n) {
    return typeof n === r || "a" + (e < 1 ? "n " : " ") + r;
  };
});
const eE = {};
zy.transitional = function(e, t, n) {
  function i(s, l) {
    return "[Axios v" + qM + "] Transitional option '" + s + "'" + l + (n ? ". " + n : "");
  }
  return (s, l, o) => {
    if (e === !1)
      throw new pn(i(l, " has been removed" + (t ? " in " + t : "")), pn.ERR_DEPRECATED);
    return t && !eE[l] && (eE[l] = !0, console.warn(i(l, " has been deprecated since v" + t + " and will be removed in the near future"))), e ? e(s, l, o) : !0;
  };
};
zy.spelling = function(e) {
  return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0);
};
function nK(r, e, t) {
  if (typeof r != "object")
    throw new pn("options must be an object", pn.ERR_BAD_OPTION_VALUE);
  const n = Object.keys(r);
  let i = n.length;
  for (; i-- > 0; ) {
    const s = n[i], l = e[s];
    if (l) {
      const o = r[s], d = o === void 0 || l(o, s, r);
      if (d !== !0)
        throw new pn("option " + s + " must be " + d, pn.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new pn("Unknown option " + s, pn.ERR_BAD_OPTION);
  }
}
const u_ = {
  assertOptions: nK,
  validators: zy
}, tu = u_.validators;
let Af = class {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new $S(),
      response: new $S()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (n) {
      if (n instanceof Error) {
        let i = {};
        Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error();
        const s = i.stack ? i.stack.replace(/^.+\n/, "") : "";
        try {
          n.stack ? s && !String(n.stack).endsWith(s.replace(/^.+\n.+\n/, "")) && (n.stack += `
` + s) : n.stack = s;
        } catch {
        }
      }
      throw n;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = Mf(this.defaults, t);
    const {
      transitional: n,
      paramsSerializer: i,
      headers: s
    } = t;
    n !== void 0 && u_.assertOptions(n, {
      silentJSONParsing: tu.transitional(tu.boolean),
      forcedJSONParsing: tu.transitional(tu.boolean),
      clarifyTimeoutError: tu.transitional(tu.boolean)
    }, !1), i != null && (jt.isFunction(i) ? t.paramsSerializer = {
      serialize: i
    } : u_.assertOptions(i, {
      encode: tu.function,
      serialize: tu.function
    }, !0)), u_.assertOptions(t, {
      baseUrl: tu.spelling("baseURL"),
      withXsrfToken: tu.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let l = s && jt.merge(s.common, s[t.method]);
    s && jt.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (D) => {
      delete s[D];
    }), t.headers = Sa.concat(l, s);
    const o = [];
    let d = !0;
    this.interceptors.request.forEach(function(U) {
      typeof U.runWhen == "function" && U.runWhen(t) === !1 || (d = d && U.synchronous, o.unshift(U.fulfilled, U.rejected));
    });
    const m = [];
    this.interceptors.response.forEach(function(U) {
      m.push(U.fulfilled, U.rejected);
    });
    let b, T = 0, M;
    if (!d) {
      const D = [QS.bind(this), void 0];
      for (D.unshift.apply(D, o), D.push.apply(D, m), M = D.length, b = Promise.resolve(t); T < M; )
        b = b.then(D[T++], D[T++]);
      return b;
    }
    M = o.length;
    let E = t;
    for (T = 0; T < M; ) {
      const D = o[T++], U = o[T++];
      try {
        E = D(E);
      } catch (q) {
        U.call(this, q);
        break;
      }
    }
    try {
      b = QS.call(this, E);
    } catch (D) {
      return Promise.reject(D);
    }
    for (T = 0, M = m.length; T < M; )
      b = b.then(m[T++], m[T++]);
    return b;
  }
  getUri(e) {
    e = Mf(this.defaults, e);
    const t = FM(e.baseURL, e.url);
    return LM(t, e.params, e.paramsSerializer);
  }
};
jt.forEach(["delete", "get", "head", "options"], function(e) {
  Af.prototype[e] = function(t, n) {
    return this.request(Mf(n || {}, {
      method: e,
      url: t,
      data: (n || {}).data
    }));
  };
});
jt.forEach(["post", "put", "patch"], function(e) {
  function t(n) {
    return function(s, l, o) {
      return this.request(Mf(o || {}, {
        method: e,
        headers: n ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: s,
        data: l
      }));
    };
  }
  Af.prototype[e] = t(), Af.prototype[e + "Form"] = t(!0);
});
let iK = class GM {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(s) {
      t = s;
    });
    const n = this;
    this.promise.then((i) => {
      if (!n._listeners) return;
      let s = n._listeners.length;
      for (; s-- > 0; )
        n._listeners[s](i);
      n._listeners = null;
    }), this.promise.then = (i) => {
      let s;
      const l = new Promise((o) => {
        n.subscribe(o), s = o;
      }).then(i);
      return l.cancel = function() {
        n.unsubscribe(s);
      }, l;
    }, e(function(s, l, o) {
      n.reason || (n.reason = new np(s, l, o), t(n.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), t = (n) => {
      e.abort(n);
    };
    return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new GM(function(i) {
        e = i;
      }),
      cancel: e
    };
  }
};
function sK(r) {
  return function(t) {
    return r.apply(null, t);
  };
}
function oK(r) {
  return jt.isObject(r) && r.isAxiosError === !0;
}
const Nv = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(Nv).forEach((r) => {
  let [e, t] = r;
  Nv[t] = e;
});
function $M(r) {
  const e = new Af(r), t = xM(Af.prototype.request, e);
  return jt.extend(t, Af.prototype, e, {
    allOwnKeys: !0
  }), jt.extend(t, e, null, {
    allOwnKeys: !0
  }), t.create = function(i) {
    return $M(Mf(r, i));
  }, t;
}
const Es = $M(Ng);
Es.Axios = Af;
Es.CanceledError = np;
Es.CancelToken = iK;
Es.isCancel = DM;
Es.VERSION = qM;
Es.toFormData = Fy;
Es.AxiosError = pn;
Es.Cancel = Es.CanceledError;
Es.all = function(e) {
  return Promise.all(e);
};
Es.spread = sK;
Es.isAxiosError = oK;
Es.mergeConfig = Mf;
Es.AxiosHeaders = Sa;
Es.formToJSON = (r) => NM(jt.isHTMLForm(r) ? new FormData(r) : r);
Es.getAdapter = VM.getAdapter;
Es.HttpStatusCode = Nv;
Es.default = Es;
const {
  Axios: MK,
  AxiosError: PK,
  CanceledError: RK,
  isCancel: BK,
  CancelToken: LK,
  VERSION: OK,
  all: NK,
  Cancel: DK,
  isAxiosError: kK,
  spread: FK,
  toFormData: UK,
  AxiosHeaders: zK,
  HttpStatusCode: jK,
  formToJSON: VK,
  getAdapter: qK,
  mergeConfig: GK
} = Es, aK = "https://eines.icgc.cat/recursos/mapicgc-gl-js/mapicgc-config.json", lK = 5e3;
class cK {
  static async getConfigICGC() {
    try {
      const e = await Es.get(aK, {
        timeout: lK
      });
      return e.data ? e.data : (console.log("Resposta sense dades:", e), df);
    } catch (e) {
      return e.response ? (console.error("Error de resposta:", e.response.data), console.error("Codi d'estat:", e.response.status)) : e.request ? console.error("No s'ha rebut resposta del servidor:", e.request) : console.error("Error:", e.message), df;
    }
  }
}
const uK = {
  "fill-opacity": ["interpolate", ["exponential", 0.5], ["zoom"], 13.5, 1, 18, 0.4],
  "fill-outline-color": "rgba(0,0, 0, 0)",
  "fill-color": ["interpolate", ["cubic-bezier", 0.5, 1, 1, 1], ["get", "nivell_2"], 0, "#ffffff", 111, "#ffff00", 112, "#ccff33", 113, "#af5b15", 114, "#808000", 115, "#cdcd00", 116, "#ffffcc", 221, "#33cc33", 222, "#66ff33", 223, "#689018", 224, "#967d5f", 225, "#19e61e", 226, "#b4ff9b", 227, "#aaa500", 228, "#c3c3a0", 229, "#00ff9b", 230, "#ff9632", 231, "#282828", 232, "#79797a", 233, "#f5df78", 234, "#3296ff", 341, "#ff007d", 342, "#ff53cd", 343, "#ffa4e2", 344, "#ffc8e2", 345, "#ffb4b4", 346, "#0f3700", 347, "#730055", 348, "#6200c4", 349, "#4a9595", 350, "#ff00f0", 351, "#adaaca", 352, "#ffe6e6", 353, "#67629a", 354, "#4a466e", 355, "#2f2d46", 461, "#6f6fff", 462, "#0000dc", 463, "#000064", 464, "#185f94", 465, "#12466d", 466, "#000080"]
}, hK = {
  cobertesSol: uK
}, fK = "lines", Vm = "labels";
let Za, rf, Vp, os, ei, $K = class {
  /**
   * Constructor for the Map class.
   * @param {Object} options - Options to initialize the map.
   */
  constructor(e) {
    cK.getConfigICGC().then((t) => {
      rf = {
        ...t.Styles
      }, os = {
        ...t.Layers
      }, Vp = {
        ...t.Terrains
      }, ei = {
        ...t.defaultOptions
      }, this.initTheMap(e);
    }).catch((t) => {
      console.info("Configuracio per defecte", t), rf = {
        ...df.Styles
      }, os = {
        ...df.Layers
      }, Vp = {
        ...df.Terrains
      }, ei = {
        ...df.defaultOptions
      }, this.initTheMap(e);
    });
  }
  initTheMap(e) {
    if (!e)
      e = ei.mapOptions;
    else
      for (const n in ei.mapOptions) {
        let i = [ei.mapOptions.center[0], ei.mapOptions.center[1]];
        ei.mapOptions.center = i, e.hasOwnProperty(n) || (e[n] = ei.mapOptions[n]);
      }
    e.maxPitch = 85, e.maplibreLogo = !1, e.attributionControl = !1;
    const t = e.style.includes("https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/");
    t ? (this.map = new io.Map({
      container: e.container,
      center: e.center,
      zoom: e.zoom,
      pitch: e.pitch || 0,
      hash: e.hash || !1,
      style: {
        version: 8,
        sources: {},
        layers: []
      }
    }), this.map.on("load", () => {
      this.map.addSource("raster-source", {
        type: "raster",
        tiles: [e.style],
        // URL del raster
        tileSize: 256
      }), this.map.addLayer({
        id: "raster-layer",
        type: "raster",
        source: "raster-source"
      });
    })) : this.map = new io.Map(e), this.map.on("load", () => {
      if (!t) {
        const n = this.map.getStyle().name, i = e.style;
        this.map.addControl(new SZ({
          color: i.indexOf("orto") === -1,
          defaultOptions: ei
        }), "bottom-left"), this._dealOrto3dStyle(n);
      }
    });
  }
  /**
   * Add geocoder with customizable options.
   * @function addGeocoderICGC
   * @param {Object} [options={}] - Optional configuration options for the geocoder. Defaults to an empty object.
   * @param {string} [position='top-right'] - Position to add the geocoder control on the map. Defaults to 'top-right'.
   * @returns {Object} - The merged configuration options for the geocoder, including the position.
   *
   */
  addGeocoderICGC() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top-right";
    try {
      e = {
        ...{
          collapsed: !0,
          marker: !0,
          zoom: 16,
          popup: !0,
          showResultMarkers: !0,
          maplibregl: io,
          showResultsWhileTyping: !0,
          minLength: 2
        },
        ...e
      };
      const i = {
        forwardGeocode: async (l) => {
          const o = [];
          try {
            const d = ei.geocoder.peliasUrl1 + encodeURIComponent(l.query) + ei.geocoder.peliasUrl2, b = await (await fetch(d)).json();
            for (const T of b.features) {
              const M = T.geometry.coordinates, E = {
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: M
                },
                place_name: T.properties.etiqueta,
                properties: T.properties,
                text: T.properties.etiqueta,
                place_type: ["place"],
                center: M
              };
              o.push(E);
            }
          } catch (d) {
            console.error(`Failed to forwardGeocode with error: ${d}`);
          }
          return {
            features: o
          };
        }
      };
      this.map.addControl(new vZ(i, e), t);
      let s = document.getElementsByClassName("maplibregl-ctrl-geocoder--input");
      s[0].attributes[2].nodeValue = "Cerca...", s[0].addEventListener("input", function(l) {
        l.target.value.length > 3;
      });
    } catch (n) {
      console.error(`Error adding ICGC geocoder: ${n.message}`);
    }
  }
  //geocoder ends
  async loadImage(e) {
    try {
      return this.map.loadImage(e);
    } catch (t) {
      console.error(`Error getting loadImage: ${t.message}`);
    }
  }
  /**
   * Retrieves the available base styles from default options.
   * @function getConfigStyles
   * @returns {Array} - Array containing the names of available base styles.
   */
  getConfigStyles() {
    try {
      let e = [];
      for (const t of rf)
        e.push(t.name);
      return e;
    } catch (e) {
      console.error(`Error retrieving base styles: ${e.message}`);
    }
  }
  /**
   * Retrieves the available WMS image layers from default options.
   * @function getConfigWMSLayers
   * @returns {Array} - Array containing the keys of available WMS image layers.
   */
  getConfigWMSLayers() {
    try {
      let e = [];
      for (const t in os.WMS)
        os.WMS.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving WMS layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available orto image layers from default options.
   * @function getConfigOrtoLayers
   * @returns {Array} - Array containing the keys of available image layers.
   */
  getConfigOrtoLayers() {
    try {
      let e = [];
      for (const t in os.Orto)
        os.Orto.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving orto image layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorLayers
   * @returns {Array} - Array containing the keys of available vector layers.
   */
  getConfigVectorLayers() {
    try {
      let e = [];
      for (const t in os.Vector)
        os.Vector.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vector layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorAdminLayers
   * @returns {Array} - Array containing the keys of available vectorAdmin layers.
   */
  getConfigVectorAdminLayers() {
    try {
      let e = [];
      for (const t in os.VectorAdmin)
        os.VectorAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vectorAdmin layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available fgb layers from default options.
   * @function getConfigFGBAdminLayers
   * @returns {Array} - Array containing the keys of available fgbadmin layers.
   */
  getConfigFGBAdminLayers() {
    try {
      let e = [];
      for (const t in os.FGBAdmin)
        os.FGBAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving FGBAdmin layers: ${e.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The id for the layer.
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchData(e, t, n) {
    try {
      (!n || n === void 0) && (n = {
        type: "line",
        layout: {
          visibility: "visible"
        },
        paint: {
          "line-color": "grey",
          "line-width": 2
        },
        layerPosition: "top"
        // select: 'top', 'lines' or 'labels'
      });
      let i = n.layerPosition;
      if (e.includes(".fgb"))
        this.addFGBLayerICGC(e, t, n);
      else {
        const l = await (await fetch(e)).json();
        let o = t, d = this._dealOrderLayer(i), m = l.features[0].geometry.type;
        m.includes("ine") && (n !== void 0 ? this.map.addLayer({
          id: o,
          type: "line",
          source: {
            type: "geojson",
            data: l
          },
          layout: n.layout || {},
          paint: n.paint || {}
        }, d) : this.map.addLayer({
          id: o,
          type: "line",
          source: {
            type: "geojson",
            data: l
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "line-color": "black",
            "line-width": 2,
            "line-opacity": 1
          }
        }, d)), m.includes("olygon") && (n !== void 0 ? this.map.addLayer({
          id: o,
          type: "fill",
          source: {
            type: "geojson",
            data: l
          },
          layout: n.layout,
          paint: n.paint
        }, d) : this.map.addLayer({
          id: o,
          type: "fill",
          source: {
            type: "geojson",
            data: l
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "fill-color": "blue",
            "fill-opacity": 0.6
          }
        }, d)), m.includes("oint") && (n !== void 0 ? this.map.addLayer({
          id: o,
          type: "circle",
          source: {
            type: "geojson",
            data: l
          },
          layout: n.layout,
          paint: n.paint
        }, d) : this.map.addLayer({
          id: o,
          type: "circle",
          source: {
            type: "geojson",
            data: l
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "circle-color": "red",
            "circle-opacity": 0.85
          }
        }, d));
      }
    } catch (i) {
      console.error(`Error fetching data: ${i.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type and adds to the Menu as a checkbox item.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The geometry name (e.g., 'buildings').
   * @param {string} filterField - Import all features as unique or group based on a field ('all', 'field').
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchDataAndMenu(e, t, n, i) {
    try {
      let s;
      i !== null ? s = i.layerPosition : s = Vm;
      let l, o = document.getElementById("map");
      if (document.getElementById("menu-group") ? l = document.getElementById("menu-group") : (l = document.createElement("nav"), l.id = "menu-group", l.classList.add = "filter-group", o.appendChild(l)), l !== null) {
        let d = "visible", m = this._dealOrderLayer(s), b;
        if (e.includes(".fgb")) {
          let M = this._getKeyByUrlFGB(e);
          M === null && (M = "userFGB");
          const E = await fetch(e), D = {
            type: "FeatureCollection",
            features: []
          };
          for await (const q of Yw(E.body)) D.features.push(q);
          b = D;
          let U = t;
          if (this.map.addSource(U, {
            type: "geojson",
            data: D
          }), e.includes("text"))
            i !== void 0 ? this.map.addLayer({
              id: t,
              type: "symbol",
              source: U,
              layout: i.layout,
              paint: i.paint
            }, m) : this.map.addLayer({
              id: t,
              type: "symbol",
              source: U,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: d,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, m);
          else {
            let q = t + "Text";
            this.map.addLayer({
              id: q,
              type: "symbol",
              source: U,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: d,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, m);
          }
        } else
          b = await (await fetch(e)).json();
        if (n !== "all") {
          const M = document.createElement("div");
          M.id = "titleDivMenu", M.textContent = t, l.appendChild(M);
          const E = document.createElement("div");
          E.id = "titleDivMenuSub", E.textContent = ` ${n}`, l.appendChild(E);
        }
        let T;
        if (i.type ? T = i.type : T = b.features[0].geometry.type, n === "all")
          T.includes("ine") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: b
            },
            layout: i.layout,
            paint: i.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: b
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "line-color": "black",
              "line-width": 2,
              "line-opacity": 1
            }
          }, m)), T.includes("olygon") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: b
            },
            layout: i.layout,
            paint: i.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: b
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "fill-color": "#0000FF",
              "fill-opacity": 0
            }
          }, m)), T.includes("oint") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: b
            },
            layout: i.layout,
            paint: i.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: b
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "circle-color": "red",
              "circle-opacity": 0.85
            }
          }, m)), T.includes("ymbol") && (i !== void 0 ? this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: b
            },
            layout: i.layout,
            paint: i.paint
          }, m) : this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: b
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "text-halo-blur": 0.5,
              "text-color": "rgba(90, 7, 7, 1)",
              "text-halo-width": 2,
              "text-halo-color": "rgba(255, 255, 255,0.8)"
            }
          }, m)), this.addMenuItem(t);
        else {
          let M = n;
          const E = {};
          b.features.forEach((D) => {
            const U = D.properties[M], q = U + "-userFieldFilter-" + t;
            U !== null && (E[q] || (T.includes("ine") && (i !== void 0 ? this.map.addLayer({
              id: q,
              type: "line",
              source: {
                type: "geojson",
                data: b
              },
              layout: i.layout,
              paint: i.paint,
              filter: ["==", `${M}`, U]
            }, m) : this.map.addLayer({
              id: q,
              type: "line",
              source: {
                type: "geojson",
                data: b
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${M}`, U],
              paint: {
                "line-color": "black",
                "line-width": 2,
                "line-opacity": 1
              }
            }, m)), T.includes("olygon") && (i !== void 0 ? this.map.addLayer({
              id: q,
              type: "fill",
              source: {
                type: "geojson",
                data: b
              },
              filter: ["==", `${M}`, U],
              layout: i.layout,
              paint: i.paint
            }, m) : this.map.addLayer({
              id: q,
              type: "fill",
              source: {
                type: "geojson",
                data: b
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${M}`, U],
              paint: {
                "fill-color": "blue",
                "fill-opacity": 0.6
              }
            }, m)), T.includes("oint") && (i !== void 0 ? this.map.addLayer({
              id: q,
              type: "circle",
              source: {
                type: "geojson",
                data: b
              },
              filter: ["==", `${M}`, U],
              layout: i.layout,
              paint: i.paint
            }, m) : this.map.addLayer({
              id: q,
              type: "circle",
              source: {
                type: "geojson",
                data: b
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${M}`, U],
              paint: {
                "circle-color": "red",
                "circle-opacity": 0.85
              }
            }, m)), E[q] = !0, this.addMenuItem(q)));
          });
        }
      }
    } catch (s) {
      console.error(`Error fetching data: ${s.message}`);
    }
  }
  /**
   * Adds an event listener to the map.
   * @function on
   * @param {string} type - The type of the event.
   * @param {Function} func - The callback function to be executed when the event occurs.
   */
  on(e, t) {
    setTimeout(() => {
      try {
        return this.map.on(e, t);
      } catch (n) {
        console.error(`Error adding event ON listener: ${n.message}`);
      }
    }, 100);
  }
  /**
   * Sets the style of the map.
   * @function setStyle
   * @param {string} style - Name of the map style.
   * @param {Object} [options] - Options for setting the style.
   */
  setStyle(e, t) {
    try {
      t !== void 0 ? this.map.setStyle(e, t) : this.map.setStyle(e), this.map.on("styledata", () => {
        if (window.document.querySelector(".maplibregl-compact-show")) {
          var n = window.document.querySelector(".maplibregl-compact-show");
          n.classList.remove("maplibregl-compact-show");
        }
        this._dealOrto3dStyle(this.map.getStyle().name);
      });
    } catch (n) {
      console.error(`Error setting style: ${n.message}`);
    }
  }
  /**
   * Adds a control to the map with the specified position.
   * @function addControl
   * @param {Object} control - The control to add.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(e, t);
    } catch (n) {
      console.error(`Error adding control: ${n.message}`);
    }
  }
  /**
   * Sets the sky properties of the map.
   * @function setSky
   * @param {Object} options - Options to set the sky properties.
   * @param {string} [options.skyType='gradient'] - Type of sky to set (e.g., 'gradient', 'atmosphere').
   * @param {string} [options.color='lightblue'] - Color of the sky.
   * @param {Number} [options.horizonBlend=0.03] - Blend horizon value.
   * @param {Number} [options.starIntensity=0.5] - Intensity of stars in the sky.
   * @param {Number} [options.sunIntensity=0.1] - Intensity of the sun in the sky.
   * @param {Array<Number>} [options.sunPosition=[0, 0]] - Position of the sun in the sky.
   */
  setSky(e) {
    try {
      e === void 0 && (this.map.style.stylesheet.id.includes("orto") ? e = {
        "sky-color": "#86bbd5",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#ffffff33",
        "horizon-fog-blend": 0.1,
        "fog-ground-blend": 0.75,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("mapa_estandard_general") ? e = {
        "sky-color": "#a5f0f0",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#e1e3e3",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("icgc_mapa_vissir") ? e = {
        "sky-color": "#a5f0f0",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#e1e3e3",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("fosc") ? e = {
        "sky-color": "#232423",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#969996",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#383838"
      } : e = {
        "sky-color": "#86bbd5",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#ffffff33",
        "horizon-fog-blend": 0.1,
        "fog-ground-blend": 0.75,
        "fog-color": "#c5d6d6"
      }), this.map.setSky(e);
    } catch (t) {
      console.error(`Error setting sky properties: ${t.message}`);
    }
  }
  /**
   * Adds a mouse coordinate control to the map.
   * @function addMouseCoordControl
   * @param {Number} options.width - Width control i.
   * @param {Boolean} options.utm - Boolean to show coordinates in UTM.
   * @param {Boolean} options.lonlat - Boolean to show coordinates in Lon Lat.
   * @param {string} [position='bottom-left'] - Position to add the control on the map.
   */
  addMouseCoordControl(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "bottom-left";
    try {
      this.map.addControl(new PZ(e), t);
    } catch (n) {
      console.error(`Error adding mouse coordinate control: ${n.message}`);
    }
  }
  /**
   * Adds a geolocate control to the map.
   * @function addGeolocateControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addGeolocateControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new io.GeolocateControl({
        positionOptions: {
          enableHighAccuracy: !0
        },
        trackUserLocation: !0
      }), t) : this.map.addControl(new io.GeolocateControl(e), t);
    } catch (n) {
      console.error(`Error adding geolocate control: ${n.message}`);
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullscreenControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullscreenControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new io.FullscreenControl({
        container: HTMLElement
      }), t) : this.map.addControl(new io.FullscreenControl(e), t);
    } catch (n) {
      console.error(`Error adding fullscreen control: ${n.message}`);
    }
  }
  /**
   * Adds a layer to the map.
   * @function addLayer
   * @param {Object} layer - Options for the layer to add.
   * @param {string} layerIdOrder - Optional layer Id draw position.
   */
  addLayer(e, t) {
    try {
      this.map.addLayer(e, t);
    } catch (n) {
      console.error(`Error adding layer: ${n.message}`);
    }
  }
  //add maplibre methods
  /**
   * Adds an image to the map.
   * @function addImage
   * @param {string} id - The ID of the image.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The image object to add.
   * @param {Partial<StyleImageMetadata>} options - Optional metadata for the image.
   * @returns {this}
   */
  addImage(e, t, n) {
    try {
      this.map.addImage(e, t, n);
    } catch (i) {
      console.error(`Error adding image: ${i.message}`);
    }
    return this;
  }
  /**
   * Adds a source to the map.
   * @function addSource
   * @param {string} id - The ID of the source.
   * @param {SourceSpecification} source - The source object to add.
   * @returns {this}
   */
  addSource(e, t) {
    try {
      this.map.addSource(e, t);
    } catch (n) {
      console.error(`Error adding source: ${n.message}`);
    }
    return this;
  }
  /**
   * Adds a sprite to the map.
   * @function addSprite
   * @param {string} id - The ID of the sprite.
   * @param {string} url - The URL to load the sprite from.
   * @param {StyleSetterOptions} options - Options object.
   * @returns {this}
   */
  addSprite(e, t, n) {
    try {
      this.map.addSprite(e, t, n);
    } catch (i) {
      console.error(`Error adding sprite: ${i.message}`);
    }
    return this;
  }
  /**
   * Checks if all tiles in the viewport are loaded.
   * @function areTilesLoaded
   * @returns {boolean}
   */
  areTilesLoaded() {
    return this.map.areTilesLoaded();
  }
  /**
   * Calculates the camera position for given bounds.
   * @function cameraForBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {CameraForBoundsOptions} options - Options object.
   * @returns {CenterZoomBearing | undefined}
   */
  cameraForBounds(e, t) {
    return this.map.cameraForBounds(e, t);
  }
  /**
   * Eases the camera to a new position.
   * @function easeTo
   * @param {object} options - Options describing the animation.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  easeTo(e, t) {
    return this.map.easeTo(e, t), this;
  }
  /**
   * Fits the map to the given geographical bounds.
   * @function fitBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitBounds(e, t, n) {
    return this.map.fitBounds(e, t, n), this;
  }
  /**
   * Fits the map to the given screen coordinates.
   * @function fitScreenCoordinates
   * @param {PointLike} p0 - First point on screen, in pixel coordinates.
   * @param {PointLike} p1 - Second point on screen, in pixel coordinates.
   * @param {number} bearing - Desired map bearing at end of animation, in degrees.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitScreenCoordinates(e, t, n, i, s) {
    return this.map.fitScreenCoordinates(e, t, n, i, s), this;
  }
  /**
   * Flies the camera to a new position.
   * @function flyTo
   * @param {FlyToOptions} options - Options describing the flight.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  flyTo(e, t) {
    return this.map.flyTo(e, t), this;
  }
  /**
   * Gets the current bearing of the map.
   * @function getBearing
   * @returns {number}
   */
  getBearing() {
    return this.map.getBearing();
  }
  /**
   * Gets the current geographical bounds of the map.
   * @function getBounds
   * @returns {LngLatBounds}
   */
  getBounds() {
    return this.map.getBounds();
  }
  /**
   * Gets the elevation for the point where the camera is looking.
   * @function getCameraTargetElevation
   * @returns {number}
   */
  getCameraTargetElevation() {
    return this.map.getCameraTargetElevation();
  }
  /**
   * Gets the map's <canvas> element.
   * @function getCanvas
   * @returns {HTMLCanvasElement}
   */
  getCanvas() {
    return this.map.getCanvas();
  }
  /**
   * Gets the HTML element containing the map's <canvas> element.
   * @function getCanvasContainer
   * @returns {HTMLElement}
   */
  getCanvasContainer() {
    return this.map.getCanvasContainer();
  }
  /**
   * Returns the map's geographical centerpoint.
   * @function getCenter
   * @returns {LngLat} The map's geographical centerpoint.
   */
  getCenter() {
    return this.map.getCenter();
  }
  /**
   * Returns the map's containing HTML element.
   * @function getContainer
   * @returns {HTMLElement} The map's container.
   */
  getContainer() {
    return this.map.getContainer();
  }
  /**
   * Gets the state of a feature.
   * @function getFeatureState
   * @param {FeatureIdentifier} feature - Feature identifier.
   * @returns {any} The state of the feature.
   */
  getFeatureState(e) {
    return this.map.getFeatureState(e);
  }
  /**
   * Returns the filter applied to the specified style layer.
   * @function getFilter
   * @param {string} layerId - The ID of the style layer.
   * @returns {void | FilterSpecification} The layer's filter.
   */
  getFilter(e) {
    return this.map.getFilter(e);
  }
  /**
   * Returns the value of the style's glyphs URL.
   * @function getGlyphs
   * @returns {string} The glyphs Style's glyphs URL.
   */
  getGlyphs() {
    return this.map.getGlyphs();
  }
  /**
   * Returns an image currently available in the map.
   * @function getImage
   * @param {string} id - The ID of the image.
   * @returns {StyleImage} An image in the map with the specified ID.
   */
  getImage(e) {
    return this.map.getImage(e);
  }
  /**
   * Returns the layer with the specified ID in the map's style.
   * @function getLayer
   * @param {string} id - The ID of the layer to get.
   * @returns {StyleLayer} The layer with the specified ID.
   */
  getLayer(e) {
    return this.map.getLayer(e);
  }
  /**
   * Return the ids of all layers currently in the style, including custom layers, in order.
   * @function getLayersOrder
   * @returns {string[]} Ids of layers, in order.
   */
  getLayersOrder() {
    return this.map.getLayersOrder();
  }
  /**
   * Returns the value of a layout property in the specified style layer.
   * @function getLayoutProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of the layout property.
   * @returns {any} The value of the specified layout property.
   */
  getLayoutProperty(e, t) {
    return this.map.getLayoutProperty(e, t);
  }
  /**
   * Returns the value of the light object.
   * @function getLight
   * @returns {LightSpecification} Light properties of the style.
   */
  getLight() {
    return this.map.getLight();
  }
  /**
   * Returns the maximum geographical bounds the map is constrained to.
   * @function getMaxBounds
   * @returns {LngLatBounds} The map's maximum geographical bounds.
   */
  getMaxBounds() {
    return this.map.getMaxBounds();
  }
  /**
   * Returns the map's maximum allowable pitch.
   * @function getMaxPitch
   * @returns {number} The maxPitch.
   */
  getMaxPitch() {
    return this.map.getMaxPitch();
  }
  /**
   * Returns the map's maximum allowable zoom level.
   * @function getMaxZoom
   * @returns {number} The maxZoom.
   */
  getMaxZoom() {
    return this.map.getMaxZoom();
  }
  /**
   * Returns the map's minimum allowable pitch.
   * @function getMinPitch
   * @returns {number} The minPitch.
   */
  getMinPitch() {
    return this.map.getMinPitch();
  }
  /**
   * Returns the map's minimum allowable zoom level.
   * @function getMinZoom
   * @returns {number} The minZoom.
   */
  getMinZoom() {
    return this.map.getMinZoom();
  }
  /**
   * Returns the current padding applied around the map viewport.
   * @function getPadding
   * @returns {PaddingOptions} The current padding around the map viewport.
   */
  getPadding() {
    return this.map.getPadding();
  }
  /**
   * Returns the value of a paint property in the specified style layer.
   * @function getPaintProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of a paint property.
   * @returns {unknown} The value of the specified paint property.
   */
  getPaintProperty(e, t) {
    return this.map.getPaintProperty(e, t);
  }
  /**
   * Returns the map's current pitch (tilt).
   * @function getPitch
   * @returns {number} The map's current pitch, measured in degrees away from the plane of the screen.
   */
  getPitch() {
    return this.map.getPitch();
  }
  /**
   * Returns the map's pixel ratio.
   * @function getPixelRatio
   * @returns {number} The pixel ratio.
   */
  getPixelRatio() {
    return this.map.getPixelRatio();
  }
  /**
   * Returns the state of renderWorldCopies.
   * @function getRenderWorldCopies
   * @returns {boolean} The renderWorldCopies.
   */
  getRenderWorldCopies() {
    return this.map.getRenderWorldCopies();
  }
  /**
   * Returns the source with the specified ID in the map's style.
   * @function getSource
   * @param {string} id - The ID of the source to get.
   * @returns {Source} The style source with the specified ID.
   */
  getSource(e) {
    return this.map.getSource(e);
  }
  /**
   * Returns the as-is value of the style's sprite.
   * @function getSprite
   * @returns {object[]} Style's sprite list of id-url pairs.
   */
  getSprite() {
    return this.map.getSprite();
  }
  /**
   * Returns the map's MapLibre style object.
   * @function getStyle
   * @returns {StyleSpecification} The map's style JSON object.
   */
  getStyle() {
    return this.map.getStyle();
  }
  /**
   * Get the terrain-options if terrain is loaded.
   * @function getTerrain
   * @returns {TerrainSpecification} The TerrainSpecification passed to setTerrain.
   */
  getTerrain() {
    return this.map.getTerrain();
  }
  //  Function getZoom()
  /**
   * Returns the map's current zoom level.
   * @function getZoom
   * @returns {number} The map's current zoom level.
   */
  getZoom() {
    return this.map.getZoom();
  }
  //  Function hasControl()
  /**
   * Checks if a control exists on the map.
   * @function hasControl
   * @param {IControl} control - The IControl to check.
   * @returns {boolean} true if map contains control.
   */
  hasControl(e) {
    return this.map.hasControl(e);
  }
  //  Function hasImage()
  /**
   * Check whether or not an image with a specific ID exists in the style.
   * @function hasImage
   * @param {string} id - The ID of the image.
   * @returns {boolean} A Boolean indicating whether the image exists.
   */
  hasImage(e) {
    return this.map.hasImage(e);
  }
  //  Function isMoving()
  /**
   * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.
   * @function isMoving
   * @returns {boolean} true if the map is moving.
   */
  isMoving() {
    return this.map.isMoving();
  }
  //  Function isRotating()
  /**
   * Returns true if the map is rotating due to a camera animation or user gesture.
   * @function isRotating
   * @returns {boolean} true if the map is rotating.
   */
  isRotating() {
    return this.map.isRotating();
  }
  //  Function isSourceLoaded()
  /**
   * Returns a Boolean indicating whether the source is loaded.
   * @function isSourceLoaded
   * @param {string} id - The ID of the source to be checked.
   * @returns {boolean} A Boolean indicating whether the source is loaded.
   */
  isSourceLoaded(e) {
    return this.map.isSourceLoaded(e);
  }
  //  Function isStyleLoaded()
  /**
   * Returns a Boolean indicating whether the map's style is fully loaded.
   * @function isStyleLoaded
   * @returns {boolean | void} A Boolean indicating whether the style is fully loaded.
   */
  isStyleLoaded() {
    return this.map.isStyleLoaded();
  }
  //  Function isZooming()
  /**
   * Returns true if the map is zooming due to a camera animation or user gesture.
   * @function isZooming
   * @returns {boolean} true if the map is zooming.
   */
  isZooming() {
    return this.map.isZooming();
  }
  //  Function jumpTo()
  /**
   * Changes any combination of center, zoom, bearing, and pitch, without an animated transition.
   * @function jumpTo
   * @param {JumpToOptions} options - Options object
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  jumpTo(e, t) {
    return this.map.jumpTo(e, t);
  }
  //  Function listImages()
  /**
   * Returns an Array of strings containing the IDs of all images currently available in the map.
   * @function listImages
   * @returns {string[]} An Array of strings containing the names of all sprites/images currently available in the map.
   */
  listImages() {
    return this.map.listImages();
  }
  //  Function listens()
  /**
   * Returns a true if this instance of Evented or any forwardeed instances of Evented have a listener for the specified type.
   * @function listens
   * @param {string} type - The event type.
   * @returns {boolean} true if there is at least one registered listener for specified event type, false otherwise.
   */
  listens(e) {
    return this.map.listens(e);
  }
  //  Function loadImage()
  /**
   * Load an image from an external URL to be used with Map#addImage.
   * @function loadImage
   * @param {string} url - The URL of the image file. Image file must be in png, webp, or jpg format.
   * @returns {Promise<GetResourceResponse<ImageBitmap | HTMLImageElement>>} A promise that is resolved when the image is loaded.
   */
  loadImage(e) {
    return this.map.loadImage(e);
  }
  //  Function loaded()
  /**
   * Returns a Boolean indicating whether the map is fully loaded.
   * @function loaded
   * @returns {boolean} A Boolean indicating whether the map is fully loaded.
   */
  loaded() {
    return this.map.loaded();
  }
  //  Function new LngLatBounds()
  /**
   * Constructs a new LngLatBounds object representing a geographical bounding box.
   * @class LngLatBounds
   * @constructor
   * @param {LngLatLike} [sw] - The southwest corner of the bounding box. Can be specified as an array of 4 numbers in the order of west, south, east, north, or an array of 2 LngLatLike representing [sw,ne].
   * @param {LngLatLike} [ne] - The northeast corner of the bounding box.
   */
  LngLatBounds(e, t) {
    return new io.LngLatBounds(e, t);
  }
  //  Function addProtocol()
  /**
   * Adds a custom load resource function that will be called when using a URL that starts with a custom URL schema.
   * @function addProtocol
   * @param {string} customProtocol - The protocol to hook, for example 'custom'.
   * @param {AddProtocolAction} loadFn - The function to use when trying to fetch a resource specified by the customProtocol.
   * @returns {void}
   */
  addProtocol(e, t) {
    return this.map.addProtocol(e, t);
  }
  //  Function moveLayer()
  /**
   * Moves a layer to a different z-position.
   * @function moveLayer
   * @param {string} id - The ID of the layer to move.
   * @param {string} [beforeId] - The ID of an existing layer to insert the new layer before.
   * @returns {this}
   */
  moveLayer(e, t) {
    return this.map.moveLayer(e, t);
  }
  //  Function panBy()
  /**
   * Pans the map by the specified offset.
   * @function panBy
   * @param {PointLike} offset - x and y coordinates by which to pan the map.
   * @param {AnimationOptions} [options] - Options object.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panBy(e, t, n) {
    return this.map.panBy(e, t, n);
  }
  //  Function panTo()
  /**
   * Pans the map to the specified location with an animated transition.
   * @function panTo
   * @param {LngLatLike} lnglat - The location to pan the map to.
   * @param {AnimationOptions} [options] - Options describing the destination and animation of the transition.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panTo(e, t, n) {
    return this.map.panTo(e, t, n);
  }
  //  Function project()
  /**
   * Returns a Point representing pixel coordinates, relative to the map's container, that correspond to the specified geographical location.
   * @function project
   * @param {LngLatLike} lnglat - The geographical location to project.
   * @returns {Point} The Point corresponding to lnglat, relative to the map's container.
   */
  project(e) {
    return this.map.project(e);
  }
  //  Function queryRenderedFeatures()
  /**
   * Queries rendered features within a specified geometry or bounding box.
   * @function queryRenderedFeatures
   * @param {GeometryLike | Array | Object} [geometryOrOptions] - The geometry or options for the query.
   * @param {Object} [options] - Options for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features that intersect the query geometry.
   */
  queryRenderedFeatures(e, t) {
    return this.map.queryRenderedFeatures(e, t);
  }
  //  Function querySourceFeatures()
  /**
   * Queries source features within a specified source.
   * @function querySourceFeatures
   * @param {string} sourceId - The ID of the source to query.
   * @param {Object} parameters - Parameters for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features in the source that satisfy the query parameters.
   */
  querySourceFeatures(e, t) {
    return this.map.querySourceFeatures(e, t);
  }
  //  Function queryTerrainElevation()
  /**
   * Queries the terrain elevation at a specified geographical location.
   * @function queryTerrainElevation
   * @param {LngLatLike} lngLatLike - The geographical location to query.
   * @returns {number} The elevation (in meters) at the specified location.
   */
  queryTerrainElevation(e) {
    return this.map.queryTerrainElevation(e);
  }
  //  Function redraw()
  /**
   * Redraws the map.
   * @function redraw
   * @returns {this}
   */
  redraw() {
    return this.map.redraw();
  }
  //  Function remove()
  /**
   * Removes the map from the DOM.
   * @function remove
   * @returns {this}
   */
  remove() {
    return this.map.remove();
  }
  //  Function removeControl()
  /**
   * Removes a control from the map.
   * @function removeControl
   * @param {Object} control - The control to remove.
   * @returns {this}
   */
  removeControl(e) {
    return this.map.removeControl(e);
  }
  //  Function removeFeatureState()
  /**
   * Removes the state of a feature.
   * @function removeFeatureState
   * @param {Object} target - The target feature.
   * @param {string} [key] - The key of the state to remove.
   * @returns {this}
   */
  removeFeatureState(e, t) {
    return this.map.removeFeatureState(e, t);
  }
  //  Function removeImage()
  /**
   * Removes an image from the style's sprite.
   * @function removeImage
   * @param {string} id - The ID of the image to remove.
   * @returns {this}
   */
  removeImage(e) {
    return this.map.removeImage(e);
  }
  /**
   * Removes a layer from the map.
   * @function removeLayer
   * @param {string} idLayer - Identifier of the layer to remove.
   */
  removeLayer(e) {
    try {
      this.map.removeLayer(e);
    } catch (t) {
      console.error(`Error removing layer: ${t.message}`);
    }
  }
  /**
   * Removes a source from the map.
   * @function removeSource
   * @param {string} idLayer - Identifier of the source to remove.
   */
  removeSource(e) {
    try {
      this.map.removeSource(e);
    } catch (t) {
      console.error(`Error removing source: ${t.message}`);
    }
  }
  //  Function removeSprite()
  /**
   * Removes a sprite from the style.
   * @function removeSprite
   * @param {string} id - The ID of the sprite to remove.
   * @returns {this}
   */
  removeSprite(e) {
    return this.map.removeSprite(e);
  }
  //  Function resetNorth()
  /**
   * Resets the map orientation so that north is up.
   * @function resetNorth
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorth(e, t) {
    return this.map.resetNorth(e, t);
  }
  //  Function resetNorthPitch()
  /**
   * Resets the map orientation so that north is up and pitch is set to 0.
   * @function resetNorthPitch
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorthPitch(e, t) {
    return this.map.resetNorthPitch(e, t);
  }
  //  Function resize()
  /**
   * Resizes the map to fit its container.
   * @function resize
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resize(e) {
    return this.map.resize(e);
  }
  //  Function rotateTo()
  /**
   * Rotates the map to the specified bearing with an animated transition.
   * @function rotateTo
   * @param {number} bearing - The desired bearing (in degrees) to rotate the map to.
   * @param {Object} [options] - Options for the rotation.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  rotateTo(e, t, n) {
    return this.map.rotateTo(e, t, n);
  }
  //  Function setBearing()
  /**
   * Sets the map's bearing with an optional animated transition.
   * @function setBearing
   * @param {number} bearing - The desired bearing (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setBearing(e, t) {
    return this.map.setBearing(e, t);
  }
  //  Function setCenter()
  /**
   * Sets the map's center coordinates with an optional animated transition.
   * @function setCenter
   * @param {LngLatLike} center - The desired center coordinates to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setCenter(e, t) {
    return this.map.setCenter(e, t);
  }
  //  Function setEventedParent()
  /**
   * Sets the parent of the map's event emitter.
   * @function setEventedParent
   * @param {any} [parent] - The parent object to set for the event emitter.
   * @param {any} [data] - Additional data to pass to the parent.
   * @returns {this}
   */
  setEventedParent(e, t) {
    return this.map.setEventedParent(e, t);
  }
  //  Function setFeatureState()
  /**
   * Sets the state of a feature.
   * @function setFeatureState
   * @param {Object} feature - The feature to set the state for.
   * @param {Object} state - The state object to set for the feature.
   * @returns {this}
   */
  setFeatureState(e, t) {
    return this.map.setFeatureState(e, t);
  }
  //  Function setFilter()
  /**
   * Sets the filter for a specified layer.
   * @function setFilter
   * @param {string} layerId - The ID of the layer to set the filter for.
   * @param {Array} [filter] - The filter array to apply to the layer.
   * @param {Object} [options] - Options for the filter.
   * @returns {this}
   */
  setFilter(e, t, n) {
    return this.map.setFilter(e, t, n);
  }
  //  Function setGlyphs()
  /**
   * Sets the glyphs for the map's style.
   * @function setGlyphs
   * @param {string} glyphsUrl - The URL to the glyphs.
   * @param {Object} [options] - Options for setting the glyphs.
   * @returns {this}
   */
  setGlyphs(e, t) {
    return this.map.setGlyphs(e, t);
  }
  //  Function setLayerZoomRange()
  /**
   * Sets the zoom range for a specified layer.
   * @function setLayerZoomRange
   * @param {string} layerId - The ID of the layer to set the zoom range for.
   * @param {number} minzoom - The minimum zoom level for the layer.
   * @param {number} maxzoom - The maximum zoom level for the layer.
   * @returns {this}
   */
  setLayerZoomRange(e, t, n) {
    return this.map.setLayerZoomRange(e, t, n);
  }
  //  Function setLayoutProperty()
  /**
   * Sets a layout property for a specified layer.
   * @function setLayoutProperty
   * @param {string} layerId - The ID of the layer to set the layout property for.
   * @param {string} name - The name of the layout property to set.
   * @param {any} value - The value to set for the layout property.
   * @param {Object} [options] - Options for setting the layout property.
   * @returns {this}
   */
  setLayoutProperty(e, t, n, i) {
    return this.map.setLayoutProperty(e, t, n, i);
  }
  //  Function setLight()
  /**
   * Sets the light for the map's style.
   * @function setLight
   * @param {Object} light - The light object to set for the map.
   * @param {Object} [options] - Options for setting the light.
   * @returns {this}
   */
  setLight(e, t) {
    return this.map.setLight(e, t);
  }
  //  Function setMaxBounds()
  /**
   * Sets the maximum bounds for the map.
   * @function setMaxBounds
   * @param {Array} bounds - The maximum bounds for the map.
   * @returns {this}
   */
  setMaxBounds(e) {
    return this.map.setMaxBounds(e);
  }
  //  Function setMaxPitch()
  /**
   * Sets the maximum pitch for the map.
   * @function setMaxPitch
   * @param {number} maxPitch - The maximum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMaxPitch(e) {
    return this.map.setMaxPitch(e);
  }
  //  Function setMaxZoom()
  /**
   * Sets the maximum zoom level for the map.
   * @function setMaxZoom
   * @param {number} maxZoom - The maximum zoom level for the map.
   * @returns {this}
   */
  setMaxZoom(e) {
    return this.map.setMaxZoom(e);
  }
  //  Function setMinPitch()
  /**
   * Sets the minimum pitch for the map.
   * @function setMinPitch
   * @param {number} minPitch - The minimum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMinPitch(e) {
    return this.map.setMinPitch(e);
  }
  //  Function setMinZoom()
  /**
   * Sets the minimum zoom level for the map.
   * @function setMinZoom
   * @param {number} minZoom - The minimum zoom level for the map.
   * @returns {this}
   */
  setMinZoom(e) {
    return this.map.setMinZoom(e);
  }
  //  Function setPadding()
  /**
   * Sets padding for the map's container.
   * @function setPadding
   * @param {Object} padding - The padding object to set for the map's container.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPadding(e, t) {
    return this.map.setPadding(e, t);
  }
  //  Function setPaintProperty()
  /**
   * Sets a paint property for a specified layer.
   * @function setPaintProperty
   * @param {string} layerId - The ID of the layer to set the paint property for.
   * @param {string} name - The name of the paint property to set.
   * @param {any} value - The value to set for the paint property.
   * @param {Object} [options] - Options for setting the paint property.
   * @returns {this}
   */
  setPaintProperty(e, t, n, i) {
    return this.map.setPaintProperty(e, t, n, i);
  }
  //  Function setPitch()
  /**
   * Sets the map's pitch angle with an optional animated transition.
   * @function setPitch
   * @param {number} pitch - The desired pitch angle (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPitch(e, t) {
    return this.map.setPitch(e, t);
  }
  //  Function setPixelRatio()
  /**
   * Sets the pixel ratio for the map.
   * @function setPixelRatio
   * @param {number} pixelRatio - The desired pixel ratio for the map.
   * @returns {this}
   */
  setPixelRatio(e) {
    return this.map.setPixelRatio(e);
  }
  //  Function setRenderWorldCopies()
  /**
   * Sets whether the map should render world copies when the center longitude is greater than or less than 180 degrees.
   * @function setRenderWorldCopies
   * @param {boolean} renderWorldCopies - A boolean indicating whether to render world copies.
   * @returns {this}
   */
  setRenderWorldCopies(e) {
    return this.map.setRenderWorldCopies(e);
  }
  //  Function setSprite()
  /**
   * Sets the sprite for the map's style.
   * @function setSprite
   * @param {string} spriteUrl - The URL to the sprite.
   * @param {Object} [options] - Options for setting the sprite.
   * @returns {this}
   */
  setSprite(e, t) {
    return this.map.setSprite(e, t);
  }
  //  Function setTerrain()
  /**
   * Loads a 3D terrain mesh based on a "raster-dem" source.
   * @function setTerrain
   * @param {TerrainSpecification} options - Options object specifying the terrain source.
   * @returns {this}
   */
  setTerrain(e) {
    return this.map.setTerrain(e);
  }
  //  Function setTransformRequest()
  /**
   * Updates the requestManager's transform request with a new function.
   * @function setTransformRequest
   * @param {RequestTransformFunction} transformRequest - The callback function to update the transform request.
   * @returns {this}
   */
  setTransformRequest(e) {
    return this.map.setTransformRequest(e);
  }
  //  Function setZoom()
  /**
   * Sets the map's zoom level.
   * @function setZoom
   * @param {number} zoom - The zoom level to set (0-20).
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setZoom(e, t) {
    return this.map.setZoom(e, t);
  }
  //  Function snapToNorth()
  /**
   * Snaps the map so that north is up (0 bearing), if the current bearing is close enough to it.
   * @function snapToNorth
   * @param {Object} [options] - Options for snapping to north.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  snapToNorth(e, t) {
    return this.map.snapToNorth(e, t);
  }
  //  Function stop()
  /**
   * Stops any animated transition underway.
   * @function stop
   * @returns {this}
   */
  stop() {
    return this.map.stop();
  }
  //  Function triggerRepaint()
  /**
   * Triggers the rendering of a single frame.
   * @function triggerRepaint
   * @returns {void}
   */
  triggerRepaint() {
    return this.map.triggerRepaint();
  }
  //  Function unproject()
  /**
   * Returns geographical coordinates corresponding to the specified pixel coordinates.
   * @function unproject
   * @param {PointLike} point - The pixel coordinates to unproject.
   * @returns {LngLat} The geographical coordinates corresponding to the specified pixel coordinates.
   */
  unproject(e) {
    return this.map.unproject(e);
  }
  //  Function updateImage()
  /**
   * Updates an existing image in the style's sprite.
   * @function updateImage
   * @param {string} id - The ID of the image to update.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The new image data.
   * @returns {this}
   */
  updateImage(e, t) {
    return this.map.updateImage(e, t);
  }
  //  Function zoomIn()
  /**
   * Increases the map's zoom level by 1.
   * @function zoomIn
   * @param {Object} [options] - Options for zooming in.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomIn(e, t) {
    return this.map.zoomIn(e, t);
  }
  //  Function zoomOut()
  /**
   * Decreases the map's zoom level by 1.
   * @function zoomOut
   * @param {Object} [options] - Options for zooming out.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomOut(e, t) {
    return this.map.zoomOut(e, t);
  }
  //  Function zoomTo()
  /**
   * Zooms the map to the specified zoom level with an animated transition.
   * @function zoomTo
   * @param {number} zoom - The zoom level to transition to.
   * @param {Object} [options] - Options for zooming to.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomTo(e, t, n) {
    return this.map.zoomTo(e, t, n);
  }
  // end maplibre methods
  /**
   * Adds a GeoJSON layer to the map.
   * @function addLayerGeoJSON
   * @param {Object} layer - Options for the GeoJSON layer to add.
   * @param {string} layer.id - Unique identifier for the layer.
   * @param {Object} layer.data - GeoJSON data for the layer.
   * @param {string} layer.type - Map layer type (e.g., 'symbol', 'circle', 'fill').   *
   * @param {Object} layer.layout - Layer layout configuration.
   * @param {Object} layer.paint - Layer paint configuration.
   * @param {string} layerPosition - Position of the layer: 'top', below 'labels' or below 'lines'.
   */
  addLayerGeoJSON(e, t) {
    try {
      let n = this._dealOrderLayer(t);
      this.map.addSource(`${e.id}`, {
        type: "geojson",
        data: e.data
      }), this.map.addLayer({
        id: `${e.id}-layerIcgcMap`,
        type: e.type,
        source: `${e.id}`,
        layout: e.layout,
        paint: e.paint
      }, n);
    } catch (n) {
      console.error(`Error adding GeoJSON layer: ${n.message}`);
    }
  }
  /**
   * Adds a WMS layer to the map.
   * @function addLayerWMS
   
   * @param {string[]} tiles - Tiles for the raster layer.
   * @param {string} idLayer - Unique identifier for the layer.
   * @param {Object} options - Options of the layer: layout, paint and layerPosition.
   */
  addLayerWMS(e, t, n) {
    try {
      let i = this._dealOrderLayer(n.layerPosition);
      n ? (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, i), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        layout: n.layout,
        paint: n.paint
      }, i)) : (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, i), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        paint: {}
      }, i));
    } catch (i) {
      console.error(`Error adding WMS layer: ${i.message}`);
    }
  }
  /**
   * Adds a logo to the map.
   * @function addLogo
   * @param {Object} options - Options for the logo to add.
   * @param {string} options.id - Unique identifier for the logo.
   * @param {string} options.url - URL of the logo image.
   * @param {string} options.href - URL to navigate to when the logo is clicked.
   * @param {string} options.height - Height of the logo.
   */
  addLogo(e) {
    try {
      let t = document.getElementById("map"), n;
      n = document.createElement("div"), n.id = "logos", t.appendChild(n);
      const i = document.createElement("img");
      i.src = e.url, i.style.height = e.height;
      const s = document.getElementById("logos"), l = document.createElement("a");
      l.id = e.id, l.href = e.href, l.target = "_blank", l.style.position = "relative", l.style.bottom = "1px", l.appendChild(i), s.appendChild(l);
    } catch (t) {
      console.error(`Error adding logo: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemapsICGC
   * @param {Object[]} basesArray - Array of base layer objects.
   */
  addBasemapsICGC(e) {
    try {
      const t = (l) => {
        this.map.setStyle(l);
      };
      let n = document.getElementById("map"), i;
      i = document.createElement("div"), i.id = "basemap-group", i.classList.add = "filter-group", n.appendChild(i);
      const s = document.getElementById("basemap-group");
      for (const l of e)
        for (const o of Object.keys(ei.baseStyles)) {
          const d = ei.baseStyles[o];
          if (l === d.url) {
            const m = document.createElement("div");
            m.className = "basemap-item", m.title = d.key, m.style.backgroundImage = `url('${d.image}')`, s.appendChild(m), m.addEventListener("click", () => t(d.url));
          }
        }
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemaps
   * @param {Object[]} baseLayers - Array of base layer objects.
   * @param {string} baseLayers.label - Label for the base layer.
   * @param {string} baseLayers.image - URL of the image representing the base layer.
   * @param {string} baseLayers.url - URL of the base layer style.
   */
  addBasemaps(e) {
    try {
      const t = (l) => {
        map.setStyle(l.url);
      };
      let n = document.getElementById("map"), i;
      i = document.createElement("div"), i.id = "basemap-group", i.classList.add = "basemap-group", n.appendChild(i);
      const s = document.getElementById("basemap-group");
      e.forEach((l) => {
        const o = document.createElement("div");
        o.className = "basemap-item", o.title = l.label, o.style.backgroundImage = `url('${l.image}')`, s.appendChild(o), o.addEventListener("click", () => t(l));
      });
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds feature query function to a layer.
   * @function addFeatureQuery
   * @param {string} idLayer - name of the layer
   * @param {objetc} queryFields - optional indications for the popup
   * @param {objetc} popupStyle - optional indications for the popup style
   */
  addFeatureQuery(e, t, n) {
    try {
      let i;
      this.map.on("mouseenter", e, () => {
        this.map.getCanvas().style.cursor = "pointer";
      }), this.map.on("mouseleave", e, () => {
        this.map.getCanvas().style.cursor = "";
      }), this.map.on("click", (s) => {
        let l = this.map.queryRenderedFeatures(s.point);
        if (l && l[0].source.includes(e)) {
          let o = [s.lngLat.lng, s.lngLat.lat];
          if (t !== void 0 && t.length > 0 && t !== "all") {
            if (t !== null) {
              let d = "";
              t.forEach((m) => {
                let b = l[0].properties[m];
                d = d + `<h4>${b}</h4>`;
              }), i = d, this.addPopup(o, i, n);
            }
          } else {
            let d = "";
            for (const m in l[0].properties)
              d += "<b>" + m + "</b>:" + l[0].properties[m] + "<br>";
            i = d, this.addPopup(o, i, n);
          }
        }
      });
    } catch (i) {
      console.error(`Error adding feature query: ${i.message}`);
    }
  }
  /**
   * Adds a scale control to the map.
   *  * @function addScaleControl
   * @param {Object} options - Options for configuring the scale control.
   * @param {string} position - The position on the map to place the scale control (e.g., 'top-left', 'bottom-right').
   */
  addScaleControl(e, t) {
    try {
      var n = new io.ScaleControl(e);
      this.map.addControl(n, t);
    } catch (i) {
      console.error(`Error adding scale: ${i.message}`);
    }
  }
  /**
   * Adds an export control to the map with the provided options and position.
   * @function addExportControl
   * @param {Object|string} options - Options for the export control or position if provided as a string.
   * @param {string} [position] - Position to place the export control (e.g., 'top-right').
   */
  addExportControl(e, t) {
    try {
      typeof e == "string" && (t = e, e = void 0), e === void 0 && (e = {
        PageSize: ff.A4,
        PageOrientation: Kp.Landscape,
        Format: Ou.PNG,
        DPI: yv[300],
        Crosshair: !0,
        PrintableArea: !0,
        Local: "ca"
      }, t = "top-right"), this.map.addControl(new QX(e), t);
    } catch (n) {
      console.error(`Error adding export control: ${n.message}`);
    }
  }
  /**
   * Adds a marker to the map.
   * @function addMarker
   * @param {Object} options - Options for the marker to add.
   * @param {string} options.text - Text content for the marker popup.
   * @param {Object} options.options - Marker options.
   * @param {LngLatLike} options.coord - Coordinates for placing the marker.
   * @param {Object} options.textOffset - Text offset for the marker popup.
   * @returns {Object} - Instance of the added marker.
   */
  addMarker(e) {
    try {
      let t, n;
      return e.text === void 0 ? t = new io.Marker(e.options).setLngLat(e.coord).addTo(this.map) : (n = new io.Popup({
        offset: e.textOffset
      }).setHTML(e.text), t = new io.Marker(e.options).setLngLat(e.coord).setPopup(n).addTo(this.map)), t;
    } catch (t) {
      return console.error(`Error adding marker: ${t.message}`), null;
    }
  }
  /**
   * Adds a popup to the map.
   * @function addPopup
   * @param {Object} options - Options for the popup to add.
   * @param {LngLatLike} coord - Coordinates for placing the popup.
   * @param {string} text - HTML content for the popup.
   * @param {string} popupStyle - css content for the popup style.
   * @returns {Object} - Instance of the added popup.
   */
  addPopup(e, t, n) {
    try {
      return n.image === void 0 ? new io.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${n.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
 ${t}
          </div>
          <div class="popupBottomDown">
          </div>
          </div>
        </div>
      `).addTo(this.map) : new io.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${n.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
          ${t}
          </div>
          <div class="popupBottomDown">
             <img style="  padding: 8px;  width: 50%;" src=${n.image} />
          </div>
          </div>
        </div>
      `).addTo(this.map);
    } catch (i) {
      return console.error(`Error adding popup: ${i.message}`), null;
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullScreen
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullScreen(e) {
    try {
      e === void 0 && (e = "top-right"), this.map.addControl(new io.FullscreenControl(), e);
    } catch (t) {
      console.error(`Error adding fullscreen control: ${t.message}`);
    }
  }
  /**
   * Adds a menu item with a checkbox for controlling the visibility of a layer on the map.
   * @function addMenuItem
   * @param {string} name - The name of the layer corresponding to the menu item.
   */
  addMenuItem(e) {
    try {
      let t;
      if (e.includes("-userFieldFilter-") ? t = e.split("-userFieldFilter-")[0] : t = e, e.length > 0) {
        const n = document.getElementById("menu-group"), i = document.createElement("input");
        i.type = "checkbox", i.id = e, i.checked = !0, n.appendChild(i);
        const s = document.createElement("label");
        s.setAttribute("for", e), s.textContent = t, n.appendChild(s), i.addEventListener("change", (l) => {
          this.map.setLayoutProperty(e, "visibility", l.target.checked ? "visible" : "none");
        });
      }
    } catch (t) {
      console.error(`Error adding menu item: ${t.message}`);
    }
  }
  /**
   * Adds a layer tree to the map.
   * @function addLayerTree
   * @param {Object} options - Options for the layer tree to add.
   * @param {Object} options.features - Features for the layer tree.
   * @param {string} options.id - Unique identifier for the layer tree.
   * @param {string} options.type - Type of layer tree ('geojson', 'raster', etc.).
   */
  addLayerTree(e) {
    try {
      let t = e.features, n = document.getElementById("map"), i = document.createElement("nav");
      i.id = "filter-group", n.appendChild(i);
      const s = document.getElementById("filter-group");
      this.map.addSource(`${e.id}`, {
        type: e.type,
        data: t
      }), t.features.forEach((l) => {
        const o = l.properties.icon, d = `poi-${o}`;
        if (!this.map.getLayer(d)) {
          this.map.addLayer({
            id: d,
            type: "circle",
            source: `${e.id}`,
            paint: {
              "circle-radius": 6,
              "circle-color": "#B42222"
            },
            filter: ["==", "icon", o]
          }, this._firstSymbolLayer());
          const m = document.createElement("input");
          m.type = "checkbox", m.id = d, m.checked = !0, s.appendChild(m);
          const b = document.createElement("label");
          b.setAttribute("for", d), b.textContent = o, s.appendChild(b), m.addEventListener("change", (T) => {
            this.map.setLayoutProperty(d, "visibility", T.target.checked ? "visible" : "none");
          });
        }
      });
    } catch (t) {
      console.error(`Error adding layer tree: ${t.message}`);
    }
  }
  /**
   * Creates a navigation control with the provided options.
   * @function createNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   * @returns {Object} - Instance of the created navigation control.
   */
  createNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new io.NavigationControl(e), t);
    } catch (n) {
      return console.error(`Error creating navigation control: ${n.message}`), null;
    }
  }
  /**
   * Adds a navigation control to the map with the provided options.
   * @function addNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new io.NavigationControl(e), t);
    } catch (n) {
      console.error(`Error adding navigation control: ${n.message}`);
    }
  }
  /**
   * Adds an attribution control to the map with the provided options.
   * @function addAttributionControl
   * @param {Object} options - Options for the attribution control.
   * @param {string} [position='bottom-right'] - Position to add the control on the map.
   */
  addAttributionControl(e, t) {
    try {
      this.map.addControl(new io.AttributionControl(e), t);
    } catch (n) {
      console.error(`Error adding attribution control: ${n.message}`);
    }
  }
  /**
   * Adds an ICGC image layer to the map based on the specified name and year.
   * @function addImageLayerICGC
   * @param {string} url - The url of the  layer.
   * @param {string} idLayer - The user id for the  layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   */
  addImageLayerICGC(e, t, n) {
    try {
      let i = null, s, l;
      n ? (l = n, s = n.layerPosition) : l = {
        type: "raster",
        layout: {
          visibility: "visible"
        },
        paint: {
          "raster-opacity": 1
        },
        layerPosition: Vm
      }, i = this._findImageType(e, os.Orto, os.VectorAdmin, os.WMS, os.Vector), i || console.log(" %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
      let o = {
        id: t,
        tiles: e
      };
      this.addLayerWMS(e, t, l);
    } catch (i) {
      console.error(`Error adding ICGC image layer: ${i.message}`);
    }
  }
  /**
   * Adds an ICGC vector layer to the map based on the specified name and year.
   * @function addVectorLayerICGC
   * @param {string} url - The url of the vector layer.
   * @param {string} idLayer - The user id for the vector layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   *
   */
  async addVectorLayerICGC(e, t, n) {
    try {
      let {
        type: i = "line",
        layerPosition: s = Vm,
        layoutOptions: l = {
          visibility: "visible"
        },
        paintOption: o
      } = n || {}, d = this._dealOrderLayer(s);
      if (!e) {
        console.log(" %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
        return;
      }
      if (e.includes("https")) {
        let m = this._getKeyByUrlVector(e);
        this.map.addSource(m, {
          type: "vector",
          url: e
        });
        let b = {
          id: m,
          type: "fill",
          source: m,
          "source-layer": "cobertes",
          maxzoom: 18,
          layout: n.layout,
          paint: hK.cobertesSol
        };
        if (m === "cobertes2018" && this.map.addLayer(b, d), l.visibility === "visible") {
          let T = this._getLegendByName(m);
          this.addLegend(T, m);
        }
      } else {
        let m = t;
        this.map.addSource(m, {
          type: "vector",
          url: ei.limitsUrl
        });
        let b = {
          id: t,
          type: i,
          source: m,
          "source-layer": e,
          layout: n.layout,
          paint: n.paint || {}
        };
        i === "fill" || i === "polygon" ? b.paint = o || {
          "fill-color": "#0000FF",
          "fill-opacity": 0
        } : i === "line" && (b.paint = o || {
          "line-color": "#4832a8",
          "line-opacity": 1,
          "line-width": 1
        }), this.map.addLayer(b, d);
      }
    } catch (i) {
      console.error(`Error adding ICGC vector layer: ${i.message}`);
    }
  }
  /**
   * Adds an ICGC FGB layer to the map based on the specified name and year.
   * @function addFGBLayerICGC
   * @param {string} url - The url of the FGB layer.
   * @param {string} idLayer - Id for the layer.
   * @param {object} options - Paint option for the layer
   *
   */
  async addFGBLayerICGC(e, t, n) {
    try {
      n || (n.layout = {
        visibility: !0
      }, n.paint = {
        "line-color": "#4832a8",
        "line-opacity": 1,
        "line-width": 1
      }, n.type = "lines", n.layerPosition = "labels");
      let i = this._dealOrderLayer(n.layerPosition);
      const s = await fetch(e), l = {
        type: "FeatureCollection",
        features: []
      };
      for await (const d of Yw(s.body)) l.features.push(d);
      let o = t;
      this.map.addSource(o, {
        type: "geojson",
        data: l
      }), e.includes("text") ? this.map.addLayer({
        id: t,
        type: "symbol",
        source: o,
        layout: {
          "text-letter-spacing": 0.1,
          "text-size": {
            base: 1.2,
            stops: [[8, 0], [12, 14], [15, 15]]
          },
          "text-font": ["FiraSans-Regular"],
          "text-field": ["get", "NOM_AC"],
          "text-transform": "none",
          "text-max-width": 25,
          visibility: n.layout.visibility,
          "text-justify": "right",
          "text-anchor": "top",
          "text-allow-overlap": !1,
          "symbol-spacing": 2,
          "text-line-height": 1
        },
        paint: {
          "text-halo-blur": 0.5,
          "text-color": "rgba(90, 7, 7, 1)",
          "text-halo-width": 2,
          "text-halo-color": "rgba(255, 255, 255,0.8)"
        }
      }, i) : this.map.addLayer({
        id: t,
        type: n.type,
        source: o,
        layout: n.layout,
        paint: n.paint
      }, i);
    } catch (i) {
      console.error(`Error adding ICGC FGB layer: ${i.message}`);
    }
  }
  /**
   * Adds 3D terrain to the map using hillshade.
   * @function addTerrainICGC
   * @param {string} url - dataset url of the terrain
   * @param {string} controlPosition - Position to add the control on the map.
   */
  addTerrainICGC(e, t) {
    try {
      let n;
      for (const s in Vp)
        if (Vp.hasOwnProperty(s)) {
          const l = Vp[s];
          l === e && (n = l);
        }
      let i = n;
      this.getSource("terrainICGC") !== void 0 && (this.getStyle().layers.forEach((l) => {
        l.source === "terrainICGC" && this.removeLayer(l.id);
      }), this.removeSource("terrainICGC")), this.getSource("terrainICGC") === void 0 && (e.includes("terrarium") ? this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [i],
        tileSize: 512,
        encoding: "terrarium",
        maxzoom: 16
      }) : this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [i],
        tileSize: 256,
        maxzoom: 14,
        minzoom: 7
      })), this.map.setTerrain({
        source: "terrainICGC",
        exaggeration: 1.5
      }), t == null || this.map.addControl(new n4({
        pitch: 90,
        bearing: null,
        minpitchzoom: null
      }), t);
    } catch (n) {
      console.error(`Error adding 3D terrain: ${n.message}`);
    }
  }
  /**
   * Add image legend.
   * @function addLegend
   * @param {string} url - image legend url.
   * @param {string} idLayer - layer's name.
   */
  addLegend(e, t) {
    try {
      this.map.addControl(new EZ({
        url: e,
        idLayer: t
      }));
    } catch (n) {
      console.error(`Error adding legend: ${n.message}`);
    }
  }
  //Internal methods
  /**
   * Finds the type of image based on the provided URL and specified vectors.
   * @function _findImageType
   * @param {string} url - The URL of the image to find the type for.
   * @param {Object} var1 - The first vector object containing key-value pairs.
   * @param {Object} var2 - The second vector object containing key-value pairs.
   * @param {Object} var3 - The third vector object containing key-value pairs.
   * @param {Object} var4 - The fourth vector object containing key-value pairs.
   * @returns {string|null} - The type of image if found, otherwise null.
   */
  _findImageType(e, t, n, i, s) {
    const l = [t, n, i, s];
    for (const o of l)
      for (const [d, m] of Object.entries(o))
        if (m === e)
          return d;
    return null;
  }
  /**
   * Gets the key by URL from the FGBAdmin layers.
   * @function _getKeyByUrlFGB
   * @param {string} url - The URL to find the key for in the FGBAdmin layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlFGB(e) {
    for (const t in os.FGBAdmin)
      if (os.FGBAdmin.hasOwnProperty(t) && os.FGBAdmin[t] === e)
        return t;
    return null;
  }
  /**
   * Gets the legend by name from the default vector layers.
   * @function _getLegendByName
   * @param {string} name - The name of the vector layer to get the legend for.
   * @returns {string|null} - The legend if found, otherwise null.
   */
  _getLegendByName(e) {
    for (const t in ei.vectorLayers) {
      const n = ei.vectorLayers[t];
      if (n.key === e)
        return n.legend;
    }
    return null;
  }
  /**
   * Gets the key by URL from the Vector layers.
   * @function _getKeyByUrlVector
   * @param {string} url - The URL to find the key for in the Vector layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlVector(e) {
    for (const t in os.Vector)
      if (os.Vector.hasOwnProperty(t) && os.Vector[t] === e)
        return t;
    return null;
  }
  /**
   * Raises text 3D style on the map.
   * @function _raiseText3DStyle
   * @async
   * @returns {Promise<void>} - A promise that resolves after updating the text 3D style on the map.
   */
  async _raiseText3DStyle() {
    try {
      const e = await this.map.loadImage(ei.map3dOptions.imageIcon);
      this.map.hasImage("stick") || this.map.addImage("stick", e.data), this.map.getStyle().layers.forEach((t) => {
        if (t["source-layer"] === ei.map3dOptions.sourceLayerFilterId && t.minzoom >= ei.map3dOptions.minZoomFilter && e) {
          const n = t.id;
          this.map.setLayoutProperty(n, "icon-image", "stick"), this.map.setLayoutProperty(n, "text-offset", [0, -9]), this.map.setLayoutProperty(n, "symbol-placement", "point"), this.map.setLayoutProperty(n, "symbol-avoid-edges", !1), this.map.setLayoutProperty(n, "text-allow-overlap", !0), this.map.setLayoutProperty(n, "text-ignore-placement", !1), this.map.setLayoutProperty(n, "text-pitch-alignment", "auto"), this.map.setLayoutProperty(n, "text-rotation-alignment", "auto"), this.map.setLayoutProperty(n, "text-justify", "center"), this.map.setLayoutProperty(n, "text-anchor", "bottom"), this.map.setLayoutProperty(n, "icon-anchor", "bottom"), this.map.setPaintProperty(n, "text-color", "#ffffff"), this.map.setPaintProperty(n, "text-halo-color", "#000000"), this.map.setPaintProperty(n, "text-halo-width", 2);
        }
      });
    } catch (e) {
      return console.error(`Error dealing orto 3D: ${e.message}`), null;
    }
  }
  /**
   * Deals with map styles based on the name.
   * @function _dealStyleMaps
   * @param {string} name - The name of the map style.
   * @returns {Object|string|null} - The map style object if found, or the input name if not found, or null if an error occurs.
   */
  _dealStyleMaps(e) {
    try {
      if (e && e.indexOf("icgc.cat") != -1) {
        for (const t in rf)
          if (rf.hasOwnProperty(t)) {
            const n = rf[t];
            if (t === e)
              return n;
          }
        return rf[0];
      } else
        return e;
    } catch (t) {
      return console.error(`Error dealing with map styles: ${t.message}`), null;
    }
  }
  /**
   * Deals with the 3D ortho style based on the name.
   * @function _dealOrto3dStyle
   * @param {string} name - The name of the orto3D style.
   * @returns {void|null} - Returns null if an error occurs.
   */
  _dealOrto3dStyle(e) {
    try {
      if (e == "orto3d") {
        this.map.setMaxZoom(18.8), this.map.easeTo({
          pitch: 45
        });
        const t = new aC({
          intensity: 4
        }), n = new S2({
          ambientLight: t
        });
        this.map.setTerrain({
          source: ei.map3dOptions.terrainSource,
          exaggeration: ei.map3dOptions.exaggeration
        }), Za = new F9({
          interleaved: !0,
          layers: [this._createCitiesMapboxLayer(!1)],
          // Inicialment invisible
          effects: [n],
          onAfterRender: () => {
            try {
              const s = this.map.getZoom() >= ei.map3dOptions.minZoomRange;
              Za.setProps({
                layers: [this._createCitiesMapboxLayer(s)]
              });
            } catch {
              console.log("No render 3D Mesh");
            }
          }
        }), this.map.hasControl(Za) || (this.map.addControl(Za), this._raiseText3DStyle()), this.map.setSky({
          "sky-color": "#86bbd5",
          "sky-horizon-blend": 0.3,
          "horizon-color": "#ffffff33",
          "horizon-fog-blend": 0.1,
          "fog-ground-blend": 0.75,
          "fog-color": "#c5d6d6"
        }), this.map.on("zoomend", () => {
          !this.map.getStyle().name == "orto3d" && this.map.hasControl(Za) && (this.map.removeControl(Za), Za.setProps({
            layers: []
          }), this.map.setTerrain(null));
        });
      } else
        Za == null || Za.setProps({
          layers: []
        }), this.map.hasControl(Za) && (this.map.removeControl(Za), Za.setProps({
          layers: []
        }), this.map.setTerrain(null));
    } catch (t) {
      return console.error(`Error dealing orto 3D: ${t.message}`), null;
    }
  }
  /**
   * Deals with the order of the layer.
   * @function _dealOrderLayer
   * @param {string} order - The order of the layer.
   * @returns {string} - The id of the first symbol layer if the order is 'symbol', the id of the first line layer if the order is 'line', otherwise an empty string.
   */
  _dealOrderLayer(e) {
    return e === Vm ? this._firstSymbolLayer() : e === fK ? this._firstLineLayer() : "";
  }
  /**
   * Retrieves the id of the first symbol layer.
   * @function _firstSymbolLayer
   * @returns {string|undefined} - The id of the first symbol layer if found, otherwise undefined.
   */
  _firstSymbolLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let n = 0; n < e.length; n++)
        if (e[n].type === "symbol" && e[n].id.indexOf("contour") === -1 && e[n].id.indexOf("water") === -1) {
          t = e[n].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Retrieves the id of the first line layer.
   * @function _firstLineLayer
   * @returns {string|undefined} - The id of the first line layer if found, otherwise undefined.
   */
  _firstLineLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let n = 0; n < e.length; n++)
        if (e[n].type === "line") {
          t = e[n].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Creates a Mapbox layer for displaying cities in 3D.
   * @function _createCitiesMapboxLayer
   * @returns {MapboxLayer|null} - The Mapbox layer for displaying cities in 3D if created successfully, otherwise null.
   */
  _createCitiesMapboxLayer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    try {
      return new Q2({
        id: ei.map3dOptions.layerId3d,
        data: ei.map3dOptions.urlTilesetCities,
        loader: J2,
        beforeId: ei.map3dOptions.layerIdOrder,
        visible: e,
        loadOptions: {
          tileset: {
            viewDistanceScale: 1,
            memoryAdjustedScreenSpaceError: ei.map3dOptions.spaceErrorFactor,
            updateTransforms: !0,
            adjustScreenSpaceError: ei.map3dOptions.spaceErrorFactor
            // Aplicaci inicial
          }
        },
        onTilesetLoad: (t) => {
          t.adjustScreenSpaceError = ei.map3dOptions.spaceErrorFactor, t.memoryAdjustedScreenSpaceError = ei.map3dOptions.spaceErrorFactor;
        },
        onTileLoad: (t) => {
          t.content.cartographicOrigin.z -= ei.map3dOptions.zfactor;
        },
        operation: "terrain+draw",
        pickable: !1
      });
    } catch (t) {
      return console.error(`Error adding MapboxOverlay: ${t.message}`), null;
    }
  }
};
var a1 = { exports: {} }, l1, tE;
function dK() {
  if (tE) return l1;
  tE = 1;
  function r(t, n) {
    var i = t.getCenter(), s = t.getZoom(), l = t.getBearing(), o = t.getPitch();
    n.forEach(function(d) {
      d.jumpTo({
        center: i,
        zoom: s,
        bearing: l,
        pitch: o
      });
    });
  }
  function e() {
    var t, n = arguments.length;
    if (n === 1)
      t = arguments[0];
    else {
      t = [];
      for (var i = 0; i < n; i++)
        t.push(arguments[i]);
    }
    var s = [];
    t.forEach(function(m, b) {
      s[b] = d.bind(null, m, t.filter(function(T, M) {
        return M !== b;
      }));
    });
    function l() {
      t.forEach(function(m, b) {
        m.on("move", s[b]);
      });
    }
    function o() {
      t.forEach(function(m, b) {
        m.off("move", s[b]);
      });
    }
    function d(m, b) {
      o(), r(m, b), l();
    }
    return l(), function() {
      o(), s = [], t = [];
    };
  }
  return l1 = e, l1;
}
var qm = { exports: {} }, rE;
function pK() {
  if (rE) return qm.exports;
  rE = 1;
  var r = typeof Reflect == "object" ? Reflect : null, e = r && typeof r.apply == "function" ? r.apply : function(J, ie, ye) {
    return Function.prototype.apply.call(J, ie, ye);
  }, t;
  r && typeof r.ownKeys == "function" ? t = r.ownKeys : Object.getOwnPropertySymbols ? t = function(J) {
    return Object.getOwnPropertyNames(J).concat(Object.getOwnPropertySymbols(J));
  } : t = function(J) {
    return Object.getOwnPropertyNames(J);
  };
  function n(X) {
    console && console.warn && console.warn(X);
  }
  var i = Number.isNaN || function(J) {
    return J !== J;
  };
  function s() {
    s.init.call(this);
  }
  qm.exports = s, qm.exports.once = G, s.EventEmitter = s, s.prototype._events = void 0, s.prototype._eventsCount = 0, s.prototype._maxListeners = void 0;
  var l = 10;
  function o(X) {
    if (typeof X != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof X);
  }
  Object.defineProperty(s, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return l;
    },
    set: function(X) {
      if (typeof X != "number" || X < 0 || i(X))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + X + ".");
      l = X;
    }
  }), s.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, s.prototype.setMaxListeners = function(J) {
    if (typeof J != "number" || J < 0 || i(J))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + J + ".");
    return this._maxListeners = J, this;
  };
  function d(X) {
    return X._maxListeners === void 0 ? s.defaultMaxListeners : X._maxListeners;
  }
  s.prototype.getMaxListeners = function() {
    return d(this);
  }, s.prototype.emit = function(J) {
    for (var ie = [], ye = 1; ye < arguments.length; ye++) ie.push(arguments[ye]);
    var oe = J === "error", Re = this._events;
    if (Re !== void 0) oe = oe && Re.error === void 0;
    else if (!oe) return !1;
    if (oe) {
      var Ne;
      if (ie.length > 0 && (Ne = ie[0]), Ne instanceof Error)
        throw Ne;
      var me = new Error("Unhandled error." + (Ne ? " (" + Ne.message + ")" : ""));
      throw me.context = Ne, me;
    }
    var _e = Re[J];
    if (_e === void 0) return !1;
    if (typeof _e == "function")
      e(_e, this, ie);
    else
      for (var Fe = _e.length, Me = D(_e, Fe), ye = 0; ye < Fe; ++ye) e(Me[ye], this, ie);
    return !0;
  };
  function m(X, J, ie, ye) {
    var oe, Re, Ne;
    if (o(ie), Re = X._events, Re === void 0 ? (Re = X._events = /* @__PURE__ */ Object.create(null), X._eventsCount = 0) : (Re.newListener !== void 0 && (X.emit("newListener", J, ie.listener ? ie.listener : ie), Re = X._events), Ne = Re[J]), Ne === void 0)
      Ne = Re[J] = ie, ++X._eventsCount;
    else if (typeof Ne == "function" ? Ne = Re[J] = ye ? [ie, Ne] : [Ne, ie] : ye ? Ne.unshift(ie) : Ne.push(ie), oe = d(X), oe > 0 && Ne.length > oe && !Ne.warned) {
      Ne.warned = !0;
      var me = new Error("Possible EventEmitter memory leak detected. " + Ne.length + " " + String(J) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      me.name = "MaxListenersExceededWarning", me.emitter = X, me.type = J, me.count = Ne.length, n(me);
    }
    return X;
  }
  s.prototype.addListener = function(J, ie) {
    return m(this, J, ie, !1);
  }, s.prototype.on = s.prototype.addListener, s.prototype.prependListener = function(J, ie) {
    return m(this, J, ie, !0);
  };
  function b() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function T(X, J, ie) {
    var ye = {
      fired: !1,
      wrapFn: void 0,
      target: X,
      type: J,
      listener: ie
    }, oe = b.bind(ye);
    return oe.listener = ie, ye.wrapFn = oe, oe;
  }
  s.prototype.once = function(J, ie) {
    return o(ie), this.on(J, T(this, J, ie)), this;
  }, s.prototype.prependOnceListener = function(J, ie) {
    return o(ie), this.prependListener(J, T(this, J, ie)), this;
  }, s.prototype.removeListener = function(J, ie) {
    var ye, oe, Re, Ne, me;
    if (o(ie), oe = this._events, oe === void 0) return this;
    if (ye = oe[J], ye === void 0) return this;
    if (ye === ie || ye.listener === ie)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete oe[J], oe.removeListener && this.emit("removeListener", J, ye.listener || ie));
    else if (typeof ye != "function") {
      for (Re = -1, Ne = ye.length - 1; Ne >= 0; Ne--)
        if (ye[Ne] === ie || ye[Ne].listener === ie) {
          me = ye[Ne].listener, Re = Ne;
          break;
        }
      if (Re < 0) return this;
      Re === 0 ? ye.shift() : U(ye, Re), ye.length === 1 && (oe[J] = ye[0]), oe.removeListener !== void 0 && this.emit("removeListener", J, me || ie);
    }
    return this;
  }, s.prototype.off = s.prototype.removeListener, s.prototype.removeAllListeners = function(J) {
    var ie, ye, oe;
    if (ye = this._events, ye === void 0) return this;
    if (ye.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : ye[J] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete ye[J]), this;
    if (arguments.length === 0) {
      var Re = Object.keys(ye), Ne;
      for (oe = 0; oe < Re.length; ++oe)
        Ne = Re[oe], Ne !== "removeListener" && this.removeAllListeners(Ne);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (ie = ye[J], typeof ie == "function")
      this.removeListener(J, ie);
    else if (ie !== void 0)
      for (oe = ie.length - 1; oe >= 0; oe--)
        this.removeListener(J, ie[oe]);
    return this;
  };
  function M(X, J, ie) {
    var ye = X._events;
    if (ye === void 0) return [];
    var oe = ye[J];
    return oe === void 0 ? [] : typeof oe == "function" ? ie ? [oe.listener || oe] : [oe] : ie ? q(oe) : D(oe, oe.length);
  }
  s.prototype.listeners = function(J) {
    return M(this, J, !0);
  }, s.prototype.rawListeners = function(J) {
    return M(this, J, !1);
  }, s.listenerCount = function(X, J) {
    return typeof X.listenerCount == "function" ? X.listenerCount(J) : E.call(X, J);
  }, s.prototype.listenerCount = E;
  function E(X) {
    var J = this._events;
    if (J !== void 0) {
      var ie = J[X];
      if (typeof ie == "function")
        return 1;
      if (ie !== void 0)
        return ie.length;
    }
    return 0;
  }
  s.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function D(X, J) {
    for (var ie = new Array(J), ye = 0; ye < J; ++ye) ie[ye] = X[ye];
    return ie;
  }
  function U(X, J) {
    for (; J + 1 < X.length; J++) X[J] = X[J + 1];
    X.pop();
  }
  function q(X) {
    for (var J = new Array(X.length), ie = 0; ie < J.length; ++ie)
      J[ie] = X[ie].listener || X[ie];
    return J;
  }
  function G(X, J) {
    return new Promise(function(ie, ye) {
      function oe(Ne) {
        X.removeListener(J, Re), ye(Ne);
      }
      function Re() {
        typeof X.removeListener == "function" && X.removeListener("error", oe), ie([].slice.call(arguments));
      }
      he(X, J, Re, {
        once: !0
      }), J !== "error" && Y(X, oe, {
        once: !0
      });
    });
  }
  function Y(X, J, ie) {
    typeof X.on == "function" && he(X, "error", J, ie);
  }
  function he(X, J, ie, ye) {
    if (typeof X.on == "function")
      ye.once ? X.once(J, ie) : X.on(J, ie);
    else if (typeof X.addEventListener == "function")
      X.addEventListener(J, function oe(Re) {
        ye.once && X.removeEventListener(J, oe), ie(Re);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof X);
  }
  return qm.exports;
}
var nE;
function gK() {
  return nE || (nE = 1, function(r) {
    var e = dK(), t = pK().EventEmitter;
    function n(i, s, l, o) {
      if (this.options = o || {}, this._mapA = i, this._mapB = s, this._horizontal = this.options.orientation === "horizontal", this._onDown = this._onDown.bind(this), this._onMove = this._onMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._ev = new t(), this._swiper = document.createElement("div"), this._swiper.className = this._horizontal ? "compare-swiper-horizontal" : "compare-swiper-vertical", this._controlContainer = document.createElement("div"), this._controlContainer.className = this._horizontal ? "maplibregl-compare maplibregl-compare-horizontal" : "maplibregl-compare", this._controlContainer.className = this._controlContainer.className, this._controlContainer.appendChild(this._swiper), typeof l == "string" && document.body.querySelectorAll) {
        var d = document.body.querySelectorAll(l)[0];
        if (!d)
          throw new Error("Cannot find element with specified container selector.");
        d.appendChild(this._controlContainer);
      } else if (l instanceof Element && l.appendChild)
        l.appendChild(this._controlContainer);
      else
        throw new Error("Invalid container specified. Must be CSS selector or HTML element.");
      this._bounds = s.getContainer().getBoundingClientRect();
      var m = (this._horizontal ? this._bounds.height : this._bounds.width) / 2;
      this._setPosition(m), this._clearSync = e(i, s), this._onResize = (function() {
        this._bounds = s.getContainer().getBoundingClientRect(), this.currentPosition && this._setPosition(this.currentPosition);
      }).bind(this), s.on("resize", this._onResize), this.options && this.options.mousemove && (i.getContainer().addEventListener("mousemove", this._onMove), s.getContainer().addEventListener("mousemove", this._onMove)), this._swiper.addEventListener("mousedown", this._onDown), this._swiper.addEventListener("touchstart", this._onDown);
    }
    n.prototype = {
      _setPointerEvents: function(i) {
        this._controlContainer.style.pointerEvents = i, this._swiper.style.pointerEvents = i;
      },
      _onDown: function(i) {
        i.touches ? (document.addEventListener("touchmove", this._onMove), document.addEventListener("touchend", this._onTouchEnd)) : (document.addEventListener("mousemove", this._onMove), document.addEventListener("mouseup", this._onMouseUp));
      },
      _setPosition: function(i) {
        i = Math.min(i, this._horizontal ? this._bounds.height : this._bounds.width);
        var s = this._horizontal ? "translate(0, " + i + "px)" : "translate(" + i + "px, 0)";
        this._controlContainer.style.transform = s, this._controlContainer.style.WebkitTransform = s;
        var l = this._horizontal ? "rect(0, 999em, " + i + "px, 0)" : "rect(0, " + i + "px, " + this._bounds.height + "px, 0)", o = this._horizontal ? "rect(" + i + "px, 999em, " + this._bounds.height + "px,0)" : "rect(0, 999em, " + this._bounds.height + "px," + i + "px)";
        this._mapA.getContainer().style.clip = l, this._mapB.getContainer().style.clip = o, this.currentPosition = i;
      },
      _onMove: function(i) {
        this.options && this.options.mousemove && this._setPointerEvents(i.touches ? "auto" : "none"), this._horizontal ? this._setPosition(this._getY(i)) : this._setPosition(this._getX(i));
      },
      _onMouseUp: function() {
        document.removeEventListener("mousemove", this._onMove), document.removeEventListener("mouseup", this._onMouseUp), this.fire("slideend", {
          currentPosition: this.currentPosition
        });
      },
      _onTouchEnd: function() {
        document.removeEventListener("touchmove", this._onMove), document.removeEventListener("touchend", this._onTouchEnd), this.fire("slideend", {
          currentPosition: this.currentPosition
        });
      },
      _getX: function(i) {
        i = i.touches ? i.touches[0] : i;
        var s = i.clientX - this._bounds.left;
        return s < 0 && (s = 0), s > this._bounds.width && (s = this._bounds.width), s;
      },
      _getY: function(i) {
        i = i.touches ? i.touches[0] : i;
        var s = i.clientY - this._bounds.top;
        return s < 0 && (s = 0), s > this._bounds.height && (s = this._bounds.height), s;
      },
      /**
       * Set the position of the slider.
       *
       * @param {number} x Slider position in pixels from left/top.
       */
      setSlider: function(i) {
        this._setPosition(i);
      },
      /**
       * Adds a listener for events of a specified type.
       *
       * @param {string} type The event type to listen for; one of `slideend`.
       * @param {Function} listener The function to be called when the event is fired.
       * @returns {Compare} `this`
       */
      on: function(i, s) {
        return this._ev.on(i, s), this;
      },
      /**
       * Fire an event of a specified type.
       *
       * @param {string} type The event type to fire; one of `slideend`.
       * @param {Object} data Data passed to the event listener.
       * @returns {Compare} `this`
       */
      fire: function(i, s) {
        return this._ev.emit(i, s), this;
      },
      /**
       * Removes an event listener previously added with `Compare#on`.
       *
       * @param {string} type The event type previously used to install the listener.
       * @param {Function} listener The function previously installed as a listener.
       * @returns {Compare} `this`
       */
      off: function(i, s) {
        return this._ev.removeListener(i, s), this;
      },
      remove: function() {
        this._clearSync(), this._mapB.off("resize", this._onResize);
        var i = this._mapA.getContainer();
        i && (i.style.clip = null, i.removeEventListener("mousemove", this._onMove));
        var s = this._mapB.getContainer();
        s && (s.style.clip = null, s.removeEventListener("mousemove", this._onMove)), this._swiper.removeEventListener("mousedown", this._onDown), this._swiper.removeEventListener("touchstart", this._onDown), this._controlContainer.remove();
      }
    }, window.maplibregl ? maplibregl.Compare = n : r.exports = n;
  }(a1)), a1.exports;
}
var mK = gK();
const _K = /* @__PURE__ */ Dv(mK);
class WK {
  /**
   * Constructor for the map comparison class.
   * @class MapComparison
   * @param {Object} map1 - The first map object to compare.
   * @param {Object} map2 - The second map object to compare.
   * @param {string} container - The HTML container element ID for displaying the comparison.
   * @param {Object} options - Additional options for map comparison (if needed).
   */
  constructor(e, t, n, i) {
    const s = this;
    setTimeout(function() {
      s.mapCompare = new _K(e.map, t.map, n, {});
    }, 1e3);
  }
}
export {
  WK as C,
  $K as M,
  cK as a,
  ii as d
};
