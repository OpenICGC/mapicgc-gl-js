function GP(n, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i)
        if (r !== "default" && !(r in n)) {
          const l = Object.getOwnPropertyDescriptor(i, r);
          l && Object.defineProperty(n, r, l.get ? l : {
            enumerable: !0,
            get: () => i[r]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var VP = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function $m(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var aT = { exports: {} };
(function(n, e) {
  (function(t, i) {
    n.exports = i();
  })(VP, function() {
    var t = {}, i = {};
    function r(c, a, g) {
      if (i[c] = g, c === "index") {
        var y = "var sharedModule = {}; (" + i.shared + ")(sharedModule); (" + i.worker + ")(sharedModule);", A = {};
        return i.shared(A), i.index(t, A), typeof window < "u" && t.setWorkerUrl(window.URL.createObjectURL(new Blob([y], { type: "text/javascript" }))), t;
      }
    }
    r("shared", ["exports"], function(c) {
      function a(d, o, h, f) {
        return new (h || (h = Promise))(function(_, v) {
          function w(D) {
            try {
              R(f.next(D));
            } catch (z) {
              v(z);
            }
          }
          function P(D) {
            try {
              R(f.throw(D));
            } catch (z) {
              v(z);
            }
          }
          function R(D) {
            var z;
            D.done ? _(D.value) : (z = D.value, z instanceof h ? z : new h(function(j) {
              j(z);
            })).then(w, P);
          }
          R((f = f.apply(d, o || [])).next());
        });
      }
      function g(d) {
        return d && d.__esModule && Object.prototype.hasOwnProperty.call(d, "default") ? d.default : d;
      }
      var y, A;
      function C() {
        if (A) return y;
        function d(o, h) {
          this.x = o, this.y = h;
        }
        return A = 1, y = d, d.prototype = { clone: function() {
          return new d(this.x, this.y);
        }, add: function(o) {
          return this.clone()._add(o);
        }, sub: function(o) {
          return this.clone()._sub(o);
        }, multByPoint: function(o) {
          return this.clone()._multByPoint(o);
        }, divByPoint: function(o) {
          return this.clone()._divByPoint(o);
        }, mult: function(o) {
          return this.clone()._mult(o);
        }, div: function(o) {
          return this.clone()._div(o);
        }, rotate: function(o) {
          return this.clone()._rotate(o);
        }, rotateAround: function(o, h) {
          return this.clone()._rotateAround(o, h);
        }, matMult: function(o) {
          return this.clone()._matMult(o);
        }, unit: function() {
          return this.clone()._unit();
        }, perp: function() {
          return this.clone()._perp();
        }, round: function() {
          return this.clone()._round();
        }, mag: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }, equals: function(o) {
          return this.x === o.x && this.y === o.y;
        }, dist: function(o) {
          return Math.sqrt(this.distSqr(o));
        }, distSqr: function(o) {
          var h = o.x - this.x, f = o.y - this.y;
          return h * h + f * f;
        }, angle: function() {
          return Math.atan2(this.y, this.x);
        }, angleTo: function(o) {
          return Math.atan2(this.y - o.y, this.x - o.x);
        }, angleWith: function(o) {
          return this.angleWithSep(o.x, o.y);
        }, angleWithSep: function(o, h) {
          return Math.atan2(this.x * h - this.y * o, this.x * o + this.y * h);
        }, _matMult: function(o) {
          var h = o[2] * this.x + o[3] * this.y;
          return this.x = o[0] * this.x + o[1] * this.y, this.y = h, this;
        }, _add: function(o) {
          return this.x += o.x, this.y += o.y, this;
        }, _sub: function(o) {
          return this.x -= o.x, this.y -= o.y, this;
        }, _mult: function(o) {
          return this.x *= o, this.y *= o, this;
        }, _div: function(o) {
          return this.x /= o, this.y /= o, this;
        }, _multByPoint: function(o) {
          return this.x *= o.x, this.y *= o.y, this;
        }, _divByPoint: function(o) {
          return this.x /= o.x, this.y /= o.y, this;
        }, _unit: function() {
          return this._div(this.mag()), this;
        }, _perp: function() {
          var o = this.y;
          return this.y = this.x, this.x = -o, this;
        }, _rotate: function(o) {
          var h = Math.cos(o), f = Math.sin(o), _ = f * this.x + h * this.y;
          return this.x = h * this.x - f * this.y, this.y = _, this;
        }, _rotateAround: function(o, h) {
          var f = Math.cos(o), _ = Math.sin(o), v = h.y + _ * (this.x - h.x) + f * (this.y - h.y);
          return this.x = h.x + f * (this.x - h.x) - _ * (this.y - h.y), this.y = v, this;
        }, _round: function() {
          return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
        } }, d.convert = function(o) {
          return o instanceof d ? o : Array.isArray(o) ? new d(o[0], o[1]) : o;
        }, y;
      }
      typeof SuppressedError == "function" && SuppressedError;
      var I, S, F = g(C()), U = function() {
        if (S) return I;
        function d(o, h, f, _) {
          this.cx = 3 * o, this.bx = 3 * (f - o) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * h, this.by = 3 * (_ - h) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = o, this.p1y = h, this.p2x = f, this.p2y = _;
        }
        return S = 1, I = d, d.prototype = { sampleCurveX: function(o) {
          return ((this.ax * o + this.bx) * o + this.cx) * o;
        }, sampleCurveY: function(o) {
          return ((this.ay * o + this.by) * o + this.cy) * o;
        }, sampleCurveDerivativeX: function(o) {
          return (3 * this.ax * o + 2 * this.bx) * o + this.cx;
        }, solveCurveX: function(o, h) {
          if (h === void 0 && (h = 1e-6), o < 0) return 0;
          if (o > 1) return 1;
          for (var f = o, _ = 0; _ < 8; _++) {
            var v = this.sampleCurveX(f) - o;
            if (Math.abs(v) < h) return f;
            var w = this.sampleCurveDerivativeX(f);
            if (Math.abs(w) < 1e-6) break;
            f -= v / w;
          }
          var P = 0, R = 1;
          for (f = o, _ = 0; _ < 20 && (v = this.sampleCurveX(f), !(Math.abs(v - o) < h)); _++) o > v ? P = f : R = f, f = 0.5 * (R - P) + P;
          return f;
        }, solve: function(o, h) {
          return this.sampleCurveY(this.solveCurveX(o, h));
        } }, I;
      }(), V = g(U);
      let W, X;
      function de() {
        return W == null && (W = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") && typeof createImageBitmap == "function"), W;
      }
      function ie() {
        if (X == null && (X = !1, de())) {
          const o = new OffscreenCanvas(5, 5).getContext("2d", { willReadFrequently: !0 });
          if (o) {
            for (let f = 0; f < 5 * 5; f++) {
              const _ = 4 * f;
              o.fillStyle = `rgb(${_},${_ + 1},${_ + 2})`, o.fillRect(f % 5, Math.floor(f / 5), 1, 1);
            }
            const h = o.getImageData(0, 0, 5, 5).data;
            for (let f = 0; f < 5 * 5 * 4; f++) if (f % 4 != 3 && h[f] !== f) {
              X = !0;
              break;
            }
          }
        }
        return X || !1;
      }
      var fe, Ae = 1e-6, Te = typeof Float32Array < "u" ? Float32Array : Array;
      function me() {
        var d = new Te(9);
        return Te != Float32Array && (d[1] = 0, d[2] = 0, d[3] = 0, d[5] = 0, d[6] = 0, d[7] = 0), d[0] = 1, d[4] = 1, d[8] = 1, d;
      }
      function Ge(d) {
        return d[0] = 1, d[1] = 0, d[2] = 0, d[3] = 0, d[4] = 0, d[5] = 1, d[6] = 0, d[7] = 0, d[8] = 0, d[9] = 0, d[10] = 1, d[11] = 0, d[12] = 0, d[13] = 0, d[14] = 0, d[15] = 1, d;
      }
      function ke() {
        var d = new Te(3);
        return Te != Float32Array && (d[0] = 0, d[1] = 0, d[2] = 0), d;
      }
      function pe(d, o, h) {
        var f = new Te(3);
        return f[0] = d, f[1] = o, f[2] = h, f;
      }
      function _e(d, o, h) {
        var f = o[0], _ = o[1], v = o[2], w = o[3];
        return d[0] = h[0] * f + h[4] * _ + h[8] * v + h[12] * w, d[1] = h[1] * f + h[5] * _ + h[9] * v + h[13] * w, d[2] = h[2] * f + h[6] * _ + h[10] * v + h[14] * w, d[3] = h[3] * f + h[7] * _ + h[11] * v + h[15] * w, d;
      }
      function De() {
        var d = new Te(4);
        return Te != Float32Array && (d[0] = 0, d[1] = 0, d[2] = 0), d[3] = 1, d;
      }
      function Me() {
        var d = new Te(2);
        return Te != Float32Array && (d[0] = 0, d[1] = 0), d;
      }
      function St(d, o) {
        var h = new Te(2);
        return h[0] = d, h[1] = o, h;
      }
      Math.hypot || (Math.hypot = function() {
        for (var d = 0, o = arguments.length; o--; ) d += arguments[o] * arguments[o];
        return Math.sqrt(d);
      }), ke(), fe = new Te(4), Te != Float32Array && (fe[0] = 0, fe[1] = 0, fe[2] = 0, fe[3] = 0), ke(), pe(1, 0, 0), pe(0, 1, 0), De(), De(), me(), Me();
      const dt = 8192;
      function Pt(d, o, h) {
        return o * (dt / (d.tileSize * Math.pow(2, h - d.tileID.overscaledZ)));
      }
      function gt(d, o) {
        return (d % o + o) % o;
      }
      function Rt(d, o, h) {
        return d * (1 - h) + o * h;
      }
      function Ft(d) {
        if (d <= 0) return 0;
        if (d >= 1) return 1;
        const o = d * d, h = o * d;
        return 4 * (d < 0.5 ? h : 3 * (d - o) + h - 0.75);
      }
      function mn(d, o, h, f) {
        const _ = new V(d, o, h, f);
        return (v) => _.solve(v);
      }
      const oe = mn(0.25, 0.1, 0.25, 1);
      function Re(d, o, h) {
        return Math.min(h, Math.max(o, d));
      }
      function ze(d, o, h) {
        const f = h - o, _ = ((d - o) % f + f) % f + o;
        return _ === o ? h : _;
      }
      function Xe(d) {
        for (var o = arguments.length, h = new Array(o > 1 ? o - 1 : 0), f = 1; f < o; f++)
          h[f - 1] = arguments[f];
        for (const _ of h) for (const v in _) d[v] = _[v];
        return d;
      }
      let ot = 1;
      function rt(d, o, h) {
        const f = {};
        for (const _ in d) f[_] = o.call(this, d[_], _, d);
        return f;
      }
      function xt(d, o, h) {
        const f = {};
        for (const _ in d) o.call(this, d[_], _, d) && (f[_] = d[_]);
        return f;
      }
      function ht(d) {
        return Array.isArray(d) ? d.map(ht) : typeof d == "object" && d ? rt(d, ht) : d;
      }
      const $t = {};
      function Wt(d) {
        $t[d] || (typeof console < "u" && console.warn(d), $t[d] = !0);
      }
      function on(d, o, h) {
        return (h.y - d.y) * (o.x - d.x) > (o.y - d.y) * (h.x - d.x);
      }
      function hn(d) {
        return typeof WorkerGlobalScope < "u" && d !== void 0 && d instanceof WorkerGlobalScope;
      }
      let wn = null;
      function Bt(d) {
        return typeof ImageBitmap < "u" && d instanceof ImageBitmap;
      }
      const Ue = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
      function On(d, o, h, f, _) {
        return a(this, void 0, void 0, function* () {
          if (typeof VideoFrame > "u") throw new Error("VideoFrame not supported");
          const v = new VideoFrame(d, { timestamp: 0 });
          try {
            const w = v == null ? void 0 : v.format;
            if (!w || !w.startsWith("BGR") && !w.startsWith("RGB")) throw new Error(`Unrecognized format ${w}`);
            const P = w.startsWith("BGR"), R = new Uint8ClampedArray(f * _ * 4);
            if (yield v.copyTo(R, function(D, z, j, Y, K) {
              const Q = 4 * Math.max(1, 0), se = (Math.max(0, j) - j) * Y * 4 + Q, Ee = 4 * Y, Se = Math.max(0, z), et = Math.max(0, j);
              return { rect: { x: Se, y: et, width: Math.min(D.width, z + Y) - Se, height: Math.min(D.height, j + K) - et }, layout: [{ offset: se, stride: Ee }] };
            }(d, o, h, f, _)), P) for (let D = 0; D < R.length; D += 4) {
              const z = R[D];
              R[D] = R[D + 2], R[D + 2] = z;
            }
            return R;
          } finally {
            v.close();
          }
        });
      }
      let Sn, en;
      function ln(d) {
        return d / Math.PI * 180;
      }
      const un = "AbortError";
      function _n() {
        return new Error(un);
      }
      const Mn = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
      function Wn(d) {
        return Mn.REGISTERED_PROTOCOLS[d.substring(0, d.indexOf("://"))];
      }
      const $n = "global-dispatcher";
      class Yn extends Error {
        constructor(o, h, f, _) {
          super(`AJAXError: ${h} (${o}): ${f}`), this.status = o, this.statusText = h, this.url = f, this.body = _;
        }
      }
      const si = () => hn(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href, fi = function(d, o) {
        if (/:\/\//.test(d.url) && !/^https?:|^file:/.test(d.url)) {
          const f = Wn(d.url);
          if (f) return f(d, o);
          if (hn(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: d, targetMapId: $n }, o);
        }
        if (!(/^file:/.test(h = d.url) || /^file:/.test(si()) && !/^\w+:/.test(h))) {
          if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal")) return function(f, _) {
            return a(this, void 0, void 0, function* () {
              const v = new Request(f.url, { method: f.method || "GET", body: f.body, credentials: f.credentials, headers: f.headers, cache: f.cache, referrer: si(), signal: _.signal });
              let w, P;
              f.type !== "json" || v.headers.has("Accept") || v.headers.set("Accept", "application/json");
              try {
                w = yield fetch(v);
              } catch (D) {
                throw new Yn(0, D.message, f.url, new Blob());
              }
              if (!w.ok) {
                const D = yield w.blob();
                throw new Yn(w.status, w.statusText, f.url, D);
              }
              P = f.type === "arrayBuffer" || f.type === "image" ? w.arrayBuffer() : f.type === "json" ? w.json() : w.text();
              const R = yield P;
              if (_.signal.aborted) throw _n();
              return { data: R, cacheControl: w.headers.get("Cache-Control"), expires: w.headers.get("Expires") };
            });
          }(d, o);
          if (hn(self) && self.worker && self.worker.actor) return self.worker.actor.sendAsync({ type: "GR", data: d, mustQueue: !0, targetMapId: $n }, o);
        }
        var h;
        return function(f, _) {
          return new Promise((v, w) => {
            var P;
            const R = new XMLHttpRequest();
            R.open(f.method || "GET", f.url, !0), f.type !== "arrayBuffer" && f.type !== "image" || (R.responseType = "arraybuffer");
            for (const D in f.headers) R.setRequestHeader(D, f.headers[D]);
            f.type === "json" && (R.responseType = "text", !((P = f.headers) === null || P === void 0) && P.Accept || R.setRequestHeader("Accept", "application/json")), R.withCredentials = f.credentials === "include", R.onerror = () => {
              w(new Error(R.statusText));
            }, R.onload = () => {
              if (!_.signal.aborted) if ((R.status >= 200 && R.status < 300 || R.status === 0) && R.response !== null) {
                let D = R.response;
                if (f.type === "json") try {
                  D = JSON.parse(R.response);
                } catch (z) {
                  return void w(z);
                }
                v({ data: D, cacheControl: R.getResponseHeader("Cache-Control"), expires: R.getResponseHeader("Expires") });
              } else {
                const D = new Blob([R.response], { type: R.getResponseHeader("Content-Type") });
                w(new Yn(R.status, R.statusText, f.url, D));
              }
            }, _.signal.addEventListener("abort", () => {
              R.abort(), w(_n());
            }), R.send(f.body);
          });
        }(d, o);
      };
      function Un(d) {
        if (!d || d.indexOf("://") <= 0 || d.indexOf("data:image/") === 0 || d.indexOf("blob:") === 0) return !0;
        const o = new URL(d), h = window.location;
        return o.protocol === h.protocol && o.host === h.host;
      }
      function Jn(d, o, h) {
        h[d] && h[d].indexOf(o) !== -1 || (h[d] = h[d] || [], h[d].push(o));
      }
      function bn(d, o, h) {
        if (h && h[d]) {
          const f = h[d].indexOf(o);
          f !== -1 && h[d].splice(f, 1);
        }
      }
      class tr {
        constructor(o) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          Xe(this, h), this.type = o;
        }
      }
      class pi extends tr {
        constructor(o) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          super("error", Xe({ error: o }, h));
        }
      }
      class Dr {
        on(o, h) {
          return this._listeners = this._listeners || {}, Jn(o, h, this._listeners), { unsubscribe: () => {
            this.off(o, h);
          } };
        }
        off(o, h) {
          return bn(o, h, this._listeners), bn(o, h, this._oneTimeListeners), this;
        }
        once(o, h) {
          return h ? (this._oneTimeListeners = this._oneTimeListeners || {}, Jn(o, h, this._oneTimeListeners), this) : new Promise((f) => this.once(o, f));
        }
        fire(o, h) {
          typeof o == "string" && (o = new tr(o, h || {}));
          const f = o.type;
          if (this.listens(f)) {
            o.target = this;
            const _ = this._listeners && this._listeners[f] ? this._listeners[f].slice() : [];
            for (const P of _) P.call(this, o);
            const v = this._oneTimeListeners && this._oneTimeListeners[f] ? this._oneTimeListeners[f].slice() : [];
            for (const P of v) bn(f, P, this._oneTimeListeners), P.call(this, o);
            const w = this._eventedParent;
            w && (Xe(o, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData), w.fire(o));
          } else o instanceof pi && console.error(o.error);
          return this;
        }
        listens(o) {
          return this._listeners && this._listeners[o] && this._listeners[o].length > 0 || this._oneTimeListeners && this._oneTimeListeners[o] && this._oneTimeListeners[o].length > 0 || this._eventedParent && this._eventedParent.listens(o);
        }
        setEventedParent(o, h) {
          return this._eventedParent = o, this._eventedParentData = h, this;
        }
      }
      var be = { $version: 8, $root: { version: { required: !0, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, centerAltitude: { type: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, roll: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sky: { type: "sky" }, projection: { type: "projection" }, terrain: { type: "terrain" }, sources: { required: !0, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: !0, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: !0, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster: { type: { required: !0, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_raster_dem: { type: { required: !0, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: !1 }, "*": { type: "*" } }, source_geojson: { type: { required: !0, type: "enum", values: { geojson: {} } }, data: { required: !0, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: !1 }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: !1 }, generateId: { type: "boolean", default: !1 }, promoteId: { type: "promoteId" } }, source_video: { type: { required: !0, type: "enum", values: { video: {} } }, urls: { required: !0, type: "array", value: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: !0, type: "enum", values: { image: {} } }, url: { required: !0, type: "string" }, coordinates: { required: !0, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: !0 }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: !0 }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: !1, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: !1, requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: !1, requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: !1, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: !0, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: !0, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: !0, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: !1, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: !1, requires: ["text-field"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: !1, requires: ["text-field", "icon-image"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: !1 } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: !1, expression: { interpolated: !1, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, sky: { "sky-color": { type: "color", "property-type": "data-constant", default: "#88C6FC", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-color": { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "fog-ground-blend": { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "horizon-fog-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "sky-horizon-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 }, "atmosphere-blend": { type: "number", "property-type": "data-constant", default: 0.8, minimum: 0, maximum: 1, expression: { interpolated: !0, parameters: ["zoom"] }, transition: !0 } }, terrain: { source: { type: "string", required: !0 }, exaggeration: { type: "number", minimum: 0, default: 1 } }, projection: { type: { type: "projectionDefinition", default: "mercator", "property-type": "data-constant", transition: !1, expression: { interpolated: !0, parameters: ["zoom"] } } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: !0, requires: [{ "!": "fill-pattern" }, { "fill-antialias": !0 }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: !0, requires: ["fill-extrusion-height"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: !0, transition: !1, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "line-pattern" }], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: !0, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: !1, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: !0 } }], expression: { interpolated: !0, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: !0, units: "pixels", expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: !1, expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: !1, expression: { interpolated: !0, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["icon-image"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: !0, overridable: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: !0, requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: !0, units: "pixels", requires: ["text-field"], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: !0, units: "degrees", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: !1, units: "milliseconds", expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: !1, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: !0, requires: [{ "!": "background-pattern" }], expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: !0, expression: { interpolated: !1, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: !0, expression: { interpolated: !0, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
      const ne = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
      function ce(d, o) {
        const h = {};
        for (const f in d) f !== "ref" && (h[f] = d[f]);
        return ne.forEach((f) => {
          f in o && (h[f] = o[f]);
        }), h;
      }
      function ue(d, o) {
        if (Array.isArray(d)) {
          if (!Array.isArray(o) || d.length !== o.length) return !1;
          for (let h = 0; h < d.length; h++) if (!ue(d[h], o[h])) return !1;
          return !0;
        }
        if (typeof d == "object" && d !== null && o !== null) {
          if (typeof o != "object" || Object.keys(d).length !== Object.keys(o).length) return !1;
          for (const h in d) if (!ue(d[h], o[h])) return !1;
          return !0;
        }
        return d === o;
      }
      function Oe(d, o) {
        d.push(o);
      }
      function qe(d, o, h) {
        Oe(h, { command: "addSource", args: [d, o[d]] });
      }
      function it(d, o, h) {
        Oe(o, { command: "removeSource", args: [d] }), h[d] = !0;
      }
      function mt(d, o, h, f) {
        it(d, h, f), qe(d, o, h);
      }
      function Ye(d, o, h) {
        let f;
        for (f in d[h]) if (Object.prototype.hasOwnProperty.call(d[h], f) && f !== "data" && !ue(d[h][f], o[h][f])) return !1;
        for (f in o[h]) if (Object.prototype.hasOwnProperty.call(o[h], f) && f !== "data" && !ue(d[h][f], o[h][f])) return !1;
        return !0;
      }
      function at(d, o, h, f, _, v) {
        d = d || {}, o = o || {};
        for (const w in d) Object.prototype.hasOwnProperty.call(d, w) && (ue(d[w], o[w]) || h.push({ command: v, args: [f, w, o[w], _] }));
        for (const w in o) Object.prototype.hasOwnProperty.call(o, w) && !Object.prototype.hasOwnProperty.call(d, w) && (ue(d[w], o[w]) || h.push({ command: v, args: [f, w, o[w], _] }));
      }
      function pt(d) {
        return d.id;
      }
      function lt(d, o) {
        return d[o.id] = o, d;
      }
      class Ze {
        constructor(o, h, f, _) {
          this.message = (o ? `${o}: ` : "") + f, _ && (this.identifier = _), h != null && h.__line__ && (this.line = h.__line__);
        }
      }
      function an(d) {
        for (var o = arguments.length, h = new Array(o > 1 ? o - 1 : 0), f = 1; f < o; f++)
          h[f - 1] = arguments[f];
        for (const _ of h) for (const v in _) d[v] = _[v];
        return d;
      }
      class Yt extends Error {
        constructor(o, h) {
          super(h), this.message = h, this.key = o;
        }
      }
      class Xt {
        constructor(o) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
          this.parent = o, this.bindings = {};
          for (const [f, _] of h) this.bindings[f] = _;
        }
        concat(o) {
          return new Xt(this, o);
        }
        get(o) {
          if (this.bindings[o]) return this.bindings[o];
          if (this.parent) return this.parent.get(o);
          throw new Error(`${o} not found in scope.`);
        }
        has(o) {
          return !!this.bindings[o] || !!this.parent && this.parent.has(o);
        }
      }
      const An = { kind: "null" }, It = { kind: "number" }, Jt = { kind: "string" }, cn = { kind: "boolean" }, In = { kind: "color" }, Zn = { kind: "projectionDefinition" }, Ln = { kind: "object" }, fn = { kind: "value" }, xi = { kind: "collator" }, Er = { kind: "formatted" }, Pi = { kind: "padding" }, Ii = { kind: "resolvedImage" }, ui = { kind: "variableAnchorOffsetCollection" };
      function Oi(d, o) {
        return { kind: "array", itemType: d, N: o };
      }
      function _i(d) {
        if (d.kind === "array") {
          const o = _i(d.itemType);
          return typeof d.N == "number" ? `array<${o}, ${d.N}>` : d.itemType.kind === "value" ? "array" : `array<${o}>`;
        }
        return d.kind;
      }
      const xs = [An, It, Jt, cn, In, Zn, Er, Ln, Oi(fn), Pi, Ii, ui];
      function ws(d, o) {
        if (o.kind === "error") return null;
        if (d.kind === "array") {
          if (o.kind === "array" && (o.N === 0 && o.itemType.kind === "value" || !ws(d.itemType, o.itemType)) && (typeof d.N != "number" || d.N === o.N)) return null;
        } else {
          if (d.kind === o.kind) return null;
          if (d.kind === "value") {
            for (const h of xs) if (!ws(h, o)) return null;
          }
        }
        return `Expected ${_i(d)} but found ${_i(o)} instead.`;
      }
      function Ao(d, o) {
        return o.some((h) => h.kind === d.kind);
      }
      function qs(d, o) {
        return o.some((h) => h === "null" ? d === null : h === "array" ? Array.isArray(d) : h === "object" ? d && !Array.isArray(d) && typeof d == "object" : h === typeof d);
      }
      function To(d, o) {
        return d.kind === "array" && o.kind === "array" ? d.itemType.kind === o.itemType.kind && typeof d.N == "number" : d.kind === o.kind;
      }
      const Ia = 0.96422, Hr = 0.82521, Hs = 4 / 29, Wr = 6 / 29, Ws = 3 * Wr * Wr, $o = Wr * Wr * Wr, Zs = Math.PI / 180, $s = 180 / Math.PI;
      function Il(d) {
        return (d %= 360) < 0 && (d += 360), d;
      }
      function Xo(d) {
        let [o, h, f, _] = d, v, w;
        const P = Ti((0.2225045 * (o = Xs(o)) + 0.7168786 * (h = Xs(h)) + 0.0606169 * (f = Xs(f))) / 1);
        o === h && h === f ? v = w = P : (v = Ti((0.4360747 * o + 0.3850649 * h + 0.1430804 * f) / Ia), w = Ti((0.0139322 * o + 0.0971045 * h + 0.7141733 * f) / Hr));
        const R = 116 * P - 16;
        return [R < 0 ? 0 : R, 500 * (v - P), 200 * (P - w), _];
      }
      function Xs(d) {
        return d <= 0.04045 ? d / 12.92 : Math.pow((d + 0.055) / 1.055, 2.4);
      }
      function Ti(d) {
        return d > $o ? Math.pow(d, 1 / 3) : d / Ws + Hs;
      }
      function ha(d) {
        let [o, h, f, _] = d, v = (o + 16) / 116, w = isNaN(h) ? v : v + h / 500, P = isNaN(f) ? v : v - f / 200;
        return v = 1 * da(v), w = Ia * da(w), P = Hr * da(P), [Ys(3.1338561 * w - 1.6168667 * v - 0.4906146 * P), Ys(-0.9787684 * w + 1.9161415 * v + 0.033454 * P), Ys(0.0719453 * w - 0.2289914 * v + 1.4052427 * P), _];
      }
      function Ys(d) {
        return (d = d <= 304e-5 ? 12.92 * d : 1.055 * Math.pow(d, 1 / 2.4) - 0.055) < 0 ? 0 : d > 1 ? 1 : d;
      }
      function da(d) {
        return d > Wr ? d * d * d : Ws * (d - Hs);
      }
      function Eo(d) {
        return parseInt(d.padEnd(2, d), 16) / 255;
      }
      function sl(d, o) {
        return yr(o ? d / 100 : d, 0, 1);
      }
      function yr(d, o, h) {
        return Math.min(Math.max(o, d), h);
      }
      function os(d) {
        return !d.some(Number.isNaN);
      }
      const nr = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      function Xn(d, o, h) {
        return d + h * (o - d);
      }
      function as(d, o, h) {
        return d.map((f, _) => Xn(f, o[_], h));
      }
      class Qn {
        constructor(o, h, f) {
          let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, v = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0;
          this.r = o, this.g = h, this.b = f, this.a = _, v || (this.r *= _, this.g *= _, this.b *= _, _ || this.overwriteGetter("rgb", [o, h, f, _]));
        }
        static parse(o) {
          if (o instanceof Qn) return o;
          if (typeof o != "string") return;
          const h = function(f) {
            if ((f = f.toLowerCase().trim()) === "transparent") return [0, 0, 0, 0];
            const _ = nr[f];
            if (_) {
              const [w, P, R] = _;
              return [w / 255, P / 255, R / 255, 1];
            }
            if (f.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(f)) {
              const w = f.length < 6 ? 1 : 2;
              let P = 1;
              return [Eo(f.slice(P, P += w)), Eo(f.slice(P, P += w)), Eo(f.slice(P, P += w)), Eo(f.slice(P, P + w) || "ff")];
            }
            if (f.startsWith("rgb")) {
              const w = f.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
              if (w) {
                const [P, R, D, z, j, Y, K, Q, se, Ee, Se, et] = w, Ne = [z || " ", K || " ", Ee].join("");
                if (Ne === "  " || Ne === "  /" || Ne === ",," || Ne === ",,,") {
                  const J = [D, Y, se].join(""), ve = J === "%%%" ? 100 : J === "" ? 255 : 0;
                  if (ve) {
                    const je = [yr(+R / ve, 0, 1), yr(+j / ve, 0, 1), yr(+Q / ve, 0, 1), Se ? sl(+Se, et) : 1];
                    if (os(je)) return je;
                  }
                }
                return;
              }
            }
            const v = f.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
            if (v) {
              const [w, P, R, D, z, j, Y, K, Q] = v, se = [R || " ", z || " ", Y].join("");
              if (se === "  " || se === "  /" || se === ",," || se === ",,,") {
                const Ee = [+P, yr(+D, 0, 100), yr(+j, 0, 100), K ? sl(+K, Q) : 1];
                if (os(Ee)) return function(Se) {
                  let [et, Ne, J, ve] = Se;
                  function je(vt) {
                    const Vt = (vt + et / 30) % 12, Et = Ne * Math.min(J, 1 - J);
                    return J - Et * Math.max(-1, Math.min(Vt - 3, 9 - Vt, 1));
                  }
                  return et = Il(et), Ne /= 100, J /= 100, [je(0), je(8), je(4), ve];
                }(Ee);
              }
            }
          }(o);
          return h ? new Qn(...h, !1) : void 0;
        }
        get rgb() {
          const { r: o, g: h, b: f, a: _ } = this, v = _ || 1 / 0;
          return this.overwriteGetter("rgb", [o / v, h / v, f / v, _]);
        }
        get hcl() {
          return this.overwriteGetter("hcl", function(o) {
            const [h, f, _, v] = Xo(o), w = Math.sqrt(f * f + _ * _);
            return [Math.round(1e4 * w) ? Il(Math.atan2(_, f) * $s) : NaN, w, h, v];
          }(this.rgb));
        }
        get lab() {
          return this.overwriteGetter("lab", Xo(this.rgb));
        }
        overwriteGetter(o, h) {
          return Object.defineProperty(this, o, { value: h }), h;
        }
        toString() {
          const [o, h, f, _] = this.rgb;
          return `rgba(${[o, h, f].map((v) => Math.round(255 * v)).join(",")},${_})`;
        }
        static interpolate(o, h, f) {
          switch (arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "rgb") {
            case "rgb": {
              const [v, w, P, R] = as(o.rgb, h.rgb, f);
              return new Qn(v, w, P, R, !1);
            }
            case "hcl": {
              const [v, w, P, R] = o.hcl, [D, z, j, Y] = h.hcl;
              let K, Q;
              if (isNaN(v) || isNaN(D)) isNaN(v) ? isNaN(D) ? K = NaN : (K = D, P !== 1 && P !== 0 || (Q = z)) : (K = v, j !== 1 && j !== 0 || (Q = w));
              else {
                let Ne = D - v;
                D > v && Ne > 180 ? Ne -= 360 : D < v && v - D > 180 && (Ne += 360), K = v + f * Ne;
              }
              const [se, Ee, Se, et] = function(Ne) {
                let [J, ve, je, vt] = Ne;
                return J = isNaN(J) ? 0 : J * Zs, ha([je, Math.cos(J) * ve, Math.sin(J) * ve, vt]);
              }([K, Q ?? Xn(w, z, f), Xn(P, j, f), Xn(R, Y, f)]);
              return new Qn(se, Ee, Se, et, !1);
            }
            case "lab": {
              const [v, w, P, R] = ha(as(o.lab, h.lab, f));
              return new Qn(v, w, P, R, !1);
            }
          }
        }
      }
      Qn.black = new Qn(0, 0, 0, 1), Qn.white = new Qn(1, 1, 1, 1), Qn.transparent = new Qn(0, 0, 0, 0), Qn.red = new Qn(1, 0, 0, 1);
      class Ma {
        constructor(o, h, f) {
          this.sensitivity = o ? h ? "variant" : "case" : h ? "accent" : "base", this.locale = f, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
        }
        compare(o, h) {
          return this.collator.compare(o, h);
        }
        resolvedLocale() {
          return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
        }
      }
      const Ec = ["bottom", "center", "top"];
      class ge {
        constructor(o, h, f, _, v, w) {
          this.text = o, this.image = h, this.scale = f, this.fontStack = _, this.textColor = v, this.verticalAlign = w;
        }
      }
      class we {
        constructor(o) {
          this.sections = o;
        }
        static fromString(o) {
          return new we([new ge(o, null, null, null, null, null)]);
        }
        isEmpty() {
          return this.sections.length === 0 || !this.sections.some((o) => o.text.length !== 0 || o.image && o.image.name.length !== 0);
        }
        static factory(o) {
          return o instanceof we ? o : we.fromString(o);
        }
        toString() {
          return this.sections.length === 0 ? "" : this.sections.map((o) => o.text).join("");
        }
      }
      class Ve {
        constructor(o) {
          this.values = o.slice();
        }
        static parse(o) {
          if (o instanceof Ve) return o;
          if (typeof o == "number") return new Ve([o, o, o, o]);
          if (Array.isArray(o) && !(o.length < 1 || o.length > 4)) {
            for (const h of o) if (typeof h != "number") return;
            switch (o.length) {
              case 1:
                o = [o[0], o[0], o[0], o[0]];
                break;
              case 2:
                o = [o[0], o[1], o[0], o[1]];
                break;
              case 3:
                o = [o[0], o[1], o[2], o[1]];
            }
            return new Ve(o);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(o, h, f) {
          return new Ve(as(o.values, h.values, f));
        }
      }
      class _t {
        constructor(o) {
          this.name = "ExpressionEvaluationError", this.message = o;
        }
        toJSON() {
          return this.message;
        }
      }
      const Kt = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
      class gn {
        constructor(o) {
          this.values = o.slice();
        }
        static parse(o) {
          if (o instanceof gn) return o;
          if (Array.isArray(o) && !(o.length < 1) && o.length % 2 == 0) {
            for (let h = 0; h < o.length; h += 2) {
              const f = o[h], _ = o[h + 1];
              if (typeof f != "string" || !Kt.has(f) || !Array.isArray(_) || _.length !== 2 || typeof _[0] != "number" || typeof _[1] != "number") return;
            }
            return new gn(o);
          }
        }
        toString() {
          return JSON.stringify(this.values);
        }
        static interpolate(o, h, f) {
          const _ = o.values, v = h.values;
          if (_.length !== v.length) throw new _t(`Cannot interpolate values of different length. from: ${o.toString()}, to: ${h.toString()}`);
          const w = [];
          for (let P = 0; P < _.length; P += 2) {
            if (_[P] !== v[P]) throw new _t(`Cannot interpolate values containing mismatched anchors. from[${P}]: ${_[P]}, to[${P}]: ${v[P]}`);
            w.push(_[P]);
            const [R, D] = _[P + 1], [z, j] = v[P + 1];
            w.push([Xn(R, z, f), Xn(D, j, f)]);
          }
          return new gn(w);
        }
      }
      class Rn {
        constructor(o) {
          this.name = o.name, this.available = o.available;
        }
        toString() {
          return this.name;
        }
        static fromString(o) {
          return o ? new Rn({ name: o, available: !1 }) : null;
        }
      }
      class hi {
        constructor(o, h, f) {
          this.from = o, this.to = h, this.transition = f;
        }
        static interpolate(o, h, f) {
          return new hi(o, h, f);
        }
        static parse(o) {
          return o instanceof hi ? o : Array.isArray(o) && o.length === 3 && typeof o[0] == "string" && typeof o[1] == "string" && typeof o[2] == "number" ? new hi(o[0], o[1], o[2]) : typeof o == "object" && typeof o.from == "string" && typeof o.to == "string" && typeof o.transition == "number" ? new hi(o.from, o.to, o.transition) : typeof o == "string" ? new hi(o, o, 1) : void 0;
        }
      }
      function Ji(d, o, h, f) {
        return typeof d == "number" && d >= 0 && d <= 255 && typeof o == "number" && o >= 0 && o <= 255 && typeof h == "number" && h >= 0 && h <= 255 ? f === void 0 || typeof f == "number" && f >= 0 && f <= 1 ? null : `Invalid rgba value [${[d, o, h, f].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof f == "number" ? [d, o, h, f] : [d, o, h]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
      }
      function Ki(d) {
        if (d === null || typeof d == "string" || typeof d == "boolean" || typeof d == "number" || d instanceof hi || d instanceof Qn || d instanceof Ma || d instanceof we || d instanceof Ve || d instanceof gn || d instanceof Rn) return !0;
        if (Array.isArray(d)) {
          for (const o of d) if (!Ki(o)) return !1;
          return !0;
        }
        if (typeof d == "object") {
          for (const o in d) if (!Ki(d[o])) return !1;
          return !0;
        }
        return !1;
      }
      function qn(d) {
        if (d === null) return An;
        if (typeof d == "string") return Jt;
        if (typeof d == "boolean") return cn;
        if (typeof d == "number") return It;
        if (d instanceof Qn) return In;
        if (d instanceof hi) return Zn;
        if (d instanceof Ma) return xi;
        if (d instanceof we) return Er;
        if (d instanceof Ve) return Pi;
        if (d instanceof gn) return ui;
        if (d instanceof Rn) return Ii;
        if (Array.isArray(d)) {
          const o = d.length;
          let h;
          for (const f of d) {
            const _ = qn(f);
            if (h) {
              if (h === _) continue;
              h = fn;
              break;
            }
            h = _;
          }
          return Oi(h || fn, o);
        }
        return Ln;
      }
      function Ml(d) {
        const o = typeof d;
        return d === null ? "" : o === "string" || o === "number" || o === "boolean" ? String(d) : d instanceof Qn || d instanceof hi || d instanceof we || d instanceof Ve || d instanceof gn || d instanceof Rn ? d.toString() : JSON.stringify(d);
      }
      class ho {
        constructor(o, h) {
          this.type = o, this.value = h;
        }
        static parse(o, h) {
          if (o.length !== 2) return h.error(`'literal' expression requires exactly one argument, but found ${o.length - 1} instead.`);
          if (!Ki(o[1])) return h.error("invalid value");
          const f = o[1];
          let _ = qn(f);
          const v = h.expectedType;
          return _.kind !== "array" || _.N !== 0 || !v || v.kind !== "array" || typeof v.N == "number" && v.N !== 0 || (_ = v), new ho(_, f);
        }
        evaluate() {
          return this.value;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      const Vn = { string: Jt, number: It, boolean: cn, object: Ln };
      class Js {
        constructor(o, h) {
          this.type = o, this.args = h;
        }
        static parse(o, h) {
          if (o.length < 2) return h.error("Expected at least one argument.");
          let f, _ = 1;
          const v = o[0];
          if (v === "array") {
            let P, R;
            if (o.length > 2) {
              const D = o[1];
              if (typeof D != "string" || !(D in Vn) || D === "object") return h.error('The item type argument of "array" must be one of string, number, boolean', 1);
              P = Vn[D], _++;
            } else P = fn;
            if (o.length > 3) {
              if (o[2] !== null && (typeof o[2] != "number" || o[2] < 0 || o[2] !== Math.floor(o[2]))) return h.error('The length argument to "array" must be a positive integer literal', 2);
              R = o[2], _++;
            }
            f = Oi(P, R);
          } else {
            if (!Vn[v]) throw new Error(`Types doesn't contain name = ${v}`);
            f = Vn[v];
          }
          const w = [];
          for (; _ < o.length; _++) {
            const P = h.parse(o[_], _, fn);
            if (!P) return null;
            w.push(P);
          }
          return new Js(f, w);
        }
        evaluate(o) {
          for (let h = 0; h < this.args.length; h++) {
            const f = this.args[h].evaluate(o);
            if (!ws(this.type, qn(f))) return f;
            if (h === this.args.length - 1) throw new _t(`Expected value to be of type ${_i(this.type)}, but found ${_i(qn(f))} instead.`);
          }
          throw new Error();
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return this.args.every((o) => o.outputDefined());
        }
      }
      const ru = { "to-boolean": cn, "to-color": In, "to-number": It, "to-string": Jt };
      class Zr {
        constructor(o, h) {
          this.type = o, this.args = h;
        }
        static parse(o, h) {
          if (o.length < 2) return h.error("Expected at least one argument.");
          const f = o[0];
          if (!ru[f]) throw new Error(`Can't parse ${f} as it is not part of the known types`);
          if ((f === "to-boolean" || f === "to-string") && o.length !== 2) return h.error("Expected one argument.");
          const _ = ru[f], v = [];
          for (let w = 1; w < o.length; w++) {
            const P = h.parse(o[w], w, fn);
            if (!P) return null;
            v.push(P);
          }
          return new Zr(_, v);
        }
        evaluate(o) {
          switch (this.type.kind) {
            case "boolean":
              return !!this.args[0].evaluate(o);
            case "color": {
              let h, f;
              for (const _ of this.args) {
                if (h = _.evaluate(o), f = null, h instanceof Qn) return h;
                if (typeof h == "string") {
                  const v = o.parseColor(h);
                  if (v) return v;
                } else if (Array.isArray(h) && (f = h.length < 3 || h.length > 4 ? `Invalid rgba value ${JSON.stringify(h)}: expected an array containing either three or four numeric values.` : Ji(h[0], h[1], h[2], h[3]), !f)) return new Qn(h[0] / 255, h[1] / 255, h[2] / 255, h[3]);
              }
              throw new _t(f || `Could not parse color from value '${typeof h == "string" ? h : JSON.stringify(h)}'`);
            }
            case "padding": {
              let h;
              for (const f of this.args) {
                h = f.evaluate(o);
                const _ = Ve.parse(h);
                if (_) return _;
              }
              throw new _t(`Could not parse padding from value '${typeof h == "string" ? h : JSON.stringify(h)}'`);
            }
            case "variableAnchorOffsetCollection": {
              let h;
              for (const f of this.args) {
                h = f.evaluate(o);
                const _ = gn.parse(h);
                if (_) return _;
              }
              throw new _t(`Could not parse variableAnchorOffsetCollection from value '${typeof h == "string" ? h : JSON.stringify(h)}'`);
            }
            case "number": {
              let h = null;
              for (const f of this.args) {
                if (h = f.evaluate(o), h === null) return 0;
                const _ = Number(h);
                if (!isNaN(_)) return _;
              }
              throw new _t(`Could not convert ${JSON.stringify(h)} to number.`);
            }
            case "formatted":
              return we.fromString(Ml(this.args[0].evaluate(o)));
            case "resolvedImage":
              return Rn.fromString(Ml(this.args[0].evaluate(o)));
            case "projectionDefinition":
              return this.args[0].evaluate(o);
            default:
              return Ml(this.args[0].evaluate(o));
          }
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return this.args.every((o) => o.outputDefined());
        }
      }
      const Ll = ["Unknown", "Point", "LineString", "Polygon"];
      class Ui {
        constructor() {
          this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
        }
        id() {
          return this.feature && "id" in this.feature ? this.feature.id : null;
        }
        geometryType() {
          return this.feature ? typeof this.feature.type == "number" ? Ll[this.feature.type] : this.feature.type : null;
        }
        geometry() {
          return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
        }
        canonicalID() {
          return this.canonical;
        }
        properties() {
          return this.feature && this.feature.properties || {};
        }
        parseColor(o) {
          let h = this._parseColorCache[o];
          return h || (h = this._parseColorCache[o] = Qn.parse(o)), h;
        }
      }
      class Yo {
        constructor(o, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], _ = arguments.length > 3 ? arguments[3] : void 0, v = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new Xt(), w = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : [];
          this.registry = o, this.path = f, this.key = f.map((P) => `[${P}]`).join(""), this.scope = v, this.errors = w, this.expectedType = _, this._isConstant = h;
        }
        parse(o, h, f, _) {
          let v = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          return h ? this.concat(h, f, _)._parse(o, v) : this._parse(o, v);
        }
        _parse(o, h) {
          function f(_, v, w) {
            return w === "assert" ? new Js(v, [_]) : w === "coerce" ? new Zr(v, [_]) : _;
          }
          if (o !== null && typeof o != "string" && typeof o != "boolean" && typeof o != "number" || (o = ["literal", o]), Array.isArray(o)) {
            if (o.length === 0) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
            const _ = o[0];
            if (typeof _ != "string") return this.error(`Expression name must be a string, but found ${typeof _} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
            const v = this.registry[_];
            if (v) {
              let w = v.parse(o, this);
              if (!w) return null;
              if (this.expectedType) {
                const P = this.expectedType, R = w.type;
                if (P.kind !== "string" && P.kind !== "number" && P.kind !== "boolean" && P.kind !== "object" && P.kind !== "array" || R.kind !== "value")
                  if (P.kind !== "projectionDefinition" || R.kind !== "string" && R.kind !== "array")
                    if (P.kind !== "color" && P.kind !== "formatted" && P.kind !== "resolvedImage" || R.kind !== "value" && R.kind !== "string")
                      if (P.kind !== "padding" || R.kind !== "value" && R.kind !== "number" && R.kind !== "array")
                        if (P.kind !== "variableAnchorOffsetCollection" || R.kind !== "value" && R.kind !== "array") {
                          if (this.checkSubtype(P, R)) return null;
                        } else w = f(w, P, h.typeAnnotation || "coerce");
                      else w = f(w, P, h.typeAnnotation || "coerce");
                    else w = f(w, P, h.typeAnnotation || "coerce");
                  else w = f(w, P, h.typeAnnotation || "coerce");
                else w = f(w, P, h.typeAnnotation || "assert");
              }
              if (!(w instanceof ho) && w.type.kind !== "resolvedImage" && this._isConstant(w)) {
                const P = new Ui();
                try {
                  w = new ho(w.type, w.evaluate(P));
                } catch (R) {
                  return this.error(R.message), null;
                }
              }
              return w;
            }
            return this.error(`Unknown expression "${_}". If you wanted a literal array, use ["literal", [...]].`, 0);
          }
          return this.error(o === void 0 ? "'undefined' value invalid. Use null instead." : typeof o == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof o} instead.`);
        }
        concat(o, h, f) {
          const _ = typeof o == "number" ? this.path.concat(o) : this.path, v = f ? this.scope.concat(f) : this.scope;
          return new Yo(this.registry, this._isConstant, _, h || null, v, this.errors);
        }
        error(o) {
          for (var h = arguments.length, f = new Array(h > 1 ? h - 1 : 0), _ = 1; _ < h; _++)
            f[_ - 1] = arguments[_];
          const v = `${this.key}${f.map((w) => `[${w}]`).join("")}`;
          this.errors.push(new Yt(v, o));
        }
        checkSubtype(o, h) {
          const f = ws(o, h);
          return f && this.error(f), f;
        }
      }
      class li {
        constructor(o, h) {
          this.type = h.type, this.bindings = [].concat(o), this.result = h;
        }
        evaluate(o) {
          return this.result.evaluate(o);
        }
        eachChild(o) {
          for (const h of this.bindings) o(h[1]);
          o(this.result);
        }
        static parse(o, h) {
          if (o.length < 4) return h.error(`Expected at least 3 arguments, but found ${o.length - 1} instead.`);
          const f = [];
          for (let v = 1; v < o.length - 1; v += 2) {
            const w = o[v];
            if (typeof w != "string") return h.error(`Expected string, but found ${typeof w} instead.`, v);
            if (/[^a-zA-Z0-9_]/.test(w)) return h.error("Variable names must contain only alphanumeric characters or '_'.", v);
            const P = h.parse(o[v + 1], v + 1);
            if (!P) return null;
            f.push([w, P]);
          }
          const _ = h.parse(o[o.length - 1], o.length - 1, h.expectedType, f);
          return _ ? new li(f, _) : null;
        }
        outputDefined() {
          return this.result.outputDefined();
        }
      }
      class Kn {
        constructor(o, h) {
          this.type = h.type, this.name = o, this.boundExpression = h;
        }
        static parse(o, h) {
          if (o.length !== 2 || typeof o[1] != "string") return h.error("'var' expression requires exactly one string literal argument.");
          const f = o[1];
          return h.scope.has(f) ? new Kn(f, h.scope.get(f)) : h.error(`Unknown variable "${f}". Make sure "${f}" has been bound in an enclosing "let" expression before using it.`, 1);
        }
        evaluate(o) {
          return this.boundExpression.evaluate(o);
        }
        eachChild() {
        }
        outputDefined() {
          return !1;
        }
      }
      class Rl {
        constructor(o, h, f) {
          this.type = o, this.index = h, this.input = f;
        }
        static parse(o, h) {
          if (o.length !== 3) return h.error(`Expected 2 arguments, but found ${o.length - 1} instead.`);
          const f = h.parse(o[1], 1, It), _ = h.parse(o[2], 2, Oi(h.expectedType || fn));
          return f && _ ? new Rl(_.type.itemType, f, _) : null;
        }
        evaluate(o) {
          const h = this.index.evaluate(o), f = this.input.evaluate(o);
          if (h < 0) throw new _t(`Array index out of bounds: ${h} < 0.`);
          if (h >= f.length) throw new _t(`Array index out of bounds: ${h} > ${f.length - 1}.`);
          if (h !== Math.floor(h)) throw new _t(`Array index must be an integer, but found ${h} instead.`);
          return f[h];
        }
        eachChild(o) {
          o(this.index), o(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class gi {
        constructor(o, h) {
          this.type = cn, this.needle = o, this.haystack = h;
        }
        static parse(o, h) {
          if (o.length !== 3) return h.error(`Expected 2 arguments, but found ${o.length - 1} instead.`);
          const f = h.parse(o[1], 1, fn), _ = h.parse(o[2], 2, fn);
          return f && _ ? Ao(f.type, [cn, Jt, It, An, fn]) ? new gi(f, _) : h.error(`Expected first argument to be of type boolean, string, number or null, but found ${_i(f.type)} instead`) : null;
        }
        evaluate(o) {
          const h = this.needle.evaluate(o), f = this.haystack.evaluate(o);
          if (!f) return !1;
          if (!qs(h, ["boolean", "string", "number", "null"])) throw new _t(`Expected first argument to be of type boolean, string, number or null, but found ${_i(qn(h))} instead.`);
          if (!qs(f, ["string", "array"])) throw new _t(`Expected second argument to be of type array or string, but found ${_i(qn(f))} instead.`);
          return f.indexOf(h) >= 0;
        }
        eachChild(o) {
          o(this.needle), o(this.haystack);
        }
        outputDefined() {
          return !0;
        }
      }
      class fa {
        constructor(o, h, f) {
          this.type = It, this.needle = o, this.haystack = h, this.fromIndex = f;
        }
        static parse(o, h) {
          if (o.length <= 2 || o.length >= 5) return h.error(`Expected 3 or 4 arguments, but found ${o.length - 1} instead.`);
          const f = h.parse(o[1], 1, fn), _ = h.parse(o[2], 2, fn);
          if (!f || !_) return null;
          if (!Ao(f.type, [cn, Jt, It, An, fn])) return h.error(`Expected first argument to be of type boolean, string, number or null, but found ${_i(f.type)} instead`);
          if (o.length === 4) {
            const v = h.parse(o[3], 3, It);
            return v ? new fa(f, _, v) : null;
          }
          return new fa(f, _);
        }
        evaluate(o) {
          const h = this.needle.evaluate(o), f = this.haystack.evaluate(o);
          if (!qs(h, ["boolean", "string", "number", "null"])) throw new _t(`Expected first argument to be of type boolean, string, number or null, but found ${_i(qn(h))} instead.`);
          let _;
          if (this.fromIndex && (_ = this.fromIndex.evaluate(o)), qs(f, ["string"])) {
            const v = f.indexOf(h, _);
            return v === -1 ? -1 : [...f.slice(0, v)].length;
          }
          if (qs(f, ["array"])) return f.indexOf(h, _);
          throw new _t(`Expected second argument to be of type array or string, but found ${_i(qn(f))} instead.`);
        }
        eachChild(o) {
          o(this.needle), o(this.haystack), this.fromIndex && o(this.fromIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      class ls {
        constructor(o, h, f, _, v, w) {
          this.inputType = o, this.type = h, this.input = f, this.cases = _, this.outputs = v, this.otherwise = w;
        }
        static parse(o, h) {
          if (o.length < 5) return h.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
          if (o.length % 2 != 1) return h.error("Expected an even number of arguments.");
          let f, _;
          h.expectedType && h.expectedType.kind !== "value" && (_ = h.expectedType);
          const v = {}, w = [];
          for (let D = 2; D < o.length - 1; D += 2) {
            let z = o[D];
            const j = o[D + 1];
            Array.isArray(z) || (z = [z]);
            const Y = h.concat(D);
            if (z.length === 0) return Y.error("Expected at least one branch label.");
            for (const Q of z) {
              if (typeof Q != "number" && typeof Q != "string") return Y.error("Branch labels must be numbers or strings.");
              if (typeof Q == "number" && Math.abs(Q) > Number.MAX_SAFE_INTEGER) return Y.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
              if (typeof Q == "number" && Math.floor(Q) !== Q) return Y.error("Numeric branch labels must be integer values.");
              if (f) {
                if (Y.checkSubtype(f, qn(Q))) return null;
              } else f = qn(Q);
              if (v[String(Q)] !== void 0) return Y.error("Branch labels must be unique.");
              v[String(Q)] = w.length;
            }
            const K = h.parse(j, D, _);
            if (!K) return null;
            _ = _ || K.type, w.push(K);
          }
          const P = h.parse(o[1], 1, fn);
          if (!P) return null;
          const R = h.parse(o[o.length - 1], o.length - 1, _);
          return R ? P.type.kind !== "value" && h.concat(1).checkSubtype(f, P.type) ? null : new ls(f, _, P, v, w, R) : null;
        }
        evaluate(o) {
          const h = this.input.evaluate(o);
          return (qn(h) === this.inputType && this.outputs[this.cases[h]] || this.otherwise).evaluate(o);
        }
        eachChild(o) {
          o(this.input), this.outputs.forEach(o), o(this.otherwise);
        }
        outputDefined() {
          return this.outputs.every((o) => o.outputDefined()) && this.otherwise.outputDefined();
        }
      }
      class So {
        constructor(o, h, f) {
          this.type = o, this.branches = h, this.otherwise = f;
        }
        static parse(o, h) {
          if (o.length < 4) return h.error(`Expected at least 3 arguments, but found only ${o.length - 1}.`);
          if (o.length % 2 != 0) return h.error("Expected an odd number of arguments.");
          let f;
          h.expectedType && h.expectedType.kind !== "value" && (f = h.expectedType);
          const _ = [];
          for (let w = 1; w < o.length - 1; w += 2) {
            const P = h.parse(o[w], w, cn);
            if (!P) return null;
            const R = h.parse(o[w + 1], w + 1, f);
            if (!R) return null;
            _.push([P, R]), f = f || R.type;
          }
          const v = h.parse(o[o.length - 1], o.length - 1, f);
          if (!v) return null;
          if (!f) throw new Error("Can't infer output type");
          return new So(f, _, v);
        }
        evaluate(o) {
          for (const [h, f] of this.branches) if (h.evaluate(o)) return f.evaluate(o);
          return this.otherwise.evaluate(o);
        }
        eachChild(o) {
          for (const [h, f] of this.branches) o(h), o(f);
          o(this.otherwise);
        }
        outputDefined() {
          return this.branches.every((o) => {
            let [h, f] = o;
            return f.outputDefined();
          }) && this.otherwise.outputDefined();
        }
      }
      class Bl {
        constructor(o, h, f, _) {
          this.type = o, this.input = h, this.beginIndex = f, this.endIndex = _;
        }
        static parse(o, h) {
          if (o.length <= 2 || o.length >= 5) return h.error(`Expected 3 or 4 arguments, but found ${o.length - 1} instead.`);
          const f = h.parse(o[1], 1, fn), _ = h.parse(o[2], 2, It);
          if (!f || !_) return null;
          if (!Ao(f.type, [Oi(fn), Jt, fn])) return h.error(`Expected first argument to be of type array or string, but found ${_i(f.type)} instead`);
          if (o.length === 4) {
            const v = h.parse(o[3], 3, It);
            return v ? new Bl(f.type, f, _, v) : null;
          }
          return new Bl(f.type, f, _);
        }
        evaluate(o) {
          const h = this.input.evaluate(o), f = this.beginIndex.evaluate(o);
          let _;
          if (this.endIndex && (_ = this.endIndex.evaluate(o)), qs(h, ["string"])) return [...h].slice(f, _).join("");
          if (qs(h, ["array"])) return h.slice(f, _);
          throw new _t(`Expected first argument to be of type array or string, but found ${_i(qn(h))} instead.`);
        }
        eachChild(o) {
          o(this.input), o(this.beginIndex), this.endIndex && o(this.endIndex);
        }
        outputDefined() {
          return !1;
        }
      }
      function Jo(d, o) {
        const h = d.length - 1;
        let f, _, v = 0, w = h, P = 0;
        for (; v <= w; ) if (P = Math.floor((v + w) / 2), f = d[P], _ = d[P + 1], f <= o) {
          if (P === h || o < _) return P;
          v = P + 1;
        } else {
          if (!(f > o)) throw new _t("Input is not a number.");
          w = P - 1;
        }
        return 0;
      }
      class Ko {
        constructor(o, h, f) {
          this.type = o, this.input = h, this.labels = [], this.outputs = [];
          for (const [_, v] of f) this.labels.push(_), this.outputs.push(v);
        }
        static parse(o, h) {
          if (o.length - 1 < 4) return h.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
          if ((o.length - 1) % 2 != 0) return h.error("Expected an even number of arguments.");
          const f = h.parse(o[1], 1, It);
          if (!f) return null;
          const _ = [];
          let v = null;
          h.expectedType && h.expectedType.kind !== "value" && (v = h.expectedType);
          for (let w = 1; w < o.length; w += 2) {
            const P = w === 1 ? -1 / 0 : o[w], R = o[w + 1], D = w, z = w + 1;
            if (typeof P != "number") return h.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', D);
            if (_.length && _[_.length - 1][0] >= P) return h.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', D);
            const j = h.parse(R, z, v);
            if (!j) return null;
            v = v || j.type, _.push([P, j]);
          }
          return new Ko(v, f, _);
        }
        evaluate(o) {
          const h = this.labels, f = this.outputs;
          if (h.length === 1) return f[0].evaluate(o);
          const _ = this.input.evaluate(o);
          if (_ <= h[0]) return f[0].evaluate(o);
          const v = h.length;
          return _ >= h[v - 1] ? f[v - 1].evaluate(o) : f[Jo(h, _)].evaluate(o);
        }
        eachChild(o) {
          o(this.input);
          for (const h of this.outputs) o(h);
        }
        outputDefined() {
          return this.outputs.every((o) => o.outputDefined());
        }
      }
      function Ol(d) {
        return d && d.__esModule && Object.prototype.hasOwnProperty.call(d, "default") ? d.default : d;
      }
      var Sc, Cc, su = function() {
        if (Cc) return Sc;
        function d(o, h, f, _) {
          this.cx = 3 * o, this.bx = 3 * (f - o) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * h, this.by = 3 * (_ - h) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = o, this.p1y = h, this.p2x = f, this.p2y = _;
        }
        return Cc = 1, Sc = d, d.prototype = { sampleCurveX: function(o) {
          return ((this.ax * o + this.bx) * o + this.cx) * o;
        }, sampleCurveY: function(o) {
          return ((this.ay * o + this.by) * o + this.cy) * o;
        }, sampleCurveDerivativeX: function(o) {
          return (3 * this.ax * o + 2 * this.bx) * o + this.cx;
        }, solveCurveX: function(o, h) {
          if (h === void 0 && (h = 1e-6), o < 0) return 0;
          if (o > 1) return 1;
          for (var f = o, _ = 0; _ < 8; _++) {
            var v = this.sampleCurveX(f) - o;
            if (Math.abs(v) < h) return f;
            var w = this.sampleCurveDerivativeX(f);
            if (Math.abs(w) < 1e-6) break;
            f -= v / w;
          }
          var P = 0, R = 1;
          for (f = o, _ = 0; _ < 20 && (v = this.sampleCurveX(f), !(Math.abs(v - o) < h)); _++) o > v ? P = f : R = f, f = 0.5 * (R - P) + P;
          return f;
        }, solve: function(o, h) {
          return this.sampleCurveY(this.solveCurveX(o, h));
        } }, Sc;
      }(), ol = Ol(su);
      class yi {
        constructor(o, h, f, _, v) {
          this.type = o, this.operator = h, this.interpolation = f, this.input = _, this.labels = [], this.outputs = [];
          for (const [w, P] of v) this.labels.push(w), this.outputs.push(P);
        }
        static interpolationFactor(o, h, f, _) {
          let v = 0;
          if (o.name === "exponential") v = Ks(h, o.base, f, _);
          else if (o.name === "linear") v = Ks(h, 1, f, _);
          else if (o.name === "cubic-bezier") {
            const w = o.controlPoints;
            v = new ol(w[0], w[1], w[2], w[3]).solve(Ks(h, 1, f, _));
          }
          return v;
        }
        static parse(o, h) {
          let [f, _, v, ...w] = o;
          if (!Array.isArray(_) || _.length === 0) return h.error("Expected an interpolation type expression.", 1);
          if (_[0] === "linear") _ = { name: "linear" };
          else if (_[0] === "exponential") {
            const D = _[1];
            if (typeof D != "number") return h.error("Exponential interpolation requires a numeric base.", 1, 1);
            _ = { name: "exponential", base: D };
          } else {
            if (_[0] !== "cubic-bezier") return h.error(`Unknown interpolation type ${String(_[0])}`, 1, 0);
            {
              const D = _.slice(1);
              if (D.length !== 4 || D.some((z) => typeof z != "number" || z < 0 || z > 1)) return h.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              _ = { name: "cubic-bezier", controlPoints: D };
            }
          }
          if (o.length - 1 < 4) return h.error(`Expected at least 4 arguments, but found only ${o.length - 1}.`);
          if ((o.length - 1) % 2 != 0) return h.error("Expected an even number of arguments.");
          if (v = h.parse(v, 2, It), !v) return null;
          const P = [];
          let R = null;
          f === "interpolate-hcl" || f === "interpolate-lab" ? R = In : h.expectedType && h.expectedType.kind !== "value" && (R = h.expectedType);
          for (let D = 0; D < w.length; D += 2) {
            const z = w[D], j = w[D + 1], Y = D + 3, K = D + 4;
            if (typeof z != "number") return h.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', Y);
            if (P.length && P[P.length - 1][0] >= z) return h.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', Y);
            const Q = h.parse(j, K, R);
            if (!Q) return null;
            R = R || Q.type, P.push([z, Q]);
          }
          return To(R, It) || To(R, Zn) || To(R, In) || To(R, Pi) || To(R, ui) || To(R, Oi(It)) ? new yi(R, f, _, v, P) : h.error(`Type ${_i(R)} is not interpolatable.`);
        }
        evaluate(o) {
          const h = this.labels, f = this.outputs;
          if (h.length === 1) return f[0].evaluate(o);
          const _ = this.input.evaluate(o);
          if (_ <= h[0]) return f[0].evaluate(o);
          const v = h.length;
          if (_ >= h[v - 1]) return f[v - 1].evaluate(o);
          const w = Jo(h, _), P = yi.interpolationFactor(this.interpolation, _, h[w], h[w + 1]), R = f[w].evaluate(o), D = f[w + 1].evaluate(o);
          switch (this.operator) {
            case "interpolate":
              switch (this.type.kind) {
                case "number":
                  return Xn(R, D, P);
                case "color":
                  return Qn.interpolate(R, D, P);
                case "padding":
                  return Ve.interpolate(R, D, P);
                case "variableAnchorOffsetCollection":
                  return gn.interpolate(R, D, P);
                case "array":
                  return as(R, D, P);
                case "projectionDefinition":
                  return hi.interpolate(R, D, P);
              }
            case "interpolate-hcl":
              return Qn.interpolate(R, D, P, "hcl");
            case "interpolate-lab":
              return Qn.interpolate(R, D, P, "lab");
          }
        }
        eachChild(o) {
          o(this.input);
          for (const h of this.outputs) o(h);
        }
        outputDefined() {
          return this.outputs.every((o) => o.outputDefined());
        }
      }
      function Ks(d, o, h, f) {
        const _ = f - h, v = d - h;
        return _ === 0 ? 0 : o === 1 ? v / _ : (Math.pow(o, v) - 1) / (Math.pow(o, _) - 1);
      }
      const fo = { color: Qn.interpolate, number: Xn, padding: Ve.interpolate, variableAnchorOffsetCollection: gn.interpolate, array: as };
      class Qs {
        constructor(o, h) {
          this.type = o, this.args = h;
        }
        static parse(o, h) {
          if (o.length < 2) return h.error("Expected at least one argument.");
          let f = null;
          const _ = h.expectedType;
          _ && _.kind !== "value" && (f = _);
          const v = [];
          for (const P of o.slice(1)) {
            const R = h.parse(P, 1 + v.length, f, void 0, { typeAnnotation: "omit" });
            if (!R) return null;
            f = f || R.type, v.push(R);
          }
          if (!f) throw new Error("No output type");
          const w = _ && v.some((P) => ws(_, P.type));
          return new Qs(w ? fn : f, v);
        }
        evaluate(o) {
          let h, f = null, _ = 0;
          for (const v of this.args) if (_++, f = v.evaluate(o), f && f instanceof Rn && !f.available && (h || (h = f.name), f = null, _ === this.args.length && (f = h)), f !== null) break;
          return f;
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return this.args.every((o) => o.outputDefined());
        }
      }
      function ji(d, o) {
        return d === "==" || d === "!=" ? o.kind === "boolean" || o.kind === "string" || o.kind === "number" || o.kind === "null" || o.kind === "value" : o.kind === "string" || o.kind === "number" || o.kind === "value";
      }
      function Dl(d, o, h, f) {
        return f.compare(o, h) === 0;
      }
      function eo(d, o, h) {
        const f = d !== "==" && d !== "!=";
        return class lT {
          constructor(v, w, P) {
            this.type = cn, this.lhs = v, this.rhs = w, this.collator = P, this.hasUntypedArgument = v.type.kind === "value" || w.type.kind === "value";
          }
          static parse(v, w) {
            if (v.length !== 3 && v.length !== 4) return w.error("Expected two or three arguments.");
            const P = v[0];
            let R = w.parse(v[1], 1, fn);
            if (!R) return null;
            if (!ji(P, R.type)) return w.concat(1).error(`"${P}" comparisons are not supported for type '${_i(R.type)}'.`);
            let D = w.parse(v[2], 2, fn);
            if (!D) return null;
            if (!ji(P, D.type)) return w.concat(2).error(`"${P}" comparisons are not supported for type '${_i(D.type)}'.`);
            if (R.type.kind !== D.type.kind && R.type.kind !== "value" && D.type.kind !== "value") return w.error(`Cannot compare types '${_i(R.type)}' and '${_i(D.type)}'.`);
            f && (R.type.kind === "value" && D.type.kind !== "value" ? R = new Js(D.type, [R]) : R.type.kind !== "value" && D.type.kind === "value" && (D = new Js(R.type, [D])));
            let z = null;
            if (v.length === 4) {
              if (R.type.kind !== "string" && D.type.kind !== "string" && R.type.kind !== "value" && D.type.kind !== "value") return w.error("Cannot use collator to compare non-string types.");
              if (z = w.parse(v[3], 3, xi), !z) return null;
            }
            return new lT(R, D, z);
          }
          evaluate(v) {
            const w = this.lhs.evaluate(v), P = this.rhs.evaluate(v);
            if (f && this.hasUntypedArgument) {
              const R = qn(w), D = qn(P);
              if (R.kind !== D.kind || R.kind !== "string" && R.kind !== "number") throw new _t(`Expected arguments for "${d}" to be (string, string) or (number, number), but found (${R.kind}, ${D.kind}) instead.`);
            }
            if (this.collator && !f && this.hasUntypedArgument) {
              const R = qn(w), D = qn(P);
              if (R.kind !== "string" || D.kind !== "string") return o(v, w, P);
            }
            return this.collator ? h(v, w, P, this.collator.evaluate(v)) : o(v, w, P);
          }
          eachChild(v) {
            v(this.lhs), v(this.rhs), this.collator && v(this.collator);
          }
          outputDefined() {
            return !0;
          }
        };
      }
      const ku = eo("==", function(d, o, h) {
        return o === h;
      }, Dl), Pc = eo("!=", function(d, o, h) {
        return o !== h;
      }, function(d, o, h, f) {
        return !Dl(0, o, h, f);
      }), Ic = eo("<", function(d, o, h) {
        return o < h;
      }, function(d, o, h, f) {
        return f.compare(o, h) < 0;
      }), Fl = eo(">", function(d, o, h) {
        return o > h;
      }, function(d, o, h, f) {
        return f.compare(o, h) > 0;
      }), ou = eo("<=", function(d, o, h) {
        return o <= h;
      }, function(d, o, h, f) {
        return f.compare(o, h) <= 0;
      }), Nl = eo(">=", function(d, o, h) {
        return o >= h;
      }, function(d, o, h, f) {
        return f.compare(o, h) >= 0;
      });
      class Co {
        constructor(o, h, f) {
          this.type = xi, this.locale = f, this.caseSensitive = o, this.diacriticSensitive = h;
        }
        static parse(o, h) {
          if (o.length !== 2) return h.error("Expected one argument.");
          const f = o[1];
          if (typeof f != "object" || Array.isArray(f)) return h.error("Collator options argument must be an object.");
          const _ = h.parse(f["case-sensitive"] !== void 0 && f["case-sensitive"], 1, cn);
          if (!_) return null;
          const v = h.parse(f["diacritic-sensitive"] !== void 0 && f["diacritic-sensitive"], 1, cn);
          if (!v) return null;
          let w = null;
          return f.locale && (w = h.parse(f.locale, 1, Jt), !w) ? null : new Co(_, v, w);
        }
        evaluate(o) {
          return new Ma(this.caseSensitive.evaluate(o), this.diacriticSensitive.evaluate(o), this.locale ? this.locale.evaluate(o) : null);
        }
        eachChild(o) {
          o(this.caseSensitive), o(this.diacriticSensitive), this.locale && o(this.locale);
        }
        outputDefined() {
          return !1;
        }
      }
      class cs {
        constructor(o, h, f, _, v) {
          this.type = Jt, this.number = o, this.locale = h, this.currency = f, this.minFractionDigits = _, this.maxFractionDigits = v;
        }
        static parse(o, h) {
          if (o.length !== 3) return h.error("Expected two arguments.");
          const f = h.parse(o[1], 1, It);
          if (!f) return null;
          const _ = o[2];
          if (typeof _ != "object" || Array.isArray(_)) return h.error("NumberFormat options argument must be an object.");
          let v = null;
          if (_.locale && (v = h.parse(_.locale, 1, Jt), !v)) return null;
          let w = null;
          if (_.currency && (w = h.parse(_.currency, 1, Jt), !w)) return null;
          let P = null;
          if (_["min-fraction-digits"] && (P = h.parse(_["min-fraction-digits"], 1, It), !P)) return null;
          let R = null;
          return _["max-fraction-digits"] && (R = h.parse(_["max-fraction-digits"], 1, It), !R) ? null : new cs(f, v, w, P, R);
        }
        evaluate(o) {
          return new Intl.NumberFormat(this.locale ? this.locale.evaluate(o) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(o) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(o) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(o) : void 0 }).format(this.number.evaluate(o));
        }
        eachChild(o) {
          o(this.number), this.locale && o(this.locale), this.currency && o(this.currency), this.minFractionDigits && o(this.minFractionDigits), this.maxFractionDigits && o(this.maxFractionDigits);
        }
        outputDefined() {
          return !1;
        }
      }
      class La {
        constructor(o) {
          this.type = Er, this.sections = o;
        }
        static parse(o, h) {
          if (o.length < 2) return h.error("Expected at least one argument.");
          const f = o[1];
          if (!Array.isArray(f) && typeof f == "object") return h.error("First argument must be an image or text section.");
          const _ = [];
          let v = !1;
          for (let w = 1; w <= o.length - 1; ++w) {
            const P = o[w];
            if (v && typeof P == "object" && !Array.isArray(P)) {
              v = !1;
              let R = null;
              if (P["font-scale"] && (R = h.parse(P["font-scale"], 1, It), !R)) return null;
              let D = null;
              if (P["text-font"] && (D = h.parse(P["text-font"], 1, Oi(Jt)), !D)) return null;
              let z = null;
              if (P["text-color"] && (z = h.parse(P["text-color"], 1, In), !z)) return null;
              let j = null;
              if (P["vertical-align"]) {
                if (typeof P["vertical-align"] == "string" && !Ec.includes(P["vertical-align"])) return h.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${P["vertical-align"]}' instead.`);
                if (j = h.parse(P["vertical-align"], 1, Jt), !j) return null;
              }
              const Y = _[_.length - 1];
              Y.scale = R, Y.font = D, Y.textColor = z, Y.verticalAlign = j;
            } else {
              const R = h.parse(o[w], 1, fn);
              if (!R) return null;
              const D = R.type.kind;
              if (D !== "string" && D !== "value" && D !== "null" && D !== "resolvedImage") return h.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
              v = !0, _.push({ content: R, scale: null, font: null, textColor: null, verticalAlign: null });
            }
          }
          return new La(_);
        }
        evaluate(o) {
          return new we(this.sections.map((h) => {
            const f = h.content.evaluate(o);
            return qn(f) === Ii ? new ge("", f, null, null, null, h.verticalAlign ? h.verticalAlign.evaluate(o) : null) : new ge(Ml(f), null, h.scale ? h.scale.evaluate(o) : null, h.font ? h.font.evaluate(o).join(",") : null, h.textColor ? h.textColor.evaluate(o) : null, h.verticalAlign ? h.verticalAlign.evaluate(o) : null);
          }));
        }
        eachChild(o) {
          for (const h of this.sections) o(h.content), h.scale && o(h.scale), h.font && o(h.font), h.textColor && o(h.textColor), h.verticalAlign && o(h.verticalAlign);
        }
        outputDefined() {
          return !1;
        }
      }
      class Ra {
        constructor(o) {
          this.type = Ii, this.input = o;
        }
        static parse(o, h) {
          if (o.length !== 2) return h.error("Expected two arguments.");
          const f = h.parse(o[1], 1, Jt);
          return f ? new Ra(f) : h.error("No image name provided.");
        }
        evaluate(o) {
          const h = this.input.evaluate(o), f = Rn.fromString(h);
          return f && o.availableImages && (f.available = o.availableImages.indexOf(h) > -1), f;
        }
        eachChild(o) {
          o(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      class au {
        constructor(o) {
          this.type = It, this.input = o;
        }
        static parse(o, h) {
          if (o.length !== 2) return h.error(`Expected 1 argument, but found ${o.length - 1} instead.`);
          const f = h.parse(o[1], 1);
          return f ? f.type.kind !== "array" && f.type.kind !== "string" && f.type.kind !== "value" ? h.error(`Expected argument of type string or array, but found ${_i(f.type)} instead.`) : new au(f) : null;
        }
        evaluate(o) {
          const h = this.input.evaluate(o);
          if (typeof h == "string") return [...h].length;
          if (Array.isArray(h)) return h.length;
          throw new _t(`Expected value to be of type string or array, but found ${_i(qn(h))} instead.`);
        }
        eachChild(o) {
          o(this.input);
        }
        outputDefined() {
          return !1;
        }
      }
      const us = 8192;
      function kl(d, o) {
        const h = (180 + d[0]) / 360, f = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + d[1] * Math.PI / 360))) / 360, _ = Math.pow(2, o.z);
        return [Math.round(h * _ * us), Math.round(f * _ * us)];
      }
      function zl(d, o) {
        const h = Math.pow(2, o.z);
        return [(_ = (d[0] / us + o.x) / h, 360 * _ - 180), (f = (d[1] / us + o.y) / h, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * f) * Math.PI / 180)) - 90)];
        var f, _;
      }
      function Po(d, o) {
        d[0] = Math.min(d[0], o[0]), d[1] = Math.min(d[1], o[1]), d[2] = Math.max(d[2], o[0]), d[3] = Math.max(d[3], o[1]);
      }
      function Ba(d, o) {
        return !(d[0] <= o[0] || d[2] >= o[2] || d[1] <= o[1] || d[3] >= o[3]);
      }
      function O(d, o, h) {
        const f = d[0] - o[0], _ = d[1] - o[1], v = d[0] - h[0], w = d[1] - h[1];
        return f * w - v * _ == 0 && f * v <= 0 && _ * w <= 0;
      }
      function te(d, o, h, f) {
        return (_ = [f[0] - h[0], f[1] - h[1]])[0] * (v = [o[0] - d[0], o[1] - d[1]])[1] - _[1] * v[0] != 0 && !(!Tn(d, o, h, f) || !Tn(h, f, d, o));
        var _, v;
      }
      function Fe(d, o, h) {
        for (const f of h) for (let _ = 0; _ < f.length - 1; ++_) if (te(d, o, f[_], f[_ + 1])) return !0;
        return !1;
      }
      function Ke(d, o) {
        let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, f = !1;
        for (const P of o) for (let R = 0; R < P.length - 1; R++) {
          if (O(d, P[R], P[R + 1])) return h;
          (v = P[R])[1] > (_ = d)[1] != (w = P[R + 1])[1] > _[1] && _[0] < (w[0] - v[0]) * (_[1] - v[1]) / (w[1] - v[1]) + v[0] && (f = !f);
        }
        var _, v, w;
        return f;
      }
      function yt(d, o) {
        for (const h of o) if (Ke(d, h)) return !0;
        return !1;
      }
      function kt(d, o) {
        for (const h of d) if (!Ke(h, o)) return !1;
        for (let h = 0; h < d.length - 1; ++h) if (Fe(d[h], d[h + 1], o)) return !1;
        return !0;
      }
      function tn(d, o) {
        for (const h of o) if (kt(d, h)) return !0;
        return !1;
      }
      function Tn(d, o, h, f) {
        const _ = f[0] - h[0], v = f[1] - h[1], w = (d[0] - h[0]) * v - _ * (d[1] - h[1]), P = (o[0] - h[0]) * v - _ * (o[1] - h[1]);
        return w > 0 && P < 0 || w < 0 && P > 0;
      }
      function kn(d, o, h) {
        const f = [];
        for (let _ = 0; _ < d.length; _++) {
          const v = [];
          for (let w = 0; w < d[_].length; w++) {
            const P = kl(d[_][w], h);
            Po(o, P), v.push(P);
          }
          f.push(v);
        }
        return f;
      }
      function ii(d, o, h) {
        const f = [];
        for (let _ = 0; _ < d.length; _++) {
          const v = kn(d[_], o, h);
          f.push(v);
        }
        return f;
      }
      function ei(d, o, h, f) {
        if (d[0] < h[0] || d[0] > h[2]) {
          const _ = 0.5 * f;
          let v = d[0] - h[0] > _ ? -f : h[0] - d[0] > _ ? f : 0;
          v === 0 && (v = d[0] - h[2] > _ ? -f : h[2] - d[0] > _ ? f : 0), d[0] += v;
        }
        Po(o, d);
      }
      function wi(d, o, h, f) {
        const _ = Math.pow(2, f.z) * us, v = [f.x * us, f.y * us], w = [];
        for (const P of d) for (const R of P) {
          const D = [R.x + v[0], R.y + v[1]];
          ei(D, o, h, _), w.push(D);
        }
        return w;
      }
      function ir(d, o, h, f) {
        const _ = Math.pow(2, f.z) * us, v = [f.x * us, f.y * us], w = [];
        for (const R of d) {
          const D = [];
          for (const z of R) {
            const j = [z.x + v[0], z.y + v[1]];
            Po(o, j), D.push(j);
          }
          w.push(D);
        }
        if (o[2] - o[0] <= _ / 2) {
          (P = o)[0] = P[1] = 1 / 0, P[2] = P[3] = -1 / 0;
          for (const R of w) for (const D of R) ei(D, o, h, _);
        }
        var P;
        return w;
      }
      class Wi {
        constructor(o, h) {
          this.type = cn, this.geojson = o, this.geometries = h;
        }
        static parse(o, h) {
          if (o.length !== 2) return h.error(`'within' expression requires exactly one argument, but found ${o.length - 1} instead.`);
          if (Ki(o[1])) {
            const f = o[1];
            if (f.type === "FeatureCollection") {
              const _ = [];
              for (const v of f.features) {
                const { type: w, coordinates: P } = v.geometry;
                w === "Polygon" && _.push(P), w === "MultiPolygon" && _.push(...P);
              }
              if (_.length) return new Wi(f, { type: "MultiPolygon", coordinates: _ });
            } else if (f.type === "Feature") {
              const _ = f.geometry.type;
              if (_ === "Polygon" || _ === "MultiPolygon") return new Wi(f, f.geometry);
            } else if (f.type === "Polygon" || f.type === "MultiPolygon") return new Wi(f, f);
          }
          return h.error("'within' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(o) {
          if (o.geometry() != null && o.canonicalID() != null) {
            if (o.geometryType() === "Point") return function(h, f) {
              const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], w = h.canonicalID();
              if (f.type === "Polygon") {
                const P = kn(f.coordinates, v, w), R = wi(h.geometry(), _, v, w);
                if (!Ba(_, v)) return !1;
                for (const D of R) if (!Ke(D, P)) return !1;
              }
              if (f.type === "MultiPolygon") {
                const P = ii(f.coordinates, v, w), R = wi(h.geometry(), _, v, w);
                if (!Ba(_, v)) return !1;
                for (const D of R) if (!yt(D, P)) return !1;
              }
              return !0;
            }(o, this.geometries);
            if (o.geometryType() === "LineString") return function(h, f) {
              const _ = [1 / 0, 1 / 0, -1 / 0, -1 / 0], v = [1 / 0, 1 / 0, -1 / 0, -1 / 0], w = h.canonicalID();
              if (f.type === "Polygon") {
                const P = kn(f.coordinates, v, w), R = ir(h.geometry(), _, v, w);
                if (!Ba(_, v)) return !1;
                for (const D of R) if (!kt(D, P)) return !1;
              }
              if (f.type === "MultiPolygon") {
                const P = ii(f.coordinates, v, w), R = ir(h.geometry(), _, v, w);
                if (!Ba(_, v)) return !1;
                for (const D of R) if (!tn(D, P)) return !1;
              }
              return !0;
            }(o, this.geometries);
          }
          return !1;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      let Sr = class {
        constructor() {
          let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (h, f) => h < f ? -1 : h > f ? 1 : 0;
          if (this.data = d, this.length = this.data.length, this.compare = o, this.length > 0) for (let h = (this.length >> 1) - 1; h >= 0; h--) this._down(h);
        }
        push(d) {
          this.data.push(d), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const d = this.data[0], o = this.data.pop();
          return --this.length > 0 && (this.data[0] = o, this._down(0)), d;
        }
        peek() {
          return this.data[0];
        }
        _up(d) {
          const { data: o, compare: h } = this, f = o[d];
          for (; d > 0; ) {
            const _ = d - 1 >> 1, v = o[_];
            if (h(f, v) >= 0) break;
            o[d] = v, d = _;
          }
          o[d] = f;
        }
        _down(d) {
          const { data: o, compare: h } = this, f = this.length >> 1, _ = o[d];
          for (; d < f; ) {
            let v = 1 + (d << 1);
            const w = v + 1;
            if (w < this.length && h(o[w], o[v]) < 0 && (v = w), h(o[v], _) >= 0) break;
            o[d] = o[v], d = v;
          }
          o[d] = _;
        }
      };
      function hs(d, o) {
        let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : d.length - 1, _ = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : po;
        for (; f > h; ) {
          if (f - h > 600) {
            const R = f - h + 1, D = o - h + 1, z = Math.log(R), j = 0.5 * Math.exp(2 * z / 3), Y = 0.5 * Math.sqrt(z * j * (R - j) / R) * (D - R / 2 < 0 ? -1 : 1);
            hs(d, o, Math.max(h, Math.floor(o - D * j / R + Y)), Math.min(f, Math.floor(o + (R - D) * j / R + Y)), _);
          }
          const v = d[o];
          let w = h, P = f;
          for (br(d, h, o), _(d[f], v) > 0 && br(d, h, f); w < P; ) {
            for (br(d, w, P), w++, P--; _(d[w], v) < 0; ) w++;
            for (; _(d[P], v) > 0; ) P--;
          }
          _(d[h], v) === 0 ? br(d, h, P) : (P++, br(d, P, f)), P <= o && (h = P + 1), o <= P && (f = P - 1);
        }
      }
      function br(d, o, h) {
        const f = d[o];
        d[o] = d[h], d[h] = f;
      }
      function po(d, o) {
        return d < o ? -1 : d > o ? 1 : 0;
      }
      function Bs(d, o) {
        if (d.length <= 1) return [d];
        const h = [];
        let f, _;
        for (const v of d) {
          const w = zu(v);
          w !== 0 && (v.area = Math.abs(w), _ === void 0 && (_ = w < 0), _ === w < 0 ? (f && h.push(f), f = [v]) : f.push(v));
        }
        if (f && h.push(f), o > 1) for (let v = 0; v < h.length; v++) h[v].length <= o || (hs(h[v], o, 1, h[v].length - 1, pa), h[v] = h[v].slice(0, o));
        return h;
      }
      function pa(d, o) {
        return o.area - d.area;
      }
      function zu(d) {
        let o = 0;
        for (let h, f, _ = 0, v = d.length, w = v - 1; _ < v; w = _++) h = d[_], f = d[w], o += (f.x - h.x) * (h.y + f.y);
        return o;
      }
      const Ul = 1 / 298.257223563, jl = Ul * (2 - Ul), Gl = Math.PI / 180;
      class Vl {
        constructor(o) {
          const h = 6378.137 * Gl * 1e3, f = Math.cos(o * Gl), _ = 1 / (1 - jl * (1 - f * f)), v = Math.sqrt(_);
          this.kx = h * v * f, this.ky = h * v * _ * (1 - jl);
        }
        distance(o, h) {
          const f = this.wrap(o[0] - h[0]) * this.kx, _ = (o[1] - h[1]) * this.ky;
          return Math.sqrt(f * f + _ * _);
        }
        pointOnLine(o, h) {
          let f, _, v, w, P = 1 / 0;
          for (let R = 0; R < o.length - 1; R++) {
            let D = o[R][0], z = o[R][1], j = this.wrap(o[R + 1][0] - D) * this.kx, Y = (o[R + 1][1] - z) * this.ky, K = 0;
            j === 0 && Y === 0 || (K = (this.wrap(h[0] - D) * this.kx * j + (h[1] - z) * this.ky * Y) / (j * j + Y * Y), K > 1 ? (D = o[R + 1][0], z = o[R + 1][1]) : K > 0 && (D += j / this.kx * K, z += Y / this.ky * K)), j = this.wrap(h[0] - D) * this.kx, Y = (h[1] - z) * this.ky;
            const Q = j * j + Y * Y;
            Q < P && (P = Q, f = D, _ = z, v = R, w = K);
          }
          return { point: [f, _], index: v, t: Math.max(0, Math.min(1, w)) };
        }
        wrap(o) {
          for (; o < -180; ) o += 360;
          for (; o > 180; ) o -= 360;
          return o;
        }
      }
      function ql(d, o) {
        return o[0] - d[0];
      }
      function ga(d) {
        return d[1] - d[0] + 1;
      }
      function rr(d, o) {
        return d[1] >= d[0] && d[1] < o;
      }
      function al(d, o) {
        if (d[0] > d[1]) return [null, null];
        const h = ga(d);
        if (o) {
          if (h === 2) return [d, null];
          const _ = Math.floor(h / 2);
          return [[d[0], d[0] + _], [d[0] + _, d[1]]];
        }
        if (h === 1) return [d, null];
        const f = Math.floor(h / 2) - 1;
        return [[d[0], d[0] + f], [d[0] + f + 1, d[1]]];
      }
      function ll(d, o) {
        if (!rr(o, d.length)) return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        const h = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (let f = o[0]; f <= o[1]; ++f) Po(h, d[f]);
        return h;
      }
      function Oa(d) {
        const o = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
        for (const h of d) for (const f of h) Po(o, f);
        return o;
      }
      function Mc(d) {
        return d[0] !== -1 / 0 && d[1] !== -1 / 0 && d[2] !== 1 / 0 && d[3] !== 1 / 0;
      }
      function As(d, o, h) {
        if (!Mc(d) || !Mc(o)) return NaN;
        let f = 0, _ = 0;
        return d[2] < o[0] && (f = o[0] - d[2]), d[0] > o[2] && (f = d[0] - o[2]), d[1] > o[3] && (_ = d[1] - o[3]), d[3] < o[1] && (_ = o[1] - d[3]), h.distance([0, 0], [f, _]);
      }
      function Da(d, o, h) {
        const f = h.pointOnLine(o, d);
        return h.distance(d, f.point);
      }
      function Hl(d, o, h, f, _) {
        const v = Math.min(Da(d, [h, f], _), Da(o, [h, f], _)), w = Math.min(Da(h, [d, o], _), Da(f, [d, o], _));
        return Math.min(v, w);
      }
      function Ei(d, o, h, f, _) {
        if (!rr(o, d.length) || !rr(f, h.length)) return 1 / 0;
        let v = 1 / 0;
        for (let w = o[0]; w < o[1]; ++w) {
          const P = d[w], R = d[w + 1];
          for (let D = f[0]; D < f[1]; ++D) {
            const z = h[D], j = h[D + 1];
            if (te(P, R, z, j)) return 0;
            v = Math.min(v, Hl(P, R, z, j, _));
          }
        }
        return v;
      }
      function Io(d, o, h, f, _) {
        if (!rr(o, d.length) || !rr(f, h.length)) return NaN;
        let v = 1 / 0;
        for (let w = o[0]; w <= o[1]; ++w) for (let P = f[0]; P <= f[1]; ++P) if (v = Math.min(v, _.distance(d[w], h[P])), v === 0) return v;
        return v;
      }
      function Lc(d, o, h) {
        if (Ke(d, o, !0)) return 0;
        let f = 1 / 0;
        for (const _ of o) {
          const v = _[0], w = _[_.length - 1];
          if (v !== w && (f = Math.min(f, Da(d, [w, v], h)), f === 0)) return f;
          const P = h.pointOnLine(_, d);
          if (f = Math.min(f, h.distance(d, P.point)), f === 0) return f;
        }
        return f;
      }
      function Uu(d, o, h, f) {
        if (!rr(o, d.length)) return NaN;
        for (let v = o[0]; v <= o[1]; ++v) if (Ke(d[v], h, !0)) return 0;
        let _ = 1 / 0;
        for (let v = o[0]; v < o[1]; ++v) {
          const w = d[v], P = d[v + 1];
          for (const R of h) for (let D = 0, z = R.length, j = z - 1; D < z; j = D++) {
            const Y = R[j], K = R[D];
            if (te(w, P, Y, K)) return 0;
            _ = Math.min(_, Hl(w, P, Y, K, f));
          }
        }
        return _;
      }
      function lu(d, o) {
        for (const h of d) for (const f of h) if (Ke(f, o, !0)) return !0;
        return !1;
      }
      function cl(d, o, h) {
        let f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1 / 0;
        const _ = Oa(d), v = Oa(o);
        if (f !== 1 / 0 && As(_, v, h) >= f) return f;
        if (Ba(_, v)) {
          if (lu(d, o)) return 0;
        } else if (lu(o, d)) return 0;
        let w = 1 / 0;
        for (const P of d) for (let R = 0, D = P.length, z = D - 1; R < D; z = R++) {
          const j = P[z], Y = P[R];
          for (const K of o) for (let Q = 0, se = K.length, Ee = se - 1; Q < se; Ee = Q++) {
            const Se = K[Ee], et = K[Q];
            if (te(j, Y, Se, et)) return 0;
            w = Math.min(w, Hl(j, Y, Se, et, h));
          }
        }
        return w;
      }
      function ul(d, o, h, f, _, v) {
        if (!v) return;
        const w = As(ll(f, v), _, h);
        w < o && d.push([w, v, [0, 0]]);
      }
      function ds(d, o, h, f, _, v, w) {
        if (!v || !w) return;
        const P = As(ll(f, v), ll(_, w), h);
        P < o && d.push([P, v, w]);
      }
      function $r(d, o, h, f) {
        let _ = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1 / 0, v = Math.min(f.distance(d[0], h[0][0]), _);
        if (v === 0) return v;
        const w = new Sr([[0, [0, d.length - 1], [0, 0]]], ql), P = Oa(h);
        for (; w.length > 0; ) {
          const R = w.pop();
          if (R[0] >= v) continue;
          const D = R[1], z = o ? 50 : 100;
          if (ga(D) <= z) {
            if (!rr(D, d.length)) return NaN;
            if (o) {
              const j = Uu(d, D, h, f);
              if (isNaN(j) || j === 0) return j;
              v = Math.min(v, j);
            } else for (let j = D[0]; j <= D[1]; ++j) {
              const Y = Lc(d[j], h, f);
              if (v = Math.min(v, Y), v === 0) return 0;
            }
          } else {
            const j = al(D, o);
            ul(w, v, f, d, P, j[0]), ul(w, v, f, d, P, j[1]);
          }
        }
        return v;
      }
      function Qo(d, o, h, f, _) {
        let v = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1 / 0, w = Math.min(v, _.distance(d[0], h[0]));
        if (w === 0) return w;
        const P = new Sr([[0, [0, d.length - 1], [0, h.length - 1]]], ql);
        for (; P.length > 0; ) {
          const R = P.pop();
          if (R[0] >= w) continue;
          const D = R[1], z = R[2], j = o ? 50 : 100, Y = f ? 50 : 100;
          if (ga(D) <= j && ga(z) <= Y) {
            if (!rr(D, d.length) && rr(z, h.length)) return NaN;
            let K;
            if (o && f) K = Ei(d, D, h, z, _), w = Math.min(w, K);
            else if (o && !f) {
              const Q = d.slice(D[0], D[1] + 1);
              for (let se = z[0]; se <= z[1]; ++se) if (K = Da(h[se], Q, _), w = Math.min(w, K), w === 0) return w;
            } else if (!o && f) {
              const Q = h.slice(z[0], z[1] + 1);
              for (let se = D[0]; se <= D[1]; ++se) if (K = Da(d[se], Q, _), w = Math.min(w, K), w === 0) return w;
            } else K = Io(d, D, h, z, _), w = Math.min(w, K);
          } else {
            const K = al(D, o), Q = al(z, f);
            ds(P, w, _, d, h, K[0], Q[0]), ds(P, w, _, d, h, K[0], Q[1]), ds(P, w, _, d, h, K[1], Q[0]), ds(P, w, _, d, h, K[1], Q[1]);
          }
        }
        return w;
      }
      function ea(d) {
        return d.type === "MultiPolygon" ? d.coordinates.map((o) => ({ type: "Polygon", coordinates: o })) : d.type === "MultiLineString" ? d.coordinates.map((o) => ({ type: "LineString", coordinates: o })) : d.type === "MultiPoint" ? d.coordinates.map((o) => ({ type: "Point", coordinates: o })) : [d];
      }
      class Os {
        constructor(o, h) {
          this.type = It, this.geojson = o, this.geometries = h;
        }
        static parse(o, h) {
          if (o.length !== 2) return h.error(`'distance' expression requires exactly one argument, but found ${o.length - 1} instead.`);
          if (Ki(o[1])) {
            const f = o[1];
            if (f.type === "FeatureCollection") return new Os(f, f.features.map((_) => ea(_.geometry)).flat());
            if (f.type === "Feature") return new Os(f, ea(f.geometry));
            if ("type" in f && "coordinates" in f) return new Os(f, ea(f));
          }
          return h.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
        }
        evaluate(o) {
          if (o.geometry() != null && o.canonicalID() != null) {
            if (o.geometryType() === "Point") return function(h, f) {
              const _ = h.geometry(), v = _.flat().map((R) => zl([R.x, R.y], h.canonical));
              if (_.length === 0) return NaN;
              const w = new Vl(v[0][1]);
              let P = 1 / 0;
              for (const R of f) {
                switch (R.type) {
                  case "Point":
                    P = Math.min(P, Qo(v, !1, [R.coordinates], !1, w, P));
                    break;
                  case "LineString":
                    P = Math.min(P, Qo(v, !1, R.coordinates, !0, w, P));
                    break;
                  case "Polygon":
                    P = Math.min(P, $r(v, !1, R.coordinates, w, P));
                }
                if (P === 0) return P;
              }
              return P;
            }(o, this.geometries);
            if (o.geometryType() === "LineString") return function(h, f) {
              const _ = h.geometry(), v = _.flat().map((R) => zl([R.x, R.y], h.canonical));
              if (_.length === 0) return NaN;
              const w = new Vl(v[0][1]);
              let P = 1 / 0;
              for (const R of f) {
                switch (R.type) {
                  case "Point":
                    P = Math.min(P, Qo(v, !0, [R.coordinates], !1, w, P));
                    break;
                  case "LineString":
                    P = Math.min(P, Qo(v, !0, R.coordinates, !0, w, P));
                    break;
                  case "Polygon":
                    P = Math.min(P, $r(v, !0, R.coordinates, w, P));
                }
                if (P === 0) return P;
              }
              return P;
            }(o, this.geometries);
            if (o.geometryType() === "Polygon") return function(h, f) {
              const _ = h.geometry();
              if (_.length === 0 || _[0].length === 0) return NaN;
              const v = Bs(_, 0).map((R) => R.map((D) => D.map((z) => zl([z.x, z.y], h.canonical)))), w = new Vl(v[0][0][0][1]);
              let P = 1 / 0;
              for (const R of f) for (const D of v) {
                switch (R.type) {
                  case "Point":
                    P = Math.min(P, $r([R.coordinates], !1, D, w, P));
                    break;
                  case "LineString":
                    P = Math.min(P, $r(R.coordinates, !0, D, w, P));
                    break;
                  case "Polygon":
                    P = Math.min(P, cl(D, R.coordinates, w, P));
                }
                if (P === 0) return P;
              }
              return P;
            }(o, this.geometries);
          }
          return NaN;
        }
        eachChild() {
        }
        outputDefined() {
          return !0;
        }
      }
      const ta = { "==": ku, "!=": Pc, ">": Fl, "<": Ic, ">=": Nl, "<=": ou, array: Js, at: Rl, boolean: Js, case: So, coalesce: Qs, collator: Co, format: La, image: Ra, in: gi, "index-of": fa, interpolate: yi, "interpolate-hcl": yi, "interpolate-lab": yi, length: au, let: li, literal: ho, match: ls, number: Js, "number-format": cs, object: Js, slice: Bl, step: Ko, string: Js, "to-boolean": Zr, "to-color": Zr, "to-number": Zr, "to-string": Zr, var: Kn, within: Wi, distance: Os };
      class Fr {
        constructor(o, h, f, _) {
          this.name = o, this.type = h, this._evaluate = f, this.args = _;
        }
        evaluate(o) {
          return this._evaluate(o, this.args);
        }
        eachChild(o) {
          this.args.forEach(o);
        }
        outputDefined() {
          return !1;
        }
        static parse(o, h) {
          const f = o[0], _ = Fr.definitions[f];
          if (!_) return h.error(`Unknown expression "${f}". If you wanted a literal array, use ["literal", [...]].`, 0);
          const v = Array.isArray(_) ? _[0] : _.type, w = Array.isArray(_) ? [[_[1], _[2]]] : _.overloads, P = w.filter((D) => {
            let [z] = D;
            return !Array.isArray(z) || z.length === o.length - 1;
          });
          let R = null;
          for (const [D, z] of P) {
            R = new Yo(h.registry, Fa, h.path, null, h.scope);
            const j = [];
            let Y = !1;
            for (let K = 1; K < o.length; K++) {
              const Q = o[K], se = Array.isArray(D) ? D[K - 1] : D.type, Ee = R.parse(Q, 1 + j.length, se);
              if (!Ee) {
                Y = !0;
                break;
              }
              j.push(Ee);
            }
            if (!Y) if (Array.isArray(D) && D.length !== j.length) R.error(`Expected ${D.length} arguments, but found ${j.length} instead.`);
            else {
              for (let K = 0; K < j.length; K++) {
                const Q = Array.isArray(D) ? D[K] : D.type, se = j[K];
                R.concat(K + 1).checkSubtype(Q, se.type);
              }
              if (R.errors.length === 0) return new Fr(f, v, z, j);
            }
          }
          if (P.length === 1) h.errors.push(...R.errors);
          else {
            const D = (P.length ? P : w).map((j) => {
              let [Y] = j;
              return K = Y, Array.isArray(K) ? `(${K.map(_i).join(", ")})` : `(${_i(K.type)}...)`;
              var K;
            }).join(" | "), z = [];
            for (let j = 1; j < o.length; j++) {
              const Y = h.parse(o[j], 1 + z.length);
              if (!Y) return null;
              z.push(_i(Y.type));
            }
            h.error(`Expected arguments of type ${D}, but found (${z.join(", ")}) instead.`);
          }
          return null;
        }
        static register(o, h) {
          Fr.definitions = h;
          for (const f in h) o[f] = Fr;
        }
      }
      function vr(d, o) {
        let [h, f, _, v] = o;
        h = h.evaluate(d), f = f.evaluate(d), _ = _.evaluate(d);
        const w = v ? v.evaluate(d) : 1, P = Ji(h, f, _, w);
        if (P) throw new _t(P);
        return new Qn(h / 255, f / 255, _ / 255, w, !1);
      }
      function Rc(d, o) {
        return d in o;
      }
      function fs(d, o) {
        const h = o[d];
        return h === void 0 ? null : h;
      }
      function Xr(d) {
        return { type: d };
      }
      function Fa(d) {
        if (d instanceof Kn) return Fa(d.boundExpression);
        if (d instanceof Fr && d.name === "error" || d instanceof Co || d instanceof Wi || d instanceof Os) return !1;
        const o = d instanceof Zr || d instanceof Js;
        let h = !0;
        return d.eachChild((f) => {
          h = o ? h && Fa(f) : h && f instanceof ho;
        }), !!h && Wl(d) && ma(d, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
      }
      function Wl(d) {
        if (d instanceof Fr && (d.name === "get" && d.args.length === 1 || d.name === "feature-state" || d.name === "has" && d.args.length === 1 || d.name === "properties" || d.name === "geometry-type" || d.name === "id" || /^filter-/.test(d.name)) || d instanceof Wi || d instanceof Os) return !1;
        let o = !0;
        return d.eachChild((h) => {
          o && !Wl(h) && (o = !1);
        }), o;
      }
      function Na(d) {
        if (d instanceof Fr && d.name === "feature-state") return !1;
        let o = !0;
        return d.eachChild((h) => {
          o && !Na(h) && (o = !1);
        }), o;
      }
      function ma(d, o) {
        if (d instanceof Fr && o.indexOf(d.name) >= 0) return !1;
        let h = !0;
        return d.eachChild((f) => {
          h && !ma(f, o) && (h = !1);
        }), h;
      }
      function hl(d) {
        return { result: "success", value: d };
      }
      function go(d) {
        return { result: "error", value: d };
      }
      function Mo(d) {
        return d["property-type"] === "data-driven" || d["property-type"] === "cross-faded-data-driven";
      }
      function Zl(d) {
        return !!d.expression && d.expression.parameters.indexOf("zoom") > -1;
      }
      function ka(d) {
        return !!d.expression && d.expression.interpolated;
      }
      function oi(d) {
        return d instanceof Number ? "number" : d instanceof String ? "string" : d instanceof Boolean ? "boolean" : Array.isArray(d) ? "array" : d === null ? "null" : typeof d;
      }
      function dl(d) {
        return typeof d == "object" && d !== null && !Array.isArray(d);
      }
      function Lo(d) {
        return d;
      }
      function mo(d, o) {
        const h = o.type === "color", f = d.stops && typeof d.stops[0][0] == "object", _ = f || !(f || d.property !== void 0), v = d.type || (ka(o) ? "exponential" : "interval");
        if (h || o.type === "padding") {
          const z = h ? Qn.parse : Ve.parse;
          (d = an({}, d)).stops && (d.stops = d.stops.map((j) => [j[0], z(j[1])])), d.default = z(d.default ? d.default : o.default);
        }
        if (d.colorSpace && (w = d.colorSpace) !== "rgb" && w !== "hcl" && w !== "lab") throw new Error(`Unknown color space: "${d.colorSpace}"`);
        var w;
        let P, R, D;
        if (v === "exponential") P = Nr;
        else if (v === "interval") P = Cr;
        else if (v === "categorical") {
          P = Zi, R = /* @__PURE__ */ Object.create(null);
          for (const z of d.stops) R[z[0]] = z[1];
          D = typeof d.stops[0][0];
        } else {
          if (v !== "identity") throw new Error(`Unknown function type "${v}"`);
          P = za;
        }
        if (f) {
          const z = {}, j = [];
          for (let Q = 0; Q < d.stops.length; Q++) {
            const se = d.stops[Q], Ee = se[0].zoom;
            z[Ee] === void 0 && (z[Ee] = { zoom: Ee, type: d.type, property: d.property, default: d.default, stops: [] }, j.push(Ee)), z[Ee].stops.push([se[0].value, se[1]]);
          }
          const Y = [];
          for (const Q of j) Y.push([z[Q].zoom, mo(z[Q], o)]);
          const K = { name: "linear" };
          return { kind: "composite", interpolationType: K, interpolationFactor: yi.interpolationFactor.bind(void 0, K), zoomStops: Y.map((Q) => Q[0]), evaluate: (Q, se) => {
            let { zoom: Ee } = Q;
            return Nr({ stops: Y, base: d.base }, o, Ee).evaluate(Ee, se);
          } };
        }
        if (_) {
          const z = v === "exponential" ? { name: "exponential", base: d.base !== void 0 ? d.base : 1 } : null;
          return { kind: "camera", interpolationType: z, interpolationFactor: yi.interpolationFactor.bind(void 0, z), zoomStops: d.stops.map((j) => j[0]), evaluate: (j) => {
            let { zoom: Y } = j;
            return P(d, o, Y, R, D);
          } };
        }
        return { kind: "source", evaluate(z, j) {
          const Y = j && j.properties ? j.properties[d.property] : void 0;
          return Y === void 0 ? Di(d.default, o.default) : P(d, o, Y, R, D);
        } };
      }
      function Di(d, o, h) {
        return d !== void 0 ? d : o !== void 0 ? o : h !== void 0 ? h : void 0;
      }
      function Zi(d, o, h, f, _) {
        return Di(typeof h === _ ? f[h] : void 0, d.default, o.default);
      }
      function Cr(d, o, h) {
        if (oi(h) !== "number") return Di(d.default, o.default);
        const f = d.stops.length;
        if (f === 1 || h <= d.stops[0][0]) return d.stops[0][1];
        if (h >= d.stops[f - 1][0]) return d.stops[f - 1][1];
        const _ = Jo(d.stops.map((v) => v[0]), h);
        return d.stops[_][1];
      }
      function Nr(d, o, h) {
        const f = d.base !== void 0 ? d.base : 1;
        if (oi(h) !== "number") return Di(d.default, o.default);
        const _ = d.stops.length;
        if (_ === 1 || h <= d.stops[0][0]) return d.stops[0][1];
        if (h >= d.stops[_ - 1][0]) return d.stops[_ - 1][1];
        const v = Jo(d.stops.map((z) => z[0]), h), w = function(z, j, Y, K) {
          const Q = K - Y, se = z - Y;
          return Q === 0 ? 0 : j === 1 ? se / Q : (Math.pow(j, se) - 1) / (Math.pow(j, Q) - 1);
        }(h, f, d.stops[v][0], d.stops[v + 1][0]), P = d.stops[v][1], R = d.stops[v + 1][1], D = fo[o.type] || Lo;
        return typeof P.evaluate == "function" ? { evaluate() {
          for (var z = arguments.length, j = new Array(z), Y = 0; Y < z; Y++)
            j[Y] = arguments[Y];
          const K = P.evaluate.apply(void 0, j), Q = R.evaluate.apply(void 0, j);
          if (K !== void 0 && Q !== void 0) return D(K, Q, w, d.colorSpace);
        } } : D(P, R, w, d.colorSpace);
      }
      function za(d, o, h) {
        switch (o.type) {
          case "color":
            h = Qn.parse(h);
            break;
          case "formatted":
            h = we.fromString(h.toString());
            break;
          case "resolvedImage":
            h = Rn.fromString(h.toString());
            break;
          case "padding":
            h = Ve.parse(h);
            break;
          default:
            oi(h) === o.type || o.type === "enum" && o.values[h] || (h = void 0);
        }
        return Di(h, d.default, o.default);
      }
      Fr.register(ta, { error: [{ kind: "error" }, [Jt], (d, o) => {
        let [h] = o;
        throw new _t(h.evaluate(d));
      }], typeof: [Jt, [fn], (d, o) => {
        let [h] = o;
        return _i(qn(h.evaluate(d)));
      }], "to-rgba": [Oi(It, 4), [In], (d, o) => {
        let [h] = o;
        const [f, _, v, w] = h.evaluate(d).rgb;
        return [255 * f, 255 * _, 255 * v, w];
      }], rgb: [In, [It, It, It], vr], rgba: [In, [It, It, It, It], vr], has: { type: cn, overloads: [[[Jt], (d, o) => {
        let [h] = o;
        return Rc(h.evaluate(d), d.properties());
      }], [[Jt, Ln], (d, o) => {
        let [h, f] = o;
        return Rc(h.evaluate(d), f.evaluate(d));
      }]] }, get: { type: fn, overloads: [[[Jt], (d, o) => {
        let [h] = o;
        return fs(h.evaluate(d), d.properties());
      }], [[Jt, Ln], (d, o) => {
        let [h, f] = o;
        return fs(h.evaluate(d), f.evaluate(d));
      }]] }, "feature-state": [fn, [Jt], (d, o) => {
        let [h] = o;
        return fs(h.evaluate(d), d.featureState || {});
      }], properties: [Ln, [], (d) => d.properties()], "geometry-type": [Jt, [], (d) => d.geometryType()], id: [fn, [], (d) => d.id()], zoom: [It, [], (d) => d.globals.zoom], "heatmap-density": [It, [], (d) => d.globals.heatmapDensity || 0], "line-progress": [It, [], (d) => d.globals.lineProgress || 0], accumulated: [fn, [], (d) => d.globals.accumulated === void 0 ? null : d.globals.accumulated], "+": [It, Xr(It), (d, o) => {
        let h = 0;
        for (const f of o) h += f.evaluate(d);
        return h;
      }], "*": [It, Xr(It), (d, o) => {
        let h = 1;
        for (const f of o) h *= f.evaluate(d);
        return h;
      }], "-": { type: It, overloads: [[[It, It], (d, o) => {
        let [h, f] = o;
        return h.evaluate(d) - f.evaluate(d);
      }], [[It], (d, o) => {
        let [h] = o;
        return -h.evaluate(d);
      }]] }, "/": [It, [It, It], (d, o) => {
        let [h, f] = o;
        return h.evaluate(d) / f.evaluate(d);
      }], "%": [It, [It, It], (d, o) => {
        let [h, f] = o;
        return h.evaluate(d) % f.evaluate(d);
      }], ln2: [It, [], () => Math.LN2], pi: [It, [], () => Math.PI], e: [It, [], () => Math.E], "^": [It, [It, It], (d, o) => {
        let [h, f] = o;
        return Math.pow(h.evaluate(d), f.evaluate(d));
      }], sqrt: [It, [It], (d, o) => {
        let [h] = o;
        return Math.sqrt(h.evaluate(d));
      }], log10: [It, [It], (d, o) => {
        let [h] = o;
        return Math.log(h.evaluate(d)) / Math.LN10;
      }], ln: [It, [It], (d, o) => {
        let [h] = o;
        return Math.log(h.evaluate(d));
      }], log2: [It, [It], (d, o) => {
        let [h] = o;
        return Math.log(h.evaluate(d)) / Math.LN2;
      }], sin: [It, [It], (d, o) => {
        let [h] = o;
        return Math.sin(h.evaluate(d));
      }], cos: [It, [It], (d, o) => {
        let [h] = o;
        return Math.cos(h.evaluate(d));
      }], tan: [It, [It], (d, o) => {
        let [h] = o;
        return Math.tan(h.evaluate(d));
      }], asin: [It, [It], (d, o) => {
        let [h] = o;
        return Math.asin(h.evaluate(d));
      }], acos: [It, [It], (d, o) => {
        let [h] = o;
        return Math.acos(h.evaluate(d));
      }], atan: [It, [It], (d, o) => {
        let [h] = o;
        return Math.atan(h.evaluate(d));
      }], min: [It, Xr(It), (d, o) => Math.min(...o.map((h) => h.evaluate(d)))], max: [It, Xr(It), (d, o) => Math.max(...o.map((h) => h.evaluate(d)))], abs: [It, [It], (d, o) => {
        let [h] = o;
        return Math.abs(h.evaluate(d));
      }], round: [It, [It], (d, o) => {
        let [h] = o;
        const f = h.evaluate(d);
        return f < 0 ? -Math.round(-f) : Math.round(f);
      }], floor: [It, [It], (d, o) => {
        let [h] = o;
        return Math.floor(h.evaluate(d));
      }], ceil: [It, [It], (d, o) => {
        let [h] = o;
        return Math.ceil(h.evaluate(d));
      }], "filter-==": [cn, [Jt, fn], (d, o) => {
        let [h, f] = o;
        return d.properties()[h.value] === f.value;
      }], "filter-id-==": [cn, [fn], (d, o) => {
        let [h] = o;
        return d.id() === h.value;
      }], "filter-type-==": [cn, [Jt], (d, o) => {
        let [h] = o;
        return d.geometryType() === h.value;
      }], "filter-<": [cn, [Jt, fn], (d, o) => {
        let [h, f] = o;
        const _ = d.properties()[h.value], v = f.value;
        return typeof _ == typeof v && _ < v;
      }], "filter-id-<": [cn, [fn], (d, o) => {
        let [h] = o;
        const f = d.id(), _ = h.value;
        return typeof f == typeof _ && f < _;
      }], "filter->": [cn, [Jt, fn], (d, o) => {
        let [h, f] = o;
        const _ = d.properties()[h.value], v = f.value;
        return typeof _ == typeof v && _ > v;
      }], "filter-id->": [cn, [fn], (d, o) => {
        let [h] = o;
        const f = d.id(), _ = h.value;
        return typeof f == typeof _ && f > _;
      }], "filter-<=": [cn, [Jt, fn], (d, o) => {
        let [h, f] = o;
        const _ = d.properties()[h.value], v = f.value;
        return typeof _ == typeof v && _ <= v;
      }], "filter-id-<=": [cn, [fn], (d, o) => {
        let [h] = o;
        const f = d.id(), _ = h.value;
        return typeof f == typeof _ && f <= _;
      }], "filter->=": [cn, [Jt, fn], (d, o) => {
        let [h, f] = o;
        const _ = d.properties()[h.value], v = f.value;
        return typeof _ == typeof v && _ >= v;
      }], "filter-id->=": [cn, [fn], (d, o) => {
        let [h] = o;
        const f = d.id(), _ = h.value;
        return typeof f == typeof _ && f >= _;
      }], "filter-has": [cn, [fn], (d, o) => {
        let [h] = o;
        return h.value in d.properties();
      }], "filter-has-id": [cn, [], (d) => d.id() !== null && d.id() !== void 0], "filter-type-in": [cn, [Oi(Jt)], (d, o) => {
        let [h] = o;
        return h.value.indexOf(d.geometryType()) >= 0;
      }], "filter-id-in": [cn, [Oi(fn)], (d, o) => {
        let [h] = o;
        return h.value.indexOf(d.id()) >= 0;
      }], "filter-in-small": [cn, [Jt, Oi(fn)], (d, o) => {
        let [h, f] = o;
        return f.value.indexOf(d.properties()[h.value]) >= 0;
      }], "filter-in-large": [cn, [Jt, Oi(fn)], (d, o) => {
        let [h, f] = o;
        return function(_, v, w, P) {
          for (; w <= P; ) {
            const R = w + P >> 1;
            if (v[R] === _) return !0;
            v[R] > _ ? P = R - 1 : w = R + 1;
          }
          return !1;
        }(d.properties()[h.value], f.value, 0, f.value.length - 1);
      }], all: { type: cn, overloads: [[[cn, cn], (d, o) => {
        let [h, f] = o;
        return h.evaluate(d) && f.evaluate(d);
      }], [Xr(cn), (d, o) => {
        for (const h of o) if (!h.evaluate(d)) return !1;
        return !0;
      }]] }, any: { type: cn, overloads: [[[cn, cn], (d, o) => {
        let [h, f] = o;
        return h.evaluate(d) || f.evaluate(d);
      }], [Xr(cn), (d, o) => {
        for (const h of o) if (h.evaluate(d)) return !0;
        return !1;
      }]] }, "!": [cn, [cn], (d, o) => {
        let [h] = o;
        return !h.evaluate(d);
      }], "is-supported-script": [cn, [Jt], (d, o) => {
        let [h] = o;
        const f = d.globals && d.globals.isSupportedScript;
        return !f || f(h.evaluate(d));
      }], upcase: [Jt, [Jt], (d, o) => {
        let [h] = o;
        return h.evaluate(d).toUpperCase();
      }], downcase: [Jt, [Jt], (d, o) => {
        let [h] = o;
        return h.evaluate(d).toLowerCase();
      }], concat: [Jt, Xr(fn), (d, o) => o.map((h) => Ml(h.evaluate(d))).join("")], "resolved-locale": [Jt, [xi], (d, o) => {
        let [h] = o;
        return h.evaluate(d).resolvedLocale();
      }] });
      class fl {
        constructor(o, h) {
          var f;
          this.expression = o, this._warningHistory = {}, this._evaluator = new Ui(), this._defaultValue = h ? (f = h).type === "color" && dl(f.default) ? new Qn(0, 0, 0, 0) : f.type === "color" ? Qn.parse(f.default) || null : f.type === "padding" ? Ve.parse(f.default) || null : f.type === "variableAnchorOffsetCollection" ? gn.parse(f.default) || null : f.type === "projectionDefinition" ? hi.parse(f.default) || null : f.default === void 0 ? null : f.default : null, this._enumValues = h && h.type === "enum" ? h.values : null;
        }
        evaluateWithoutErrorHandling(o, h, f, _, v, w) {
          return this._evaluator.globals = o, this._evaluator.feature = h, this._evaluator.featureState = f, this._evaluator.canonical = _, this._evaluator.availableImages = v || null, this._evaluator.formattedSection = w, this.expression.evaluate(this._evaluator);
        }
        evaluate(o, h, f, _, v, w) {
          this._evaluator.globals = o, this._evaluator.feature = h || null, this._evaluator.featureState = f || null, this._evaluator.canonical = _, this._evaluator.availableImages = v || null, this._evaluator.formattedSection = w || null;
          try {
            const P = this.expression.evaluate(this._evaluator);
            if (P == null || typeof P == "number" && P != P) return this._defaultValue;
            if (this._enumValues && !(P in this._enumValues)) throw new _t(`Expected value to be one of ${Object.keys(this._enumValues).map((R) => JSON.stringify(R)).join(", ")}, but found ${JSON.stringify(P)} instead.`);
            return P;
          } catch (P) {
            return this._warningHistory[P.message] || (this._warningHistory[P.message] = !0, typeof console < "u" && console.warn(P.message)), this._defaultValue;
          }
        }
      }
      function Ua(d) {
        return Array.isArray(d) && d.length > 0 && typeof d[0] == "string" && d[0] in ta;
      }
      function $l(d, o) {
        const h = new Yo(ta, Fa, [], o ? function(_) {
          const v = { color: In, string: Jt, number: It, enum: Jt, boolean: cn, formatted: Er, padding: Pi, projectionDefinition: Zn, resolvedImage: Ii, variableAnchorOffsetCollection: ui };
          return _.type === "array" ? Oi(v[_.value] || fn, _.length) : v[_.type];
        }(o) : void 0), f = h.parse(d, void 0, void 0, void 0, o && o.type === "string" ? { typeAnnotation: "coerce" } : void 0);
        return f ? hl(new fl(f, o)) : go(h.errors);
      }
      class pl {
        constructor(o, h) {
          this.kind = o, this._styleExpression = h, this.isStateDependent = o !== "constant" && !Na(h.expression);
        }
        evaluateWithoutErrorHandling(o, h, f, _, v, w) {
          return this._styleExpression.evaluateWithoutErrorHandling(o, h, f, _, v, w);
        }
        evaluate(o, h, f, _, v, w) {
          return this._styleExpression.evaluate(o, h, f, _, v, w);
        }
      }
      class Xl {
        constructor(o, h, f, _) {
          this.kind = o, this.zoomStops = f, this._styleExpression = h, this.isStateDependent = o !== "camera" && !Na(h.expression), this.interpolationType = _;
        }
        evaluateWithoutErrorHandling(o, h, f, _, v, w) {
          return this._styleExpression.evaluateWithoutErrorHandling(o, h, f, _, v, w);
        }
        evaluate(o, h, f, _, v, w) {
          return this._styleExpression.evaluate(o, h, f, _, v, w);
        }
        interpolationFactor(o, h, f) {
          return this.interpolationType ? yi.interpolationFactor(this.interpolationType, o, h, f) : 0;
        }
      }
      function to(d, o) {
        const h = $l(d, o);
        if (h.result === "error") return h;
        const f = h.value.expression, _ = Wl(f);
        if (!_ && !Mo(o)) return go([new Yt("", "data expressions not supported")]);
        const v = ma(f, ["zoom"]);
        if (!v && !Zl(o)) return go([new Yt("", "zoom expressions not supported")]);
        const w = Yl(f);
        return w || v ? w instanceof Yt ? go([w]) : w instanceof yi && !ka(o) ? go([new Yt("", '"interpolate" expressions cannot be used with this property')]) : hl(w ? new Xl(_ ? "camera" : "composite", h.value, w.labels, w instanceof yi ? w.interpolation : void 0) : new pl(_ ? "constant" : "source", h.value)) : go([new Yt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
      }
      class Ds {
        constructor(o, h) {
          this._parameters = o, this._specification = h, an(this, mo(this._parameters, this._specification));
        }
        static deserialize(o) {
          return new Ds(o._parameters, o._specification);
        }
        static serialize(o) {
          return { _parameters: o._parameters, _specification: o._specification };
        }
      }
      function Yl(d) {
        let o = null;
        if (d instanceof li) o = Yl(d.result);
        else if (d instanceof Qs) {
          for (const h of d.args) if (o = Yl(h), o) break;
        } else (d instanceof Ko || d instanceof yi) && d.input instanceof Fr && d.input.name === "zoom" && (o = d);
        return o instanceof Yt || d.eachChild((h) => {
          const f = Yl(h);
          f instanceof Yt ? o = f : !o && f ? o = new Yt("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : o && f && o !== f && (o = new Yt("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
        }), o;
      }
      function Bc(d) {
        if (d === !0 || d === !1) return !0;
        if (!Array.isArray(d) || d.length === 0) return !1;
        switch (d[0]) {
          case "has":
            return d.length >= 2 && d[1] !== "$id" && d[1] !== "$type";
          case "in":
            return d.length >= 3 && (typeof d[1] != "string" || Array.isArray(d[2]));
          case "!in":
          case "!has":
          case "none":
            return !1;
          case "==":
          case "!=":
          case ">":
          case ">=":
          case "<":
          case "<=":
            return d.length !== 3 || Array.isArray(d[1]) || Array.isArray(d[2]);
          case "any":
          case "all":
            for (const o of d.slice(1)) if (!Bc(o) && typeof o != "boolean") return !1;
            return !0;
          default:
            return !0;
        }
      }
      const ad = { type: "boolean", default: !1, transition: !1, "property-type": "data-driven", expression: { interpolated: !1, parameters: ["zoom", "feature"] } };
      function Jl(d) {
        if (d == null) return { filter: () => !0, needGeometry: !1 };
        Bc(d) || (d = uu(d));
        const o = $l(d, ad);
        if (o.result === "error") throw new Error(o.value.map((h) => `${h.key}: ${h.message}`).join(", "));
        return { filter: (h, f, _) => o.value.evaluate(h, f, {}, _), needGeometry: ju(d) };
      }
      function cu(d, o) {
        return d < o ? -1 : d > o ? 1 : 0;
      }
      function ju(d) {
        if (!Array.isArray(d)) return !1;
        if (d[0] === "within" || d[0] === "distance") return !0;
        for (let o = 1; o < d.length; o++) if (ju(d[o])) return !0;
        return !1;
      }
      function uu(d) {
        if (!d) return !0;
        const o = d[0];
        return d.length <= 1 ? o !== "any" : o === "==" ? Oc(d[1], d[2], "==") : o === "!=" ? Kl(Oc(d[1], d[2], "==")) : o === "<" || o === ">" || o === "<=" || o === ">=" ? Oc(d[1], d[2], o) : o === "any" ? (h = d.slice(1), ["any"].concat(h.map(uu))) : o === "all" ? ["all"].concat(d.slice(1).map(uu)) : o === "none" ? ["all"].concat(d.slice(1).map(uu).map(Kl)) : o === "in" ? hu(d[1], d.slice(2)) : o === "!in" ? Kl(hu(d[1], d.slice(2))) : o === "has" ? Dc(d[1]) : o !== "!has" || Kl(Dc(d[1]));
        var h;
      }
      function Oc(d, o, h) {
        switch (d) {
          case "$type":
            return [`filter-type-${h}`, o];
          case "$id":
            return [`filter-id-${h}`, o];
          default:
            return [`filter-${h}`, d, o];
        }
      }
      function hu(d, o) {
        if (o.length === 0) return !1;
        switch (d) {
          case "$type":
            return ["filter-type-in", ["literal", o]];
          case "$id":
            return ["filter-id-in", ["literal", o]];
          default:
            return o.length > 200 && !o.some((h) => typeof h != typeof o[0]) ? ["filter-in-large", d, ["literal", o.sort(cu)]] : ["filter-in-small", d, ["literal", o]];
        }
      }
      function Dc(d) {
        switch (d) {
          case "$type":
            return !0;
          case "$id":
            return ["filter-has-id"];
          default:
            return ["filter-has", d];
        }
      }
      function Kl(d) {
        return ["!", d];
      }
      function du(d) {
        const o = typeof d;
        if (o === "number" || o === "boolean" || o === "string" || d == null) return JSON.stringify(d);
        if (Array.isArray(d)) {
          let _ = "[";
          for (const v of d) _ += `${du(v)},`;
          return `${_}]`;
        }
        const h = Object.keys(d).sort();
        let f = "{";
        for (let _ = 0; _ < h.length; _++) f += `${JSON.stringify(h[_])}:${du(d[h[_]])},`;
        return `${f}}`;
      }
      function bh(d) {
        let o = "";
        for (const h of ne) o += `/${du(d[h])}`;
        return o;
      }
      function fu(d) {
        const o = d.value;
        return o ? [new Ze(d.key, o, "constants have been deprecated as of v8")] : [];
      }
      function sr(d) {
        return d instanceof Number || d instanceof String || d instanceof Boolean ? d.valueOf() : d;
      }
      function Ql(d) {
        if (Array.isArray(d)) return d.map(Ql);
        if (d instanceof Object && !(d instanceof Number || d instanceof String || d instanceof Boolean)) {
          const o = {};
          for (const h in d) o[h] = Ql(d[h]);
          return o;
        }
        return sr(d);
      }
      function Ro(d) {
        const o = d.key, h = d.value, f = d.valueSpec || {}, _ = d.objectElementValidators || {}, v = d.style, w = d.styleSpec, P = d.validateSpec;
        let R = [];
        const D = oi(h);
        if (D !== "object") return [new Ze(o, h, `object expected, ${D} found`)];
        for (const z in h) {
          const j = z.split(".")[0], Y = f[j] || f["*"];
          let K;
          if (_[j]) K = _[j];
          else if (f[j]) K = P;
          else if (_["*"]) K = _["*"];
          else {
            if (!f["*"]) {
              R.push(new Ze(o, h[z], `unknown property "${z}"`));
              continue;
            }
            K = P;
          }
          R = R.concat(K({ key: (o && `${o}.`) + z, value: h[z], valueSpec: Y, style: v, styleSpec: w, object: h, objectKey: z, validateSpec: P }, h));
        }
        for (const z in f) _[z] || f[z].required && f[z].default === void 0 && h[z] === void 0 && R.push(new Ze(o, h, `missing required property "${z}"`));
        return R;
      }
      function vh(d) {
        const o = d.value, h = d.valueSpec, f = d.style, _ = d.styleSpec, v = d.key, w = d.arrayElementValidator || d.validateSpec;
        if (oi(o) !== "array") return [new Ze(v, o, `array expected, ${oi(o)} found`)];
        if (h.length && o.length !== h.length) return [new Ze(v, o, `array length ${h.length} expected, length ${o.length} found`)];
        if (h["min-length"] && o.length < h["min-length"]) return [new Ze(v, o, `array length at least ${h["min-length"]} expected, length ${o.length} found`)];
        let P = { type: h.value, values: h.values };
        _.$version < 7 && (P.function = h.function), oi(h.value) === "object" && (P = h.value);
        let R = [];
        for (let D = 0; D < o.length; D++) R = R.concat(w({ array: o, arrayIndex: D, value: o[D], valueSpec: P, validateSpec: d.validateSpec, style: f, styleSpec: _, key: `${v}[${D}]` }));
        return R;
      }
      function xh(d) {
        const o = d.key, h = d.value, f = d.valueSpec;
        let _ = oi(h);
        return _ === "number" && h != h && (_ = "NaN"), _ !== "number" ? [new Ze(o, h, `number expected, ${_} found`)] : "minimum" in f && h < f.minimum ? [new Ze(o, h, `${h} is less than the minimum value ${f.minimum}`)] : "maximum" in f && h > f.maximum ? [new Ze(o, h, `${h} is greater than the maximum value ${f.maximum}`)] : [];
      }
      function Gu(d) {
        const o = d.valueSpec, h = sr(d.value.type);
        let f, _, v, w = {};
        const P = h !== "categorical" && d.value.property === void 0, R = !P, D = oi(d.value.stops) === "array" && oi(d.value.stops[0]) === "array" && oi(d.value.stops[0][0]) === "object", z = Ro({ key: d.key, value: d.value, valueSpec: d.styleSpec.function, validateSpec: d.validateSpec, style: d.style, styleSpec: d.styleSpec, objectElementValidators: { stops: function(K) {
          if (h === "identity") return [new Ze(K.key, K.value, 'identity function may not have a "stops" property')];
          let Q = [];
          const se = K.value;
          return Q = Q.concat(vh({ key: K.key, value: se, valueSpec: K.valueSpec, validateSpec: K.validateSpec, style: K.style, styleSpec: K.styleSpec, arrayElementValidator: j })), oi(se) === "array" && se.length === 0 && Q.push(new Ze(K.key, se, "array must have at least one stop")), Q;
        }, default: function(K) {
          return K.validateSpec({ key: K.key, value: K.value, valueSpec: o, validateSpec: K.validateSpec, style: K.style, styleSpec: K.styleSpec });
        } } });
        return h === "identity" && P && z.push(new Ze(d.key, d.value, 'missing required property "property"')), h === "identity" || d.value.stops || z.push(new Ze(d.key, d.value, 'missing required property "stops"')), h === "exponential" && d.valueSpec.expression && !ka(d.valueSpec) && z.push(new Ze(d.key, d.value, "exponential functions not supported")), d.styleSpec.$version >= 8 && (R && !Mo(d.valueSpec) ? z.push(new Ze(d.key, d.value, "property functions not supported")) : P && !Zl(d.valueSpec) && z.push(new Ze(d.key, d.value, "zoom functions not supported"))), h !== "categorical" && !D || d.value.property !== void 0 || z.push(new Ze(d.key, d.value, '"property" property is required')), z;
        function j(K) {
          let Q = [];
          const se = K.value, Ee = K.key;
          if (oi(se) !== "array") return [new Ze(Ee, se, `array expected, ${oi(se)} found`)];
          if (se.length !== 2) return [new Ze(Ee, se, `array length 2 expected, length ${se.length} found`)];
          if (D) {
            if (oi(se[0]) !== "object") return [new Ze(Ee, se, `object expected, ${oi(se[0])} found`)];
            if (se[0].zoom === void 0) return [new Ze(Ee, se, "object stop key must have zoom")];
            if (se[0].value === void 0) return [new Ze(Ee, se, "object stop key must have value")];
            if (v && v > sr(se[0].zoom)) return [new Ze(Ee, se[0].zoom, "stop zoom values must appear in ascending order")];
            sr(se[0].zoom) !== v && (v = sr(se[0].zoom), _ = void 0, w = {}), Q = Q.concat(Ro({ key: `${Ee}[0]`, value: se[0], valueSpec: { zoom: {} }, validateSpec: K.validateSpec, style: K.style, styleSpec: K.styleSpec, objectElementValidators: { zoom: xh, value: Y } }));
          } else Q = Q.concat(Y({ key: `${Ee}[0]`, value: se[0], validateSpec: K.validateSpec, style: K.style, styleSpec: K.styleSpec }, se));
          return Ua(Ql(se[1])) ? Q.concat([new Ze(`${Ee}[1]`, se[1], "expressions are not allowed in function stops.")]) : Q.concat(K.validateSpec({ key: `${Ee}[1]`, value: se[1], valueSpec: o, validateSpec: K.validateSpec, style: K.style, styleSpec: K.styleSpec }));
        }
        function Y(K, Q) {
          const se = oi(K.value), Ee = sr(K.value), Se = K.value !== null ? K.value : Q;
          if (f) {
            if (se !== f) return [new Ze(K.key, Se, `${se} stop domain type must match previous stop domain type ${f}`)];
          } else f = se;
          if (se !== "number" && se !== "string" && se !== "boolean") return [new Ze(K.key, Se, "stop domain value must be a number, string, or boolean")];
          if (se !== "number" && h !== "categorical") {
            let et = `number expected, ${se} found`;
            return Mo(o) && h === void 0 && (et += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Ze(K.key, Se, et)];
          }
          return h !== "categorical" || se !== "number" || isFinite(Ee) && Math.floor(Ee) === Ee ? h !== "categorical" && se === "number" && _ !== void 0 && Ee < _ ? [new Ze(K.key, Se, "stop domain values must appear in ascending order")] : (_ = Ee, h === "categorical" && Ee in w ? [new Ze(K.key, Se, "stop domain values must be unique")] : (w[Ee] = !0, [])) : [new Ze(K.key, Se, `integer expected, found ${Ee}`)];
        }
      }
      function gl(d) {
        const o = (d.expressionContext === "property" ? to : $l)(Ql(d.value), d.valueSpec);
        if (o.result === "error") return o.value.map((f) => new Ze(`${d.key}${f.key}`, d.value, f.message));
        const h = o.value.expression || o.value._styleExpression.expression;
        if (d.expressionContext === "property" && d.propertyKey === "text-font" && !h.outputDefined()) return [new Ze(d.key, d.value, `Invalid data expression for "${d.propertyKey}". Output values must be contained as literals within the expression.`)];
        if (d.expressionContext === "property" && d.propertyType === "layout" && !Na(h)) return [new Ze(d.key, d.value, '"feature-state" data expressions are not supported with layout properties.')];
        if (d.expressionContext === "filter" && !Na(h)) return [new Ze(d.key, d.value, '"feature-state" data expressions are not supported with filters.')];
        if (d.expressionContext && d.expressionContext.indexOf("cluster") === 0) {
          if (!ma(h, ["zoom", "feature-state"])) return [new Ze(d.key, d.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
          if (d.expressionContext === "cluster-initial" && !Wl(h)) return [new Ze(d.key, d.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
        }
        return [];
      }
      function _a(d) {
        const o = d.key, h = d.value, f = d.valueSpec, _ = [];
        return Array.isArray(f.values) ? f.values.indexOf(sr(h)) === -1 && _.push(new Ze(o, h, `expected one of [${f.values.join(", ")}], ${JSON.stringify(h)} found`)) : Object.keys(f.values).indexOf(sr(h)) === -1 && _.push(new Ze(o, h, `expected one of [${Object.keys(f.values).join(", ")}], ${JSON.stringify(h)} found`)), _;
      }
      function Vu(d) {
        return Bc(Ql(d.value)) ? gl(an({}, d, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : pu(d);
      }
      function pu(d) {
        const o = d.value, h = d.key;
        if (oi(o) !== "array") return [new Ze(h, o, `array expected, ${oi(o)} found`)];
        const f = d.styleSpec;
        let _, v = [];
        if (o.length < 1) return [new Ze(h, o, "filter array must have at least 1 element")];
        switch (v = v.concat(_a({ key: `${h}[0]`, value: o[0], valueSpec: f.filter_operator, style: d.style, styleSpec: d.styleSpec })), sr(o[0])) {
          case "<":
          case "<=":
          case ">":
          case ">=":
            o.length >= 2 && sr(o[1]) === "$type" && v.push(new Ze(h, o, `"$type" cannot be use with operator "${o[0]}"`));
          case "==":
          case "!=":
            o.length !== 3 && v.push(new Ze(h, o, `filter array for operator "${o[0]}" must have 3 elements`));
          case "in":
          case "!in":
            o.length >= 2 && (_ = oi(o[1]), _ !== "string" && v.push(new Ze(`${h}[1]`, o[1], `string expected, ${_} found`)));
            for (let w = 2; w < o.length; w++) _ = oi(o[w]), sr(o[1]) === "$type" ? v = v.concat(_a({ key: `${h}[${w}]`, value: o[w], valueSpec: f.geometry_type, style: d.style, styleSpec: d.styleSpec })) : _ !== "string" && _ !== "number" && _ !== "boolean" && v.push(new Ze(`${h}[${w}]`, o[w], `string, number, or boolean expected, ${_} found`));
            break;
          case "any":
          case "all":
          case "none":
            for (let w = 1; w < o.length; w++) v = v.concat(pu({ key: `${h}[${w}]`, value: o[w], style: d.style, styleSpec: d.styleSpec }));
            break;
          case "has":
          case "!has":
            _ = oi(o[1]), o.length !== 2 ? v.push(new Ze(h, o, `filter array for "${o[0]}" operator must have 2 elements`)) : _ !== "string" && v.push(new Ze(`${h}[1]`, o[1], `string expected, ${_} found`));
        }
        return v;
      }
      function wh(d, o) {
        const h = d.key, f = d.validateSpec, _ = d.style, v = d.styleSpec, w = d.value, P = d.objectKey, R = v[`${o}_${d.layerType}`];
        if (!R) return [];
        const D = P.match(/^(.*)-transition$/);
        if (o === "paint" && D && R[D[1]] && R[D[1]].transition) return f({ key: h, value: w, valueSpec: v.transition, style: _, styleSpec: v });
        const z = d.valueSpec || R[P];
        if (!z) return [new Ze(h, w, `unknown property "${P}"`)];
        let j;
        if (oi(w) === "string" && Mo(z) && !z.tokens && (j = /^{([^}]+)}$/.exec(w))) return [new Ze(h, w, `"${P}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(j[1])} }\`.`)];
        const Y = [];
        return d.layerType === "symbol" && (P === "text-field" && _ && !_.glyphs && Y.push(new Ze(h, w, 'use of "text-field" requires a style "glyphs" property')), P === "text-font" && dl(Ql(w)) && sr(w.type) === "identity" && Y.push(new Ze(h, w, '"text-font" does not support identity functions'))), Y.concat(f({ key: d.key, value: w, valueSpec: z, style: _, styleSpec: v, expressionContext: "property", propertyType: o, propertyKey: P }));
      }
      function Ah(d) {
        return wh(d, "paint");
      }
      function Th(d) {
        return wh(d, "layout");
      }
      function ld(d) {
        let o = [];
        const h = d.value, f = d.key, _ = d.style, v = d.styleSpec;
        h.type || h.ref || o.push(new Ze(f, h, 'either "type" or "ref" is required'));
        let w = sr(h.type);
        const P = sr(h.ref);
        if (h.id) {
          const R = sr(h.id);
          for (let D = 0; D < d.arrayIndex; D++) {
            const z = _.layers[D];
            sr(z.id) === R && o.push(new Ze(f, h.id, `duplicate layer id "${h.id}", previously used at line ${z.id.__line__}`));
          }
        }
        if ("ref" in h) {
          let R;
          ["type", "source", "source-layer", "filter", "layout"].forEach((D) => {
            D in h && o.push(new Ze(f, h[D], `"${D}" is prohibited for ref layers`));
          }), _.layers.forEach((D) => {
            sr(D.id) === P && (R = D);
          }), R ? R.ref ? o.push(new Ze(f, h.ref, "ref cannot reference another ref layer")) : w = sr(R.type) : o.push(new Ze(f, h.ref, `ref layer "${P}" not found`));
        } else if (w !== "background") if (h.source) {
          const R = _.sources && _.sources[h.source], D = R && sr(R.type);
          R ? D === "vector" && w === "raster" ? o.push(new Ze(f, h.source, `layer "${h.id}" requires a raster source`)) : D !== "raster-dem" && w === "hillshade" ? o.push(new Ze(f, h.source, `layer "${h.id}" requires a raster-dem source`)) : D === "raster" && w !== "raster" ? o.push(new Ze(f, h.source, `layer "${h.id}" requires a vector source`)) : D !== "vector" || h["source-layer"] ? D === "raster-dem" && w !== "hillshade" ? o.push(new Ze(f, h.source, "raster-dem source can only be used with layer type 'hillshade'.")) : w !== "line" || !h.paint || !h.paint["line-gradient"] || D === "geojson" && R.lineMetrics || o.push(new Ze(f, h, `layer "${h.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : o.push(new Ze(f, h, `layer "${h.id}" must specify a "source-layer"`)) : o.push(new Ze(f, h.source, `source "${h.source}" not found`));
        } else o.push(new Ze(f, h, 'missing required property "source"'));
        return o = o.concat(Ro({ key: f, value: h, valueSpec: v.layer, style: d.style, styleSpec: d.styleSpec, validateSpec: d.validateSpec, objectElementValidators: { "*": () => [], type: () => d.validateSpec({ key: `${f}.type`, value: h.type, valueSpec: v.layer.type, style: d.style, styleSpec: d.styleSpec, validateSpec: d.validateSpec, object: h, objectKey: "type" }), filter: Vu, layout: (R) => Ro({ layer: h, key: R.key, value: R.value, style: R.style, styleSpec: R.styleSpec, validateSpec: R.validateSpec, objectElementValidators: { "*": (D) => Th(an({ layerType: w }, D)) } }), paint: (R) => Ro({ layer: h, key: R.key, value: R.value, style: R.style, styleSpec: R.styleSpec, validateSpec: R.validateSpec, objectElementValidators: { "*": (D) => Ah(an({ layerType: w }, D)) } }) } })), o;
      }
      function ml(d) {
        const o = d.value, h = d.key, f = oi(o);
        return f !== "string" ? [new Ze(h, o, `string expected, ${f} found`)] : [];
      }
      const ya = { promoteId: function(d) {
        let { key: o, value: h } = d;
        if (oi(h) === "string") return ml({ key: o, value: h });
        {
          const f = [];
          for (const _ in h) f.push(...ml({ key: `${o}.${_}`, value: h[_] }));
          return f;
        }
      } };
      function Ts(d) {
        const o = d.value, h = d.key, f = d.styleSpec, _ = d.style, v = d.validateSpec;
        if (!o.type) return [new Ze(h, o, '"type" is required')];
        const w = sr(o.type);
        let P;
        switch (w) {
          case "vector":
          case "raster":
            return P = Ro({ key: h, value: o, valueSpec: f[`source_${w.replace("-", "_")}`], style: d.style, styleSpec: f, objectElementValidators: ya, validateSpec: v }), P;
          case "raster-dem":
            return P = function(R) {
              var D;
              const z = (D = R.sourceName) !== null && D !== void 0 ? D : "", j = R.value, Y = R.styleSpec, K = Y.source_raster_dem, Q = R.style;
              let se = [];
              const Ee = oi(j);
              if (j === void 0) return se;
              if (Ee !== "object") return se.push(new Ze("source_raster_dem", j, `object expected, ${Ee} found`)), se;
              const Se = sr(j.encoding) === "custom", et = ["redFactor", "greenFactor", "blueFactor", "baseShift"], Ne = R.value.encoding ? `"${R.value.encoding}"` : "Default";
              for (const J in j) !Se && et.includes(J) ? se.push(new Ze(J, j[J], `In "${z}": "${J}" is only valid when "encoding" is set to "custom". ${Ne} encoding found`)) : K[J] ? se = se.concat(R.validateSpec({ key: J, value: j[J], valueSpec: K[J], validateSpec: R.validateSpec, style: Q, styleSpec: Y })) : se.push(new Ze(J, j[J], `unknown property "${J}"`));
              return se;
            }({ sourceName: h, value: o, style: d.style, styleSpec: f, validateSpec: v }), P;
          case "geojson":
            if (P = Ro({ key: h, value: o, valueSpec: f.source_geojson, style: _, styleSpec: f, validateSpec: v, objectElementValidators: ya }), o.cluster) for (const R in o.clusterProperties) {
              const [D, z] = o.clusterProperties[R], j = typeof D == "string" ? [D, ["accumulated"], ["get", R]] : D;
              P.push(...gl({ key: `${h}.${R}.map`, value: z, expressionContext: "cluster-map" })), P.push(...gl({ key: `${h}.${R}.reduce`, value: j, expressionContext: "cluster-reduce" }));
            }
            return P;
          case "video":
            return Ro({ key: h, value: o, valueSpec: f.source_video, style: _, validateSpec: v, styleSpec: f });
          case "image":
            return Ro({ key: h, value: o, valueSpec: f.source_image, style: _, validateSpec: v, styleSpec: f });
          case "canvas":
            return [new Ze(h, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
          default:
            return _a({ key: `${h}.type`, value: o.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] } });
        }
      }
      function ba(d) {
        const o = d.value, h = d.styleSpec, f = h.light, _ = d.style;
        let v = [];
        const w = oi(o);
        if (o === void 0) return v;
        if (w !== "object") return v = v.concat([new Ze("light", o, `object expected, ${w} found`)]), v;
        for (const P in o) {
          const R = P.match(/^(.*)-transition$/);
          v = v.concat(R && f[R[1]] && f[R[1]].transition ? d.validateSpec({ key: P, value: o[P], valueSpec: h.transition, validateSpec: d.validateSpec, style: _, styleSpec: h }) : f[P] ? d.validateSpec({ key: P, value: o[P], valueSpec: f[P], validateSpec: d.validateSpec, style: _, styleSpec: h }) : [new Ze(P, o[P], `unknown property "${P}"`)]);
        }
        return v;
      }
      function cd(d) {
        const o = d.value, h = d.styleSpec, f = h.sky, _ = d.style, v = oi(o);
        if (o === void 0) return [];
        if (v !== "object") return [new Ze("sky", o, `object expected, ${v} found`)];
        let w = [];
        for (const P in o) w = w.concat(f[P] ? d.validateSpec({ key: P, value: o[P], valueSpec: f[P], style: _, styleSpec: h }) : [new Ze(P, o[P], `unknown property "${P}"`)]);
        return w;
      }
      function Eh(d) {
        const o = d.value, h = d.styleSpec, f = h.terrain, _ = d.style;
        let v = [];
        const w = oi(o);
        if (o === void 0) return v;
        if (w !== "object") return v = v.concat([new Ze("terrain", o, `object expected, ${w} found`)]), v;
        for (const P in o) v = v.concat(f[P] ? d.validateSpec({ key: P, value: o[P], valueSpec: f[P], validateSpec: d.validateSpec, style: _, styleSpec: h }) : [new Ze(P, o[P], `unknown property "${P}"`)]);
        return v;
      }
      function ja(d) {
        let o = [];
        const h = d.value, f = d.key;
        if (Array.isArray(h)) {
          const _ = [], v = [];
          for (const w in h) h[w].id && _.includes(h[w].id) && o.push(new Ze(f, h, `all the sprites' ids must be unique, but ${h[w].id} is duplicated`)), _.push(h[w].id), h[w].url && v.includes(h[w].url) && o.push(new Ze(f, h, `all the sprites' URLs must be unique, but ${h[w].url} is duplicated`)), v.push(h[w].url), o = o.concat(Ro({ key: `${f}[${w}]`, value: h[w], valueSpec: { id: { type: "string", required: !0 }, url: { type: "string", required: !0 } }, validateSpec: d.validateSpec }));
          return o;
        }
        return ml({ key: f, value: h });
      }
      const _o = { "*": () => [], array: vh, boolean: function(d) {
        const o = d.value, h = d.key, f = oi(o);
        return f !== "boolean" ? [new Ze(h, o, `boolean expected, ${f} found`)] : [];
      }, number: xh, color: function(d) {
        const o = d.key, h = d.value, f = oi(h);
        return f !== "string" ? [new Ze(o, h, `color expected, ${f} found`)] : Qn.parse(String(h)) ? [] : [new Ze(o, h, `color expected, "${h}" found`)];
      }, constants: fu, enum: _a, filter: Vu, function: Gu, layer: ld, object: Ro, source: Ts, light: ba, sky: cd, terrain: Eh, projection: function(d) {
        const o = d.value, h = d.styleSpec, f = h.projection, _ = d.style, v = oi(o);
        if (o === void 0) return [];
        if (v !== "object") return [new Ze("projection", o, `object expected, ${v} found`)];
        let w = [];
        for (const P in o) w = w.concat(f[P] ? d.validateSpec({ key: P, value: o[P], valueSpec: f[P], style: _, styleSpec: h }) : [new Ze(P, o[P], `unknown property "${P}"`)]);
        return w;
      }, projectionDefinition: function(d) {
        const o = d.key;
        let h = d.value;
        h = h instanceof String ? h.valueOf() : h;
        const f = oi(h);
        return f !== "array" || function(_) {
          return Array.isArray(_) && _.length === 3 && typeof _[0] == "string" && typeof _[1] == "string" && typeof _[2] == "number";
        }(h) || function(_) {
          return !!["interpolate", "step", "literal"].includes(_[0]);
        }(h) ? ["array", "string"].includes(f) ? [] : [new Ze(o, h, `projection expected, invalid type "${f}" found`)] : [new Ze(o, h, `projection expected, invalid array ${JSON.stringify(h)} found`)];
      }, string: ml, formatted: function(d) {
        return ml(d).length === 0 ? [] : gl(d);
      }, resolvedImage: function(d) {
        return ml(d).length === 0 ? [] : gl(d);
      }, padding: function(d) {
        const o = d.key, h = d.value;
        if (oi(h) === "array") {
          if (h.length < 1 || h.length > 4) return [new Ze(o, h, `padding requires 1 to 4 values; ${h.length} values found`)];
          const f = { type: "number" };
          let _ = [];
          for (let v = 0; v < h.length; v++) _ = _.concat(d.validateSpec({ key: `${o}[${v}]`, value: h[v], validateSpec: d.validateSpec, valueSpec: f }));
          return _;
        }
        return xh({ key: o, value: h, valueSpec: {} });
      }, variableAnchorOffsetCollection: function(d) {
        const o = d.key, h = d.value, f = oi(h), _ = d.styleSpec;
        if (f !== "array" || h.length < 1 || h.length % 2 != 0) return [new Ze(o, h, "variableAnchorOffsetCollection requires a non-empty array of even length")];
        let v = [];
        for (let w = 0; w < h.length; w += 2) v = v.concat(_a({ key: `${o}[${w}]`, value: h[w], valueSpec: _.layout_symbol["text-anchor"] })), v = v.concat(vh({ key: `${o}[${w + 1}]`, value: h[w + 1], valueSpec: { length: 2, value: "number" }, validateSpec: d.validateSpec, style: d.style, styleSpec: _ }));
        return v;
      }, sprite: ja };
      function qu(d) {
        const o = d.value, h = d.valueSpec, f = d.styleSpec;
        return d.validateSpec = qu, h.expression && dl(sr(o)) ? Gu(d) : h.expression && Ua(Ql(o)) ? gl(d) : h.type && _o[h.type] ? _o[h.type](d) : Ro(an({}, d, { valueSpec: h.type ? f[h.type] : h }));
      }
      function Fc(d) {
        const o = d.value, h = d.key, f = ml(d);
        return f.length || (o.indexOf("{fontstack}") === -1 && f.push(new Ze(h, o, '"glyphs" url must include a "{fontstack}" token')), o.indexOf("{range}") === -1 && f.push(new Ze(h, o, '"glyphs" url must include a "{range}" token'))), f;
      }
      function Es(d) {
        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : be, h = [];
        return h = h.concat(qu({ key: "", value: d, valueSpec: o.$root, styleSpec: o, style: d, validateSpec: qu, objectElementValidators: { glyphs: Fc, "*": () => [] } })), d.constants && (h = h.concat(fu({ key: "constants", value: d.constants }))), ec(h);
      }
      function pr(d) {
        return function(o) {
          return d({ ...o, validateSpec: qu });
        };
      }
      function ec(d) {
        return [].concat(d).sort((o, h) => o.line - h.line);
      }
      function Bo(d) {
        return function() {
          for (var o = arguments.length, h = new Array(o), f = 0; f < o; f++)
            h[f] = arguments[f];
          return ec(d.apply(this, h));
        };
      }
      Es.source = Bo(pr(Ts)), Es.sprite = Bo(pr(ja)), Es.glyphs = Bo(pr(Fc)), Es.light = Bo(pr(ba)), Es.sky = Bo(pr(cd)), Es.terrain = Bo(pr(Eh)), Es.layer = Bo(pr(ld)), Es.filter = Bo(pr(Vu)), Es.paintProperty = Bo(pr(Ah)), Es.layoutProperty = Bo(pr(Th));
      const Nc = Es, Hu = Nc.light, _l = Nc.sky, kc = Nc.paintProperty, gu = Nc.layoutProperty;
      function ud(d, o) {
        let h = !1;
        if (o && o.length) for (const f of o) d.fire(new pi(new Error(f.message))), h = !0;
        return h;
      }
      class yl {
        constructor(o, h, f) {
          const _ = this.cells = [];
          if (o instanceof ArrayBuffer) {
            this.arrayBuffer = o;
            const w = new Int32Array(this.arrayBuffer);
            o = w[0], this.d = (h = w[1]) + 2 * (f = w[2]);
            for (let R = 0; R < this.d * this.d; R++) {
              const D = w[3 + R], z = w[3 + R + 1];
              _.push(D === z ? null : w.subarray(D, z));
            }
            const P = w[3 + _.length + 1];
            this.keys = w.subarray(w[3 + _.length], P), this.bboxes = w.subarray(P), this.insert = this._insertReadonly;
          } else {
            this.d = h + 2 * f;
            for (let w = 0; w < this.d * this.d; w++) _.push([]);
            this.keys = [], this.bboxes = [];
          }
          this.n = h, this.extent = o, this.padding = f, this.scale = h / o, this.uid = 0;
          const v = f / h * o;
          this.min = -v, this.max = o + v;
        }
        insert(o, h, f, _, v) {
          this._forEachCell(h, f, _, v, this._insertCell, this.uid++, void 0, void 0), this.keys.push(o), this.bboxes.push(h), this.bboxes.push(f), this.bboxes.push(_), this.bboxes.push(v);
        }
        _insertReadonly() {
          throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
        }
        _insertCell(o, h, f, _, v, w) {
          this.cells[v].push(w);
        }
        query(o, h, f, _, v) {
          const w = this.min, P = this.max;
          if (o <= w && h <= w && P <= f && P <= _ && !v) return Array.prototype.slice.call(this.keys);
          {
            const R = [];
            return this._forEachCell(o, h, f, _, this._queryCell, R, {}, v), R;
          }
        }
        _queryCell(o, h, f, _, v, w, P, R) {
          const D = this.cells[v];
          if (D !== null) {
            const z = this.keys, j = this.bboxes;
            for (let Y = 0; Y < D.length; Y++) {
              const K = D[Y];
              if (P[K] === void 0) {
                const Q = 4 * K;
                (R ? R(j[Q + 0], j[Q + 1], j[Q + 2], j[Q + 3]) : o <= j[Q + 2] && h <= j[Q + 3] && f >= j[Q + 0] && _ >= j[Q + 1]) ? (P[K] = !0, w.push(z[K])) : P[K] = !1;
              }
            }
          }
        }
        _forEachCell(o, h, f, _, v, w, P, R) {
          const D = this._convertToCellCoord(o), z = this._convertToCellCoord(h), j = this._convertToCellCoord(f), Y = this._convertToCellCoord(_);
          for (let K = D; K <= j; K++) for (let Q = z; Q <= Y; Q++) {
            const se = this.d * Q + K;
            if ((!R || R(this._convertFromCellCoord(K), this._convertFromCellCoord(Q), this._convertFromCellCoord(K + 1), this._convertFromCellCoord(Q + 1))) && v.call(this, o, h, f, _, se, w, P, R)) return;
          }
        }
        _convertFromCellCoord(o) {
          return (o - this.padding) / this.scale;
        }
        _convertToCellCoord(o) {
          return Math.max(0, Math.min(this.d - 1, Math.floor(o * this.scale) + this.padding));
        }
        toArrayBuffer() {
          if (this.arrayBuffer) return this.arrayBuffer;
          const o = this.cells, h = 3 + this.cells.length + 1 + 1;
          let f = 0;
          for (let w = 0; w < this.cells.length; w++) f += this.cells[w].length;
          const _ = new Int32Array(h + f + this.keys.length + this.bboxes.length);
          _[0] = this.extent, _[1] = this.n, _[2] = this.padding;
          let v = h;
          for (let w = 0; w < o.length; w++) {
            const P = o[w];
            _[3 + w] = v, _.set(P, v), v += P.length;
          }
          return _[3 + o.length] = v, _.set(this.keys, v), v += this.keys.length, _[3 + o.length + 1] = v, _.set(this.bboxes, v), v += this.bboxes.length, _.buffer;
        }
        static serialize(o, h) {
          const f = o.toArrayBuffer();
          return h && h.push(f), { buffer: f };
        }
        static deserialize(o) {
          return new yl(o.buffer);
        }
      }
      const Ga = {};
      function vn(d, o) {
        let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        if (Ga[d]) throw new Error(`${d} is already registered.`);
        Object.defineProperty(o, "_classRegistryKey", { value: d, writeable: !1 }), Ga[d] = { klass: o, omit: h.omit || [], shallow: h.shallow || [] };
      }
      vn("Object", Object), vn("TransferableGridIndex", yl), vn("Color", Qn), vn("Error", Error), vn("AJAXError", Yn), vn("ResolvedImage", Rn), vn("StylePropertyFunction", Ds), vn("StyleExpression", fl, { omit: ["_evaluator"] }), vn("ZoomDependentExpression", Xl), vn("ZoomConstantExpression", pl), vn("CompoundExpression", Fr, { omit: ["_evaluate"] });
      for (const d in ta) ta[d]._classRegistryKey || vn(`Expression_${d}`, ta[d]);
      function hd(d) {
        return d && typeof ArrayBuffer < "u" && (d instanceof ArrayBuffer || d.constructor && d.constructor.name === "ArrayBuffer");
      }
      function tc(d) {
        return d.$name || d.constructor._classRegistryKey;
      }
      function dd(d) {
        return !function(o) {
          if (o === null || typeof o != "object") return !1;
          const h = tc(o);
          return !(!h || h === "Object");
        }(d) && (d == null || typeof d == "boolean" || typeof d == "number" || typeof d == "string" || d instanceof Boolean || d instanceof Number || d instanceof String || d instanceof Date || d instanceof RegExp || d instanceof Blob || d instanceof Error || hd(d) || Bt(d) || ArrayBuffer.isView(d) || d instanceof ImageData);
      }
      function mu(d, o) {
        if (dd(d)) return (hd(d) || Bt(d)) && o && o.push(d), ArrayBuffer.isView(d) && o && o.push(d.buffer), d instanceof ImageData && o && o.push(d.data.buffer), d;
        if (Array.isArray(d)) {
          const v = [];
          for (const w of d) v.push(mu(w, o));
          return v;
        }
        if (typeof d != "object") throw new Error("can't serialize object of type " + typeof d);
        const h = tc(d);
        if (!h) throw new Error(`can't serialize object of unregistered class ${d.constructor.name}`);
        if (!Ga[h]) throw new Error(`${h} is not registered.`);
        const { klass: f } = Ga[h], _ = f.serialize ? f.serialize(d, o) : {};
        if (f.serialize) {
          if (o && _ === o[o.length - 1]) throw new Error("statically serialized object won't survive transfer of $name property");
        } else {
          for (const v in d) {
            if (!d.hasOwnProperty(v) || Ga[h].omit.indexOf(v) >= 0) continue;
            const w = d[v];
            _[v] = Ga[h].shallow.indexOf(v) >= 0 ? w : mu(w, o);
          }
          d instanceof Error && (_.message = d.message);
        }
        if (_.$name) throw new Error("$name property is reserved for worker serialization logic.");
        return h !== "Object" && (_.$name = h), _;
      }
      function Va(d) {
        if (dd(d)) return d;
        if (Array.isArray(d)) return d.map(Va);
        if (typeof d != "object") throw new Error("can't deserialize object of type " + typeof d);
        const o = tc(d) || "Object";
        if (!Ga[o]) throw new Error(`can't deserialize unregistered class ${o}`);
        const { klass: h } = Ga[o];
        if (!h) throw new Error(`can't deserialize unregistered class ${o}`);
        if (h.deserialize) return h.deserialize(d);
        const f = Object.create(h.prototype);
        for (const _ of Object.keys(d)) {
          if (_ === "$name") continue;
          const v = d[_];
          f[_] = Ga[o].shallow.indexOf(_) >= 0 ? v : Va(v);
        }
        return f;
      }
      class _u {
        constructor() {
          this.first = !0;
        }
        update(o, h) {
          const f = Math.floor(o);
          return this.first ? (this.first = !1, this.lastIntegerZoom = f, this.lastIntegerZoomTime = 0, this.lastZoom = o, this.lastFloorZoom = f, !0) : (this.lastFloorZoom > f ? (this.lastIntegerZoom = f + 1, this.lastIntegerZoomTime = h) : this.lastFloorZoom < f && (this.lastIntegerZoom = f, this.lastIntegerZoomTime = h), o !== this.lastZoom && (this.lastZoom = o, this.lastFloorZoom = f, !0));
        }
      }
      const ci = { "Latin-1 Supplement": (d) => d >= 128 && d <= 255, "Hangul Jamo": (d) => d >= 4352 && d <= 4607, Khmer: (d) => d >= 6016 && d <= 6143, "General Punctuation": (d) => d >= 8192 && d <= 8303, "Letterlike Symbols": (d) => d >= 8448 && d <= 8527, "Number Forms": (d) => d >= 8528 && d <= 8591, "Miscellaneous Technical": (d) => d >= 8960 && d <= 9215, "Control Pictures": (d) => d >= 9216 && d <= 9279, "Optical Character Recognition": (d) => d >= 9280 && d <= 9311, "Enclosed Alphanumerics": (d) => d >= 9312 && d <= 9471, "Geometric Shapes": (d) => d >= 9632 && d <= 9727, "Miscellaneous Symbols": (d) => d >= 9728 && d <= 9983, "Miscellaneous Symbols and Arrows": (d) => d >= 11008 && d <= 11263, "Ideographic Description Characters": (d) => d >= 12272 && d <= 12287, "CJK Symbols and Punctuation": (d) => d >= 12288 && d <= 12351, Hiragana: (d) => d >= 12352 && d <= 12447, Katakana: (d) => d >= 12448 && d <= 12543, Kanbun: (d) => d >= 12688 && d <= 12703, "CJK Strokes": (d) => d >= 12736 && d <= 12783, "Enclosed CJK Letters and Months": (d) => d >= 12800 && d <= 13055, "CJK Compatibility": (d) => d >= 13056 && d <= 13311, "Yijing Hexagram Symbols": (d) => d >= 19904 && d <= 19967, "CJK Unified Ideographs": (d) => d >= 19968 && d <= 40959, "Hangul Syllables": (d) => d >= 44032 && d <= 55215, "Private Use Area": (d) => d >= 57344 && d <= 63743, "Vertical Forms": (d) => d >= 65040 && d <= 65055, "CJK Compatibility Forms": (d) => d >= 65072 && d <= 65103, "Small Form Variants": (d) => d >= 65104 && d <= 65135, "Halfwidth and Fullwidth Forms": (d) => d >= 65280 && d <= 65519 };
      function zc(d) {
        for (const o of d) if (ee(o.charCodeAt(0))) return !0;
        return !1;
      }
      function Sh(d) {
        for (const o of d) if (!k(o.charCodeAt(0))) return !1;
        return !0;
      }
      function T(d) {
        const o = d.map((h) => {
          try {
            return new RegExp(`\\p{sc=${h}}`, "u").source;
          } catch {
            return null;
          }
        }).filter((h) => h);
        return new RegExp(o.join("|"), "u");
      }
      const M = T(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
      function k(d) {
        return !M.test(String.fromCodePoint(d));
      }
      const q = T(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
      function ee(d) {
        return !(d !== 746 && d !== 747 && (d < 4352 || !(ci["CJK Compatibility Forms"](d) && !(d >= 65097 && d <= 65103) || ci["CJK Compatibility"](d) || ci["CJK Strokes"](d) || !(!ci["CJK Symbols and Punctuation"](d) || d >= 12296 && d <= 12305 || d >= 12308 && d <= 12319 || d === 12336) || ci["Enclosed CJK Letters and Months"](d) || ci["Ideographic Description Characters"](d) || ci.Kanbun(d) || ci.Katakana(d) && d !== 12540 || !(!ci["Halfwidth and Fullwidth Forms"](d) || d === 65288 || d === 65289 || d === 65293 || d >= 65306 && d <= 65310 || d === 65339 || d === 65341 || d === 65343 || d >= 65371 && d <= 65503 || d === 65507 || d >= 65512 && d <= 65519) || !(!ci["Small Form Variants"](d) || d >= 65112 && d <= 65118 || d >= 65123 && d <= 65126) || ci["Vertical Forms"](d) || ci["Yijing Hexagram Symbols"](d) || new RegExp("\\p{sc=Cans}", "u").test(String.fromCodePoint(d)) || new RegExp("\\p{sc=Hang}", "u").test(String.fromCodePoint(d)) || q.test(String.fromCodePoint(d)))));
      }
      function le(d) {
        return !(ee(d) || function(o) {
          return !!(ci["Latin-1 Supplement"](o) && (o === 167 || o === 169 || o === 174 || o === 177 || o === 188 || o === 189 || o === 190 || o === 215 || o === 247) || ci["General Punctuation"](o) && (o === 8214 || o === 8224 || o === 8225 || o === 8240 || o === 8241 || o === 8251 || o === 8252 || o === 8258 || o === 8263 || o === 8264 || o === 8265 || o === 8273) || ci["Letterlike Symbols"](o) || ci["Number Forms"](o) || ci["Miscellaneous Technical"](o) && (o >= 8960 && o <= 8967 || o >= 8972 && o <= 8991 || o >= 8996 && o <= 9e3 || o === 9003 || o >= 9085 && o <= 9114 || o >= 9150 && o <= 9165 || o === 9167 || o >= 9169 && o <= 9179 || o >= 9186 && o <= 9215) || ci["Control Pictures"](o) && o !== 9251 || ci["Optical Character Recognition"](o) || ci["Enclosed Alphanumerics"](o) || ci["Geometric Shapes"](o) || ci["Miscellaneous Symbols"](o) && !(o >= 9754 && o <= 9759) || ci["Miscellaneous Symbols and Arrows"](o) && (o >= 11026 && o <= 11055 || o >= 11088 && o <= 11097 || o >= 11192 && o <= 11243) || ci["CJK Symbols and Punctuation"](o) || ci.Katakana(o) || ci["Private Use Area"](o) || ci["CJK Compatibility Forms"](o) || ci["Small Form Variants"](o) || ci["Halfwidth and Fullwidth Forms"](o) || o === 8734 || o === 8756 || o === 8757 || o >= 9984 && o <= 10087 || o >= 10102 && o <= 10131 || o === 65532 || o === 65533);
        }(d));
      }
      const he = T(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
      function ye(d) {
        return he.test(String.fromCodePoint(d));
      }
      function xe(d, o) {
        return !(!o && ye(d) || d >= 2304 && d <= 3583 || d >= 3840 && d <= 4255 || ci.Khmer(d));
      }
      function Le(d) {
        for (const o of d) if (ye(o.charCodeAt(0))) return !0;
        return !1;
      }
      const tt = new class {
        constructor() {
          this.TIMEOUT = 5e3, this.applyArabicShaping = null, this.processBidirectionalText = null, this.processStyledBidirectionalText = null, this.pluginStatus = "unavailable", this.pluginURL = null, this.loadScriptResolve = () => {
          };
        }
        setState(d) {
          this.pluginStatus = d.pluginStatus, this.pluginURL = d.pluginURL;
        }
        getState() {
          return { pluginStatus: this.pluginStatus, pluginURL: this.pluginURL };
        }
        setMethods(d) {
          if (tt.isParsed()) throw new Error("RTL text plugin already registered.");
          this.applyArabicShaping = d.applyArabicShaping, this.processBidirectionalText = d.processBidirectionalText, this.processStyledBidirectionalText = d.processStyledBidirectionalText, this.loadScriptResolve();
        }
        isParsed() {
          return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null;
        }
        getRTLTextPluginStatus() {
          return this.pluginStatus;
        }
        syncState(d, o) {
          return a(this, void 0, void 0, function* () {
            if (this.isParsed()) return this.getState();
            if (d.pluginStatus !== "loading") return this.setState(d), d;
            const h = d.pluginURL, f = new Promise((v) => {
              this.loadScriptResolve = v;
            });
            o(h);
            const _ = new Promise((v) => setTimeout(() => v(), this.TIMEOUT));
            if (yield Promise.race([f, _]), this.isParsed()) {
              const v = { pluginStatus: "loaded", pluginURL: h };
              return this.setState(v), v;
            }
            throw this.setState({ pluginStatus: "error", pluginURL: "" }), new Error(`RTL Text Plugin failed to import scripts from ${h}`);
          });
        }
      }();
      class ut {
        constructor(o, h) {
          this.zoom = o, h ? (this.now = h.now, this.fadeDuration = h.fadeDuration, this.zoomHistory = h.zoomHistory, this.transition = h.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new _u(), this.transition = {});
        }
        isSupportedScript(o) {
          return function(h, f) {
            for (const _ of h) if (!xe(_.charCodeAt(0), f)) return !1;
            return !0;
          }(o, tt.getRTLTextPluginStatus() === "loaded");
        }
        crossFadingFactor() {
          return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
        }
        getCrossfadeParameters() {
          const o = this.zoom, h = o - Math.floor(o), f = this.crossFadingFactor();
          return o > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: h + (1 - h) * f } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - f) * h };
        }
      }
      class At {
        constructor(o, h) {
          this.property = o, this.value = h, this.expression = function(f, _) {
            if (dl(f)) return new Ds(f, _);
            if (Ua(f)) {
              const v = to(f, _);
              if (v.result === "error") throw new Error(v.value.map((w) => `${w.key}: ${w.message}`).join(", "));
              return v.value;
            }
            {
              let v = f;
              return _.type === "color" && typeof f == "string" ? v = Qn.parse(f) : _.type !== "padding" || typeof f != "number" && !Array.isArray(f) ? _.type === "variableAnchorOffsetCollection" && Array.isArray(f) ? v = gn.parse(f) : _.type === "projectionDefinition" && typeof f == "string" && (v = hi.parse(f)) : v = Ve.parse(f), { kind: "constant", evaluate: () => v };
            }
          }(h === void 0 ? o.specification.default : h, o.specification);
        }
        isDataDriven() {
          return this.expression.kind === "source" || this.expression.kind === "composite";
        }
        possiblyEvaluate(o, h, f) {
          return this.property.possiblyEvaluate(this, o, h, f);
        }
      }
      class ct {
        constructor(o) {
          this.property = o, this.value = new At(o, void 0);
        }
        transitioned(o, h) {
          return new Ot(this.property, this.value, h, Xe({}, o.transition, this.transition), o.now);
        }
        untransitioned() {
          return new Ot(this.property, this.value, null, {}, 0);
        }
      }
      class qt {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultTransitionablePropertyValues);
        }
        getValue(o) {
          return ht(this._values[o].value.value);
        }
        setValue(o, h) {
          Object.prototype.hasOwnProperty.call(this._values, o) || (this._values[o] = new ct(this._values[o].property)), this._values[o].value = new At(this._values[o].property, h === null ? void 0 : ht(h));
        }
        getTransition(o) {
          return ht(this._values[o].transition);
        }
        setTransition(o, h) {
          Object.prototype.hasOwnProperty.call(this._values, o) || (this._values[o] = new ct(this._values[o].property)), this._values[o].transition = ht(h) || void 0;
        }
        serialize() {
          const o = {};
          for (const h of Object.keys(this._values)) {
            const f = this.getValue(h);
            f !== void 0 && (o[h] = f);
            const _ = this.getTransition(h);
            _ !== void 0 && (o[`${h}-transition`] = _);
          }
          return o;
        }
        transitioned(o, h) {
          const f = new nt(this._properties);
          for (const _ of Object.keys(this._values)) f._values[_] = this._values[_].transitioned(o, h._values[_]);
          return f;
        }
        untransitioned() {
          const o = new nt(this._properties);
          for (const h of Object.keys(this._values)) o._values[h] = this._values[h].untransitioned();
          return o;
        }
      }
      class Ot {
        constructor(o, h, f, _, v) {
          this.property = o, this.value = h, this.begin = v + _.delay || 0, this.end = this.begin + _.duration || 0, o.specification.transition && (_.delay || _.duration) && (this.prior = f);
        }
        possiblyEvaluate(o, h, f) {
          const _ = o.now || 0, v = this.value.possiblyEvaluate(o, h, f), w = this.prior;
          if (w) {
            if (_ > this.end) return this.prior = null, v;
            if (this.value.isDataDriven()) return this.prior = null, v;
            if (_ < this.begin) return w.possiblyEvaluate(o, h, f);
            {
              const P = (_ - this.begin) / (this.end - this.begin);
              return this.property.interpolate(w.possiblyEvaluate(o, h, f), v, Ft(P));
            }
          }
          return v;
        }
      }
      class nt {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultTransitioningPropertyValues);
        }
        possiblyEvaluate(o, h, f) {
          const _ = new Zt(this._properties);
          for (const v of Object.keys(this._values)) _._values[v] = this._values[v].possiblyEvaluate(o, h, f);
          return _;
        }
        hasTransition() {
          for (const o of Object.keys(this._values)) if (this._values[o].prior) return !0;
          return !1;
        }
      }
      class st {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultPropertyValues);
        }
        hasValue(o) {
          return this._values[o].value !== void 0;
        }
        getValue(o) {
          return ht(this._values[o].value);
        }
        setValue(o, h) {
          this._values[o] = new At(this._values[o].property, h === null ? void 0 : ht(h));
        }
        serialize() {
          const o = {};
          for (const h of Object.keys(this._values)) {
            const f = this.getValue(h);
            f !== void 0 && (o[h] = f);
          }
          return o;
        }
        possiblyEvaluate(o, h, f) {
          const _ = new Zt(this._properties);
          for (const v of Object.keys(this._values)) _._values[v] = this._values[v].possiblyEvaluate(o, h, f);
          return _;
        }
      }
      class jt {
        constructor(o, h, f) {
          this.property = o, this.value = h, this.parameters = f;
        }
        isConstant() {
          return this.value.kind === "constant";
        }
        constantOr(o) {
          return this.value.kind === "constant" ? this.value.value : o;
        }
        evaluate(o, h, f, _) {
          return this.property.evaluate(this.value, this.parameters, o, h, f, _);
        }
      }
      class Zt {
        constructor(o) {
          this._properties = o, this._values = Object.create(o.defaultPossiblyEvaluatedValues);
        }
        get(o) {
          return this._values[o];
        }
      }
      class ft {
        constructor(o) {
          this.specification = o;
        }
        possiblyEvaluate(o, h) {
          if (o.isDataDriven()) throw new Error("Value should not be data driven");
          return o.expression.evaluate(h);
        }
        interpolate(o, h, f) {
          const _ = fo[this.specification.type];
          return _ ? _(o, h, f) : o;
        }
      }
      class Ut {
        constructor(o, h) {
          this.specification = o, this.overrides = h;
        }
        possiblyEvaluate(o, h, f, _) {
          return new jt(this, o.expression.kind === "constant" || o.expression.kind === "camera" ? { kind: "constant", value: o.expression.evaluate(h, null, {}, f, _) } : o.expression, h);
        }
        interpolate(o, h, f) {
          if (o.value.kind !== "constant" || h.value.kind !== "constant") return o;
          if (o.value.value === void 0 || h.value.value === void 0) return new jt(this, { kind: "constant", value: void 0 }, o.parameters);
          const _ = fo[this.specification.type];
          if (_) {
            const v = _(o.value.value, h.value.value, f);
            return new jt(this, { kind: "constant", value: v }, o.parameters);
          }
          return o;
        }
        evaluate(o, h, f, _, v, w) {
          return o.kind === "constant" ? o.value : o.evaluate(h, f, _, v, w);
        }
      }
      class yn extends Ut {
        possiblyEvaluate(o, h, f, _) {
          if (o.value === void 0) return new jt(this, { kind: "constant", value: void 0 }, h);
          if (o.expression.kind === "constant") {
            const v = o.expression.evaluate(h, null, {}, f, _), w = o.property.specification.type === "resolvedImage" && typeof v != "string" ? v.name : v, P = this._calculate(w, w, w, h);
            return new jt(this, { kind: "constant", value: P }, h);
          }
          if (o.expression.kind === "camera") {
            const v = this._calculate(o.expression.evaluate({ zoom: h.zoom - 1 }), o.expression.evaluate({ zoom: h.zoom }), o.expression.evaluate({ zoom: h.zoom + 1 }), h);
            return new jt(this, { kind: "constant", value: v }, h);
          }
          return new jt(this, o.expression, h);
        }
        evaluate(o, h, f, _, v, w) {
          if (o.kind === "source") {
            const P = o.evaluate(h, f, _, v, w);
            return this._calculate(P, P, P, h);
          }
          return o.kind === "composite" ? this._calculate(o.evaluate({ zoom: Math.floor(h.zoom) - 1 }, f, _), o.evaluate({ zoom: Math.floor(h.zoom) }, f, _), o.evaluate({ zoom: Math.floor(h.zoom) + 1 }, f, _), h) : o.value;
        }
        _calculate(o, h, f, _) {
          return _.zoom > _.zoomHistory.lastIntegerZoom ? { from: o, to: h } : { from: f, to: h };
        }
        interpolate(o) {
          return o;
        }
      }
      class jn {
        constructor(o) {
          this.specification = o;
        }
        possiblyEvaluate(o, h, f, _) {
          if (o.value !== void 0) {
            if (o.expression.kind === "constant") {
              const v = o.expression.evaluate(h, null, {}, f, _);
              return this._calculate(v, v, v, h);
            }
            return this._calculate(o.expression.evaluate(new ut(Math.floor(h.zoom - 1), h)), o.expression.evaluate(new ut(Math.floor(h.zoom), h)), o.expression.evaluate(new ut(Math.floor(h.zoom + 1), h)), h);
          }
        }
        _calculate(o, h, f, _) {
          return _.zoom > _.zoomHistory.lastIntegerZoom ? { from: o, to: h } : { from: f, to: h };
        }
        interpolate(o) {
          return o;
        }
      }
      class xn {
        constructor(o) {
          this.specification = o;
        }
        possiblyEvaluate(o, h, f, _) {
          return !!o.expression.evaluate(h, null, {}, f, _);
        }
        interpolate() {
          return !1;
        }
      }
      class ri {
        constructor(o) {
          this.properties = o, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
          for (const h in o) {
            const f = o[h];
            f.specification.overridable && this.overridableProperties.push(h);
            const _ = this.defaultPropertyValues[h] = new At(f, void 0), v = this.defaultTransitionablePropertyValues[h] = new ct(f);
            this.defaultTransitioningPropertyValues[h] = v.untransitioned(), this.defaultPossiblyEvaluatedValues[h] = _.possiblyEvaluate({});
          }
        }
      }
      vn("DataDrivenProperty", Ut), vn("DataConstantProperty", ft), vn("CrossFadedDataDrivenProperty", yn), vn("CrossFadedProperty", jn), vn("ColorRampProperty", xn);
      const Fi = "-transition";
      class ai extends Dr {
        constructor(o, h) {
          if (super(), this.id = o.id, this.type = o.type, this._featureFilter = { filter: () => !0, needGeometry: !1 }, o.type !== "custom" && (this.metadata = o.metadata, this.minzoom = o.minzoom, this.maxzoom = o.maxzoom, o.type !== "background" && (this.source = o.source, this.sourceLayer = o["source-layer"], this.filter = o.filter), h.layout && (this._unevaluatedLayout = new st(h.layout)), h.paint)) {
            this._transitionablePaint = new qt(h.paint);
            for (const f in o.paint) this.setPaintProperty(f, o.paint[f], { validate: !1 });
            for (const f in o.layout) this.setLayoutProperty(f, o.layout[f], { validate: !1 });
            this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Zt(h.paint);
          }
        }
        getCrossfadeParameters() {
          return this._crossfadeParameters;
        }
        getLayoutProperty(o) {
          return o === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(o);
        }
        setLayoutProperty(o, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          h != null && this._validate(gu, `layers.${this.id}.layout.${o}`, o, h, f) || (o !== "visibility" ? this._unevaluatedLayout.setValue(o, h) : this.visibility = h);
        }
        getPaintProperty(o) {
          return o.endsWith(Fi) ? this._transitionablePaint.getTransition(o.slice(0, -11)) : this._transitionablePaint.getValue(o);
        }
        setPaintProperty(o, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (h != null && this._validate(kc, `layers.${this.id}.paint.${o}`, o, h, f)) return !1;
          if (o.endsWith(Fi)) return this._transitionablePaint.setTransition(o.slice(0, -11), h || void 0), !1;
          {
            const _ = this._transitionablePaint._values[o], v = _.property.specification["property-type"] === "cross-faded-data-driven", w = _.value.isDataDriven(), P = _.value;
            this._transitionablePaint.setValue(o, h), this._handleSpecialPaintPropertyUpdate(o);
            const R = this._transitionablePaint._values[o].value;
            return R.isDataDriven() || w || v || this._handleOverridablePaintPropertyUpdate(o, P, R);
          }
        }
        _handleSpecialPaintPropertyUpdate(o) {
        }
        _handleOverridablePaintPropertyUpdate(o, h, f) {
          return !1;
        }
        isHidden(o) {
          return !!(this.minzoom && o < this.minzoom) || !!(this.maxzoom && o >= this.maxzoom) || this.visibility === "none";
        }
        updateTransitions(o) {
          this._transitioningPaint = this._transitionablePaint.transitioned(o, this._transitioningPaint);
        }
        hasTransition() {
          return this._transitioningPaint.hasTransition();
        }
        recalculate(o, h) {
          o.getCrossfadeParameters && (this._crossfadeParameters = o.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(o, void 0, h)), this.paint = this._transitioningPaint.possiblyEvaluate(o, void 0, h);
        }
        serialize() {
          const o = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
          return this.visibility && (o.layout = o.layout || {}, o.layout.visibility = this.visibility), xt(o, (h, f) => !(h === void 0 || f === "layout" && !Object.keys(h).length || f === "paint" && !Object.keys(h).length));
        }
        _validate(o, h, f, _) {
          let v = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          return (!v || v.validate !== !1) && ud(this, o.call(Nc, { key: h, layerType: this.type, objectKey: f, value: _, styleSpec: be, style: { glyphs: !0, sprite: !0 } }));
        }
        is3D() {
          return !1;
        }
        isTileClipped() {
          return !1;
        }
        hasOffscreenPass() {
          return !1;
        }
        resize() {
        }
        isStateDependent() {
          for (const o in this.paint._values) {
            const h = this.paint.get(o);
            if (h instanceof jt && Mo(h.property.specification) && (h.value.kind === "source" || h.value.kind === "composite") && h.value.isStateDependent) return !0;
          }
          return !1;
        }
      }
      const Ai = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
      class Li {
        constructor(o, h) {
          this._structArray = o, this._pos1 = h * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
        }
      }
      class Gn {
        constructor() {
          this.isTransferred = !1, this.capacity = -1, this.resize(0);
        }
        static serialize(o, h) {
          return o._trim(), h && (o.isTransferred = !0, h.push(o.arrayBuffer)), { length: o.length, arrayBuffer: o.arrayBuffer };
        }
        static deserialize(o) {
          const h = Object.create(this.prototype);
          return h.arrayBuffer = o.arrayBuffer, h.length = o.length, h.capacity = o.arrayBuffer.byteLength / h.bytesPerElement, h._refreshViews(), h;
        }
        _trim() {
          this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
        }
        clear() {
          this.length = 0;
        }
        resize(o) {
          this.reserve(o), this.length = o;
        }
        reserve(o) {
          if (o > this.capacity) {
            this.capacity = Math.max(o, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
            const h = this.uint8;
            this._refreshViews(), h && this.uint8.set(h);
          }
        }
        _refreshViews() {
          throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
        }
      }
      function Bn(d) {
        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, h = 0, f = 0;
        return { members: d.map((_) => {
          const v = Ai[_.type].BYTES_PER_ELEMENT, w = h = Pr(h, Math.max(o, v)), P = _.components || 1;
          return f = Math.max(f, v), h += v * P, { name: _.name, type: _.type, components: P, offset: w };
        }), size: Pr(h, Math.max(f, o)), alignment: o };
      }
      function Pr(d, o) {
        return Math.ceil(d / o) * o;
      }
      class Yr extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, h) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, o, h);
        }
        emplace(o, h, f) {
          const _ = 2 * o;
          return this.int16[_ + 0] = h, this.int16[_ + 1] = f, o;
        }
      }
      Yr.prototype.bytesPerElement = 4, vn("StructArrayLayout2i4", Yr);
      class lr extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f) {
          const _ = this.length;
          return this.resize(_ + 1), this.emplace(_, o, h, f);
        }
        emplace(o, h, f, _) {
          const v = 3 * o;
          return this.int16[v + 0] = h, this.int16[v + 1] = f, this.int16[v + 2] = _, o;
        }
      }
      lr.prototype.bytesPerElement = 6, vn("StructArrayLayout3i6", lr);
      class Ss extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, o, h, f, _);
        }
        emplace(o, h, f, _, v) {
          const w = 4 * o;
          return this.int16[w + 0] = h, this.int16[w + 1] = f, this.int16[w + 2] = _, this.int16[w + 3] = v, o;
        }
      }
      Ss.prototype.bytesPerElement = 8, vn("StructArrayLayout4i8", Ss);
      class Ri extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _, v, w) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, o, h, f, _, v, w);
        }
        emplace(o, h, f, _, v, w, P) {
          const R = 6 * o;
          return this.int16[R + 0] = h, this.int16[R + 1] = f, this.int16[R + 2] = _, this.int16[R + 3] = v, this.int16[R + 4] = w, this.int16[R + 5] = P, o;
        }
      }
      Ri.prototype.bytesPerElement = 12, vn("StructArrayLayout2i4i12", Ri);
      class Ir extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _, v, w) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, o, h, f, _, v, w);
        }
        emplace(o, h, f, _, v, w, P) {
          const R = 4 * o, D = 8 * o;
          return this.int16[R + 0] = h, this.int16[R + 1] = f, this.uint8[D + 4] = _, this.uint8[D + 5] = v, this.uint8[D + 6] = w, this.uint8[D + 7] = P, o;
        }
      }
      Ir.prototype.bytesPerElement = 8, vn("StructArrayLayout2i4ub8", Ir);
      class Jr extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, h) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, o, h);
        }
        emplace(o, h, f) {
          const _ = 2 * o;
          return this.float32[_ + 0] = h, this.float32[_ + 1] = f, o;
        }
      }
      Jr.prototype.bytesPerElement = 8, vn("StructArrayLayout2f8", Jr);
      class xr extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _, v, w, P, R, D, z) {
          const j = this.length;
          return this.resize(j + 1), this.emplace(j, o, h, f, _, v, w, P, R, D, z);
        }
        emplace(o, h, f, _, v, w, P, R, D, z, j) {
          const Y = 10 * o;
          return this.uint16[Y + 0] = h, this.uint16[Y + 1] = f, this.uint16[Y + 2] = _, this.uint16[Y + 3] = v, this.uint16[Y + 4] = w, this.uint16[Y + 5] = P, this.uint16[Y + 6] = R, this.uint16[Y + 7] = D, this.uint16[Y + 8] = z, this.uint16[Y + 9] = j, o;
        }
      }
      xr.prototype.bytesPerElement = 20, vn("StructArrayLayout10ui20", xr);
      class kr extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _, v, w, P, R, D, z, j, Y) {
          const K = this.length;
          return this.resize(K + 1), this.emplace(K, o, h, f, _, v, w, P, R, D, z, j, Y);
        }
        emplace(o, h, f, _, v, w, P, R, D, z, j, Y, K) {
          const Q = 12 * o;
          return this.int16[Q + 0] = h, this.int16[Q + 1] = f, this.int16[Q + 2] = _, this.int16[Q + 3] = v, this.uint16[Q + 4] = w, this.uint16[Q + 5] = P, this.uint16[Q + 6] = R, this.uint16[Q + 7] = D, this.int16[Q + 8] = z, this.int16[Q + 9] = j, this.int16[Q + 10] = Y, this.int16[Q + 11] = K, o;
        }
      }
      kr.prototype.bytesPerElement = 24, vn("StructArrayLayout4i4ui4i24", kr);
      class jr extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f) {
          const _ = this.length;
          return this.resize(_ + 1), this.emplace(_, o, h, f);
        }
        emplace(o, h, f, _) {
          const v = 3 * o;
          return this.float32[v + 0] = h, this.float32[v + 1] = f, this.float32[v + 2] = _, o;
        }
      }
      jr.prototype.bytesPerElement = 12, vn("StructArrayLayout3f12", jr);
      class no extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
        }
        emplaceBack(o) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, o);
        }
        emplace(o, h) {
          return this.uint32[1 * o + 0] = h, o;
        }
      }
      no.prototype.bytesPerElement = 4, vn("StructArrayLayout1ul4", no);
      class Fs extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _, v, w, P, R, D) {
          const z = this.length;
          return this.resize(z + 1), this.emplace(z, o, h, f, _, v, w, P, R, D);
        }
        emplace(o, h, f, _, v, w, P, R, D, z) {
          const j = 10 * o, Y = 5 * o;
          return this.int16[j + 0] = h, this.int16[j + 1] = f, this.int16[j + 2] = _, this.int16[j + 3] = v, this.int16[j + 4] = w, this.int16[j + 5] = P, this.uint32[Y + 3] = R, this.uint16[j + 8] = D, this.uint16[j + 9] = z, o;
        }
      }
      Fs.prototype.bytesPerElement = 20, vn("StructArrayLayout6i1ul2ui20", Fs);
      class cr extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _, v, w) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, o, h, f, _, v, w);
        }
        emplace(o, h, f, _, v, w, P) {
          const R = 6 * o;
          return this.int16[R + 0] = h, this.int16[R + 1] = f, this.int16[R + 2] = _, this.int16[R + 3] = v, this.int16[R + 4] = w, this.int16[R + 5] = P, o;
        }
      }
      cr.prototype.bytesPerElement = 12, vn("StructArrayLayout2i2i2i12", cr);
      class na extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _, v) {
          const w = this.length;
          return this.resize(w + 1), this.emplace(w, o, h, f, _, v);
        }
        emplace(o, h, f, _, v, w) {
          const P = 4 * o, R = 8 * o;
          return this.float32[P + 0] = h, this.float32[P + 1] = f, this.float32[P + 2] = _, this.int16[R + 6] = v, this.int16[R + 7] = w, o;
        }
      }
      na.prototype.bytesPerElement = 16, vn("StructArrayLayout2f1f2i16", na);
      class va extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _, v, w) {
          const P = this.length;
          return this.resize(P + 1), this.emplace(P, o, h, f, _, v, w);
        }
        emplace(o, h, f, _, v, w, P) {
          const R = 16 * o, D = 4 * o, z = 8 * o;
          return this.uint8[R + 0] = h, this.uint8[R + 1] = f, this.float32[D + 1] = _, this.float32[D + 2] = v, this.int16[z + 6] = w, this.int16[z + 7] = P, o;
        }
      }
      va.prototype.bytesPerElement = 16, vn("StructArrayLayout2ub2f2i16", va);
      class yo extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f) {
          const _ = this.length;
          return this.resize(_ + 1), this.emplace(_, o, h, f);
        }
        emplace(o, h, f, _) {
          const v = 3 * o;
          return this.uint16[v + 0] = h, this.uint16[v + 1] = f, this.uint16[v + 2] = _, o;
        }
      }
      yo.prototype.bytesPerElement = 6, vn("StructArrayLayout3ui6", yo);
      class xa extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _, v, w, P, R, D, z, j, Y, K, Q, se, Ee, Se) {
          const et = this.length;
          return this.resize(et + 1), this.emplace(et, o, h, f, _, v, w, P, R, D, z, j, Y, K, Q, se, Ee, Se);
        }
        emplace(o, h, f, _, v, w, P, R, D, z, j, Y, K, Q, se, Ee, Se, et) {
          const Ne = 24 * o, J = 12 * o, ve = 48 * o;
          return this.int16[Ne + 0] = h, this.int16[Ne + 1] = f, this.uint16[Ne + 2] = _, this.uint16[Ne + 3] = v, this.uint32[J + 2] = w, this.uint32[J + 3] = P, this.uint32[J + 4] = R, this.uint16[Ne + 10] = D, this.uint16[Ne + 11] = z, this.uint16[Ne + 12] = j, this.float32[J + 7] = Y, this.float32[J + 8] = K, this.uint8[ve + 36] = Q, this.uint8[ve + 37] = se, this.uint8[ve + 38] = Ee, this.uint32[J + 10] = Se, this.int16[Ne + 22] = et, o;
        }
      }
      xa.prototype.bytesPerElement = 48, vn("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", xa);
      class ur extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _, v, w, P, R, D, z, j, Y, K, Q, se, Ee, Se, et, Ne, J, ve, je, vt, Vt, Et, Lt, Qt, Ht) {
          const rn = this.length;
          return this.resize(rn + 1), this.emplace(rn, o, h, f, _, v, w, P, R, D, z, j, Y, K, Q, se, Ee, Se, et, Ne, J, ve, je, vt, Vt, Et, Lt, Qt, Ht);
        }
        emplace(o, h, f, _, v, w, P, R, D, z, j, Y, K, Q, se, Ee, Se, et, Ne, J, ve, je, vt, Vt, Et, Lt, Qt, Ht, rn) {
          const Dt = 32 * o, Cn = 16 * o;
          return this.int16[Dt + 0] = h, this.int16[Dt + 1] = f, this.int16[Dt + 2] = _, this.int16[Dt + 3] = v, this.int16[Dt + 4] = w, this.int16[Dt + 5] = P, this.int16[Dt + 6] = R, this.int16[Dt + 7] = D, this.uint16[Dt + 8] = z, this.uint16[Dt + 9] = j, this.uint16[Dt + 10] = Y, this.uint16[Dt + 11] = K, this.uint16[Dt + 12] = Q, this.uint16[Dt + 13] = se, this.uint16[Dt + 14] = Ee, this.uint16[Dt + 15] = Se, this.uint16[Dt + 16] = et, this.uint16[Dt + 17] = Ne, this.uint16[Dt + 18] = J, this.uint16[Dt + 19] = ve, this.uint16[Dt + 20] = je, this.uint16[Dt + 21] = vt, this.uint16[Dt + 22] = Vt, this.uint32[Cn + 12] = Et, this.float32[Cn + 13] = Lt, this.float32[Cn + 14] = Qt, this.uint16[Dt + 30] = Ht, this.uint16[Dt + 31] = rn, o;
        }
      }
      ur.prototype.bytesPerElement = 64, vn("StructArrayLayout8i15ui1ul2f2ui64", ur);
      class nc extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, o);
        }
        emplace(o, h) {
          return this.float32[1 * o + 0] = h, o;
        }
      }
      nc.prototype.bytesPerElement = 4, vn("StructArrayLayout1f4", nc);
      class Wu extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f) {
          const _ = this.length;
          return this.resize(_ + 1), this.emplace(_, o, h, f);
        }
        emplace(o, h, f, _) {
          const v = 3 * o;
          return this.uint16[6 * o + 0] = h, this.float32[v + 1] = f, this.float32[v + 2] = _, o;
        }
      }
      Wu.prototype.bytesPerElement = 12, vn("StructArrayLayout1ui2f12", Wu);
      class b extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f) {
          const _ = this.length;
          return this.resize(_ + 1), this.emplace(_, o, h, f);
        }
        emplace(o, h, f, _) {
          const v = 4 * o;
          return this.uint32[2 * o + 0] = h, this.uint16[v + 2] = f, this.uint16[v + 3] = _, o;
        }
      }
      b.prototype.bytesPerElement = 8, vn("StructArrayLayout1ul2ui8", b);
      class s extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o, h) {
          const f = this.length;
          return this.resize(f + 1), this.emplace(f, o, h);
        }
        emplace(o, h, f) {
          const _ = 2 * o;
          return this.uint16[_ + 0] = h, this.uint16[_ + 1] = f, o;
        }
      }
      s.prototype.bytesPerElement = 4, vn("StructArrayLayout2ui4", s);
      class u extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
        }
        emplaceBack(o) {
          const h = this.length;
          return this.resize(h + 1), this.emplace(h, o);
        }
        emplace(o, h) {
          return this.uint16[1 * o + 0] = h, o;
        }
      }
      u.prototype.bytesPerElement = 2, vn("StructArrayLayout1ui2", u);
      class p extends Gn {
        _refreshViews() {
          this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
        }
        emplaceBack(o, h, f, _) {
          const v = this.length;
          return this.resize(v + 1), this.emplace(v, o, h, f, _);
        }
        emplace(o, h, f, _, v) {
          const w = 4 * o;
          return this.float32[w + 0] = h, this.float32[w + 1] = f, this.float32[w + 2] = _, this.float32[w + 3] = v, o;
        }
      }
      p.prototype.bytesPerElement = 16, vn("StructArrayLayout4f16", p);
      class m extends Li {
        get anchorPointX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorPointY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get x1() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get y1() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get x2() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get y2() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get anchorPoint() {
          return new F(this.anchorPointX, this.anchorPointY);
        }
      }
      m.prototype.size = 20;
      class x extends Fs {
        get(o) {
          return new m(this, o);
        }
      }
      vn("CollisionBoxArray", x);
      class E extends Li {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get glyphStartIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get numGlyphs() {
          return this._structArray.uint16[this._pos2 + 3];
        }
        get vertexStartIndex() {
          return this._structArray.uint32[this._pos4 + 2];
        }
        get lineStartIndex() {
          return this._structArray.uint32[this._pos4 + 3];
        }
        get lineLength() {
          return this._structArray.uint32[this._pos4 + 4];
        }
        get segment() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get lowerSize() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get upperSize() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get lineOffsetX() {
          return this._structArray.float32[this._pos4 + 7];
        }
        get lineOffsetY() {
          return this._structArray.float32[this._pos4 + 8];
        }
        get writingMode() {
          return this._structArray.uint8[this._pos1 + 36];
        }
        get placedOrientation() {
          return this._structArray.uint8[this._pos1 + 37];
        }
        set placedOrientation(o) {
          this._structArray.uint8[this._pos1 + 37] = o;
        }
        get hidden() {
          return this._structArray.uint8[this._pos1 + 38];
        }
        set hidden(o) {
          this._structArray.uint8[this._pos1 + 38] = o;
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 10];
        }
        set crossTileID(o) {
          this._structArray.uint32[this._pos4 + 10] = o;
        }
        get associatedIconIndex() {
          return this._structArray.int16[this._pos2 + 22];
        }
      }
      E.prototype.size = 48;
      class L extends xa {
        get(o) {
          return new E(this, o);
        }
      }
      vn("PlacedSymbolArray", L);
      class B extends Li {
        get anchorX() {
          return this._structArray.int16[this._pos2 + 0];
        }
        get anchorY() {
          return this._structArray.int16[this._pos2 + 1];
        }
        get rightJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 2];
        }
        get centerJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 3];
        }
        get leftJustifiedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 4];
        }
        get verticalPlacedTextSymbolIndex() {
          return this._structArray.int16[this._pos2 + 5];
        }
        get placedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 6];
        }
        get verticalPlacedIconSymbolIndex() {
          return this._structArray.int16[this._pos2 + 7];
        }
        get key() {
          return this._structArray.uint16[this._pos2 + 8];
        }
        get textBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 9];
        }
        get textBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 10];
        }
        get verticalTextBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 11];
        }
        get verticalTextBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 12];
        }
        get iconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 13];
        }
        get iconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 14];
        }
        get verticalIconBoxStartIndex() {
          return this._structArray.uint16[this._pos2 + 15];
        }
        get verticalIconBoxEndIndex() {
          return this._structArray.uint16[this._pos2 + 16];
        }
        get featureIndex() {
          return this._structArray.uint16[this._pos2 + 17];
        }
        get numHorizontalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 18];
        }
        get numVerticalGlyphVertices() {
          return this._structArray.uint16[this._pos2 + 19];
        }
        get numIconVertices() {
          return this._structArray.uint16[this._pos2 + 20];
        }
        get numVerticalIconVertices() {
          return this._structArray.uint16[this._pos2 + 21];
        }
        get useRuntimeCollisionCircles() {
          return this._structArray.uint16[this._pos2 + 22];
        }
        get crossTileID() {
          return this._structArray.uint32[this._pos4 + 12];
        }
        set crossTileID(o) {
          this._structArray.uint32[this._pos4 + 12] = o;
        }
        get textBoxScale() {
          return this._structArray.float32[this._pos4 + 13];
        }
        get collisionCircleDiameter() {
          return this._structArray.float32[this._pos4 + 14];
        }
        get textAnchorOffsetStartIndex() {
          return this._structArray.uint16[this._pos2 + 30];
        }
        get textAnchorOffsetEndIndex() {
          return this._structArray.uint16[this._pos2 + 31];
        }
      }
      B.prototype.size = 64;
      class N extends ur {
        get(o) {
          return new B(this, o);
        }
      }
      vn("SymbolInstanceArray", N);
      class G extends nc {
        getoffsetX(o) {
          return this.float32[1 * o + 0];
        }
      }
      vn("GlyphOffsetArray", G);
      class Z extends lr {
        getx(o) {
          return this.int16[3 * o + 0];
        }
        gety(o) {
          return this.int16[3 * o + 1];
        }
        gettileUnitDistanceFromAnchor(o) {
          return this.int16[3 * o + 2];
        }
      }
      vn("SymbolLineVertexArray", Z);
      class $ extends Li {
        get textAnchor() {
          return this._structArray.uint16[this._pos2 + 0];
        }
        get textOffset0() {
          return this._structArray.float32[this._pos4 + 1];
        }
        get textOffset1() {
          return this._structArray.float32[this._pos4 + 2];
        }
      }
      $.prototype.size = 12;
      class re extends Wu {
        get(o) {
          return new $(this, o);
        }
      }
      vn("TextAnchorOffsetArray", re);
      class ae extends Li {
        get featureIndex() {
          return this._structArray.uint32[this._pos4 + 0];
        }
        get sourceLayerIndex() {
          return this._structArray.uint16[this._pos2 + 2];
        }
        get bucketIndex() {
          return this._structArray.uint16[this._pos2 + 3];
        }
      }
      ae.prototype.size = 8;
      class Pe extends b {
        get(o) {
          return new ae(this, o);
        }
      }
      vn("FeatureIndexArray", Pe);
      class Ce extends Yr {
      }
      class Ie extends Yr {
      }
      class Be extends Yr {
      }
      class He extends Ri {
      }
      class We extends Ir {
      }
      class $e extends Jr {
      }
      class Je extends xr {
      }
      class Qe extends kr {
      }
      class wt extends jr {
      }
      class bt extends no {
      }
      class Mt extends cr {
      }
      class Nt extends va {
      }
      class Ct extends yo {
      }
      class sn extends s {
      }
      const nn = Bn([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Gt } = nn;
      class dn {
        constructor() {
          let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          this._forceNewSegmentOnNextPrepare = !1, this.segments = o;
        }
        prepareSegment(o, h, f, _) {
          const v = this.segments[this.segments.length - 1];
          return o > dn.MAX_VERTEX_ARRAY_LENGTH && Wt(`Max vertices per segment is ${dn.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${o}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${dn.MAX_VERTEX_ARRAY_LENGTH} vertices.`), this._forceNewSegmentOnNextPrepare || !v || v.vertexLength + o > dn.MAX_VERTEX_ARRAY_LENGTH || v.sortKey !== _ ? this.createNewSegment(h, f, _) : v;
        }
        createNewSegment(o, h, f) {
          const _ = { vertexOffset: o.length, primitiveOffset: h.length, vertexLength: 0, primitiveLength: 0, vaos: {} };
          return f !== void 0 && (_.sortKey = f), this._forceNewSegmentOnNextPrepare = !1, this.segments.push(_), _;
        }
        getOrCreateLatestSegment(o, h, f) {
          return this.prepareSegment(0, o, h, f);
        }
        forceNewSegmentOnNextPrepare() {
          this._forceNewSegmentOnNextPrepare = !0;
        }
        get() {
          return this.segments;
        }
        destroy() {
          for (const o of this.segments) for (const h in o.vaos) o.vaos[h].destroy();
        }
        static simpleSegment(o, h, f, _) {
          return new dn([{ vertexOffset: o, primitiveOffset: h, vertexLength: f, primitiveLength: _, vaos: {}, sortKey: 0 }]);
        }
      }
      function Hn(d, o) {
        return 256 * (d = Re(Math.floor(d), 0, 255)) + Re(Math.floor(o), 0, 255);
      }
      dn.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, vn("SegmentVector", dn);
      const bi = Bn([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
      var Qi, Gi, er, Ci = { exports: {} }, Ni = { exports: {} }, ki = { exports: {} }, ps = function() {
        if (er) return Ci.exports;
        er = 1;
        var d = (Qi || (Qi = 1, Ni.exports = function(h, f) {
          var _, v, w, P, R, D, z, j;
          for (v = h.length - (_ = 3 & h.length), w = f, R = 3432918353, D = 461845907, j = 0; j < v; ) z = 255 & h.charCodeAt(j) | (255 & h.charCodeAt(++j)) << 8 | (255 & h.charCodeAt(++j)) << 16 | (255 & h.charCodeAt(++j)) << 24, ++j, w = 27492 + (65535 & (P = 5 * (65535 & (w = (w ^= z = (65535 & (z = (z = (65535 & z) * R + (((z >>> 16) * R & 65535) << 16) & 4294967295) << 15 | z >>> 17)) * D + (((z >>> 16) * D & 65535) << 16) & 4294967295) << 13 | w >>> 19)) + ((5 * (w >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (P >>> 16) & 65535) << 16);
          switch (z = 0, _) {
            case 3:
              z ^= (255 & h.charCodeAt(j + 2)) << 16;
            case 2:
              z ^= (255 & h.charCodeAt(j + 1)) << 8;
            case 1:
              w ^= z = (65535 & (z = (z = (65535 & (z ^= 255 & h.charCodeAt(j))) * R + (((z >>> 16) * R & 65535) << 16) & 4294967295) << 15 | z >>> 17)) * D + (((z >>> 16) * D & 65535) << 16) & 4294967295;
          }
          return w ^= h.length, w = 2246822507 * (65535 & (w ^= w >>> 16)) + ((2246822507 * (w >>> 16) & 65535) << 16) & 4294967295, w = 3266489909 * (65535 & (w ^= w >>> 13)) + ((3266489909 * (w >>> 16) & 65535) << 16) & 4294967295, (w ^= w >>> 16) >>> 0;
        }), Ni.exports), o = (Gi || (Gi = 1, ki.exports = function(h, f) {
          for (var _, v = h.length, w = f ^ v, P = 0; v >= 4; ) _ = 1540483477 * (65535 & (_ = 255 & h.charCodeAt(P) | (255 & h.charCodeAt(++P)) << 8 | (255 & h.charCodeAt(++P)) << 16 | (255 & h.charCodeAt(++P)) << 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16), w = 1540483477 * (65535 & w) + ((1540483477 * (w >>> 16) & 65535) << 16) ^ (_ = 1540483477 * (65535 & (_ ^= _ >>> 24)) + ((1540483477 * (_ >>> 16) & 65535) << 16)), v -= 4, ++P;
          switch (v) {
            case 3:
              w ^= (255 & h.charCodeAt(P + 2)) << 16;
            case 2:
              w ^= (255 & h.charCodeAt(P + 1)) << 8;
            case 1:
              w = 1540483477 * (65535 & (w ^= 255 & h.charCodeAt(P))) + ((1540483477 * (w >>> 16) & 65535) << 16);
          }
          return w = 1540483477 * (65535 & (w ^= w >>> 13)) + ((1540483477 * (w >>> 16) & 65535) << 16), (w ^= w >>> 15) >>> 0;
        }), ki.exports);
        return Ci.exports = d, Ci.exports.murmur3 = d, Ci.exports.murmur2 = o, Ci.exports;
      }(), Mr = g(ps);
      class zr {
        constructor() {
          this.ids = [], this.positions = [], this.indexed = !1;
        }
        add(o, h, f, _) {
          this.ids.push(Gr(o)), this.positions.push(h, f, _);
        }
        getPositions(o) {
          if (!this.indexed) throw new Error("Trying to get index, but feature positions are not indexed");
          const h = Gr(o);
          let f = 0, _ = this.ids.length - 1;
          for (; f < _; ) {
            const w = f + _ >> 1;
            this.ids[w] >= h ? _ = w : f = w + 1;
          }
          const v = [];
          for (; this.ids[f] === h; ) v.push({ index: this.positions[3 * f], start: this.positions[3 * f + 1], end: this.positions[3 * f + 2] }), f++;
          return v;
        }
        static serialize(o, h) {
          const f = new Float64Array(o.ids), _ = new Uint32Array(o.positions);
          return ia(f, _, 0, f.length - 1), h && h.push(f.buffer, _.buffer), { ids: f, positions: _ };
        }
        static deserialize(o) {
          const h = new zr();
          return h.ids = o.ids, h.positions = o.positions, h.indexed = !0, h;
        }
      }
      function Gr(d) {
        const o = +d;
        return !isNaN(o) && o <= Number.MAX_SAFE_INTEGER ? o : Mr(String(d));
      }
      function ia(d, o, h, f) {
        for (; h < f; ) {
          const _ = d[h + f >> 1];
          let v = h - 1, w = f + 1;
          for (; ; ) {
            do
              v++;
            while (d[v] < _);
            do
              w--;
            while (d[w] > _);
            if (v >= w) break;
            bo(d, v, w), bo(o, 3 * v, 3 * w), bo(o, 3 * v + 1, 3 * w + 1), bo(o, 3 * v + 2, 3 * w + 2);
          }
          w - h < f - w ? (ia(d, o, h, w), h = w + 1) : (ia(d, o, w + 1, f), f = w);
        }
      }
      function bo(d, o, h) {
        const f = d[o];
        d[o] = d[h], d[h] = f;
      }
      vn("FeaturePositionMap", zr);
      class Lr {
        constructor(o, h) {
          this.gl = o.gl, this.location = h;
        }
      }
      class Cs extends Lr {
        constructor(o, h) {
          super(o, h), this.current = 0;
        }
        set(o) {
          this.current !== o && (this.current = o, this.gl.uniform1f(this.location, o));
        }
      }
      class Oo extends Lr {
        constructor(o, h) {
          super(o, h), this.current = [0, 0, 0, 0];
        }
        set(o) {
          o[0] === this.current[0] && o[1] === this.current[1] && o[2] === this.current[2] && o[3] === this.current[3] || (this.current = o, this.gl.uniform4f(this.location, o[0], o[1], o[2], o[3]));
        }
      }
      class bl extends Lr {
        constructor(o, h) {
          super(o, h), this.current = Qn.transparent;
        }
        set(o) {
          o.r === this.current.r && o.g === this.current.g && o.b === this.current.b && o.a === this.current.a || (this.current = o, this.gl.uniform4f(this.location, o.r, o.g, o.b, o.a));
        }
      }
      const vl = new Float32Array(16);
      function Ns(d) {
        return [Hn(255 * d.r, 255 * d.g), Hn(255 * d.b, 255 * d.a)];
      }
      class Do {
        constructor(o, h, f) {
          this.value = o, this.uniformNames = h.map((_) => `u_${_}`), this.type = f;
        }
        setUniform(o, h, f) {
          o.set(f.constantOr(this.value));
        }
        getBinding(o, h, f) {
          return this.type === "color" ? new bl(o, h) : new Cs(o, h);
        }
      }
      class io {
        constructor(o, h) {
          this.uniformNames = h.map((f) => `u_${f}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
        }
        setConstantPatternPositions(o, h) {
          this.pixelRatioFrom = h.pixelRatio, this.pixelRatioTo = o.pixelRatio, this.patternFrom = h.tlbr, this.patternTo = o.tlbr;
        }
        setUniform(o, h, f, _) {
          const v = _ === "u_pattern_to" ? this.patternTo : _ === "u_pattern_from" ? this.patternFrom : _ === "u_pixel_ratio_to" ? this.pixelRatioTo : _ === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
          v && o.set(v);
        }
        getBinding(o, h, f) {
          return f.substr(0, 9) === "u_pattern" ? new Oo(o, h) : new Cs(o, h);
        }
      }
      class ks {
        constructor(o, h, f, _) {
          this.expression = o, this.type = f, this.maxValue = 0, this.paintVertexAttributes = h.map((v) => ({ name: `a_${v}`, type: "Float32", components: f === "color" ? 2 : 1, offset: 0 })), this.paintVertexArray = new _();
        }
        populatePaintArray(o, h, f, _, v) {
          const w = this.paintVertexArray.length, P = this.expression.evaluate(new ut(0), h, {}, _, [], v);
          this.paintVertexArray.resize(o), this._setPaintValue(w, o, P);
        }
        updatePaintArray(o, h, f, _) {
          const v = this.expression.evaluate({ zoom: 0 }, f, _);
          this._setPaintValue(o, h, v);
        }
        _setPaintValue(o, h, f) {
          if (this.type === "color") {
            const _ = Ns(f);
            for (let v = o; v < h; v++) this.paintVertexArray.emplace(v, _[0], _[1]);
          } else {
            for (let _ = o; _ < h; _++) this.paintVertexArray.emplace(_, f);
            this.maxValue = Math.max(this.maxValue, Math.abs(f));
          }
        }
        upload(o) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = o.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
      }
      class Xi {
        constructor(o, h, f, _, v, w) {
          this.expression = o, this.uniformNames = h.map((P) => `u_${P}_t`), this.type = f, this.useIntegerZoom = _, this.zoom = v, this.maxValue = 0, this.paintVertexAttributes = h.map((P) => ({ name: `a_${P}`, type: "Float32", components: f === "color" ? 4 : 2, offset: 0 })), this.paintVertexArray = new w();
        }
        populatePaintArray(o, h, f, _, v) {
          const w = this.expression.evaluate(new ut(this.zoom), h, {}, _, [], v), P = this.expression.evaluate(new ut(this.zoom + 1), h, {}, _, [], v), R = this.paintVertexArray.length;
          this.paintVertexArray.resize(o), this._setPaintValue(R, o, w, P);
        }
        updatePaintArray(o, h, f, _) {
          const v = this.expression.evaluate({ zoom: this.zoom }, f, _), w = this.expression.evaluate({ zoom: this.zoom + 1 }, f, _);
          this._setPaintValue(o, h, v, w);
        }
        _setPaintValue(o, h, f, _) {
          if (this.type === "color") {
            const v = Ns(f), w = Ns(_);
            for (let P = o; P < h; P++) this.paintVertexArray.emplace(P, v[0], v[1], w[0], w[1]);
          } else {
            for (let v = o; v < h; v++) this.paintVertexArray.emplace(v, f, _);
            this.maxValue = Math.max(this.maxValue, Math.abs(f), Math.abs(_));
          }
        }
        upload(o) {
          this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = o.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
        }
        destroy() {
          this.paintVertexBuffer && this.paintVertexBuffer.destroy();
        }
        setUniform(o, h) {
          const f = this.useIntegerZoom ? Math.floor(h.zoom) : h.zoom, _ = Re(this.expression.interpolationFactor(f, this.zoom, this.zoom + 1), 0, 1);
          o.set(_);
        }
        getBinding(o, h, f) {
          return new Cs(o, h);
        }
      }
      class gr {
        constructor(o, h, f, _, v, w) {
          this.expression = o, this.type = h, this.useIntegerZoom = f, this.zoom = _, this.layerId = w, this.zoomInPaintVertexArray = new v(), this.zoomOutPaintVertexArray = new v();
        }
        populatePaintArray(o, h, f) {
          const _ = this.zoomInPaintVertexArray.length;
          this.zoomInPaintVertexArray.resize(o), this.zoomOutPaintVertexArray.resize(o), this._setPaintValues(_, o, h.patterns && h.patterns[this.layerId], f);
        }
        updatePaintArray(o, h, f, _, v) {
          this._setPaintValues(o, h, f.patterns && f.patterns[this.layerId], v);
        }
        _setPaintValues(o, h, f, _) {
          if (!_ || !f) return;
          const { min: v, mid: w, max: P } = f, R = _[v], D = _[w], z = _[P];
          if (R && D && z) for (let j = o; j < h; j++) this.zoomInPaintVertexArray.emplace(j, D.tl[0], D.tl[1], D.br[0], D.br[1], R.tl[0], R.tl[1], R.br[0], R.br[1], D.pixelRatio, R.pixelRatio), this.zoomOutPaintVertexArray.emplace(j, D.tl[0], D.tl[1], D.br[0], D.br[1], z.tl[0], z.tl[1], z.br[0], z.br[1], D.pixelRatio, z.pixelRatio);
        }
        upload(o) {
          this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = o.createVertexBuffer(this.zoomInPaintVertexArray, bi.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = o.createVertexBuffer(this.zoomOutPaintVertexArray, bi.members, this.expression.isStateDependent));
        }
        destroy() {
          this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
        }
      }
      class ra {
        constructor(o, h, f) {
          this.binders = {}, this._buffers = [];
          const _ = [];
          for (const v in o.paint._values) {
            if (!f(v)) continue;
            const w = o.paint.get(v);
            if (!(w instanceof jt && Mo(w.property.specification))) continue;
            const P = b_(v, o.type), R = w.value, D = w.property.specification.type, z = w.property.useIntegerZoom, j = w.property.specification["property-type"], Y = j === "cross-faded" || j === "cross-faded-data-driven";
            if (R.kind === "constant") this.binders[v] = Y ? new io(R.value, P) : new Do(R.value, P, D), _.push(`/u_${v}`);
            else if (R.kind === "source" || Y) {
              const K = tg(v, D, "source");
              this.binders[v] = Y ? new gr(R, D, z, h, K, o.id) : new ks(R, P, D, K), _.push(`/a_${v}`);
            } else {
              const K = tg(v, D, "composite");
              this.binders[v] = new Xi(R, P, D, z, h, K), _.push(`/z_${v}`);
            }
          }
          this.cacheKey = _.sort().join("");
        }
        getMaxValue(o) {
          const h = this.binders[o];
          return h instanceof ks || h instanceof Xi ? h.maxValue : 0;
        }
        populatePaintArrays(o, h, f, _, v) {
          for (const w in this.binders) {
            const P = this.binders[w];
            (P instanceof ks || P instanceof Xi || P instanceof gr) && P.populatePaintArray(o, h, f, _, v);
          }
        }
        setConstantPatternPositions(o, h) {
          for (const f in this.binders) {
            const _ = this.binders[f];
            _ instanceof io && _.setConstantPatternPositions(o, h);
          }
        }
        updatePaintArrays(o, h, f, _, v) {
          let w = !1;
          for (const P in o) {
            const R = h.getPositions(P);
            for (const D of R) {
              const z = f.feature(D.index);
              for (const j in this.binders) {
                const Y = this.binders[j];
                if ((Y instanceof ks || Y instanceof Xi || Y instanceof gr) && Y.expression.isStateDependent === !0) {
                  const K = _.paint.get(j);
                  Y.expression = K.value, Y.updatePaintArray(D.start, D.end, z, o[P], v), w = !0;
                }
              }
            }
          }
          return w;
        }
        defines() {
          const o = [];
          for (const h in this.binders) {
            const f = this.binders[h];
            (f instanceof Do || f instanceof io) && o.push(...f.uniformNames.map((_) => `#define HAS_UNIFORM_${_}`));
          }
          return o;
        }
        getBinderAttributes() {
          const o = [];
          for (const h in this.binders) {
            const f = this.binders[h];
            if (f instanceof ks || f instanceof Xi) for (let _ = 0; _ < f.paintVertexAttributes.length; _++) o.push(f.paintVertexAttributes[_].name);
            else if (f instanceof gr) for (let _ = 0; _ < bi.members.length; _++) o.push(bi.members[_].name);
          }
          return o;
        }
        getBinderUniforms() {
          const o = [];
          for (const h in this.binders) {
            const f = this.binders[h];
            if (f instanceof Do || f instanceof io || f instanceof Xi) for (const _ of f.uniformNames) o.push(_);
          }
          return o;
        }
        getPaintVertexBuffers() {
          return this._buffers;
        }
        getUniforms(o, h) {
          const f = [];
          for (const _ in this.binders) {
            const v = this.binders[_];
            if (v instanceof Do || v instanceof io || v instanceof Xi) {
              for (const w of v.uniformNames) if (h[w]) {
                const P = v.getBinding(o, h[w], w);
                f.push({ name: w, property: _, binding: P });
              }
            }
          }
          return f;
        }
        setUniforms(o, h, f, _) {
          for (const { name: v, property: w, binding: P } of h) this.binders[w].setUniform(P, _, f.get(w), v);
        }
        updatePaintBuffers(o) {
          this._buffers = [];
          for (const h in this.binders) {
            const f = this.binders[h];
            if (o && f instanceof gr) {
              const _ = o.fromScale === 2 ? f.zoomInPaintVertexBuffer : f.zoomOutPaintVertexBuffer;
              _ && this._buffers.push(_);
            } else (f instanceof ks || f instanceof Xi) && f.paintVertexBuffer && this._buffers.push(f.paintVertexBuffer);
          }
        }
        upload(o) {
          for (const h in this.binders) {
            const f = this.binders[h];
            (f instanceof ks || f instanceof Xi || f instanceof gr) && f.upload(o);
          }
          this.updatePaintBuffers();
        }
        destroy() {
          for (const o in this.binders) {
            const h = this.binders[o];
            (h instanceof ks || h instanceof Xi || h instanceof gr) && h.destroy();
          }
        }
      }
      class wr {
        constructor(o, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : () => !0;
          this.programConfigurations = {};
          for (const _ of o) this.programConfigurations[_.id] = new ra(_, h, f);
          this.needsUpload = !1, this._featureMap = new zr(), this._bufferOffset = 0;
        }
        populatePaintArrays(o, h, f, _, v, w) {
          for (const P in this.programConfigurations) this.programConfigurations[P].populatePaintArrays(o, h, _, v, w);
          h.id !== void 0 && this._featureMap.add(h.id, f, this._bufferOffset, o), this._bufferOffset = o, this.needsUpload = !0;
        }
        updatePaintArrays(o, h, f, _) {
          for (const v of f) this.needsUpload = this.programConfigurations[v.id].updatePaintArrays(o, this._featureMap, h, v, _) || this.needsUpload;
        }
        get(o) {
          return this.programConfigurations[o];
        }
        upload(o) {
          if (this.needsUpload) {
            for (const h in this.programConfigurations) this.programConfigurations[h].upload(o);
            this.needsUpload = !1;
          }
        }
        destroy() {
          for (const o in this.programConfigurations) this.programConfigurations[o].destroy();
        }
      }
      function b_(d, o) {
        return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[d] || [d.replace(`${o}-`, "").replace(/-/g, "_")];
      }
      function tg(d, o, h) {
        const f = { color: { source: Jr, composite: p }, number: { source: nc, composite: Jr } }, _ = function(v) {
          return { "line-pattern": { source: Je, composite: Je }, "fill-pattern": { source: Je, composite: Je }, "fill-extrusion-pattern": { source: Je, composite: Je } }[v];
        }(d);
        return _ && _[h] || f[o][h];
      }
      vn("ConstantBinder", Do), vn("CrossFadedConstantBinder", io), vn("SourceExpressionBinder", ks), vn("CrossFadedCompositeBinder", gr), vn("CompositeExpressionBinder", Xi), vn("ProgramConfiguration", ra, { omit: ["_buffers"] }), vn("ProgramConfigurationSet", wr);
      const wf = Math.pow(2, 14) - 1, ng = -wf - 1;
      function yu(d) {
        const o = dt / d.extent, h = d.loadGeometry();
        for (let f = 0; f < h.length; f++) {
          const _ = h[f];
          for (let v = 0; v < _.length; v++) {
            const w = _[v], P = Math.round(w.x * o), R = Math.round(w.y * o);
            w.x = Re(P, ng, wf), w.y = Re(R, ng, wf), (P < w.x || P > w.x + 1 || R < w.y || R > w.y + 1) && Wt("Geometry exceeds allowed extent, reduce your vector tile buffer size");
          }
        }
        return h;
      }
      function bu(d, o) {
        return { type: d.type, id: d.id, properties: d.properties, geometry: o ? yu(d) : [] };
      }
      const Uc = -32768;
      function ig(d, o, h, f, _) {
        d.emplaceBack(Uc + 8 * o + f, Uc + 8 * h + _);
      }
      class fd {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((h) => h.id), this.index = o.index, this.hasPattern = !1, this.layoutVertexArray = new Ie(), this.indexArray = new Ct(), this.segments = new dn(), this.programConfigurations = new wr(o.layers, o.zoom), this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
        }
        populate(o, h, f) {
          const _ = this.layers[0], v = [];
          let w = null, P = !1, R = _.type === "heatmap";
          if (_.type === "circle") {
            const z = _;
            w = z.layout.get("circle-sort-key"), P = !w.isConstant(), R = R || z.paint.get("circle-pitch-alignment") === "map";
          }
          const D = R ? h.subdivisionGranularity.circle : 1;
          for (const { feature: z, id: j, index: Y, sourceLayerIndex: K } of o) {
            const Q = this.layers[0]._featureFilter.needGeometry, se = bu(z, Q);
            if (!this.layers[0]._featureFilter.filter(new ut(this.zoom), se, f)) continue;
            const Ee = P ? w.evaluate(se, {}, f) : void 0, Se = { id: j, properties: z.properties, type: z.type, sourceLayerIndex: K, index: Y, geometry: Q ? se.geometry : yu(z), patterns: {}, sortKey: Ee };
            v.push(Se);
          }
          P && v.sort((z, j) => z.sortKey - j.sortKey);
          for (const z of v) {
            const { geometry: j, index: Y, sourceLayerIndex: K } = z, Q = o[Y].feature;
            this.addFeature(z, j, Y, f, D), h.featureIndex.insert(Q, j, Y, K, this.index);
          }
        }
        update(o, h, f) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, h, this.stateDependentLayers, f);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, Gt), this.indexBuffer = o.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        addFeature(o, h, f, _) {
          let v = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1, w;
          switch (v) {
            case 1:
              w = [0, 7];
              break;
            case 3:
              w = [0, 2, 5, 7];
              break;
            case 5:
              w = [0, 1, 3, 4, 6, 7];
              break;
            case 7:
              w = [0, 1, 2, 3, 4, 5, 6, 7];
              break;
            default:
              throw new Error(`Invalid circle bucket granularity: ${v}; valid values are 1, 3, 5, 7.`);
          }
          const P = w.length;
          for (const R of h) for (const D of R) {
            const z = D.x, j = D.y;
            if (z < 0 || z >= dt || j < 0 || j >= dt) continue;
            const Y = this.segments.prepareSegment(P * P, this.layoutVertexArray, this.indexArray, o.sortKey), K = Y.vertexLength;
            for (let Q = 0; Q < P; Q++) for (let se = 0; se < P; se++) ig(this.layoutVertexArray, z, j, w[se], w[Q]);
            for (let Q = 0; Q < P - 1; Q++) for (let se = 0; se < P - 1; se++) {
              const Ee = K + Q * P + se, Se = K + (Q + 1) * P + se;
              this.indexArray.emplaceBack(Ee, Se + 1, Ee + 1), this.indexArray.emplaceBack(Ee, Se, Se + 1);
            }
            Y.vertexLength += P * P, Y.primitiveLength += (P - 1) * (P - 1) * 2;
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, f, {}, _);
        }
      }
      function Af(d, o) {
        for (let h = 0; h < d.length; h++) if (pd(o, d[h])) return !0;
        for (let h = 0; h < o.length; h++) if (pd(d, o[h])) return !0;
        return !!v_(d, o);
      }
      function Tf(d, o, h) {
        return !!pd(d, o) || !!x_(o, d, h);
      }
      function Ef(d, o) {
        if (d.length === 1) return dv(o, d[0]);
        for (let h = 0; h < o.length; h++) {
          const f = o[h];
          for (let _ = 0; _ < f.length; _++) if (pd(d, f[_])) return !0;
        }
        for (let h = 0; h < d.length; h++) if (dv(o, d[h])) return !0;
        for (let h = 0; h < o.length; h++) if (v_(d, o[h])) return !0;
        return !1;
      }
      function Sf(d, o, h) {
        if (d.length > 1) {
          if (v_(d, o)) return !0;
          for (let f = 0; f < o.length; f++) if (x_(o[f], d, h)) return !0;
        }
        for (let f = 0; f < d.length; f++) if (x_(d[f], o, h)) return !0;
        return !1;
      }
      function v_(d, o) {
        if (d.length === 0 || o.length === 0) return !1;
        for (let h = 0; h < d.length - 1; h++) {
          const f = d[h], _ = d[h + 1];
          for (let v = 0; v < o.length - 1; v++) if (lC(f, _, o[v], o[v + 1])) return !0;
        }
        return !1;
      }
      function lC(d, o, h, f) {
        return on(d, h, f) !== on(o, h, f) && on(d, o, h) !== on(d, o, f);
      }
      function x_(d, o, h) {
        const f = h * h;
        if (o.length === 1) return d.distSqr(o[0]) < f;
        for (let _ = 1; _ < o.length; _++) if (hv(d, o[_ - 1], o[_]) < f) return !0;
        return !1;
      }
      function hv(d, o, h) {
        const f = o.distSqr(h);
        if (f === 0) return d.distSqr(o);
        const _ = ((d.x - o.x) * (h.x - o.x) + (d.y - o.y) * (h.y - o.y)) / f;
        return d.distSqr(_ < 0 ? o : _ > 1 ? h : h.sub(o)._mult(_)._add(o));
      }
      function dv(d, o) {
        let h, f, _, v = !1;
        for (let w = 0; w < d.length; w++) {
          h = d[w];
          for (let P = 0, R = h.length - 1; P < h.length; R = P++) f = h[P], _ = h[R], f.y > o.y != _.y > o.y && o.x < (_.x - f.x) * (o.y - f.y) / (_.y - f.y) + f.x && (v = !v);
        }
        return v;
      }
      function pd(d, o) {
        let h = !1;
        for (let f = 0, _ = d.length - 1; f < d.length; _ = f++) {
          const v = d[f], w = d[_];
          v.y > o.y != w.y > o.y && o.x < (w.x - v.x) * (o.y - v.y) / (w.y - v.y) + v.x && (h = !h);
        }
        return h;
      }
      function cC(d, o, h) {
        const f = h[0], _ = h[2];
        if (d.x < f.x && o.x < f.x || d.x > _.x && o.x > _.x || d.y < f.y && o.y < f.y || d.y > _.y && o.y > _.y) return !1;
        const v = on(d, o, h[0]);
        return v !== on(d, o, h[1]) || v !== on(d, o, h[2]) || v !== on(d, o, h[3]);
      }
      function Cf(d, o, h) {
        const f = o.paint.get(d).value;
        return f.kind === "constant" ? f.value : h.programConfigurations.get(o.id).getMaxValue(d);
      }
      function rg(d) {
        return Math.sqrt(d[0] * d[0] + d[1] * d[1]);
      }
      function sg(d, o, h, f, _) {
        if (!o[0] && !o[1]) return d;
        const v = F.convert(o)._mult(_);
        h === "viewport" && v._rotate(-f);
        const w = [];
        for (let P = 0; P < d.length; P++) w.push(d[P].sub(v));
        return w;
      }
      let fv, pv;
      vn("CircleBucket", fd, { omit: ["layers"] });
      var uC = { get paint() {
        return pv = pv || new ri({ "circle-radius": new Ut(be.paint_circle["circle-radius"]), "circle-color": new Ut(be.paint_circle["circle-color"]), "circle-blur": new Ut(be.paint_circle["circle-blur"]), "circle-opacity": new Ut(be.paint_circle["circle-opacity"]), "circle-translate": new ft(be.paint_circle["circle-translate"]), "circle-translate-anchor": new ft(be.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new ft(be.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new ft(be.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new Ut(be.paint_circle["circle-stroke-width"]), "circle-stroke-color": new Ut(be.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new Ut(be.paint_circle["circle-stroke-opacity"]) });
      }, get layout() {
        return fv = fv || new ri({ "circle-sort-key": new Ut(be.layout_circle["circle-sort-key"]) });
      } };
      class hC extends ai {
        constructor(o) {
          super(o, uC);
        }
        createBucket(o) {
          return new fd(o);
        }
        queryRadius(o) {
          const h = o;
          return Cf("circle-radius", this, h) + Cf("circle-stroke-width", this, h) + rg(this.paint.get("circle-translate"));
        }
        queryIntersectsFeature(o) {
          let { queryGeometry: h, feature: f, featureState: _, geometry: v, transform: w, pixelsToTileUnits: P, pixelPosMatrix: R } = o;
          const D = sg(h, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -w.bearingInRadians, P), z = this.paint.get("circle-radius").evaluate(f, _) + this.paint.get("circle-stroke-width").evaluate(f, _), j = this.paint.get("circle-pitch-alignment") === "map", Y = j ? D : function(Q, se) {
            return Q.map((Ee) => gv(Ee, se));
          }(D, R), K = j ? z * P : z;
          for (const Q of v) for (const se of Q) {
            const Ee = j ? se : gv(se, R);
            let Se = K;
            const et = _e([], [se.x, se.y, 0, 1], R);
            if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? Se *= et[3] / w.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (Se *= w.cameraToCenterDistance / et[3]), Tf(Y, Ee, Se)) return !0;
          }
          return !1;
        }
      }
      function gv(d, o) {
        const h = _e([], [d.x, d.y, 0, 1], o);
        return new F(h[0] / h[3], h[1] / h[3]);
      }
      class mv extends fd {
      }
      let _v;
      vn("HeatmapBucket", mv, { omit: ["layers"] });
      var dC = { get paint() {
        return _v = _v || new ri({ "heatmap-radius": new Ut(be.paint_heatmap["heatmap-radius"]), "heatmap-weight": new Ut(be.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new ft(be.paint_heatmap["heatmap-intensity"]), "heatmap-color": new xn(be.paint_heatmap["heatmap-color"]), "heatmap-opacity": new ft(be.paint_heatmap["heatmap-opacity"]) });
      } };
      function w_(d, o, h, f) {
        let { width: _, height: v } = o;
        if (f) {
          if (f instanceof Uint8ClampedArray) f = new Uint8Array(f.buffer);
          else if (f.length !== _ * v * h) throw new RangeError(`mismatched image size. expected: ${f.length} but got: ${_ * v * h}`);
        } else f = new Uint8Array(_ * v * h);
        return d.width = _, d.height = v, d.data = f, d;
      }
      function yv(d, o, h) {
        let { width: f, height: _ } = o;
        if (f === d.width && _ === d.height) return;
        const v = w_({}, { width: f, height: _ }, h);
        A_(d, v, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(d.width, f), height: Math.min(d.height, _) }, h), d.width = f, d.height = _, d.data = v.data;
      }
      function A_(d, o, h, f, _, v) {
        if (_.width === 0 || _.height === 0) return o;
        if (_.width > d.width || _.height > d.height || h.x > d.width - _.width || h.y > d.height - _.height) throw new RangeError("out of range source coordinates for image copy");
        if (_.width > o.width || _.height > o.height || f.x > o.width - _.width || f.y > o.height - _.height) throw new RangeError("out of range destination coordinates for image copy");
        const w = d.data, P = o.data;
        if (w === P) throw new Error("srcData equals dstData, so image is already copied");
        for (let R = 0; R < _.height; R++) {
          const D = ((h.y + R) * d.width + h.x) * v, z = ((f.y + R) * o.width + f.x) * v;
          for (let j = 0; j < _.width * v; j++) P[z + j] = w[D + j];
        }
        return o;
      }
      class Pf {
        constructor(o, h) {
          w_(this, o, 1, h);
        }
        resize(o) {
          yv(this, o, 1);
        }
        clone() {
          return new Pf({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(o, h, f, _, v) {
          A_(o, h, f, _, v, 1);
        }
      }
      class qa {
        constructor(o, h) {
          w_(this, o, 4, h);
        }
        resize(o) {
          yv(this, o, 4);
        }
        replace(o, h) {
          h ? this.data.set(o) : this.data = o instanceof Uint8ClampedArray ? new Uint8Array(o.buffer) : o;
        }
        clone() {
          return new qa({ width: this.width, height: this.height }, new Uint8Array(this.data));
        }
        static copy(o, h, f, _, v) {
          A_(o, h, f, _, v, 4);
        }
      }
      function bv(d) {
        const o = {}, h = d.resolution || 256, f = d.clips ? d.clips.length : 1, _ = d.image || new qa({ width: h, height: f });
        if (Math.log(h) / Math.LN2 % 1 != 0) throw new Error(`width is not a power of 2 - ${h}`);
        const v = (w, P, R) => {
          o[d.evaluationKey] = R;
          const D = d.expression.evaluate(o);
          _.data[w + P + 0] = Math.floor(255 * D.r / D.a), _.data[w + P + 1] = Math.floor(255 * D.g / D.a), _.data[w + P + 2] = Math.floor(255 * D.b / D.a), _.data[w + P + 3] = Math.floor(255 * D.a);
        };
        if (d.clips) for (let w = 0, P = 0; w < f; ++w, P += 4 * h) for (let R = 0, D = 0; R < h; R++, D += 4) {
          const z = R / (h - 1), { start: j, end: Y } = d.clips[w];
          v(P, D, j * (1 - z) + Y * z);
        }
        else for (let w = 0, P = 0; w < h; w++, P += 4) v(0, P, w / (h - 1));
        return _;
      }
      vn("AlphaImage", Pf), vn("RGBAImage", qa);
      const T_ = "big-fb";
      class fC extends ai {
        createBucket(o) {
          return new mv(o);
        }
        constructor(o) {
          super(o, dC), this.heatmapFbos = /* @__PURE__ */ new Map(), this._updateColorRamp();
        }
        _handleSpecialPaintPropertyUpdate(o) {
          o === "heatmap-color" && this._updateColorRamp();
        }
        _updateColorRamp() {
          this.colorRamp = bv({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
        }
        resize() {
          this.heatmapFbos.has(T_) && this.heatmapFbos.delete(T_);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          return !1;
        }
        hasOffscreenPass() {
          return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none";
        }
      }
      let vv;
      var pC = { get paint() {
        return vv = vv || new ri({ "hillshade-illumination-direction": new ft(be.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new ft(be.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new ft(be.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new ft(be.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new ft(be.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new ft(be.paint_hillshade["hillshade-accent-color"]) });
      } };
      class gC extends ai {
        constructor(o) {
          super(o, pC);
        }
        hasOffscreenPass() {
          return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none";
        }
      }
      const mC = Bn([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: _C } = mC;
      function E_(d, o, h) {
        const f = h.patternDependencies;
        let _ = !1;
        for (const v of o) {
          const w = v.paint.get(`${d}-pattern`);
          w.isConstant() || (_ = !0);
          const P = w.constantOr(null);
          P && (_ = !0, f[P.to] = !0, f[P.from] = !0);
        }
        return _;
      }
      function S_(d, o, h, f, _) {
        const v = _.patternDependencies;
        for (const w of o) {
          const P = w.paint.get(`${d}-pattern`).value;
          if (P.kind !== "constant") {
            let R = P.evaluate({ zoom: f - 1 }, h, {}, _.availableImages), D = P.evaluate({ zoom: f }, h, {}, _.availableImages), z = P.evaluate({ zoom: f + 1 }, h, {}, _.availableImages);
            R = R && R.name ? R.name : R, D = D && D.name ? D.name : D, z = z && z.name ? z.name : z, v[R] = !0, v[D] = !0, v[z] = !0, h.patterns[w.id] = { min: R, mid: D, max: z };
          }
        }
        return h;
      }
      function xv(d, o, h, f, _) {
        let v;
        if (_ === function(w, P, R, D) {
          let z = 0;
          for (let j = P, Y = R - D; j < R; j += D) z += (w[Y] - w[j]) * (w[j + 1] + w[Y + 1]), Y = j;
          return z;
        }(d, o, h, f) > 0) for (let w = o; w < h; w += f) v = Ev(w / f | 0, d[w], d[w + 1], v);
        else for (let w = h - f; w >= o; w -= f) v = Ev(w / f | 0, d[w], d[w + 1], v);
        return v && gd(v, v.next) && (Rf(v), v = v.next), v;
      }
      function Ch(d, o) {
        if (!d) return d;
        o || (o = d);
        let h, f = d;
        do
          if (h = !1, f.steiner || !gd(f, f.next) && Vr(f.prev, f, f.next) !== 0) f = f.next;
          else {
            if (Rf(f), f = o = f.prev, f === f.next) break;
            h = !0;
          }
        while (h || f !== o);
        return o;
      }
      function If(d, o, h, f, _, v, w) {
        if (!d) return;
        !w && v && function(R, D, z, j) {
          let Y = R;
          do
            Y.z === 0 && (Y.z = C_(Y.x, Y.y, D, z, j)), Y.prevZ = Y.prev, Y.nextZ = Y.next, Y = Y.next;
          while (Y !== R);
          Y.prevZ.nextZ = null, Y.prevZ = null, function(K) {
            let Q, se = 1;
            do {
              let Ee, Se = K;
              K = null;
              let et = null;
              for (Q = 0; Se; ) {
                Q++;
                let Ne = Se, J = 0;
                for (let je = 0; je < se && (J++, Ne = Ne.nextZ, Ne); je++) ;
                let ve = se;
                for (; J > 0 || ve > 0 && Ne; ) J !== 0 && (ve === 0 || !Ne || Se.z <= Ne.z) ? (Ee = Se, Se = Se.nextZ, J--) : (Ee = Ne, Ne = Ne.nextZ, ve--), et ? et.nextZ = Ee : K = Ee, Ee.prevZ = et, et = Ee;
                Se = Ne;
              }
              et.nextZ = null, se *= 2;
            } while (Q > 1);
          }(Y);
        }(d, f, _, v);
        let P = d;
        for (; d.prev !== d.next; ) {
          const R = d.prev, D = d.next;
          if (v ? bC(d, f, _, v) : yC(d)) o.push(R.i, d.i, D.i), Rf(d), d = D.next, P = D.next;
          else if ((d = D) === P) {
            w ? w === 1 ? If(d = vC(Ch(d), o), o, h, f, _, v, 2) : w === 2 && xC(d, o, h, f, _, v) : If(Ch(d), o, h, f, _, v, 1);
            break;
          }
        }
      }
      function yC(d) {
        const o = d.prev, h = d, f = d.next;
        if (Vr(o, h, f) >= 0) return !1;
        const _ = o.x, v = h.x, w = f.x, P = o.y, R = h.y, D = f.y, z = Math.min(_, v, w), j = Math.min(P, R, D), Y = Math.max(_, v, w), K = Math.max(P, R, D);
        let Q = f.next;
        for (; Q !== o; ) {
          if (Q.x >= z && Q.x <= Y && Q.y >= j && Q.y <= K && Mf(_, P, v, R, w, D, Q.x, Q.y) && Vr(Q.prev, Q, Q.next) >= 0) return !1;
          Q = Q.next;
        }
        return !0;
      }
      function bC(d, o, h, f) {
        const _ = d.prev, v = d, w = d.next;
        if (Vr(_, v, w) >= 0) return !1;
        const P = _.x, R = v.x, D = w.x, z = _.y, j = v.y, Y = w.y, K = Math.min(P, R, D), Q = Math.min(z, j, Y), se = Math.max(P, R, D), Ee = Math.max(z, j, Y), Se = C_(K, Q, o, h, f), et = C_(se, Ee, o, h, f);
        let Ne = d.prevZ, J = d.nextZ;
        for (; Ne && Ne.z >= Se && J && J.z <= et; ) {
          if (Ne.x >= K && Ne.x <= se && Ne.y >= Q && Ne.y <= Ee && Ne !== _ && Ne !== w && Mf(P, z, R, j, D, Y, Ne.x, Ne.y) && Vr(Ne.prev, Ne, Ne.next) >= 0 || (Ne = Ne.prevZ, J.x >= K && J.x <= se && J.y >= Q && J.y <= Ee && J !== _ && J !== w && Mf(P, z, R, j, D, Y, J.x, J.y) && Vr(J.prev, J, J.next) >= 0)) return !1;
          J = J.nextZ;
        }
        for (; Ne && Ne.z >= Se; ) {
          if (Ne.x >= K && Ne.x <= se && Ne.y >= Q && Ne.y <= Ee && Ne !== _ && Ne !== w && Mf(P, z, R, j, D, Y, Ne.x, Ne.y) && Vr(Ne.prev, Ne, Ne.next) >= 0) return !1;
          Ne = Ne.prevZ;
        }
        for (; J && J.z <= et; ) {
          if (J.x >= K && J.x <= se && J.y >= Q && J.y <= Ee && J !== _ && J !== w && Mf(P, z, R, j, D, Y, J.x, J.y) && Vr(J.prev, J, J.next) >= 0) return !1;
          J = J.nextZ;
        }
        return !0;
      }
      function vC(d, o) {
        let h = d;
        do {
          const f = h.prev, _ = h.next.next;
          !gd(f, _) && Av(f, h, h.next, _) && Lf(f, _) && Lf(_, f) && (o.push(f.i, h.i, _.i), Rf(h), Rf(h.next), h = d = _), h = h.next;
        } while (h !== d);
        return Ch(h);
      }
      function xC(d, o, h, f, _, v) {
        let w = d;
        do {
          let P = w.next.next;
          for (; P !== w.prev; ) {
            if (w.i !== P.i && SC(w, P)) {
              let R = Tv(w, P);
              return w = Ch(w, w.next), R = Ch(R, R.next), If(w, o, h, f, _, v, 0), void If(R, o, h, f, _, v, 0);
            }
            P = P.next;
          }
          w = w.next;
        } while (w !== d);
      }
      function wC(d, o) {
        let h = d.x - o.x;
        return h === 0 && (h = d.y - o.y, h === 0) && (h = (d.next.y - d.y) / (d.next.x - d.x) - (o.next.y - o.y) / (o.next.x - o.x)), h;
      }
      function AC(d, o) {
        const h = function(_, v) {
          let w = v;
          const P = _.x, R = _.y;
          let D, z = -1 / 0;
          if (gd(_, w)) return w;
          do {
            if (gd(_, w.next)) return w.next;
            if (R <= w.y && R >= w.next.y && w.next.y !== w.y) {
              const se = w.x + (R - w.y) * (w.next.x - w.x) / (w.next.y - w.y);
              if (se <= P && se > z && (z = se, D = w.x < w.next.x ? w : w.next, se === P)) return D;
            }
            w = w.next;
          } while (w !== v);
          if (!D) return null;
          const j = D, Y = D.x, K = D.y;
          let Q = 1 / 0;
          w = D;
          do {
            if (P >= w.x && w.x >= Y && P !== w.x && wv(R < K ? P : z, R, Y, K, R < K ? z : P, R, w.x, w.y)) {
              const se = Math.abs(R - w.y) / (P - w.x);
              Lf(w, _) && (se < Q || se === Q && (w.x > D.x || w.x === D.x && TC(D, w))) && (D = w, Q = se);
            }
            w = w.next;
          } while (w !== j);
          return D;
        }(d, o);
        if (!h) return o;
        const f = Tv(h, d);
        return Ch(f, f.next), Ch(h, h.next);
      }
      function TC(d, o) {
        return Vr(d.prev, d, o.prev) < 0 && Vr(o.next, d, d.next) < 0;
      }
      function C_(d, o, h, f, _) {
        return (d = 1431655765 & ((d = 858993459 & ((d = 252645135 & ((d = 16711935 & ((d = (d - h) * _ | 0) | d << 8)) | d << 4)) | d << 2)) | d << 1)) | (o = 1431655765 & ((o = 858993459 & ((o = 252645135 & ((o = 16711935 & ((o = (o - f) * _ | 0) | o << 8)) | o << 4)) | o << 2)) | o << 1)) << 1;
      }
      function EC(d) {
        let o = d, h = d;
        do
          (o.x < h.x || o.x === h.x && o.y < h.y) && (h = o), o = o.next;
        while (o !== d);
        return h;
      }
      function wv(d, o, h, f, _, v, w, P) {
        return (_ - w) * (o - P) >= (d - w) * (v - P) && (d - w) * (f - P) >= (h - w) * (o - P) && (h - w) * (v - P) >= (_ - w) * (f - P);
      }
      function Mf(d, o, h, f, _, v, w, P) {
        return !(d === w && o === P) && wv(d, o, h, f, _, v, w, P);
      }
      function SC(d, o) {
        return d.next.i !== o.i && d.prev.i !== o.i && !function(h, f) {
          let _ = h;
          do {
            if (_.i !== h.i && _.next.i !== h.i && _.i !== f.i && _.next.i !== f.i && Av(_, _.next, h, f)) return !0;
            _ = _.next;
          } while (_ !== h);
          return !1;
        }(d, o) && (Lf(d, o) && Lf(o, d) && function(h, f) {
          let _ = h, v = !1;
          const w = (h.x + f.x) / 2, P = (h.y + f.y) / 2;
          do
            _.y > P != _.next.y > P && _.next.y !== _.y && w < (_.next.x - _.x) * (P - _.y) / (_.next.y - _.y) + _.x && (v = !v), _ = _.next;
          while (_ !== h);
          return v;
        }(d, o) && (Vr(d.prev, d, o.prev) || Vr(d, o.prev, o)) || gd(d, o) && Vr(d.prev, d, d.next) > 0 && Vr(o.prev, o, o.next) > 0);
      }
      function Vr(d, o, h) {
        return (o.y - d.y) * (h.x - o.x) - (o.x - d.x) * (h.y - o.y);
      }
      function gd(d, o) {
        return d.x === o.x && d.y === o.y;
      }
      function Av(d, o, h, f) {
        const _ = ag(Vr(d, o, h)), v = ag(Vr(d, o, f)), w = ag(Vr(h, f, d)), P = ag(Vr(h, f, o));
        return _ !== v && w !== P || !(_ !== 0 || !og(d, h, o)) || !(v !== 0 || !og(d, f, o)) || !(w !== 0 || !og(h, d, f)) || !(P !== 0 || !og(h, o, f));
      }
      function og(d, o, h) {
        return o.x <= Math.max(d.x, h.x) && o.x >= Math.min(d.x, h.x) && o.y <= Math.max(d.y, h.y) && o.y >= Math.min(d.y, h.y);
      }
      function ag(d) {
        return d > 0 ? 1 : d < 0 ? -1 : 0;
      }
      function Lf(d, o) {
        return Vr(d.prev, d, d.next) < 0 ? Vr(d, o, d.next) >= 0 && Vr(d, d.prev, o) >= 0 : Vr(d, o, d.prev) < 0 || Vr(d, d.next, o) < 0;
      }
      function Tv(d, o) {
        const h = P_(d.i, d.x, d.y), f = P_(o.i, o.x, o.y), _ = d.next, v = o.prev;
        return d.next = o, o.prev = d, h.next = _, _.prev = h, f.next = h, h.prev = f, v.next = f, f.prev = v, f;
      }
      function Ev(d, o, h, f) {
        const _ = P_(d, o, h);
        return f ? (_.next = f.next, _.prev = f, f.next.prev = _, f.next = _) : (_.prev = _, _.next = _), _;
      }
      function Rf(d) {
        d.next.prev = d.prev, d.prev.next = d.next, d.prevZ && (d.prevZ.nextZ = d.nextZ), d.nextZ && (d.nextZ.prevZ = d.prevZ);
      }
      function P_(d, o, h) {
        return { i: d, x: o, y: h, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: !1 };
      }
      class md {
        constructor(o, h) {
          if (h > o) throw new Error("Min granularity must not be greater than base granularity.");
          this._baseZoomGranularity = o, this._minGranularity = h;
        }
        getGranularityForZoomLevel(o) {
          return Math.max(Math.floor(this._baseZoomGranularity / (1 << o)), this._minGranularity, 1);
        }
      }
      class lg {
        constructor(o) {
          this.fill = o.fill, this.line = o.line, this.tile = o.tile, this.stencil = o.stencil, this.circle = o.circle;
        }
      }
      lg.noSubdivision = new lg({ fill: new md(0, 0), line: new md(0, 0), tile: new md(0, 0), stencil: new md(0, 0), circle: 1 }), vn("SubdivisionGranularityExpression", md), vn("SubdivisionGranularitySetting", lg);
      const _d = -32768, Bf = 32767;
      class CC {
        constructor(o, h) {
          this._vertexBuffer = [], this._vertexDictionary = /* @__PURE__ */ new Map(), this._used = !1, this._granularity = o, this._granularityCellSize = dt / o, this._canonical = h;
        }
        _getKey(o, h) {
          return (o += 32768) << 16 | (h += 32768) << 0;
        }
        _vertexToIndex(o, h) {
          if (o < -32768 || h < -32768 || o > 32767 || h > 32767) throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
          const f = 0 | Math.round(o), _ = 0 | Math.round(h), v = this._getKey(f, _);
          if (this._vertexDictionary.has(v)) return this._vertexDictionary.get(v);
          const w = this._vertexBuffer.length / 2;
          return this._vertexDictionary.set(v, w), this._vertexBuffer.push(f, _), w;
        }
        _subdivideTrianglesScanline(o) {
          if (this._granularity < 2) return function(_, v) {
            const w = [];
            for (let P = 0; P < v.length; P += 3) {
              const R = v[P], D = v[P + 1], z = v[P + 2], j = _[2 * R], Y = _[2 * R + 1];
              (_[2 * D] - j) * (_[2 * z + 1] - Y) - (_[2 * D + 1] - Y) * (_[2 * z] - j) > 0 ? (w.push(R), w.push(z), w.push(D)) : (w.push(R), w.push(D), w.push(z));
            }
            return w;
          }(this._vertexBuffer, o);
          const h = [], f = o.length;
          for (let _ = 0; _ < f; _ += 3) {
            const v = [o[_ + 0], o[_ + 1], o[_ + 2]], w = [this._vertexBuffer[2 * o[_ + 0] + 0], this._vertexBuffer[2 * o[_ + 0] + 1], this._vertexBuffer[2 * o[_ + 1] + 0], this._vertexBuffer[2 * o[_ + 1] + 1], this._vertexBuffer[2 * o[_ + 2] + 0], this._vertexBuffer[2 * o[_ + 2] + 1]];
            let P = 1 / 0, R = 1 / 0, D = -1 / 0, z = -1 / 0;
            for (let se = 0; se < 3; se++) {
              const Ee = w[2 * se], Se = w[2 * se + 1];
              P = Math.min(P, Ee), D = Math.max(D, Ee), R = Math.min(R, Se), z = Math.max(z, Se);
            }
            if (P === D || R === z) continue;
            const j = Math.floor(P / this._granularityCellSize), Y = Math.ceil(D / this._granularityCellSize), K = Math.floor(R / this._granularityCellSize), Q = Math.ceil(z / this._granularityCellSize);
            if (j !== Y || K !== Q) for (let se = K; se < Q; se++) {
              const Ee = this._scanlineGenerateVertexRingForCellRow(se, w, v);
              PC(this._vertexBuffer, Ee, h);
            }
            else h.push(...v);
          }
          return h;
        }
        _scanlineGenerateVertexRingForCellRow(o, h, f) {
          const _ = o * this._granularityCellSize, v = _ + this._granularityCellSize, w = [];
          for (let P = 0; P < 3; P++) {
            const R = h[2 * P], D = h[2 * P + 1], z = h[2 * (P + 1) % 6], j = h[(2 * (P + 1) + 1) % 6], Y = h[2 * (P + 2) % 6], K = h[(2 * (P + 2) + 1) % 6], Q = z - R, se = j - D, Ee = Q === 0, Se = se === 0, et = (_ - D) / se, Ne = (v - D) / se, J = Math.min(et, Ne), ve = Math.max(et, Ne);
            if (!Se && (J >= 1 || ve <= 0) || Se && (D < _ || D > v)) {
              j >= _ && j <= v && w.push(f[(P + 1) % 3]);
              continue;
            }
            !Se && J > 0 && w.push(this._vertexToIndex(R + Q * J, D + se * J));
            const je = R + Q * Math.max(J, 0), vt = R + Q * Math.min(ve, 1);
            Ee || this._generateIntraEdgeVertices(w, R, D, z, j, je, vt), !Se && ve < 1 && w.push(this._vertexToIndex(R + Q * ve, D + se * ve)), (Se || j >= _ && j <= v) && w.push(f[(P + 1) % 3]), !Se && (j <= _ || j >= v) && this._generateInterEdgeVertices(w, R, D, z, j, Y, K, vt, _, v);
          }
          return w;
        }
        _generateIntraEdgeVertices(o, h, f, _, v, w, P) {
          const R = _ - h, D = v - f, z = D === 0, j = z ? Math.min(h, _) : Math.min(w, P), Y = z ? Math.max(h, _) : Math.max(w, P), K = Math.floor(j / this._granularityCellSize) + 1, Q = Math.ceil(Y / this._granularityCellSize) - 1;
          if (z ? h < _ : w < P) for (let se = K; se <= Q; se++) {
            const Ee = se * this._granularityCellSize;
            o.push(this._vertexToIndex(Ee, f + D * (Ee - h) / R));
          }
          else for (let se = Q; se >= K; se--) {
            const Ee = se * this._granularityCellSize;
            o.push(this._vertexToIndex(Ee, f + D * (Ee - h) / R));
          }
        }
        _generateInterEdgeVertices(o, h, f, _, v, w, P, R, D, z) {
          const j = v - f, Y = w - _, K = P - v, Q = (D - v) / K, se = (z - v) / K, Ee = Math.min(Q, se), Se = Math.max(Q, se), et = _ + Y * Ee;
          let Ne = Math.floor(Math.min(et, R) / this._granularityCellSize) + 1, J = Math.ceil(Math.max(et, R) / this._granularityCellSize) - 1, ve = R < et;
          const je = K === 0;
          if (je && (P === D || P === z)) return;
          if (je || Ee >= 1 || Se <= 0) {
            const Vt = f - P, Et = w + (h - w) * Math.min((D - P) / Vt, (z - P) / Vt);
            Ne = Math.floor(Math.min(Et, R) / this._granularityCellSize) + 1, J = Math.ceil(Math.max(Et, R) / this._granularityCellSize) - 1, ve = R < Et;
          }
          const vt = j > 0 ? z : D;
          if (ve) for (let Vt = Ne; Vt <= J; Vt++) o.push(this._vertexToIndex(Vt * this._granularityCellSize, vt));
          else for (let Vt = J; Vt >= Ne; Vt--) o.push(this._vertexToIndex(Vt * this._granularityCellSize, vt));
        }
        _generateOutline(o) {
          const h = [];
          for (const f of o) {
            const _ = Ph(f, this._granularity, !0), v = this._pointArrayToIndices(_), w = [];
            for (let P = 1; P < v.length; P++) w.push(v[P - 1]), w.push(v[P]);
            h.push(w);
          }
          return h;
        }
        _handlePoles(o) {
          let h = !1, f = !1;
          this._canonical && (this._canonical.y === 0 && (h = !0), this._canonical.y === (1 << this._canonical.z) - 1 && (f = !0)), (h || f) && this._fillPoles(o, h, f);
        }
        _ensureNoPoleVertices() {
          const o = this._vertexBuffer;
          for (let h = 0; h < o.length; h += 2) {
            const f = o[h + 1];
            f === _d && (o[h + 1] = -32767), f === Bf && (o[h + 1] = 32766);
          }
        }
        _generatePoleQuad(o, h, f, _, v, w) {
          _ > v != (w === _d) ? (o.push(h), o.push(f), o.push(this._vertexToIndex(_, w)), o.push(f), o.push(this._vertexToIndex(v, w)), o.push(this._vertexToIndex(_, w))) : (o.push(f), o.push(h), o.push(this._vertexToIndex(_, w)), o.push(this._vertexToIndex(v, w)), o.push(f), o.push(this._vertexToIndex(_, w)));
        }
        _fillPoles(o, h, f) {
          const _ = this._vertexBuffer, v = dt, w = o.length;
          for (let P = 2; P < w; P += 3) {
            const R = o[P - 2], D = o[P - 1], z = o[P], j = _[2 * R], Y = _[2 * R + 1], K = _[2 * D], Q = _[2 * D + 1], se = _[2 * z], Ee = _[2 * z + 1];
            h && (Y === 0 && Q === 0 && this._generatePoleQuad(o, R, D, j, K, _d), Q === 0 && Ee === 0 && this._generatePoleQuad(o, D, z, K, se, _d), Ee === 0 && Y === 0 && this._generatePoleQuad(o, z, R, se, j, _d)), f && (Y === v && Q === v && this._generatePoleQuad(o, R, D, j, K, Bf), Q === v && Ee === v && this._generatePoleQuad(o, D, z, K, se, Bf), Ee === v && Y === v && this._generatePoleQuad(o, z, R, se, j, Bf));
          }
        }
        _initializeVertices(o) {
          for (let h = 0; h < o.length; h += 2) this._vertexToIndex(o[h], o[h + 1]);
        }
        subdividePolygonInternal(o, h) {
          if (this._used) throw new Error("Subdivision: multiple use not allowed.");
          this._used = !0;
          const { flattened: f, holeIndices: _ } = function(P) {
            const R = [], D = [];
            for (const z of P) if (z.length !== 0) {
              z !== P[0] && R.push(D.length / 2);
              for (let j = 0; j < z.length; j++) D.push(z[j].x), D.push(z[j].y);
            }
            return { flattened: D, holeIndices: R };
          }(o);
          let v;
          this._initializeVertices(f);
          try {
            const P = function(D, z) {
              let j = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 2;
              const Y = z && z.length, K = Y ? z[0] * j : D.length;
              let Q = xv(D, 0, K, j, !0);
              const se = [];
              if (!Q || Q.next === Q.prev) return se;
              let Ee, Se, et;
              if (Y && (Q = function(Ne, J, ve, je) {
                const vt = [];
                for (let Vt = 0, Et = J.length; Vt < Et; Vt++) {
                  const Lt = xv(Ne, J[Vt] * je, Vt < Et - 1 ? J[Vt + 1] * je : Ne.length, je, !1);
                  Lt === Lt.next && (Lt.steiner = !0), vt.push(EC(Lt));
                }
                vt.sort(wC);
                for (let Vt = 0; Vt < vt.length; Vt++) ve = AC(vt[Vt], ve);
                return ve;
              }(D, z, Q, j)), D.length > 80 * j) {
                Ee = 1 / 0, Se = 1 / 0;
                let Ne = -1 / 0, J = -1 / 0;
                for (let ve = j; ve < K; ve += j) {
                  const je = D[ve], vt = D[ve + 1];
                  je < Ee && (Ee = je), vt < Se && (Se = vt), je > Ne && (Ne = je), vt > J && (J = vt);
                }
                et = Math.max(Ne - Ee, J - Se), et = et !== 0 ? 32767 / et : 0;
              }
              return If(Q, se, j, Ee, Se, et, 0), se;
            }(f, _), R = this._convertIndices(f, P);
            v = this._subdivideTrianglesScanline(R);
          } catch (P) {
            console.error(P);
          }
          let w = [];
          return h && (w = this._generateOutline(o)), this._ensureNoPoleVertices(), this._handlePoles(v), { verticesFlattened: this._vertexBuffer, indicesTriangles: v, indicesLineList: w };
        }
        _convertIndices(o, h) {
          const f = [];
          for (let _ = 0; _ < h.length; _++) f.push(this._vertexToIndex(o[2 * h[_]], o[2 * h[_] + 1]));
          return f;
        }
        _pointArrayToIndices(o) {
          const h = [];
          for (let f = 0; f < o.length; f++) {
            const _ = o[f];
            h.push(this._vertexToIndex(_.x, _.y));
          }
          return h;
        }
      }
      function Sv(d, o, h) {
        let f = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0;
        return new CC(h, o).subdividePolygonInternal(d, f);
      }
      function Ph(d, o) {
        let h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        if (!d || d.length < 1) return [];
        if (d.length < 2) return [];
        const f = d[0], _ = d[d.length - 1], v = h && (f.x !== _.x || f.y !== _.y);
        if (o < 2) return v ? [...d, d[0]] : [...d];
        const w = Math.floor(dt / o), P = [];
        P.push(new F(d[0].x, d[0].y));
        const R = d.length, D = v ? R : R - 1;
        for (let z = 0; z < D; z++) {
          const j = d[z], Y = z < R - 1 ? d[z + 1] : d[0], K = j.x, Q = j.y, se = Y.x, Ee = Y.y, Se = K !== se, et = Q !== Ee;
          if (!Se && !et) continue;
          const Ne = se - K, J = Ee - Q, ve = Math.abs(Ne), je = Math.abs(J);
          let vt = K, Vt = Q;
          for (; ; ) {
            const Lt = Ne > 0 ? (Math.floor(vt / w) + 1) * w : (Math.ceil(vt / w) - 1) * w, Qt = J > 0 ? (Math.floor(Vt / w) + 1) * w : (Math.ceil(Vt / w) - 1) * w, Ht = Math.abs(vt - Lt), rn = Math.abs(Vt - Qt), Dt = Math.abs(vt - se), Cn = Math.abs(Vt - Ee), zn = Se ? Ht / ve : Number.POSITIVE_INFINITY, Dn = et ? rn / je : Number.POSITIVE_INFINITY;
            if ((Dt <= Ht || !Se) && (Cn <= rn || !et)) break;
            if (zn < Dn && Se || !et) {
              vt = Lt, Vt += J * zn;
              const Pn = new F(vt, Math.round(Vt));
              P[P.length - 1].x === Pn.x && P[P.length - 1].y === Pn.y || P.push(Pn);
            } else {
              vt += Ne * Dn, Vt = Qt;
              const Pn = new F(Math.round(vt), Vt);
              P[P.length - 1].x === Pn.x && P[P.length - 1].y === Pn.y || P.push(Pn);
            }
          }
          const Et = new F(se, Ee);
          P[P.length - 1].x === Et.x && P[P.length - 1].y === Et.y || P.push(Et);
        }
        return P;
      }
      function PC(d, o, h) {
        if (o.length === 0) throw new Error("Subdivision vertex ring is empty.");
        let f = 0, _ = d[2 * o[0]];
        for (let R = 1; R < o.length; R++) {
          const D = d[2 * o[R]];
          D < _ && (_ = D, f = R);
        }
        const v = o.length;
        let w = f, P = (w + 1) % v;
        for (; ; ) {
          const R = w - 1 >= 0 ? w - 1 : v - 1, D = (P + 1) % v, z = d[2 * o[R]], j = d[2 * o[D]], Y = d[2 * o[w]], K = d[2 * o[w] + 1], Q = d[2 * o[P] + 1];
          let se = !1;
          if (z < j) se = !0;
          else if (z > j) se = !1;
          else {
            const Ee = Q - K, Se = -(d[2 * o[P]] - Y), et = K < Q ? 1 : -1;
            ((z - Y) * Ee + (d[2 * o[R] + 1] - K) * Se) * et > ((j - Y) * Ee + (d[2 * o[D] + 1] - K) * Se) * et && (se = !0);
          }
          if (se) {
            const Ee = o[R], Se = o[w], et = o[P];
            Ee !== Se && Ee !== et && Se !== et && h.push(et, Se, Ee), w--, w < 0 && (w = v - 1);
          } else {
            const Ee = o[D], Se = o[w], et = o[P];
            Ee !== Se && Ee !== et && Se !== et && h.push(et, Se, Ee), P++, P >= v && (P = 0);
          }
          if (R === D) break;
        }
      }
      function Cv(d, o, h, f, _, v, w, P, R) {
        const D = _.length / 2, z = w && P && R;
        if (D < dn.MAX_VERTEX_ARRAY_LENGTH) {
          const j = o.prepareSegment(D, h, f), Y = j.vertexLength;
          for (let se = 0; se < v.length; se += 3) f.emplaceBack(Y + v[se], Y + v[se + 1], Y + v[se + 2]);
          let K, Q;
          j.vertexLength += D, j.primitiveLength += v.length / 3, z && (Q = w.prepareSegment(D, h, P), K = Q.vertexLength, Q.vertexLength += D);
          for (let se = 0; se < _.length; se += 2) d(_[se], _[se + 1]);
          if (z) for (let se = 0; se < R.length; se++) {
            const Ee = R[se];
            for (let Se = 1; Se < Ee.length; Se += 2) P.emplaceBack(K + Ee[Se - 1], K + Ee[Se]);
            Q.primitiveLength += Ee.length / 2;
          }
        } else (function(j, Y, K, Q, se, Ee) {
          const Se = [];
          for (let je = 0; je < Q.length / 2; je++) Se.push(-1);
          const et = { count: 0 };
          let Ne = 0, J = j.getOrCreateLatestSegment(Y, K), ve = J.vertexLength;
          for (let je = 2; je < se.length; je += 3) {
            const vt = se[je - 2], Vt = se[je - 1], Et = se[je];
            let Lt = Se[vt] < Ne, Qt = Se[Vt] < Ne, Ht = Se[Et] < Ne;
            J.vertexLength + ((Lt ? 1 : 0) + (Qt ? 1 : 0) + (Ht ? 1 : 0)) > dn.MAX_VERTEX_ARRAY_LENGTH && (J = j.createNewSegment(Y, K), Ne = et.count, Lt = !0, Qt = !0, Ht = !0, ve = 0);
            const rn = Of(Se, Q, Ee, et, vt, Lt, J), Dt = Of(Se, Q, Ee, et, Vt, Qt, J), Cn = Of(Se, Q, Ee, et, Et, Ht, J);
            K.emplaceBack(ve + rn - Ne, ve + Dt - Ne, ve + Cn - Ne), J.primitiveLength++;
          }
        })(o, h, f, _, v, d), z && function(j, Y, K, Q, se, Ee) {
          const Se = [];
          for (let je = 0; je < Q.length / 2; je++) Se.push(-1);
          const et = { count: 0 };
          let Ne = 0, J = j.getOrCreateLatestSegment(Y, K), ve = J.vertexLength;
          for (let je = 0; je < se.length; je++) {
            const vt = se[je];
            for (let Vt = 1; Vt < se[je].length; Vt += 2) {
              const Et = vt[Vt - 1], Lt = vt[Vt];
              let Qt = Se[Et] < Ne, Ht = Se[Lt] < Ne;
              J.vertexLength + ((Qt ? 1 : 0) + (Ht ? 1 : 0)) > dn.MAX_VERTEX_ARRAY_LENGTH && (J = j.createNewSegment(Y, K), Ne = et.count, Qt = !0, Ht = !0, ve = 0);
              const rn = Of(Se, Q, Ee, et, Et, Qt, J), Dt = Of(Se, Q, Ee, et, Lt, Ht, J);
              K.emplaceBack(ve + rn - Ne, ve + Dt - Ne), J.primitiveLength++;
            }
          }
        }(w, h, P, _, R, d), o.forceNewSegmentOnNextPrepare(), w == null || w.forceNewSegmentOnNextPrepare();
      }
      function Of(d, o, h, f, _, v, w) {
        if (v) {
          const P = f.count;
          return h(o[2 * _], o[2 * _ + 1]), d[_] = f.count, f.count++, w.vertexLength++, P;
        }
        return d[_];
      }
      class I_ {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((h) => h.id), this.index = o.index, this.hasPattern = !1, this.patternFeatures = [], this.layoutVertexArray = new Be(), this.indexArray = new Ct(), this.indexArray2 = new sn(), this.programConfigurations = new wr(o.layers, o.zoom), this.segments = new dn(), this.segments2 = new dn(), this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
        }
        populate(o, h, f) {
          this.hasPattern = E_("fill", this.layers, h);
          const _ = this.layers[0].layout.get("fill-sort-key"), v = !_.isConstant(), w = [];
          for (const { feature: P, id: R, index: D, sourceLayerIndex: z } of o) {
            const j = this.layers[0]._featureFilter.needGeometry, Y = bu(P, j);
            if (!this.layers[0]._featureFilter.filter(new ut(this.zoom), Y, f)) continue;
            const K = v ? _.evaluate(Y, {}, f, h.availableImages) : void 0, Q = { id: R, properties: P.properties, type: P.type, sourceLayerIndex: z, index: D, geometry: j ? Y.geometry : yu(P), patterns: {}, sortKey: K };
            w.push(Q);
          }
          v && w.sort((P, R) => P.sortKey - R.sortKey);
          for (const P of w) {
            const { geometry: R, index: D, sourceLayerIndex: z } = P;
            if (this.hasPattern) {
              const j = S_("fill", this.layers, P, this.zoom, h);
              this.patternFeatures.push(j);
            } else this.addFeature(P, R, D, f, {}, h.subdivisionGranularity);
            h.featureIndex.insert(o[D].feature, R, D, z, this.index);
          }
        }
        update(o, h, f) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, h, this.stateDependentLayers, f);
        }
        addFeatures(o, h, f) {
          for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, h, f, o.subdivisionGranularity);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, _C), this.indexBuffer = o.createIndexBuffer(this.indexArray), this.indexBuffer2 = o.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
        }
        addFeature(o, h, f, _, v, w) {
          for (const P of Bs(h, 500)) {
            const R = Sv(P, _, w.fill.getGranularityForZoomLevel(_.z)), D = this.layoutVertexArray;
            Cv((z, j) => {
              D.emplaceBack(z, j);
            }, this.segments, this.layoutVertexArray, this.indexArray, R.verticesFlattened, R.indicesTriangles, this.segments2, this.indexArray2, R.indicesLineList);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, f, v, _);
        }
      }
      let Pv, Iv;
      vn("FillBucket", I_, { omit: ["layers", "patternFeatures"] });
      var IC = { get paint() {
        return Iv = Iv || new ri({ "fill-antialias": new ft(be.paint_fill["fill-antialias"]), "fill-opacity": new Ut(be.paint_fill["fill-opacity"]), "fill-color": new Ut(be.paint_fill["fill-color"]), "fill-outline-color": new Ut(be.paint_fill["fill-outline-color"]), "fill-translate": new ft(be.paint_fill["fill-translate"]), "fill-translate-anchor": new ft(be.paint_fill["fill-translate-anchor"]), "fill-pattern": new yn(be.paint_fill["fill-pattern"]) });
      }, get layout() {
        return Pv = Pv || new ri({ "fill-sort-key": new Ut(be.layout_fill["fill-sort-key"]) });
      } };
      class MC extends ai {
        constructor(o) {
          super(o, IC);
        }
        recalculate(o, h) {
          super.recalculate(o, h);
          const f = this.paint._values["fill-outline-color"];
          f.value.kind === "constant" && f.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
        }
        createBucket(o) {
          return new I_(o);
        }
        queryRadius() {
          return rg(this.paint.get("fill-translate"));
        }
        queryIntersectsFeature(o) {
          let { queryGeometry: h, geometry: f, transform: _, pixelsToTileUnits: v } = o;
          return Ef(sg(h, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -_.bearingInRadians, v), f);
        }
        isTileClipped() {
          return !0;
        }
      }
      const LC = Bn([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), RC = Bn([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: BC } = LC;
      var M_, Mv, L_, Lv, R_, Rv, Bv, cg = {};
      function Ov() {
        if (Mv) return M_;
        Mv = 1;
        var d = C();
        function o(_, v, w, P, R) {
          this.properties = {}, this.extent = w, this.type = 0, this._pbf = _, this._geometry = -1, this._keys = P, this._values = R, _.readFields(h, this, v);
        }
        function h(_, v, w) {
          _ == 1 ? v.id = w.readVarint() : _ == 2 ? function(P, R) {
            for (var D = P.readVarint() + P.pos; P.pos < D; ) {
              var z = R._keys[P.readVarint()], j = R._values[P.readVarint()];
              R.properties[z] = j;
            }
          }(w, v) : _ == 3 ? v.type = w.readVarint() : _ == 4 && (v._geometry = w.pos);
        }
        function f(_) {
          for (var v, w, P = 0, R = 0, D = _.length, z = D - 1; R < D; z = R++) P += ((w = _[z]).x - (v = _[R]).x) * (v.y + w.y);
          return P;
        }
        return M_ = o, o.types = ["Unknown", "Point", "LineString", "Polygon"], o.prototype.loadGeometry = function() {
          var _ = this._pbf;
          _.pos = this._geometry;
          for (var v, w = _.readVarint() + _.pos, P = 1, R = 0, D = 0, z = 0, j = []; _.pos < w; ) {
            if (R <= 0) {
              var Y = _.readVarint();
              P = 7 & Y, R = Y >> 3;
            }
            if (R--, P === 1 || P === 2) D += _.readSVarint(), z += _.readSVarint(), P === 1 && (v && j.push(v), v = []), v.push(new d(D, z));
            else {
              if (P !== 7) throw new Error("unknown command " + P);
              v && v.push(v[0].clone());
            }
          }
          return v && j.push(v), j;
        }, o.prototype.bbox = function() {
          var _ = this._pbf;
          _.pos = this._geometry;
          for (var v = _.readVarint() + _.pos, w = 1, P = 0, R = 0, D = 0, z = 1 / 0, j = -1 / 0, Y = 1 / 0, K = -1 / 0; _.pos < v; ) {
            if (P <= 0) {
              var Q = _.readVarint();
              w = 7 & Q, P = Q >> 3;
            }
            if (P--, w === 1 || w === 2) (R += _.readSVarint()) < z && (z = R), R > j && (j = R), (D += _.readSVarint()) < Y && (Y = D), D > K && (K = D);
            else if (w !== 7) throw new Error("unknown command " + w);
          }
          return [z, Y, j, K];
        }, o.prototype.toGeoJSON = function(_, v, w) {
          var P, R, D = this.extent * Math.pow(2, w), z = this.extent * _, j = this.extent * v, Y = this.loadGeometry(), K = o.types[this.type];
          function Q(Se) {
            for (var et = 0; et < Se.length; et++) {
              var Ne = Se[et];
              Se[et] = [360 * (Ne.x + z) / D - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (Ne.y + j) / D) * Math.PI / 180)) - 90];
            }
          }
          switch (this.type) {
            case 1:
              var se = [];
              for (P = 0; P < Y.length; P++) se[P] = Y[P][0];
              Q(Y = se);
              break;
            case 2:
              for (P = 0; P < Y.length; P++) Q(Y[P]);
              break;
            case 3:
              for (Y = function(Se) {
                var et = Se.length;
                if (et <= 1) return [Se];
                for (var Ne, J, ve = [], je = 0; je < et; je++) {
                  var vt = f(Se[je]);
                  vt !== 0 && (J === void 0 && (J = vt < 0), J === vt < 0 ? (Ne && ve.push(Ne), Ne = [Se[je]]) : Ne.push(Se[je]));
                }
                return Ne && ve.push(Ne), ve;
              }(Y), P = 0; P < Y.length; P++) for (R = 0; R < Y[P].length; R++) Q(Y[P][R]);
          }
          Y.length === 1 ? Y = Y[0] : K = "Multi" + K;
          var Ee = { type: "Feature", geometry: { type: K, coordinates: Y }, properties: this.properties };
          return "id" in this && (Ee.id = this.id), Ee;
        }, M_;
      }
      function Dv() {
        if (Lv) return L_;
        Lv = 1;
        var d = Ov();
        function o(f, _) {
          this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = f, this._keys = [], this._values = [], this._features = [], f.readFields(h, this, _), this.length = this._features.length;
        }
        function h(f, _, v) {
          f === 15 ? _.version = v.readVarint() : f === 1 ? _.name = v.readString() : f === 5 ? _.extent = v.readVarint() : f === 2 ? _._features.push(v.pos) : f === 3 ? _._keys.push(v.readString()) : f === 4 && _._values.push(function(w) {
            for (var P = null, R = w.readVarint() + w.pos; w.pos < R; ) {
              var D = w.readVarint() >> 3;
              P = D === 1 ? w.readString() : D === 2 ? w.readFloat() : D === 3 ? w.readDouble() : D === 4 ? w.readVarint64() : D === 5 ? w.readVarint() : D === 6 ? w.readSVarint() : D === 7 ? w.readBoolean() : null;
            }
            return P;
          }(v));
        }
        return L_ = o, o.prototype.feature = function(f) {
          if (f < 0 || f >= this._features.length) throw new Error("feature index out of bounds");
          this._pbf.pos = this._features[f];
          var _ = this._pbf.readVarint() + this._pbf.pos;
          return new d(this._pbf, _, this.extent, this._keys, this._values);
        }, L_;
      }
      function Fv() {
        return Bv || (Bv = 1, cg.VectorTile = function() {
          if (Rv) return R_;
          Rv = 1;
          var d = Dv();
          function o(h, f, _) {
            if (h === 3) {
              var v = new d(_, _.readVarint() + _.pos);
              v.length && (f[v.name] = v);
            }
          }
          return R_ = function(h, f) {
            this.layers = h.readFields(o, {}, f);
          }, R_;
        }(), cg.VectorTileFeature = Ov(), cg.VectorTileLayer = Dv()), cg;
      }
      var Df = g(Fv());
      const OC = Df.VectorTileFeature.types, B_ = Math.pow(2, 13);
      function Ff(d, o, h, f, _, v, w, P) {
        d.emplaceBack(o, h, 2 * Math.floor(f * B_) + w, _ * B_ * 2, v * B_ * 2, Math.round(P));
      }
      class O_ {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((h) => h.id), this.index = o.index, this.hasPattern = !1, this.layoutVertexArray = new He(), this.centroidVertexArray = new Ce(), this.indexArray = new Ct(), this.programConfigurations = new wr(o.layers, o.zoom), this.segments = new dn(), this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
        }
        populate(o, h, f) {
          this.features = [], this.hasPattern = E_("fill-extrusion", this.layers, h);
          for (const { feature: _, id: v, index: w, sourceLayerIndex: P } of o) {
            const R = this.layers[0]._featureFilter.needGeometry, D = bu(_, R);
            if (!this.layers[0]._featureFilter.filter(new ut(this.zoom), D, f)) continue;
            const z = { id: v, sourceLayerIndex: P, index: w, geometry: R ? D.geometry : yu(_), properties: _.properties, type: _.type, patterns: {} };
            this.hasPattern ? this.features.push(S_("fill-extrusion", this.layers, z, this.zoom, h)) : this.addFeature(z, z.geometry, w, f, {}, h.subdivisionGranularity), h.featureIndex.insert(_, z.geometry, w, P, this.index, !0);
          }
        }
        addFeatures(o, h, f) {
          for (const _ of this.features) {
            const { geometry: v } = _;
            this.addFeature(_, v, _.index, h, f, o.subdivisionGranularity);
          }
        }
        update(o, h, f) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, h, this.stateDependentLayers, f);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, BC), this.centroidVertexBuffer = o.createVertexBuffer(this.centroidVertexArray, RC.members, !0), this.indexBuffer = o.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
        }
        addFeature(o, h, f, _, v, w) {
          for (const P of Bs(h, 500)) {
            const R = { x: 0, y: 0, sampleCount: 0 }, D = this.layoutVertexArray.length;
            this.processPolygon(R, _, o, P, w);
            const z = this.layoutVertexArray.length - D, j = Math.floor(R.x / R.sampleCount), Y = Math.floor(R.y / R.sampleCount);
            for (let K = 0; K < z; K++) this.centroidVertexArray.emplaceBack(j, Y);
          }
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, f, v, _);
        }
        processPolygon(o, h, f, _, v) {
          if (_.length < 1 || Nv(_[0])) return;
          for (const j of _) j.length !== 0 && DC(o, j);
          const w = { segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray) }, P = v.fill.getGranularityForZoomLevel(h.z), R = OC[f.type] === "Polygon";
          for (const j of _) {
            if (j.length === 0 || Nv(j)) continue;
            const Y = Ph(j, P, R);
            this._generateSideFaces(Y, w);
          }
          if (!R) return;
          const D = Sv(_, h, P, !1), z = this.layoutVertexArray;
          Cv((j, Y) => {
            Ff(z, j, Y, 0, 0, 1, 1, 0);
          }, this.segments, this.layoutVertexArray, this.indexArray, D.verticesFlattened, D.indicesTriangles);
        }
        _generateSideFaces(o, h) {
          let f = 0;
          for (let _ = 1; _ < o.length; _++) {
            const v = o[_], w = o[_ - 1];
            if (FC(v, w)) continue;
            h.segment.vertexLength + 4 > dn.MAX_VERTEX_ARRAY_LENGTH && (h.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
            const P = v.sub(w)._perp()._unit(), R = w.dist(v);
            f + R > 32768 && (f = 0), Ff(this.layoutVertexArray, v.x, v.y, P.x, P.y, 0, 0, f), Ff(this.layoutVertexArray, v.x, v.y, P.x, P.y, 0, 1, f), f += R, Ff(this.layoutVertexArray, w.x, w.y, P.x, P.y, 0, 0, f), Ff(this.layoutVertexArray, w.x, w.y, P.x, P.y, 0, 1, f);
            const D = h.segment.vertexLength;
            this.indexArray.emplaceBack(D, D + 2, D + 1), this.indexArray.emplaceBack(D + 1, D + 2, D + 3), h.segment.vertexLength += 4, h.segment.primitiveLength += 2;
          }
        }
      }
      function DC(d, o) {
        for (let h = 0; h < o.length; h++) {
          const f = o[h];
          h === o.length - 1 && o[0].x === f.x && o[0].y === f.y || (d.x += f.x, d.y += f.y, d.sampleCount++);
        }
      }
      function FC(d, o) {
        return d.x === o.x && (d.x < 0 || d.x > dt) || d.y === o.y && (d.y < 0 || d.y > dt);
      }
      function Nv(d) {
        return d.every((o) => o.x < 0) || d.every((o) => o.x > dt) || d.every((o) => o.y < 0) || d.every((o) => o.y > dt);
      }
      let kv;
      vn("FillExtrusionBucket", O_, { omit: ["layers", "features"] });
      var NC = { get paint() {
        return kv = kv || new ri({ "fill-extrusion-opacity": new ft(be["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new Ut(be["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new ft(be["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new ft(be["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new yn(be["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new Ut(be["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new Ut(be["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new ft(be["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
      } };
      class kC extends ai {
        constructor(o) {
          super(o, NC);
        }
        createBucket(o) {
          return new O_(o);
        }
        queryRadius() {
          return rg(this.paint.get("fill-extrusion-translate"));
        }
        is3D() {
          return !0;
        }
        queryIntersectsFeature(o) {
          let { queryGeometry: h, feature: f, featureState: _, geometry: v, transform: w, pixelsToTileUnits: P, pixelPosMatrix: R } = o;
          const D = sg(h, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -w.bearingInRadians, P), z = this.paint.get("fill-extrusion-height").evaluate(f, _), j = this.paint.get("fill-extrusion-base").evaluate(f, _), Y = function(Q, se, Ee) {
            const Se = [];
            for (const et of Q) {
              const Ne = [et.x, et.y, 0, 1];
              _e(Ne, Ne, se), Se.push(new F(Ne[0] / Ne[3], Ne[1] / Ne[3]));
            }
            return Se;
          }(D, R), K = function(Q, se, Ee, Se) {
            const et = [], Ne = [], J = Se[8] * se, ve = Se[9] * se, je = Se[10] * se, vt = Se[11] * se, Vt = Se[8] * Ee, Et = Se[9] * Ee, Lt = Se[10] * Ee, Qt = Se[11] * Ee;
            for (const Ht of Q) {
              const rn = [], Dt = [];
              for (const Cn of Ht) {
                const zn = Cn.x, Dn = Cn.y, Pn = Se[0] * zn + Se[4] * Dn + Se[12], vi = Se[1] * zn + Se[5] * Dn + Se[13], Rr = Se[2] * zn + Se[6] * Dn + Se[14], Kr = Se[3] * zn + Se[7] * Dn + Se[15], Fo = Rr + je, oa = Kr + vt, aa = Pn + Vt, zs = vi + Et, Ur = Rr + Lt, ms = Kr + Qt, Us = new F((Pn + J) / oa, (vi + ve) / oa);
                Us.z = Fo / oa, rn.push(Us);
                const Qr = new F(aa / ms, zs / ms);
                Qr.z = Ur / ms, Dt.push(Qr);
              }
              et.push(rn), Ne.push(Dt);
            }
            return [et, Ne];
          }(v, j, z, R);
          return function(Q, se, Ee) {
            let Se = 1 / 0;
            Ef(Ee, se) && (Se = zv(Ee, se[0]));
            for (let et = 0; et < se.length; et++) {
              const Ne = se[et], J = Q[et];
              for (let ve = 0; ve < Ne.length - 1; ve++) {
                const je = Ne[ve], vt = [je, Ne[ve + 1], J[ve + 1], J[ve], je];
                Af(Ee, vt) && (Se = Math.min(Se, zv(Ee, vt)));
              }
            }
            return Se !== 1 / 0 && Se;
          }(K[0], K[1], Y);
        }
      }
      function Nf(d, o) {
        return d.x * o.x + d.y * o.y;
      }
      function zv(d, o) {
        if (d.length === 1) {
          let h = 0;
          const f = o[h++];
          let _;
          for (; !_ || f.equals(_); ) if (_ = o[h++], !_) return 1 / 0;
          for (; h < o.length; h++) {
            const v = o[h], w = d[0], P = _.sub(f), R = v.sub(f), D = w.sub(f), z = Nf(P, P), j = Nf(P, R), Y = Nf(R, R), K = Nf(D, P), Q = Nf(D, R), se = z * Y - j * j, Ee = (Y * K - j * Q) / se, Se = (z * Q - j * K) / se, et = f.z * (1 - Ee - Se) + _.z * Ee + v.z * Se;
            if (isFinite(et)) return et;
          }
          return 1 / 0;
        }
        {
          let h = 1 / 0;
          for (const f of o) h = Math.min(h, f.z);
          return h;
        }
      }
      const zC = Bn([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: UC } = zC, jC = Bn([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: GC } = jC, VC = Df.VectorTileFeature.types, qC = Math.cos(Math.PI / 180 * 37.5), Uv = Math.pow(2, 14) / 0.5;
      class D_ {
        constructor(o) {
          this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((h) => h.id), this.index = o.index, this.hasPattern = !1, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((h) => {
            this.gradients[h.id] = {};
          }), this.layoutVertexArray = new We(), this.layoutVertexArray2 = new $e(), this.indexArray = new Ct(), this.programConfigurations = new wr(o.layers, o.zoom), this.segments = new dn(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((h) => h.isStateDependent()).map((h) => h.id);
        }
        populate(o, h, f) {
          this.hasPattern = E_("line", this.layers, h);
          const _ = this.layers[0].layout.get("line-sort-key"), v = !_.isConstant(), w = [];
          for (const { feature: P, id: R, index: D, sourceLayerIndex: z } of o) {
            const j = this.layers[0]._featureFilter.needGeometry, Y = bu(P, j);
            if (!this.layers[0]._featureFilter.filter(new ut(this.zoom), Y, f)) continue;
            const K = v ? _.evaluate(Y, {}, f) : void 0, Q = { id: R, properties: P.properties, type: P.type, sourceLayerIndex: z, index: D, geometry: j ? Y.geometry : yu(P), patterns: {}, sortKey: K };
            w.push(Q);
          }
          v && w.sort((P, R) => P.sortKey - R.sortKey);
          for (const P of w) {
            const { geometry: R, index: D, sourceLayerIndex: z } = P;
            if (this.hasPattern) {
              const j = S_("line", this.layers, P, this.zoom, h);
              this.patternFeatures.push(j);
            } else this.addFeature(P, R, D, f, {}, h.subdivisionGranularity);
            h.featureIndex.insert(o[D].feature, R, D, z, this.index);
          }
        }
        update(o, h, f) {
          this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(o, h, this.stateDependentLayers, f);
        }
        addFeatures(o, h, f) {
          for (const _ of this.patternFeatures) this.addFeature(_, _.geometry, _.index, h, f, o.subdivisionGranularity);
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0;
        }
        uploadPending() {
          return !this.uploaded || this.programConfigurations.needsUpload;
        }
        upload(o) {
          this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = o.createVertexBuffer(this.layoutVertexArray2, GC)), this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, UC), this.indexBuffer = o.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(o), this.uploaded = !0;
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
        }
        lineFeatureClips(o) {
          if (o.properties && Object.prototype.hasOwnProperty.call(o.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(o.properties, "mapbox_clip_end")) return { start: +o.properties.mapbox_clip_start, end: +o.properties.mapbox_clip_end };
        }
        addFeature(o, h, f, _, v, w) {
          const P = this.layers[0].layout, R = P.get("line-join").evaluate(o, {}), D = P.get("line-cap"), z = P.get("line-miter-limit"), j = P.get("line-round-limit");
          this.lineClips = this.lineFeatureClips(o);
          for (const Y of h) this.addLine(Y, o, R, D, z, j, _, w);
          this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, o, f, v, _);
        }
        addLine(o, h, f, _, v, w, P, R) {
          if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, o = Ph(o, P ? R.line.getGranularityForZoomLevel(P.z) : 1), this.lineClips) {
            this.lineClipsArray.push(this.lineClips);
            for (let Ne = 0; Ne < o.length - 1; Ne++) this.totalDistance += o[Ne].dist(o[Ne + 1]);
            this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
          }
          const D = VC[h.type] === "Polygon";
          let z = o.length;
          for (; z >= 2 && o[z - 1].equals(o[z - 2]); ) z--;
          let j = 0;
          for (; j < z - 1 && o[j].equals(o[j + 1]); ) j++;
          if (z < (D ? 3 : 2)) return;
          f === "bevel" && (v = 1.05);
          const Y = this.overscaling <= 16 ? 15 * dt / (512 * this.overscaling) : 0, K = this.segments.prepareSegment(10 * z, this.layoutVertexArray, this.indexArray);
          let Q, se, Ee, Se, et;
          this.e1 = this.e2 = -1, D && (Q = o[z - 2], et = o[j].sub(Q)._unit()._perp());
          for (let Ne = j; Ne < z; Ne++) {
            if (Ee = Ne === z - 1 ? D ? o[j + 1] : void 0 : o[Ne + 1], Ee && o[Ne].equals(Ee)) continue;
            et && (Se = et), Q && (se = Q), Q = o[Ne], et = Ee ? Ee.sub(Q)._unit()._perp() : Se, Se = Se || et;
            let J = Se.add(et);
            J.x === 0 && J.y === 0 || J._unit();
            const ve = Se.x * et.x + Se.y * et.y, je = J.x * et.x + J.y * et.y, vt = je !== 0 ? 1 / je : 1 / 0, Vt = 2 * Math.sqrt(2 - 2 * je), Et = je < qC && se && Ee, Lt = Se.x * et.y - Se.y * et.x > 0;
            if (Et && Ne > j) {
              const rn = Q.dist(se);
              if (rn > 2 * Y) {
                const Dt = Q.sub(Q.sub(se)._mult(Y / rn)._round());
                this.updateDistance(se, Dt), this.addCurrentVertex(Dt, Se, 0, 0, K), se = Dt;
              }
            }
            const Qt = se && Ee;
            let Ht = Qt ? f : D ? "butt" : _;
            if (Qt && Ht === "round" && (vt < w ? Ht = "miter" : vt <= 2 && (Ht = "fakeround")), Ht === "miter" && vt > v && (Ht = "bevel"), Ht === "bevel" && (vt > 2 && (Ht = "flipbevel"), vt < v && (Ht = "miter")), se && this.updateDistance(se, Q), Ht === "miter") J._mult(vt), this.addCurrentVertex(Q, J, 0, 0, K);
            else if (Ht === "flipbevel") {
              if (vt > 100) J = et.mult(-1);
              else {
                const rn = vt * Se.add(et).mag() / Se.sub(et).mag();
                J._perp()._mult(rn * (Lt ? -1 : 1));
              }
              this.addCurrentVertex(Q, J, 0, 0, K), this.addCurrentVertex(Q, J.mult(-1), 0, 0, K);
            } else if (Ht === "bevel" || Ht === "fakeround") {
              const rn = -Math.sqrt(vt * vt - 1), Dt = Lt ? rn : 0, Cn = Lt ? 0 : rn;
              if (se && this.addCurrentVertex(Q, Se, Dt, Cn, K), Ht === "fakeround") {
                const zn = Math.round(180 * Vt / Math.PI / 20);
                for (let Dn = 1; Dn < zn; Dn++) {
                  let Pn = Dn / zn;
                  if (Pn !== 0.5) {
                    const Rr = Pn - 0.5;
                    Pn += Pn * Rr * (Pn - 1) * ((1.0904 + ve * (ve * (3.55645 - 1.43519 * ve) - 3.2452)) * Rr * Rr + (0.848013 + ve * (0.215638 * ve - 1.06021)));
                  }
                  const vi = et.sub(Se)._mult(Pn)._add(Se)._unit()._mult(Lt ? -1 : 1);
                  this.addHalfVertex(Q, vi.x, vi.y, !1, Lt, 0, K);
                }
              }
              Ee && this.addCurrentVertex(Q, et, -Dt, -Cn, K);
            } else if (Ht === "butt") this.addCurrentVertex(Q, J, 0, 0, K);
            else if (Ht === "square") {
              const rn = se ? 1 : -1;
              this.addCurrentVertex(Q, J, rn, rn, K);
            } else Ht === "round" && (se && (this.addCurrentVertex(Q, Se, 0, 0, K), this.addCurrentVertex(Q, Se, 1, 1, K, !0)), Ee && (this.addCurrentVertex(Q, et, -1, -1, K, !0), this.addCurrentVertex(Q, et, 0, 0, K)));
            if (Et && Ne < z - 1) {
              const rn = Q.dist(Ee);
              if (rn > 2 * Y) {
                const Dt = Q.add(Ee.sub(Q)._mult(Y / rn)._round());
                this.updateDistance(Q, Dt), this.addCurrentVertex(Dt, et, 0, 0, K), Q = Dt;
              }
            }
          }
        }
        addCurrentVertex(o, h, f, _, v) {
          let w = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;
          const P = h.y * _ - h.x, R = -h.y - h.x * _;
          this.addHalfVertex(o, h.x + h.y * f, h.y - h.x * f, w, !1, f, v), this.addHalfVertex(o, P, R, w, !0, -_, v), this.distance > Uv / 2 && this.totalDistance === 0 && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(o, h, f, _, v, w));
        }
        addHalfVertex(o, h, f, _, v, w, P) {
          let { x: R, y: D } = o;
          const z = 0.5 * (this.lineClips ? this.scaledDistance * (Uv - 1) : this.scaledDistance);
          this.layoutVertexArray.emplaceBack((R << 1) + (_ ? 1 : 0), (D << 1) + (v ? 1 : 0), Math.round(63 * h) + 128, Math.round(63 * f) + 128, 1 + (w === 0 ? 0 : w < 0 ? -1 : 1) | (63 & z) << 2, z >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
          const j = P.vertexLength++;
          this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, j, this.e2), P.primitiveLength++), v ? this.e2 = j : this.e1 = j;
        }
        updateScaledDistance() {
          this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
        }
        updateDistance(o, h) {
          this.distance += o.dist(h), this.updateScaledDistance();
        }
      }
      let jv, Gv;
      vn("LineBucket", D_, { omit: ["layers", "patternFeatures"] });
      var Vv = { get paint() {
        return Gv = Gv || new ri({ "line-opacity": new Ut(be.paint_line["line-opacity"]), "line-color": new Ut(be.paint_line["line-color"]), "line-translate": new ft(be.paint_line["line-translate"]), "line-translate-anchor": new ft(be.paint_line["line-translate-anchor"]), "line-width": new Ut(be.paint_line["line-width"]), "line-gap-width": new Ut(be.paint_line["line-gap-width"]), "line-offset": new Ut(be.paint_line["line-offset"]), "line-blur": new Ut(be.paint_line["line-blur"]), "line-dasharray": new jn(be.paint_line["line-dasharray"]), "line-pattern": new yn(be.paint_line["line-pattern"]), "line-gradient": new xn(be.paint_line["line-gradient"]) });
      }, get layout() {
        return jv = jv || new ri({ "line-cap": new ft(be.layout_line["line-cap"]), "line-join": new Ut(be.layout_line["line-join"]), "line-miter-limit": new ft(be.layout_line["line-miter-limit"]), "line-round-limit": new ft(be.layout_line["line-round-limit"]), "line-sort-key": new Ut(be.layout_line["line-sort-key"]) });
      } };
      class HC extends Ut {
        possiblyEvaluate(o, h) {
          return h = new ut(Math.floor(h.zoom), { now: h.now, fadeDuration: h.fadeDuration, zoomHistory: h.zoomHistory, transition: h.transition }), super.possiblyEvaluate(o, h);
        }
        evaluate(o, h, f, _) {
          return h = Xe({}, h, { zoom: Math.floor(h.zoom) }), super.evaluate(o, h, f, _);
        }
      }
      let ug;
      class WC extends ai {
        constructor(o) {
          super(o, Vv), this.gradientVersion = 0, ug || (ug = new HC(Vv.paint.properties["line-width"].specification), ug.useIntegerZoom = !0);
        }
        _handleSpecialPaintPropertyUpdate(o) {
          if (o === "line-gradient") {
            const h = this.gradientExpression();
            this.stepInterpolant = !!function(f) {
              return f._styleExpression !== void 0;
            }(h) && h._styleExpression.expression instanceof Ko, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
          }
        }
        gradientExpression() {
          return this._transitionablePaint._values["line-gradient"].value.expression;
        }
        recalculate(o, h) {
          super.recalculate(o, h), this.paint._values["line-floorwidth"] = ug.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, o);
        }
        createBucket(o) {
          return new D_(o);
        }
        queryRadius(o) {
          const h = o, f = qv(Cf("line-width", this, h), Cf("line-gap-width", this, h)), _ = Cf("line-offset", this, h);
          return f / 2 + Math.abs(_) + rg(this.paint.get("line-translate"));
        }
        queryIntersectsFeature(o) {
          let { queryGeometry: h, feature: f, featureState: _, geometry: v, transform: w, pixelsToTileUnits: P } = o;
          const R = sg(h, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -w.bearingInRadians, P), D = P / 2 * qv(this.paint.get("line-width").evaluate(f, _), this.paint.get("line-gap-width").evaluate(f, _)), z = this.paint.get("line-offset").evaluate(f, _);
          return z && (v = function(j, Y) {
            const K = [];
            for (let Q = 0; Q < j.length; Q++) {
              const se = j[Q], Ee = [];
              for (let Se = 0; Se < se.length; Se++) {
                const et = se[Se - 1], Ne = se[Se], J = se[Se + 1], ve = Se === 0 ? new F(0, 0) : Ne.sub(et)._unit()._perp(), je = Se === se.length - 1 ? new F(0, 0) : J.sub(Ne)._unit()._perp(), vt = ve._add(je)._unit(), Vt = vt.x * je.x + vt.y * je.y;
                Vt !== 0 && vt._mult(1 / Vt), Ee.push(vt._mult(Y)._add(Ne));
              }
              K.push(Ee);
            }
            return K;
          }(v, z * P)), function(j, Y, K) {
            for (let Q = 0; Q < Y.length; Q++) {
              const se = Y[Q];
              if (j.length >= 3) {
                for (let Ee = 0; Ee < se.length; Ee++) if (pd(j, se[Ee])) return !0;
              }
              if (Sf(j, se, K)) return !0;
            }
            return !1;
          }(R, v, D);
        }
        isTileClipped() {
          return !0;
        }
      }
      function qv(d, o) {
        return o > 0 ? o + 2 * d : d;
      }
      const ZC = Bn([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), $C = Bn([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
      Bn([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
      const XC = Bn([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_box_real", components: 2, type: "Int16" }]);
      Bn([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
      const Hv = Bn([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), YC = Bn([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
      function JC(d, o, h) {
        return d.sections.forEach((f) => {
          f.text = function(_, v, w) {
            const P = v.layout.get("text-transform").evaluate(w, {});
            return P === "uppercase" ? _ = _.toLocaleUpperCase() : P === "lowercase" && (_ = _.toLocaleLowerCase()), tt.applyArabicShaping && (_ = tt.applyArabicShaping(_)), _;
          }(f.text, o, h);
        }), d;
      }
      Bn([{ name: "triangle", components: 3, type: "Uint16" }]), Bn([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Bn([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Bn([{ type: "Float32", name: "offsetX" }]), Bn([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Bn([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
      const kf = { "!": "︕", "#": "＃", $: "＄", "%": "％", "&": "＆", "(": "︵", ")": "︶", "*": "＊", "+": "＋", ",": "︐", "-": "︲", ".": "・", "/": "／", ":": "︓", ";": "︔", "<": "︿", "=": "＝", ">": "﹀", "?": "︖", "@": "＠", "[": "﹇", "\\": "＼", "]": "﹈", "^": "＾", _: "︳", "`": "｀", "{": "︷", "|": "―", "}": "︸", "~": "～", "¢": "￠", "£": "￡", "¥": "￥", "¦": "￤", "¬": "￢", "¯": "￣", "–": "︲", "—": "︱", "‘": "﹃", "’": "﹄", "“": "﹁", "”": "﹂", "…": "︙", "‧": "・", "₩": "￦", "、": "︑", "。": "︒", "〈": "︿", "〉": "﹀", "《": "︽", "》": "︾", "「": "﹁", "」": "﹂", "『": "﹃", "』": "﹄", "【": "︻", "】": "︼", "〔": "︹", "〕": "︺", "〖": "︗", "〗": "︘", "！": "︕", "（": "︵", "）": "︶", "，": "︐", "－": "︲", "．": "・", "：": "︓", "；": "︔", "＜": "︿", "＞": "﹀", "？": "︖", "［": "﹇", "］": "﹈", "＿": "︳", "｛": "︷", "｜": "―", "｝": "︸", "｟": "︵", "｠": "︶", "｡": "︒", "｢": "﹁", "｣": "﹂" };
      var Wv, F_, Zv, gs = 24, N_ = {};
      function KC() {
        return Wv || (Wv = 1, N_.read = function(d, o, h, f, _) {
          var v, w, P = 8 * _ - f - 1, R = (1 << P) - 1, D = R >> 1, z = -7, j = h ? _ - 1 : 0, Y = h ? -1 : 1, K = d[o + j];
          for (j += Y, v = K & (1 << -z) - 1, K >>= -z, z += P; z > 0; v = 256 * v + d[o + j], j += Y, z -= 8) ;
          for (w = v & (1 << -z) - 1, v >>= -z, z += f; z > 0; w = 256 * w + d[o + j], j += Y, z -= 8) ;
          if (v === 0) v = 1 - D;
          else {
            if (v === R) return w ? NaN : 1 / 0 * (K ? -1 : 1);
            w += Math.pow(2, f), v -= D;
          }
          return (K ? -1 : 1) * w * Math.pow(2, v - f);
        }, N_.write = function(d, o, h, f, _, v) {
          var w, P, R, D = 8 * v - _ - 1, z = (1 << D) - 1, j = z >> 1, Y = _ === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, K = f ? 0 : v - 1, Q = f ? 1 : -1, se = o < 0 || o === 0 && 1 / o < 0 ? 1 : 0;
          for (o = Math.abs(o), isNaN(o) || o === 1 / 0 ? (P = isNaN(o) ? 1 : 0, w = z) : (w = Math.floor(Math.log(o) / Math.LN2), o * (R = Math.pow(2, -w)) < 1 && (w--, R *= 2), (o += w + j >= 1 ? Y / R : Y * Math.pow(2, 1 - j)) * R >= 2 && (w++, R /= 2), w + j >= z ? (P = 0, w = z) : w + j >= 1 ? (P = (o * R - 1) * Math.pow(2, _), w += j) : (P = o * Math.pow(2, j - 1) * Math.pow(2, _), w = 0)); _ >= 8; d[h + K] = 255 & P, K += Q, P /= 256, _ -= 8) ;
          for (w = w << _ | P, D += _; D > 0; d[h + K] = 255 & w, K += Q, w /= 256, D -= 8) ;
          d[h + K - Q] |= 128 * se;
        }), N_;
      }
      function $v() {
        if (Zv) return F_;
        Zv = 1, F_ = o;
        var d = KC();
        function o(J) {
          this.buf = ArrayBuffer.isView && ArrayBuffer.isView(J) ? J : new Uint8Array(J || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
        }
        o.Varint = 0, o.Fixed64 = 1, o.Bytes = 2, o.Fixed32 = 5;
        var h = 4294967296, f = 1 / h, _ = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
        function v(J) {
          return J.type === o.Bytes ? J.readVarint() + J.pos : J.pos + 1;
        }
        function w(J, ve, je) {
          return je ? 4294967296 * ve + (J >>> 0) : 4294967296 * (ve >>> 0) + (J >>> 0);
        }
        function P(J, ve, je) {
          var vt = ve <= 16383 ? 1 : ve <= 2097151 ? 2 : ve <= 268435455 ? 3 : Math.floor(Math.log(ve) / (7 * Math.LN2));
          je.realloc(vt);
          for (var Vt = je.pos - 1; Vt >= J; Vt--) je.buf[Vt + vt] = je.buf[Vt];
        }
        function R(J, ve) {
          for (var je = 0; je < J.length; je++) ve.writeVarint(J[je]);
        }
        function D(J, ve) {
          for (var je = 0; je < J.length; je++) ve.writeSVarint(J[je]);
        }
        function z(J, ve) {
          for (var je = 0; je < J.length; je++) ve.writeFloat(J[je]);
        }
        function j(J, ve) {
          for (var je = 0; je < J.length; je++) ve.writeDouble(J[je]);
        }
        function Y(J, ve) {
          for (var je = 0; je < J.length; je++) ve.writeBoolean(J[je]);
        }
        function K(J, ve) {
          for (var je = 0; je < J.length; je++) ve.writeFixed32(J[je]);
        }
        function Q(J, ve) {
          for (var je = 0; je < J.length; je++) ve.writeSFixed32(J[je]);
        }
        function se(J, ve) {
          for (var je = 0; je < J.length; je++) ve.writeFixed64(J[je]);
        }
        function Ee(J, ve) {
          for (var je = 0; je < J.length; je++) ve.writeSFixed64(J[je]);
        }
        function Se(J, ve) {
          return (J[ve] | J[ve + 1] << 8 | J[ve + 2] << 16) + 16777216 * J[ve + 3];
        }
        function et(J, ve, je) {
          J[je] = ve, J[je + 1] = ve >>> 8, J[je + 2] = ve >>> 16, J[je + 3] = ve >>> 24;
        }
        function Ne(J, ve) {
          return (J[ve] | J[ve + 1] << 8 | J[ve + 2] << 16) + (J[ve + 3] << 24);
        }
        return o.prototype = { destroy: function() {
          this.buf = null;
        }, readFields: function(J, ve, je) {
          for (je = je || this.length; this.pos < je; ) {
            var vt = this.readVarint(), Vt = vt >> 3, Et = this.pos;
            this.type = 7 & vt, J(Vt, ve, this), this.pos === Et && this.skip(vt);
          }
          return ve;
        }, readMessage: function(J, ve) {
          return this.readFields(J, ve, this.readVarint() + this.pos);
        }, readFixed32: function() {
          var J = Se(this.buf, this.pos);
          return this.pos += 4, J;
        }, readSFixed32: function() {
          var J = Ne(this.buf, this.pos);
          return this.pos += 4, J;
        }, readFixed64: function() {
          var J = Se(this.buf, this.pos) + Se(this.buf, this.pos + 4) * h;
          return this.pos += 8, J;
        }, readSFixed64: function() {
          var J = Se(this.buf, this.pos) + Ne(this.buf, this.pos + 4) * h;
          return this.pos += 8, J;
        }, readFloat: function() {
          var J = d.read(this.buf, this.pos, !0, 23, 4);
          return this.pos += 4, J;
        }, readDouble: function() {
          var J = d.read(this.buf, this.pos, !0, 52, 8);
          return this.pos += 8, J;
        }, readVarint: function(J) {
          var ve, je, vt = this.buf;
          return ve = 127 & (je = vt[this.pos++]), je < 128 ? ve : (ve |= (127 & (je = vt[this.pos++])) << 7, je < 128 ? ve : (ve |= (127 & (je = vt[this.pos++])) << 14, je < 128 ? ve : (ve |= (127 & (je = vt[this.pos++])) << 21, je < 128 ? ve : function(Vt, Et, Lt) {
            var Qt, Ht, rn = Lt.buf;
            if (Qt = (112 & (Ht = rn[Lt.pos++])) >> 4, Ht < 128 || (Qt |= (127 & (Ht = rn[Lt.pos++])) << 3, Ht < 128) || (Qt |= (127 & (Ht = rn[Lt.pos++])) << 10, Ht < 128) || (Qt |= (127 & (Ht = rn[Lt.pos++])) << 17, Ht < 128) || (Qt |= (127 & (Ht = rn[Lt.pos++])) << 24, Ht < 128) || (Qt |= (1 & (Ht = rn[Lt.pos++])) << 31, Ht < 128)) return w(Vt, Qt, Et);
            throw new Error("Expected varint not more than 10 bytes");
          }(ve |= (15 & (je = vt[this.pos])) << 28, J, this))));
        }, readVarint64: function() {
          return this.readVarint(!0);
        }, readSVarint: function() {
          var J = this.readVarint();
          return J % 2 == 1 ? (J + 1) / -2 : J / 2;
        }, readBoolean: function() {
          return !!this.readVarint();
        }, readString: function() {
          var J = this.readVarint() + this.pos, ve = this.pos;
          return this.pos = J, J - ve >= 12 && _ ? function(je, vt, Vt) {
            return _.decode(je.subarray(vt, Vt));
          }(this.buf, ve, J) : function(je, vt, Vt) {
            for (var Et = "", Lt = vt; Lt < Vt; ) {
              var Qt, Ht, rn, Dt = je[Lt], Cn = null, zn = Dt > 239 ? 4 : Dt > 223 ? 3 : Dt > 191 ? 2 : 1;
              if (Lt + zn > Vt) break;
              zn === 1 ? Dt < 128 && (Cn = Dt) : zn === 2 ? (192 & (Qt = je[Lt + 1])) == 128 && (Cn = (31 & Dt) << 6 | 63 & Qt) <= 127 && (Cn = null) : zn === 3 ? (Ht = je[Lt + 2], (192 & (Qt = je[Lt + 1])) == 128 && (192 & Ht) == 128 && ((Cn = (15 & Dt) << 12 | (63 & Qt) << 6 | 63 & Ht) <= 2047 || Cn >= 55296 && Cn <= 57343) && (Cn = null)) : zn === 4 && (Ht = je[Lt + 2], rn = je[Lt + 3], (192 & (Qt = je[Lt + 1])) == 128 && (192 & Ht) == 128 && (192 & rn) == 128 && ((Cn = (15 & Dt) << 18 | (63 & Qt) << 12 | (63 & Ht) << 6 | 63 & rn) <= 65535 || Cn >= 1114112) && (Cn = null)), Cn === null ? (Cn = 65533, zn = 1) : Cn > 65535 && (Cn -= 65536, Et += String.fromCharCode(Cn >>> 10 & 1023 | 55296), Cn = 56320 | 1023 & Cn), Et += String.fromCharCode(Cn), Lt += zn;
            }
            return Et;
          }(this.buf, ve, J);
        }, readBytes: function() {
          var J = this.readVarint() + this.pos, ve = this.buf.subarray(this.pos, J);
          return this.pos = J, ve;
        }, readPackedVarint: function(J, ve) {
          if (this.type !== o.Bytes) return J.push(this.readVarint(ve));
          var je = v(this);
          for (J = J || []; this.pos < je; ) J.push(this.readVarint(ve));
          return J;
        }, readPackedSVarint: function(J) {
          if (this.type !== o.Bytes) return J.push(this.readSVarint());
          var ve = v(this);
          for (J = J || []; this.pos < ve; ) J.push(this.readSVarint());
          return J;
        }, readPackedBoolean: function(J) {
          if (this.type !== o.Bytes) return J.push(this.readBoolean());
          var ve = v(this);
          for (J = J || []; this.pos < ve; ) J.push(this.readBoolean());
          return J;
        }, readPackedFloat: function(J) {
          if (this.type !== o.Bytes) return J.push(this.readFloat());
          var ve = v(this);
          for (J = J || []; this.pos < ve; ) J.push(this.readFloat());
          return J;
        }, readPackedDouble: function(J) {
          if (this.type !== o.Bytes) return J.push(this.readDouble());
          var ve = v(this);
          for (J = J || []; this.pos < ve; ) J.push(this.readDouble());
          return J;
        }, readPackedFixed32: function(J) {
          if (this.type !== o.Bytes) return J.push(this.readFixed32());
          var ve = v(this);
          for (J = J || []; this.pos < ve; ) J.push(this.readFixed32());
          return J;
        }, readPackedSFixed32: function(J) {
          if (this.type !== o.Bytes) return J.push(this.readSFixed32());
          var ve = v(this);
          for (J = J || []; this.pos < ve; ) J.push(this.readSFixed32());
          return J;
        }, readPackedFixed64: function(J) {
          if (this.type !== o.Bytes) return J.push(this.readFixed64());
          var ve = v(this);
          for (J = J || []; this.pos < ve; ) J.push(this.readFixed64());
          return J;
        }, readPackedSFixed64: function(J) {
          if (this.type !== o.Bytes) return J.push(this.readSFixed64());
          var ve = v(this);
          for (J = J || []; this.pos < ve; ) J.push(this.readSFixed64());
          return J;
        }, skip: function(J) {
          var ve = 7 & J;
          if (ve === o.Varint) for (; this.buf[this.pos++] > 127; ) ;
          else if (ve === o.Bytes) this.pos = this.readVarint() + this.pos;
          else if (ve === o.Fixed32) this.pos += 4;
          else {
            if (ve !== o.Fixed64) throw new Error("Unimplemented type: " + ve);
            this.pos += 8;
          }
        }, writeTag: function(J, ve) {
          this.writeVarint(J << 3 | ve);
        }, realloc: function(J) {
          for (var ve = this.length || 16; ve < this.pos + J; ) ve *= 2;
          if (ve !== this.length) {
            var je = new Uint8Array(ve);
            je.set(this.buf), this.buf = je, this.length = ve;
          }
        }, finish: function() {
          return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
        }, writeFixed32: function(J) {
          this.realloc(4), et(this.buf, J, this.pos), this.pos += 4;
        }, writeSFixed32: function(J) {
          this.realloc(4), et(this.buf, J, this.pos), this.pos += 4;
        }, writeFixed64: function(J) {
          this.realloc(8), et(this.buf, -1 & J, this.pos), et(this.buf, Math.floor(J * f), this.pos + 4), this.pos += 8;
        }, writeSFixed64: function(J) {
          this.realloc(8), et(this.buf, -1 & J, this.pos), et(this.buf, Math.floor(J * f), this.pos + 4), this.pos += 8;
        }, writeVarint: function(J) {
          (J = +J || 0) > 268435455 || J < 0 ? function(ve, je) {
            var vt, Vt;
            if (ve >= 0 ? (vt = ve % 4294967296 | 0, Vt = ve / 4294967296 | 0) : (Vt = ~(-ve / 4294967296), 4294967295 ^ (vt = ~(-ve % 4294967296)) ? vt = vt + 1 | 0 : (vt = 0, Vt = Vt + 1 | 0)), ve >= 18446744073709552e3 || ve < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
            je.realloc(10), function(Et, Lt, Qt) {
              Qt.buf[Qt.pos++] = 127 & Et | 128, Et >>>= 7, Qt.buf[Qt.pos++] = 127 & Et | 128, Et >>>= 7, Qt.buf[Qt.pos++] = 127 & Et | 128, Et >>>= 7, Qt.buf[Qt.pos++] = 127 & Et | 128, Qt.buf[Qt.pos] = 127 & (Et >>>= 7);
            }(vt, 0, je), function(Et, Lt) {
              var Qt = (7 & Et) << 4;
              Lt.buf[Lt.pos++] |= Qt | ((Et >>>= 3) ? 128 : 0), Et && (Lt.buf[Lt.pos++] = 127 & Et | ((Et >>>= 7) ? 128 : 0), Et && (Lt.buf[Lt.pos++] = 127 & Et | ((Et >>>= 7) ? 128 : 0), Et && (Lt.buf[Lt.pos++] = 127 & Et | ((Et >>>= 7) ? 128 : 0), Et && (Lt.buf[Lt.pos++] = 127 & Et | ((Et >>>= 7) ? 128 : 0), Et && (Lt.buf[Lt.pos++] = 127 & Et)))));
            }(Vt, je);
          }(J, this) : (this.realloc(4), this.buf[this.pos++] = 127 & J | (J > 127 ? 128 : 0), J <= 127 || (this.buf[this.pos++] = 127 & (J >>>= 7) | (J > 127 ? 128 : 0), J <= 127 || (this.buf[this.pos++] = 127 & (J >>>= 7) | (J > 127 ? 128 : 0), J <= 127 || (this.buf[this.pos++] = J >>> 7 & 127))));
        }, writeSVarint: function(J) {
          this.writeVarint(J < 0 ? 2 * -J - 1 : 2 * J);
        }, writeBoolean: function(J) {
          this.writeVarint(!!J);
        }, writeString: function(J) {
          J = String(J), this.realloc(4 * J.length), this.pos++;
          var ve = this.pos;
          this.pos = function(vt, Vt, Et) {
            for (var Lt, Qt, Ht = 0; Ht < Vt.length; Ht++) {
              if ((Lt = Vt.charCodeAt(Ht)) > 55295 && Lt < 57344) {
                if (!Qt) {
                  Lt > 56319 || Ht + 1 === Vt.length ? (vt[Et++] = 239, vt[Et++] = 191, vt[Et++] = 189) : Qt = Lt;
                  continue;
                }
                if (Lt < 56320) {
                  vt[Et++] = 239, vt[Et++] = 191, vt[Et++] = 189, Qt = Lt;
                  continue;
                }
                Lt = Qt - 55296 << 10 | Lt - 56320 | 65536, Qt = null;
              } else Qt && (vt[Et++] = 239, vt[Et++] = 191, vt[Et++] = 189, Qt = null);
              Lt < 128 ? vt[Et++] = Lt : (Lt < 2048 ? vt[Et++] = Lt >> 6 | 192 : (Lt < 65536 ? vt[Et++] = Lt >> 12 | 224 : (vt[Et++] = Lt >> 18 | 240, vt[Et++] = Lt >> 12 & 63 | 128), vt[Et++] = Lt >> 6 & 63 | 128), vt[Et++] = 63 & Lt | 128);
            }
            return Et;
          }(this.buf, J, this.pos);
          var je = this.pos - ve;
          je >= 128 && P(ve, je, this), this.pos = ve - 1, this.writeVarint(je), this.pos += je;
        }, writeFloat: function(J) {
          this.realloc(4), d.write(this.buf, J, this.pos, !0, 23, 4), this.pos += 4;
        }, writeDouble: function(J) {
          this.realloc(8), d.write(this.buf, J, this.pos, !0, 52, 8), this.pos += 8;
        }, writeBytes: function(J) {
          var ve = J.length;
          this.writeVarint(ve), this.realloc(ve);
          for (var je = 0; je < ve; je++) this.buf[this.pos++] = J[je];
        }, writeRawMessage: function(J, ve) {
          this.pos++;
          var je = this.pos;
          J(ve, this);
          var vt = this.pos - je;
          vt >= 128 && P(je, vt, this), this.pos = je - 1, this.writeVarint(vt), this.pos += vt;
        }, writeMessage: function(J, ve, je) {
          this.writeTag(J, o.Bytes), this.writeRawMessage(ve, je);
        }, writePackedVarint: function(J, ve) {
          ve.length && this.writeMessage(J, R, ve);
        }, writePackedSVarint: function(J, ve) {
          ve.length && this.writeMessage(J, D, ve);
        }, writePackedBoolean: function(J, ve) {
          ve.length && this.writeMessage(J, Y, ve);
        }, writePackedFloat: function(J, ve) {
          ve.length && this.writeMessage(J, z, ve);
        }, writePackedDouble: function(J, ve) {
          ve.length && this.writeMessage(J, j, ve);
        }, writePackedFixed32: function(J, ve) {
          ve.length && this.writeMessage(J, K, ve);
        }, writePackedSFixed32: function(J, ve) {
          ve.length && this.writeMessage(J, Q, ve);
        }, writePackedFixed64: function(J, ve) {
          ve.length && this.writeMessage(J, se, ve);
        }, writePackedSFixed64: function(J, ve) {
          ve.length && this.writeMessage(J, Ee, ve);
        }, writeBytesField: function(J, ve) {
          this.writeTag(J, o.Bytes), this.writeBytes(ve);
        }, writeFixed32Field: function(J, ve) {
          this.writeTag(J, o.Fixed32), this.writeFixed32(ve);
        }, writeSFixed32Field: function(J, ve) {
          this.writeTag(J, o.Fixed32), this.writeSFixed32(ve);
        }, writeFixed64Field: function(J, ve) {
          this.writeTag(J, o.Fixed64), this.writeFixed64(ve);
        }, writeSFixed64Field: function(J, ve) {
          this.writeTag(J, o.Fixed64), this.writeSFixed64(ve);
        }, writeVarintField: function(J, ve) {
          this.writeTag(J, o.Varint), this.writeVarint(ve);
        }, writeSVarintField: function(J, ve) {
          this.writeTag(J, o.Varint), this.writeSVarint(ve);
        }, writeStringField: function(J, ve) {
          this.writeTag(J, o.Bytes), this.writeString(ve);
        }, writeFloatField: function(J, ve) {
          this.writeTag(J, o.Fixed32), this.writeFloat(ve);
        }, writeDoubleField: function(J, ve) {
          this.writeTag(J, o.Fixed64), this.writeDouble(ve);
        }, writeBooleanField: function(J, ve) {
          this.writeVarintField(J, !!ve);
        } }, F_;
      }
      var k_ = g($v());
      const z_ = 3;
      function QC(d, o, h) {
        d === 1 && h.readMessage(eP, o);
      }
      function eP(d, o, h) {
        if (d === 3) {
          const { id: f, bitmap: _, width: v, height: w, left: P, top: R, advance: D } = h.readMessage(tP, {});
          o.push({ id: f, bitmap: new Pf({ width: v + 2 * z_, height: w + 2 * z_ }, _), metrics: { width: v, height: w, left: P, top: R, advance: D } });
        }
      }
      function tP(d, o, h) {
        d === 1 ? o.id = h.readVarint() : d === 2 ? o.bitmap = h.readBytes() : d === 3 ? o.width = h.readVarint() : d === 4 ? o.height = h.readVarint() : d === 5 ? o.left = h.readSVarint() : d === 6 ? o.top = h.readSVarint() : d === 7 && (o.advance = h.readVarint());
      }
      const nP = z_;
      function Xv(d) {
        let o = 0, h = 0;
        for (const w of d) o += w.w * w.h, h = Math.max(h, w.w);
        d.sort((w, P) => P.h - w.h);
        const f = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(o / 0.95)), h), h: 1 / 0 }];
        let _ = 0, v = 0;
        for (const w of d) for (let P = f.length - 1; P >= 0; P--) {
          const R = f[P];
          if (!(w.w > R.w || w.h > R.h)) {
            if (w.x = R.x, w.y = R.y, v = Math.max(v, w.y + w.h), _ = Math.max(_, w.x + w.w), w.w === R.w && w.h === R.h) {
              const D = f.pop();
              P < f.length && (f[P] = D);
            } else w.h === R.h ? (R.x += w.w, R.w -= w.w) : w.w === R.w ? (R.y += w.h, R.h -= w.h) : (f.push({ x: R.x + w.w, y: R.y, w: R.w - w.w, h: w.h }), R.y += w.h, R.h -= w.h);
            break;
          }
        }
        return { w: _, h: v, fill: o / (_ * v) || 0 };
      }
      const sa = 1;
      class U_ {
        constructor(o, h) {
          let { pixelRatio: f, version: _, stretchX: v, stretchY: w, content: P, textFitWidth: R, textFitHeight: D } = h;
          this.paddedRect = o, this.pixelRatio = f, this.stretchX = v, this.stretchY = w, this.content = P, this.version = _, this.textFitWidth = R, this.textFitHeight = D;
        }
        get tl() {
          return [this.paddedRect.x + sa, this.paddedRect.y + sa];
        }
        get br() {
          return [this.paddedRect.x + this.paddedRect.w - sa, this.paddedRect.y + this.paddedRect.h - sa];
        }
        get tlbr() {
          return this.tl.concat(this.br);
        }
        get displaySize() {
          return [(this.paddedRect.w - 2 * sa) / this.pixelRatio, (this.paddedRect.h - 2 * sa) / this.pixelRatio];
        }
      }
      class Yv {
        constructor(o, h) {
          const f = {}, _ = {};
          this.haveRenderCallbacks = [];
          const v = [];
          this.addImages(o, f, v), this.addImages(h, _, v);
          const { w, h: P } = Xv(v), R = new qa({ width: w || 1, height: P || 1 });
          for (const D in o) {
            const z = o[D], j = f[D].paddedRect;
            qa.copy(z.data, R, { x: 0, y: 0 }, { x: j.x + sa, y: j.y + sa }, z.data);
          }
          for (const D in h) {
            const z = h[D], j = _[D].paddedRect, Y = j.x + sa, K = j.y + sa, Q = z.data.width, se = z.data.height;
            qa.copy(z.data, R, { x: 0, y: 0 }, { x: Y, y: K }, z.data), qa.copy(z.data, R, { x: 0, y: se - 1 }, { x: Y, y: K - 1 }, { width: Q, height: 1 }), qa.copy(z.data, R, { x: 0, y: 0 }, { x: Y, y: K + se }, { width: Q, height: 1 }), qa.copy(z.data, R, { x: Q - 1, y: 0 }, { x: Y - 1, y: K }, { width: 1, height: se }), qa.copy(z.data, R, { x: 0, y: 0 }, { x: Y + Q, y: K }, { width: 1, height: se });
          }
          this.image = R, this.iconPositions = f, this.patternPositions = _;
        }
        addImages(o, h, f) {
          for (const _ in o) {
            const v = o[_], w = { x: 0, y: 0, w: v.data.width + 2 * sa, h: v.data.height + 2 * sa };
            f.push(w), h[_] = new U_(w, v), v.hasRenderCallback && this.haveRenderCallbacks.push(_);
          }
        }
        patchUpdatedImages(o, h) {
          o.dispatchRenderCallbacks(this.haveRenderCallbacks);
          for (const f in o.updatedImages) this.patchUpdatedImage(this.iconPositions[f], o.getImage(f), h), this.patchUpdatedImage(this.patternPositions[f], o.getImage(f), h);
        }
        patchUpdatedImage(o, h, f) {
          if (!o || !h || o.version === h.version) return;
          o.version = h.version;
          const [_, v] = o.tl;
          f.update(h.data, void 0, { x: _, y: v });
        }
      }
      var Zu;
      vn("ImagePosition", U_), vn("ImageAtlas", Yv), c.af = void 0, (Zu = c.af || (c.af = {}))[Zu.none = 0] = "none", Zu[Zu.horizontal = 1] = "horizontal", Zu[Zu.vertical = 2] = "vertical", Zu[Zu.horizontalOnly = 3] = "horizontalOnly";
      const hg = -17;
      class zf {
        constructor() {
          this.scale = 1, this.fontStack = "", this.imageName = null, this.verticalAlign = "bottom";
        }
        static forText(o, h, f) {
          const _ = new zf();
          return _.scale = o || 1, _.fontStack = h, _.verticalAlign = f || "bottom", _;
        }
        static forImage(o, h) {
          const f = new zf();
          return f.imageName = o, f.verticalAlign = h || "bottom", f;
        }
      }
      class yd {
        constructor() {
          this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
        }
        static fromFeature(o, h) {
          const f = new yd();
          for (let _ = 0; _ < o.sections.length; _++) {
            const v = o.sections[_];
            v.image ? f.addImageSection(v) : f.addTextSection(v, h);
          }
          return f;
        }
        length() {
          return this.text.length;
        }
        getSection(o) {
          return this.sections[this.sectionIndex[o]];
        }
        getSectionIndex(o) {
          return this.sectionIndex[o];
        }
        getCharCode(o) {
          return this.text.charCodeAt(o);
        }
        verticalizePunctuation() {
          this.text = function(o) {
            let h = "";
            for (let f = 0; f < o.length; f++) {
              const _ = o.charCodeAt(f + 1) || null, v = o.charCodeAt(f - 1) || null;
              h += _ && le(_) && !kf[o[f + 1]] || v && le(v) && !kf[o[f - 1]] || !kf[o[f]] ? o[f] : kf[o[f]];
            }
            return h;
          }(this.text);
        }
        trim() {
          let o = 0;
          for (let f = 0; f < this.text.length && fg[this.text.charCodeAt(f)]; f++) o++;
          let h = this.text.length;
          for (let f = this.text.length - 1; f >= 0 && f >= o && fg[this.text.charCodeAt(f)]; f--) h--;
          this.text = this.text.substring(o, h), this.sectionIndex = this.sectionIndex.slice(o, h);
        }
        substring(o, h) {
          const f = new yd();
          return f.text = this.text.substring(o, h), f.sectionIndex = this.sectionIndex.slice(o, h), f.sections = this.sections, f;
        }
        toString() {
          return this.text;
        }
        getMaxScale() {
          return this.sectionIndex.reduce((o, h) => Math.max(o, this.sections[h].scale), 0);
        }
        getMaxImageSize(o) {
          let h = 0, f = 0;
          for (let _ = 0; _ < this.length(); _++) {
            const v = this.getSection(_);
            if (v.imageName) {
              const w = o[v.imageName];
              if (!w) continue;
              const P = w.displaySize;
              h = Math.max(h, P[0]), f = Math.max(f, P[1]);
            }
          }
          return { maxImageWidth: h, maxImageHeight: f };
        }
        addTextSection(o, h) {
          this.text += o.text, this.sections.push(zf.forText(o.scale, o.fontStack || h, o.verticalAlign));
          const f = this.sections.length - 1;
          for (let _ = 0; _ < o.text.length; ++_) this.sectionIndex.push(f);
        }
        addImageSection(o) {
          const h = o.image ? o.image.name : "";
          if (h.length === 0) return void Wt("Can't add FormattedSection with an empty image.");
          const f = this.getNextImageSectionCharCode();
          f ? (this.text += String.fromCharCode(f), this.sections.push(zf.forImage(h, o.verticalAlign)), this.sectionIndex.push(this.sections.length - 1)) : Wt("Reached maximum number of images 6401");
        }
        getNextImageSectionCharCode() {
          return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
        }
      }
      function dg(d, o, h, f, _, v, w, P, R, D, z, j, Y, K, Q) {
        const se = yd.fromFeature(d, _);
        let Ee;
        j === c.af.vertical && se.verticalizePunctuation();
        const { processBidirectionalText: Se, processStyledBidirectionalText: et } = tt;
        if (Se && se.sections.length === 1) {
          Ee = [];
          const ve = Se(se.toString(), j_(se, D, v, o, f, K));
          for (const je of ve) {
            const vt = new yd();
            vt.text = je, vt.sections = se.sections;
            for (let Vt = 0; Vt < je.length; Vt++) vt.sectionIndex.push(0);
            Ee.push(vt);
          }
        } else if (et) {
          Ee = [];
          const ve = et(se.text, se.sectionIndex, j_(se, D, v, o, f, K));
          for (const je of ve) {
            const vt = new yd();
            vt.text = je[0], vt.sectionIndex = je[1], vt.sections = se.sections, Ee.push(vt);
          }
        } else Ee = function(ve, je) {
          const vt = [], Vt = ve.text;
          let Et = 0;
          for (const Lt of je) vt.push(ve.substring(Et, Lt)), Et = Lt;
          return Et < Vt.length && vt.push(ve.substring(Et, Vt.length)), vt;
        }(se, j_(se, D, v, o, f, K));
        const Ne = [], J = { positionedLines: Ne, text: se.toString(), top: z[1], bottom: z[1], left: z[0], right: z[0], writingMode: j, iconsInText: !1, verticalizable: !1 };
        return function(ve, je, vt, Vt, Et, Lt, Qt, Ht, rn, Dt, Cn, zn) {
          let Dn = 0, Pn = 0, vi = 0, Rr = 0;
          const Kr = Ht === "right" ? 1 : Ht === "left" ? 0 : 0.5, Fo = gs / zn;
          let oa = 0;
          for (const Ur of Et) {
            Ur.trim();
            const ms = Ur.getMaxScale(), Us = { positionedGlyphs: [], lineOffset: 0 };
            ve.positionedLines[oa] = Us;
            const Qr = Us.positionedGlyphs;
            let No = 0;
            if (!Ur.length()) {
              Pn += Lt, ++oa;
              continue;
            }
            const Wa = oP(Vt, Ur, Fo);
            for (let la = 0; la < Ur.length(); la++) {
              const _s = Ur.getSection(la), Is = Ur.getSectionIndex(la), Ms = Ur.getCharCode(la), es = aP(rn, Cn, Ms);
              let hr;
              if (_s.imageName) {
                if (ve.iconsInText = !0, _s.scale = _s.scale * Fo, hr = cP(_s, es, ms, Wa, Vt), !hr) continue;
                No = Math.max(No, hr.imageOffset);
              } else if (hr = lP(_s, Ms, es, Wa, je, vt), !hr) continue;
              const { rect: ic, metrics: wd, baselineOffset: rc } = hr;
              Qr.push({ glyph: Ms, imageName: _s.imageName, x: Dn, y: Pn + rc + hg, vertical: es, scale: _s.scale, fontStack: _s.fontStack, sectionIndex: Is, metrics: wd, rect: ic }), es ? (ve.verticalizable = !0, Dn += (_s.imageName ? wd.advance : gs) * _s.scale + Dt) : Dn += wd.advance * _s.scale + Dt;
            }
            Qr.length !== 0 && (vi = Math.max(Dn - Dt, vi), uP(Qr, 0, Qr.length - 1, Kr)), Dn = 0, Us.lineOffset = Math.max(No, (ms - 1) * gs);
            const Ps = Lt * ms + No;
            Pn += Ps, Rr = Math.max(Ps, Rr), ++oa;
          }
          const { horizontalAlign: aa, verticalAlign: zs } = G_(Qt);
          (function(Ur, ms, Us, Qr, No, Wa, Ps, la, _s) {
            const Is = (ms - Us) * No;
            let Ms = 0;
            Ms = Wa !== Ps ? -la * Qr - hg : -Qr * _s * Ps + 0.5 * Ps;
            for (const es of Ur) for (const hr of es.positionedGlyphs) hr.x += Is, hr.y += Ms;
          })(ve.positionedLines, Kr, aa, zs, vi, Rr, Lt, Pn, Et.length), ve.top += -zs * Pn, ve.bottom = ve.top + Pn, ve.left += -aa * vi, ve.right = ve.left + vi;
        }(J, o, h, f, Ee, w, P, R, j, D, Y, Q), !function(ve) {
          for (const je of ve) if (je.positionedGlyphs.length !== 0) return !1;
          return !0;
        }(Ne) && J;
      }
      const fg = { 9: !0, 10: !0, 11: !0, 12: !0, 13: !0, 32: !0 }, iP = { 10: !0, 32: !0, 38: !0, 41: !0, 43: !0, 45: !0, 47: !0, 173: !0, 183: !0, 8203: !0, 8208: !0, 8211: !0, 8231: !0 }, rP = { 40: !0 };
      function Jv(d, o, h, f, _, v) {
        if (o.imageName) {
          const w = f[o.imageName];
          return w ? w.displaySize[0] * o.scale * gs / v + _ : 0;
        }
        {
          const w = h[o.fontStack], P = w && w[d];
          return P ? P.metrics.advance * o.scale + _ : 0;
        }
      }
      function Kv(d, o, h, f) {
        const _ = Math.pow(d - o, 2);
        return f ? d < o ? _ / 2 : 2 * _ : _ + Math.abs(h) * h;
      }
      function sP(d, o, h) {
        let f = 0;
        return d === 10 && (f -= 1e4), h && (f += 150), d !== 40 && d !== 65288 || (f += 50), o !== 41 && o !== 65289 || (f += 50), f;
      }
      function Qv(d, o, h, f, _, v) {
        let w = null, P = Kv(o, h, _, v);
        for (const R of f) {
          const D = Kv(o - R.x, h, _, v) + R.badness;
          D <= P && (w = R, P = D);
        }
        return { index: d, x: o, priorBreak: w, badness: P };
      }
      function e2(d) {
        return d ? e2(d.priorBreak).concat(d.index) : [];
      }
      function j_(d, o, h, f, _, v) {
        if (!d) return [];
        const w = [], P = function(j, Y, K, Q, se, Ee) {
          let Se = 0;
          for (let et = 0; et < j.length(); et++) {
            const Ne = j.getSection(et);
            Se += Jv(j.getCharCode(et), Ne, Q, se, Y, Ee);
          }
          return Se / Math.max(1, Math.ceil(Se / K));
        }(d, o, h, f, _, v), R = d.text.indexOf("​") >= 0;
        let D = 0;
        for (let j = 0; j < d.length(); j++) {
          const Y = d.getSection(j), K = d.getCharCode(j);
          if (fg[K] || (D += Jv(K, Y, f, _, o, v)), j < d.length() - 1) {
            const Q = !((z = K) < 11904) && (!!ci["CJK Compatibility Forms"](z) || !!ci["CJK Compatibility"](z) || !!ci["CJK Strokes"](z) || !!ci["CJK Symbols and Punctuation"](z) || !!ci["Enclosed CJK Letters and Months"](z) || !!ci["Halfwidth and Fullwidth Forms"](z) || !!ci["Ideographic Description Characters"](z) || !!ci["Vertical Forms"](z) || q.test(String.fromCodePoint(z)));
            (iP[K] || Q || Y.imageName || j !== d.length() - 2 && rP[d.getCharCode(j + 1)]) && w.push(Qv(j + 1, D, P, w, sP(K, d.getCharCode(j + 1), Q && R), !1));
          }
        }
        var z;
        return e2(Qv(d.length(), D, P, w, 0, !0));
      }
      function G_(d) {
        let o = 0.5, h = 0.5;
        switch (d) {
          case "right":
          case "top-right":
          case "bottom-right":
            o = 1;
            break;
          case "left":
          case "top-left":
          case "bottom-left":
            o = 0;
        }
        switch (d) {
          case "bottom":
          case "bottom-right":
          case "bottom-left":
            h = 1;
            break;
          case "top":
          case "top-right":
          case "top-left":
            h = 0;
        }
        return { horizontalAlign: o, verticalAlign: h };
      }
      function oP(d, o, h) {
        const f = o.getMaxScale() * gs, { maxImageWidth: _, maxImageHeight: v } = o.getMaxImageSize(d), w = Math.max(f, v * h);
        return { verticalLineContentWidth: Math.max(f, _ * h), horizontalLineContentHeight: w };
      }
      function t2(d) {
        switch (d) {
          case "top":
            return 0;
          case "center":
            return 0.5;
          default:
            return 1;
        }
      }
      function aP(d, o, h) {
        return !(d === c.af.horizontal || !o && !ee(h) || o && (fg[h] || (f = h, new RegExp("\\p{sc=Arab}", "u").test(String.fromCodePoint(f)))));
        var f;
      }
      function lP(d, o, h, f, _, v) {
        const w = v[d.fontStack], P = function(D, z, j, Y) {
          if (D && D.rect) return D;
          const K = z[j.fontStack], Q = K && K[Y];
          return Q ? { rect: null, metrics: Q.metrics } : null;
        }(w && w[o], _, d, o);
        if (P === null) return null;
        let R;
        if (h) R = f.verticalLineContentWidth - d.scale * gs;
        else {
          const D = t2(d.verticalAlign);
          R = (f.horizontalLineContentHeight - d.scale * gs) * D;
        }
        return { rect: P.rect, metrics: P.metrics, baselineOffset: R };
      }
      function cP(d, o, h, f, _) {
        const v = _[d.imageName];
        if (!v) return null;
        const w = v.paddedRect, P = v.displaySize, R = { width: P[0], height: P[1], left: sa, top: -3, advance: o ? P[1] : P[0] };
        let D;
        if (o) D = f.verticalLineContentWidth - P[1] * d.scale;
        else {
          const z = t2(d.verticalAlign);
          D = (f.horizontalLineContentHeight - P[1] * d.scale) * z;
        }
        return { rect: w, metrics: R, baselineOffset: D, imageOffset: (o ? P[0] : P[1]) * d.scale - gs * h };
      }
      function uP(d, o, h, f) {
        if (f === 0) return;
        const _ = d[h], v = (d[h].x + _.metrics.advance * _.scale) * f;
        for (let w = o; w <= h; w++) d[w].x -= v;
      }
      function hP(d, o, h) {
        const { horizontalAlign: f, verticalAlign: _ } = G_(h), v = o[0] - d.displaySize[0] * f, w = o[1] - d.displaySize[1] * _;
        return { image: d, top: w, bottom: w + d.displaySize[1], left: v, right: v + d.displaySize[0] };
      }
      function n2(d) {
        var o, h;
        let f = d.left, _ = d.top, v = d.right - f, w = d.bottom - _;
        const P = (o = d.image.textFitWidth) !== null && o !== void 0 ? o : "stretchOrShrink", R = (h = d.image.textFitHeight) !== null && h !== void 0 ? h : "stretchOrShrink", D = (d.image.content[2] - d.image.content[0]) / (d.image.content[3] - d.image.content[1]);
        if (R === "proportional") {
          if (P === "stretchOnly" && v / w < D || P === "proportional") {
            const z = Math.ceil(w * D);
            f *= z / v, v = z;
          }
        } else if (P === "proportional" && R === "stretchOnly" && D !== 0 && v / w > D) {
          const z = Math.ceil(v / D);
          _ *= z / w, w = z;
        }
        return { x1: f, y1: _, x2: f + v, y2: _ + w };
      }
      function i2(d, o, h, f, _, v) {
        const w = d.image;
        let P;
        if (w.content) {
          const Ee = w.content, Se = w.pixelRatio || 1;
          P = [Ee[0] / Se, Ee[1] / Se, w.displaySize[0] - Ee[2] / Se, w.displaySize[1] - Ee[3] / Se];
        }
        const R = o.left * v, D = o.right * v;
        let z, j, Y, K;
        h === "width" || h === "both" ? (K = _[0] + R - f[3], j = _[0] + D + f[1]) : (K = _[0] + (R + D - w.displaySize[0]) / 2, j = K + w.displaySize[0]);
        const Q = o.top * v, se = o.bottom * v;
        return h === "height" || h === "both" ? (z = _[1] + Q - f[0], Y = _[1] + se + f[2]) : (z = _[1] + (Q + se - w.displaySize[1]) / 2, Y = z + w.displaySize[1]), { image: w, top: z, right: j, bottom: Y, left: K, collisionPadding: P };
      }
      const Uf = 255, jc = 128, $u = Uf * jc;
      function r2(d, o) {
        const { expression: h } = o;
        if (h.kind === "constant") return { kind: "constant", layoutSize: h.evaluate(new ut(d + 1)) };
        if (h.kind === "source") return { kind: "source" };
        {
          const { zoomStops: f, interpolationType: _ } = h;
          let v = 0;
          for (; v < f.length && f[v] <= d; ) v++;
          v = Math.max(0, v - 1);
          let w = v;
          for (; w < f.length && f[w] < d + 1; ) w++;
          w = Math.min(f.length - 1, w);
          const P = f[v], R = f[w];
          return h.kind === "composite" ? { kind: "composite", minZoom: P, maxZoom: R, interpolationType: _ } : { kind: "camera", minZoom: P, maxZoom: R, minSize: h.evaluate(new ut(P)), maxSize: h.evaluate(new ut(R)), interpolationType: _ };
        }
      }
      function V_(d, o, h) {
        let f = "never";
        const _ = d.get(o);
        return _ ? f = _ : d.get(h) && (f = "always"), f;
      }
      const dP = Df.VectorTileFeature.types, fP = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
      function pg(d, o, h, f, _, v, w, P, R, D, z, j, Y) {
        const K = P ? Math.min($u, Math.round(P[0])) : 0, Q = P ? Math.min($u, Math.round(P[1])) : 0;
        d.emplaceBack(o, h, Math.round(32 * f), Math.round(32 * _), v, w, (K << 1) + (R ? 1 : 0), Q, 16 * D, 16 * z, 256 * j, 256 * Y);
      }
      function q_(d, o, h) {
        d.emplaceBack(o.x, o.y, h), d.emplaceBack(o.x, o.y, h), d.emplaceBack(o.x, o.y, h), d.emplaceBack(o.x, o.y, h);
      }
      function pP(d) {
        for (const o of d.sections) if (Le(o.text)) return !0;
        return !1;
      }
      class H_ {
        constructor(o) {
          this.layoutVertexArray = new Qe(), this.indexArray = new Ct(), this.programConfigurations = o, this.segments = new dn(), this.dynamicLayoutVertexArray = new wt(), this.opacityVertexArray = new bt(), this.hasVisibleVertices = !1, this.placedSymbolArray = new L();
        }
        isEmpty() {
          return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0;
        }
        upload(o, h, f, _) {
          this.isEmpty() || (f && (this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, ZC.members), this.indexBuffer = o.createIndexBuffer(this.indexArray, h), this.dynamicLayoutVertexBuffer = o.createVertexBuffer(this.dynamicLayoutVertexArray, $C.members, !0), this.opacityVertexBuffer = o.createVertexBuffer(this.opacityVertexArray, fP, !0), this.opacityVertexBuffer.itemSize = 1), (f || _) && this.programConfigurations.upload(o));
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
        }
      }
      vn("SymbolBuffers", H_);
      class W_ {
        constructor(o, h, f) {
          this.layoutVertexArray = new o(), this.layoutAttributes = h, this.indexArray = new f(), this.segments = new dn(), this.collisionVertexArray = new Nt();
        }
        upload(o) {
          this.layoutVertexBuffer = o.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = o.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = o.createVertexBuffer(this.collisionVertexArray, XC.members, !0);
        }
        destroy() {
          this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
        }
      }
      vn("CollisionBuffers", W_);
      class bd {
        constructor(o) {
          this.collisionBoxArray = o.collisionBoxArray, this.zoom = o.zoom, this.overscaling = o.overscaling, this.layers = o.layers, this.layerIds = this.layers.map((w) => w.id), this.index = o.index, this.pixelRatio = o.pixelRatio, this.sourceLayerIndex = o.sourceLayerIndex, this.hasPattern = !1, this.hasRTLText = !1, this.sortKeyRanges = [], this.collisionCircleArray = [];
          const h = this.layers[0]._unevaluatedLayout._values;
          this.textSizeData = r2(this.zoom, h["text-size"]), this.iconSizeData = r2(this.zoom, h["icon-size"]);
          const f = this.layers[0].layout, _ = f.get("symbol-sort-key"), v = f.get("symbol-z-order");
          this.canOverlap = V_(f, "text-overlap", "text-allow-overlap") !== "never" || V_(f, "icon-overlap", "icon-allow-overlap") !== "never" || f.get("text-ignore-placement") || f.get("icon-ignore-placement"), this.sortFeaturesByKey = v !== "viewport-y" && !_.isConstant(), this.sortFeaturesByY = (v === "viewport-y" || v === "auto" && !this.sortFeaturesByKey) && this.canOverlap, f.get("symbol-placement") === "point" && (this.writingModes = f.get("text-writing-mode").map((w) => c.af[w])), this.stateDependentLayerIds = this.layers.filter((w) => w.isStateDependent()).map((w) => w.id), this.sourceID = o.sourceID;
        }
        createArrays() {
          this.text = new H_(new wr(this.layers, this.zoom, (o) => /^text/.test(o))), this.icon = new H_(new wr(this.layers, this.zoom, (o) => /^icon/.test(o))), this.glyphOffsetArray = new G(), this.lineVertexArray = new Z(), this.symbolInstances = new N(), this.textAnchorOffsets = new re();
        }
        calculateGlyphDependencies(o, h, f, _, v) {
          for (let w = 0; w < o.length; w++) if (h[o.charCodeAt(w)] = !0, (f || _) && v) {
            const P = kf[o.charAt(w)];
            P && (h[P.charCodeAt(0)] = !0);
          }
        }
        populate(o, h, f) {
          const _ = this.layers[0], v = _.layout, w = v.get("text-font"), P = v.get("text-field"), R = v.get("icon-image"), D = (P.value.kind !== "constant" || P.value.value instanceof we && !P.value.value.isEmpty() || P.value.value.toString().length > 0) && (w.value.kind !== "constant" || w.value.value.length > 0), z = R.value.kind !== "constant" || !!R.value.value || Object.keys(R.parameters).length > 0, j = v.get("symbol-sort-key");
          if (this.features = [], !D && !z) return;
          const Y = h.iconDependencies, K = h.glyphDependencies, Q = h.availableImages, se = new ut(this.zoom);
          for (const { feature: Ee, id: Se, index: et, sourceLayerIndex: Ne } of o) {
            const J = _._featureFilter.needGeometry, ve = bu(Ee, J);
            if (!_._featureFilter.filter(se, ve, f)) continue;
            let je, vt;
            if (J || (ve.geometry = yu(Ee)), D) {
              const Et = _.getValueAndResolveTokens("text-field", ve, f, Q), Lt = we.factory(Et), Qt = this.hasRTLText = this.hasRTLText || pP(Lt);
              (!Qt || tt.getRTLTextPluginStatus() === "unavailable" || Qt && tt.isParsed()) && (je = JC(Lt, _, ve));
            }
            if (z) {
              const Et = _.getValueAndResolveTokens("icon-image", ve, f, Q);
              vt = Et instanceof Rn ? Et : Rn.fromString(Et);
            }
            if (!je && !vt) continue;
            const Vt = this.sortFeaturesByKey ? j.evaluate(ve, {}, f) : void 0;
            if (this.features.push({ id: Se, text: je, icon: vt, index: et, sourceLayerIndex: Ne, geometry: ve.geometry, properties: Ee.properties, type: dP[Ee.type], sortKey: Vt }), vt && (Y[vt.name] = !0), je) {
              const Et = w.evaluate(ve, {}, f).join(","), Lt = v.get("text-rotation-alignment") !== "viewport" && v.get("symbol-placement") !== "point";
              this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(c.af.vertical) >= 0;
              for (const Qt of je.sections) if (Qt.image) Y[Qt.image.name] = !0;
              else {
                const Ht = zc(je.toString()), rn = Qt.fontStack || Et, Dt = K[rn] = K[rn] || {};
                this.calculateGlyphDependencies(Qt.text, Dt, Lt, this.allowVerticalPlacement, Ht);
              }
            }
          }
          v.get("symbol-placement") === "line" && (this.features = function(Ee) {
            const Se = {}, et = {}, Ne = [];
            let J = 0;
            function ve(Et) {
              Ne.push(Ee[Et]), J++;
            }
            function je(Et, Lt, Qt) {
              const Ht = et[Et];
              return delete et[Et], et[Lt] = Ht, Ne[Ht].geometry[0].pop(), Ne[Ht].geometry[0] = Ne[Ht].geometry[0].concat(Qt[0]), Ht;
            }
            function vt(Et, Lt, Qt) {
              const Ht = Se[Lt];
              return delete Se[Lt], Se[Et] = Ht, Ne[Ht].geometry[0].shift(), Ne[Ht].geometry[0] = Qt[0].concat(Ne[Ht].geometry[0]), Ht;
            }
            function Vt(Et, Lt, Qt) {
              const Ht = Qt ? Lt[0][Lt[0].length - 1] : Lt[0][0];
              return `${Et}:${Ht.x}:${Ht.y}`;
            }
            for (let Et = 0; Et < Ee.length; Et++) {
              const Lt = Ee[Et], Qt = Lt.geometry, Ht = Lt.text ? Lt.text.toString() : null;
              if (!Ht) {
                ve(Et);
                continue;
              }
              const rn = Vt(Ht, Qt), Dt = Vt(Ht, Qt, !0);
              if (rn in et && Dt in Se && et[rn] !== Se[Dt]) {
                const Cn = vt(rn, Dt, Qt), zn = je(rn, Dt, Ne[Cn].geometry);
                delete Se[rn], delete et[Dt], et[Vt(Ht, Ne[zn].geometry, !0)] = zn, Ne[Cn].geometry = null;
              } else rn in et ? je(rn, Dt, Qt) : Dt in Se ? vt(rn, Dt, Qt) : (ve(Et), Se[rn] = J - 1, et[Dt] = J - 1);
            }
            return Ne.filter((Et) => Et.geometry);
          }(this.features)), this.sortFeaturesByKey && this.features.sort((Ee, Se) => Ee.sortKey - Se.sortKey);
        }
        update(o, h, f) {
          this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(o, h, this.layers, f), this.icon.programConfigurations.updatePaintArrays(o, h, this.layers, f));
        }
        isEmpty() {
          return this.symbolInstances.length === 0 && !this.hasRTLText;
        }
        uploadPending() {
          return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
        }
        upload(o) {
          !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(o), this.iconCollisionBox.upload(o)), this.text.upload(o, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(o, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = !0;
        }
        destroyDebugData() {
          this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
        }
        destroy() {
          this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
        }
        addToLineVertexArray(o, h) {
          const f = this.lineVertexArray.length;
          if (o.segment !== void 0) {
            let _ = o.dist(h[o.segment + 1]), v = o.dist(h[o.segment]);
            const w = {};
            for (let P = o.segment + 1; P < h.length; P++) w[P] = { x: h[P].x, y: h[P].y, tileUnitDistanceFromAnchor: _ }, P < h.length - 1 && (_ += h[P + 1].dist(h[P]));
            for (let P = o.segment || 0; P >= 0; P--) w[P] = { x: h[P].x, y: h[P].y, tileUnitDistanceFromAnchor: v }, P > 0 && (v += h[P - 1].dist(h[P]));
            for (let P = 0; P < h.length; P++) {
              const R = w[P];
              this.lineVertexArray.emplaceBack(R.x, R.y, R.tileUnitDistanceFromAnchor);
            }
          }
          return { lineStartIndex: f, lineLength: this.lineVertexArray.length - f };
        }
        addSymbols(o, h, f, _, v, w, P, R, D, z, j, Y) {
          const K = o.indexArray, Q = o.layoutVertexArray, se = o.segments.prepareSegment(4 * h.length, Q, K, this.canOverlap ? w.sortKey : void 0), Ee = this.glyphOffsetArray.length, Se = se.vertexLength, et = this.allowVerticalPlacement && P === c.af.vertical ? Math.PI / 2 : 0, Ne = w.text && w.text.sections;
          for (let J = 0; J < h.length; J++) {
            const { tl: ve, tr: je, bl: vt, br: Vt, tex: Et, pixelOffsetTL: Lt, pixelOffsetBR: Qt, minFontScaleX: Ht, minFontScaleY: rn, glyphOffset: Dt, isSDF: Cn, sectionIndex: zn } = h[J], Dn = se.vertexLength, Pn = Dt[1];
            pg(Q, R.x, R.y, ve.x, Pn + ve.y, Et.x, Et.y, f, Cn, Lt.x, Lt.y, Ht, rn), pg(Q, R.x, R.y, je.x, Pn + je.y, Et.x + Et.w, Et.y, f, Cn, Qt.x, Lt.y, Ht, rn), pg(Q, R.x, R.y, vt.x, Pn + vt.y, Et.x, Et.y + Et.h, f, Cn, Lt.x, Qt.y, Ht, rn), pg(Q, R.x, R.y, Vt.x, Pn + Vt.y, Et.x + Et.w, Et.y + Et.h, f, Cn, Qt.x, Qt.y, Ht, rn), q_(o.dynamicLayoutVertexArray, R, et), K.emplaceBack(Dn, Dn + 2, Dn + 1), K.emplaceBack(Dn + 1, Dn + 2, Dn + 3), se.vertexLength += 4, se.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(Dt[0]), J !== h.length - 1 && zn === h[J + 1].sectionIndex || o.programConfigurations.populatePaintArrays(Q.length, w, w.index, {}, Y, Ne && Ne[zn]);
          }
          o.placedSymbolArray.emplaceBack(R.x, R.y, Ee, this.glyphOffsetArray.length - Ee, Se, D, z, R.segment, f ? f[0] : 0, f ? f[1] : 0, _[0], _[1], P, 0, !1, 0, j);
        }
        _addCollisionDebugVertex(o, h, f, _, v, w) {
          return h.emplaceBack(0, 0), o.emplaceBack(f.x, f.y, _, v, Math.round(w.x), Math.round(w.y));
        }
        addCollisionDebugVertices(o, h, f, _, v, w, P) {
          const R = v.segments.prepareSegment(4, v.layoutVertexArray, v.indexArray), D = R.vertexLength, z = v.layoutVertexArray, j = v.collisionVertexArray, Y = P.anchorX, K = P.anchorY;
          this._addCollisionDebugVertex(z, j, w, Y, K, new F(o, h)), this._addCollisionDebugVertex(z, j, w, Y, K, new F(f, h)), this._addCollisionDebugVertex(z, j, w, Y, K, new F(f, _)), this._addCollisionDebugVertex(z, j, w, Y, K, new F(o, _)), R.vertexLength += 4;
          const Q = v.indexArray;
          Q.emplaceBack(D, D + 1), Q.emplaceBack(D + 1, D + 2), Q.emplaceBack(D + 2, D + 3), Q.emplaceBack(D + 3, D), R.primitiveLength += 4;
        }
        addDebugCollisionBoxes(o, h, f, _) {
          for (let v = o; v < h; v++) {
            const w = this.collisionBoxArray.get(v);
            this.addCollisionDebugVertices(w.x1, w.y1, w.x2, w.y2, _ ? this.textCollisionBox : this.iconCollisionBox, w.anchorPoint, f);
          }
        }
        generateCollisionDebugBuffers() {
          this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new W_(Mt, Hv.members, sn), this.iconCollisionBox = new W_(Mt, Hv.members, sn);
          for (let o = 0; o < this.symbolInstances.length; o++) {
            const h = this.symbolInstances.get(o);
            this.addDebugCollisionBoxes(h.textBoxStartIndex, h.textBoxEndIndex, h, !0), this.addDebugCollisionBoxes(h.verticalTextBoxStartIndex, h.verticalTextBoxEndIndex, h, !0), this.addDebugCollisionBoxes(h.iconBoxStartIndex, h.iconBoxEndIndex, h, !1), this.addDebugCollisionBoxes(h.verticalIconBoxStartIndex, h.verticalIconBoxEndIndex, h, !1);
          }
        }
        _deserializeCollisionBoxesForSymbol(o, h, f, _, v, w, P, R, D) {
          const z = {};
          for (let j = h; j < f; j++) {
            const Y = o.get(j);
            z.textBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, z.textFeatureIndex = Y.featureIndex;
            break;
          }
          for (let j = _; j < v; j++) {
            const Y = o.get(j);
            z.verticalTextBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, z.verticalTextFeatureIndex = Y.featureIndex;
            break;
          }
          for (let j = w; j < P; j++) {
            const Y = o.get(j);
            z.iconBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, z.iconFeatureIndex = Y.featureIndex;
            break;
          }
          for (let j = R; j < D; j++) {
            const Y = o.get(j);
            z.verticalIconBox = { x1: Y.x1, y1: Y.y1, x2: Y.x2, y2: Y.y2, anchorPointX: Y.anchorPointX, anchorPointY: Y.anchorPointY }, z.verticalIconFeatureIndex = Y.featureIndex;
            break;
          }
          return z;
        }
        deserializeCollisionBoxes(o) {
          this.collisionArrays = [];
          for (let h = 0; h < this.symbolInstances.length; h++) {
            const f = this.symbolInstances.get(h);
            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(o, f.textBoxStartIndex, f.textBoxEndIndex, f.verticalTextBoxStartIndex, f.verticalTextBoxEndIndex, f.iconBoxStartIndex, f.iconBoxEndIndex, f.verticalIconBoxStartIndex, f.verticalIconBoxEndIndex));
          }
        }
        hasTextData() {
          return this.text.segments.get().length > 0;
        }
        hasIconData() {
          return this.icon.segments.get().length > 0;
        }
        hasDebugData() {
          return this.textCollisionBox && this.iconCollisionBox;
        }
        hasTextCollisionBoxData() {
          return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
        }
        hasIconCollisionBoxData() {
          return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
        }
        addIndicesForPlacedSymbol(o, h) {
          const f = o.placedSymbolArray.get(h), _ = f.vertexStartIndex + 4 * f.numGlyphs;
          for (let v = f.vertexStartIndex; v < _; v += 4) o.indexArray.emplaceBack(v, v + 2, v + 1), o.indexArray.emplaceBack(v + 1, v + 2, v + 3);
        }
        getSortedSymbolIndexes(o) {
          if (this.sortedAngle === o && this.symbolInstanceIndexes !== void 0) return this.symbolInstanceIndexes;
          const h = Math.sin(o), f = Math.cos(o), _ = [], v = [], w = [];
          for (let P = 0; P < this.symbolInstances.length; ++P) {
            w.push(P);
            const R = this.symbolInstances.get(P);
            _.push(0 | Math.round(h * R.anchorX + f * R.anchorY)), v.push(R.featureIndex);
          }
          return w.sort((P, R) => _[P] - _[R] || v[R] - v[P]), w;
        }
        addToSortKeyRanges(o, h) {
          const f = this.sortKeyRanges[this.sortKeyRanges.length - 1];
          f && f.sortKey === h ? f.symbolInstanceEnd = o + 1 : this.sortKeyRanges.push({ sortKey: h, symbolInstanceStart: o, symbolInstanceEnd: o + 1 });
        }
        sortFeatures(o) {
          if (this.sortFeaturesByY && this.sortedAngle !== o && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(o), this.sortedAngle = o, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
            for (const h of this.symbolInstanceIndexes) {
              const f = this.symbolInstances.get(h);
              this.featureSortOrder.push(f.featureIndex), [f.rightJustifiedTextSymbolIndex, f.centerJustifiedTextSymbolIndex, f.leftJustifiedTextSymbolIndex].forEach((_, v, w) => {
                _ >= 0 && w.indexOf(_) === v && this.addIndicesForPlacedSymbol(this.text, _);
              }), f.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, f.verticalPlacedTextSymbolIndex), f.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, f.placedIconSymbolIndex), f.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, f.verticalPlacedIconSymbolIndex);
            }
            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
          }
        }
      }
      let s2, o2;
      vn("SymbolBucket", bd, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), bd.MAX_GLYPHS = 65535, bd.addDynamicAttributes = q_;
      var Z_ = { get paint() {
        return o2 = o2 || new ri({ "icon-opacity": new Ut(be.paint_symbol["icon-opacity"]), "icon-color": new Ut(be.paint_symbol["icon-color"]), "icon-halo-color": new Ut(be.paint_symbol["icon-halo-color"]), "icon-halo-width": new Ut(be.paint_symbol["icon-halo-width"]), "icon-halo-blur": new Ut(be.paint_symbol["icon-halo-blur"]), "icon-translate": new ft(be.paint_symbol["icon-translate"]), "icon-translate-anchor": new ft(be.paint_symbol["icon-translate-anchor"]), "text-opacity": new Ut(be.paint_symbol["text-opacity"]), "text-color": new Ut(be.paint_symbol["text-color"], { runtimeType: In, getOverride: (d) => d.textColor, hasOverride: (d) => !!d.textColor }), "text-halo-color": new Ut(be.paint_symbol["text-halo-color"]), "text-halo-width": new Ut(be.paint_symbol["text-halo-width"]), "text-halo-blur": new Ut(be.paint_symbol["text-halo-blur"]), "text-translate": new ft(be.paint_symbol["text-translate"]), "text-translate-anchor": new ft(be.paint_symbol["text-translate-anchor"]) });
      }, get layout() {
        return s2 = s2 || new ri({ "symbol-placement": new ft(be.layout_symbol["symbol-placement"]), "symbol-spacing": new ft(be.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new ft(be.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new Ut(be.layout_symbol["symbol-sort-key"]), "symbol-z-order": new ft(be.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new ft(be.layout_symbol["icon-allow-overlap"]), "icon-overlap": new ft(be.layout_symbol["icon-overlap"]), "icon-ignore-placement": new ft(be.layout_symbol["icon-ignore-placement"]), "icon-optional": new ft(be.layout_symbol["icon-optional"]), "icon-rotation-alignment": new ft(be.layout_symbol["icon-rotation-alignment"]), "icon-size": new Ut(be.layout_symbol["icon-size"]), "icon-text-fit": new ft(be.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new ft(be.layout_symbol["icon-text-fit-padding"]), "icon-image": new Ut(be.layout_symbol["icon-image"]), "icon-rotate": new Ut(be.layout_symbol["icon-rotate"]), "icon-padding": new Ut(be.layout_symbol["icon-padding"]), "icon-keep-upright": new ft(be.layout_symbol["icon-keep-upright"]), "icon-offset": new Ut(be.layout_symbol["icon-offset"]), "icon-anchor": new Ut(be.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new ft(be.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new ft(be.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new ft(be.layout_symbol["text-rotation-alignment"]), "text-field": new Ut(be.layout_symbol["text-field"]), "text-font": new Ut(be.layout_symbol["text-font"]), "text-size": new Ut(be.layout_symbol["text-size"]), "text-max-width": new Ut(be.layout_symbol["text-max-width"]), "text-line-height": new ft(be.layout_symbol["text-line-height"]), "text-letter-spacing": new Ut(be.layout_symbol["text-letter-spacing"]), "text-justify": new Ut(be.layout_symbol["text-justify"]), "text-radial-offset": new Ut(be.layout_symbol["text-radial-offset"]), "text-variable-anchor": new ft(be.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new Ut(be.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new Ut(be.layout_symbol["text-anchor"]), "text-max-angle": new ft(be.layout_symbol["text-max-angle"]), "text-writing-mode": new ft(be.layout_symbol["text-writing-mode"]), "text-rotate": new Ut(be.layout_symbol["text-rotate"]), "text-padding": new ft(be.layout_symbol["text-padding"]), "text-keep-upright": new ft(be.layout_symbol["text-keep-upright"]), "text-transform": new Ut(be.layout_symbol["text-transform"]), "text-offset": new Ut(be.layout_symbol["text-offset"]), "text-allow-overlap": new ft(be.layout_symbol["text-allow-overlap"]), "text-overlap": new ft(be.layout_symbol["text-overlap"]), "text-ignore-placement": new ft(be.layout_symbol["text-ignore-placement"]), "text-optional": new ft(be.layout_symbol["text-optional"]) });
      } };
      class a2 {
        constructor(o) {
          if (o.property.overrides === void 0) throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
          this.type = o.property.overrides ? o.property.overrides.runtimeType : An, this.defaultValue = o;
        }
        evaluate(o) {
          if (o.formattedSection) {
            const h = this.defaultValue.property.overrides;
            if (h && h.hasOverride(o.formattedSection)) return h.getOverride(o.formattedSection);
          }
          return o.feature && o.featureState ? this.defaultValue.evaluate(o.feature, o.featureState) : this.defaultValue.property.specification.default;
        }
        eachChild(o) {
          this.defaultValue.isConstant() || o(this.defaultValue.value._styleExpression.expression);
        }
        outputDefined() {
          return !1;
        }
        serialize() {
          return null;
        }
      }
      vn("FormatSectionOverride", a2, { omit: ["defaultValue"] });
      class gg extends ai {
        constructor(o) {
          super(o, Z_);
        }
        recalculate(o, h) {
          if (super.recalculate(o, h), this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"), this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"), this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), this.layout.get("symbol-placement") === "point") {
            const f = this.layout.get("text-writing-mode");
            if (f) {
              const _ = [];
              for (const v of f) _.indexOf(v) < 0 && _.push(v);
              this.layout._values["text-writing-mode"] = _;
            } else this.layout._values["text-writing-mode"] = ["horizontal"];
          }
          this._setPaintOverrides();
        }
        getValueAndResolveTokens(o, h, f, _) {
          const v = this.layout.get(o).evaluate(h, {}, f, _), w = this._unevaluatedLayout._values[o];
          return w.isDataDriven() || Ua(w.value) || !v ? v : function(P, R) {
            return R.replace(/{([^{}]+)}/g, (D, z) => P && z in P ? String(P[z]) : "");
          }(h.properties, v);
        }
        createBucket(o) {
          return new bd(o);
        }
        queryRadius() {
          return 0;
        }
        queryIntersectsFeature() {
          throw new Error("Should take a different path in FeatureIndex");
        }
        _setPaintOverrides() {
          for (const o of Z_.paint.overridableProperties) {
            if (!gg.hasPaintOverride(this.layout, o)) continue;
            const h = this.paint.get(o), f = new a2(h), _ = new fl(f, h.property.specification);
            let v = null;
            v = h.value.kind === "constant" || h.value.kind === "source" ? new pl("source", _) : new Xl("composite", _, h.value.zoomStops), this.paint._values[o] = new jt(h.property, v, h.parameters);
          }
        }
        _handleOverridablePaintPropertyUpdate(o, h, f) {
          return !(!this.layout || h.isDataDriven() || f.isDataDriven()) && gg.hasPaintOverride(this.layout, o);
        }
        static hasPaintOverride(o, h) {
          const f = o.get("text-field"), _ = Z_.paint.properties[h];
          let v = !1;
          const w = (P) => {
            for (const R of P) if (_.overrides && _.overrides.hasOverride(R)) return void (v = !0);
          };
          if (f.value.kind === "constant" && f.value.value instanceof we) w(f.value.value.sections);
          else if (f.value.kind === "source") {
            const P = (D) => {
              v || (D instanceof ho && qn(D.value) === Er ? w(D.value.sections) : D instanceof La ? w(D.sections) : D.eachChild(P));
            }, R = f.value;
            R._styleExpression && P(R._styleExpression.expression);
          }
          return v;
        }
      }
      let l2;
      var gP = { get paint() {
        return l2 = l2 || new ri({ "background-color": new ft(be.paint_background["background-color"]), "background-pattern": new jn(be.paint_background["background-pattern"]), "background-opacity": new ft(be.paint_background["background-opacity"]) });
      } };
      class mP extends ai {
        constructor(o) {
          super(o, gP);
        }
      }
      let c2;
      var _P = { get paint() {
        return c2 = c2 || new ri({ "raster-opacity": new ft(be.paint_raster["raster-opacity"]), "raster-hue-rotate": new ft(be.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new ft(be.paint_raster["raster-brightness-min"]), "raster-brightness-max": new ft(be.paint_raster["raster-brightness-max"]), "raster-saturation": new ft(be.paint_raster["raster-saturation"]), "raster-contrast": new ft(be.paint_raster["raster-contrast"]), "raster-resampling": new ft(be.paint_raster["raster-resampling"]), "raster-fade-duration": new ft(be.paint_raster["raster-fade-duration"]) });
      } };
      class yP extends ai {
        constructor(o) {
          super(o, _P);
        }
      }
      class bP extends ai {
        constructor(o) {
          super(o, {}), this.onAdd = (h) => {
            this.implementation.onAdd && this.implementation.onAdd(h, h.painter.context.gl);
          }, this.onRemove = (h) => {
            this.implementation.onRemove && this.implementation.onRemove(h, h.painter.context.gl);
          }, this.implementation = o;
        }
        is3D() {
          return this.implementation.renderingMode === "3d";
        }
        hasOffscreenPass() {
          return this.implementation.prerender !== void 0;
        }
        recalculate() {
        }
        updateTransitions() {
        }
        hasTransition() {
          return !1;
        }
        serialize() {
          throw new Error("Custom layers cannot be serialized");
        }
      }
      class vP {
        constructor(o) {
          this._methodToThrottle = o, this._triggered = !1, typeof MessageChannel < "u" && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
            this._triggered = !1, this._methodToThrottle();
          });
        }
        trigger() {
          this._triggered || (this._triggered = !0, this._channel ? this._channel.port1.postMessage(!0) : setTimeout(() => {
            this._triggered = !1, this._methodToThrottle();
          }, 0));
        }
        remove() {
          delete this._channel, this._methodToThrottle = () => {
          };
        }
      }
      const $_ = 63710088e-1;
      class Xu {
        constructor(o, h) {
          if (isNaN(o) || isNaN(h)) throw new Error(`Invalid LngLat object: (${o}, ${h})`);
          if (this.lng = +o, this.lat = +h, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
        }
        wrap() {
          return new Xu(ze(this.lng, -180, 180), this.lat);
        }
        toArray() {
          return [this.lng, this.lat];
        }
        toString() {
          return `LngLat(${this.lng}, ${this.lat})`;
        }
        distanceTo(o) {
          const h = Math.PI / 180, f = this.lat * h, _ = o.lat * h, v = Math.sin(f) * Math.sin(_) + Math.cos(f) * Math.cos(_) * Math.cos((o.lng - this.lng) * h);
          return $_ * Math.acos(Math.min(v, 1));
        }
        static convert(o) {
          if (o instanceof Xu) return o;
          if (Array.isArray(o) && (o.length === 2 || o.length === 3)) return new Xu(Number(o[0]), Number(o[1]));
          if (!Array.isArray(o) && typeof o == "object" && o !== null) return new Xu(Number("lng" in o ? o.lng : o.lon), Number(o.lat));
          throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
        }
      }
      const u2 = 2 * Math.PI * $_;
      function h2(d) {
        return u2 * Math.cos(d * Math.PI / 180);
      }
      function d2(d) {
        return (180 + d) / 360;
      }
      function f2(d) {
        return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + d * Math.PI / 360))) / 360;
      }
      function p2(d, o) {
        return d / h2(o);
      }
      function X_(d) {
        return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * d) * Math.PI / 180)) - 90;
      }
      function g2(d, o) {
        return d * h2(X_(o));
      }
      class jf {
        constructor(o, h) {
          let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          this.x = +o, this.y = +h, this.z = +f;
        }
        static fromLngLat(o) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          const f = Xu.convert(o);
          return new jf(d2(f.lng), f2(f.lat), p2(h, f.lat));
        }
        toLngLat() {
          return new Xu(360 * this.x - 180, X_(this.y));
        }
        toAltitude() {
          return g2(this.z, this.y);
        }
        meterInMercatorCoordinateUnits() {
          return 1 / u2 * (o = X_(this.y), 1 / Math.cos(o * Math.PI / 180));
          var o;
        }
      }
      function m2(d, o, h) {
        var f = 2 * Math.PI * 6378137 / 256 / Math.pow(2, h);
        return [d * f - 2 * Math.PI * 6378137 / 2, o * f - 2 * Math.PI * 6378137 / 2];
      }
      class Y_ {
        constructor(o, h, f) {
          if (!function(_, v, w) {
            return !(_ < 0 || _ > 25 || w < 0 || w >= Math.pow(2, _) || v < 0 || v >= Math.pow(2, _));
          }(o, h, f)) throw new Error(`x=${h}, y=${f}, z=${o} outside of bounds. 0<=x<${Math.pow(2, o)}, 0<=y<${Math.pow(2, o)} 0<=z<=25 `);
          this.z = o, this.x = h, this.y = f, this.key = vd(0, o, o, h, f);
        }
        equals(o) {
          return this.z === o.z && this.x === o.x && this.y === o.y;
        }
        url(o, h, f) {
          const _ = (w = this.y, P = this.z, R = m2(256 * (v = this.x), 256 * (w = Math.pow(2, P) - w - 1), P), D = m2(256 * (v + 1), 256 * (w + 1), P), R[0] + "," + R[1] + "," + D[0] + "," + D[1]);
          var v, w, P, R, D;
          const z = function(j, Y, K) {
            let Q, se = "";
            for (let Ee = j; Ee > 0; Ee--) Q = 1 << Ee - 1, se += (Y & Q ? 1 : 0) + (K & Q ? 2 : 0);
            return se;
          }(this.z, this.x, this.y);
          return o[(this.x + this.y) % o.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(f === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, h > 1 ? "@2x" : "").replace(/{quadkey}/g, z).replace(/{bbox-epsg-3857}/g, _);
        }
        isChildOf(o) {
          const h = this.z - o.z;
          return h > 0 && o.x === this.x >> h && o.y === this.y >> h;
        }
        getTilePoint(o) {
          const h = Math.pow(2, this.z);
          return new F((o.x * h - this.x) * dt, (o.y * h - this.y) * dt);
        }
        toString() {
          return `${this.z}/${this.x}/${this.y}`;
        }
      }
      class _2 {
        constructor(o, h) {
          this.wrap = o, this.canonical = h, this.key = vd(o, h.z, h.z, h.x, h.y);
        }
      }
      class Ha {
        constructor(o, h, f, _, v) {
          if (this.terrainRttPosMatrix32f = null, o < f) throw new Error(`overscaledZ should be >= z; overscaledZ = ${o}; z = ${f}`);
          this.overscaledZ = o, this.wrap = h, this.canonical = new Y_(f, +_, +v), this.key = vd(h, o, f, _, v);
        }
        clone() {
          return new Ha(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        equals(o) {
          return this.overscaledZ === o.overscaledZ && this.wrap === o.wrap && this.canonical.equals(o.canonical);
        }
        scaledTo(o) {
          if (o > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${o}; overscaledZ = ${this.overscaledZ}`);
          const h = this.canonical.z - o;
          return o > this.canonical.z ? new Ha(o, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Ha(o, this.wrap, o, this.canonical.x >> h, this.canonical.y >> h);
        }
        calculateScaledKey(o, h) {
          if (o > this.overscaledZ) throw new Error(`targetZ > this.overscaledZ; targetZ = ${o}; overscaledZ = ${this.overscaledZ}`);
          const f = this.canonical.z - o;
          return o > this.canonical.z ? vd(this.wrap * +h, o, this.canonical.z, this.canonical.x, this.canonical.y) : vd(this.wrap * +h, o, o, this.canonical.x >> f, this.canonical.y >> f);
        }
        isChildOf(o) {
          if (o.wrap !== this.wrap) return !1;
          const h = this.canonical.z - o.canonical.z;
          return o.overscaledZ === 0 || o.overscaledZ < this.overscaledZ && o.canonical.x === this.canonical.x >> h && o.canonical.y === this.canonical.y >> h;
        }
        children(o) {
          if (this.overscaledZ >= o) return [new Ha(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
          const h = this.canonical.z + 1, f = 2 * this.canonical.x, _ = 2 * this.canonical.y;
          return [new Ha(h, this.wrap, h, f, _), new Ha(h, this.wrap, h, f + 1, _), new Ha(h, this.wrap, h, f, _ + 1), new Ha(h, this.wrap, h, f + 1, _ + 1)];
        }
        isLessThan(o) {
          return this.wrap < o.wrap || !(this.wrap > o.wrap) && (this.overscaledZ < o.overscaledZ || !(this.overscaledZ > o.overscaledZ) && (this.canonical.x < o.canonical.x || !(this.canonical.x > o.canonical.x) && this.canonical.y < o.canonical.y));
        }
        wrapped() {
          return new Ha(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        unwrapTo(o) {
          return new Ha(this.overscaledZ, o, this.canonical.z, this.canonical.x, this.canonical.y);
        }
        overscaleFactor() {
          return Math.pow(2, this.overscaledZ - this.canonical.z);
        }
        toUnwrapped() {
          return new _2(this.wrap, this.canonical);
        }
        toString() {
          return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
        }
        getTilePoint(o) {
          return this.canonical.getTilePoint(new jf(o.x - this.wrap, o.y));
        }
      }
      function vd(d, o, h, f, _) {
        (d *= 2) < 0 && (d = -1 * d - 1);
        const v = 1 << h;
        return (v * v * d + v * _ + f).toString(36) + h.toString(36) + o.toString(36);
      }
      vn("CanonicalTileID", Y_), vn("OverscaledTileID", Ha, { omit: ["terrainRttPosMatrix32f"] });
      class y2 {
        constructor(o, h, f) {
          let _ = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1, v = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1, w = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1, P = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 0;
          if (this.uid = o, h.height !== h.width) throw new RangeError("DEM tiles must be square");
          if (f && !["mapbox", "terrarium", "custom"].includes(f)) return void Wt(`"${f}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
          this.stride = h.height;
          const R = this.dim = h.height - 2;
          switch (this.data = new Uint32Array(h.data.buffer), f) {
            case "terrarium":
              this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
              break;
            case "custom":
              this.redFactor = _, this.greenFactor = v, this.blueFactor = w, this.baseShift = P;
              break;
            default:
              this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
          }
          for (let D = 0; D < R; D++) this.data[this._idx(-1, D)] = this.data[this._idx(0, D)], this.data[this._idx(R, D)] = this.data[this._idx(R - 1, D)], this.data[this._idx(D, -1)] = this.data[this._idx(D, 0)], this.data[this._idx(D, R)] = this.data[this._idx(D, R - 1)];
          this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(R, -1)] = this.data[this._idx(R - 1, 0)], this.data[this._idx(-1, R)] = this.data[this._idx(0, R - 1)], this.data[this._idx(R, R)] = this.data[this._idx(R - 1, R - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
          for (let D = 0; D < R; D++) for (let z = 0; z < R; z++) {
            const j = this.get(D, z);
            j > this.max && (this.max = j), j < this.min && (this.min = j);
          }
        }
        get(o, h) {
          const f = new Uint8Array(this.data.buffer), _ = 4 * this._idx(o, h);
          return this.unpack(f[_], f[_ + 1], f[_ + 2]);
        }
        getUnpackVector() {
          return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
        }
        _idx(o, h) {
          if (o < -1 || o >= this.dim + 1 || h < -1 || h >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
          return (h + 1) * this.stride + (o + 1);
        }
        unpack(o, h, f) {
          return o * this.redFactor + h * this.greenFactor + f * this.blueFactor - this.baseShift;
        }
        getPixels() {
          return new qa({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
        }
        backfillBorder(o, h, f) {
          if (this.dim !== o.dim) throw new Error("dem dimension mismatch");
          let _ = h * this.dim, v = h * this.dim + this.dim, w = f * this.dim, P = f * this.dim + this.dim;
          switch (h) {
            case -1:
              _ = v - 1;
              break;
            case 1:
              v = _ + 1;
          }
          switch (f) {
            case -1:
              w = P - 1;
              break;
            case 1:
              P = w + 1;
          }
          const R = -h * this.dim, D = -f * this.dim;
          for (let z = w; z < P; z++) for (let j = _; j < v; j++) this.data[this._idx(j, z)] = o.data[this._idx(j + R, z + D)];
        }
      }
      vn("DEMData", y2);
      class b2 {
        constructor(o) {
          this._stringToNumber = {}, this._numberToString = [];
          for (let h = 0; h < o.length; h++) {
            const f = o[h];
            this._stringToNumber[f] = h, this._numberToString[h] = f;
          }
        }
        encode(o) {
          return this._stringToNumber[o];
        }
        decode(o) {
          if (o >= this._numberToString.length) throw new Error(`Out of bounds. Index requested n=${o} can't be >= this._numberToString.length ${this._numberToString.length}`);
          return this._numberToString[o];
        }
      }
      class v2 {
        constructor(o, h, f, _, v) {
          this.type = "Feature", this._vectorTileFeature = o, o._z = h, o._x = f, o._y = _, this.properties = o.properties, this.id = v;
        }
        get geometry() {
          return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
        }
        set geometry(o) {
          this._geometry = o;
        }
        toJSON() {
          const o = { geometry: this.geometry };
          for (const h in this) h !== "_geometry" && h !== "_vectorTileFeature" && (o[h] = this[h]);
          return o;
        }
      }
      class x2 {
        constructor(o, h) {
          this.tileID = o, this.x = o.canonical.x, this.y = o.canonical.y, this.z = o.canonical.z, this.grid = new yl(dt, 16, 0), this.grid3D = new yl(dt, 16, 0), this.featureIndexArray = new Pe(), this.promoteId = h;
        }
        insert(o, h, f, _, v, w) {
          const P = this.featureIndexArray.length;
          this.featureIndexArray.emplaceBack(f, _, v);
          const R = w ? this.grid3D : this.grid;
          for (let D = 0; D < h.length; D++) {
            const z = h[D], j = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let Y = 0; Y < z.length; Y++) {
              const K = z[Y];
              j[0] = Math.min(j[0], K.x), j[1] = Math.min(j[1], K.y), j[2] = Math.max(j[2], K.x), j[3] = Math.max(j[3], K.y);
            }
            j[0] < dt && j[1] < dt && j[2] >= 0 && j[3] >= 0 && R.insert(P, j[0], j[1], j[2], j[3]);
          }
        }
        loadVTLayers() {
          return this.vtLayers || (this.vtLayers = new Df.VectorTile(new k_(this.rawTileData)).layers, this.sourceLayerCoder = new b2(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
        }
        query(o, h, f, _) {
          this.loadVTLayers();
          const v = o.params, w = dt / o.tileSize / o.scale, P = Jl(v.filter), R = o.queryGeometry, D = o.queryPadding * w, z = A2(R), j = this.grid.query(z.minX - D, z.minY - D, z.maxX + D, z.maxY + D), Y = A2(o.cameraQueryGeometry), K = this.grid3D.query(Y.minX - D, Y.minY - D, Y.maxX + D, Y.maxY + D, (Ee, Se, et, Ne) => function(J, ve, je, vt, Vt) {
            for (const Lt of J) if (ve <= Lt.x && je <= Lt.y && vt >= Lt.x && Vt >= Lt.y) return !0;
            const Et = [new F(ve, je), new F(ve, Vt), new F(vt, Vt), new F(vt, je)];
            if (J.length > 2) {
              for (const Lt of Et) if (pd(J, Lt)) return !0;
            }
            for (let Lt = 0; Lt < J.length - 1; Lt++) if (cC(J[Lt], J[Lt + 1], Et)) return !0;
            return !1;
          }(o.cameraQueryGeometry, Ee - D, Se - D, et + D, Ne + D));
          for (const Ee of K) j.push(Ee);
          j.sort(xP);
          const Q = {};
          let se;
          for (let Ee = 0; Ee < j.length; Ee++) {
            const Se = j[Ee];
            if (Se === se) continue;
            se = Se;
            const et = this.featureIndexArray.get(Se);
            let Ne = null;
            this.loadMatchingFeature(Q, et.bucketIndex, et.sourceLayerIndex, et.featureIndex, P, v.layers, v.availableImages, h, f, _, (J, ve, je) => (Ne || (Ne = yu(J)), ve.queryIntersectsFeature({ queryGeometry: R, feature: J, featureState: je, geometry: Ne, zoom: this.z, transform: o.transform, pixelsToTileUnits: w, pixelPosMatrix: o.pixelPosMatrix })));
          }
          return Q;
        }
        loadMatchingFeature(o, h, f, _, v, w, P, R, D, z, j) {
          const Y = this.bucketLayerIDs[h];
          if (w && !Y.some((Ee) => w.has(Ee))) return;
          const K = this.sourceLayerCoder.decode(f), Q = this.vtLayers[K].feature(_);
          if (v.needGeometry) {
            const Ee = bu(Q, !0);
            if (!v.filter(new ut(this.tileID.overscaledZ), Ee, this.tileID.canonical)) return;
          } else if (!v.filter(new ut(this.tileID.overscaledZ), Q)) return;
          const se = this.getId(Q, K);
          for (let Ee = 0; Ee < Y.length; Ee++) {
            const Se = Y[Ee];
            if (w && !w.has(Se)) continue;
            const et = R[Se];
            if (!et) continue;
            let Ne = {};
            se && z && (Ne = z.getState(et.sourceLayer || "_geojsonTileLayer", se));
            const J = Xe({}, D[Se]);
            J.paint = w2(J.paint, et.paint, Q, Ne, P), J.layout = w2(J.layout, et.layout, Q, Ne, P);
            const ve = !j || j(Q, et, Ne);
            if (!ve) continue;
            const je = new v2(Q, this.z, this.x, this.y, se);
            je.layer = J;
            let vt = o[Se];
            vt === void 0 && (vt = o[Se] = []), vt.push({ featureIndex: _, feature: je, intersectionZ: ve });
          }
        }
        lookupSymbolFeatures(o, h, f, _, v, w, P, R) {
          const D = {};
          this.loadVTLayers();
          const z = Jl(v);
          for (const j of o) this.loadMatchingFeature(D, f, _, j, z, w, P, R, h);
          return D;
        }
        hasLayer(o) {
          for (const h of this.bucketLayerIDs) for (const f of h) if (o === f) return !0;
          return !1;
        }
        getId(o, h) {
          var f;
          let _ = o.id;
          return this.promoteId && (_ = o.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[h]], typeof _ == "boolean" && (_ = Number(_)), _ === void 0 && (!((f = o.properties) === null || f === void 0) && f.cluster) && this.promoteId && (_ = Number(o.properties.cluster_id))), _;
        }
      }
      function w2(d, o, h, f, _) {
        return rt(d, (v, w) => {
          const P = o instanceof Zt ? o.get(w) : null;
          return P && P.evaluate ? P.evaluate(h, f, _) : P;
        });
      }
      function A2(d) {
        let o = 1 / 0, h = 1 / 0, f = -1 / 0, _ = -1 / 0;
        for (const v of d) o = Math.min(o, v.x), h = Math.min(h, v.y), f = Math.max(f, v.x), _ = Math.max(_, v.y);
        return { minX: o, minY: h, maxX: f, maxY: _ };
      }
      function xP(d, o) {
        return o - d;
      }
      function T2(d, o, h, f, _) {
        const v = [];
        for (let w = 0; w < d.length; w++) {
          const P = d[w];
          let R;
          for (let D = 0; D < P.length - 1; D++) {
            let z = P[D], j = P[D + 1];
            z.x < o && j.x < o || (z.x < o ? z = new F(o, z.y + (o - z.x) / (j.x - z.x) * (j.y - z.y))._round() : j.x < o && (j = new F(o, z.y + (o - z.x) / (j.x - z.x) * (j.y - z.y))._round()), z.y < h && j.y < h || (z.y < h ? z = new F(z.x + (h - z.y) / (j.y - z.y) * (j.x - z.x), h)._round() : j.y < h && (j = new F(z.x + (h - z.y) / (j.y - z.y) * (j.x - z.x), h)._round()), z.x >= f && j.x >= f || (z.x >= f ? z = new F(f, z.y + (f - z.x) / (j.x - z.x) * (j.y - z.y))._round() : j.x >= f && (j = new F(f, z.y + (f - z.x) / (j.x - z.x) * (j.y - z.y))._round()), z.y >= _ && j.y >= _ || (z.y >= _ ? z = new F(z.x + (_ - z.y) / (j.y - z.y) * (j.x - z.x), _)._round() : j.y >= _ && (j = new F(z.x + (_ - z.y) / (j.y - z.y) * (j.x - z.x), _)._round()), R && z.equals(R[R.length - 1]) || (R = [z], v.push(R)), R.push(j)))));
          }
        }
        return v;
      }
      vn("FeatureIndex", x2, { omit: ["rawTileData", "sourceLayerCoder"] });
      class Yu extends F {
        constructor(o, h, f, _) {
          super(o, h), this.angle = f, _ !== void 0 && (this.segment = _);
        }
        clone() {
          return new Yu(this.x, this.y, this.angle, this.segment);
        }
      }
      function E2(d, o, h, f, _) {
        if (o.segment === void 0 || h === 0) return !0;
        let v = o, w = o.segment + 1, P = 0;
        for (; P > -h / 2; ) {
          if (w--, w < 0) return !1;
          P -= d[w].dist(v), v = d[w];
        }
        P += d[w].dist(d[w + 1]), w++;
        const R = [];
        let D = 0;
        for (; P < h / 2; ) {
          const z = d[w], j = d[w + 1];
          if (!j) return !1;
          let Y = d[w - 1].angleTo(z) - z.angleTo(j);
          for (Y = Math.abs((Y + 3 * Math.PI) % (2 * Math.PI) - Math.PI), R.push({ distance: P, angleDelta: Y }), D += Y; P - R[0].distance > f; ) D -= R.shift().angleDelta;
          if (D > _) return !1;
          w++, P += z.dist(j);
        }
        return !0;
      }
      function S2(d) {
        let o = 0;
        for (let h = 0; h < d.length - 1; h++) o += d[h].dist(d[h + 1]);
        return o;
      }
      function C2(d, o, h) {
        return d ? 0.6 * o * h : 0;
      }
      function P2(d, o) {
        return Math.max(d ? d.right - d.left : 0, o ? o.right - o.left : 0);
      }
      function wP(d, o, h, f, _, v) {
        const w = C2(h, _, v), P = P2(h, f) * v;
        let R = 0;
        const D = S2(d) / 2;
        for (let z = 0; z < d.length - 1; z++) {
          const j = d[z], Y = d[z + 1], K = j.dist(Y);
          if (R + K > D) {
            const Q = (D - R) / K, se = fo.number(j.x, Y.x, Q), Ee = fo.number(j.y, Y.y, Q), Se = new Yu(se, Ee, Y.angleTo(j), z);
            return Se._round(), !w || E2(d, Se, P, w, o) ? Se : void 0;
          }
          R += K;
        }
      }
      function AP(d, o, h, f, _, v, w, P, R) {
        const D = C2(f, v, w), z = P2(f, _), j = z * w, Y = d[0].x === 0 || d[0].x === R || d[0].y === 0 || d[0].y === R;
        return o - j < o / 4 && (o = j + o / 4), I2(d, Y ? o / 2 * P % o : (z / 2 + 2 * v) * w * P % o, o, D, h, j, Y, !1, R);
      }
      function I2(d, o, h, f, _, v, w, P, R) {
        const D = v / 2, z = S2(d);
        let j = 0, Y = o - h, K = [];
        for (let Q = 0; Q < d.length - 1; Q++) {
          const se = d[Q], Ee = d[Q + 1], Se = se.dist(Ee), et = Ee.angleTo(se);
          for (; Y + h < j + Se; ) {
            Y += h;
            const Ne = (Y - j) / Se, J = fo.number(se.x, Ee.x, Ne), ve = fo.number(se.y, Ee.y, Ne);
            if (J >= 0 && J < R && ve >= 0 && ve < R && Y - D >= 0 && Y + D <= z) {
              const je = new Yu(J, ve, et, Q);
              je._round(), f && !E2(d, je, v, f, _) || K.push(je);
            }
          }
          j += Se;
        }
        return P || K.length || w || (K = I2(d, j / 2, h, f, _, v, w, !0, R)), K;
      }
      vn("Anchor", Yu);
      const Gf = sa;
      function M2(d, o, h, f) {
        const _ = [], v = d.image, w = v.pixelRatio, P = v.paddedRect.w - 2 * Gf, R = v.paddedRect.h - 2 * Gf;
        let D = { x1: d.left, y1: d.top, x2: d.right, y2: d.bottom };
        const z = v.stretchX || [[0, P]], j = v.stretchY || [[0, R]], Y = (Dt, Cn) => Dt + Cn[1] - Cn[0], K = z.reduce(Y, 0), Q = j.reduce(Y, 0), se = P - K, Ee = R - Q;
        let Se = 0, et = K, Ne = 0, J = Q, ve = 0, je = se, vt = 0, Vt = Ee;
        if (v.content && f) {
          const Dt = v.content, Cn = Dt[2] - Dt[0], zn = Dt[3] - Dt[1];
          (v.textFitWidth || v.textFitHeight) && (D = n2(d)), Se = mg(z, 0, Dt[0]), Ne = mg(j, 0, Dt[1]), et = mg(z, Dt[0], Dt[2]), J = mg(j, Dt[1], Dt[3]), ve = Dt[0] - Se, vt = Dt[1] - Ne, je = Cn - et, Vt = zn - J;
        }
        const Et = D.x1, Lt = D.y1, Qt = D.x2 - Et, Ht = D.y2 - Lt, rn = (Dt, Cn, zn, Dn) => {
          const Pn = _g(Dt.stretch - Se, et, Qt, Et), vi = yg(Dt.fixed - ve, je, Dt.stretch, K), Rr = _g(Cn.stretch - Ne, J, Ht, Lt), Kr = yg(Cn.fixed - vt, Vt, Cn.stretch, Q), Fo = _g(zn.stretch - Se, et, Qt, Et), oa = yg(zn.fixed - ve, je, zn.stretch, K), aa = _g(Dn.stretch - Ne, J, Ht, Lt), zs = yg(Dn.fixed - vt, Vt, Dn.stretch, Q), Ur = new F(Pn, Rr), ms = new F(Fo, Rr), Us = new F(Fo, aa), Qr = new F(Pn, aa), No = new F(vi / w, Kr / w), Wa = new F(oa / w, zs / w), Ps = o * Math.PI / 180;
          if (Ps) {
            const Is = Math.sin(Ps), Ms = Math.cos(Ps), es = [Ms, -Is, Is, Ms];
            Ur._matMult(es), ms._matMult(es), Qr._matMult(es), Us._matMult(es);
          }
          const la = Dt.stretch + Dt.fixed, _s = Cn.stretch + Cn.fixed;
          return { tl: Ur, tr: ms, bl: Qr, br: Us, tex: { x: v.paddedRect.x + Gf + la, y: v.paddedRect.y + Gf + _s, w: zn.stretch + zn.fixed - la, h: Dn.stretch + Dn.fixed - _s }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: No, pixelOffsetBR: Wa, minFontScaleX: je / w / Qt, minFontScaleY: Vt / w / Ht, isSDF: h };
        };
        if (f && (v.stretchX || v.stretchY)) {
          const Dt = L2(z, se, K), Cn = L2(j, Ee, Q);
          for (let zn = 0; zn < Dt.length - 1; zn++) {
            const Dn = Dt[zn], Pn = Dt[zn + 1];
            for (let vi = 0; vi < Cn.length - 1; vi++) _.push(rn(Dn, Cn[vi], Pn, Cn[vi + 1]));
          }
        } else _.push(rn({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: P + 1 }, { fixed: 0, stretch: R + 1 }));
        return _;
      }
      function mg(d, o, h) {
        let f = 0;
        for (const _ of d) f += Math.max(o, Math.min(h, _[1])) - Math.max(o, Math.min(h, _[0]));
        return f;
      }
      function L2(d, o, h) {
        const f = [{ fixed: -1, stretch: 0 }];
        for (const [_, v] of d) {
          const w = f[f.length - 1];
          f.push({ fixed: _ - w.stretch, stretch: w.stretch }), f.push({ fixed: _ - w.stretch, stretch: w.stretch + (v - _) });
        }
        return f.push({ fixed: o + Gf, stretch: h }), f;
      }
      function _g(d, o, h, f) {
        return d / o * h + f;
      }
      function yg(d, o, h, f) {
        return d - o * h / f;
      }
      class bg {
        constructor(o, h, f, _, v, w, P, R, D, z) {
          var j;
          if (this.boxStartIndex = o.length, D) {
            let Y = w.top, K = w.bottom;
            const Q = w.collisionPadding;
            Q && (Y -= Q[1], K += Q[3]);
            let se = K - Y;
            se > 0 && (se = Math.max(10, se), this.circleDiameter = se);
          } else {
            const Y = !((j = w.image) === null || j === void 0) && j.content && (w.image.textFitWidth || w.image.textFitHeight) ? n2(w) : { x1: w.left, y1: w.top, x2: w.right, y2: w.bottom };
            Y.y1 = Y.y1 * P - R[0], Y.y2 = Y.y2 * P + R[2], Y.x1 = Y.x1 * P - R[3], Y.x2 = Y.x2 * P + R[1];
            const K = w.collisionPadding;
            if (K && (Y.x1 -= K[0] * P, Y.y1 -= K[1] * P, Y.x2 += K[2] * P, Y.y2 += K[3] * P), z) {
              const Q = new F(Y.x1, Y.y1), se = new F(Y.x2, Y.y1), Ee = new F(Y.x1, Y.y2), Se = new F(Y.x2, Y.y2), et = z * Math.PI / 180;
              Q._rotate(et), se._rotate(et), Ee._rotate(et), Se._rotate(et), Y.x1 = Math.min(Q.x, se.x, Ee.x, Se.x), Y.x2 = Math.max(Q.x, se.x, Ee.x, Se.x), Y.y1 = Math.min(Q.y, se.y, Ee.y, Se.y), Y.y2 = Math.max(Q.y, se.y, Ee.y, Se.y);
            }
            o.emplaceBack(h.x, h.y, Y.x1, Y.y1, Y.x2, Y.y2, f, _, v);
          }
          this.boxEndIndex = o.length;
        }
      }
      class TP {
        constructor() {
          let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (f, _) => f < _ ? -1 : f > _ ? 1 : 0;
          if (this.data = o, this.length = this.data.length, this.compare = h, this.length > 0) for (let f = (this.length >> 1) - 1; f >= 0; f--) this._down(f);
        }
        push(o) {
          this.data.push(o), this._up(this.length++);
        }
        pop() {
          if (this.length === 0) return;
          const o = this.data[0], h = this.data.pop();
          return --this.length > 0 && (this.data[0] = h, this._down(0)), o;
        }
        peek() {
          return this.data[0];
        }
        _up(o) {
          const { data: h, compare: f } = this, _ = h[o];
          for (; o > 0; ) {
            const v = o - 1 >> 1, w = h[v];
            if (f(_, w) >= 0) break;
            h[o] = w, o = v;
          }
          h[o] = _;
        }
        _down(o) {
          const { data: h, compare: f } = this, _ = this.length >> 1, v = h[o];
          for (; o < _; ) {
            let w = 1 + (o << 1);
            const P = w + 1;
            if (P < this.length && f(h[P], h[w]) < 0 && (w = P), f(h[w], v) >= 0) break;
            h[o] = h[w], o = w;
          }
          h[o] = v;
        }
      }
      function EP(d) {
        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, h = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, f = 1 / 0, _ = 1 / 0, v = -1 / 0, w = -1 / 0;
        const P = d[0];
        for (let K = 0; K < P.length; K++) {
          const Q = P[K];
          (!K || Q.x < f) && (f = Q.x), (!K || Q.y < _) && (_ = Q.y), (!K || Q.x > v) && (v = Q.x), (!K || Q.y > w) && (w = Q.y);
        }
        const R = Math.min(v - f, w - _);
        let D = R / 2;
        const z = new TP([], SP);
        if (R === 0) return new F(f, _);
        for (let K = f; K < v; K += R) for (let Q = _; Q < w; Q += R) z.push(new xd(K + D, Q + D, D, d));
        let j = function(K) {
          let Q = 0, se = 0, Ee = 0;
          const Se = K[0];
          for (let et = 0, Ne = Se.length, J = Ne - 1; et < Ne; J = et++) {
            const ve = Se[et], je = Se[J], vt = ve.x * je.y - je.x * ve.y;
            se += (ve.x + je.x) * vt, Ee += (ve.y + je.y) * vt, Q += 3 * vt;
          }
          return new xd(se / Q, Ee / Q, 0, K);
        }(d), Y = z.length;
        for (; z.length; ) {
          const K = z.pop();
          (K.d > j.d || !j.d) && (j = K, h && console.log("found best %d after %d probes", Math.round(1e4 * K.d) / 1e4, Y)), K.max - j.d <= o || (D = K.h / 2, z.push(new xd(K.p.x - D, K.p.y - D, D, d)), z.push(new xd(K.p.x + D, K.p.y - D, D, d)), z.push(new xd(K.p.x - D, K.p.y + D, D, d)), z.push(new xd(K.p.x + D, K.p.y + D, D, d)), Y += 4);
        }
        return h && (console.log(`num probes: ${Y}`), console.log(`best distance: ${j.d}`)), j.p;
      }
      function SP(d, o) {
        return o.max - d.max;
      }
      function xd(d, o, h, f) {
        this.p = new F(d, o), this.h = h, this.d = function(_, v) {
          let w = !1, P = 1 / 0;
          for (let R = 0; R < v.length; R++) {
            const D = v[R];
            for (let z = 0, j = D.length, Y = j - 1; z < j; Y = z++) {
              const K = D[z], Q = D[Y];
              K.y > _.y != Q.y > _.y && _.x < (Q.x - K.x) * (_.y - K.y) / (Q.y - K.y) + K.x && (w = !w), P = Math.min(P, hv(_, K, Q));
            }
          }
          return (w ? 1 : -1) * Math.sqrt(P);
        }(this.p, f), this.max = this.d + this.h * Math.SQRT2;
      }
      var ro;
      c.aw = void 0, (ro = c.aw || (c.aw = {}))[ro.center = 1] = "center", ro[ro.left = 2] = "left", ro[ro.right = 3] = "right", ro[ro.top = 4] = "top", ro[ro.bottom = 5] = "bottom", ro[ro["top-left"] = 6] = "top-left", ro[ro["top-right"] = 7] = "top-right", ro[ro["bottom-left"] = 8] = "bottom-left", ro[ro["bottom-right"] = 9] = "bottom-right";
      const Ju = 7, J_ = Number.POSITIVE_INFINITY;
      function R2(d, o) {
        return o[1] !== J_ ? function(h, f, _) {
          let v = 0, w = 0;
          switch (f = Math.abs(f), _ = Math.abs(_), h) {
            case "top-right":
            case "top-left":
            case "top":
              w = _ - Ju;
              break;
            case "bottom-right":
            case "bottom-left":
            case "bottom":
              w = -_ + Ju;
          }
          switch (h) {
            case "top-right":
            case "bottom-right":
            case "right":
              v = -f;
              break;
            case "top-left":
            case "bottom-left":
            case "left":
              v = f;
          }
          return [v, w];
        }(d, o[0], o[1]) : function(h, f) {
          let _ = 0, v = 0;
          f < 0 && (f = 0);
          const w = f / Math.SQRT2;
          switch (h) {
            case "top-right":
            case "top-left":
              v = w - Ju;
              break;
            case "bottom-right":
            case "bottom-left":
              v = -w + Ju;
              break;
            case "bottom":
              v = -f + Ju;
              break;
            case "top":
              v = f - Ju;
          }
          switch (h) {
            case "top-right":
            case "bottom-right":
              _ = -w;
              break;
            case "top-left":
            case "bottom-left":
              _ = w;
              break;
            case "left":
              _ = f;
              break;
            case "right":
              _ = -f;
          }
          return [_, v];
        }(d, o[0]);
      }
      function B2(d, o, h) {
        var f;
        const _ = d.layout, v = (f = _.get("text-variable-anchor-offset")) === null || f === void 0 ? void 0 : f.evaluate(o, {}, h);
        if (v) {
          const P = v.values, R = [];
          for (let D = 0; D < P.length; D += 2) {
            const z = R[D] = P[D], j = P[D + 1].map((Y) => Y * gs);
            z.startsWith("top") ? j[1] -= Ju : z.startsWith("bottom") && (j[1] += Ju), R[D + 1] = j;
          }
          return new gn(R);
        }
        const w = _.get("text-variable-anchor");
        if (w) {
          let P;
          P = d._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [_.get("text-radial-offset").evaluate(o, {}, h) * gs, J_] : _.get("text-offset").evaluate(o, {}, h).map((D) => D * gs);
          const R = [];
          for (const D of w) R.push(D, R2(D, P));
          return new gn(R);
        }
        return null;
      }
      function K_(d) {
        switch (d) {
          case "right":
          case "top-right":
          case "bottom-right":
            return "right";
          case "left":
          case "top-left":
          case "bottom-left":
            return "left";
        }
        return "center";
      }
      function CP(d, o, h, f, _, v, w, P, R, D, z, j) {
        let Y = v.textMaxSize.evaluate(o, {});
        Y === void 0 && (Y = w);
        const K = d.layers[0].layout, Q = K.get("icon-offset").evaluate(o, {}, z), se = D2(h.horizontal), Ee = w / 24, Se = d.tilePixelRatio * Ee, et = d.tilePixelRatio * Y / 24, Ne = d.tilePixelRatio * P, J = d.tilePixelRatio * K.get("symbol-spacing"), ve = K.get("text-padding") * d.tilePixelRatio, je = function(zn, Dn, Pn) {
          let vi = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
          const Rr = zn.get("icon-padding").evaluate(Dn, {}, Pn), Kr = Rr && Rr.values;
          return [Kr[0] * vi, Kr[1] * vi, Kr[2] * vi, Kr[3] * vi];
        }(K, o, z, d.tilePixelRatio), vt = K.get("text-max-angle") / 180 * Math.PI, Vt = K.get("text-rotation-alignment") !== "viewport" && K.get("symbol-placement") !== "point", Et = K.get("icon-rotation-alignment") === "map" && K.get("symbol-placement") !== "point", Lt = K.get("symbol-placement"), Qt = J / 2, Ht = K.get("icon-text-fit");
        let rn;
        f && Ht !== "none" && (d.allowVerticalPlacement && h.vertical && (rn = i2(f, h.vertical, Ht, K.get("icon-text-fit-padding"), Q, Ee)), se && (f = i2(f, se, Ht, K.get("icon-text-fit-padding"), Q, Ee)));
        const Dt = z ? j.line.getGranularityForZoomLevel(z.z) : 1, Cn = (zn, Dn) => {
          Dn.x < 0 || Dn.x >= dt || Dn.y < 0 || Dn.y >= dt || function(Pn, vi, Rr, Kr, Fo, oa, aa, zs, Ur, ms, Us, Qr, No, Wa, Ps, la, _s, Is, Ms, es, hr, ic, wd, rc, MP) {
            const Ad = Pn.addToLineVertexArray(vi, Rr);
            let Ih, Td, Ed, Sd, z2 = 0, U2 = 0, j2 = 0, G2 = 0, o0 = -1, a0 = -1;
            const vu = {};
            let V2 = Mr("");
            if (Pn.allowVerticalPlacement && Kr.vertical) {
              const vo = zs.layout.get("text-rotate").evaluate(hr, {}, rc) + 90;
              Ed = new bg(Ur, vi, ms, Us, Qr, Kr.vertical, No, Wa, Ps, vo), aa && (Sd = new bg(Ur, vi, ms, Us, Qr, aa, _s, Is, Ps, vo));
            }
            if (Fo) {
              const vo = zs.layout.get("icon-rotate").evaluate(hr, {}), Za = zs.layout.get("icon-text-fit") !== "none", Mh = M2(Fo, vo, wd, Za), oc = aa ? M2(aa, vo, wd, Za) : void 0;
              Td = new bg(Ur, vi, ms, Us, Qr, Fo, _s, Is, !1, vo), z2 = 4 * Mh.length;
              const Lh = Pn.iconSizeData;
              let Gc = null;
              Lh.kind === "source" ? (Gc = [jc * zs.layout.get("icon-size").evaluate(hr, {})], Gc[0] > $u && Wt(`${Pn.layerIds[0]}: Value for "icon-size" is >= ${Uf}. Reduce your "icon-size".`)) : Lh.kind === "composite" && (Gc = [jc * ic.compositeIconSizes[0].evaluate(hr, {}, rc), jc * ic.compositeIconSizes[1].evaluate(hr, {}, rc)], (Gc[0] > $u || Gc[1] > $u) && Wt(`${Pn.layerIds[0]}: Value for "icon-size" is >= ${Uf}. Reduce your "icon-size".`)), Pn.addSymbols(Pn.icon, Mh, Gc, es, Ms, hr, c.af.none, vi, Ad.lineStartIndex, Ad.lineLength, -1, rc), o0 = Pn.icon.placedSymbolArray.length - 1, oc && (U2 = 4 * oc.length, Pn.addSymbols(Pn.icon, oc, Gc, es, Ms, hr, c.af.vertical, vi, Ad.lineStartIndex, Ad.lineLength, -1, rc), a0 = Pn.icon.placedSymbolArray.length - 1);
            }
            const q2 = Object.keys(Kr.horizontal);
            for (const vo of q2) {
              const Za = Kr.horizontal[vo];
              if (!Ih) {
                V2 = Mr(Za.text);
                const oc = zs.layout.get("text-rotate").evaluate(hr, {}, rc);
                Ih = new bg(Ur, vi, ms, Us, Qr, Za, No, Wa, Ps, oc);
              }
              const Mh = Za.positionedLines.length === 1;
              if (j2 += O2(Pn, vi, Za, oa, zs, Ps, hr, la, Ad, Kr.vertical ? c.af.horizontal : c.af.horizontalOnly, Mh ? q2 : [vo], vu, o0, ic, rc), Mh) break;
            }
            Kr.vertical && (G2 += O2(Pn, vi, Kr.vertical, oa, zs, Ps, hr, la, Ad, c.af.vertical, ["vertical"], vu, a0, ic, rc));
            const LP = Ih ? Ih.boxStartIndex : Pn.collisionBoxArray.length, RP = Ih ? Ih.boxEndIndex : Pn.collisionBoxArray.length, BP = Ed ? Ed.boxStartIndex : Pn.collisionBoxArray.length, OP = Ed ? Ed.boxEndIndex : Pn.collisionBoxArray.length, DP = Td ? Td.boxStartIndex : Pn.collisionBoxArray.length, FP = Td ? Td.boxEndIndex : Pn.collisionBoxArray.length, NP = Sd ? Sd.boxStartIndex : Pn.collisionBoxArray.length, kP = Sd ? Sd.boxEndIndex : Pn.collisionBoxArray.length;
            let sc = -1;
            const xg = (vo, Za) => vo && vo.circleDiameter ? Math.max(vo.circleDiameter, Za) : Za;
            sc = xg(Ih, sc), sc = xg(Ed, sc), sc = xg(Td, sc), sc = xg(Sd, sc);
            const H2 = sc > -1 ? 1 : 0;
            H2 && (sc *= MP / gs), Pn.glyphOffsetArray.length >= bd.MAX_GLYPHS && Wt("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), hr.sortKey !== void 0 && Pn.addToSortKeyRanges(Pn.symbolInstances.length, hr.sortKey);
            const zP = B2(zs, hr, rc), [UP, jP] = function(vo, Za) {
              const Mh = vo.length, oc = Za == null ? void 0 : Za.values;
              if ((oc == null ? void 0 : oc.length) > 0) for (let Lh = 0; Lh < oc.length; Lh += 2) {
                const Gc = oc[Lh + 1];
                vo.emplaceBack(c.aw[oc[Lh]], Gc[0], Gc[1]);
              }
              return [Mh, vo.length];
            }(Pn.textAnchorOffsets, zP);
            Pn.symbolInstances.emplaceBack(vi.x, vi.y, vu.right >= 0 ? vu.right : -1, vu.center >= 0 ? vu.center : -1, vu.left >= 0 ? vu.left : -1, vu.vertical || -1, o0, a0, V2, LP, RP, BP, OP, DP, FP, NP, kP, ms, j2, G2, z2, U2, H2, 0, No, sc, UP, jP);
          }(d, Dn, zn, h, f, _, rn, d.layers[0], d.collisionBoxArray, o.index, o.sourceLayerIndex, d.index, Se, [ve, ve, ve, ve], Vt, R, Ne, je, Et, Q, o, v, D, z, w);
        };
        if (Lt === "line") for (const zn of T2(o.geometry, 0, 0, dt, dt)) {
          const Dn = Ph(zn, Dt), Pn = AP(Dn, J, vt, h.vertical || se, f, 24, et, d.overscaling, dt);
          for (const vi of Pn) se && PP(d, se.text, Qt, vi) || Cn(Dn, vi);
        }
        else if (Lt === "line-center") {
          for (const zn of o.geometry) if (zn.length > 1) {
            const Dn = Ph(zn, Dt), Pn = wP(Dn, vt, h.vertical || se, f, 24, et);
            Pn && Cn(Dn, Pn);
          }
        } else if (o.type === "Polygon") for (const zn of Bs(o.geometry, 0)) {
          const Dn = EP(zn, 16);
          Cn(Ph(zn[0], Dt, !0), new Yu(Dn.x, Dn.y, 0));
        }
        else if (o.type === "LineString") for (const zn of o.geometry) {
          const Dn = Ph(zn, Dt);
          Cn(Dn, new Yu(Dn[0].x, Dn[0].y, 0));
        }
        else if (o.type === "Point") for (const zn of o.geometry) for (const Dn of zn) Cn([Dn], new Yu(Dn.x, Dn.y, 0));
      }
      function O2(d, o, h, f, _, v, w, P, R, D, z, j, Y, K, Q) {
        const se = function(et, Ne, J, ve, je, vt, Vt, Et) {
          const Lt = ve.layout.get("text-rotate").evaluate(vt, {}) * Math.PI / 180, Qt = [];
          for (const Ht of Ne.positionedLines) for (const rn of Ht.positionedGlyphs) {
            if (!rn.rect) continue;
            const Dt = rn.rect || {};
            let Cn = nP + 1, zn = !0, Dn = 1, Pn = 0;
            const vi = (je || Et) && rn.vertical, Rr = rn.metrics.advance * rn.scale / 2;
            if (Et && Ne.verticalizable && (Pn = Ht.lineOffset / 2 - (rn.imageName ? -(gs - rn.metrics.width * rn.scale) / 2 : (rn.scale - 1) * gs)), rn.imageName) {
              const Is = Vt[rn.imageName];
              zn = Is.sdf, Dn = Is.pixelRatio, Cn = sa / Dn;
            }
            const Kr = je ? [rn.x + Rr, rn.y] : [0, 0];
            let Fo = je ? [0, 0] : [rn.x + Rr + J[0], rn.y + J[1] - Pn], oa = [0, 0];
            vi && (oa = Fo, Fo = [0, 0]);
            const aa = rn.metrics.isDoubleResolution ? 2 : 1, zs = (rn.metrics.left - Cn) * rn.scale - Rr + Fo[0], Ur = (-rn.metrics.top - Cn) * rn.scale + Fo[1], ms = zs + Dt.w / aa * rn.scale / Dn, Us = Ur + Dt.h / aa * rn.scale / Dn, Qr = new F(zs, Ur), No = new F(ms, Ur), Wa = new F(zs, Us), Ps = new F(ms, Us);
            if (vi) {
              const Is = new F(-Rr, Rr - hg), Ms = -Math.PI / 2, es = gs / 2 - Rr, hr = new F(5 - hg - es, -(rn.imageName ? es : 0)), ic = new F(...oa);
              Qr._rotateAround(Ms, Is)._add(hr)._add(ic), No._rotateAround(Ms, Is)._add(hr)._add(ic), Wa._rotateAround(Ms, Is)._add(hr)._add(ic), Ps._rotateAround(Ms, Is)._add(hr)._add(ic);
            }
            if (Lt) {
              const Is = Math.sin(Lt), Ms = Math.cos(Lt), es = [Ms, -Is, Is, Ms];
              Qr._matMult(es), No._matMult(es), Wa._matMult(es), Ps._matMult(es);
            }
            const la = new F(0, 0), _s = new F(0, 0);
            Qt.push({ tl: Qr, tr: No, bl: Wa, br: Ps, tex: Dt, writingMode: Ne.writingMode, glyphOffset: Kr, sectionIndex: rn.sectionIndex, isSDF: zn, pixelOffsetTL: la, pixelOffsetBR: _s, minFontScaleX: 0, minFontScaleY: 0 });
          }
          return Qt;
        }(0, h, P, _, v, w, f, d.allowVerticalPlacement), Ee = d.textSizeData;
        let Se = null;
        Ee.kind === "source" ? (Se = [jc * _.layout.get("text-size").evaluate(w, {})], Se[0] > $u && Wt(`${d.layerIds[0]}: Value for "text-size" is >= ${Uf}. Reduce your "text-size".`)) : Ee.kind === "composite" && (Se = [jc * K.compositeTextSizes[0].evaluate(w, {}, Q), jc * K.compositeTextSizes[1].evaluate(w, {}, Q)], (Se[0] > $u || Se[1] > $u) && Wt(`${d.layerIds[0]}: Value for "text-size" is >= ${Uf}. Reduce your "text-size".`)), d.addSymbols(d.text, se, Se, P, v, w, D, o, R.lineStartIndex, R.lineLength, Y, Q);
        for (const et of z) j[et] = d.text.placedSymbolArray.length - 1;
        return 4 * se.length;
      }
      function D2(d) {
        for (const o in d) return d[o];
        return null;
      }
      function PP(d, o, h, f) {
        const _ = d.compareText;
        if (o in _) {
          const v = _[o];
          for (let w = v.length - 1; w >= 0; w--) if (f.dist(v[w]) < h) return !0;
        } else _[o] = [];
        return _[o].push(f), !1;
      }
      const F2 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
      class Q_ {
        static from(o) {
          if (!(o instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
          const [h, f] = new Uint8Array(o, 0, 2);
          if (h !== 219) throw new Error("Data does not appear to be in a KDBush format.");
          const _ = f >> 4;
          if (_ !== 1) throw new Error(`Got v${_} data when expected v1.`);
          const v = F2[15 & f];
          if (!v) throw new Error("Unrecognized array type.");
          const [w] = new Uint16Array(o, 2, 1), [P] = new Uint32Array(o, 4, 1);
          return new Q_(P, w, v, o);
        }
        constructor(o) {
          let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, _ = arguments.length > 3 ? arguments[3] : void 0;
          if (isNaN(o) || o < 0) throw new Error(`Unpexpected numItems value: ${o}.`);
          this.numItems = +o, this.nodeSize = Math.min(Math.max(+h, 2), 65535), this.ArrayType = f, this.IndexArrayType = o < 65536 ? Uint16Array : Uint32Array;
          const v = F2.indexOf(this.ArrayType), w = 2 * o * this.ArrayType.BYTES_PER_ELEMENT, P = o * this.IndexArrayType.BYTES_PER_ELEMENT, R = (8 - P % 8) % 8;
          if (v < 0) throw new Error(`Unexpected typed array class: ${f}.`);
          _ && _ instanceof ArrayBuffer ? (this.data = _, this.ids = new this.IndexArrayType(this.data, 8, o), this.coords = new this.ArrayType(this.data, 8 + P + R, 2 * o), this._pos = 2 * o, this._finished = !0) : (this.data = new ArrayBuffer(8 + w + P + R), this.ids = new this.IndexArrayType(this.data, 8, o), this.coords = new this.ArrayType(this.data, 8 + P + R, 2 * o), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, 16 + v]), new Uint16Array(this.data, 2, 1)[0] = h, new Uint32Array(this.data, 4, 1)[0] = o);
        }
        add(o, h) {
          const f = this._pos >> 1;
          return this.ids[f] = f, this.coords[this._pos++] = o, this.coords[this._pos++] = h, f;
        }
        finish() {
          const o = this._pos >> 1;
          if (o !== this.numItems) throw new Error(`Added ${o} items when expected ${this.numItems}.`);
          return e0(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
        }
        range(o, h, f, _) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: v, coords: w, nodeSize: P } = this, R = [0, v.length - 1, 0], D = [];
          for (; R.length; ) {
            const z = R.pop() || 0, j = R.pop() || 0, Y = R.pop() || 0;
            if (j - Y <= P) {
              for (let Ee = Y; Ee <= j; Ee++) {
                const Se = w[2 * Ee], et = w[2 * Ee + 1];
                Se >= o && Se <= f && et >= h && et <= _ && D.push(v[Ee]);
              }
              continue;
            }
            const K = Y + j >> 1, Q = w[2 * K], se = w[2 * K + 1];
            Q >= o && Q <= f && se >= h && se <= _ && D.push(v[K]), (z === 0 ? o <= Q : h <= se) && (R.push(Y), R.push(K - 1), R.push(1 - z)), (z === 0 ? f >= Q : _ >= se) && (R.push(K + 1), R.push(j), R.push(1 - z));
          }
          return D;
        }
        within(o, h, f) {
          if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
          const { ids: _, coords: v, nodeSize: w } = this, P = [0, _.length - 1, 0], R = [], D = f * f;
          for (; P.length; ) {
            const z = P.pop() || 0, j = P.pop() || 0, Y = P.pop() || 0;
            if (j - Y <= w) {
              for (let Ee = Y; Ee <= j; Ee++) k2(v[2 * Ee], v[2 * Ee + 1], o, h) <= D && R.push(_[Ee]);
              continue;
            }
            const K = Y + j >> 1, Q = v[2 * K], se = v[2 * K + 1];
            k2(Q, se, o, h) <= D && R.push(_[K]), (z === 0 ? o - f <= Q : h - f <= se) && (P.push(Y), P.push(K - 1), P.push(1 - z)), (z === 0 ? o + f >= Q : h + f >= se) && (P.push(K + 1), P.push(j), P.push(1 - z));
          }
          return R;
        }
      }
      function e0(d, o, h, f, _, v) {
        if (_ - f <= h) return;
        const w = f + _ >> 1;
        N2(d, o, w, f, _, v), e0(d, o, h, f, w - 1, 1 - v), e0(d, o, h, w + 1, _, 1 - v);
      }
      function N2(d, o, h, f, _, v) {
        for (; _ > f; ) {
          if (_ - f > 600) {
            const D = _ - f + 1, z = h - f + 1, j = Math.log(D), Y = 0.5 * Math.exp(2 * j / 3), K = 0.5 * Math.sqrt(j * Y * (D - Y) / D) * (z - D / 2 < 0 ? -1 : 1);
            N2(d, o, h, Math.max(f, Math.floor(h - z * Y / D + K)), Math.min(_, Math.floor(h + (D - z) * Y / D + K)), v);
          }
          const w = o[2 * h + v];
          let P = f, R = _;
          for (Vf(d, o, f, h), o[2 * _ + v] > w && Vf(d, o, f, _); P < R; ) {
            for (Vf(d, o, P, R), P++, R--; o[2 * P + v] < w; ) P++;
            for (; o[2 * R + v] > w; ) R--;
          }
          o[2 * f + v] === w ? Vf(d, o, f, R) : (R++, Vf(d, o, R, _)), R <= h && (f = R + 1), h <= R && (_ = R - 1);
        }
      }
      function Vf(d, o, h, f) {
        t0(d, h, f), t0(o, 2 * h, 2 * f), t0(o, 2 * h + 1, 2 * f + 1);
      }
      function t0(d, o, h) {
        const f = d[o];
        d[o] = d[h], d[h] = f;
      }
      function k2(d, o, h, f) {
        const _ = d - h, v = o - f;
        return _ * _ + v * v;
      }
      var n0;
      c.cf = void 0, (n0 = c.cf || (c.cf = {})).create = "create", n0.load = "load", n0.fullLoad = "fullLoad";
      let vg = null, qf = [];
      const i0 = 1e3 / 60, r0 = "loadTime", s0 = "fullLoadTime", IP = { mark(d) {
        performance.mark(d);
      }, frame(d) {
        const o = d;
        vg != null && qf.push(o - vg), vg = o;
      }, clearMetrics() {
        vg = null, qf = [], performance.clearMeasures(r0), performance.clearMeasures(s0);
        for (const d in c.cf) performance.clearMarks(c.cf[d]);
      }, getPerformanceMetrics() {
        performance.measure(r0, c.cf.create, c.cf.load), performance.measure(s0, c.cf.create, c.cf.fullLoad);
        const d = performance.getEntriesByName(r0)[0].duration, o = performance.getEntriesByName(s0)[0].duration, h = qf.length, f = 1 / (qf.reduce((v, w) => v + w, 0) / h / 1e3), _ = qf.filter((v) => v > i0).reduce((v, w) => v + (w - i0) / i0, 0);
        return { loadTime: d, fullLoadTime: o, fps: f, percentDroppedFrames: _ / (h + _) * 100, totalFrames: h };
      } };
      c.$ = Y_, c.A = Te, c.B = ut, c.C = _l, c.D = ft, c.E = Dr, c.F = function(d) {
        if (wn == null) {
          const o = d.navigator ? d.navigator.userAgent : null;
          wn = !!d.safari || !(!o || !(/\b(iPad|iPhone|iPod)\b/.test(o) || o.match("Safari") && !o.match("Chrome")));
        }
        return wn;
      }, c.G = class {
        constructor(d, o) {
          this.target = d, this.mapId = o, this.resolveRejects = {}, this.tasks = {}, this.taskQueue = [], this.abortControllers = {}, this.messageHandlers = {}, this.invoker = new vP(() => this.process()), this.subscription = function(h, f, _, v) {
            return h.addEventListener(f, _, !1), { unsubscribe: () => {
              h.removeEventListener(f, _, !1);
            } };
          }(this.target, "message", (h) => this.receive(h)), this.globalScope = hn(self) ? d : window;
        }
        registerMessageHandler(d, o) {
          this.messageHandlers[d] = o;
        }
        sendAsync(d, o) {
          return new Promise((h, f) => {
            const _ = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            this.resolveRejects[_] = { resolve: h, reject: f }, o && o.signal.addEventListener("abort", () => {
              delete this.resolveRejects[_];
              const P = { id: _, type: "<cancel>", origin: location.origin, targetMapId: d.targetMapId, sourceMapId: this.mapId };
              this.target.postMessage(P);
            }, { once: !0 });
            const v = [], w = Object.assign(Object.assign({}, d), { id: _, sourceMapId: this.mapId, origin: location.origin, data: mu(d.data, v) });
            this.target.postMessage(w, { transfer: v });
          });
        }
        receive(d) {
          const o = d.data, h = o.id;
          if (!(o.origin !== "file://" && location.origin !== "file://" && o.origin !== "resource://android" && location.origin !== "resource://android" && o.origin !== location.origin || o.targetMapId && this.mapId !== o.targetMapId)) {
            if (o.type === "<cancel>") {
              delete this.tasks[h];
              const f = this.abortControllers[h];
              return delete this.abortControllers[h], void (f && f.abort());
            }
            if (hn(self) || o.mustQueue) return this.tasks[h] = o, this.taskQueue.push(h), void this.invoker.trigger();
            this.processTask(h, o);
          }
        }
        process() {
          if (this.taskQueue.length === 0) return;
          const d = this.taskQueue.shift(), o = this.tasks[d];
          delete this.tasks[d], this.taskQueue.length > 0 && this.invoker.trigger(), o && this.processTask(d, o);
        }
        processTask(d, o) {
          return a(this, void 0, void 0, function* () {
            if (o.type === "<response>") {
              const _ = this.resolveRejects[d];
              return delete this.resolveRejects[d], _ ? void (o.error ? _.reject(Va(o.error)) : _.resolve(Va(o.data))) : void 0;
            }
            if (!this.messageHandlers[o.type]) return void this.completeTask(d, new Error(`Could not find a registered handler for ${o.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
            const h = Va(o.data), f = new AbortController();
            this.abortControllers[d] = f;
            try {
              const _ = yield this.messageHandlers[o.type](o.sourceMapId, h, f);
              this.completeTask(d, null, _);
            } catch (_) {
              this.completeTask(d, _);
            }
          });
        }
        completeTask(d, o, h) {
          const f = [];
          delete this.abortControllers[d];
          const _ = { id: d, type: "<response>", sourceMapId: this.mapId, origin: location.origin, error: o ? mu(o) : null, data: mu(h, f) };
          this.target.postMessage(_, { transfer: f });
        }
        remove() {
          this.invoker.remove(), this.subscription.unsubscribe();
        }
      }, c.H = $n, c.I = U_, c.J = function() {
        var d = new Te(16);
        return Te != Float32Array && (d[1] = 0, d[2] = 0, d[3] = 0, d[4] = 0, d[6] = 0, d[7] = 0, d[8] = 0, d[9] = 0, d[11] = 0, d[12] = 0, d[13] = 0, d[14] = 0), d[0] = 1, d[5] = 1, d[10] = 1, d[15] = 1, d;
      }, c.K = function(d, o, h) {
        var f, _, v, w, P, R, D, z, j, Y, K, Q, se = h[0], Ee = h[1], Se = h[2];
        return o === d ? (d[12] = o[0] * se + o[4] * Ee + o[8] * Se + o[12], d[13] = o[1] * se + o[5] * Ee + o[9] * Se + o[13], d[14] = o[2] * se + o[6] * Ee + o[10] * Se + o[14], d[15] = o[3] * se + o[7] * Ee + o[11] * Se + o[15]) : (_ = o[1], v = o[2], w = o[3], P = o[4], R = o[5], D = o[6], z = o[7], j = o[8], Y = o[9], K = o[10], Q = o[11], d[0] = f = o[0], d[1] = _, d[2] = v, d[3] = w, d[4] = P, d[5] = R, d[6] = D, d[7] = z, d[8] = j, d[9] = Y, d[10] = K, d[11] = Q, d[12] = f * se + P * Ee + j * Se + o[12], d[13] = _ * se + R * Ee + Y * Se + o[13], d[14] = v * se + D * Ee + K * Se + o[14], d[15] = w * se + z * Ee + Q * Se + o[15]), d;
      }, c.L = function(d, o, h) {
        var f = h[0], _ = h[1], v = h[2];
        return d[0] = o[0] * f, d[1] = o[1] * f, d[2] = o[2] * f, d[3] = o[3] * f, d[4] = o[4] * _, d[5] = o[5] * _, d[6] = o[6] * _, d[7] = o[7] * _, d[8] = o[8] * v, d[9] = o[9] * v, d[10] = o[10] * v, d[11] = o[11] * v, d[12] = o[12], d[13] = o[13], d[14] = o[14], d[15] = o[15], d;
      }, c.M = function(d, o, h) {
        var f = o[0], _ = o[1], v = o[2], w = o[3], P = o[4], R = o[5], D = o[6], z = o[7], j = o[8], Y = o[9], K = o[10], Q = o[11], se = o[12], Ee = o[13], Se = o[14], et = o[15], Ne = h[0], J = h[1], ve = h[2], je = h[3];
        return d[0] = Ne * f + J * P + ve * j + je * se, d[1] = Ne * _ + J * R + ve * Y + je * Ee, d[2] = Ne * v + J * D + ve * K + je * Se, d[3] = Ne * w + J * z + ve * Q + je * et, d[4] = (Ne = h[4]) * f + (J = h[5]) * P + (ve = h[6]) * j + (je = h[7]) * se, d[5] = Ne * _ + J * R + ve * Y + je * Ee, d[6] = Ne * v + J * D + ve * K + je * Se, d[7] = Ne * w + J * z + ve * Q + je * et, d[8] = (Ne = h[8]) * f + (J = h[9]) * P + (ve = h[10]) * j + (je = h[11]) * se, d[9] = Ne * _ + J * R + ve * Y + je * Ee, d[10] = Ne * v + J * D + ve * K + je * Se, d[11] = Ne * w + J * z + ve * Q + je * et, d[12] = (Ne = h[12]) * f + (J = h[13]) * P + (ve = h[14]) * j + (je = h[15]) * se, d[13] = Ne * _ + J * R + ve * Y + je * Ee, d[14] = Ne * v + J * D + ve * K + je * Se, d[15] = Ne * w + J * z + ve * Q + je * et, d;
      }, c.N = function(d, o) {
        const h = {};
        for (let f = 0; f < o.length; f++) {
          const _ = o[f];
          _ in d && (h[_] = d[_]);
        }
        return h;
      }, c.O = Xu, c.P = F, c.Q = f2, c.R = qa, c.S = d2, c.T = qt, c.U = de, c.V = ie, c.W = On, c.X = Ha, c.Y = dt, c.Z = jf, c._ = a, c.a = Mn, c.a$ = function() {
        const d = new Float64Array(16);
        return Ge(d), d;
      }, c.a0 = (d) => {
        const o = window.document.createElement("video");
        return o.muted = !0, new Promise((h) => {
          o.onloadstart = () => {
            h(o);
          };
          for (const f of d) {
            const _ = window.document.createElement("source");
            Un(f) || (o.crossOrigin = "Anonymous"), _.src = f, o.appendChild(_);
          }
        });
      }, c.a1 = Ze, c.a2 = function() {
        return ot++;
      }, c.a3 = x, c.a4 = bd, c.a5 = Jl, c.a6 = bu, c.a7 = v2, c.a8 = function(d) {
        const o = {};
        if (d.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (h, f, _, v) => {
          const w = _ || v;
          return o[f] = !w || w.toLowerCase(), "";
        }), o["max-age"]) {
          const h = parseInt(o["max-age"], 10);
          isNaN(h) ? delete o["max-age"] : o["max-age"] = h;
        }
        return o;
      }, c.a9 = function(d) {
        return Math.log(d) / Math.LN2;
      }, c.aA = Q_, c.aB = Bn, c.aC = lg, c.aD = Ce, c.aE = dn, c.aF = Ct, c.aG = function(d) {
        return Math.pow(2, d);
      }, c.aH = 85.051129, c.aI = p2, c.aJ = ze, c.aK = ln, c.aL = g2, c.aM = function(d, o, h) {
        return d[0] = o[0] * h, d[1] = o[1] * h, d[2] = o[2] * h, d;
      }, c.aN = function(d, o, h) {
        return d[0] = o[0] + h[0], d[1] = o[1] + h[1], d[2] = o[2] + h[2], d;
      }, c.aO = function(d) {
        var o = new Te(3);
        return o[0] = d[0], o[1] = d[1], o[2] = d[2], o;
      }, c.aP = function(d, o, h) {
        return d[0] = o[0] * h[0], d[1] = o[1] * h[1], d[2] = o[2] * h[2], d[3] = o[3] * h[3], d;
      }, c.aQ = function(d, o, h) {
        return d[0] = o[0] - h[0], d[1] = o[1] - h[1], d[2] = o[2] - h[2], d;
      }, c.aR = function(d, o) {
        var h = o[0], f = o[1], _ = o[2], v = h * h + f * f + _ * _;
        return v > 0 && (v = 1 / Math.sqrt(v)), d[0] = o[0] * v, d[1] = o[1] * v, d[2] = o[2] * v, d;
      }, c.aS = function(d, o, h) {
        var f = o[0], _ = o[1], v = o[2], w = h[0], P = h[1], R = h[2];
        return d[0] = _ * R - v * P, d[1] = v * w - f * R, d[2] = f * P - _ * w, d;
      }, c.aT = function(d, o) {
        return d[0] * o[0] + d[1] * o[1] + d[2] * o[2];
      }, c.aU = _2, c.aV = vd, c.aW = function(d, o, h, f, _) {
        var v, w = 1 / Math.tan(o / 2);
        return d[0] = w / h, d[1] = 0, d[2] = 0, d[3] = 0, d[4] = 0, d[5] = w, d[6] = 0, d[7] = 0, d[8] = 0, d[9] = 0, d[11] = -1, d[12] = 0, d[13] = 0, d[15] = 0, _ != null && _ !== 1 / 0 ? (d[10] = (_ + f) * (v = 1 / (f - _)), d[14] = 2 * _ * f * v) : (d[10] = -1, d[14] = -2 * f), d;
      }, c.aX = function(d) {
        var o = new Te(16);
        return o[0] = d[0], o[1] = d[1], o[2] = d[2], o[3] = d[3], o[4] = d[4], o[5] = d[5], o[6] = d[6], o[7] = d[7], o[8] = d[8], o[9] = d[9], o[10] = d[10], o[11] = d[11], o[12] = d[12], o[13] = d[13], o[14] = d[14], o[15] = d[15], o;
      }, c.aY = function(d, o, h) {
        var f = Math.sin(h), _ = Math.cos(h), v = o[0], w = o[1], P = o[2], R = o[3], D = o[4], z = o[5], j = o[6], Y = o[7];
        return o !== d && (d[8] = o[8], d[9] = o[9], d[10] = o[10], d[11] = o[11], d[12] = o[12], d[13] = o[13], d[14] = o[14], d[15] = o[15]), d[0] = v * _ + D * f, d[1] = w * _ + z * f, d[2] = P * _ + j * f, d[3] = R * _ + Y * f, d[4] = D * _ - v * f, d[5] = z * _ - w * f, d[6] = j * _ - P * f, d[7] = Y * _ - R * f, d;
      }, c.aZ = function(d, o, h) {
        var f = Math.sin(h), _ = Math.cos(h), v = o[4], w = o[5], P = o[6], R = o[7], D = o[8], z = o[9], j = o[10], Y = o[11];
        return o !== d && (d[0] = o[0], d[1] = o[1], d[2] = o[2], d[3] = o[3], d[12] = o[12], d[13] = o[13], d[14] = o[14], d[15] = o[15]), d[4] = v * _ + D * f, d[5] = w * _ + z * f, d[6] = P * _ + j * f, d[7] = R * _ + Y * f, d[8] = D * _ - v * f, d[9] = z * _ - w * f, d[10] = j * _ - P * f, d[11] = Y * _ - R * f, d;
      }, c.a_ = function() {
        const d = new Float32Array(16);
        return Ge(d), d;
      }, c.aa = function(d) {
        var o = d[0], h = d[1];
        return o * o + h * h;
      }, c.ab = function(d) {
        return d * Math.PI / 180;
      }, c.ac = Re, c.ad = function(d, o) {
        const h = [];
        for (const f in d) f in o || h.push(f);
        return h;
      }, c.ae = function(d, o) {
        let h = 0, f = 0;
        if (d.kind === "constant") f = d.layoutSize;
        else if (d.kind !== "source") {
          const { interpolationType: _, minZoom: v, maxZoom: w } = d, P = _ ? Re(yi.interpolationFactor(_, o, v, w), 0, 1) : 0;
          d.kind === "camera" ? f = fo.number(d.minSize, d.maxSize, P) : h = P;
        }
        return { uSizeT: h, uSize: f };
      }, c.ag = function(d, o, h) {
        let { uSize: f, uSizeT: _ } = o, { lowerSize: v, upperSize: w } = h;
        return d.kind === "source" ? v / jc : d.kind === "composite" ? fo.number(v / jc, w / jc, _) : f;
      }, c.ah = function(d, o) {
        var h = o[0], f = o[1], _ = o[2], v = o[3], w = o[4], P = o[5], R = o[6], D = o[7], z = o[8], j = o[9], Y = o[10], K = o[11], Q = o[12], se = o[13], Ee = o[14], Se = o[15], et = h * P - f * w, Ne = h * R - _ * w, J = h * D - v * w, ve = f * R - _ * P, je = f * D - v * P, vt = _ * D - v * R, Vt = z * se - j * Q, Et = z * Ee - Y * Q, Lt = z * Se - K * Q, Qt = j * Ee - Y * se, Ht = j * Se - K * se, rn = Y * Se - K * Ee, Dt = et * rn - Ne * Ht + J * Qt + ve * Lt - je * Et + vt * Vt;
        return Dt ? (d[0] = (P * rn - R * Ht + D * Qt) * (Dt = 1 / Dt), d[1] = (_ * Ht - f * rn - v * Qt) * Dt, d[2] = (se * vt - Ee * je + Se * ve) * Dt, d[3] = (Y * je - j * vt - K * ve) * Dt, d[4] = (R * Lt - w * rn - D * Et) * Dt, d[5] = (h * rn - _ * Lt + v * Et) * Dt, d[6] = (Ee * J - Q * vt - Se * Ne) * Dt, d[7] = (z * vt - Y * J + K * Ne) * Dt, d[8] = (w * Ht - P * Lt + D * Vt) * Dt, d[9] = (f * Lt - h * Ht - v * Vt) * Dt, d[10] = (Q * je - se * J + Se * et) * Dt, d[11] = (j * J - z * je - K * et) * Dt, d[12] = (P * Et - w * Qt - R * Vt) * Dt, d[13] = (h * Qt - f * Et + _ * Vt) * Dt, d[14] = (se * Ne - Q * ve - Ee * et) * Dt, d[15] = (z * ve - j * Ne + Y * et) * Dt, d) : null;
      }, c.ai = Me, c.aj = function(d) {
        return Math.hypot(d[0], d[1]);
      }, c.ak = function(d) {
        return d[0] = 0, d[1] = 0, d;
      }, c.al = function(d, o, h) {
        return d[0] = o[0] * h, d[1] = o[1] * h, d;
      }, c.am = q_, c.an = _e, c.ao = function(d, o, h, f) {
        const _ = o.y - d.y, v = o.x - d.x, w = f.y - h.y, P = f.x - h.x, R = w * v - P * _;
        if (R === 0) return null;
        const D = (P * (d.y - h.y) - w * (d.x - h.x)) / R;
        return new F(d.x + D * v, d.y + D * _);
      }, c.ap = T2, c.aq = Af, c.ar = Ge, c.as = function(d) {
        let o = 1 / 0, h = 1 / 0, f = -1 / 0, _ = -1 / 0;
        for (const v of d) o = Math.min(o, v.x), h = Math.min(h, v.y), f = Math.max(f, v.x), _ = Math.max(_, v.y);
        return [o, h, f, _];
      }, c.at = gs, c.au = Pt, c.av = function(d, o, h, f) {
        let _ = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
        if (!h[0] && !h[1]) return [0, 0];
        const v = _ ? f === "map" ? -d.bearingInRadians : 0 : f === "viewport" ? d.bearingInRadians : 0;
        if (v) {
          const w = Math.sin(v), P = Math.cos(v);
          h = [h[0] * P - h[1] * w, h[0] * w + h[1] * P];
        }
        return [_ ? h[0] : Pt(o, h[0], d.zoom), _ ? h[1] : Pt(o, h[1], d.zoom)];
      }, c.ax = V_, c.ay = K_, c.az = G_, c.b = Bt, c.b$ = (d) => d.type === "heatmap", c.b0 = function() {
        return new Float64Array(16);
      }, c.b1 = function(d, o, h) {
        const f = new Float64Array(4);
        return function(_, v, w, P) {
          var R = 0.5 * Math.PI / 180;
          v *= R, w *= R, P *= R;
          var D = Math.sin(v), z = Math.cos(v), j = Math.sin(w), Y = Math.cos(w), K = Math.sin(P), Q = Math.cos(P);
          _[0] = D * Y * Q - z * j * K, _[1] = z * j * Q + D * Y * K, _[2] = z * Y * K - D * j * Q, _[3] = z * Y * Q + D * j * K;
        }(f, d, o - 90, h), f;
      }, c.b2 = function(d, o, h, f) {
        var _, v, w, P, R, D = o[0], z = o[1], j = o[2], Y = o[3], K = h[0], Q = h[1], se = h[2], Ee = h[3];
        return (v = D * K + z * Q + j * se + Y * Ee) < 0 && (v = -v, K = -K, Q = -Q, se = -se, Ee = -Ee), 1 - v > Ae ? (_ = Math.acos(v), w = Math.sin(_), P = Math.sin((1 - f) * _) / w, R = Math.sin(f * _) / w) : (P = 1 - f, R = f), d[0] = P * D + R * K, d[1] = P * z + R * Q, d[2] = P * j + R * se, d[3] = P * Y + R * Ee, d;
      }, c.b3 = function(d) {
        const o = new Float64Array(9);
        var h, f, _, v, w, P, R, D, z, j, Y, K, Q, se, Ee, Se, et, Ne;
        j = (_ = (f = d)[0]) * (R = _ + _), Y = (v = f[1]) * R, Q = (w = f[2]) * R, se = w * (D = v + v), Se = (P = f[3]) * R, et = P * D, Ne = P * (z = w + w), (h = o)[0] = 1 - (K = v * D) - (Ee = w * z), h[3] = Y - Ne, h[6] = Q + et, h[1] = Y + Ne, h[4] = 1 - j - Ee, h[7] = se - Se, h[2] = Q - et, h[5] = se + Se, h[8] = 1 - j - K;
        const J = ln(-Math.asin(Re(o[2], -1, 1)));
        let ve, je;
        return Math.hypot(o[5], o[8]) < 1e-3 ? (ve = 0, je = -ln(Math.atan2(o[3], o[4]))) : (ve = ln(o[5] === 0 && o[8] === 0 ? 0 : Math.atan2(o[5], o[8])), je = ln(o[1] === 0 && o[0] === 0 ? 0 : Math.atan2(o[1], o[0]))), { roll: ve, pitch: J + 90, bearing: je };
      }, c.b4 = function(d, o) {
        return d.roll == o.roll && d.pitch == o.pitch && d.bearing == o.bearing;
      }, c.b5 = Qn, c.b6 = Cs, c.b7 = _d, c.b8 = Bf, c.b9 = md, c.bA = function d(o, h) {
        if (Array.isArray(o)) {
          if (!Array.isArray(h) || o.length !== h.length) return !1;
          for (let f = 0; f < o.length; f++) if (!d(o[f], h[f])) return !1;
          return !0;
        }
        if (typeof o == "object" && o !== null && h !== null) {
          if (typeof h != "object" || Object.keys(o).length !== Object.keys(h).length) return !1;
          for (const f in o) if (!d(o[f], h[f])) return !1;
          return !0;
        }
        return o === h;
      }, c.bB = rt, c.bC = xt, c.bD = class extends Lr {
        constructor(d, o) {
          super(d, o), this.current = 0;
        }
        set(d) {
          this.current !== d && (this.current = d, this.gl.uniform1i(this.location, d));
        }
      }, c.bE = bl, c.bF = class extends Lr {
        constructor(d, o) {
          super(d, o), this.current = vl;
        }
        set(d) {
          if (d[12] !== this.current[12] || d[0] !== this.current[0]) return this.current = d, void this.gl.uniformMatrix4fv(this.location, !1, d);
          for (let o = 1; o < 16; o++) if (d[o] !== this.current[o]) {
            this.current = d, this.gl.uniformMatrix4fv(this.location, !1, d);
            break;
          }
        }
      }, c.bG = Oo, c.bH = class extends Lr {
        constructor(d, o) {
          super(d, o), this.current = [0, 0, 0];
        }
        set(d) {
          d[0] === this.current[0] && d[1] === this.current[1] && d[2] === this.current[2] || (this.current = d, this.gl.uniform3f(this.location, d[0], d[1], d[2]));
        }
      }, c.bI = class extends Lr {
        constructor(d, o) {
          super(d, o), this.current = [0, 0];
        }
        set(d) {
          d[0] === this.current[0] && d[1] === this.current[1] || (this.current = d, this.gl.uniform2f(this.location, d[0], d[1]));
        }
      }, c.bJ = me, c.bK = function(d, o) {
        var h = Math.sin(o), f = Math.cos(o);
        return d[0] = f, d[1] = h, d[2] = 0, d[3] = -h, d[4] = f, d[5] = 0, d[6] = 0, d[7] = 0, d[8] = 1, d;
      }, c.bL = function(d, o, h) {
        var f = o[0], _ = o[1], v = o[2];
        return d[0] = f * h[0] + _ * h[3] + v * h[6], d[1] = f * h[1] + _ * h[4] + v * h[7], d[2] = f * h[2] + _ * h[5] + v * h[8], d;
      }, c.bM = function(d, o, h, f, _, v, w) {
        var P = 1 / (o - h), R = 1 / (f - _), D = 1 / (v - w);
        return d[0] = -2 * P, d[1] = 0, d[2] = 0, d[3] = 0, d[4] = 0, d[5] = -2 * R, d[6] = 0, d[7] = 0, d[8] = 0, d[9] = 0, d[10] = 2 * D, d[11] = 0, d[12] = (o + h) * P, d[13] = (_ + f) * R, d[14] = (w + v) * D, d[15] = 1, d;
      }, c.bN = class extends na {
      }, c.bO = YC, c.bP = class extends yo {
      }, c.bQ = T_, c.bR = function(d) {
        return d <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(d) / Math.LN2));
      }, c.bS = bv, c.bT = function(d, o, h) {
        var f = o[0], _ = o[1], v = o[2], w = h[3] * f + h[7] * _ + h[11] * v + h[15];
        return d[0] = (h[0] * f + h[4] * _ + h[8] * v + h[12]) / (w = w || 1), d[1] = (h[1] * f + h[5] * _ + h[9] * v + h[13]) / w, d[2] = (h[2] * f + h[6] * _ + h[10] * v + h[14]) / w, d;
      }, c.bU = class extends Ss {
      }, c.bV = class extends u {
      }, c.bW = function(d, o) {
        return d[0] === o[0] && d[1] === o[1] && d[2] === o[2] && d[3] === o[3] && d[4] === o[4] && d[5] === o[5] && d[6] === o[6] && d[7] === o[7] && d[8] === o[8] && d[9] === o[9] && d[10] === o[10] && d[11] === o[11] && d[12] === o[12] && d[13] === o[13] && d[14] === o[14] && d[15] === o[15];
      }, c.bX = function(d, o) {
        var h = d[0], f = d[1], _ = d[2], v = d[3], w = d[4], P = d[5], R = d[6], D = d[7], z = d[8], j = d[9], Y = d[10], K = d[11], Q = d[12], se = d[13], Ee = d[14], Se = d[15], et = o[0], Ne = o[1], J = o[2], ve = o[3], je = o[4], vt = o[5], Vt = o[6], Et = o[7], Lt = o[8], Qt = o[9], Ht = o[10], rn = o[11], Dt = o[12], Cn = o[13], zn = o[14], Dn = o[15];
        return Math.abs(h - et) <= Ae * Math.max(1, Math.abs(h), Math.abs(et)) && Math.abs(f - Ne) <= Ae * Math.max(1, Math.abs(f), Math.abs(Ne)) && Math.abs(_ - J) <= Ae * Math.max(1, Math.abs(_), Math.abs(J)) && Math.abs(v - ve) <= Ae * Math.max(1, Math.abs(v), Math.abs(ve)) && Math.abs(w - je) <= Ae * Math.max(1, Math.abs(w), Math.abs(je)) && Math.abs(P - vt) <= Ae * Math.max(1, Math.abs(P), Math.abs(vt)) && Math.abs(R - Vt) <= Ae * Math.max(1, Math.abs(R), Math.abs(Vt)) && Math.abs(D - Et) <= Ae * Math.max(1, Math.abs(D), Math.abs(Et)) && Math.abs(z - Lt) <= Ae * Math.max(1, Math.abs(z), Math.abs(Lt)) && Math.abs(j - Qt) <= Ae * Math.max(1, Math.abs(j), Math.abs(Qt)) && Math.abs(Y - Ht) <= Ae * Math.max(1, Math.abs(Y), Math.abs(Ht)) && Math.abs(K - rn) <= Ae * Math.max(1, Math.abs(K), Math.abs(rn)) && Math.abs(Q - Dt) <= Ae * Math.max(1, Math.abs(Q), Math.abs(Dt)) && Math.abs(se - Cn) <= Ae * Math.max(1, Math.abs(se), Math.abs(Cn)) && Math.abs(Ee - zn) <= Ae * Math.max(1, Math.abs(Ee), Math.abs(zn)) && Math.abs(Se - Dn) <= Ae * Math.max(1, Math.abs(Se), Math.abs(Dn));
      }, c.bY = function(d, o) {
        return d[0] = o[0], d[1] = o[1], d[2] = o[2], d[3] = o[3], d[4] = o[4], d[5] = o[5], d[6] = o[6], d[7] = o[7], d[8] = o[8], d[9] = o[9], d[10] = o[10], d[11] = o[11], d[12] = o[12], d[13] = o[13], d[14] = o[14], d[15] = o[15], d;
      }, c.bZ = (d) => d.type === "symbol", c.b_ = (d) => d.type === "circle", c.ba = Rt, c.bb = Ft, c.bc = hi, c.bd = function(d, o, h, f, _) {
        return Rt(f, _, Re((d - o) / (h - o), 0, 1));
      }, c.be = gt, c.bf = function() {
        return new Float64Array(4);
      }, c.bg = function() {
        return new Float64Array(3);
      }, c.bh = function(d, o, h, f) {
        var _ = [], v = [];
        return _[0] = o[0] - h[0], _[1] = o[1] - h[1], _[2] = o[2] - h[2], v[0] = _[0] * Math.cos(f) - _[1] * Math.sin(f), v[1] = _[0] * Math.sin(f) + _[1] * Math.cos(f), v[2] = _[2], d[0] = v[0] + h[0], d[1] = v[1] + h[1], d[2] = v[2] + h[2], d;
      }, c.bi = function(d, o, h, f) {
        var _ = [], v = [];
        return _[0] = o[0] - h[0], _[1] = o[1] - h[1], _[2] = o[2] - h[2], v[0] = _[0], v[1] = _[1] * Math.cos(f) - _[2] * Math.sin(f), v[2] = _[1] * Math.sin(f) + _[2] * Math.cos(f), d[0] = v[0] + h[0], d[1] = v[1] + h[1], d[2] = v[2] + h[2], d;
      }, c.bj = function(d, o, h, f) {
        var _ = [], v = [];
        return _[0] = o[0] - h[0], _[1] = o[1] - h[1], _[2] = o[2] - h[2], v[0] = _[2] * Math.sin(f) + _[0] * Math.cos(f), v[1] = _[1], v[2] = _[2] * Math.cos(f) - _[0] * Math.sin(f), d[0] = v[0] + h[0], d[1] = v[1] + h[1], d[2] = v[2] + h[2], d;
      }, c.bk = function(d, o, h) {
        var f = Math.sin(h), _ = Math.cos(h), v = o[0], w = o[1], P = o[2], R = o[3], D = o[8], z = o[9], j = o[10], Y = o[11];
        return o !== d && (d[4] = o[4], d[5] = o[5], d[6] = o[6], d[7] = o[7], d[12] = o[12], d[13] = o[13], d[14] = o[14], d[15] = o[15]), d[0] = v * _ - D * f, d[1] = w * _ - z * f, d[2] = P * _ - j * f, d[3] = R * _ - Y * f, d[8] = v * f + D * _, d[9] = w * f + z * _, d[10] = P * f + j * _, d[11] = R * f + Y * _, d;
      }, c.bl = function(d, o) {
        const h = gt(d, 360), f = gt(o, 360), _ = f - h, v = f > h ? _ - 360 : _ + 360;
        return Math.abs(_) < Math.abs(v) ? _ : v;
      }, c.bm = function(d) {
        return d[0] = 0, d[1] = 0, d[2] = 0, d;
      }, c.bn = function(d, o, h, f) {
        const _ = Math.sqrt(d * d + o * o), v = Math.sqrt(h * h + f * f);
        d /= _, o /= _, h /= v, f /= v;
        const w = Math.acos(d * h + o * f);
        return -o * h + d * f > 0 ? w : -w;
      }, c.bo = function(d, o) {
        return d[0] * o[0] + d[1] * o[1] + d[2] * o[2] + d[3];
      }, c.bp = $_, c.bq = function(d, o) {
        const h = gt(d, 2 * Math.PI), f = gt(o, 2 * Math.PI);
        return Math.min(Math.abs(h - f), Math.abs(h - f + 2 * Math.PI), Math.abs(h - f - 2 * Math.PI));
      }, c.br = function(d) {
        return Math.hypot(d[0], d[1], d[2]);
      }, c.bs = function() {
        const d = {}, o = be.$version;
        for (const h in be.$root) {
          const f = be.$root[h];
          if (f.required) {
            let _ = null;
            _ = h === "version" ? o : f.type === "array" ? [] : {}, _ != null && (d[h] = _);
          }
        }
        return d;
      }, c.bt = _u, c.bu = si, c.bv = function(d) {
        d = d.slice();
        const o = /* @__PURE__ */ Object.create(null);
        for (let h = 0; h < d.length; h++) o[d[h].id] = d[h];
        for (let h = 0; h < d.length; h++) "ref" in d[h] && (d[h] = ce(d[h], o[d[h].ref]));
        return d;
      }, c.bw = function(d) {
        if (d.type === "custom") return new bP(d);
        switch (d.type) {
          case "background":
            return new mP(d);
          case "circle":
            return new hC(d);
          case "fill":
            return new MC(d);
          case "fill-extrusion":
            return new kC(d);
          case "heatmap":
            return new fC(d);
          case "hillshade":
            return new gC(d);
          case "line":
            return new WC(d);
          case "raster":
            return new yP(d);
          case "symbol":
            return new gg(d);
        }
      }, c.bx = ht, c.by = function(d, o) {
        if (!d) return [{ command: "setStyle", args: [o] }];
        let h = [];
        try {
          if (!ue(d.version, o.version)) return [{ command: "setStyle", args: [o] }];
          ue(d.center, o.center) || h.push({ command: "setCenter", args: [o.center] }), ue(d.centerAltitude, o.centerAltitude) || h.push({ command: "setCenterAltitude", args: [o.centerAltitude] }), ue(d.zoom, o.zoom) || h.push({ command: "setZoom", args: [o.zoom] }), ue(d.bearing, o.bearing) || h.push({ command: "setBearing", args: [o.bearing] }), ue(d.pitch, o.pitch) || h.push({ command: "setPitch", args: [o.pitch] }), ue(d.roll, o.roll) || h.push({ command: "setRoll", args: [o.roll] }), ue(d.sprite, o.sprite) || h.push({ command: "setSprite", args: [o.sprite] }), ue(d.glyphs, o.glyphs) || h.push({ command: "setGlyphs", args: [o.glyphs] }), ue(d.transition, o.transition) || h.push({ command: "setTransition", args: [o.transition] }), ue(d.light, o.light) || h.push({ command: "setLight", args: [o.light] }), ue(d.terrain, o.terrain) || h.push({ command: "setTerrain", args: [o.terrain] }), ue(d.sky, o.sky) || h.push({ command: "setSky", args: [o.sky] }), ue(d.projection, o.projection) || h.push({ command: "setProjection", args: [o.projection] });
          const f = {}, _ = [];
          (function(w, P, R, D) {
            let z;
            for (z in P = P || {}, w = w || {}) Object.prototype.hasOwnProperty.call(w, z) && (Object.prototype.hasOwnProperty.call(P, z) || it(z, R, D));
            for (z in P) Object.prototype.hasOwnProperty.call(P, z) && (Object.prototype.hasOwnProperty.call(w, z) ? ue(w[z], P[z]) || (w[z].type === "geojson" && P[z].type === "geojson" && Ye(w, P, z) ? Oe(R, { command: "setGeoJSONSourceData", args: [z, P[z].data] }) : mt(z, P, R, D)) : qe(z, P, R));
          })(d.sources, o.sources, _, f);
          const v = [];
          d.layers && d.layers.forEach((w) => {
            "source" in w && f[w.source] ? h.push({ command: "removeLayer", args: [w.id] }) : v.push(w);
          }), h = h.concat(_), function(w, P, R) {
            P = P || [];
            const D = (w = w || []).map(pt), z = P.map(pt), j = w.reduce(lt, {}), Y = P.reduce(lt, {}), K = D.slice(), Q = /* @__PURE__ */ Object.create(null);
            let se, Ee, Se, et, Ne;
            for (let J = 0, ve = 0; J < D.length; J++) se = D[J], Object.prototype.hasOwnProperty.call(Y, se) ? ve++ : (Oe(R, { command: "removeLayer", args: [se] }), K.splice(K.indexOf(se, ve), 1));
            for (let J = 0, ve = 0; J < z.length; J++) se = z[z.length - 1 - J], K[K.length - 1 - J] !== se && (Object.prototype.hasOwnProperty.call(j, se) ? (Oe(R, { command: "removeLayer", args: [se] }), K.splice(K.lastIndexOf(se, K.length - ve), 1)) : ve++, et = K[K.length - J], Oe(R, { command: "addLayer", args: [Y[se], et] }), K.splice(K.length - J, 0, se), Q[se] = !0);
            for (let J = 0; J < z.length; J++) if (se = z[J], Ee = j[se], Se = Y[se], !Q[se] && !ue(Ee, Se)) if (ue(Ee.source, Se.source) && ue(Ee["source-layer"], Se["source-layer"]) && ue(Ee.type, Se.type)) {
              for (Ne in at(Ee.layout, Se.layout, R, se, null, "setLayoutProperty"), at(Ee.paint, Se.paint, R, se, null, "setPaintProperty"), ue(Ee.filter, Se.filter) || Oe(R, { command: "setFilter", args: [se, Se.filter] }), ue(Ee.minzoom, Se.minzoom) && ue(Ee.maxzoom, Se.maxzoom) || Oe(R, { command: "setLayerZoomRange", args: [se, Se.minzoom, Se.maxzoom] }), Ee) Object.prototype.hasOwnProperty.call(Ee, Ne) && Ne !== "layout" && Ne !== "paint" && Ne !== "filter" && Ne !== "metadata" && Ne !== "minzoom" && Ne !== "maxzoom" && (Ne.indexOf("paint.") === 0 ? at(Ee[Ne], Se[Ne], R, se, Ne.slice(6), "setPaintProperty") : ue(Ee[Ne], Se[Ne]) || Oe(R, { command: "setLayerProperty", args: [se, Ne, Se[Ne]] }));
              for (Ne in Se) Object.prototype.hasOwnProperty.call(Se, Ne) && !Object.prototype.hasOwnProperty.call(Ee, Ne) && Ne !== "layout" && Ne !== "paint" && Ne !== "filter" && Ne !== "metadata" && Ne !== "minzoom" && Ne !== "maxzoom" && (Ne.indexOf("paint.") === 0 ? at(Ee[Ne], Se[Ne], R, se, Ne.slice(6), "setPaintProperty") : ue(Ee[Ne], Se[Ne]) || Oe(R, { command: "setLayerProperty", args: [se, Ne, Se[Ne]] }));
            } else Oe(R, { command: "removeLayer", args: [se] }), et = K[K.lastIndexOf(se) + 1], Oe(R, { command: "addLayer", args: [Se, et] });
          }(v, o.layers, h);
        } catch (f) {
          console.warn("Unable to compute style diff:", f), h = [{ command: "setStyle", args: [o] }];
        }
        return h;
      }, c.bz = function(d) {
        const o = [], h = d.id;
        return h === void 0 && o.push({ message: `layers.${h}: missing required property "id"` }), d.render === void 0 && o.push({ message: `layers.${h}: missing required method "render"` }), d.renderingMode && d.renderingMode !== "2d" && d.renderingMode !== "3d" && o.push({ message: `layers.${h}: property "renderingMode" must be either "2d" or "3d"` }), o;
      }, c.c = _n, c.c0 = (d) => d.type === "line", c.c1 = (d) => d.type === "fill", c.c2 = (d) => d.type === "fill-extrusion", c.c3 = (d) => d.type === "hillshade", c.c4 = (d) => d.type === "raster", c.c5 = (d) => d.type === "background", c.c6 = (d) => d.type === "custom", c.c7 = mn, c.c8 = function(d, o, h) {
        const f = St(o.x - h.x, o.y - h.y), _ = St(d.x - h.x, d.y - h.y);
        var v, w;
        return ln(Math.atan2(f[0] * _[1] - f[1] * _[0], (v = f)[0] * (w = _)[0] + v[1] * w[1]));
      }, c.c9 = oe, c.cA = Fv, c.cB = $v, c.cC = $l, c.cD = tt, c.ca = function(d, o, h) {
        var f = o[0], _ = o[1];
        return d[0] = h[0] * f + h[4] * _ + h[12], d[1] = h[1] * f + h[5] * _ + h[13], d;
      }, c.cb = function(d, o) {
        const { x: h, y: f } = jf.fromLngLat(o);
        return !(d < 0 || d > 25 || f < 0 || f >= 1 || h < 0 || h >= 1);
      }, c.cc = function(d, o) {
        return d[0] = o[0], d[1] = 0, d[2] = 0, d[3] = 0, d[4] = 0, d[5] = o[1], d[6] = 0, d[7] = 0, d[8] = 0, d[9] = 0, d[10] = o[2], d[11] = 0, d[12] = 0, d[13] = 0, d[14] = 0, d[15] = 1, d;
      }, c.cd = class extends lr {
      }, c.ce = IP, c.cg = function(d) {
        return d.message === un;
      }, c.ch = Yn, c.ci = function(d, o) {
        Mn.REGISTERED_PROTOCOLS[d] = o;
      }, c.cj = function(d) {
        delete Mn.REGISTERED_PROTOCOLS[d];
      }, c.ck = function(d, o) {
        const h = {};
        for (let _ = 0; _ < d.length; _++) {
          const v = o && o[d[_].id] || bh(d[_]);
          o && (o[d[_].id] = v);
          let w = h[v];
          w || (w = h[v] = []), w.push(d[_]);
        }
        const f = [];
        for (const _ in h) f.push(h[_]);
        return f;
      }, c.cl = vn, c.cm = b2, c.cn = x2, c.co = Yv, c.cp = function(d) {
        d.bucket.createArrays(), d.bucket.tilePixelRatio = dt / (512 * d.bucket.overscaling), d.bucket.compareText = {}, d.bucket.iconsNeedLinear = !1;
        const o = d.bucket.layers[0], h = o.layout, f = o._unevaluatedLayout._values, _ = { layoutIconSize: f["icon-size"].possiblyEvaluate(new ut(d.bucket.zoom + 1), d.canonical), layoutTextSize: f["text-size"].possiblyEvaluate(new ut(d.bucket.zoom + 1), d.canonical), textMaxSize: f["text-size"].possiblyEvaluate(new ut(18)) };
        if (d.bucket.textSizeData.kind === "composite") {
          const { minZoom: D, maxZoom: z } = d.bucket.textSizeData;
          _.compositeTextSizes = [f["text-size"].possiblyEvaluate(new ut(D), d.canonical), f["text-size"].possiblyEvaluate(new ut(z), d.canonical)];
        }
        if (d.bucket.iconSizeData.kind === "composite") {
          const { minZoom: D, maxZoom: z } = d.bucket.iconSizeData;
          _.compositeIconSizes = [f["icon-size"].possiblyEvaluate(new ut(D), d.canonical), f["icon-size"].possiblyEvaluate(new ut(z), d.canonical)];
        }
        const v = h.get("text-line-height") * gs, w = h.get("text-rotation-alignment") !== "viewport" && h.get("symbol-placement") !== "point", P = h.get("text-keep-upright"), R = h.get("text-size");
        for (const D of d.bucket.features) {
          const z = h.get("text-font").evaluate(D, {}, d.canonical).join(","), j = R.evaluate(D, {}, d.canonical), Y = _.layoutTextSize.evaluate(D, {}, d.canonical), K = _.layoutIconSize.evaluate(D, {}, d.canonical), Q = { horizontal: {}, vertical: void 0 }, se = D.text;
          let Ee, Se = [0, 0];
          if (se) {
            const J = se.toString(), ve = h.get("text-letter-spacing").evaluate(D, {}, d.canonical) * gs, je = Sh(J) ? ve : 0, vt = h.get("text-anchor").evaluate(D, {}, d.canonical), Vt = B2(o, D, d.canonical);
            if (!Vt) {
              const Ht = h.get("text-radial-offset").evaluate(D, {}, d.canonical);
              Se = Ht ? R2(vt, [Ht * gs, J_]) : h.get("text-offset").evaluate(D, {}, d.canonical).map((rn) => rn * gs);
            }
            let Et = w ? "center" : h.get("text-justify").evaluate(D, {}, d.canonical);
            const Lt = h.get("symbol-placement") === "point" ? h.get("text-max-width").evaluate(D, {}, d.canonical) * gs : 1 / 0, Qt = () => {
              d.bucket.allowVerticalPlacement && zc(J) && (Q.vertical = dg(se, d.glyphMap, d.glyphPositions, d.imagePositions, z, Lt, v, vt, "left", je, Se, c.af.vertical, !0, Y, j));
            };
            if (!w && Vt) {
              const Ht = /* @__PURE__ */ new Set();
              if (Et === "auto") for (let Dt = 0; Dt < Vt.values.length; Dt += 2) Ht.add(K_(Vt.values[Dt]));
              else Ht.add(Et);
              let rn = !1;
              for (const Dt of Ht) if (!Q.horizontal[Dt]) if (rn) Q.horizontal[Dt] = Q.horizontal[0];
              else {
                const Cn = dg(se, d.glyphMap, d.glyphPositions, d.imagePositions, z, Lt, v, "center", Dt, je, Se, c.af.horizontal, !1, Y, j);
                Cn && (Q.horizontal[Dt] = Cn, rn = Cn.positionedLines.length === 1);
              }
              Qt();
            } else {
              Et === "auto" && (Et = K_(vt));
              const Ht = dg(se, d.glyphMap, d.glyphPositions, d.imagePositions, z, Lt, v, vt, Et, je, Se, c.af.horizontal, !1, Y, j);
              Ht && (Q.horizontal[Et] = Ht), Qt(), zc(J) && w && P && (Q.vertical = dg(se, d.glyphMap, d.glyphPositions, d.imagePositions, z, Lt, v, vt, Et, je, Se, c.af.vertical, !1, Y, j));
            }
          }
          let et = !1;
          if (D.icon && D.icon.name) {
            const J = d.imageMap[D.icon.name];
            J && (Ee = hP(d.imagePositions[D.icon.name], h.get("icon-offset").evaluate(D, {}, d.canonical), h.get("icon-anchor").evaluate(D, {}, d.canonical)), et = !!J.sdf, d.bucket.sdfIcons === void 0 ? d.bucket.sdfIcons = et : d.bucket.sdfIcons !== et && Wt("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (J.pixelRatio !== d.bucket.pixelRatio || h.get("icon-rotate").constantOr(1) !== 0) && (d.bucket.iconsNeedLinear = !0));
          }
          const Ne = D2(Q.horizontal) || Q.vertical;
          d.bucket.iconsInText = !!Ne && Ne.iconsInText, (Ne || Ee) && CP(d.bucket, D, Q, Ee, d.imageMap, _, Y, K, Se, et, d.canonical, d.subdivisionGranularity);
        }
        d.showCollisionBoxes && d.bucket.generateCollisionDebugBuffers();
      }, c.cq = D_, c.cr = I_, c.cs = O_, c.ct = Df, c.cu = k_, c.cv = class {
        constructor(d) {
          this._marks = { start: [d.url, "start"].join("#"), end: [d.url, "end"].join("#"), measure: d.url.toString() }, performance.mark(this._marks.start);
        }
        finish() {
          performance.mark(this._marks.end);
          let d = performance.getEntriesByName(this._marks.measure);
          return d.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), d = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), d;
        }
      }, c.cw = function(d, o, h, f, _) {
        return a(this, void 0, void 0, function* () {
          if (ie()) try {
            return yield On(d, o, h, f, _);
          } catch {
          }
          return function(v, w, P, R, D) {
            const z = v.width, j = v.height;
            Sn && en || (Sn = new OffscreenCanvas(z, j), en = Sn.getContext("2d", { willReadFrequently: !0 })), Sn.width = z, Sn.height = j, en.drawImage(v, 0, 0, z, j);
            const Y = en.getImageData(w, P, R, D);
            return en.clearRect(0, 0, z, j), Y.data;
          }(d, o, h, f, _);
        });
      }, c.cx = y2, c.cy = g, c.cz = C, c.d = (d) => a(void 0, void 0, void 0, function* () {
        if (d.byteLength === 0) return createImageBitmap(new ImageData(1, 1));
        const o = new Blob([new Uint8Array(d)], { type: "image/png" });
        try {
          return createImageBitmap(o);
        } catch (h) {
          throw new Error(`Could not load image because of ${h.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`);
        }
      }), c.e = Xe, c.f = (d) => new Promise((o, h) => {
        const f = new Image();
        f.onload = () => {
          o(f), URL.revokeObjectURL(f.src), f.onload = null, window.requestAnimationFrame(() => {
            f.src = Ue;
          });
        }, f.onerror = () => h(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
        const _ = new Blob([new Uint8Array(d)], { type: "image/png" });
        f.src = d.byteLength ? URL.createObjectURL(_) : Ue;
      }), c.g = Wn, c.h = (d, o) => fi(Xe(d, { type: "json" }), o), c.i = hn, c.j = pi, c.k = tr, c.l = (d, o) => fi(Xe(d, { type: "arrayBuffer" }), o), c.m = fi, c.n = function(d) {
        return new k_(d).readFields(QC, []);
      }, c.o = Pf, c.p = Xv, c.q = ri, c.r = Hu, c.s = Un, c.t = ud, c.u = ci, c.v = be, c.w = Wt, c.x = Nc, c.y = function(d) {
        let [o, h, f] = d;
        return h += 90, h *= Math.PI / 180, f *= Math.PI / 180, { x: o * Math.cos(h) * Math.sin(f), y: o * Math.sin(h) * Math.sin(f), z: o * Math.cos(f) };
      }, c.z = fo;
    }), r("worker", ["./shared"], function(c) {
      class a {
        constructor(ne) {
          this.keyCache = {}, ne && this.replace(ne);
        }
        replace(ne) {
          this._layerConfigs = {}, this._layers = {}, this.update(ne, []);
        }
        update(ne, ce) {
          for (const Oe of ne) {
            this._layerConfigs[Oe.id] = Oe;
            const qe = this._layers[Oe.id] = c.bw(Oe);
            qe._featureFilter = c.a5(qe.filter), this.keyCache[Oe.id] && delete this.keyCache[Oe.id];
          }
          for (const Oe of ce) delete this.keyCache[Oe], delete this._layerConfigs[Oe], delete this._layers[Oe];
          this.familiesBySource = {};
          const ue = c.ck(Object.values(this._layerConfigs), this.keyCache);
          for (const Oe of ue) {
            const qe = Oe.map((lt) => this._layers[lt.id]), it = qe[0];
            if (it.visibility === "none") continue;
            const mt = it.source || "";
            let Ye = this.familiesBySource[mt];
            Ye || (Ye = this.familiesBySource[mt] = {});
            const at = it.sourceLayer || "_geojsonTileLayer";
            let pt = Ye[at];
            pt || (pt = Ye[at] = []), pt.push(qe);
          }
        }
      }
      class g {
        constructor(ne) {
          const ce = {}, ue = [];
          for (const mt in ne) {
            const Ye = ne[mt], at = ce[mt] = {};
            for (const pt in Ye) {
              const lt = Ye[+pt];
              if (!lt || lt.bitmap.width === 0 || lt.bitmap.height === 0) continue;
              const Ze = { x: 0, y: 0, w: lt.bitmap.width + 2, h: lt.bitmap.height + 2 };
              ue.push(Ze), at[pt] = { rect: Ze, metrics: lt.metrics };
            }
          }
          const { w: Oe, h: qe } = c.p(ue), it = new c.o({ width: Oe || 1, height: qe || 1 });
          for (const mt in ne) {
            const Ye = ne[mt];
            for (const at in Ye) {
              const pt = Ye[+at];
              if (!pt || pt.bitmap.width === 0 || pt.bitmap.height === 0) continue;
              const lt = ce[mt][at].rect;
              c.o.copy(pt.bitmap, it, { x: 0, y: 0 }, { x: lt.x + 1, y: lt.y + 1 }, pt.bitmap);
            }
          }
          this.image = it, this.positions = ce;
        }
      }
      c.cl("GlyphAtlas", g);
      class y {
        constructor(ne) {
          this.tileID = new c.X(ne.tileID.overscaledZ, ne.tileID.wrap, ne.tileID.canonical.z, ne.tileID.canonical.x, ne.tileID.canonical.y), this.uid = ne.uid, this.zoom = ne.zoom, this.pixelRatio = ne.pixelRatio, this.tileSize = ne.tileSize, this.source = ne.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = ne.showCollisionBoxes, this.collectResourceTiming = !!ne.collectResourceTiming, this.returnDependencies = !!ne.returnDependencies, this.promoteId = ne.promoteId, this.inFlightDependencies = [];
        }
        parse(ne, ce, ue, Oe, qe) {
          return c._(this, void 0, void 0, function* () {
            this.status = "parsing", this.data = ne, this.collisionBoxArray = new c.a3();
            const it = new c.cm(Object.keys(ne.layers).sort()), mt = new c.cn(this.tileID, this.promoteId);
            mt.bucketLayerIDs = [];
            const Ye = {}, at = { featureIndex: mt, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: ue, subdivisionGranularity: qe }, pt = ce.familiesBySource[this.source];
            for (const Ln in pt) {
              const fn = ne.layers[Ln];
              if (!fn) continue;
              fn.version === 1 && c.w(`Vector tile source "${this.source}" layer "${Ln}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
              const xi = it.encode(Ln), Er = [];
              for (let Pi = 0; Pi < fn.length; Pi++) {
                const Ii = fn.feature(Pi), ui = mt.getId(Ii, Ln);
                Er.push({ feature: Ii, id: ui, index: Pi, sourceLayerIndex: xi });
              }
              for (const Pi of pt[Ln]) {
                const Ii = Pi[0];
                Ii.source !== this.source && c.w(`layer.source = ${Ii.source} does not equal this.source = ${this.source}`), Ii.minzoom && this.zoom < Math.floor(Ii.minzoom) || Ii.maxzoom && this.zoom >= Ii.maxzoom || Ii.visibility !== "none" && (A(Pi, this.zoom, ue), (Ye[Ii.id] = Ii.createBucket({ index: mt.bucketLayerIDs.length, layers: Pi, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: xi, sourceID: this.source })).populate(Er, at, this.tileID.canonical), mt.bucketLayerIDs.push(Pi.map((ui) => ui.id)));
              }
            }
            const lt = c.bB(at.glyphDependencies, (Ln) => Object.keys(Ln).map(Number));
            this.inFlightDependencies.forEach((Ln) => Ln == null ? void 0 : Ln.abort()), this.inFlightDependencies = [];
            let Ze = Promise.resolve({});
            if (Object.keys(lt).length) {
              const Ln = new AbortController();
              this.inFlightDependencies.push(Ln), Ze = Oe.sendAsync({ type: "GG", data: { stacks: lt, source: this.source, tileID: this.tileID, type: "glyphs" } }, Ln);
            }
            const an = Object.keys(at.iconDependencies);
            let Yt = Promise.resolve({});
            if (an.length) {
              const Ln = new AbortController();
              this.inFlightDependencies.push(Ln), Yt = Oe.sendAsync({ type: "GI", data: { icons: an, source: this.source, tileID: this.tileID, type: "icons" } }, Ln);
            }
            const Xt = Object.keys(at.patternDependencies);
            let An = Promise.resolve({});
            if (Xt.length) {
              const Ln = new AbortController();
              this.inFlightDependencies.push(Ln), An = Oe.sendAsync({ type: "GI", data: { icons: Xt, source: this.source, tileID: this.tileID, type: "patterns" } }, Ln);
            }
            const [It, Jt, cn] = yield Promise.all([Ze, Yt, An]), In = new g(It), Zn = new c.co(Jt, cn);
            for (const Ln in Ye) {
              const fn = Ye[Ln];
              fn instanceof c.a4 ? (A(fn.layers, this.zoom, ue), c.cp({ bucket: fn, glyphMap: It, glyphPositions: In.positions, imageMap: Jt, imagePositions: Zn.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical, subdivisionGranularity: at.subdivisionGranularity })) : fn.hasPattern && (fn instanceof c.cq || fn instanceof c.cr || fn instanceof c.cs) && (A(fn.layers, this.zoom, ue), fn.addFeatures(at, this.tileID.canonical, Zn.patternPositions));
            }
            return this.status = "done", { buckets: Object.values(Ye).filter((Ln) => !Ln.isEmpty()), featureIndex: mt, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: In.image, imageAtlas: Zn, glyphMap: this.returnDependencies ? It : null, iconMap: this.returnDependencies ? Jt : null, glyphPositions: this.returnDependencies ? In.positions : null };
          });
        }
      }
      function A(be, ne, ce) {
        const ue = new c.B(ne);
        for (const Oe of be) Oe.recalculate(ue, ce);
      }
      class C {
        constructor(ne, ce, ue) {
          this.actor = ne, this.layerIndex = ce, this.availableImages = ue, this.fetching = {}, this.loading = {}, this.loaded = {};
        }
        loadVectorTile(ne, ce) {
          return c._(this, void 0, void 0, function* () {
            const ue = yield c.l(ne.request, ce);
            try {
              return { vectorTile: new c.ct.VectorTile(new c.cu(ue.data)), rawData: ue.data, cacheControl: ue.cacheControl, expires: ue.expires };
            } catch (Oe) {
              const qe = new Uint8Array(ue.data);
              let it = `Unable to parse the tile at ${ne.request.url}, `;
              throw it += qe[0] === 31 && qe[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${Oe.message}`, new Error(it);
            }
          });
        }
        loadTile(ne) {
          return c._(this, void 0, void 0, function* () {
            const ce = ne.uid, ue = !!(ne && ne.request && ne.request.collectResourceTiming) && new c.cv(ne.request), Oe = new y(ne);
            this.loading[ce] = Oe;
            const qe = new AbortController();
            Oe.abort = qe;
            try {
              const it = yield this.loadVectorTile(ne, qe);
              if (delete this.loading[ce], !it) return null;
              const mt = it.rawData, Ye = {};
              it.expires && (Ye.expires = it.expires), it.cacheControl && (Ye.cacheControl = it.cacheControl);
              const at = {};
              if (ue) {
                const lt = ue.finish();
                lt && (at.resourceTiming = JSON.parse(JSON.stringify(lt)));
              }
              Oe.vectorTile = it.vectorTile;
              const pt = Oe.parse(it.vectorTile, this.layerIndex, this.availableImages, this.actor, ne.subdivisionGranularity);
              this.loaded[ce] = Oe, this.fetching[ce] = { rawTileData: mt, cacheControl: Ye, resourceTiming: at };
              try {
                const lt = yield pt;
                return c.e({ rawTileData: mt.slice(0) }, lt, Ye, at);
              } finally {
                delete this.fetching[ce];
              }
            } catch (it) {
              throw delete this.loading[ce], Oe.status = "done", this.loaded[ce] = Oe, it;
            }
          });
        }
        reloadTile(ne) {
          return c._(this, void 0, void 0, function* () {
            const ce = ne.uid;
            if (!this.loaded || !this.loaded[ce]) throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
            const ue = this.loaded[ce];
            if (ue.showCollisionBoxes = ne.showCollisionBoxes, ue.status === "parsing") {
              const Oe = yield ue.parse(ue.vectorTile, this.layerIndex, this.availableImages, this.actor, ne.subdivisionGranularity);
              let qe;
              if (this.fetching[ce]) {
                const { rawTileData: it, cacheControl: mt, resourceTiming: Ye } = this.fetching[ce];
                delete this.fetching[ce], qe = c.e({ rawTileData: it.slice(0) }, Oe, mt, Ye);
              } else qe = Oe;
              return qe;
            }
            if (ue.status === "done" && ue.vectorTile) return ue.parse(ue.vectorTile, this.layerIndex, this.availableImages, this.actor, ne.subdivisionGranularity);
          });
        }
        abortTile(ne) {
          return c._(this, void 0, void 0, function* () {
            const ce = this.loading, ue = ne.uid;
            ce && ce[ue] && ce[ue].abort && (ce[ue].abort.abort(), delete ce[ue]);
          });
        }
        removeTile(ne) {
          return c._(this, void 0, void 0, function* () {
            this.loaded && this.loaded[ne.uid] && delete this.loaded[ne.uid];
          });
        }
      }
      class I {
        constructor() {
          this.loaded = {};
        }
        loadTile(ne) {
          return c._(this, void 0, void 0, function* () {
            const { uid: ce, encoding: ue, rawImageData: Oe, redFactor: qe, greenFactor: it, blueFactor: mt, baseShift: Ye } = ne, at = Oe.width + 2, pt = Oe.height + 2, lt = c.b(Oe) ? new c.R({ width: at, height: pt }, yield c.cw(Oe, -1, -1, at, pt)) : Oe, Ze = new c.cx(ce, lt, ue, qe, it, mt, Ye);
            return this.loaded = this.loaded || {}, this.loaded[ce] = Ze, Ze;
          });
        }
        removeTile(ne) {
          const ce = this.loaded, ue = ne.uid;
          ce && ce[ue] && delete ce[ue];
        }
      }
      var S, F, U = function() {
        if (F) return S;
        function be(ce, ue) {
          if (ce.length !== 0) {
            ne(ce[0], ue);
            for (var Oe = 1; Oe < ce.length; Oe++) ne(ce[Oe], !ue);
          }
        }
        function ne(ce, ue) {
          for (var Oe = 0, qe = 0, it = 0, mt = ce.length, Ye = mt - 1; it < mt; Ye = it++) {
            var at = (ce[it][0] - ce[Ye][0]) * (ce[Ye][1] + ce[it][1]), pt = Oe + at;
            qe += Math.abs(Oe) >= Math.abs(at) ? Oe - pt + at : at - pt + Oe, Oe = pt;
          }
          Oe + qe >= 0 != !!ue && ce.reverse();
        }
        return F = 1, S = function ce(ue, Oe) {
          var qe, it = ue && ue.type;
          if (it === "FeatureCollection") for (qe = 0; qe < ue.features.length; qe++) ce(ue.features[qe], Oe);
          else if (it === "GeometryCollection") for (qe = 0; qe < ue.geometries.length; qe++) ce(ue.geometries[qe], Oe);
          else if (it === "Feature") ce(ue.geometry, Oe);
          else if (it === "Polygon") be(ue.coordinates, Oe);
          else if (it === "MultiPolygon") for (qe = 0; qe < ue.coordinates.length; qe++) be(ue.coordinates[qe], Oe);
          return ue;
        };
      }(), V = c.cy(U);
      const W = c.ct.VectorTileFeature.prototype.toGeoJSON;
      class X {
        constructor(ne) {
          this._feature = ne, this.extent = c.Y, this.type = ne.type, this.properties = ne.tags, "id" in ne && !isNaN(ne.id) && (this.id = parseInt(ne.id, 10));
        }
        loadGeometry() {
          if (this._feature.type === 1) {
            const ne = [];
            for (const ce of this._feature.geometry) ne.push([new c.P(ce[0], ce[1])]);
            return ne;
          }
          {
            const ne = [];
            for (const ce of this._feature.geometry) {
              const ue = [];
              for (const Oe of ce) ue.push(new c.P(Oe[0], Oe[1]));
              ne.push(ue);
            }
            return ne;
          }
        }
        toGeoJSON(ne, ce, ue) {
          return W.call(this, ne, ce, ue);
        }
      }
      class de {
        constructor(ne) {
          this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = c.Y, this.length = ne.length, this._features = ne;
        }
        feature(ne) {
          return new X(this._features[ne]);
        }
      }
      var ie, fe, Ae, Te = { exports: {} }, me = function() {
        if (Ae) return Te.exports;
        Ae = 1;
        var be = c.cB(), ne = function() {
          if (fe) return ie;
          fe = 1;
          var pt = c.cz(), lt = c.cA().VectorTileFeature;
          function Ze(Yt, Xt) {
            this.options = Xt || {}, this.features = Yt, this.length = Yt.length;
          }
          function an(Yt, Xt) {
            this.id = typeof Yt.id == "number" ? Yt.id : void 0, this.type = Yt.type, this.rawGeometry = Yt.type === 1 ? [Yt.geometry] : Yt.geometry, this.properties = Yt.tags, this.extent = Xt || 4096;
          }
          return ie = Ze, Ze.prototype.feature = function(Yt) {
            return new an(this.features[Yt], this.options.extent);
          }, an.prototype.loadGeometry = function() {
            var Yt = this.rawGeometry;
            this.geometry = [];
            for (var Xt = 0; Xt < Yt.length; Xt++) {
              for (var An = Yt[Xt], It = [], Jt = 0; Jt < An.length; Jt++) It.push(new pt(An[Jt][0], An[Jt][1]));
              this.geometry.push(It);
            }
            return this.geometry;
          }, an.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var Yt = this.geometry, Xt = 1 / 0, An = -1 / 0, It = 1 / 0, Jt = -1 / 0, cn = 0; cn < Yt.length; cn++) for (var In = Yt[cn], Zn = 0; Zn < In.length; Zn++) {
              var Ln = In[Zn];
              Xt = Math.min(Xt, Ln.x), An = Math.max(An, Ln.x), It = Math.min(It, Ln.y), Jt = Math.max(Jt, Ln.y);
            }
            return [Xt, It, An, Jt];
          }, an.prototype.toGeoJSON = lt.prototype.toGeoJSON, ie;
        }();
        function ce(pt) {
          var lt = new be();
          return function(Ze, an) {
            for (var Yt in Ze.layers) an.writeMessage(3, ue, Ze.layers[Yt]);
          }(pt, lt), lt.finish();
        }
        function ue(pt, lt) {
          var Ze;
          lt.writeVarintField(15, pt.version || 1), lt.writeStringField(1, pt.name || ""), lt.writeVarintField(5, pt.extent || 4096);
          var an = { keys: [], values: [], keycache: {}, valuecache: {} };
          for (Ze = 0; Ze < pt.length; Ze++) an.feature = pt.feature(Ze), lt.writeMessage(2, Oe, an);
          var Yt = an.keys;
          for (Ze = 0; Ze < Yt.length; Ze++) lt.writeStringField(3, Yt[Ze]);
          var Xt = an.values;
          for (Ze = 0; Ze < Xt.length; Ze++) lt.writeMessage(4, at, Xt[Ze]);
        }
        function Oe(pt, lt) {
          var Ze = pt.feature;
          Ze.id !== void 0 && lt.writeVarintField(1, Ze.id), lt.writeMessage(2, qe, pt), lt.writeVarintField(3, Ze.type), lt.writeMessage(4, Ye, Ze);
        }
        function qe(pt, lt) {
          var Ze = pt.feature, an = pt.keys, Yt = pt.values, Xt = pt.keycache, An = pt.valuecache;
          for (var It in Ze.properties) {
            var Jt = Ze.properties[It], cn = Xt[It];
            if (Jt !== null) {
              cn === void 0 && (an.push(It), Xt[It] = cn = an.length - 1), lt.writeVarint(cn);
              var In = typeof Jt;
              In !== "string" && In !== "boolean" && In !== "number" && (Jt = JSON.stringify(Jt));
              var Zn = In + ":" + Jt, Ln = An[Zn];
              Ln === void 0 && (Yt.push(Jt), An[Zn] = Ln = Yt.length - 1), lt.writeVarint(Ln);
            }
          }
        }
        function it(pt, lt) {
          return (lt << 3) + (7 & pt);
        }
        function mt(pt) {
          return pt << 1 ^ pt >> 31;
        }
        function Ye(pt, lt) {
          for (var Ze = pt.loadGeometry(), an = pt.type, Yt = 0, Xt = 0, An = Ze.length, It = 0; It < An; It++) {
            var Jt = Ze[It], cn = 1;
            an === 1 && (cn = Jt.length), lt.writeVarint(it(1, cn));
            for (var In = an === 3 ? Jt.length - 1 : Jt.length, Zn = 0; Zn < In; Zn++) {
              Zn === 1 && an !== 1 && lt.writeVarint(it(2, In - 1));
              var Ln = Jt[Zn].x - Yt, fn = Jt[Zn].y - Xt;
              lt.writeVarint(mt(Ln)), lt.writeVarint(mt(fn)), Yt += Ln, Xt += fn;
            }
            an === 3 && lt.writeVarint(it(7, 1));
          }
        }
        function at(pt, lt) {
          var Ze = typeof pt;
          Ze === "string" ? lt.writeStringField(1, pt) : Ze === "boolean" ? lt.writeBooleanField(7, pt) : Ze === "number" && (pt % 1 != 0 ? lt.writeDoubleField(3, pt) : pt < 0 ? lt.writeSVarintField(6, pt) : lt.writeVarintField(5, pt));
        }
        return Te.exports = ce, Te.exports.fromVectorTileJs = ce, Te.exports.fromGeojsonVt = function(pt, lt) {
          lt = lt || {};
          var Ze = {};
          for (var an in pt) Ze[an] = new ne(pt[an].features, lt), Ze[an].name = an, Ze[an].version = lt.version, Ze[an].extent = lt.extent;
          return ce({ layers: Ze });
        }, Te.exports.GeoJSONWrapper = ne, Te.exports;
      }(), Ge = c.cy(me);
      const ke = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: !1, generateId: !1, reduce: null, map: (be) => be }, pe = Math.fround || (_e = new Float32Array(1), (be) => (_e[0] = +be, _e[0]));
      var _e;
      const De = 3, Me = 5, St = 6;
      class dt {
        constructor(ne) {
          this.options = Object.assign(Object.create(ke), ne), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
        }
        load(ne) {
          const { log: ce, minZoom: ue, maxZoom: Oe } = this.options;
          ce && console.time("total time");
          const qe = `prepare ${ne.length} points`;
          ce && console.time(qe), this.points = ne;
          const it = [];
          for (let Ye = 0; Ye < ne.length; Ye++) {
            const at = ne[Ye];
            if (!at.geometry) continue;
            const [pt, lt] = at.geometry.coordinates, Ze = pe(Rt(pt)), an = pe(Ft(lt));
            it.push(Ze, an, 1 / 0, Ye, -1, 1), this.options.reduce && it.push(0);
          }
          let mt = this.trees[Oe + 1] = this._createTree(it);
          ce && console.timeEnd(qe);
          for (let Ye = Oe; Ye >= ue; Ye--) {
            const at = +Date.now();
            mt = this.trees[Ye] = this._createTree(this._cluster(mt, Ye)), ce && console.log("z%d: %d clusters in %dms", Ye, mt.numItems, +Date.now() - at);
          }
          return ce && console.timeEnd("total time"), this;
        }
        getClusters(ne, ce) {
          let ue = ((ne[0] + 180) % 360 + 360) % 360 - 180;
          const Oe = Math.max(-90, Math.min(90, ne[1]));
          let qe = ne[2] === 180 ? 180 : ((ne[2] + 180) % 360 + 360) % 360 - 180;
          const it = Math.max(-90, Math.min(90, ne[3]));
          if (ne[2] - ne[0] >= 360) ue = -180, qe = 180;
          else if (ue > qe) {
            const lt = this.getClusters([ue, Oe, 180, it], ce), Ze = this.getClusters([-180, Oe, qe, it], ce);
            return lt.concat(Ze);
          }
          const mt = this.trees[this._limitZoom(ce)], Ye = mt.range(Rt(ue), Ft(it), Rt(qe), Ft(Oe)), at = mt.data, pt = [];
          for (const lt of Ye) {
            const Ze = this.stride * lt;
            pt.push(at[Ze + Me] > 1 ? Pt(at, Ze, this.clusterProps) : this.points[at[Ze + De]]);
          }
          return pt;
        }
        getChildren(ne) {
          const ce = this._getOriginId(ne), ue = this._getOriginZoom(ne), Oe = "No cluster with the specified id.", qe = this.trees[ue];
          if (!qe) throw new Error(Oe);
          const it = qe.data;
          if (ce * this.stride >= it.length) throw new Error(Oe);
          const mt = this.options.radius / (this.options.extent * Math.pow(2, ue - 1)), Ye = qe.within(it[ce * this.stride], it[ce * this.stride + 1], mt), at = [];
          for (const pt of Ye) {
            const lt = pt * this.stride;
            it[lt + 4] === ne && at.push(it[lt + Me] > 1 ? Pt(it, lt, this.clusterProps) : this.points[it[lt + De]]);
          }
          if (at.length === 0) throw new Error(Oe);
          return at;
        }
        getLeaves(ne, ce, ue) {
          const Oe = [];
          return this._appendLeaves(Oe, ne, ce = ce || 10, ue = ue || 0, 0), Oe;
        }
        getTile(ne, ce, ue) {
          const Oe = this.trees[this._limitZoom(ne)], qe = Math.pow(2, ne), { extent: it, radius: mt } = this.options, Ye = mt / it, at = (ue - Ye) / qe, pt = (ue + 1 + Ye) / qe, lt = { features: [] };
          return this._addTileFeatures(Oe.range((ce - Ye) / qe, at, (ce + 1 + Ye) / qe, pt), Oe.data, ce, ue, qe, lt), ce === 0 && this._addTileFeatures(Oe.range(1 - Ye / qe, at, 1, pt), Oe.data, qe, ue, qe, lt), ce === qe - 1 && this._addTileFeatures(Oe.range(0, at, Ye / qe, pt), Oe.data, -1, ue, qe, lt), lt.features.length ? lt : null;
        }
        getClusterExpansionZoom(ne) {
          let ce = this._getOriginZoom(ne) - 1;
          for (; ce <= this.options.maxZoom; ) {
            const ue = this.getChildren(ne);
            if (ce++, ue.length !== 1) break;
            ne = ue[0].properties.cluster_id;
          }
          return ce;
        }
        _appendLeaves(ne, ce, ue, Oe, qe) {
          const it = this.getChildren(ce);
          for (const mt of it) {
            const Ye = mt.properties;
            if (Ye && Ye.cluster ? qe + Ye.point_count <= Oe ? qe += Ye.point_count : qe = this._appendLeaves(ne, Ye.cluster_id, ue, Oe, qe) : qe < Oe ? qe++ : ne.push(mt), ne.length === ue) break;
          }
          return qe;
        }
        _createTree(ne) {
          const ce = new c.aA(ne.length / this.stride | 0, this.options.nodeSize, Float32Array);
          for (let ue = 0; ue < ne.length; ue += this.stride) ce.add(ne[ue], ne[ue + 1]);
          return ce.finish(), ce.data = ne, ce;
        }
        _addTileFeatures(ne, ce, ue, Oe, qe, it) {
          for (const mt of ne) {
            const Ye = mt * this.stride, at = ce[Ye + Me] > 1;
            let pt, lt, Ze;
            if (at) pt = gt(ce, Ye, this.clusterProps), lt = ce[Ye], Ze = ce[Ye + 1];
            else {
              const Xt = this.points[ce[Ye + De]];
              pt = Xt.properties;
              const [An, It] = Xt.geometry.coordinates;
              lt = Rt(An), Ze = Ft(It);
            }
            const an = { type: 1, geometry: [[Math.round(this.options.extent * (lt * qe - ue)), Math.round(this.options.extent * (Ze * qe - Oe))]], tags: pt };
            let Yt;
            Yt = at || this.options.generateId ? ce[Ye + De] : this.points[ce[Ye + De]].id, Yt !== void 0 && (an.id = Yt), it.features.push(an);
          }
        }
        _limitZoom(ne) {
          return Math.max(this.options.minZoom, Math.min(Math.floor(+ne), this.options.maxZoom + 1));
        }
        _cluster(ne, ce) {
          const { radius: ue, extent: Oe, reduce: qe, minPoints: it } = this.options, mt = ue / (Oe * Math.pow(2, ce)), Ye = ne.data, at = [], pt = this.stride;
          for (let lt = 0; lt < Ye.length; lt += pt) {
            if (Ye[lt + 2] <= ce) continue;
            Ye[lt + 2] = ce;
            const Ze = Ye[lt], an = Ye[lt + 1], Yt = ne.within(Ye[lt], Ye[lt + 1], mt), Xt = Ye[lt + Me];
            let An = Xt;
            for (const It of Yt) {
              const Jt = It * pt;
              Ye[Jt + 2] > ce && (An += Ye[Jt + Me]);
            }
            if (An > Xt && An >= it) {
              let It, Jt = Ze * Xt, cn = an * Xt, In = -1;
              const Zn = ((lt / pt | 0) << 5) + (ce + 1) + this.points.length;
              for (const Ln of Yt) {
                const fn = Ln * pt;
                if (Ye[fn + 2] <= ce) continue;
                Ye[fn + 2] = ce;
                const xi = Ye[fn + Me];
                Jt += Ye[fn] * xi, cn += Ye[fn + 1] * xi, Ye[fn + 4] = Zn, qe && (It || (It = this._map(Ye, lt, !0), In = this.clusterProps.length, this.clusterProps.push(It)), qe(It, this._map(Ye, fn)));
              }
              Ye[lt + 4] = Zn, at.push(Jt / An, cn / An, 1 / 0, Zn, -1, An), qe && at.push(In);
            } else {
              for (let It = 0; It < pt; It++) at.push(Ye[lt + It]);
              if (An > 1) for (const It of Yt) {
                const Jt = It * pt;
                if (!(Ye[Jt + 2] <= ce)) {
                  Ye[Jt + 2] = ce;
                  for (let cn = 0; cn < pt; cn++) at.push(Ye[Jt + cn]);
                }
              }
            }
          }
          return at;
        }
        _getOriginId(ne) {
          return ne - this.points.length >> 5;
        }
        _getOriginZoom(ne) {
          return (ne - this.points.length) % 32;
        }
        _map(ne, ce, ue) {
          if (ne[ce + Me] > 1) {
            const it = this.clusterProps[ne[ce + St]];
            return ue ? Object.assign({}, it) : it;
          }
          const Oe = this.points[ne[ce + De]].properties, qe = this.options.map(Oe);
          return ue && qe === Oe ? Object.assign({}, qe) : qe;
        }
      }
      function Pt(be, ne, ce) {
        return { type: "Feature", id: be[ne + De], properties: gt(be, ne, ce), geometry: { type: "Point", coordinates: [(ue = be[ne], 360 * (ue - 0.5)), mn(be[ne + 1])] } };
        var ue;
      }
      function gt(be, ne, ce) {
        const ue = be[ne + Me], Oe = ue >= 1e4 ? `${Math.round(ue / 1e3)}k` : ue >= 1e3 ? Math.round(ue / 100) / 10 + "k" : ue, qe = be[ne + St], it = qe === -1 ? {} : Object.assign({}, ce[qe]);
        return Object.assign(it, { cluster: !0, cluster_id: be[ne + De], point_count: ue, point_count_abbreviated: Oe });
      }
      function Rt(be) {
        return be / 360 + 0.5;
      }
      function Ft(be) {
        const ne = Math.sin(be * Math.PI / 180), ce = 0.5 - 0.25 * Math.log((1 + ne) / (1 - ne)) / Math.PI;
        return ce < 0 ? 0 : ce > 1 ? 1 : ce;
      }
      function mn(be) {
        const ne = (180 - 360 * be) * Math.PI / 180;
        return 360 * Math.atan(Math.exp(ne)) / Math.PI - 90;
      }
      function oe(be, ne, ce, ue) {
        let Oe = ue;
        const qe = ne + (ce - ne >> 1);
        let it, mt = ce - ne;
        const Ye = be[ne], at = be[ne + 1], pt = be[ce], lt = be[ce + 1];
        for (let Ze = ne + 3; Ze < ce; Ze += 3) {
          const an = Re(be[Ze], be[Ze + 1], Ye, at, pt, lt);
          if (an > Oe) it = Ze, Oe = an;
          else if (an === Oe) {
            const Yt = Math.abs(Ze - qe);
            Yt < mt && (it = Ze, mt = Yt);
          }
        }
        Oe > ue && (it - ne > 3 && oe(be, ne, it, ue), be[it + 2] = Oe, ce - it > 3 && oe(be, it, ce, ue));
      }
      function Re(be, ne, ce, ue, Oe, qe) {
        let it = Oe - ce, mt = qe - ue;
        if (it !== 0 || mt !== 0) {
          const Ye = ((be - ce) * it + (ne - ue) * mt) / (it * it + mt * mt);
          Ye > 1 ? (ce = Oe, ue = qe) : Ye > 0 && (ce += it * Ye, ue += mt * Ye);
        }
        return it = be - ce, mt = ne - ue, it * it + mt * mt;
      }
      function ze(be, ne, ce, ue) {
        const Oe = { id: be ?? null, type: ne, geometry: ce, tags: ue, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        if (ne === "Point" || ne === "MultiPoint" || ne === "LineString") Xe(Oe, ce);
        else if (ne === "Polygon") Xe(Oe, ce[0]);
        else if (ne === "MultiLineString") for (const qe of ce) Xe(Oe, qe);
        else if (ne === "MultiPolygon") for (const qe of ce) Xe(Oe, qe[0]);
        return Oe;
      }
      function Xe(be, ne) {
        for (let ce = 0; ce < ne.length; ce += 3) be.minX = Math.min(be.minX, ne[ce]), be.minY = Math.min(be.minY, ne[ce + 1]), be.maxX = Math.max(be.maxX, ne[ce]), be.maxY = Math.max(be.maxY, ne[ce + 1]);
      }
      function ot(be, ne, ce, ue) {
        if (!ne.geometry) return;
        const Oe = ne.geometry.coordinates;
        if (Oe && Oe.length === 0) return;
        const qe = ne.geometry.type, it = Math.pow(ce.tolerance / ((1 << ce.maxZoom) * ce.extent), 2);
        let mt = [], Ye = ne.id;
        if (ce.promoteId ? Ye = ne.properties[ce.promoteId] : ce.generateId && (Ye = ue || 0), qe === "Point") rt(Oe, mt);
        else if (qe === "MultiPoint") for (const at of Oe) rt(at, mt);
        else if (qe === "LineString") xt(Oe, mt, it, !1);
        else if (qe === "MultiLineString") {
          if (ce.lineMetrics) {
            for (const at of Oe) mt = [], xt(at, mt, it, !1), be.push(ze(Ye, "LineString", mt, ne.properties));
            return;
          }
          ht(Oe, mt, it, !1);
        } else if (qe === "Polygon") ht(Oe, mt, it, !0);
        else {
          if (qe !== "MultiPolygon") {
            if (qe === "GeometryCollection") {
              for (const at of ne.geometry.geometries) ot(be, { id: Ye, geometry: at, properties: ne.properties }, ce, ue);
              return;
            }
            throw new Error("Input data is not a valid GeoJSON object.");
          }
          for (const at of Oe) {
            const pt = [];
            ht(at, pt, it, !0), mt.push(pt);
          }
        }
        be.push(ze(Ye, qe, mt, ne.properties));
      }
      function rt(be, ne) {
        ne.push($t(be[0]), Wt(be[1]), 0);
      }
      function xt(be, ne, ce, ue) {
        let Oe, qe, it = 0;
        for (let Ye = 0; Ye < be.length; Ye++) {
          const at = $t(be[Ye][0]), pt = Wt(be[Ye][1]);
          ne.push(at, pt, 0), Ye > 0 && (it += ue ? (Oe * pt - at * qe) / 2 : Math.sqrt(Math.pow(at - Oe, 2) + Math.pow(pt - qe, 2))), Oe = at, qe = pt;
        }
        const mt = ne.length - 3;
        ne[2] = 1, oe(ne, 0, mt, ce), ne[mt + 2] = 1, ne.size = Math.abs(it), ne.start = 0, ne.end = ne.size;
      }
      function ht(be, ne, ce, ue) {
        for (let Oe = 0; Oe < be.length; Oe++) {
          const qe = [];
          xt(be[Oe], qe, ce, ue), ne.push(qe);
        }
      }
      function $t(be) {
        return be / 360 + 0.5;
      }
      function Wt(be) {
        const ne = Math.sin(be * Math.PI / 180), ce = 0.5 - 0.25 * Math.log((1 + ne) / (1 - ne)) / Math.PI;
        return ce < 0 ? 0 : ce > 1 ? 1 : ce;
      }
      function on(be, ne, ce, ue, Oe, qe, it, mt) {
        if (ue /= ne, qe >= (ce /= ne) && it < ue) return be;
        if (it < ce || qe >= ue) return null;
        const Ye = [];
        for (const at of be) {
          const pt = at.geometry;
          let lt = at.type;
          const Ze = Oe === 0 ? at.minX : at.minY, an = Oe === 0 ? at.maxX : at.maxY;
          if (Ze >= ce && an < ue) {
            Ye.push(at);
            continue;
          }
          if (an < ce || Ze >= ue) continue;
          let Yt = [];
          if (lt === "Point" || lt === "MultiPoint") hn(pt, Yt, ce, ue, Oe);
          else if (lt === "LineString") wn(pt, Yt, ce, ue, Oe, !1, mt.lineMetrics);
          else if (lt === "MultiLineString") Ue(pt, Yt, ce, ue, Oe, !1);
          else if (lt === "Polygon") Ue(pt, Yt, ce, ue, Oe, !0);
          else if (lt === "MultiPolygon") for (const Xt of pt) {
            const An = [];
            Ue(Xt, An, ce, ue, Oe, !0), An.length && Yt.push(An);
          }
          if (Yt.length) {
            if (mt.lineMetrics && lt === "LineString") {
              for (const Xt of Yt) Ye.push(ze(at.id, lt, Xt, at.tags));
              continue;
            }
            lt !== "LineString" && lt !== "MultiLineString" || (Yt.length === 1 ? (lt = "LineString", Yt = Yt[0]) : lt = "MultiLineString"), lt !== "Point" && lt !== "MultiPoint" || (lt = Yt.length === 3 ? "Point" : "MultiPoint"), Ye.push(ze(at.id, lt, Yt, at.tags));
          }
        }
        return Ye.length ? Ye : null;
      }
      function hn(be, ne, ce, ue, Oe) {
        for (let qe = 0; qe < be.length; qe += 3) {
          const it = be[qe + Oe];
          it >= ce && it <= ue && On(ne, be[qe], be[qe + 1], be[qe + 2]);
        }
      }
      function wn(be, ne, ce, ue, Oe, qe, it) {
        let mt = Bt(be);
        const Ye = Oe === 0 ? Sn : en;
        let at, pt, lt = be.start;
        for (let An = 0; An < be.length - 3; An += 3) {
          const It = be[An], Jt = be[An + 1], cn = be[An + 2], In = be[An + 3], Zn = be[An + 4], Ln = Oe === 0 ? It : Jt, fn = Oe === 0 ? In : Zn;
          let xi = !1;
          it && (at = Math.sqrt(Math.pow(It - In, 2) + Math.pow(Jt - Zn, 2))), Ln < ce ? fn > ce && (pt = Ye(mt, It, Jt, In, Zn, ce), it && (mt.start = lt + at * pt)) : Ln > ue ? fn < ue && (pt = Ye(mt, It, Jt, In, Zn, ue), it && (mt.start = lt + at * pt)) : On(mt, It, Jt, cn), fn < ce && Ln >= ce && (pt = Ye(mt, It, Jt, In, Zn, ce), xi = !0), fn > ue && Ln <= ue && (pt = Ye(mt, It, Jt, In, Zn, ue), xi = !0), !qe && xi && (it && (mt.end = lt + at * pt), ne.push(mt), mt = Bt(be)), it && (lt += at);
        }
        let Ze = be.length - 3;
        const an = be[Ze], Yt = be[Ze + 1], Xt = Oe === 0 ? an : Yt;
        Xt >= ce && Xt <= ue && On(mt, an, Yt, be[Ze + 2]), Ze = mt.length - 3, qe && Ze >= 3 && (mt[Ze] !== mt[0] || mt[Ze + 1] !== mt[1]) && On(mt, mt[0], mt[1], mt[2]), mt.length && ne.push(mt);
      }
      function Bt(be) {
        const ne = [];
        return ne.size = be.size, ne.start = be.start, ne.end = be.end, ne;
      }
      function Ue(be, ne, ce, ue, Oe, qe) {
        for (const it of be) wn(it, ne, ce, ue, Oe, qe, !1);
      }
      function On(be, ne, ce, ue) {
        be.push(ne, ce, ue);
      }
      function Sn(be, ne, ce, ue, Oe, qe) {
        const it = (qe - ne) / (ue - ne);
        return On(be, qe, ce + (Oe - ce) * it, 1), it;
      }
      function en(be, ne, ce, ue, Oe, qe) {
        const it = (qe - ce) / (Oe - ce);
        return On(be, ne + (ue - ne) * it, qe, 1), it;
      }
      function ln(be, ne) {
        const ce = [];
        for (let ue = 0; ue < be.length; ue++) {
          const Oe = be[ue], qe = Oe.type;
          let it;
          if (qe === "Point" || qe === "MultiPoint" || qe === "LineString") it = un(Oe.geometry, ne);
          else if (qe === "MultiLineString" || qe === "Polygon") {
            it = [];
            for (const mt of Oe.geometry) it.push(un(mt, ne));
          } else if (qe === "MultiPolygon") {
            it = [];
            for (const mt of Oe.geometry) {
              const Ye = [];
              for (const at of mt) Ye.push(un(at, ne));
              it.push(Ye);
            }
          }
          ce.push(ze(Oe.id, qe, it, Oe.tags));
        }
        return ce;
      }
      function un(be, ne) {
        const ce = [];
        ce.size = be.size, be.start !== void 0 && (ce.start = be.start, ce.end = be.end);
        for (let ue = 0; ue < be.length; ue += 3) ce.push(be[ue] + ne, be[ue + 1], be[ue + 2]);
        return ce;
      }
      function _n(be, ne) {
        if (be.transformed) return be;
        const ce = 1 << be.z, ue = be.x, Oe = be.y;
        for (const qe of be.features) {
          const it = qe.geometry, mt = qe.type;
          if (qe.geometry = [], mt === 1) for (let Ye = 0; Ye < it.length; Ye += 2) qe.geometry.push(Mn(it[Ye], it[Ye + 1], ne, ce, ue, Oe));
          else for (let Ye = 0; Ye < it.length; Ye++) {
            const at = [];
            for (let pt = 0; pt < it[Ye].length; pt += 2) at.push(Mn(it[Ye][pt], it[Ye][pt + 1], ne, ce, ue, Oe));
            qe.geometry.push(at);
          }
        }
        return be.transformed = !0, be;
      }
      function Mn(be, ne, ce, ue, Oe, qe) {
        return [Math.round(ce * (be * ue - Oe)), Math.round(ce * (ne * ue - qe))];
      }
      function Wn(be, ne, ce, ue, Oe) {
        const qe = ne === Oe.maxZoom ? 0 : Oe.tolerance / ((1 << ne) * Oe.extent), it = { features: [], numPoints: 0, numSimplified: 0, numFeatures: be.length, source: null, x: ce, y: ue, z: ne, transformed: !1, minX: 2, minY: 1, maxX: -1, maxY: 0 };
        for (const mt of be) $n(it, mt, qe, Oe);
        return it;
      }
      function $n(be, ne, ce, ue) {
        const Oe = ne.geometry, qe = ne.type, it = [];
        if (be.minX = Math.min(be.minX, ne.minX), be.minY = Math.min(be.minY, ne.minY), be.maxX = Math.max(be.maxX, ne.maxX), be.maxY = Math.max(be.maxY, ne.maxY), qe === "Point" || qe === "MultiPoint") for (let mt = 0; mt < Oe.length; mt += 3) it.push(Oe[mt], Oe[mt + 1]), be.numPoints++, be.numSimplified++;
        else if (qe === "LineString") Yn(it, Oe, be, ce, !1, !1);
        else if (qe === "MultiLineString" || qe === "Polygon") for (let mt = 0; mt < Oe.length; mt++) Yn(it, Oe[mt], be, ce, qe === "Polygon", mt === 0);
        else if (qe === "MultiPolygon") for (let mt = 0; mt < Oe.length; mt++) {
          const Ye = Oe[mt];
          for (let at = 0; at < Ye.length; at++) Yn(it, Ye[at], be, ce, !0, at === 0);
        }
        if (it.length) {
          let mt = ne.tags || null;
          if (qe === "LineString" && ue.lineMetrics) {
            mt = {};
            for (const at in ne.tags) mt[at] = ne.tags[at];
            mt.mapbox_clip_start = Oe.start / Oe.size, mt.mapbox_clip_end = Oe.end / Oe.size;
          }
          const Ye = { geometry: it, type: qe === "Polygon" || qe === "MultiPolygon" ? 3 : qe === "LineString" || qe === "MultiLineString" ? 2 : 1, tags: mt };
          ne.id !== null && (Ye.id = ne.id), be.features.push(Ye);
        }
      }
      function Yn(be, ne, ce, ue, Oe, qe) {
        const it = ue * ue;
        if (ue > 0 && ne.size < (Oe ? it : ue)) return void (ce.numPoints += ne.length / 3);
        const mt = [];
        for (let Ye = 0; Ye < ne.length; Ye += 3) (ue === 0 || ne[Ye + 2] > it) && (ce.numSimplified++, mt.push(ne[Ye], ne[Ye + 1])), ce.numPoints++;
        Oe && function(Ye, at) {
          let pt = 0;
          for (let lt = 0, Ze = Ye.length, an = Ze - 2; lt < Ze; an = lt, lt += 2) pt += (Ye[lt] - Ye[an]) * (Ye[lt + 1] + Ye[an + 1]);
          if (pt > 0 === at) for (let lt = 0, Ze = Ye.length; lt < Ze / 2; lt += 2) {
            const an = Ye[lt], Yt = Ye[lt + 1];
            Ye[lt] = Ye[Ze - 2 - lt], Ye[lt + 1] = Ye[Ze - 1 - lt], Ye[Ze - 2 - lt] = an, Ye[Ze - 1 - lt] = Yt;
          }
        }(mt, qe), be.push(mt);
      }
      const si = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: !1, promoteId: null, generateId: !1, debug: 0 };
      class fi {
        constructor(ne, ce) {
          const ue = (ce = this.options = function(qe, it) {
            for (const mt in it) qe[mt] = it[mt];
            return qe;
          }(Object.create(si), ce)).debug;
          if (ue && console.time("preprocess data"), ce.maxZoom < 0 || ce.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
          if (ce.promoteId && ce.generateId) throw new Error("promoteId and generateId cannot be used together.");
          let Oe = function(qe, it) {
            const mt = [];
            if (qe.type === "FeatureCollection") for (let Ye = 0; Ye < qe.features.length; Ye++) ot(mt, qe.features[Ye], it, Ye);
            else ot(mt, qe.type === "Feature" ? qe : { geometry: qe }, it);
            return mt;
          }(ne, ce);
          this.tiles = {}, this.tileCoords = [], ue && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", ce.indexMaxZoom, ce.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), Oe = function(qe, it) {
            const mt = it.buffer / it.extent;
            let Ye = qe;
            const at = on(qe, 1, -1 - mt, mt, 0, -1, 2, it), pt = on(qe, 1, 1 - mt, 2 + mt, 0, -1, 2, it);
            return (at || pt) && (Ye = on(qe, 1, -mt, 1 + mt, 0, -1, 2, it) || [], at && (Ye = ln(at, 1).concat(Ye)), pt && (Ye = Ye.concat(ln(pt, -1)))), Ye;
          }(Oe, ce), Oe.length && this.splitTile(Oe, 0, 0, 0), ue && (Oe.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
        }
        splitTile(ne, ce, ue, Oe, qe, it, mt) {
          const Ye = [ne, ce, ue, Oe], at = this.options, pt = at.debug;
          for (; Ye.length; ) {
            Oe = Ye.pop(), ue = Ye.pop(), ce = Ye.pop(), ne = Ye.pop();
            const lt = 1 << ce, Ze = Un(ce, ue, Oe);
            let an = this.tiles[Ze];
            if (!an && (pt > 1 && console.time("creation"), an = this.tiles[Ze] = Wn(ne, ce, ue, Oe, at), this.tileCoords.push({ z: ce, x: ue, y: Oe }), pt)) {
              pt > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", ce, ue, Oe, an.numFeatures, an.numPoints, an.numSimplified), console.timeEnd("creation"));
              const xi = `z${ce}`;
              this.stats[xi] = (this.stats[xi] || 0) + 1, this.total++;
            }
            if (an.source = ne, qe == null) {
              if (ce === at.indexMaxZoom || an.numPoints <= at.indexMaxPoints) continue;
            } else {
              if (ce === at.maxZoom || ce === qe) continue;
              if (qe != null) {
                const xi = qe - ce;
                if (ue !== it >> xi || Oe !== mt >> xi) continue;
              }
            }
            if (an.source = null, ne.length === 0) continue;
            pt > 1 && console.time("clipping");
            const Yt = 0.5 * at.buffer / at.extent, Xt = 0.5 - Yt, An = 0.5 + Yt, It = 1 + Yt;
            let Jt = null, cn = null, In = null, Zn = null, Ln = on(ne, lt, ue - Yt, ue + An, 0, an.minX, an.maxX, at), fn = on(ne, lt, ue + Xt, ue + It, 0, an.minX, an.maxX, at);
            ne = null, Ln && (Jt = on(Ln, lt, Oe - Yt, Oe + An, 1, an.minY, an.maxY, at), cn = on(Ln, lt, Oe + Xt, Oe + It, 1, an.minY, an.maxY, at), Ln = null), fn && (In = on(fn, lt, Oe - Yt, Oe + An, 1, an.minY, an.maxY, at), Zn = on(fn, lt, Oe + Xt, Oe + It, 1, an.minY, an.maxY, at), fn = null), pt > 1 && console.timeEnd("clipping"), Ye.push(Jt || [], ce + 1, 2 * ue, 2 * Oe), Ye.push(cn || [], ce + 1, 2 * ue, 2 * Oe + 1), Ye.push(In || [], ce + 1, 2 * ue + 1, 2 * Oe), Ye.push(Zn || [], ce + 1, 2 * ue + 1, 2 * Oe + 1);
          }
        }
        getTile(ne, ce, ue) {
          ne = +ne, ce = +ce, ue = +ue;
          const Oe = this.options, { extent: qe, debug: it } = Oe;
          if (ne < 0 || ne > 24) return null;
          const mt = 1 << ne, Ye = Un(ne, ce = ce + mt & mt - 1, ue);
          if (this.tiles[Ye]) return _n(this.tiles[Ye], qe);
          it > 1 && console.log("drilling down to z%d-%d-%d", ne, ce, ue);
          let at, pt = ne, lt = ce, Ze = ue;
          for (; !at && pt > 0; ) pt--, lt >>= 1, Ze >>= 1, at = this.tiles[Un(pt, lt, Ze)];
          return at && at.source ? (it > 1 && (console.log("found parent tile z%d-%d-%d", pt, lt, Ze), console.time("drilling down")), this.splitTile(at.source, pt, lt, Ze, ne, ce, ue), it > 1 && console.timeEnd("drilling down"), this.tiles[Ye] ? _n(this.tiles[Ye], qe) : null) : null;
        }
      }
      function Un(be, ne, ce) {
        return 32 * ((1 << be) * ce + ne) + be;
      }
      function Jn(be, ne) {
        return ne ? be.properties[ne] : be.id;
      }
      function bn(be, ne) {
        if (be == null) return !0;
        if (be.type === "Feature") return Jn(be, ne) != null;
        if (be.type === "FeatureCollection") {
          const ce = /* @__PURE__ */ new Set();
          for (const ue of be.features) {
            const Oe = Jn(ue, ne);
            if (Oe == null || ce.has(Oe)) return !1;
            ce.add(Oe);
          }
          return !0;
        }
        return !1;
      }
      function tr(be, ne) {
        const ce = /* @__PURE__ */ new Map();
        if (be != null) if (be.type === "Feature") ce.set(Jn(be, ne), be);
        else for (const ue of be.features) ce.set(Jn(ue, ne), ue);
        return ce;
      }
      class pi extends C {
        constructor() {
          super(...arguments), this._dataUpdateable = /* @__PURE__ */ new Map();
        }
        loadVectorTile(ne, ce) {
          return c._(this, void 0, void 0, function* () {
            const ue = ne.tileID.canonical;
            if (!this._geoJSONIndex) throw new Error("Unable to parse the data into a cluster or geojson");
            const Oe = this._geoJSONIndex.getTile(ue.z, ue.x, ue.y);
            if (!Oe) return null;
            const qe = new de(Oe.features);
            let it = Ge(qe);
            return it.byteOffset === 0 && it.byteLength === it.buffer.byteLength || (it = new Uint8Array(it)), { vectorTile: qe, rawData: it.buffer };
          });
        }
        loadData(ne) {
          return c._(this, void 0, void 0, function* () {
            var ce;
            (ce = this._pendingRequest) === null || ce === void 0 || ce.abort();
            const ue = !!(ne && ne.request && ne.request.collectResourceTiming) && new c.cv(ne.request);
            this._pendingRequest = new AbortController();
            try {
              this._pendingData = this.loadAndProcessGeoJSON(ne, this._pendingRequest), this._geoJSONIndex = ne.cluster ? new dt(function(it) {
                let { superclusterOptions: mt, clusterProperties: Ye } = it;
                if (!Ye || !mt) return mt;
                const at = {}, pt = {}, lt = { accumulated: null, zoom: 0 }, Ze = { properties: null }, an = Object.keys(Ye);
                for (const Yt of an) {
                  const [Xt, An] = Ye[Yt], It = c.cC(An), Jt = c.cC(typeof Xt == "string" ? [Xt, ["accumulated"], ["get", Yt]] : Xt);
                  at[Yt] = It.value, pt[Yt] = Jt.value;
                }
                return mt.map = (Yt) => {
                  Ze.properties = Yt;
                  const Xt = {};
                  for (const An of an) Xt[An] = at[An].evaluate(lt, Ze);
                  return Xt;
                }, mt.reduce = (Yt, Xt) => {
                  Ze.properties = Xt;
                  for (const An of an) lt.accumulated = Yt[An], Yt[An] = pt[An].evaluate(lt, Ze);
                }, mt;
              }(ne)).load((yield this._pendingData).features) : (Oe = yield this._pendingData, new fi(Oe, ne.geojsonVtOptions)), this.loaded = {};
              const qe = {};
              if (ue) {
                const it = ue.finish();
                it && (qe.resourceTiming = {}, qe.resourceTiming[ne.source] = JSON.parse(JSON.stringify(it)));
              }
              return qe;
            } catch (qe) {
              if (delete this._pendingRequest, c.cg(qe)) return { abandoned: !0 };
              throw qe;
            }
            var Oe;
          });
        }
        getData() {
          return c._(this, void 0, void 0, function* () {
            return this._pendingData;
          });
        }
        reloadTile(ne) {
          const ce = this.loaded;
          return ce && ce[ne.uid] ? super.reloadTile(ne) : this.loadTile(ne);
        }
        loadAndProcessGeoJSON(ne, ce) {
          return c._(this, void 0, void 0, function* () {
            let ue = yield this.loadGeoJSON(ne, ce);
            if (delete this._pendingRequest, typeof ue != "object") throw new Error(`Input data given to '${ne.source}' is not a valid GeoJSON object.`);
            if (V(ue, !0), ne.filter) {
              const Oe = c.cC(ne.filter, { type: "boolean", "property-type": "data-driven", overridable: !1, transition: !1 });
              if (Oe.result === "error") throw new Error(Oe.value.map((it) => `${it.key}: ${it.message}`).join(", "));
              ue = { type: "FeatureCollection", features: ue.features.filter((it) => Oe.value.evaluate({ zoom: 0 }, it)) };
            }
            return ue;
          });
        }
        loadGeoJSON(ne, ce) {
          return c._(this, void 0, void 0, function* () {
            const { promoteId: ue } = ne;
            if (ne.request) {
              const Oe = yield c.h(ne.request, ce);
              return this._dataUpdateable = bn(Oe.data, ue) ? tr(Oe.data, ue) : void 0, Oe.data;
            }
            if (typeof ne.data == "string") try {
              const Oe = JSON.parse(ne.data);
              return this._dataUpdateable = bn(Oe, ue) ? tr(Oe, ue) : void 0, Oe;
            } catch {
              throw new Error(`Input data given to '${ne.source}' is not a valid GeoJSON object.`);
            }
            if (!ne.dataDiff) throw new Error(`Input data given to '${ne.source}' is not a valid GeoJSON object.`);
            if (!this._dataUpdateable) throw new Error(`Cannot update existing geojson data in ${ne.source}`);
            return function(Oe, qe, it) {
              var mt, Ye, at, pt;
              if (qe.removeAll && Oe.clear(), qe.remove) for (const lt of qe.remove) Oe.delete(lt);
              if (qe.add) for (const lt of qe.add) {
                const Ze = Jn(lt, it);
                Ze != null && Oe.set(Ze, lt);
              }
              if (qe.update) for (const lt of qe.update) {
                let Ze = Oe.get(lt.id);
                if (Ze == null) continue;
                const an = !lt.removeAllProperties && (((mt = lt.removeProperties) === null || mt === void 0 ? void 0 : mt.length) > 0 || ((Ye = lt.addOrUpdateProperties) === null || Ye === void 0 ? void 0 : Ye.length) > 0);
                if ((lt.newGeometry || lt.removeAllProperties || an) && (Ze = Object.assign({}, Ze), Oe.set(lt.id, Ze), an && (Ze.properties = Object.assign({}, Ze.properties))), lt.newGeometry && (Ze.geometry = lt.newGeometry), lt.removeAllProperties) Ze.properties = {};
                else if (((at = lt.removeProperties) === null || at === void 0 ? void 0 : at.length) > 0) for (const Yt of lt.removeProperties) Object.prototype.hasOwnProperty.call(Ze.properties, Yt) && delete Ze.properties[Yt];
                if (((pt = lt.addOrUpdateProperties) === null || pt === void 0 ? void 0 : pt.length) > 0) for (const { key: Yt, value: Xt } of lt.addOrUpdateProperties) Ze.properties[Yt] = Xt;
              }
            }(this._dataUpdateable, ne.dataDiff, ue), { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) };
          });
        }
        removeSource(ne) {
          return c._(this, void 0, void 0, function* () {
            this._pendingRequest && this._pendingRequest.abort();
          });
        }
        getClusterExpansionZoom(ne) {
          return this._geoJSONIndex.getClusterExpansionZoom(ne.clusterId);
        }
        getClusterChildren(ne) {
          return this._geoJSONIndex.getChildren(ne.clusterId);
        }
        getClusterLeaves(ne) {
          return this._geoJSONIndex.getLeaves(ne.clusterId, ne.limit, ne.offset);
        }
      }
      class Dr {
        constructor(ne) {
          this.self = ne, this.actor = new c.G(ne), this.layerIndexes = {}, this.availableImages = {}, this.workerSources = {}, this.demWorkerSources = {}, this.externalWorkerSourceTypes = {}, this.self.registerWorkerSource = (ce, ue) => {
            if (this.externalWorkerSourceTypes[ce]) throw new Error(`Worker source with name "${ce}" already registered.`);
            this.externalWorkerSourceTypes[ce] = ue;
          }, this.self.addProtocol = c.ci, this.self.removeProtocol = c.cj, this.self.registerRTLTextPlugin = (ce) => {
            c.cD.setMethods(ce);
          }, this.actor.registerMessageHandler("LDT", (ce, ue) => this._getDEMWorkerSource(ce, ue.source).loadTile(ue)), this.actor.registerMessageHandler("RDT", (ce, ue) => c._(this, void 0, void 0, function* () {
            this._getDEMWorkerSource(ce, ue.source).removeTile(ue);
          })), this.actor.registerMessageHandler("GCEZ", (ce, ue) => c._(this, void 0, void 0, function* () {
            return this._getWorkerSource(ce, ue.type, ue.source).getClusterExpansionZoom(ue);
          })), this.actor.registerMessageHandler("GCC", (ce, ue) => c._(this, void 0, void 0, function* () {
            return this._getWorkerSource(ce, ue.type, ue.source).getClusterChildren(ue);
          })), this.actor.registerMessageHandler("GCL", (ce, ue) => c._(this, void 0, void 0, function* () {
            return this._getWorkerSource(ce, ue.type, ue.source).getClusterLeaves(ue);
          })), this.actor.registerMessageHandler("LD", (ce, ue) => this._getWorkerSource(ce, ue.type, ue.source).loadData(ue)), this.actor.registerMessageHandler("GD", (ce, ue) => this._getWorkerSource(ce, ue.type, ue.source).getData()), this.actor.registerMessageHandler("LT", (ce, ue) => this._getWorkerSource(ce, ue.type, ue.source).loadTile(ue)), this.actor.registerMessageHandler("RT", (ce, ue) => this._getWorkerSource(ce, ue.type, ue.source).reloadTile(ue)), this.actor.registerMessageHandler("AT", (ce, ue) => this._getWorkerSource(ce, ue.type, ue.source).abortTile(ue)), this.actor.registerMessageHandler("RMT", (ce, ue) => this._getWorkerSource(ce, ue.type, ue.source).removeTile(ue)), this.actor.registerMessageHandler("RS", (ce, ue) => c._(this, void 0, void 0, function* () {
            if (!this.workerSources[ce] || !this.workerSources[ce][ue.type] || !this.workerSources[ce][ue.type][ue.source]) return;
            const Oe = this.workerSources[ce][ue.type][ue.source];
            delete this.workerSources[ce][ue.type][ue.source], Oe.removeSource !== void 0 && Oe.removeSource(ue);
          })), this.actor.registerMessageHandler("RM", (ce) => c._(this, void 0, void 0, function* () {
            delete this.layerIndexes[ce], delete this.availableImages[ce], delete this.workerSources[ce], delete this.demWorkerSources[ce];
          })), this.actor.registerMessageHandler("SR", (ce, ue) => c._(this, void 0, void 0, function* () {
            this.referrer = ue;
          })), this.actor.registerMessageHandler("SRPS", (ce, ue) => this._syncRTLPluginState(ce, ue)), this.actor.registerMessageHandler("IS", (ce, ue) => c._(this, void 0, void 0, function* () {
            this.self.importScripts(ue);
          })), this.actor.registerMessageHandler("SI", (ce, ue) => this._setImages(ce, ue)), this.actor.registerMessageHandler("UL", (ce, ue) => c._(this, void 0, void 0, function* () {
            this._getLayerIndex(ce).update(ue.layers, ue.removedIds);
          })), this.actor.registerMessageHandler("SL", (ce, ue) => c._(this, void 0, void 0, function* () {
            this._getLayerIndex(ce).replace(ue);
          }));
        }
        _setImages(ne, ce) {
          return c._(this, void 0, void 0, function* () {
            this.availableImages[ne] = ce;
            for (const ue in this.workerSources[ne]) {
              const Oe = this.workerSources[ne][ue];
              for (const qe in Oe) Oe[qe].availableImages = ce;
            }
          });
        }
        _syncRTLPluginState(ne, ce) {
          return c._(this, void 0, void 0, function* () {
            return yield c.cD.syncState(ce, this.self.importScripts);
          });
        }
        _getAvailableImages(ne) {
          let ce = this.availableImages[ne];
          return ce || (ce = []), ce;
        }
        _getLayerIndex(ne) {
          let ce = this.layerIndexes[ne];
          return ce || (ce = this.layerIndexes[ne] = new a()), ce;
        }
        _getWorkerSource(ne, ce, ue) {
          if (this.workerSources[ne] || (this.workerSources[ne] = {}), this.workerSources[ne][ce] || (this.workerSources[ne][ce] = {}), !this.workerSources[ne][ce][ue]) {
            const Oe = { sendAsync: (qe, it) => (qe.targetMapId = ne, this.actor.sendAsync(qe, it)) };
            switch (ce) {
              case "vector":
                this.workerSources[ne][ce][ue] = new C(Oe, this._getLayerIndex(ne), this._getAvailableImages(ne));
                break;
              case "geojson":
                this.workerSources[ne][ce][ue] = new pi(Oe, this._getLayerIndex(ne), this._getAvailableImages(ne));
                break;
              default:
                this.workerSources[ne][ce][ue] = new this.externalWorkerSourceTypes[ce](Oe, this._getLayerIndex(ne), this._getAvailableImages(ne));
            }
          }
          return this.workerSources[ne][ce][ue];
        }
        _getDEMWorkerSource(ne, ce) {
          return this.demWorkerSources[ne] || (this.demWorkerSources[ne] = {}), this.demWorkerSources[ne][ce] || (this.demWorkerSources[ne][ce] = new I()), this.demWorkerSources[ne][ce];
        }
      }
      return c.i(self) && (self.worker = new Dr(self)), Dr;
    }), r("index", ["exports", "./shared"], function(c, a) {
      var g = "5.1.1";
      function y() {
        var b = new a.A(4);
        return a.A != Float32Array && (b[1] = 0, b[2] = 0), b[0] = 1, b[3] = 1, b;
      }
      let A, C;
      const I = { now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(b, s, u) {
        const p = requestAnimationFrame(s);
        b.signal.addEventListener("abort", () => {
          cancelAnimationFrame(p), u(a.c());
        });
      }, frameAsync(b) {
        return new Promise((s, u) => {
          this.frame(b, s, u);
        });
      }, getImageData(b) {
        let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        return this.getImageCanvasContext(b).getImageData(-s, -s, b.width + 2 * s, b.height + 2 * s);
      }, getImageCanvasContext(b) {
        const s = window.document.createElement("canvas"), u = s.getContext("2d", { willReadFrequently: !0 });
        if (!u) throw new Error("failed to create canvas 2d context");
        return s.width = b.width, s.height = b.height, u.drawImage(b, 0, 0, b.width, b.height), u;
      }, resolveURL: (b) => (A || (A = document.createElement("a")), A.href = b, A.href), hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
        return !!matchMedia && (C == null && (C = matchMedia("(prefers-reduced-motion: reduce)")), C.matches);
      } };
      class S {
        static testProp(s) {
          if (!S.docStyle) return s[0];
          for (let u = 0; u < s.length; u++) if (s[u] in S.docStyle) return s[u];
          return s[0];
        }
        static create(s, u, p) {
          const m = window.document.createElement(s);
          return u !== void 0 && (m.className = u), p && p.appendChild(m), m;
        }
        static createNS(s, u) {
          return window.document.createElementNS(s, u);
        }
        static disableDrag() {
          S.docStyle && S.selectProp && (S.userSelect = S.docStyle[S.selectProp], S.docStyle[S.selectProp] = "none");
        }
        static enableDrag() {
          S.docStyle && S.selectProp && (S.docStyle[S.selectProp] = S.userSelect);
        }
        static setTransform(s, u) {
          s.style[S.transformProp] = u;
        }
        static addEventListener(s, u, p) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          s.addEventListener(u, p, "passive" in m ? m : m.capture);
        }
        static removeEventListener(s, u, p) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          s.removeEventListener(u, p, "passive" in m ? m : m.capture);
        }
        static suppressClickInternal(s) {
          s.preventDefault(), s.stopPropagation(), window.removeEventListener("click", S.suppressClickInternal, !0);
        }
        static suppressClick() {
          window.addEventListener("click", S.suppressClickInternal, !0), window.setTimeout(() => {
            window.removeEventListener("click", S.suppressClickInternal, !0);
          }, 0);
        }
        static getScale(s) {
          const u = s.getBoundingClientRect();
          return { x: u.width / s.offsetWidth || 1, y: u.height / s.offsetHeight || 1, boundingClientRect: u };
        }
        static getPoint(s, u, p) {
          const m = u.boundingClientRect;
          return new a.P((p.clientX - m.left) / u.x - s.clientLeft, (p.clientY - m.top) / u.y - s.clientTop);
        }
        static mousePos(s, u) {
          const p = S.getScale(s);
          return S.getPoint(s, p, u);
        }
        static touchPos(s, u) {
          const p = [], m = S.getScale(s);
          for (let x = 0; x < u.length; x++) p.push(S.getPoint(s, m, u[x]));
          return p;
        }
        static mouseButton(s) {
          return s.button;
        }
        static remove(s) {
          s.parentNode && s.parentNode.removeChild(s);
        }
        static sanitize(s) {
          const u = new DOMParser().parseFromString(s, "text/html").body || document.createElement("body"), p = u.querySelectorAll("script");
          for (const m of p) m.remove();
          return S.clean(u), u.innerHTML;
        }
        static isPossiblyDangerous(s, u) {
          const p = u.replace(/\s+/g, "").toLowerCase();
          return !(!["src", "href", "xlink:href"].includes(s) || !p.includes("javascript:") && !p.includes("data:")) || !!s.startsWith("on") || void 0;
        }
        static clean(s) {
          const u = s.children;
          for (const p of u) S.removeAttributes(p), S.clean(p);
        }
        static removeAttributes(s) {
          for (const { name: u, value: p } of s.attributes) S.isPossiblyDangerous(u, p) && s.removeAttribute(u);
        }
      }
      S.docStyle = typeof window < "u" && window.document && window.document.documentElement.style, S.selectProp = S.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), S.transformProp = S.testProp(["transform", "WebkitTransform"]);
      const F = { supported: !1, testSupport: function(b) {
        !W && V && (X ? de(b) : U = b);
      } };
      let U, V, W = !1, X = !1;
      function de(b) {
        const s = b.createTexture();
        b.bindTexture(b.TEXTURE_2D, s);
        try {
          if (b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, b.RGBA, b.UNSIGNED_BYTE, V), b.isContextLost()) return;
          F.supported = !0;
        } catch {
        }
        b.deleteTexture(s), W = !0;
      }
      var ie;
      typeof document < "u" && (V = document.createElement("img"), V.onload = () => {
        U && de(U), U = null, X = !0;
      }, V.onerror = () => {
        W = !0, U = null;
      }, V.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(b) {
        let s, u, p, m;
        b.resetRequestQueue = () => {
          s = [], u = 0, p = 0, m = {};
        }, b.addThrottleControl = (B) => {
          const N = p++;
          return m[N] = B, N;
        }, b.removeThrottleControl = (B) => {
          delete m[B], E();
        }, b.getImage = function(B, N) {
          let G = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
          return new Promise((Z, $) => {
            F.supported && (B.headers || (B.headers = {}), B.headers.accept = "image/webp,*/*"), a.e(B, { type: "image" }), s.push({ abortController: N, requestParameters: B, supportImageRefresh: G, state: "queued", onError: (re) => {
              $(re);
            }, onSuccess: (re) => {
              Z(re);
            } }), E();
          });
        };
        const x = (B) => a._(this, void 0, void 0, function* () {
          B.state = "running";
          const { requestParameters: N, supportImageRefresh: G, onError: Z, onSuccess: $, abortController: re } = B, ae = G === !1 && !a.i(self) && !a.g(N.url) && (!N.headers || Object.keys(N.headers).reduce((Ie, Be) => Ie && Be === "accept", !0));
          u++;
          const Pe = ae ? L(N, re) : a.m(N, re);
          try {
            const Ie = yield Pe;
            delete B.abortController, B.state = "completed", Ie.data instanceof HTMLImageElement || a.b(Ie.data) ? $(Ie) : Ie.data && $({ data: yield (Ce = Ie.data, typeof createImageBitmap == "function" ? a.d(Ce) : a.f(Ce)), cacheControl: Ie.cacheControl, expires: Ie.expires });
          } catch (Ie) {
            delete B.abortController, Z(Ie);
          } finally {
            u--, E();
          }
          var Ce;
        }), E = () => {
          const B = (() => {
            for (const N of Object.keys(m)) if (m[N]()) return !0;
            return !1;
          })() ? a.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : a.a.MAX_PARALLEL_IMAGE_REQUESTS;
          for (let N = u; N < B && s.length > 0; N++) {
            const G = s.shift();
            G.abortController.signal.aborted ? N-- : x(G);
          }
        }, L = (B, N) => new Promise((G, Z) => {
          const $ = new Image(), re = B.url, ae = B.credentials;
          ae && ae === "include" ? $.crossOrigin = "use-credentials" : (ae && ae === "same-origin" || !a.s(re)) && ($.crossOrigin = "anonymous"), N.signal.addEventListener("abort", () => {
            $.src = "", Z(a.c());
          }), $.fetchPriority = "high", $.onload = () => {
            $.onerror = $.onload = null, G({ data: $ });
          }, $.onerror = () => {
            $.onerror = $.onload = null, N.signal.aborted || Z(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
          }, $.src = re;
        });
      }(ie || (ie = {})), ie.resetRequestQueue();
      class fe {
        constructor(s) {
          this._transformRequestFn = s;
        }
        transformRequest(s, u) {
          return this._transformRequestFn && this._transformRequestFn(s, u) || { url: s };
        }
        setTransformRequest(s) {
          this._transformRequestFn = s;
        }
      }
      function Ae(b) {
        const s = [];
        if (typeof b == "string") s.push({ id: "default", url: b });
        else if (b && b.length > 0) {
          const u = [];
          for (const { id: p, url: m } of b) {
            const x = `${p}${m}`;
            u.indexOf(x) === -1 && (u.push(x), s.push({ id: p, url: m }));
          }
        }
        return s;
      }
      function Te(b, s, u) {
        try {
          const p = new URL(b);
          return p.pathname += `${s}${u}`, p.toString();
        } catch {
          throw new Error(`Invalid sprite URL "${b}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`);
        }
      }
      class me {
        constructor(s, u, p, m) {
          this.context = s, this.format = p, this.texture = s.gl.createTexture(), this.update(u, m);
        }
        update(s, u, p) {
          const { width: m, height: x } = s, E = !(this.size && this.size[0] === m && this.size[1] === x || p), { context: L } = this, { gl: B } = L;
          if (this.useMipmap = !!(u && u.useMipmap), B.bindTexture(B.TEXTURE_2D, this.texture), L.pixelStoreUnpackFlipY.set(!1), L.pixelStoreUnpack.set(1), L.pixelStoreUnpackPremultiplyAlpha.set(this.format === B.RGBA && (!u || u.premultiply !== !1)), E) this.size = [m, x], s instanceof HTMLImageElement || s instanceof HTMLCanvasElement || s instanceof HTMLVideoElement || s instanceof ImageData || a.b(s) ? B.texImage2D(B.TEXTURE_2D, 0, this.format, this.format, B.UNSIGNED_BYTE, s) : B.texImage2D(B.TEXTURE_2D, 0, this.format, m, x, 0, this.format, B.UNSIGNED_BYTE, s.data);
          else {
            const { x: N, y: G } = p || { x: 0, y: 0 };
            s instanceof HTMLImageElement || s instanceof HTMLCanvasElement || s instanceof HTMLVideoElement || s instanceof ImageData || a.b(s) ? B.texSubImage2D(B.TEXTURE_2D, 0, N, G, B.RGBA, B.UNSIGNED_BYTE, s) : B.texSubImage2D(B.TEXTURE_2D, 0, N, G, m, x, B.RGBA, B.UNSIGNED_BYTE, s.data);
          }
          this.useMipmap && this.isSizePowerOfTwo() && B.generateMipmap(B.TEXTURE_2D);
        }
        bind(s, u, p) {
          const { context: m } = this, { gl: x } = m;
          x.bindTexture(x.TEXTURE_2D, this.texture), p !== x.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (p = x.LINEAR), s !== this.filter && (x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, s), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, p || s), this.filter = s), u !== this.wrap && (x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, u), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, u), this.wrap = u);
        }
        isSizePowerOfTwo() {
          return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
        }
        destroy() {
          const { gl: s } = this.context;
          s.deleteTexture(this.texture), this.texture = null;
        }
      }
      function Ge(b) {
        const { userImage: s } = b;
        return !!(s && s.render && s.render()) && (b.data.replace(new Uint8Array(s.data.buffer)), !0);
      }
      class ke extends a.E {
        constructor() {
          super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = !1, this.requestors = [], this.patterns = {}, this.atlasImage = new a.R({ width: 1, height: 1 }), this.dirty = !0;
        }
        isLoaded() {
          return this.loaded;
        }
        setLoaded(s) {
          if (this.loaded !== s && (this.loaded = s, s)) {
            for (const { ids: u, promiseResolve: p } of this.requestors) p(this._getImagesForIds(u));
            this.requestors = [];
          }
        }
        getImage(s) {
          const u = this.images[s];
          if (u && !u.data && u.spriteData) {
            const p = u.spriteData;
            u.data = new a.R({ width: p.width, height: p.height }, p.context.getImageData(p.x, p.y, p.width, p.height).data), u.spriteData = null;
          }
          return u;
        }
        addImage(s, u) {
          if (this.images[s]) throw new Error(`Image id ${s} already exist, use updateImage instead`);
          this._validate(s, u) && (this.images[s] = u);
        }
        _validate(s, u) {
          let p = !0;
          const m = u.data || u.spriteData;
          return this._validateStretch(u.stretchX, m && m.width) || (this.fire(new a.j(new Error(`Image "${s}" has invalid "stretchX" value`))), p = !1), this._validateStretch(u.stretchY, m && m.height) || (this.fire(new a.j(new Error(`Image "${s}" has invalid "stretchY" value`))), p = !1), this._validateContent(u.content, u) || (this.fire(new a.j(new Error(`Image "${s}" has invalid "content" value`))), p = !1), p;
        }
        _validateStretch(s, u) {
          if (!s) return !0;
          let p = 0;
          for (const m of s) {
            if (m[0] < p || m[1] < m[0] || u < m[1]) return !1;
            p = m[1];
          }
          return !0;
        }
        _validateContent(s, u) {
          if (!s) return !0;
          if (s.length !== 4) return !1;
          const p = u.spriteData, m = p && p.width || u.data.width, x = p && p.height || u.data.height;
          return !(s[0] < 0 || m < s[0] || s[1] < 0 || x < s[1] || s[2] < 0 || m < s[2] || s[3] < 0 || x < s[3] || s[2] < s[0] || s[3] < s[1]);
        }
        updateImage(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
          const m = this.getImage(s);
          if (p && (m.data.width !== u.data.width || m.data.height !== u.data.height)) throw new Error(`size mismatch between old image (${m.data.width}x${m.data.height}) and new image (${u.data.width}x${u.data.height}).`);
          u.version = m.version + 1, this.images[s] = u, this.updatedImages[s] = !0;
        }
        removeImage(s) {
          const u = this.images[s];
          delete this.images[s], delete this.patterns[s], u.userImage && u.userImage.onRemove && u.userImage.onRemove();
        }
        listImages() {
          return Object.keys(this.images);
        }
        getImages(s) {
          return new Promise((u, p) => {
            let m = !0;
            if (!this.isLoaded()) for (const x of s) this.images[x] || (m = !1);
            this.isLoaded() || m ? u(this._getImagesForIds(s)) : this.requestors.push({ ids: s, promiseResolve: u });
          });
        }
        _getImagesForIds(s) {
          const u = {};
          for (const p of s) {
            let m = this.getImage(p);
            m || (this.fire(new a.k("styleimagemissing", { id: p })), m = this.getImage(p)), m ? u[p] = { data: m.data.clone(), pixelRatio: m.pixelRatio, sdf: m.sdf, version: m.version, stretchX: m.stretchX, stretchY: m.stretchY, content: m.content, textFitWidth: m.textFitWidth, textFitHeight: m.textFitHeight, hasRenderCallback: !!(m.userImage && m.userImage.render) } : a.w(`Image "${p}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
          }
          return u;
        }
        getPixelSize() {
          const { width: s, height: u } = this.atlasImage;
          return { width: s, height: u };
        }
        getPattern(s) {
          const u = this.patterns[s], p = this.getImage(s);
          if (!p) return null;
          if (u && u.position.version === p.version) return u.position;
          if (u) u.position.version = p.version;
          else {
            const m = { w: p.data.width + 2, h: p.data.height + 2, x: 0, y: 0 }, x = new a.I(m, p);
            this.patterns[s] = { bin: m, position: x };
          }
          return this._updatePatternAtlas(), this.patterns[s].position;
        }
        bind(s) {
          const u = s.gl;
          this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = !1) : this.atlasTexture = new me(s, this.atlasImage, u.RGBA), this.atlasTexture.bind(u.LINEAR, u.CLAMP_TO_EDGE);
        }
        _updatePatternAtlas() {
          const s = [];
          for (const x in this.patterns) s.push(this.patterns[x].bin);
          const { w: u, h: p } = a.p(s), m = this.atlasImage;
          m.resize({ width: u || 1, height: p || 1 });
          for (const x in this.patterns) {
            const { bin: E } = this.patterns[x], L = E.x + 1, B = E.y + 1, N = this.getImage(x).data, G = N.width, Z = N.height;
            a.R.copy(N, m, { x: 0, y: 0 }, { x: L, y: B }, { width: G, height: Z }), a.R.copy(N, m, { x: 0, y: Z - 1 }, { x: L, y: B - 1 }, { width: G, height: 1 }), a.R.copy(N, m, { x: 0, y: 0 }, { x: L, y: B + Z }, { width: G, height: 1 }), a.R.copy(N, m, { x: G - 1, y: 0 }, { x: L - 1, y: B }, { width: 1, height: Z }), a.R.copy(N, m, { x: 0, y: 0 }, { x: L + G, y: B }, { width: 1, height: Z });
          }
          this.dirty = !0;
        }
        beginFrame() {
          this.callbackDispatchedThisFrame = {};
        }
        dispatchRenderCallbacks(s) {
          for (const u of s) {
            if (this.callbackDispatchedThisFrame[u]) continue;
            this.callbackDispatchedThisFrame[u] = !0;
            const p = this.getImage(u);
            p || a.w(`Image with ID: "${u}" was not found`), Ge(p) && this.updateImage(u, p);
          }
        }
      }
      const pe = 1e20;
      function _e(b, s, u, p, m, x, E, L, B) {
        for (let N = s; N < s + p; N++) De(b, u * x + N, x, m, E, L, B);
        for (let N = u; N < u + m; N++) De(b, N * x + s, 1, p, E, L, B);
      }
      function De(b, s, u, p, m, x, E) {
        x[0] = 0, E[0] = -1e20, E[1] = pe, m[0] = b[s];
        for (let L = 1, B = 0, N = 0; L < p; L++) {
          m[L] = b[s + L * u];
          const G = L * L;
          do {
            const Z = x[B];
            N = (m[L] - m[Z] + G - Z * Z) / (L - Z) / 2;
          } while (N <= E[B] && --B > -1);
          B++, x[B] = L, E[B] = N, E[B + 1] = pe;
        }
        for (let L = 0, B = 0; L < p; L++) {
          for (; E[B + 1] < L; ) B++;
          const N = x[B], G = L - N;
          b[s + L * u] = m[N] + G * G;
        }
      }
      class Me {
        constructor(s, u) {
          this.requestManager = s, this.localIdeographFontFamily = u, this.entries = {};
        }
        setURL(s) {
          this.url = s;
        }
        getGlyphs(s) {
          return a._(this, void 0, void 0, function* () {
            const u = [];
            for (const x in s) for (const E of s[x]) u.push(this._getAndCacheGlyphsPromise(x, E));
            const p = yield Promise.all(u), m = {};
            for (const { stack: x, id: E, glyph: L } of p) m[x] || (m[x] = {}), m[x][E] = L && { id: L.id, bitmap: L.bitmap.clone(), metrics: L.metrics };
            return m;
          });
        }
        _getAndCacheGlyphsPromise(s, u) {
          return a._(this, void 0, void 0, function* () {
            let p = this.entries[s];
            p || (p = this.entries[s] = { glyphs: {}, requests: {}, ranges: {} });
            let m = p.glyphs[u];
            if (m !== void 0) return { stack: s, id: u, glyph: m };
            if (m = this._tinySDF(p, s, u), m) return p.glyphs[u] = m, { stack: s, id: u, glyph: m };
            const x = Math.floor(u / 256);
            if (256 * x > 65535) throw new Error("glyphs > 65535 not supported");
            if (p.ranges[x]) return { stack: s, id: u, glyph: m };
            if (!this.url) throw new Error("glyphsUrl is not set");
            if (!p.requests[x]) {
              const L = Me.loadGlyphRange(s, x, this.url, this.requestManager);
              p.requests[x] = L;
            }
            const E = yield p.requests[x];
            for (const L in E) this._doesCharSupportLocalGlyph(+L) || (p.glyphs[+L] = E[+L]);
            return p.ranges[x] = !0, { stack: s, id: u, glyph: E[u] || null };
          });
        }
        _doesCharSupportLocalGlyph(s) {
          return !!this.localIdeographFontFamily && (new RegExp("\\p{Ideo}|\\p{sc=Hang}|\\p{sc=Hira}|\\p{sc=Kana}", "u").test(String.fromCodePoint(s)) || a.u["CJK Unified Ideographs"](s) || a.u["Hangul Syllables"](s) || a.u.Hiragana(s) || a.u.Katakana(s) || a.u["CJK Symbols and Punctuation"](s) || a.u["Halfwidth and Fullwidth Forms"](s));
        }
        _tinySDF(s, u, p) {
          const m = this.localIdeographFontFamily;
          if (!m || !this._doesCharSupportLocalGlyph(p)) return;
          let x = s.tinySDF;
          if (!x) {
            let L = "400";
            /bold/i.test(u) ? L = "900" : /medium/i.test(u) ? L = "500" : /light/i.test(u) && (L = "200"), x = s.tinySDF = new Me.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: m, fontWeight: L });
          }
          const E = x.draw(String.fromCharCode(p));
          return { id: p, bitmap: new a.o({ width: E.width || 60, height: E.height || 60 }, E.data), metrics: { width: E.glyphWidth / 2 || 24, height: E.glyphHeight / 2 || 24, left: E.glyphLeft / 2 + 0.5 || 0, top: E.glyphTop / 2 - 27.5 || -8, advance: E.glyphAdvance / 2 || 24, isDoubleResolution: !0 } };
        }
      }
      Me.loadGlyphRange = function(b, s, u, p) {
        return a._(this, void 0, void 0, function* () {
          const m = 256 * s, x = m + 255, E = p.transformRequest(u.replace("{fontstack}", b).replace("{range}", `${m}-${x}`), "Glyphs"), L = yield a.l(E, new AbortController());
          if (!L || !L.data) throw new Error(`Could not load glyph range. range: ${s}, ${m}-${x}`);
          const B = {};
          for (const N of a.n(L.data)) B[N.id] = N;
          return B;
        });
      }, Me.TinySDF = class {
        constructor() {
          let { fontSize: b = 24, buffer: s = 3, radius: u = 8, cutoff: p = 0.25, fontFamily: m = "sans-serif", fontWeight: x = "normal", fontStyle: E = "normal" } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this.buffer = s, this.cutoff = p, this.radius = u;
          const L = this.size = b + 4 * s, B = this._createCanvas(L), N = this.ctx = B.getContext("2d", { willReadFrequently: !0 });
          N.font = `${E} ${x} ${b}px ${m}`, N.textBaseline = "alphabetic", N.textAlign = "left", N.fillStyle = "black", this.gridOuter = new Float64Array(L * L), this.gridInner = new Float64Array(L * L), this.f = new Float64Array(L), this.z = new Float64Array(L + 1), this.v = new Uint16Array(L);
        }
        _createCanvas(b) {
          const s = document.createElement("canvas");
          return s.width = s.height = b, s;
        }
        draw(b) {
          const { width: s, actualBoundingBoxAscent: u, actualBoundingBoxDescent: p, actualBoundingBoxLeft: m, actualBoundingBoxRight: x } = this.ctx.measureText(b), E = Math.ceil(u), L = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(x - m))), B = Math.min(this.size - this.buffer, E + Math.ceil(p)), N = L + 2 * this.buffer, G = B + 2 * this.buffer, Z = Math.max(N * G, 0), $ = new Uint8ClampedArray(Z), re = { data: $, width: N, height: G, glyphWidth: L, glyphHeight: B, glyphTop: E, glyphLeft: 0, glyphAdvance: s };
          if (L === 0 || B === 0) return re;
          const { ctx: ae, buffer: Pe, gridInner: Ce, gridOuter: Ie } = this;
          ae.clearRect(Pe, Pe, L, B), ae.fillText(b, Pe, Pe + E);
          const Be = ae.getImageData(Pe, Pe, L, B);
          Ie.fill(pe, 0, Z), Ce.fill(0, 0, Z);
          for (let He = 0; He < B; He++) for (let We = 0; We < L; We++) {
            const $e = Be.data[4 * (He * L + We) + 3] / 255;
            if ($e === 0) continue;
            const Je = (He + Pe) * N + We + Pe;
            if ($e === 1) Ie[Je] = 0, Ce[Je] = pe;
            else {
              const Qe = 0.5 - $e;
              Ie[Je] = Qe > 0 ? Qe * Qe : 0, Ce[Je] = Qe < 0 ? Qe * Qe : 0;
            }
          }
          _e(Ie, 0, 0, N, G, N, this.f, this.v, this.z), _e(Ce, Pe, Pe, L, B, N, this.f, this.v, this.z);
          for (let He = 0; He < Z; He++) {
            const We = Math.sqrt(Ie[He]) - Math.sqrt(Ce[He]);
            $[He] = Math.round(255 - 255 * (We / this.radius + this.cutoff));
          }
          return re;
        }
      };
      class St {
        constructor() {
          this.specification = a.v.light.position;
        }
        possiblyEvaluate(s, u) {
          return a.y(s.expression.evaluate(u));
        }
        interpolate(s, u, p) {
          return { x: a.z.number(s.x, u.x, p), y: a.z.number(s.y, u.y, p), z: a.z.number(s.z, u.z, p) };
        }
      }
      let dt;
      class Pt extends a.E {
        constructor(s) {
          super(), dt = dt || new a.q({ anchor: new a.D(a.v.light.anchor), position: new St(), color: new a.D(a.v.light.color), intensity: new a.D(a.v.light.intensity) }), this._transitionable = new a.T(dt), this.setLight(s), this._transitioning = this._transitionable.untransitioned();
        }
        getLight() {
          return this._transitionable.serialize();
        }
        setLight(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!this._validate(a.r, s, u)) for (const p in s) {
            const m = s[p];
            p.endsWith("-transition") ? this._transitionable.setTransition(p.slice(0, -11), m) : this._transitionable.setValue(p, m);
          }
        }
        updateTransitions(s) {
          this._transitioning = this._transitionable.transitioned(s, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(s) {
          this.properties = this._transitioning.possiblyEvaluate(s);
        }
        _validate(s, u, p) {
          return (!p || p.validate !== !1) && a.t(this, s.call(a.x, { value: u, style: { glyphs: !0, sprite: !0 }, styleSpec: a.v }));
        }
      }
      const gt = new a.q({ "sky-color": new a.D(a.v.sky["sky-color"]), "horizon-color": new a.D(a.v.sky["horizon-color"]), "fog-color": new a.D(a.v.sky["fog-color"]), "fog-ground-blend": new a.D(a.v.sky["fog-ground-blend"]), "horizon-fog-blend": new a.D(a.v.sky["horizon-fog-blend"]), "sky-horizon-blend": new a.D(a.v.sky["sky-horizon-blend"]), "atmosphere-blend": new a.D(a.v.sky["atmosphere-blend"]) });
      class Rt extends a.E {
        constructor(s) {
          super(), this._transitionable = new a.T(gt), this.setSky(s), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new a.B(0));
        }
        setSky(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!this._validate(a.C, s, u)) {
            s || (s = { "sky-color": "transparent", "horizon-color": "transparent", "fog-color": "transparent", "fog-ground-blend": 1, "atmosphere-blend": 0 });
            for (const p in s) {
              const m = s[p];
              p.endsWith("-transition") ? this._transitionable.setTransition(p.slice(0, -11), m) : this._transitionable.setValue(p, m);
            }
          }
        }
        getSky() {
          return this._transitionable.serialize();
        }
        updateTransitions(s) {
          this._transitioning = this._transitionable.transitioned(s, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition();
        }
        recalculate(s) {
          this.properties = this._transitioning.possiblyEvaluate(s);
        }
        _validate(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return (p == null ? void 0 : p.validate) !== !1 && a.t(this, s.call(a.x, a.e({ value: u, style: { glyphs: !0, sprite: !0 }, styleSpec: a.v })));
        }
        calculateFogBlendOpacity(s) {
          return s < 60 ? 0 : s < 70 ? (s - 60) / 10 : 1;
        }
      }
      class Ft {
        constructor(s, u) {
          this.width = s, this.height = u, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
        }
        getDash(s, u) {
          const p = s.join(",") + String(u);
          return this.dashEntry[p] || (this.dashEntry[p] = this.addDash(s, u)), this.dashEntry[p];
        }
        getDashRanges(s, u, p) {
          const m = [];
          let x = s.length % 2 == 1 ? -s[s.length - 1] * p : 0, E = s[0] * p, L = !0;
          m.push({ left: x, right: E, isDash: L, zeroLength: s[0] === 0 });
          let B = s[0];
          for (let N = 1; N < s.length; N++) {
            L = !L;
            const G = s[N];
            x = B * p, B += G, E = B * p, m.push({ left: x, right: E, isDash: L, zeroLength: G === 0 });
          }
          return m;
        }
        addRoundDash(s, u, p) {
          const m = u / 2;
          for (let x = -p; x <= p; x++) {
            const E = this.width * (this.nextRow + p + x);
            let L = 0, B = s[L];
            for (let N = 0; N < this.width; N++) {
              N / B.right > 1 && (B = s[++L]);
              const G = Math.abs(N - B.left), Z = Math.abs(N - B.right), $ = Math.min(G, Z);
              let re;
              const ae = x / p * (m + 1);
              if (B.isDash) {
                const Pe = m - Math.abs(ae);
                re = Math.sqrt($ * $ + Pe * Pe);
              } else re = m - Math.sqrt($ * $ + ae * ae);
              this.data[E + N] = Math.max(0, Math.min(255, re + 128));
            }
          }
        }
        addRegularDash(s) {
          for (let L = s.length - 1; L >= 0; --L) {
            const B = s[L], N = s[L + 1];
            B.zeroLength ? s.splice(L, 1) : N && N.isDash === B.isDash && (N.left = B.left, s.splice(L, 1));
          }
          const u = s[0], p = s[s.length - 1];
          u.isDash === p.isDash && (u.left = p.left - this.width, p.right = u.right + this.width);
          const m = this.width * this.nextRow;
          let x = 0, E = s[x];
          for (let L = 0; L < this.width; L++) {
            L / E.right > 1 && (E = s[++x]);
            const B = Math.abs(L - E.left), N = Math.abs(L - E.right), G = Math.min(B, N);
            this.data[m + L] = Math.max(0, Math.min(255, (E.isDash ? G : -G) + 128));
          }
        }
        addDash(s, u) {
          const p = u ? 7 : 0, m = 2 * p + 1;
          if (this.nextRow + m > this.height) return a.w("LineAtlas out of space"), null;
          let x = 0;
          for (let L = 0; L < s.length; L++) x += s[L];
          if (x !== 0) {
            const L = this.width / x, B = this.getDashRanges(s, this.width, L);
            u ? this.addRoundDash(B, L, p) : this.addRegularDash(B);
          }
          const E = { y: (this.nextRow + p + 0.5) / this.height, height: 2 * p / this.height, width: x };
          return this.nextRow += m, this.dirty = !0, E;
        }
        bind(s) {
          const u = s.gl;
          this.texture ? (u.bindTexture(u.TEXTURE_2D, this.texture), this.dirty && (this.dirty = !1, u.texSubImage2D(u.TEXTURE_2D, 0, 0, 0, this.width, this.height, u.ALPHA, u.UNSIGNED_BYTE, this.data))) : (this.texture = u.createTexture(), u.bindTexture(u.TEXTURE_2D, this.texture), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_S, u.REPEAT), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_WRAP_T, u.REPEAT), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MIN_FILTER, u.LINEAR), u.texParameteri(u.TEXTURE_2D, u.TEXTURE_MAG_FILTER, u.LINEAR), u.texImage2D(u.TEXTURE_2D, 0, u.ALPHA, this.width, this.height, 0, u.ALPHA, u.UNSIGNED_BYTE, this.data));
        }
      }
      const mn = "maplibre_preloaded_worker_pool";
      class oe {
        constructor() {
          this.active = {};
        }
        acquire(s) {
          if (!this.workers) for (this.workers = []; this.workers.length < oe.workerCount; ) this.workers.push(new Worker(a.a.WORKER_URL));
          return this.active[s] = !0, this.workers.slice();
        }
        release(s) {
          delete this.active[s], this.numActive() === 0 && (this.workers.forEach((u) => {
            u.terminate();
          }), this.workers = null);
        }
        isPreloaded() {
          return !!this.active[mn];
        }
        numActive() {
          return Object.keys(this.active).length;
        }
      }
      const Re = Math.floor(I.hardwareConcurrency / 2);
      let ze, Xe;
      function ot() {
        return ze || (ze = new oe()), ze;
      }
      oe.workerCount = a.F(globalThis) ? Math.max(Math.min(Re, 3), 1) : 1;
      class rt {
        constructor(s, u) {
          this.workerPool = s, this.actors = [], this.currentActor = 0, this.id = u;
          const p = this.workerPool.acquire(u);
          for (let m = 0; m < p.length; m++) {
            const x = new a.G(p[m], u);
            x.name = `Worker ${m}`, this.actors.push(x);
          }
          if (!this.actors.length) throw new Error("No actors found");
        }
        broadcast(s, u) {
          const p = [];
          for (const m of this.actors) p.push(m.sendAsync({ type: s, data: u }));
          return Promise.all(p);
        }
        getActor() {
          return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
        }
        remove() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          this.actors.forEach((u) => {
            u.remove();
          }), this.actors = [], s && this.workerPool.release(this.id);
        }
        registerMessageHandler(s, u) {
          for (const p of this.actors) p.registerMessageHandler(s, u);
        }
      }
      function xt() {
        return Xe || (Xe = new rt(ot(), a.H), Xe.registerMessageHandler("GR", (b, s, u) => a.m(s, u))), Xe;
      }
      function ht(b, s) {
        const u = a.J();
        return a.K(u, u, [1, 1, 0]), a.L(u, u, [0.5 * b.width, 0.5 * b.height, 1]), b.calculatePosMatrix ? a.M(u, u, b.calculatePosMatrix(s.toUnwrapped())) : u;
      }
      function $t(b, s, u, p, m, x) {
        var E;
        const L = function(Z, $, re) {
          if (Z) for (const ae of Z) {
            const Pe = $[ae];
            if (Pe && Pe.source === re && Pe.type === "fill-extrusion") return !0;
          }
          else for (const ae in $) {
            const Pe = $[ae];
            if (Pe.source === re && Pe.type === "fill-extrusion") return !0;
          }
          return !1;
        }((E = m == null ? void 0 : m.layers) !== null && E !== void 0 ? E : null, s, b.id), B = x.maxPitchScaleFactor(), N = b.tilesIn(p, B, L);
        N.sort(Wt);
        const G = [];
        for (const Z of N) G.push({ wrappedTileID: Z.tileID.wrapped().key, queryResults: Z.tile.queryRenderedFeatures(s, u, b._state, Z.queryGeometry, Z.cameraQueryGeometry, Z.scale, m, x, B, ht(b.transform, Z.tileID)) });
        return function(Z, $) {
          for (const re in Z) for (const ae of Z[re]) on(ae, $);
          return Z;
        }(function(Z) {
          const $ = {}, re = {};
          for (const ae of Z) {
            const Pe = ae.queryResults, Ce = ae.wrappedTileID, Ie = re[Ce] = re[Ce] || {};
            for (const Be in Pe) {
              const He = Pe[Be], We = Ie[Be] = Ie[Be] || {}, $e = $[Be] = $[Be] || [];
              for (const Je of He) We[Je.featureIndex] || (We[Je.featureIndex] = !0, $e.push(Je));
            }
          }
          return $;
        }(G), b);
      }
      function Wt(b, s) {
        const u = b.tileID, p = s.tileID;
        return u.overscaledZ - p.overscaledZ || u.canonical.y - p.canonical.y || u.wrap - p.wrap || u.canonical.x - p.canonical.x;
      }
      function on(b, s) {
        const u = b.feature, p = s.getFeatureState(u.layer["source-layer"], u.id);
        u.source = u.layer.source, u.layer["source-layer"] && (u.sourceLayer = u.layer["source-layer"]), u.state = p;
      }
      function hn(b, s, u) {
        return a._(this, void 0, void 0, function* () {
          let p = b;
          if (b.url ? p = (yield a.h(s.transformRequest(b.url, "Source"), u)).data : yield I.frameAsync(u), !p) return null;
          const m = a.N(a.e(p, b), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
          return "vector_layers" in p && p.vector_layers && (m.vectorLayerIds = p.vector_layers.map((x) => x.id)), m;
        });
      }
      class wn {
        constructor(s, u) {
          s && (u ? this.setSouthWest(s).setNorthEast(u) : Array.isArray(s) && (s.length === 4 ? this.setSouthWest([s[0], s[1]]).setNorthEast([s[2], s[3]]) : this.setSouthWest(s[0]).setNorthEast(s[1])));
        }
        setNorthEast(s) {
          return this._ne = s instanceof a.O ? new a.O(s.lng, s.lat) : a.O.convert(s), this;
        }
        setSouthWest(s) {
          return this._sw = s instanceof a.O ? new a.O(s.lng, s.lat) : a.O.convert(s), this;
        }
        extend(s) {
          const u = this._sw, p = this._ne;
          let m, x;
          if (s instanceof a.O) m = s, x = s;
          else {
            if (!(s instanceof wn)) return Array.isArray(s) ? s.length === 4 || s.every(Array.isArray) ? this.extend(wn.convert(s)) : this.extend(a.O.convert(s)) : s && ("lng" in s || "lon" in s) && "lat" in s ? this.extend(a.O.convert(s)) : this;
            if (m = s._sw, x = s._ne, !m || !x) return this;
          }
          return u || p ? (u.lng = Math.min(m.lng, u.lng), u.lat = Math.min(m.lat, u.lat), p.lng = Math.max(x.lng, p.lng), p.lat = Math.max(x.lat, p.lat)) : (this._sw = new a.O(m.lng, m.lat), this._ne = new a.O(x.lng, x.lat)), this;
        }
        getCenter() {
          return new a.O((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
        }
        getSouthWest() {
          return this._sw;
        }
        getNorthEast() {
          return this._ne;
        }
        getNorthWest() {
          return new a.O(this.getWest(), this.getNorth());
        }
        getSouthEast() {
          return new a.O(this.getEast(), this.getSouth());
        }
        getWest() {
          return this._sw.lng;
        }
        getSouth() {
          return this._sw.lat;
        }
        getEast() {
          return this._ne.lng;
        }
        getNorth() {
          return this._ne.lat;
        }
        toArray() {
          return [this._sw.toArray(), this._ne.toArray()];
        }
        toString() {
          return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
        }
        isEmpty() {
          return !(this._sw && this._ne);
        }
        contains(s) {
          const { lng: u, lat: p } = a.O.convert(s);
          let m = this._sw.lng <= u && u <= this._ne.lng;
          return this._sw.lng > this._ne.lng && (m = this._sw.lng >= u && u >= this._ne.lng), this._sw.lat <= p && p <= this._ne.lat && m;
        }
        static convert(s) {
          return s instanceof wn ? s : s && new wn(s);
        }
        static fromLngLat(s) {
          const p = 360 * (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0) / 40075017, m = p / Math.cos(Math.PI / 180 * s.lat);
          return new wn(new a.O(s.lng - m, s.lat - p), new a.O(s.lng + m, s.lat + p));
        }
        adjustAntiMeridian() {
          const s = new a.O(this._sw.lng, this._sw.lat), u = new a.O(this._ne.lng, this._ne.lat);
          return new wn(s, s.lng > u.lng ? new a.O(u.lng + 360, u.lat) : u);
        }
      }
      class Bt {
        constructor(s, u, p) {
          this.bounds = wn.convert(this.validateBounds(s)), this.minzoom = u || 0, this.maxzoom = p || 24;
        }
        validateBounds(s) {
          return Array.isArray(s) && s.length === 4 ? [Math.max(-180, s[0]), Math.max(-90, s[1]), Math.min(180, s[2]), Math.min(90, s[3])] : [-180, -90, 180, 90];
        }
        contains(s) {
          const u = Math.pow(2, s.z), p = Math.floor(a.S(this.bounds.getWest()) * u), m = Math.floor(a.Q(this.bounds.getNorth()) * u), x = Math.ceil(a.S(this.bounds.getEast()) * u), E = Math.ceil(a.Q(this.bounds.getSouth()) * u);
          return s.x >= p && s.x < x && s.y >= m && s.y < E;
        }
      }
      class Ue extends a.E {
        constructor(s, u, p, m) {
          if (super(), this.id = s, this.dispatcher = p, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = !0, this.isTileClipped = !0, this._loaded = !1, a.e(this, a.N(u, ["url", "scheme", "tileSize", "promoteId"])), this._options = a.e({ type: "vector" }, u), this._collectResourceTiming = u.collectResourceTiming, this.tileSize !== 512) throw new Error("vector tile sources must have a tileSize of 512");
          this.setEventedParent(m);
        }
        load() {
          return a._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new a.k("dataloading", { dataType: "source" })), this._tileJSONRequest = new AbortController();
            try {
              const s = yield hn(this._options, this.map._requestManager, this._tileJSONRequest);
              this._tileJSONRequest = null, this._loaded = !0, this.map.style.sourceCaches[this.id].clearTiles(), s && (a.e(this, s), s.bounds && (this.tileBounds = new Bt(s.bounds, this.minzoom, this.maxzoom)), this.fire(new a.k("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new a.k("data", { dataType: "source", sourceDataType: "content" })));
            } catch (s) {
              this._tileJSONRequest = null, this.fire(new a.j(s));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        hasTile(s) {
          return !this.tileBounds || this.tileBounds.contains(s.canonical);
        }
        onAdd(s) {
          this.map = s, this.load();
        }
        setSourceProperty(s) {
          this._tileJSONRequest && this._tileJSONRequest.abort(), s(), this.load();
        }
        setTiles(s) {
          return this.setSourceProperty(() => {
            this._options.tiles = s;
          }), this;
        }
        setUrl(s) {
          return this.setSourceProperty(() => {
            this.url = s, this._options.url = s;
          }), this;
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        serialize() {
          return a.e({}, this._options);
        }
        loadTile(s) {
          return a._(this, void 0, void 0, function* () {
            const u = s.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), p = { request: this.map._requestManager.transformRequest(u, "Tile"), uid: s.uid, tileID: s.tileID, zoom: s.tileID.overscaledZ, tileSize: this.tileSize * s.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
            p.request.collectResourceTiming = this._collectResourceTiming;
            let m = "RT";
            if (s.actor && s.state !== "expired") {
              if (s.state === "loading") return new Promise((x, E) => {
                s.reloadPromise = { resolve: x, reject: E };
              });
            } else s.actor = this.dispatcher.getActor(), m = "LT";
            s.abortController = new AbortController();
            try {
              const x = yield s.actor.sendAsync({ type: m, data: p }, s.abortController);
              if (delete s.abortController, s.aborted) return;
              this._afterTileLoadWorkerResponse(s, x);
            } catch (x) {
              if (delete s.abortController, s.aborted) return;
              if (x && x.status !== 404) throw x;
              this._afterTileLoadWorkerResponse(s, null);
            }
          });
        }
        _afterTileLoadWorkerResponse(s, u) {
          if (u && u.resourceTiming && (s.resourceTiming = u.resourceTiming), u && this.map._refreshExpiredTiles && s.setExpiryData(u), s.loadVectorData(u, this.map.painter), s.reloadPromise) {
            const p = s.reloadPromise;
            s.reloadPromise = null, this.loadTile(s).then(p.resolve).catch(p.reject);
          }
        }
        abortTile(s) {
          return a._(this, void 0, void 0, function* () {
            s.abortController && (s.abortController.abort(), delete s.abortController), s.actor && (yield s.actor.sendAsync({ type: "AT", data: { uid: s.uid, type: this.type, source: this.id } }));
          });
        }
        unloadTile(s) {
          return a._(this, void 0, void 0, function* () {
            s.unloadVectorData(), s.actor && (yield s.actor.sendAsync({ type: "RMT", data: { uid: s.uid, type: this.type, source: this.id } }));
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class On extends a.E {
        constructor(s, u, p, m) {
          super(), this.id = s, this.dispatcher = p, this.setEventedParent(m), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = !0, this.scheme = "xyz", this.tileSize = 512, this._loaded = !1, this._options = a.e({ type: "raster" }, u), a.e(this, a.N(u, ["url", "scheme", "tileSize"]));
        }
        load() {
          return a._(this, arguments, void 0, function() {
            var s = this;
            let u = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
            return function* () {
              s._loaded = !1, s.fire(new a.k("dataloading", { dataType: "source" })), s._tileJSONRequest = new AbortController();
              try {
                const p = yield hn(s._options, s.map._requestManager, s._tileJSONRequest);
                s._tileJSONRequest = null, s._loaded = !0, p && (a.e(s, p), p.bounds && (s.tileBounds = new Bt(p.bounds, s.minzoom, s.maxzoom)), s.fire(new a.k("data", { dataType: "source", sourceDataType: "metadata" })), s.fire(new a.k("data", { dataType: "source", sourceDataType: "content", sourceDataChanged: u })));
              } catch (p) {
                s._tileJSONRequest = null, s.fire(new a.j(p));
              }
            }();
          });
        }
        loaded() {
          return this._loaded;
        }
        onAdd(s) {
          this.map = s, this.load();
        }
        onRemove() {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null);
        }
        setSourceProperty(s) {
          this._tileJSONRequest && (this._tileJSONRequest.abort(), this._tileJSONRequest = null), s(), this.load(!0);
        }
        setTiles(s) {
          return this.setSourceProperty(() => {
            this._options.tiles = s;
          }), this;
        }
        setUrl(s) {
          return this.setSourceProperty(() => {
            this.url = s, this._options.url = s;
          }), this;
        }
        serialize() {
          return a.e({}, this._options);
        }
        hasTile(s) {
          return !this.tileBounds || this.tileBounds.contains(s.canonical);
        }
        loadTile(s) {
          return a._(this, void 0, void 0, function* () {
            const u = s.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
            s.abortController = new AbortController();
            try {
              const p = yield ie.getImage(this.map._requestManager.transformRequest(u, "Tile"), s.abortController, this.map._refreshExpiredTiles);
              if (delete s.abortController, s.aborted) return void (s.state = "unloaded");
              if (p && p.data) {
                this.map._refreshExpiredTiles && p.cacheControl && p.expires && s.setExpiryData({ cacheControl: p.cacheControl, expires: p.expires });
                const m = this.map.painter.context, x = m.gl, E = p.data;
                s.texture = this.map.painter.getTileTexture(E.width), s.texture ? s.texture.update(E, { useMipmap: !0 }) : (s.texture = new me(m, E, x.RGBA, { useMipmap: !0 }), s.texture.bind(x.LINEAR, x.CLAMP_TO_EDGE, x.LINEAR_MIPMAP_NEAREST)), s.state = "loaded";
              }
            } catch (p) {
              if (delete s.abortController, s.aborted) s.state = "unloaded";
              else if (p) throw s.state = "errored", p;
            }
          });
        }
        abortTile(s) {
          return a._(this, void 0, void 0, function* () {
            s.abortController && (s.abortController.abort(), delete s.abortController);
          });
        }
        unloadTile(s) {
          return a._(this, void 0, void 0, function* () {
            s.texture && this.map.painter.saveTileTexture(s.texture);
          });
        }
        hasTransition() {
          return !1;
        }
      }
      class Sn extends On {
        constructor(s, u, p, m) {
          super(s, u, p, m), this.type = "raster-dem", this.maxzoom = 22, this._options = a.e({ type: "raster-dem" }, u), this.encoding = u.encoding || "mapbox", this.redFactor = u.redFactor, this.greenFactor = u.greenFactor, this.blueFactor = u.blueFactor, this.baseShift = u.baseShift;
        }
        loadTile(s) {
          return a._(this, void 0, void 0, function* () {
            const u = s.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), p = this.map._requestManager.transformRequest(u, "Tile");
            s.neighboringTiles = this._getNeighboringTiles(s.tileID), s.abortController = new AbortController();
            try {
              const m = yield ie.getImage(p, s.abortController, this.map._refreshExpiredTiles);
              if (delete s.abortController, s.aborted) return void (s.state = "unloaded");
              if (m && m.data) {
                const x = m.data;
                this.map._refreshExpiredTiles && m.cacheControl && m.expires && s.setExpiryData({ cacheControl: m.cacheControl, expires: m.expires });
                const E = a.b(x) && a.U() ? x : yield this.readImageNow(x), L = { type: this.type, uid: s.uid, source: this.id, rawImageData: E, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                if (!s.actor || s.state === "expired") {
                  s.actor = this.dispatcher.getActor();
                  const B = yield s.actor.sendAsync({ type: "LDT", data: L });
                  s.dem = B, s.needsHillshadePrepare = !0, s.needsTerrainPrepare = !0, s.state = "loaded";
                }
              }
            } catch (m) {
              if (delete s.abortController, s.aborted) s.state = "unloaded";
              else if (m) throw s.state = "errored", m;
            }
          });
        }
        readImageNow(s) {
          return a._(this, void 0, void 0, function* () {
            if (typeof VideoFrame < "u" && a.V()) {
              const u = s.width + 2, p = s.height + 2;
              try {
                return new a.R({ width: u, height: p }, yield a.W(s, -1, -1, u, p));
              } catch {
              }
            }
            return I.getImageData(s, 1);
          });
        }
        _getNeighboringTiles(s) {
          const u = s.canonical, p = Math.pow(2, u.z), m = (u.x - 1 + p) % p, x = u.x === 0 ? s.wrap - 1 : s.wrap, E = (u.x + 1 + p) % p, L = u.x + 1 === p ? s.wrap + 1 : s.wrap, B = {};
          return B[new a.X(s.overscaledZ, x, u.z, m, u.y).key] = { backfilled: !1 }, B[new a.X(s.overscaledZ, L, u.z, E, u.y).key] = { backfilled: !1 }, u.y > 0 && (B[new a.X(s.overscaledZ, x, u.z, m, u.y - 1).key] = { backfilled: !1 }, B[new a.X(s.overscaledZ, s.wrap, u.z, u.x, u.y - 1).key] = { backfilled: !1 }, B[new a.X(s.overscaledZ, L, u.z, E, u.y - 1).key] = { backfilled: !1 }), u.y + 1 < p && (B[new a.X(s.overscaledZ, x, u.z, m, u.y + 1).key] = { backfilled: !1 }, B[new a.X(s.overscaledZ, s.wrap, u.z, u.x, u.y + 1).key] = { backfilled: !1 }, B[new a.X(s.overscaledZ, L, u.z, E, u.y + 1).key] = { backfilled: !1 }), B;
        }
        unloadTile(s) {
          return a._(this, void 0, void 0, function* () {
            s.demTexture && this.map.painter.saveTileTexture(s.demTexture), s.fbo && (s.fbo.destroy(), delete s.fbo), s.dem && delete s.dem, delete s.neighboringTiles, s.state = "unloaded", s.actor && (yield s.actor.sendAsync({ type: "RDT", data: { type: this.type, uid: s.uid, source: this.id } }));
          });
        }
      }
      class en extends a.E {
        constructor(s, u, p, m) {
          super(), this.id = s, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = !0, this.reparseOverscaled = !0, this._removed = !1, this._pendingLoads = 0, this.actor = p.getActor(), this.setEventedParent(m), this._data = u.data, this._options = a.e({}, u), this._collectResourceTiming = u.collectResourceTiming, u.maxzoom !== void 0 && (this.maxzoom = u.maxzoom), u.type && (this.type = u.type), u.attribution && (this.attribution = u.attribution), this.promoteId = u.promoteId, u.clusterMaxZoom !== void 0 && this.maxzoom <= u.clusterMaxZoom && a.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${u.clusterMaxZoom}".`), this.workerOptions = a.e({ source: this.id, cluster: u.cluster || !1, geojsonVtOptions: { buffer: this._pixelsToTileUnits(u.buffer !== void 0 ? u.buffer : 128), tolerance: this._pixelsToTileUnits(u.tolerance !== void 0 ? u.tolerance : 0.375), extent: a.Y, maxZoom: this.maxzoom, lineMetrics: u.lineMetrics || !1, generateId: u.generateId || !1 }, superclusterOptions: { maxZoom: u.clusterMaxZoom !== void 0 ? u.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, u.clusterMinPoints || 2), extent: a.Y, radius: this._pixelsToTileUnits(u.clusterRadius || 50), log: !1, generateId: u.generateId || !1 }, clusterProperties: u.clusterProperties, filter: u.filter }, u.workerOptions), typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId);
        }
        _pixelsToTileUnits(s) {
          return s * (a.Y / this.tileSize);
        }
        load() {
          return a._(this, void 0, void 0, function* () {
            yield this._updateWorkerData();
          });
        }
        onAdd(s) {
          this.map = s, this.load();
        }
        setData(s) {
          return this._data = s, this._updateWorkerData(), this;
        }
        updateData(s) {
          return this._updateWorkerData(s), this;
        }
        getData() {
          return a._(this, void 0, void 0, function* () {
            const s = a.e({ type: this.type }, this.workerOptions);
            return this.actor.sendAsync({ type: "GD", data: s });
          });
        }
        setClusterOptions(s) {
          return this.workerOptions.cluster = s.cluster, s && (s.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(s.clusterRadius)), s.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = s.clusterMaxZoom)), this._updateWorkerData(), this;
        }
        getClusterExpansionZoom(s) {
          return this.actor.sendAsync({ type: "GCEZ", data: { type: this.type, clusterId: s, source: this.id } });
        }
        getClusterChildren(s) {
          return this.actor.sendAsync({ type: "GCC", data: { type: this.type, clusterId: s, source: this.id } });
        }
        getClusterLeaves(s, u, p) {
          return this.actor.sendAsync({ type: "GCL", data: { type: this.type, source: this.id, clusterId: s, limit: u, offset: p } });
        }
        _updateWorkerData(s) {
          return a._(this, void 0, void 0, function* () {
            const u = a.e({ type: this.type }, this.workerOptions);
            s ? u.dataDiff = s : typeof this._data == "string" ? (u.request = this.map._requestManager.transformRequest(I.resolveURL(this._data), "Source"), u.request.collectResourceTiming = this._collectResourceTiming) : u.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new a.k("dataloading", { dataType: "source" }));
            try {
              const p = yield this.actor.sendAsync({ type: "LD", data: u });
              if (this._pendingLoads--, this._removed || p.abandoned) return void this.fire(new a.k("dataabort", { dataType: "source" }));
              let m = null;
              p.resourceTiming && p.resourceTiming[this.id] && (m = p.resourceTiming[this.id].slice(0));
              const x = { dataType: "source" };
              this._collectResourceTiming && m && m.length > 0 && a.e(x, { resourceTiming: m }), this.fire(new a.k("data", Object.assign(Object.assign({}, x), { sourceDataType: "metadata" }))), this.fire(new a.k("data", Object.assign(Object.assign({}, x), { sourceDataType: "content" })));
            } catch (p) {
              if (this._pendingLoads--, this._removed) return void this.fire(new a.k("dataabort", { dataType: "source" }));
              this.fire(new a.j(p));
            }
          });
        }
        loaded() {
          return this._pendingLoads === 0;
        }
        loadTile(s) {
          return a._(this, void 0, void 0, function* () {
            const u = s.actor ? "RT" : "LT";
            s.actor = this.actor;
            const p = { type: this.type, uid: s.uid, tileID: s.tileID, zoom: s.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, subdivisionGranularity: this.map.style.projection.subdivisionGranularity };
            s.abortController = new AbortController();
            const m = yield this.actor.sendAsync({ type: u, data: p }, s.abortController);
            delete s.abortController, s.unloadVectorData(), s.aborted || s.loadVectorData(m, this.map.painter, u === "RT");
          });
        }
        abortTile(s) {
          return a._(this, void 0, void 0, function* () {
            s.abortController && (s.abortController.abort(), delete s.abortController), s.aborted = !0;
          });
        }
        unloadTile(s) {
          return a._(this, void 0, void 0, function* () {
            s.unloadVectorData(), yield this.actor.sendAsync({ type: "RMT", data: { uid: s.uid, type: this.type, source: this.id } });
          });
        }
        onRemove() {
          this._removed = !0, this.actor.sendAsync({ type: "RS", data: { type: this.type, source: this.id } });
        }
        serialize() {
          return a.e({}, this._options, { type: this.type, data: this._data });
        }
        hasTransition() {
          return !1;
        }
      }
      class ln extends a.E {
        constructor(s, u, p, m) {
          super(), this.flippedWindingOrder = !1, this.id = s, this.dispatcher = p, this.coordinates = u.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = !1, this.setEventedParent(m), this.options = u;
        }
        load(s) {
          return a._(this, void 0, void 0, function* () {
            this._loaded = !1, this.fire(new a.k("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = new AbortController();
            try {
              const u = yield ie.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
              this._request = null, this._loaded = !0, u && u.data && (this.image = u.data, s && (this.coordinates = s), this._finishLoading());
            } catch (u) {
              this._request = null, this._loaded = !0, this.fire(new a.j(u));
            }
          });
        }
        loaded() {
          return this._loaded;
        }
        updateImage(s) {
          return s.url ? (this._request && (this._request.abort(), this._request = null), this.options.url = s.url, this.load(s.coordinates).finally(() => {
            this.texture = null;
          }), this) : this;
        }
        _finishLoading() {
          this.map && (this.setCoordinates(this.coordinates), this.fire(new a.k("data", { dataType: "source", sourceDataType: "metadata" })));
        }
        onAdd(s) {
          this.map = s, this.load();
        }
        onRemove() {
          this._request && (this._request.abort(), this._request = null);
        }
        setCoordinates(s) {
          this.coordinates = s;
          const u = s.map(a.Z.fromLngLat);
          var p;
          return this.tileID = function(m) {
            let x = 1 / 0, E = 1 / 0, L = -1 / 0, B = -1 / 0;
            for (const $ of m) x = Math.min(x, $.x), E = Math.min(E, $.y), L = Math.max(L, $.x), B = Math.max(B, $.y);
            const N = Math.max(L - x, B - E), G = Math.max(0, Math.floor(-Math.log(N) / Math.LN2)), Z = Math.pow(2, G);
            return new a.$(G, Math.floor((x + L) / 2 * Z), Math.floor((E + B) / 2 * Z));
          }(u), this.minzoom = this.maxzoom = this.tileID.z, this.tileCoords = u.map((m) => this.tileID.getTilePoint(m)._round()), this.flippedWindingOrder = ((p = this.tileCoords)[1].x - p[0].x) * (p[2].y - p[0].y) - (p[1].y - p[0].y) * (p[2].x - p[0].x) < 0, this.fire(new a.k("data", { dataType: "source", sourceDataType: "content" })), this;
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || !this.image) return;
          const s = this.map.painter.context, u = s.gl;
          this.texture || (this.texture = new me(s, this.image, u.RGBA), this.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE));
          let p = !1;
          for (const m in this.tiles) {
            const x = this.tiles[m];
            x.state !== "loaded" && (x.state = "loaded", x.texture = this.texture, p = !0);
          }
          p && this.fire(new a.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        loadTile(s) {
          return a._(this, void 0, void 0, function* () {
            this.tileID && this.tileID.equals(s.tileID.canonical) ? (this.tiles[String(s.tileID.wrap)] = s, s.buckets = {}) : s.state = "errored";
          });
        }
        serialize() {
          return { type: "image", url: this.options.url, coordinates: this.coordinates };
        }
        hasTransition() {
          return !1;
        }
      }
      class un extends ln {
        constructor(s, u, p, m) {
          super(s, u, p, m), this.roundZoom = !0, this.type = "video", this.options = u;
        }
        load() {
          return a._(this, void 0, void 0, function* () {
            this._loaded = !1;
            const s = this.options;
            this.urls = [];
            for (const u of s.urls) this.urls.push(this.map._requestManager.transformRequest(u, "Source").url);
            try {
              const u = yield a.a0(this.urls);
              if (this._loaded = !0, !u) return;
              this.video = u, this.video.loop = !0, this.video.addEventListener("playing", () => {
                this.map.triggerRepaint();
              }), this.map && this.video.play(), this._finishLoading();
            } catch (u) {
              this.fire(new a.j(u));
            }
          });
        }
        pause() {
          this.video && this.video.pause();
        }
        play() {
          this.video && this.video.play();
        }
        seek(s) {
          if (this.video) {
            const u = this.video.seekable;
            s < u.start(0) || s > u.end(0) ? this.fire(new a.j(new a.a1(`sources.${this.id}`, null, `Playback for this video can be set only between the ${u.start(0)} and ${u.end(0)}-second mark.`))) : this.video.currentTime = s;
          }
        }
        getVideo() {
          return this.video;
        }
        onAdd(s) {
          this.map || (this.map = s, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
        }
        prepare() {
          if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2) return;
          const s = this.map.painter.context, u = s.gl;
          this.texture ? this.video.paused || (this.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE), u.texSubImage2D(u.TEXTURE_2D, 0, 0, 0, u.RGBA, u.UNSIGNED_BYTE, this.video)) : (this.texture = new me(s, this.video, u.RGBA), this.texture.bind(u.LINEAR, u.CLAMP_TO_EDGE));
          let p = !1;
          for (const m in this.tiles) {
            const x = this.tiles[m];
            x.state !== "loaded" && (x.state = "loaded", x.texture = this.texture, p = !0);
          }
          p && this.fire(new a.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "video", urls: this.urls, coordinates: this.coordinates };
        }
        hasTransition() {
          return this.video && !this.video.paused;
        }
      }
      class _n extends ln {
        constructor(s, u, p, m) {
          super(s, u, p, m), u.coordinates ? Array.isArray(u.coordinates) && u.coordinates.length === 4 && !u.coordinates.some((x) => !Array.isArray(x) || x.length !== 2 || x.some((E) => typeof E != "number")) || this.fire(new a.j(new a.a1(`sources.${s}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new a.j(new a.a1(`sources.${s}`, null, 'missing required property "coordinates"'))), u.animate && typeof u.animate != "boolean" && this.fire(new a.j(new a.a1(`sources.${s}`, null, 'optional "animate" property must be a boolean value'))), u.canvas ? typeof u.canvas == "string" || u.canvas instanceof HTMLCanvasElement || this.fire(new a.j(new a.a1(`sources.${s}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new a.j(new a.a1(`sources.${s}`, null, 'missing required property "canvas"'))), this.options = u, this.animate = u.animate === void 0 || u.animate;
        }
        load() {
          return a._(this, void 0, void 0, function* () {
            this._loaded = !0, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new a.j(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
              this._playing = !0, this.map.triggerRepaint();
            }, this.pause = function() {
              this._playing && (this.prepare(), this._playing = !1);
            }, this._finishLoading());
          });
        }
        getCanvas() {
          return this.canvas;
        }
        onAdd(s) {
          this.map = s, this.load(), this.canvas && this.animate && this.play();
        }
        onRemove() {
          this.pause();
        }
        prepare() {
          let s = !1;
          if (this.canvas.width !== this.width && (this.width = this.canvas.width, s = !0), this.canvas.height !== this.height && (this.height = this.canvas.height, s = !0), this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0) return;
          const u = this.map.painter.context, p = u.gl;
          this.texture ? (s || this._playing) && this.texture.update(this.canvas, { premultiply: !0 }) : this.texture = new me(u, this.canvas, p.RGBA, { premultiply: !0 });
          let m = !1;
          for (const x in this.tiles) {
            const E = this.tiles[x];
            E.state !== "loaded" && (E.state = "loaded", E.texture = this.texture, m = !0);
          }
          m && this.fire(new a.k("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
        }
        serialize() {
          return { type: "canvas", coordinates: this.coordinates };
        }
        hasTransition() {
          return this._playing;
        }
        _hasInvalidDimensions() {
          for (const s of [this.canvas.width, this.canvas.height]) if (isNaN(s) || s <= 0) return !0;
          return !1;
        }
      }
      const Mn = {}, Wn = (b) => {
        switch (b) {
          case "geojson":
            return en;
          case "image":
            return ln;
          case "raster":
            return On;
          case "raster-dem":
            return Sn;
          case "vector":
            return Ue;
          case "video":
            return un;
          case "canvas":
            return _n;
        }
        return Mn[b];
      }, $n = "RTLPluginLoaded";
      class Yn extends a.E {
        constructor() {
          super(...arguments), this.status = "unavailable", this.url = null, this.dispatcher = xt();
        }
        _syncState(s) {
          return this.status = s, this.dispatcher.broadcast("SRPS", { pluginStatus: s, pluginURL: this.url }).catch((u) => {
            throw this.status = "error", u;
          });
        }
        getRTLTextPluginStatus() {
          return this.status;
        }
        clearRTLTextPlugin() {
          this.status = "unavailable", this.url = null;
        }
        setRTLTextPlugin(s) {
          return a._(this, arguments, void 0, function(u) {
            var p = this;
            let m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
            return function* () {
              if (p.url) throw new Error("setRTLTextPlugin cannot be called multiple times.");
              if (p.url = I.resolveURL(u), !p.url) throw new Error(`requested url ${u} is invalid`);
              if (p.status === "unavailable") {
                if (!m) return p._requestImport();
                p.status = "deferred", p._syncState(p.status);
              } else if (p.status === "requested") return p._requestImport();
            }();
          });
        }
        _requestImport() {
          return a._(this, void 0, void 0, function* () {
            yield this._syncState("loading"), this.status = "loaded", this.fire(new a.k($n));
          });
        }
        lazyLoad() {
          this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport();
        }
      }
      let si = null;
      function fi() {
        return si || (si = new Yn()), si;
      }
      class Un {
        constructor(s, u) {
          this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = s, this.uid = a.a2(), this.uses = 0, this.tileSize = u, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = !1, this.hasRTLText = !1, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
        }
        registerFadeDuration(s) {
          const u = s + this.timeAdded;
          u < this.fadeEndTime || (this.fadeEndTime = u);
        }
        wasRequested() {
          return this.state === "errored" || this.state === "loaded" || this.state === "reloading";
        }
        clearTextures(s) {
          this.demTexture && s.saveTileTexture(this.demTexture), this.demTexture = null;
        }
        loadVectorData(s, u, p) {
          if (this.hasData() && this.unloadVectorData(), this.state = "loaded", s) {
            s.featureIndex && (this.latestFeatureIndex = s.featureIndex, s.rawTileData ? (this.latestRawTileData = s.rawTileData, this.latestFeatureIndex.rawTileData = s.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = s.collisionBoxArray, this.buckets = function(m, x) {
              const E = {};
              if (!x) return E;
              for (const L of m) {
                const B = L.layerIds.map((N) => x.getLayer(N)).filter(Boolean);
                if (B.length !== 0) {
                  L.layers = B, L.stateDependentLayerIds && (L.stateDependentLayers = L.stateDependentLayerIds.map((N) => B.filter((G) => G.id === N)[0]));
                  for (const N of B) E[N.id] = L;
                }
              }
              return E;
            }(s.buckets, u == null ? void 0 : u.style), this.hasSymbolBuckets = !1;
            for (const m in this.buckets) {
              const x = this.buckets[m];
              if (x instanceof a.a4) {
                if (this.hasSymbolBuckets = !0, !p) break;
                x.justReloaded = !0;
              }
            }
            if (this.hasRTLText = !1, this.hasSymbolBuckets) for (const m in this.buckets) {
              const x = this.buckets[m];
              if (x instanceof a.a4 && x.hasRTLText) {
                this.hasRTLText = !0, fi().lazyLoad();
                break;
              }
            }
            this.queryPadding = 0;
            for (const m in this.buckets) {
              const x = this.buckets[m];
              this.queryPadding = Math.max(this.queryPadding, u.style.getLayer(m).queryRadius(x));
            }
            s.imageAtlas && (this.imageAtlas = s.imageAtlas), s.glyphAtlasImage && (this.glyphAtlasImage = s.glyphAtlasImage);
          } else this.collisionBoxArray = new a.a3();
        }
        unloadVectorData() {
          for (const s in this.buckets) this.buckets[s].destroy();
          this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
        }
        getBucket(s) {
          return this.buckets[s.id];
        }
        upload(s) {
          for (const p in this.buckets) {
            const m = this.buckets[p];
            m.uploadPending() && m.upload(s);
          }
          const u = s.gl;
          this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new me(s, this.imageAtlas.image, u.RGBA), this.imageAtlas.uploaded = !0), this.glyphAtlasImage && (this.glyphAtlasTexture = new me(s, this.glyphAtlasImage, u.ALPHA), this.glyphAtlasImage = null);
        }
        prepare(s) {
          this.imageAtlas && this.imageAtlas.patchUpdatedImages(s, this.imageAtlasTexture);
        }
        queryRenderedFeatures(s, u, p, m, x, E, L, B, N, G) {
          return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: m, cameraQueryGeometry: x, scale: E, tileSize: this.tileSize, pixelPosMatrix: G, transform: B, params: L, queryPadding: this.queryPadding * N }, s, u, p) : {};
        }
        querySourceFeatures(s, u) {
          const p = this.latestFeatureIndex;
          if (!p || !p.rawTileData) return;
          const m = p.loadVTLayers(), x = u && u.sourceLayer ? u.sourceLayer : "", E = m._geojsonTileLayer || m[x];
          if (!E) return;
          const L = a.a5(u && u.filter), { z: B, x: N, y: G } = this.tileID.canonical, Z = { z: B, x: N, y: G };
          for (let $ = 0; $ < E.length; $++) {
            const re = E.feature($);
            if (L.needGeometry) {
              const Ce = a.a6(re, !0);
              if (!L.filter(new a.B(this.tileID.overscaledZ), Ce, this.tileID.canonical)) continue;
            } else if (!L.filter(new a.B(this.tileID.overscaledZ), re)) continue;
            const ae = p.getId(re, x), Pe = new a.a7(re, B, N, G, ae);
            Pe.tile = Z, s.push(Pe);
          }
        }
        hasData() {
          return this.state === "loaded" || this.state === "reloading" || this.state === "expired";
        }
        patternsLoaded() {
          return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
        }
        setExpiryData(s) {
          const u = this.expirationTime;
          if (s.cacheControl) {
            const p = a.a8(s.cacheControl);
            p["max-age"] && (this.expirationTime = Date.now() + 1e3 * p["max-age"]);
          } else s.expires && (this.expirationTime = new Date(s.expires).getTime());
          if (this.expirationTime) {
            const p = Date.now();
            let m = !1;
            if (this.expirationTime > p) m = !1;
            else if (u)
              if (this.expirationTime < u) m = !0;
              else {
                const x = this.expirationTime - u;
                x ? this.expirationTime = p + Math.max(x, 3e4) : m = !0;
              }
            else m = !0;
            m ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
          }
        }
        getExpiryTimeout() {
          if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
        }
        setFeatureState(s, u) {
          if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(s).length === 0) return;
          const p = this.latestFeatureIndex.loadVTLayers();
          for (const m in this.buckets) {
            if (!u.style.hasLayer(m)) continue;
            const x = this.buckets[m], E = x.layers[0].sourceLayer || "_geojsonTileLayer", L = p[E], B = s[E];
            if (!L || !B || Object.keys(B).length === 0) continue;
            x.update(B, L, this.imageAtlas && this.imageAtlas.patternPositions || {});
            const N = u && u.style && u.style.getLayer(m);
            N && (this.queryPadding = Math.max(this.queryPadding, N.queryRadius(x)));
          }
        }
        holdingForFade() {
          return this.symbolFadeHoldUntil !== void 0;
        }
        symbolFadeFinished() {
          return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < I.now();
        }
        clearFadeHold() {
          this.symbolFadeHoldUntil = void 0;
        }
        setHoldDuration(s) {
          this.symbolFadeHoldUntil = I.now() + s;
        }
        setDependencies(s, u) {
          const p = {};
          for (const m of u) p[m] = !0;
          this.dependencies[s] = p;
        }
        hasDependency(s, u) {
          for (const p of s) {
            const m = this.dependencies[p];
            if (m) {
              for (const x of u) if (m[x]) return !0;
            }
          }
          return !1;
        }
      }
      class Jn {
        constructor(s, u) {
          this.max = s, this.onRemove = u, this.reset();
        }
        reset() {
          for (const s in this.data) for (const u of this.data[s]) u.timeout && clearTimeout(u.timeout), this.onRemove(u.value);
          return this.data = {}, this.order = [], this;
        }
        add(s, u, p) {
          const m = s.wrapped().key;
          this.data[m] === void 0 && (this.data[m] = []);
          const x = { value: u, timeout: void 0 };
          if (p !== void 0 && (x.timeout = setTimeout(() => {
            this.remove(s, x);
          }, p)), this.data[m].push(x), this.order.push(m), this.order.length > this.max) {
            const E = this._getAndRemoveByKey(this.order[0]);
            E && this.onRemove(E);
          }
          return this;
        }
        has(s) {
          return s.wrapped().key in this.data;
        }
        getAndRemove(s) {
          return this.has(s) ? this._getAndRemoveByKey(s.wrapped().key) : null;
        }
        _getAndRemoveByKey(s) {
          const u = this.data[s].shift();
          return u.timeout && clearTimeout(u.timeout), this.data[s].length === 0 && delete this.data[s], this.order.splice(this.order.indexOf(s), 1), u.value;
        }
        getByKey(s) {
          const u = this.data[s];
          return u ? u[0].value : null;
        }
        get(s) {
          return this.has(s) ? this.data[s.wrapped().key][0].value : null;
        }
        remove(s, u) {
          if (!this.has(s)) return this;
          const p = s.wrapped().key, m = u === void 0 ? 0 : this.data[p].indexOf(u), x = this.data[p][m];
          return this.data[p].splice(m, 1), x.timeout && clearTimeout(x.timeout), this.data[p].length === 0 && delete this.data[p], this.onRemove(x.value), this.order.splice(this.order.indexOf(p), 1), this;
        }
        setMaxSize(s) {
          for (this.max = s; this.order.length > this.max; ) {
            const u = this._getAndRemoveByKey(this.order[0]);
            u && this.onRemove(u);
          }
          return this;
        }
        filter(s) {
          const u = [];
          for (const p in this.data) for (const m of this.data[p]) s(m.value) || u.push(m);
          for (const p of u) this.remove(p.value.tileID, p);
        }
      }
      class bn {
        constructor() {
          this.state = {}, this.stateChanges = {}, this.deletedStates = {};
        }
        updateState(s, u, p) {
          const m = String(u);
          if (this.stateChanges[s] = this.stateChanges[s] || {}, this.stateChanges[s][m] = this.stateChanges[s][m] || {}, a.e(this.stateChanges[s][m], p), this.deletedStates[s] === null) {
            this.deletedStates[s] = {};
            for (const x in this.state[s]) x !== m && (this.deletedStates[s][x] = null);
          } else if (this.deletedStates[s] && this.deletedStates[s][m] === null) {
            this.deletedStates[s][m] = {};
            for (const x in this.state[s][m]) p[x] || (this.deletedStates[s][m][x] = null);
          } else for (const x in p) this.deletedStates[s] && this.deletedStates[s][m] && this.deletedStates[s][m][x] === null && delete this.deletedStates[s][m][x];
        }
        removeFeatureState(s, u, p) {
          if (this.deletedStates[s] === null) return;
          const m = String(u);
          if (this.deletedStates[s] = this.deletedStates[s] || {}, p && u !== void 0) this.deletedStates[s][m] !== null && (this.deletedStates[s][m] = this.deletedStates[s][m] || {}, this.deletedStates[s][m][p] = null);
          else if (u !== void 0)
            if (this.stateChanges[s] && this.stateChanges[s][m]) for (p in this.deletedStates[s][m] = {}, this.stateChanges[s][m]) this.deletedStates[s][m][p] = null;
            else this.deletedStates[s][m] = null;
          else this.deletedStates[s] = null;
        }
        getState(s, u) {
          const p = String(u), m = a.e({}, (this.state[s] || {})[p], (this.stateChanges[s] || {})[p]);
          if (this.deletedStates[s] === null) return {};
          if (this.deletedStates[s]) {
            const x = this.deletedStates[s][u];
            if (x === null) return {};
            for (const E in x) delete m[E];
          }
          return m;
        }
        initializeTileState(s, u) {
          s.setFeatureState(this.state, u);
        }
        coalesceChanges(s, u) {
          const p = {};
          for (const m in this.stateChanges) {
            this.state[m] = this.state[m] || {};
            const x = {};
            for (const E in this.stateChanges[m]) this.state[m][E] || (this.state[m][E] = {}), a.e(this.state[m][E], this.stateChanges[m][E]), x[E] = this.state[m][E];
            p[m] = x;
          }
          for (const m in this.deletedStates) {
            this.state[m] = this.state[m] || {};
            const x = {};
            if (this.deletedStates[m] === null) for (const E in this.state[m]) x[E] = {}, this.state[m][E] = {};
            else for (const E in this.deletedStates[m]) {
              if (this.deletedStates[m][E] === null) this.state[m][E] = {};
              else for (const L of Object.keys(this.deletedStates[m][E])) delete this.state[m][E][L];
              x[E] = this.state[m][E];
            }
            p[m] = p[m] || {}, a.e(p[m], x);
          }
          if (this.stateChanges = {}, this.deletedStates = {}, Object.keys(p).length !== 0) for (const m in s) s[m].setFeatureState(p, u);
        }
      }
      function tr(b, s, u) {
        const p = s.intersectsFrustum(b);
        if (!u) return p;
        const m = s.intersectsPlane(u);
        return p === 0 || m === 0 ? 0 : p === 2 && m === 2 ? 2 : 1;
      }
      function pi(b, s, u, p, m) {
        let x = b;
        const E = Math.atan(s / u), L = Math.hypot(s, u);
        return x = b + a.a9(p / L / Math.max(0.5, Math.cos(a.ab(m / 2)))), x += 1 * a.a9(Math.cos(E)) / 2, x += a.ac(b - x, -0, 0), x;
      }
      function Dr(b, s) {
        const u = (s.roundZoom ? Math.round : Math.floor)(b.zoom + a.a9(b.tileSize / s.tileSize));
        return Math.max(0, u);
      }
      function be(b, s) {
        const u = b.getCameraFrustum(), p = b.getClippingPlane(), m = b.screenPointToMercatorCoordinate(b.getCameraPoint()), x = a.Z.fromLngLat(b.center, b.elevation);
        m.z = x.z + Math.cos(b.pitchInRadians) * b.cameraToCenterDistance / b.worldSize;
        const E = b.getCoveringTilesDetailsProvider(), L = E.allowVariableZoom(b, s), B = Dr(b, s), N = s.minzoom || 0, G = s.maxzoom !== void 0 ? s.maxzoom : b.maxZoom, Z = Math.min(Math.max(0, B), G), $ = Math.pow(2, Z), re = [$ * m.x, $ * m.y, 0], ae = [$ * x.x, $ * x.y, 0], Pe = Math.hypot(x.x - m.x, x.y - m.y), Ce = Math.abs(x.z - m.z), Ie = Math.hypot(Pe, Ce), Be = ($e) => ({ zoom: 0, x: 0, y: 0, wrap: $e, fullyVisible: !1 }), He = [], We = [];
        if (b.renderWorldCopies && E.allowWorldCopies()) for (let $e = 1; $e <= 3; $e++) He.push(Be(-$e)), He.push(Be($e));
        for (He.push(Be(0)); He.length > 0; ) {
          const $e = He.pop(), Je = $e.x, Qe = $e.y;
          let wt = $e.fullyVisible;
          const bt = { x: Je, y: Qe, z: $e.zoom }, Mt = E.getTileAABB(bt, $e.wrap, b.elevation, s);
          if (!wt) {
            const nn = tr(u, Mt, p);
            if (nn === 0) continue;
            wt = nn === 2;
          }
          const Nt = E.distanceToTile2d(m.x, m.y, bt, Mt);
          let Ct = B;
          L && (Ct = (s.calculateTileZoom || pi)(b.zoom + a.a9(b.tileSize / s.tileSize), Nt, Ce, Ie, b.fov)), Ct = (s.roundZoom ? Math.round : Math.floor)(Ct), Ct = Math.max(0, Ct);
          const sn = Math.min(Ct, G);
          if ($e.wrap = E.getWrap(x, bt, $e.wrap), $e.zoom >= sn) {
            if ($e.zoom < N) continue;
            const nn = Z - $e.zoom, Gt = re[0] - 0.5 - (Je << nn), dn = re[1] - 0.5 - (Qe << nn), Hn = s.reparseOverscaled ? Math.max($e.zoom, Ct) : $e.zoom;
            We.push({ tileID: new a.X($e.zoom === G ? Hn : $e.zoom, $e.wrap, $e.zoom, Je, Qe), distanceSq: a.aa([ae[0] - 0.5 - Je, ae[1] - 0.5 - Qe]), tileDistanceToCamera: Math.sqrt(Gt * Gt + dn * dn) });
          } else for (let nn = 0; nn < 4; nn++) He.push({ zoom: $e.zoom + 1, x: (Je << 1) + nn % 2, y: (Qe << 1) + (nn >> 1), wrap: $e.wrap, fullyVisible: wt });
        }
        return We.sort(($e, Je) => $e.distanceSq - Je.distanceSq).map(($e) => $e.tileID);
      }
      class ne extends a.E {
        constructor(s, u, p) {
          super(), this.id = s, this.dispatcher = p, this.on("data", (m) => this._dataHandler(m)), this.on("dataloading", () => {
            this._sourceErrored = !1;
          }), this.on("error", () => {
            this._sourceErrored = this._source.loaded();
          }), this._source = ((m, x, E, L) => {
            const B = new (Wn(x.type))(m, x, E, L);
            if (B.id !== m) throw new Error(`Expected Source id to be ${m} instead of ${B.id}`);
            return B;
          })(s, u, p, this), this._tiles = {}, this._cache = new Jn(0, (m) => this._unloadTile(m)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new bn(), this._didEmitContent = !1, this._updated = !1;
        }
        onAdd(s) {
          this.map = s, this._maxTileCacheSize = s ? s._maxTileCacheSize : null, this._maxTileCacheZoomLevels = s ? s._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(s);
        }
        onRemove(s) {
          this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(s);
        }
        loaded() {
          if (this._sourceErrored) return !0;
          if (!this._sourceLoaded || !this._source.loaded()) return !1;
          if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain)) return !0;
          if (!this._updated) return !1;
          for (const s in this._tiles) {
            const u = this._tiles[s];
            if (u.state !== "loaded" && u.state !== "errored") return !1;
          }
          return !0;
        }
        getSource() {
          return this._source;
        }
        pause() {
          this._paused = !0;
        }
        resume() {
          if (!this._paused) return;
          const s = this._shouldReloadOnResume;
          this._paused = !1, this._shouldReloadOnResume = !1, s && this.reload(), this.transform && this.update(this.transform, this.terrain);
        }
        _loadTile(s, u, p) {
          return a._(this, void 0, void 0, function* () {
            try {
              yield this._source.loadTile(s), this._tileLoaded(s, u, p);
            } catch (m) {
              s.state = "errored", m.status !== 404 ? this._source.fire(new a.j(m, { tile: s })) : this.update(this.transform, this.terrain);
            }
          });
        }
        _unloadTile(s) {
          this._source.unloadTile && this._source.unloadTile(s);
        }
        _abortTile(s) {
          this._source.abortTile && this._source.abortTile(s), this._source.fire(new a.k("dataabort", { tile: s, coord: s.tileID, dataType: "source" }));
        }
        serialize() {
          return this._source.serialize();
        }
        prepare(s) {
          this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
          for (const u in this._tiles) {
            const p = this._tiles[u];
            p.upload(s), p.prepare(this.map.style.imageManager);
          }
        }
        getIds() {
          return Object.values(this._tiles).map((s) => s.tileID).sort(ce).map((s) => s.key);
        }
        getRenderableIds(s) {
          const u = [];
          for (const p in this._tiles) this._isIdRenderable(p, s) && u.push(this._tiles[p]);
          return s ? u.sort((p, m) => {
            const x = p.tileID, E = m.tileID, L = new a.P(x.canonical.x, x.canonical.y)._rotate(-this.transform.bearingInRadians), B = new a.P(E.canonical.x, E.canonical.y)._rotate(-this.transform.bearingInRadians);
            return x.overscaledZ - E.overscaledZ || B.y - L.y || B.x - L.x;
          }).map((p) => p.tileID.key) : u.map((p) => p.tileID).sort(ce).map((p) => p.key);
        }
        hasRenderableParent(s) {
          const u = this.findLoadedParent(s, 0);
          return !!u && this._isIdRenderable(u.tileID.key);
        }
        _isIdRenderable(s, u) {
          return this._tiles[s] && this._tiles[s].hasData() && !this._coveredTiles[s] && (u || !this._tiles[s].holdingForFade());
        }
        reload(s) {
          if (this._paused) this._shouldReloadOnResume = !0;
          else {
            this._cache.reset();
            for (const u in this._tiles) (s || this._tiles[u].state !== "errored") && this._reloadTile(u, "reloading");
          }
        }
        _reloadTile(s, u) {
          return a._(this, void 0, void 0, function* () {
            const p = this._tiles[s];
            p && (p.state !== "loading" && (p.state = u), yield this._loadTile(p, s, u));
          });
        }
        _tileLoaded(s, u, p) {
          s.timeAdded = I.now(), p === "expired" && (s.refreshedUponExpiration = !0), this._setTileReloadTimer(u, s), this.getSource().type === "raster-dem" && s.dem && this._backfillDEM(s), this._state.initializeTileState(s, this.map ? this.map.painter : null), s.aborted || this._source.fire(new a.k("data", { dataType: "source", tile: s, coord: s.tileID }));
        }
        _backfillDEM(s) {
          const u = this.getRenderableIds();
          for (let m = 0; m < u.length; m++) {
            const x = u[m];
            if (s.neighboringTiles && s.neighboringTiles[x]) {
              const E = this.getTileByID(x);
              p(s, E), p(E, s);
            }
          }
          function p(m, x) {
            m.needsHillshadePrepare = !0, m.needsTerrainPrepare = !0;
            let E = x.tileID.canonical.x - m.tileID.canonical.x;
            const L = x.tileID.canonical.y - m.tileID.canonical.y, B = Math.pow(2, m.tileID.canonical.z), N = x.tileID.key;
            E === 0 && L === 0 || Math.abs(L) > 1 || (Math.abs(E) > 1 && (Math.abs(E + B) === 1 ? E += B : Math.abs(E - B) === 1 && (E -= B)), x.dem && m.dem && (m.dem.backfillBorder(x.dem, E, L), m.neighboringTiles && m.neighboringTiles[N] && (m.neighboringTiles[N].backfilled = !0)));
          }
        }
        getTile(s) {
          return this.getTileByID(s.key);
        }
        getTileByID(s) {
          return this._tiles[s];
        }
        _retainLoadedChildren(s, u, p, m) {
          for (const x in this._tiles) {
            let E = this._tiles[x];
            if (m[x] || !E.hasData() || E.tileID.overscaledZ <= u || E.tileID.overscaledZ > p) continue;
            let L = E.tileID;
            for (; E && E.tileID.overscaledZ > u + 1; ) {
              const N = E.tileID.scaledTo(E.tileID.overscaledZ - 1);
              E = this._tiles[N.key], E && E.hasData() && (L = N);
            }
            let B = L;
            for (; B.overscaledZ > u; ) if (B = B.scaledTo(B.overscaledZ - 1), s[B.key] || s[B.canonical.key]) {
              m[L.key] = L;
              break;
            }
          }
        }
        findLoadedParent(s, u) {
          if (s.key in this._loadedParentTiles) {
            const p = this._loadedParentTiles[s.key];
            return p && p.tileID.overscaledZ >= u ? p : null;
          }
          for (let p = s.overscaledZ - 1; p >= u; p--) {
            const m = s.scaledTo(p), x = this._getLoadedTile(m);
            if (x) return x;
          }
        }
        findLoadedSibling(s) {
          return this._getLoadedTile(s);
        }
        _getLoadedTile(s) {
          const u = this._tiles[s.key];
          return u && u.hasData() ? u : this._cache.getByKey(s.wrapped().key);
        }
        updateCacheSize(s) {
          const u = Math.ceil(s.width / this._source.tileSize) + 1, p = Math.ceil(s.height / this._source.tileSize) + 1, m = Math.floor(u * p * (this._maxTileCacheZoomLevels === null ? a.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), x = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, m) : m;
          this._cache.setMaxSize(x);
        }
        handleWrapJump(s) {
          const u = Math.round((s - (this._prevLng === void 0 ? s : this._prevLng)) / 360);
          if (this._prevLng = s, u) {
            const p = {};
            for (const m in this._tiles) {
              const x = this._tiles[m];
              x.tileID = x.tileID.unwrapTo(x.tileID.wrap + u), p[x.tileID.key] = x;
            }
            this._tiles = p;
            for (const m in this._timers) clearTimeout(this._timers[m]), delete this._timers[m];
            for (const m in this._tiles) this._setTileReloadTimer(m, this._tiles[m]);
          }
        }
        _updateCoveredAndRetainedTiles(s, u, p, m, x, E) {
          const L = {}, B = {}, N = Object.keys(s), G = I.now();
          for (const Z of N) {
            const $ = s[Z], re = this._tiles[Z];
            if (!re || re.fadeEndTime !== 0 && re.fadeEndTime <= G) continue;
            const ae = this.findLoadedParent($, u), Pe = this.findLoadedSibling($), Ce = ae || Pe || null;
            Ce && (this._addTile(Ce.tileID), L[Ce.tileID.key] = Ce.tileID), B[Z] = $;
          }
          this._retainLoadedChildren(B, m, p, s);
          for (const Z in L) s[Z] || (this._coveredTiles[Z] = !0, s[Z] = L[Z]);
          if (E) {
            const Z = {}, $ = {};
            for (const re of x) this._tiles[re.key].hasData() ? Z[re.key] = re : $[re.key] = re;
            for (const re in $) {
              const ae = $[re].children(this._source.maxzoom);
              this._tiles[ae[0].key] && this._tiles[ae[1].key] && this._tiles[ae[2].key] && this._tiles[ae[3].key] && (Z[ae[0].key] = s[ae[0].key] = ae[0], Z[ae[1].key] = s[ae[1].key] = ae[1], Z[ae[2].key] = s[ae[2].key] = ae[2], Z[ae[3].key] = s[ae[3].key] = ae[3], delete $[re]);
            }
            for (const re in $) {
              const ae = $[re], Pe = this.findLoadedParent(ae, this._source.minzoom), Ce = this.findLoadedSibling(ae), Ie = Pe || Ce || null;
              if (Ie) {
                Z[Ie.tileID.key] = s[Ie.tileID.key] = Ie.tileID;
                for (const Be in Z) Z[Be].isChildOf(Ie.tileID) && delete Z[Be];
              }
            }
            for (const re in this._tiles) Z[re] || (this._coveredTiles[re] = !0);
          }
        }
        update(s, u) {
          if (!this._sourceLoaded || this._paused) return;
          let p;
          this.transform = s, this.terrain = u, this.updateCacheSize(s), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? p = s.getVisibleUnwrappedCoordinates(this._source.tileID).map((G) => new a.X(G.canonical.z, G.wrap, G.canonical.z, G.canonical.x, G.canonical.y)) : (p = be(s, { tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: u, calculateTileZoom: this._source.calculateTileZoom }), this._source.hasTile && (p = p.filter((G) => this._source.hasTile(G)))) : p = [];
          const m = Dr(s, this._source), x = Math.max(m - ne.maxOverzooming, this._source.minzoom), E = Math.max(m + ne.maxUnderzooming, this._source.minzoom);
          if (this.usedForTerrain) {
            const G = {};
            for (const Z of p) if (Z.canonical.z > this._source.minzoom) {
              const $ = Z.scaledTo(Z.canonical.z - 1);
              G[$.key] = $;
              const re = Z.scaledTo(Math.max(this._source.minzoom, Math.min(Z.canonical.z, 5)));
              G[re.key] = re;
            }
            p = p.concat(Object.values(G));
          }
          const L = p.length === 0 && !this._updated && this._didEmitContent;
          this._updated = !0, L && this.fire(new a.k("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
          const B = this._updateRetainedTiles(p, m);
          ue(this._source.type) && this._updateCoveredAndRetainedTiles(B, x, E, m, p, u);
          for (const G in B) this._tiles[G].clearFadeHold();
          const N = a.ad(this._tiles, B);
          for (const G of N) {
            const Z = this._tiles[G];
            Z.hasSymbolBuckets && !Z.holdingForFade() ? Z.setHoldDuration(this.map._fadeDuration) : Z.hasSymbolBuckets && !Z.symbolFadeFinished() || this._removeTile(G);
          }
          this._updateLoadedParentTileCache(), this._updateLoadedSiblingTileCache();
        }
        releaseSymbolFadeTiles() {
          for (const s in this._tiles) this._tiles[s].holdingForFade() && this._removeTile(s);
        }
        _updateRetainedTiles(s, u) {
          var p;
          const m = {}, x = {}, E = Math.max(u - ne.maxOverzooming, this._source.minzoom), L = Math.max(u + ne.maxUnderzooming, this._source.minzoom), B = {};
          for (const N of s) {
            const G = this._addTile(N);
            m[N.key] = N, G.hasData() || u < this._source.maxzoom && (B[N.key] = N);
          }
          this._retainLoadedChildren(B, u, L, m);
          for (const N of s) {
            let G = this._tiles[N.key];
            if (G.hasData()) continue;
            if (u + 1 > this._source.maxzoom) {
              const $ = N.children(this._source.maxzoom)[0], re = this.getTile($);
              if (re && re.hasData()) {
                m[$.key] = $;
                continue;
              }
            } else {
              const $ = N.children(this._source.maxzoom);
              if (m[$[0].key] && m[$[1].key] && m[$[2].key] && m[$[3].key]) continue;
            }
            let Z = G.wasRequested();
            for (let $ = N.overscaledZ - 1; $ >= E; --$) {
              const re = N.scaledTo($);
              if (x[re.key]) break;
              if (x[re.key] = !0, G = this.getTile(re), !G && Z && (G = this._addTile(re)), G) {
                const ae = G.hasData();
                if ((ae || !(!((p = this.map) === null || p === void 0) && p.cancelPendingTileRequestsWhileZooming) || Z) && (m[re.key] = re), Z = G.wasRequested(), ae) break;
              }
            }
          }
          return m;
        }
        _updateLoadedParentTileCache() {
          this._loadedParentTiles = {};
          for (const s in this._tiles) {
            const u = [];
            let p, m = this._tiles[s].tileID;
            for (; m.overscaledZ > 0; ) {
              if (m.key in this._loadedParentTiles) {
                p = this._loadedParentTiles[m.key];
                break;
              }
              u.push(m.key);
              const x = m.scaledTo(m.overscaledZ - 1);
              if (p = this._getLoadedTile(x), p) break;
              m = x;
            }
            for (const x of u) this._loadedParentTiles[x] = p;
          }
        }
        _updateLoadedSiblingTileCache() {
          this._loadedSiblingTiles = {};
          for (const s in this._tiles) {
            const u = this._tiles[s].tileID, p = this._getLoadedTile(u);
            this._loadedSiblingTiles[u.key] = p;
          }
        }
        _addTile(s) {
          let u = this._tiles[s.key];
          if (u) return u;
          u = this._cache.getAndRemove(s), u && (this._setTileReloadTimer(s.key, u), u.tileID = s, this._state.initializeTileState(u, this.map ? this.map.painter : null), this._cacheTimers[s.key] && (clearTimeout(this._cacheTimers[s.key]), delete this._cacheTimers[s.key], this._setTileReloadTimer(s.key, u)));
          const p = u;
          return u || (u = new Un(s, this._source.tileSize * s.overscaleFactor()), this._loadTile(u, s.key, u.state)), u.uses++, this._tiles[s.key] = u, p || this._source.fire(new a.k("dataloading", { tile: u, coord: u.tileID, dataType: "source" })), u;
        }
        _setTileReloadTimer(s, u) {
          s in this._timers && (clearTimeout(this._timers[s]), delete this._timers[s]);
          const p = u.getExpiryTimeout();
          p && (this._timers[s] = setTimeout(() => {
            this._reloadTile(s, "expired"), delete this._timers[s];
          }, p));
        }
        _removeTile(s) {
          const u = this._tiles[s];
          u && (u.uses--, delete this._tiles[s], this._timers[s] && (clearTimeout(this._timers[s]), delete this._timers[s]), u.uses > 0 || (u.hasData() && u.state !== "reloading" ? this._cache.add(u.tileID, u, u.getExpiryTimeout()) : (u.aborted = !0, this._abortTile(u), this._unloadTile(u))));
        }
        _dataHandler(s) {
          const u = s.sourceDataType;
          s.dataType === "source" && u === "metadata" && (this._sourceLoaded = !0), this._sourceLoaded && !this._paused && s.dataType === "source" && u === "content" && (this.reload(s.sourceDataChanged), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = !0);
        }
        clearTiles() {
          this._shouldReloadOnResume = !1, this._paused = !1;
          for (const s in this._tiles) this._removeTile(s);
          this._cache.reset();
        }
        tilesIn(s, u, p) {
          const m = [], x = this.transform;
          if (!x) return m;
          const E = p ? x.getCameraQueryGeometry(s) : s, L = s.map((ae) => x.screenPointToMercatorCoordinate(ae, this.terrain)), B = E.map((ae) => x.screenPointToMercatorCoordinate(ae, this.terrain)), N = this.getIds();
          let G = 1 / 0, Z = 1 / 0, $ = -1 / 0, re = -1 / 0;
          for (const ae of B) G = Math.min(G, ae.x), Z = Math.min(Z, ae.y), $ = Math.max($, ae.x), re = Math.max(re, ae.y);
          for (let ae = 0; ae < N.length; ae++) {
            const Pe = this._tiles[N[ae]];
            if (Pe.holdingForFade()) continue;
            const Ce = Pe.tileID, Ie = Math.pow(2, x.zoom - Pe.tileID.overscaledZ), Be = u * Pe.queryPadding * a.Y / Pe.tileSize / Ie, He = [Ce.getTilePoint(new a.Z(G, Z)), Ce.getTilePoint(new a.Z($, re))];
            if (He[0].x - Be < a.Y && He[0].y - Be < a.Y && He[1].x + Be >= 0 && He[1].y + Be >= 0) {
              const We = L.map((Je) => Ce.getTilePoint(Je)), $e = B.map((Je) => Ce.getTilePoint(Je));
              m.push({ tile: Pe, tileID: Ce, queryGeometry: We, cameraQueryGeometry: $e, scale: Ie });
            }
          }
          return m;
        }
        getVisibleCoordinates(s) {
          const u = this.getRenderableIds(s).map((p) => this._tiles[p].tileID);
          return this.transform && this.transform.populateCache(u), u;
        }
        hasTransition() {
          if (this._source.hasTransition()) return !0;
          if (ue(this._source.type)) {
            const s = I.now();
            for (const u in this._tiles) if (this._tiles[u].fadeEndTime >= s) return !0;
          }
          return !1;
        }
        setFeatureState(s, u, p) {
          this._state.updateState(s = s || "_geojsonTileLayer", u, p);
        }
        removeFeatureState(s, u, p) {
          this._state.removeFeatureState(s = s || "_geojsonTileLayer", u, p);
        }
        getFeatureState(s, u) {
          return this._state.getState(s = s || "_geojsonTileLayer", u);
        }
        setDependencies(s, u, p) {
          const m = this._tiles[s];
          m && m.setDependencies(u, p);
        }
        reloadTilesForDependencies(s, u) {
          for (const p in this._tiles) this._tiles[p].hasDependency(s, u) && this._reloadTile(p, "reloading");
          this._cache.filter((p) => !p.hasDependency(s, u));
        }
      }
      function ce(b, s) {
        const u = Math.abs(2 * b.wrap) - +(b.wrap < 0), p = Math.abs(2 * s.wrap) - +(s.wrap < 0);
        return b.overscaledZ - s.overscaledZ || p - u || s.canonical.y - b.canonical.y || s.canonical.x - b.canonical.x;
      }
      function ue(b) {
        return b === "raster" || b === "image" || b === "video";
      }
      ne.maxOverzooming = 10, ne.maxUnderzooming = 3;
      class Oe {
        constructor(s, u) {
          this.reset(s, u);
        }
        reset(s, u) {
          this.points = s || [], this._distances = [0];
          for (let p = 1; p < this.points.length; p++) this._distances[p] = this._distances[p - 1] + this.points[p].dist(this.points[p - 1]);
          this.length = this._distances[this._distances.length - 1], this.padding = Math.min(u || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
        }
        lerp(s) {
          if (this.points.length === 1) return this.points[0];
          s = a.ac(s, 0, 1);
          let u = 1, p = this._distances[u];
          const m = s * this.paddedLength + this.padding;
          for (; p < m && u < this._distances.length; ) p = this._distances[++u];
          const x = u - 1, E = this._distances[x], L = p - E, B = L > 0 ? (m - E) / L : 0;
          return this.points[x].mult(1 - B).add(this.points[u].mult(B));
        }
      }
      function qe(b, s) {
        let u = !0;
        return b === "always" || b !== "never" && s !== "never" || (u = !1), u;
      }
      class it {
        constructor(s, u, p) {
          const m = this.boxCells = [], x = this.circleCells = [];
          this.xCellCount = Math.ceil(s / p), this.yCellCount = Math.ceil(u / p);
          for (let E = 0; E < this.xCellCount * this.yCellCount; E++) m.push([]), x.push([]);
          this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = s, this.height = u, this.xScale = this.xCellCount / s, this.yScale = this.yCellCount / u, this.boxUid = 0, this.circleUid = 0;
        }
        keysLength() {
          return this.boxKeys.length + this.circleKeys.length;
        }
        insert(s, u, p, m, x) {
          this._forEachCell(u, p, m, x, this._insertBoxCell, this.boxUid++), this.boxKeys.push(s), this.bboxes.push(u), this.bboxes.push(p), this.bboxes.push(m), this.bboxes.push(x);
        }
        insertCircle(s, u, p, m) {
          this._forEachCell(u - m, p - m, u + m, p + m, this._insertCircleCell, this.circleUid++), this.circleKeys.push(s), this.circles.push(u), this.circles.push(p), this.circles.push(m);
        }
        _insertBoxCell(s, u, p, m, x, E) {
          this.boxCells[x].push(E);
        }
        _insertCircleCell(s, u, p, m, x, E) {
          this.circleCells[x].push(E);
        }
        _query(s, u, p, m, x, E, L) {
          if (p < 0 || s > this.width || m < 0 || u > this.height) return [];
          const B = [];
          if (s <= 0 && u <= 0 && this.width <= p && this.height <= m) {
            if (x) return [{ key: null, x1: s, y1: u, x2: p, y2: m }];
            for (let N = 0; N < this.boxKeys.length; N++) B.push({ key: this.boxKeys[N], x1: this.bboxes[4 * N], y1: this.bboxes[4 * N + 1], x2: this.bboxes[4 * N + 2], y2: this.bboxes[4 * N + 3] });
            for (let N = 0; N < this.circleKeys.length; N++) {
              const G = this.circles[3 * N], Z = this.circles[3 * N + 1], $ = this.circles[3 * N + 2];
              B.push({ key: this.circleKeys[N], x1: G - $, y1: Z - $, x2: G + $, y2: Z + $ });
            }
          } else this._forEachCell(s, u, p, m, this._queryCell, B, { hitTest: x, overlapMode: E, seenUids: { box: {}, circle: {} } }, L);
          return B;
        }
        query(s, u, p, m) {
          return this._query(s, u, p, m, !1, null);
        }
        hitTest(s, u, p, m, x, E) {
          return this._query(s, u, p, m, !0, x, E).length > 0;
        }
        hitTestCircle(s, u, p, m, x) {
          const E = s - p, L = s + p, B = u - p, N = u + p;
          if (L < 0 || E > this.width || N < 0 || B > this.height) return !1;
          const G = [];
          return this._forEachCell(E, B, L, N, this._queryCellCircle, G, { hitTest: !0, overlapMode: m, circle: { x: s, y: u, radius: p }, seenUids: { box: {}, circle: {} } }, x), G.length > 0;
        }
        _queryCell(s, u, p, m, x, E, L, B) {
          const { seenUids: N, hitTest: G, overlapMode: Z } = L, $ = this.boxCells[x];
          if ($ !== null) {
            const ae = this.bboxes;
            for (const Pe of $) if (!N.box[Pe]) {
              N.box[Pe] = !0;
              const Ce = 4 * Pe, Ie = this.boxKeys[Pe];
              if (s <= ae[Ce + 2] && u <= ae[Ce + 3] && p >= ae[Ce + 0] && m >= ae[Ce + 1] && (!B || B(Ie)) && (!G || !qe(Z, Ie.overlapMode)) && (E.push({ key: Ie, x1: ae[Ce], y1: ae[Ce + 1], x2: ae[Ce + 2], y2: ae[Ce + 3] }), G)) return !0;
            }
          }
          const re = this.circleCells[x];
          if (re !== null) {
            const ae = this.circles;
            for (const Pe of re) if (!N.circle[Pe]) {
              N.circle[Pe] = !0;
              const Ce = 3 * Pe, Ie = this.circleKeys[Pe];
              if (this._circleAndRectCollide(ae[Ce], ae[Ce + 1], ae[Ce + 2], s, u, p, m) && (!B || B(Ie)) && (!G || !qe(Z, Ie.overlapMode))) {
                const Be = ae[Ce], He = ae[Ce + 1], We = ae[Ce + 2];
                if (E.push({ key: Ie, x1: Be - We, y1: He - We, x2: Be + We, y2: He + We }), G) return !0;
              }
            }
          }
          return !1;
        }
        _queryCellCircle(s, u, p, m, x, E, L, B) {
          const { circle: N, seenUids: G, overlapMode: Z } = L, $ = this.boxCells[x];
          if ($ !== null) {
            const ae = this.bboxes;
            for (const Pe of $) if (!G.box[Pe]) {
              G.box[Pe] = !0;
              const Ce = 4 * Pe, Ie = this.boxKeys[Pe];
              if (this._circleAndRectCollide(N.x, N.y, N.radius, ae[Ce + 0], ae[Ce + 1], ae[Ce + 2], ae[Ce + 3]) && (!B || B(Ie)) && !qe(Z, Ie.overlapMode)) return E.push(!0), !0;
            }
          }
          const re = this.circleCells[x];
          if (re !== null) {
            const ae = this.circles;
            for (const Pe of re) if (!G.circle[Pe]) {
              G.circle[Pe] = !0;
              const Ce = 3 * Pe, Ie = this.circleKeys[Pe];
              if (this._circlesCollide(ae[Ce], ae[Ce + 1], ae[Ce + 2], N.x, N.y, N.radius) && (!B || B(Ie)) && !qe(Z, Ie.overlapMode)) return E.push(!0), !0;
            }
          }
        }
        _forEachCell(s, u, p, m, x, E, L, B) {
          const N = this._convertToXCellCoord(s), G = this._convertToYCellCoord(u), Z = this._convertToXCellCoord(p), $ = this._convertToYCellCoord(m);
          for (let re = N; re <= Z; re++) for (let ae = G; ae <= $; ae++) if (x.call(this, s, u, p, m, this.xCellCount * ae + re, E, L, B)) return;
        }
        _convertToXCellCoord(s) {
          return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(s * this.xScale)));
        }
        _convertToYCellCoord(s) {
          return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(s * this.yScale)));
        }
        _circlesCollide(s, u, p, m, x, E) {
          const L = m - s, B = x - u, N = p + E;
          return N * N > L * L + B * B;
        }
        _circleAndRectCollide(s, u, p, m, x, E, L) {
          const B = (E - m) / 2, N = Math.abs(s - (m + B));
          if (N > B + p) return !1;
          const G = (L - x) / 2, Z = Math.abs(u - (x + G));
          if (Z > G + p) return !1;
          if (N <= B || Z <= G) return !0;
          const $ = N - B, re = Z - G;
          return $ * $ + re * re <= p * p;
        }
      }
      function mt(b, s, u) {
        const p = a.J();
        if (!b) {
          const { vecSouth: Z, vecEast: $ } = at(s), re = y();
          re[0] = $[0], re[1] = $[1], re[2] = Z[0], re[3] = Z[1], m = re, (G = (E = (x = re)[0]) * (N = x[3]) - (B = x[2]) * (L = x[1])) && (m[0] = N * (G = 1 / G), m[1] = -L * G, m[2] = -B * G, m[3] = E * G), p[0] = re[0], p[1] = re[1], p[4] = re[2], p[5] = re[3];
        }
        var m, x, E, L, B, N, G;
        return a.L(p, p, [1 / u, 1 / u, 1]), p;
      }
      function Ye(b, s, u, p) {
        if (b) {
          const m = a.J();
          if (!s) {
            const { vecSouth: x, vecEast: E } = at(u);
            m[0] = E[0], m[1] = E[1], m[4] = x[0], m[5] = x[1];
          }
          return a.L(m, m, [p, p, 1]), m;
        }
        return u.pixelsToClipSpaceMatrix;
      }
      function at(b) {
        const s = Math.cos(b.rollInRadians), u = Math.sin(b.rollInRadians), p = Math.cos(b.pitchInRadians), m = Math.cos(b.bearingInRadians), x = Math.sin(b.bearingInRadians), E = a.ai();
        E[0] = -m * p * u - x * s, E[1] = -x * p * u + m * s;
        const L = a.aj(E);
        L < 1e-9 ? a.ak(E) : a.al(E, E, 1 / L);
        const B = a.ai();
        B[0] = m * p * s - x * u, B[1] = x * p * s + m * u;
        const N = a.aj(B);
        return N < 1e-9 ? a.ak(B) : a.al(B, B, 1 / N), { vecEast: B, vecSouth: E };
      }
      function pt(b, s, u, p) {
        let m;
        p ? (m = [b, s, p(b, s), 1], a.an(m, m, u)) : (m = [b, s, 0, 1], Ii(m, m, u));
        const x = m[3];
        return { point: new a.P(m[0] / x, m[1] / x), signedDistanceFromCamera: x, isOccluded: !1 };
      }
      function lt(b, s) {
        return 0.5 + b / s * 0.5;
      }
      function Ze(b, s) {
        return b.x >= -s[0] && b.x <= s[0] && b.y >= -s[1] && b.y <= s[1];
      }
      function an(b, s, u, p, m, x, E, L, B, N, G, Z, $) {
        const re = u ? b.textSizeData : b.iconSizeData, ae = a.ae(re, s.transform.zoom), Pe = [256 / s.width * 2 + 1, 256 / s.height * 2 + 1], Ce = u ? b.text.dynamicLayoutVertexArray : b.icon.dynamicLayoutVertexArray;
        Ce.clear();
        const Ie = b.lineVertexArray, Be = u ? b.text.placedSymbolArray : b.icon.placedSymbolArray, He = s.transform.width / s.transform.height;
        let We = !1;
        for (let $e = 0; $e < Be.length; $e++) {
          const Je = Be.get($e);
          if (Je.hidden || Je.writingMode === a.af.vertical && !We) {
            Pi(Je.numGlyphs, Ce);
            continue;
          }
          We = !1;
          const Qe = new a.P(Je.anchorX, Je.anchorY), wt = { getElevation: $, pitchedLabelPlaneMatrix: p, lineVertexArray: Ie, pitchWithMap: x, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: s.transform, tileAnchorPoint: Qe, unwrappedTileID: B, width: N, height: G, translation: Z }, bt = Zn(Je.anchorX, Je.anchorY, wt);
          if (!Ze(bt.point, Pe)) {
            Pi(Je.numGlyphs, Ce);
            continue;
          }
          const Mt = lt(s.transform.cameraToCenterDistance, bt.signedDistanceFromCamera), Nt = a.ag(re, ae, Je), Ct = x ? Nt * s.transform.getPitchedTextCorrection(Je.anchorX, Je.anchorY, B) / Mt : Nt * Mt, sn = An({ projectionContext: wt, pitchedLabelPlaneMatrixInverse: m, symbol: Je, fontSize: Ct, flip: !1, keepUpright: E, glyphOffsetArray: b.glyphOffsetArray, dynamicLayoutVertexArray: Ce, aspectRatio: He, rotateToLine: L });
          We = sn.useVertical, (sn.notEnoughRoom || We || sn.needsFlipping && An({ projectionContext: wt, pitchedLabelPlaneMatrixInverse: m, symbol: Je, fontSize: Ct, flip: !0, keepUpright: E, glyphOffsetArray: b.glyphOffsetArray, dynamicLayoutVertexArray: Ce, aspectRatio: He, rotateToLine: L }).notEnoughRoom) && Pi(Je.numGlyphs, Ce);
        }
        u ? b.text.dynamicLayoutVertexBuffer.updateData(Ce) : b.icon.dynamicLayoutVertexBuffer.updateData(Ce);
      }
      function Yt(b, s, u, p, m, x, E, L) {
        const B = x.glyphStartIndex + x.numGlyphs, N = x.lineStartIndex, G = x.lineStartIndex + x.lineLength, Z = s.getoffsetX(x.glyphStartIndex), $ = s.getoffsetX(B - 1), re = xi(b * Z, u, p, m, x.segment, N, G, L, E);
        if (!re) return null;
        const ae = xi(b * $, u, p, m, x.segment, N, G, L, E);
        return ae ? L.projectionCache.anyProjectionOccluded ? null : { first: re, last: ae } : null;
      }
      function Xt(b, s, u, p) {
        return b === a.af.horizontal && Math.abs(u.y - s.y) > Math.abs(u.x - s.x) * p ? { useVertical: !0 } : (b === a.af.vertical ? s.y < u.y : s.x > u.x) ? { needsFlipping: !0 } : null;
      }
      function An(b) {
        const { projectionContext: s, pitchedLabelPlaneMatrixInverse: u, symbol: p, fontSize: m, flip: x, keepUpright: E, glyphOffsetArray: L, dynamicLayoutVertexArray: B, aspectRatio: N, rotateToLine: G } = b, Z = m / 24, $ = p.lineOffsetX * Z, re = p.lineOffsetY * Z;
        let ae;
        if (p.numGlyphs > 1) {
          const Pe = p.glyphStartIndex + p.numGlyphs, Ce = p.lineStartIndex, Ie = p.lineStartIndex + p.lineLength, Be = Yt(Z, L, $, re, x, p, G, s);
          if (!Be) return { notEnoughRoom: !0 };
          const He = In(Be.first.point.x, Be.first.point.y, s, u), We = In(Be.last.point.x, Be.last.point.y, s, u);
          if (E && !x) {
            const $e = Xt(p.writingMode, He, We, N);
            if ($e) return $e;
          }
          ae = [Be.first];
          for (let $e = p.glyphStartIndex + 1; $e < Pe - 1; $e++) ae.push(xi(Z * L.getoffsetX($e), $, re, x, p.segment, Ce, Ie, s, G));
          ae.push(Be.last);
        } else {
          if (E && !x) {
            const Ce = cn(s.tileAnchorPoint.x, s.tileAnchorPoint.y, s).point, Ie = p.lineStartIndex + p.segment + 1, Be = new a.P(s.lineVertexArray.getx(Ie), s.lineVertexArray.gety(Ie)), He = cn(Be.x, Be.y, s), We = He.signedDistanceFromCamera > 0 ? He.point : It(s.tileAnchorPoint, Be, Ce, 1, s), $e = In(Ce.x, Ce.y, s, u), Je = In(We.x, We.y, s, u), Qe = Xt(p.writingMode, $e, Je, N);
            if (Qe) return Qe;
          }
          const Pe = xi(Z * L.getoffsetX(p.glyphStartIndex), $, re, x, p.segment, p.lineStartIndex, p.lineStartIndex + p.lineLength, s, G);
          if (!Pe || s.projectionCache.anyProjectionOccluded) return { notEnoughRoom: !0 };
          ae = [Pe];
        }
        for (const Pe of ae) a.am(B, Pe.point, Pe.angle);
        return {};
      }
      function It(b, s, u, p, m) {
        const x = b.add(b.sub(s)._unit()), E = cn(x.x, x.y, m).point, L = u.sub(E);
        return u.add(L._mult(p / L.mag()));
      }
      function Jt(b, s, u) {
        const p = s.projectionCache;
        if (p.projections[b]) return p.projections[b];
        const m = new a.P(s.lineVertexArray.getx(b), s.lineVertexArray.gety(b)), x = cn(m.x, m.y, s);
        if (x.signedDistanceFromCamera > 0) return p.projections[b] = x.point, p.anyProjectionOccluded = p.anyProjectionOccluded || x.isOccluded, x.point;
        const E = b - u.direction;
        return It(u.distanceFromAnchor === 0 ? s.tileAnchorPoint : new a.P(s.lineVertexArray.getx(E), s.lineVertexArray.gety(E)), m, u.previousVertex, u.absOffsetX - u.distanceFromAnchor + 1, s);
      }
      function cn(b, s, u) {
        const p = b + u.translation[0], m = s + u.translation[1];
        let x;
        return u.pitchWithMap ? (x = pt(p, m, u.pitchedLabelPlaneMatrix, u.getElevation), x.isOccluded = !1) : (x = u.transform.projectTileCoordinates(p, m, u.unwrappedTileID, u.getElevation), x.point.x = (0.5 * x.point.x + 0.5) * u.width, x.point.y = (0.5 * -x.point.y + 0.5) * u.height), x;
      }
      function In(b, s, u, p) {
        if (u.pitchWithMap) {
          const m = [b, s, 0, 1];
          return a.an(m, m, p), u.transform.projectTileCoordinates(m[0] / m[3], m[1] / m[3], u.unwrappedTileID, u.getElevation).point;
        }
        return { x: b / u.width * 2 - 1, y: s / u.height * 2 - 1 };
      }
      function Zn(b, s, u) {
        return u.transform.projectTileCoordinates(b, s, u.unwrappedTileID, u.getElevation);
      }
      function Ln(b, s, u) {
        return b._unit()._perp()._mult(s * u);
      }
      function fn(b, s, u, p, m, x, E, L, B) {
        if (L.projectionCache.offsets[b]) return L.projectionCache.offsets[b];
        const N = u.add(s);
        if (b + B.direction < p || b + B.direction >= m) return L.projectionCache.offsets[b] = N, N;
        const G = Jt(b + B.direction, L, B), Z = Ln(G.sub(u), E, B.direction), $ = u.add(Z), re = G.add(Z);
        return L.projectionCache.offsets[b] = a.ao(x, N, $, re) || N, L.projectionCache.offsets[b];
      }
      function xi(b, s, u, p, m, x, E, L, B) {
        const N = p ? b - s : b + s;
        let G = N > 0 ? 1 : -1, Z = 0;
        p && (G *= -1, Z = Math.PI), G < 0 && (Z += Math.PI);
        let $, re = G > 0 ? x + m : x + m + 1;
        L.projectionCache.cachedAnchorPoint ? $ = L.projectionCache.cachedAnchorPoint : ($ = cn(L.tileAnchorPoint.x, L.tileAnchorPoint.y, L).point, L.projectionCache.cachedAnchorPoint = $);
        let ae, Pe, Ce = $, Ie = $, Be = 0, He = 0;
        const We = Math.abs(N), $e = [];
        let Je;
        for (; Be + He <= We; ) {
          if (re += G, re < x || re >= E) return null;
          Be += He, Ie = Ce, Pe = ae;
          const bt = { absOffsetX: We, direction: G, distanceFromAnchor: Be, previousVertex: Ie };
          if (Ce = Jt(re, L, bt), u === 0) $e.push(Ie), Je = Ce.sub(Ie);
          else {
            let Mt;
            const Nt = Ce.sub(Ie);
            Mt = Nt.mag() === 0 ? Ln(Jt(re + G, L, bt).sub(Ce), u, G) : Ln(Nt, u, G), Pe || (Pe = Ie.add(Mt)), ae = fn(re, Mt, Ce, x, E, Pe, u, L, bt), $e.push(Pe), Je = ae.sub(Pe);
          }
          He = Je.mag();
        }
        const Qe = Je._mult((We - Be) / He)._add(Pe || Ie), wt = Z + Math.atan2(Ce.y - Ie.y, Ce.x - Ie.x);
        return $e.push(Qe), { point: Qe, angle: B ? wt : 0, path: $e };
      }
      const Er = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
      function Pi(b, s) {
        for (let u = 0; u < b; u++) {
          const p = s.length;
          s.resize(p + 4), s.float32.set(Er, 3 * p);
        }
      }
      function Ii(b, s, u) {
        const p = s[0], m = s[1];
        return b[0] = u[0] * p + u[4] * m + u[12], b[1] = u[1] * p + u[5] * m + u[13], b[3] = u[3] * p + u[7] * m + u[15], b;
      }
      const ui = 100;
      class Oi {
        constructor(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new it(s.width + 200, s.height + 200, 25), p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new it(s.width + 200, s.height + 200, 25);
          this.transform = s, this.grid = u, this.ignoredGrid = p, this.pitchFactor = Math.cos(s.pitch * Math.PI / 180) * s.cameraToCenterDistance, this.screenRightBoundary = s.width + ui, this.screenBottomBoundary = s.height + ui, this.gridRightBoundary = s.width + 200, this.gridBottomBoundary = s.height + 200, this.perspectiveRatioCutoff = 0.6;
        }
        placeCollisionBox(s, u, p, m, x, E, L, B, N, G, Z, $) {
          const re = this.projectAndGetPerspectiveRatio(s.anchorPointX + B[0], s.anchorPointY + B[1], x, G, $), ae = p * re.perspectiveRatio;
          let Pe;
          if (E || L) Pe = this._projectCollisionBox(s, ae, m, x, E, L, B, re, G, Z, $);
          else {
            const Je = re.x + (Z ? Z.x * ae : 0), Qe = re.y + (Z ? Z.y * ae : 0);
            Pe = { allPointsOccluded: !1, box: [Je + s.x1 * ae, Qe + s.y1 * ae, Je + s.x2 * ae, Qe + s.y2 * ae] };
          }
          const [Ce, Ie, Be, He] = Pe.box, We = E ? Pe.allPointsOccluded : re.isOccluded;
          let $e = We;
          return $e || ($e = re.perspectiveRatio < this.perspectiveRatioCutoff), $e || ($e = !this.isInsideGrid(Ce, Ie, Be, He)), $e || u !== "always" && this.grid.hitTest(Ce, Ie, Be, He, u, N) ? { box: [Ce, Ie, Be, He], placeable: !1, offscreen: !1, occluded: We } : { box: [Ce, Ie, Be, He], placeable: !0, offscreen: this.isOffscreen(Ce, Ie, Be, He), occluded: We };
        }
        placeCollisionCircles(s, u, p, m, x, E, L, B, N, G, Z, $, re, ae) {
          const Pe = [], Ce = new a.P(u.anchorX, u.anchorY), Ie = this.getPerspectiveRatio(Ce.x, Ce.y, E, ae), Be = (N ? x * this.transform.getPitchedTextCorrection(u.anchorX, u.anchorY, E) / Ie : x * Ie) / a.at, He = { getElevation: ae, pitchedLabelPlaneMatrix: L, lineVertexArray: p, pitchWithMap: N, projectionCache: { projections: {}, offsets: {}, cachedAnchorPoint: void 0, anyProjectionOccluded: !1 }, transform: this.transform, tileAnchorPoint: Ce, unwrappedTileID: E, width: this.transform.width, height: this.transform.height, translation: re }, We = Yt(Be, m, u.lineOffsetX * Be, u.lineOffsetY * Be, !1, u, !1, He);
          let $e = !1, Je = !1, Qe = !0;
          if (We) {
            const wt = 0.5 * Z * Ie + $, bt = new a.P(-100, -100), Mt = new a.P(this.screenRightBoundary, this.screenBottomBoundary), Nt = new Oe(), Ct = We.first, sn = We.last;
            let nn = [];
            for (let Hn = Ct.path.length - 1; Hn >= 1; Hn--) nn.push(Ct.path[Hn]);
            for (let Hn = 1; Hn < sn.path.length; Hn++) nn.push(sn.path[Hn]);
            const Gt = 2.5 * wt;
            if (N) {
              const Hn = this.projectPathToScreenSpace(nn, He);
              nn = Hn.some((bi) => bi.signedDistanceFromCamera <= 0) ? [] : Hn.map((bi) => bi.point);
            }
            let dn = [];
            if (nn.length > 0) {
              const Hn = nn[0].clone(), bi = nn[0].clone();
              for (let Qi = 1; Qi < nn.length; Qi++) Hn.x = Math.min(Hn.x, nn[Qi].x), Hn.y = Math.min(Hn.y, nn[Qi].y), bi.x = Math.max(bi.x, nn[Qi].x), bi.y = Math.max(bi.y, nn[Qi].y);
              dn = Hn.x >= bt.x && bi.x <= Mt.x && Hn.y >= bt.y && bi.y <= Mt.y ? [nn] : bi.x < bt.x || Hn.x > Mt.x || bi.y < bt.y || Hn.y > Mt.y ? [] : a.ap([nn], bt.x, bt.y, Mt.x, Mt.y);
            }
            for (const Hn of dn) {
              Nt.reset(Hn, 0.25 * wt);
              let bi = 0;
              bi = Nt.length <= 0.5 * wt ? 1 : Math.ceil(Nt.paddedLength / Gt) + 1;
              for (let Qi = 0; Qi < bi; Qi++) {
                const Gi = Qi / Math.max(bi - 1, 1), er = Nt.lerp(Gi), Ci = er.x + ui, Ni = er.y + ui;
                Pe.push(Ci, Ni, wt, 0);
                const ki = Ci - wt, ps = Ni - wt, Mr = Ci + wt, zr = Ni + wt;
                if (Qe = Qe && this.isOffscreen(ki, ps, Mr, zr), Je = Je || this.isInsideGrid(ki, ps, Mr, zr), s !== "always" && this.grid.hitTestCircle(Ci, Ni, wt, s, G) && ($e = !0, !B)) return { circles: [], offscreen: !1, collisionDetected: $e };
              }
            }
          }
          return { circles: !B && $e || !Je || Ie < this.perspectiveRatioCutoff ? [] : Pe, offscreen: Qe, collisionDetected: $e };
        }
        projectPathToScreenSpace(s, u) {
          const p = function(m, x) {
            const E = a.J();
            return a.ah(E, x.pitchedLabelPlaneMatrix), m.map((L) => {
              const B = pt(L.x, L.y, E, x.getElevation), N = x.transform.projectTileCoordinates(B.point.x, B.point.y, x.unwrappedTileID, x.getElevation);
              return N.point.x = (0.5 * N.point.x + 0.5) * x.width, N.point.y = (0.5 * -N.point.y + 0.5) * x.height, N;
            });
          }(s, u);
          return function(m) {
            let x = 0, E = 0, L = 0, B = 0;
            for (let N = 0; N < m.length; N++) m[N].isOccluded ? (L = N + 1, B = 0) : (B++, B > E && (E = B, x = L));
            return m.slice(x, x + E);
          }(p);
        }
        queryRenderedSymbols(s) {
          if (s.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0) return {};
          const u = [];
          let p = 1 / 0, m = 1 / 0, x = -1 / 0, E = -1 / 0;
          for (const G of s) {
            const Z = new a.P(G.x + ui, G.y + ui);
            p = Math.min(p, Z.x), m = Math.min(m, Z.y), x = Math.max(x, Z.x), E = Math.max(E, Z.y), u.push(Z);
          }
          const L = this.grid.query(p, m, x, E).concat(this.ignoredGrid.query(p, m, x, E)), B = {}, N = {};
          for (const G of L) {
            const Z = G.key;
            if (B[Z.bucketInstanceId] === void 0 && (B[Z.bucketInstanceId] = {}), B[Z.bucketInstanceId][Z.featureIndex]) continue;
            const $ = [new a.P(G.x1, G.y1), new a.P(G.x2, G.y1), new a.P(G.x2, G.y2), new a.P(G.x1, G.y2)];
            a.aq(u, $) && (B[Z.bucketInstanceId][Z.featureIndex] = !0, N[Z.bucketInstanceId] === void 0 && (N[Z.bucketInstanceId] = []), N[Z.bucketInstanceId].push(Z.featureIndex));
          }
          return N;
        }
        insertCollisionBox(s, u, p, m, x, E) {
          (p ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: m, featureIndex: x, collisionGroupID: E, overlapMode: u }, s[0], s[1], s[2], s[3]);
        }
        insertCollisionCircles(s, u, p, m, x, E) {
          const L = p ? this.ignoredGrid : this.grid, B = { bucketInstanceId: m, featureIndex: x, collisionGroupID: E, overlapMode: u };
          for (let N = 0; N < s.length; N += 4) L.insertCircle(B, s[N], s[N + 1], s[N + 2]);
        }
        projectAndGetPerspectiveRatio(s, u, p, m, x) {
          if (x) {
            let E;
            m ? (E = [s, u, m(s, u), 1], a.an(E, E, x)) : (E = [s, u, 0, 1], Ii(E, E, x));
            const L = E[3];
            return { x: (E[0] / L + 1) / 2 * this.transform.width + ui, y: (-E[1] / L + 1) / 2 * this.transform.height + ui, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / L * 0.5, isOccluded: !1, signedDistanceFromCamera: L };
          }
          {
            const E = this.transform.projectTileCoordinates(s, u, p, m);
            return { x: (E.point.x + 1) / 2 * this.transform.width + ui, y: (1 - E.point.y) / 2 * this.transform.height + ui, perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / E.signedDistanceFromCamera * 0.5, isOccluded: E.isOccluded, signedDistanceFromCamera: E.signedDistanceFromCamera };
          }
        }
        getPerspectiveRatio(s, u, p, m) {
          const x = this.transform.projectTileCoordinates(s, u, p, m);
          return 0.5 + this.transform.cameraToCenterDistance / x.signedDistanceFromCamera * 0.5;
        }
        isOffscreen(s, u, p, m) {
          return p < ui || s >= this.screenRightBoundary || m < ui || u > this.screenBottomBoundary;
        }
        isInsideGrid(s, u, p, m) {
          return p >= 0 && s < this.gridRightBoundary && m >= 0 && u < this.gridBottomBoundary;
        }
        getViewportMatrix() {
          const s = a.ar([]);
          return a.K(s, s, [-100, -100, 0]), s;
        }
        _projectCollisionBox(s, u, p, m, x, E, L, B, N, G, Z) {
          let $ = 1, re = 0, ae = 0, Pe = 1;
          const Ce = s.anchorPointX + L[0], Ie = s.anchorPointY + L[1];
          if (E && !x) {
            const nn = this.projectAndGetPerspectiveRatio(Ce + 1, Ie, m, N, Z), Gt = nn.x - B.x, dn = Math.atan((nn.y - B.y) / Gt) + (Gt < 0 ? Math.PI : 0), Hn = Math.sin(dn), bi = Math.cos(dn);
            $ = bi, re = Hn, ae = -Hn, Pe = bi;
          } else if (!E && x) {
            const nn = at(this.transform);
            $ = nn.vecEast[0], re = nn.vecEast[1], ae = nn.vecSouth[0], Pe = nn.vecSouth[1];
          }
          let Be = B.x, He = B.y, We = u;
          x && (Be = Ce, He = Ie, We = Math.pow(2, -(this.transform.zoom - p.overscaledZ)), We *= this.transform.getPitchedTextCorrection(Ce, Ie, m), G || (We *= a.ac(0.5 + B.signedDistanceFromCamera / this.transform.cameraToCenterDistance * 0.5, 0, 4))), G && (Be += $ * G.x * We + ae * G.y * We, He += re * G.x * We + Pe * G.y * We);
          const $e = s.x1 * We, Je = s.x2 * We, Qe = ($e + Je) / 2, wt = s.y1 * We, bt = s.y2 * We, Mt = (wt + bt) / 2, Nt = [{ offsetX: $e, offsetY: wt }, { offsetX: Qe, offsetY: wt }, { offsetX: Je, offsetY: wt }, { offsetX: Je, offsetY: Mt }, { offsetX: Je, offsetY: bt }, { offsetX: Qe, offsetY: bt }, { offsetX: $e, offsetY: bt }, { offsetX: $e, offsetY: Mt }];
          let Ct = [];
          for (const { offsetX: nn, offsetY: Gt } of Nt) Ct.push(new a.P(Be + $ * nn + ae * Gt, He + re * nn + Pe * Gt));
          let sn = !1;
          if (x) {
            const nn = Ct.map((Gt) => this.projectAndGetPerspectiveRatio(Gt.x, Gt.y, m, N, Z));
            sn = nn.some((Gt) => !Gt.isOccluded), Ct = nn.map((Gt) => new a.P(Gt.x, Gt.y));
          } else sn = !0;
          return { box: a.as(Ct), allPointsOccluded: !sn };
        }
      }
      class _i {
        constructor(s, u, p, m) {
          this.opacity = s ? Math.max(0, Math.min(1, s.opacity + (s.placed ? u : -u))) : m && p ? 1 : 0, this.placed = p;
        }
        isHidden() {
          return this.opacity === 0 && !this.placed;
        }
      }
      class xs {
        constructor(s, u, p, m, x) {
          this.text = new _i(s ? s.text : null, u, p, x), this.icon = new _i(s ? s.icon : null, u, m, x);
        }
        isHidden() {
          return this.text.isHidden() && this.icon.isHidden();
        }
      }
      class ws {
        constructor(s, u, p) {
          this.text = s, this.icon = u, this.skipFade = p;
        }
      }
      class Ao {
        constructor(s, u, p, m, x) {
          this.bucketInstanceId = s, this.featureIndex = u, this.sourceLayerIndex = p, this.bucketIndex = m, this.tileID = x;
        }
      }
      class qs {
        constructor(s) {
          this.crossSourceCollisions = s, this.maxGroupID = 0, this.collisionGroups = {};
        }
        get(s) {
          if (this.crossSourceCollisions) return { ID: 0, predicate: null };
          if (!this.collisionGroups[s]) {
            const u = ++this.maxGroupID;
            this.collisionGroups[s] = { ID: u, predicate: (p) => p.collisionGroupID === u };
          }
          return this.collisionGroups[s];
        }
      }
      function To(b, s, u, p, m) {
        const { horizontalAlign: x, verticalAlign: E } = a.az(b);
        return new a.P(-(x - 0.5) * s + p[0] * m, -(E - 0.5) * u + p[1] * m);
      }
      class Ia {
        constructor(s, u, p, m, x) {
          this.transform = s.clone(), this.terrain = u, this.collisionIndex = new Oi(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = !1, this.commitTime = 0, this.fadeDuration = p, this.retainedQueryData = {}, this.collisionGroups = new qs(m), this.collisionCircleArrays = {}, this.collisionBoxArrays = /* @__PURE__ */ new Map(), this.prevPlacement = x, x && (x.prevPlacement = void 0), this.placedOrientations = {};
        }
        _getTerrainElevationFunc(s) {
          const u = this.terrain;
          return u ? (p, m) => u.getElevation(s, p, m) : null;
        }
        getBucketParts(s, u, p, m) {
          const x = p.getBucket(u), E = p.latestFeatureIndex;
          if (!x || !E || u.id !== x.layerIds[0]) return;
          const L = p.collisionBoxArray, B = x.layers[0].layout, N = x.layers[0].paint, G = Math.pow(2, this.transform.zoom - p.tileID.overscaledZ), Z = p.tileSize / a.Y, $ = p.tileID.toUnwrapped(), re = B.get("text-rotation-alignment") === "map", ae = a.au(p, 1, this.transform.zoom), Pe = a.av(this.collisionIndex.transform, p, N.get("text-translate"), N.get("text-translate-anchor")), Ce = a.av(this.collisionIndex.transform, p, N.get("icon-translate"), N.get("icon-translate-anchor")), Ie = mt(re, this.transform, ae);
          this.retainedQueryData[x.bucketInstanceId] = new Ao(x.bucketInstanceId, E, x.sourceLayerIndex, x.index, p.tileID);
          const Be = { bucket: x, layout: B, translationText: Pe, translationIcon: Ce, unwrappedTileID: $, pitchedLabelPlaneMatrix: Ie, scale: G, textPixelRatio: Z, holdingForFade: p.holdingForFade(), collisionBoxArray: L, partiallyEvaluatedTextSize: a.ae(x.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(x.sourceID) };
          if (m) for (const He of x.sortKeyRanges) {
            const { sortKey: We, symbolInstanceStart: $e, symbolInstanceEnd: Je } = He;
            s.push({ sortKey: We, symbolInstanceStart: $e, symbolInstanceEnd: Je, parameters: Be });
          }
          else s.push({ symbolInstanceStart: 0, symbolInstanceEnd: x.symbolInstances.length, parameters: Be });
        }
        attemptAnchorPlacement(s, u, p, m, x, E, L, B, N, G, Z, $, re, ae, Pe, Ce, Ie, Be, He, We) {
          const $e = a.aw[s.textAnchor], Je = [s.textOffset0, s.textOffset1], Qe = To($e, p, m, Je, x), wt = this.collisionIndex.placeCollisionBox(u, $, B, N, G, L, E, Ce, Z.predicate, He, Qe, We);
          if ((!Be || this.collisionIndex.placeCollisionBox(Be, $, B, N, G, L, E, Ie, Z.predicate, He, Qe, We).placeable) && wt.placeable) {
            let bt;
            if (this.prevPlacement && this.prevPlacement.variableOffsets[re.crossTileID] && this.prevPlacement.placements[re.crossTileID] && this.prevPlacement.placements[re.crossTileID].text && (bt = this.prevPlacement.variableOffsets[re.crossTileID].anchor), re.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            return this.variableOffsets[re.crossTileID] = { textOffset: Je, width: p, height: m, anchor: $e, textBoxScale: x, prevAnchor: bt }, this.markUsedJustification(ae, $e, re, Pe), ae.allowVerticalPlacement && (this.markUsedOrientation(ae, Pe, re), this.placedOrientations[re.crossTileID] = Pe), { shift: Qe, placedGlyphBoxes: wt };
          }
        }
        placeLayerBucketPart(s, u, p) {
          const { bucket: m, layout: x, translationText: E, translationIcon: L, unwrappedTileID: B, pitchedLabelPlaneMatrix: N, textPixelRatio: G, holdingForFade: Z, collisionBoxArray: $, partiallyEvaluatedTextSize: re, collisionGroup: ae } = s.parameters, Pe = x.get("text-optional"), Ce = x.get("icon-optional"), Ie = a.ax(x, "text-overlap", "text-allow-overlap"), Be = Ie === "always", He = a.ax(x, "icon-overlap", "icon-allow-overlap"), We = He === "always", $e = x.get("text-rotation-alignment") === "map", Je = x.get("text-pitch-alignment") === "map", Qe = x.get("icon-text-fit") !== "none", wt = x.get("symbol-z-order") === "viewport-y", bt = Be && (We || !m.hasIconData() || Ce), Mt = We && (Be || !m.hasTextData() || Pe);
          !m.collisionArrays && $ && m.deserializeCollisionBoxes($);
          const Nt = this.retainedQueryData[m.bucketInstanceId].tileID, Ct = this._getTerrainElevationFunc(Nt), sn = this.transform.getFastPathSimpleProjectionMatrix(Nt), nn = (Gt, dn, Hn) => {
            var bi, Qi;
            if (u[Gt.crossTileID]) return;
            if (Z) return void (this.placements[Gt.crossTileID] = new ws(!1, !1, !1));
            let Gi = !1, er = !1, Ci = !0, Ni = null, ki = { box: null, placeable: !1, offscreen: null, occluded: !1 }, ps = { placeable: !1 }, Mr = null, zr = null, Gr = null, ia = 0, bo = 0, Lr = 0;
            dn.textFeatureIndex ? ia = dn.textFeatureIndex : Gt.useRuntimeCollisionCircles && (ia = Gt.featureIndex), dn.verticalTextFeatureIndex && (bo = dn.verticalTextFeatureIndex);
            const Cs = dn.textBox;
            if (Cs) {
              const Ns = (Xi) => {
                let gr = a.af.horizontal;
                if (m.allowVerticalPlacement && !Xi && this.prevPlacement) {
                  const ra = this.prevPlacement.placedOrientations[Gt.crossTileID];
                  ra && (this.placedOrientations[Gt.crossTileID] = ra, gr = ra, this.markUsedOrientation(m, gr, Gt));
                }
                return gr;
              }, Do = (Xi, gr) => {
                if (m.allowVerticalPlacement && Gt.numVerticalGlyphVertices > 0 && dn.verticalTextBox) {
                  for (const ra of m.writingModes) if (ra === a.af.vertical ? (ki = gr(), ps = ki) : ki = Xi(), ki && ki.placeable) break;
                } else ki = Xi();
              }, io = Gt.textAnchorOffsetStartIndex, ks = Gt.textAnchorOffsetEndIndex;
              if (ks === io) {
                const Xi = (gr, ra) => {
                  const wr = this.collisionIndex.placeCollisionBox(gr, Ie, G, Nt, B, Je, $e, E, ae.predicate, Ct, void 0, sn);
                  return wr && wr.placeable && (this.markUsedOrientation(m, ra, Gt), this.placedOrientations[Gt.crossTileID] = ra), wr;
                };
                Do(() => Xi(Cs, a.af.horizontal), () => {
                  const gr = dn.verticalTextBox;
                  return m.allowVerticalPlacement && Gt.numVerticalGlyphVertices > 0 && gr ? Xi(gr, a.af.vertical) : { box: null, offscreen: null };
                }), Ns(ki && ki.placeable);
              } else {
                let Xi = a.aw[(Qi = (bi = this.prevPlacement) === null || bi === void 0 ? void 0 : bi.variableOffsets[Gt.crossTileID]) === null || Qi === void 0 ? void 0 : Qi.anchor];
                const gr = (wr, b_, tg) => {
                  const wf = wr.x2 - wr.x1, ng = wr.y2 - wr.y1, yu = Gt.textBoxScale, bu = Qe && He === "never" ? b_ : null;
                  let Uc = null, ig = Ie === "never" ? 1 : 2, fd = "never";
                  Xi && ig++;
                  for (let Af = 0; Af < ig; Af++) {
                    for (let Tf = io; Tf < ks; Tf++) {
                      const Ef = m.textAnchorOffsets.get(Tf);
                      if (Xi && Ef.textAnchor !== Xi) continue;
                      const Sf = this.attemptAnchorPlacement(Ef, wr, wf, ng, yu, $e, Je, G, Nt, B, ae, fd, Gt, m, tg, E, L, bu, Ct);
                      if (Sf && (Uc = Sf.placedGlyphBoxes, Uc && Uc.placeable)) return Gi = !0, Ni = Sf.shift, Uc;
                    }
                    Xi ? Xi = null : fd = Ie;
                  }
                  return p && !Uc && (Uc = { box: this.collisionIndex.placeCollisionBox(Cs, "always", G, Nt, B, Je, $e, E, ae.predicate, Ct, void 0, sn).box, offscreen: !1, placeable: !1, occluded: !1 }), Uc;
                };
                Do(() => gr(Cs, dn.iconBox, a.af.horizontal), () => {
                  const wr = dn.verticalTextBox;
                  return m.allowVerticalPlacement && (!ki || !ki.placeable) && Gt.numVerticalGlyphVertices > 0 && wr ? gr(wr, dn.verticalIconBox, a.af.vertical) : { box: null, occluded: !0, offscreen: null };
                }), ki && (Gi = ki.placeable, Ci = ki.offscreen);
                const ra = Ns(ki && ki.placeable);
                if (!Gi && this.prevPlacement) {
                  const wr = this.prevPlacement.variableOffsets[Gt.crossTileID];
                  wr && (this.variableOffsets[Gt.crossTileID] = wr, this.markUsedJustification(m, wr.anchor, Gt, ra));
                }
              }
            }
            if (Mr = ki, Gi = Mr && Mr.placeable, Ci = Mr && Mr.offscreen, Gt.useRuntimeCollisionCircles) {
              const Ns = m.text.placedSymbolArray.get(Gt.centerJustifiedTextSymbolIndex), Do = a.ag(m.textSizeData, re, Ns), io = x.get("text-padding");
              zr = this.collisionIndex.placeCollisionCircles(Ie, Ns, m.lineVertexArray, m.glyphOffsetArray, Do, B, N, p, Je, ae.predicate, Gt.collisionCircleDiameter, io, E, Ct), zr.circles.length && zr.collisionDetected && !p && a.w("Collisions detected, but collision boxes are not shown"), Gi = Be || zr.circles.length > 0 && !zr.collisionDetected, Ci = Ci && zr.offscreen;
            }
            if (dn.iconFeatureIndex && (Lr = dn.iconFeatureIndex), dn.iconBox) {
              const Ns = (Do) => this.collisionIndex.placeCollisionBox(Do, He, G, Nt, B, Je, $e, L, ae.predicate, Ct, Qe && Ni ? Ni : void 0, sn);
              ps && ps.placeable && dn.verticalIconBox ? (Gr = Ns(dn.verticalIconBox), er = Gr.placeable) : (Gr = Ns(dn.iconBox), er = Gr.placeable), Ci = Ci && Gr.offscreen;
            }
            const Oo = Pe || Gt.numHorizontalGlyphVertices === 0 && Gt.numVerticalGlyphVertices === 0, bl = Ce || Gt.numIconVertices === 0;
            Oo || bl ? bl ? Oo || (er = er && Gi) : Gi = er && Gi : er = Gi = er && Gi;
            const vl = er && Gr.placeable;
            if (Gi && Mr.placeable && this.collisionIndex.insertCollisionBox(Mr.box, Ie, x.get("text-ignore-placement"), m.bucketInstanceId, ps && ps.placeable && bo ? bo : ia, ae.ID), vl && this.collisionIndex.insertCollisionBox(Gr.box, He, x.get("icon-ignore-placement"), m.bucketInstanceId, Lr, ae.ID), zr && Gi && this.collisionIndex.insertCollisionCircles(zr.circles, Ie, x.get("text-ignore-placement"), m.bucketInstanceId, ia, ae.ID), p && this.storeCollisionData(m.bucketInstanceId, Hn, dn, Mr, Gr, zr), Gt.crossTileID === 0) throw new Error("symbolInstance.crossTileID can't be 0");
            if (m.bucketInstanceId === 0) throw new Error("bucket.bucketInstanceId can't be 0");
            this.placements[Gt.crossTileID] = new ws((Gi || bt) && !(Mr != null && Mr.occluded), (er || Mt) && !(Gr != null && Gr.occluded), Ci || m.justReloaded), u[Gt.crossTileID] = !0;
          };
          if (wt) {
            if (s.symbolInstanceStart !== 0) throw new Error("bucket.bucketInstanceId should be 0");
            const Gt = m.getSortedSymbolIndexes(-this.transform.bearingInRadians);
            for (let dn = Gt.length - 1; dn >= 0; --dn) {
              const Hn = Gt[dn];
              nn(m.symbolInstances.get(Hn), m.collisionArrays[Hn], Hn);
            }
          } else for (let Gt = s.symbolInstanceStart; Gt < s.symbolInstanceEnd; Gt++) nn(m.symbolInstances.get(Gt), m.collisionArrays[Gt], Gt);
          m.justReloaded = !1;
        }
        storeCollisionData(s, u, p, m, x, E) {
          if (p.textBox || p.iconBox) {
            let L, B;
            this.collisionBoxArrays.has(s) ? L = this.collisionBoxArrays.get(s) : (L = /* @__PURE__ */ new Map(), this.collisionBoxArrays.set(s, L)), L.has(u) ? B = L.get(u) : (B = { text: null, icon: null }, L.set(u, B)), p.textBox && (B.text = m.box), p.iconBox && (B.icon = x.box);
          }
          if (E) {
            let L = this.collisionCircleArrays[s];
            L === void 0 && (L = this.collisionCircleArrays[s] = []);
            for (let B = 0; B < E.circles.length; B += 4) L.push(E.circles[B + 0] - ui), L.push(E.circles[B + 1] - ui), L.push(E.circles[B + 2]), L.push(E.collisionDetected ? 1 : 0);
          }
        }
        markUsedJustification(s, u, p, m) {
          let x;
          x = m === a.af.vertical ? p.verticalPlacedTextSymbolIndex : { left: p.leftJustifiedTextSymbolIndex, center: p.centerJustifiedTextSymbolIndex, right: p.rightJustifiedTextSymbolIndex }[a.ay(u)];
          const E = [p.leftJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.rightJustifiedTextSymbolIndex, p.verticalPlacedTextSymbolIndex];
          for (const L of E) L >= 0 && (s.text.placedSymbolArray.get(L).crossTileID = x >= 0 && L !== x ? 0 : p.crossTileID);
        }
        markUsedOrientation(s, u, p) {
          const m = u === a.af.horizontal || u === a.af.horizontalOnly ? u : 0, x = u === a.af.vertical ? u : 0, E = [p.leftJustifiedTextSymbolIndex, p.centerJustifiedTextSymbolIndex, p.rightJustifiedTextSymbolIndex];
          for (const L of E) s.text.placedSymbolArray.get(L).placedOrientation = m;
          p.verticalPlacedTextSymbolIndex && (s.text.placedSymbolArray.get(p.verticalPlacedTextSymbolIndex).placedOrientation = x);
        }
        commit(s) {
          this.commitTime = s, this.zoomAtLastRecencyCheck = this.transform.zoom;
          const u = this.prevPlacement;
          let p = !1;
          this.prevZoomAdjustment = u ? u.zoomAdjustment(this.transform.zoom) : 0;
          const m = u ? u.symbolFadeChange(s) : 1, x = u ? u.opacities : {}, E = u ? u.variableOffsets : {}, L = u ? u.placedOrientations : {};
          for (const B in this.placements) {
            const N = this.placements[B], G = x[B];
            G ? (this.opacities[B] = new xs(G, m, N.text, N.icon), p = p || N.text !== G.text.placed || N.icon !== G.icon.placed) : (this.opacities[B] = new xs(null, m, N.text, N.icon, N.skipFade), p = p || N.text || N.icon);
          }
          for (const B in x) {
            const N = x[B];
            if (!this.opacities[B]) {
              const G = new xs(N, m, !1, !1);
              G.isHidden() || (this.opacities[B] = G, p = p || N.text.placed || N.icon.placed);
            }
          }
          for (const B in E) this.variableOffsets[B] || !this.opacities[B] || this.opacities[B].isHidden() || (this.variableOffsets[B] = E[B]);
          for (const B in L) this.placedOrientations[B] || !this.opacities[B] || this.opacities[B].isHidden() || (this.placedOrientations[B] = L[B]);
          if (u && u.lastPlacementChangeTime === void 0) throw new Error("Last placement time for previous placement is not defined");
          p ? this.lastPlacementChangeTime = s : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = u ? u.lastPlacementChangeTime : s);
        }
        updateLayerOpacities(s, u) {
          const p = {};
          for (const m of u) {
            const x = m.getBucket(s);
            x && m.latestFeatureIndex && s.id === x.layerIds[0] && this.updateBucketOpacities(x, m.tileID, p, m.collisionBoxArray);
          }
        }
        updateBucketOpacities(s, u, p, m) {
          s.hasTextData() && (s.text.opacityVertexArray.clear(), s.text.hasVisibleVertices = !1), s.hasIconData() && (s.icon.opacityVertexArray.clear(), s.icon.hasVisibleVertices = !1), s.hasIconCollisionBoxData() && s.iconCollisionBox.collisionVertexArray.clear(), s.hasTextCollisionBoxData() && s.textCollisionBox.collisionVertexArray.clear();
          const x = s.layers[0], E = x.layout, L = new xs(null, 0, !1, !1, !0), B = E.get("text-allow-overlap"), N = E.get("icon-allow-overlap"), G = x._unevaluatedLayout.hasValue("text-variable-anchor") || x._unevaluatedLayout.hasValue("text-variable-anchor-offset"), Z = E.get("text-rotation-alignment") === "map", $ = E.get("text-pitch-alignment") === "map", re = E.get("icon-text-fit") !== "none", ae = new xs(null, 0, B && (N || !s.hasIconData() || E.get("icon-optional")), N && (B || !s.hasTextData() || E.get("text-optional")), !0);
          !s.collisionArrays && m && (s.hasIconCollisionBoxData() || s.hasTextCollisionBoxData()) && s.deserializeCollisionBoxes(m);
          const Pe = (Ie, Be, He) => {
            for (let We = 0; We < Be / 4; We++) Ie.opacityVertexArray.emplaceBack(He);
            Ie.hasVisibleVertices = Ie.hasVisibleVertices || He !== Xs;
          }, Ce = this.collisionBoxArrays.get(s.bucketInstanceId);
          for (let Ie = 0; Ie < s.symbolInstances.length; Ie++) {
            const Be = s.symbolInstances.get(Ie), { numHorizontalGlyphVertices: He, numVerticalGlyphVertices: We, crossTileID: $e } = Be;
            let Je = this.opacities[$e];
            p[$e] ? Je = L : Je || (Je = ae, this.opacities[$e] = Je), p[$e] = !0;
            const Qe = Be.numIconVertices > 0, wt = this.placedOrientations[Be.crossTileID], bt = wt === a.af.vertical, Mt = wt === a.af.horizontal || wt === a.af.horizontalOnly;
            if (He > 0 || We > 0) {
              const Ct = Xo(Je.text);
              Pe(s.text, He, bt ? Xs : Ct), Pe(s.text, We, Mt ? Xs : Ct);
              const sn = Je.text.isHidden();
              [Be.rightJustifiedTextSymbolIndex, Be.centerJustifiedTextSymbolIndex, Be.leftJustifiedTextSymbolIndex].forEach((dn) => {
                dn >= 0 && (s.text.placedSymbolArray.get(dn).hidden = sn || bt ? 1 : 0);
              }), Be.verticalPlacedTextSymbolIndex >= 0 && (s.text.placedSymbolArray.get(Be.verticalPlacedTextSymbolIndex).hidden = sn || Mt ? 1 : 0);
              const nn = this.variableOffsets[Be.crossTileID];
              nn && this.markUsedJustification(s, nn.anchor, Be, wt);
              const Gt = this.placedOrientations[Be.crossTileID];
              Gt && (this.markUsedJustification(s, "left", Be, Gt), this.markUsedOrientation(s, Gt, Be));
            }
            if (Qe) {
              const Ct = Xo(Je.icon), sn = !(re && Be.verticalPlacedIconSymbolIndex && bt);
              Be.placedIconSymbolIndex >= 0 && (Pe(s.icon, Be.numIconVertices, sn ? Ct : Xs), s.icon.placedSymbolArray.get(Be.placedIconSymbolIndex).hidden = Je.icon.isHidden()), Be.verticalPlacedIconSymbolIndex >= 0 && (Pe(s.icon, Be.numVerticalIconVertices, sn ? Xs : Ct), s.icon.placedSymbolArray.get(Be.verticalPlacedIconSymbolIndex).hidden = Je.icon.isHidden());
            }
            const Nt = Ce && Ce.has(Ie) ? Ce.get(Ie) : { text: null, icon: null };
            if (s.hasIconCollisionBoxData() || s.hasTextCollisionBoxData()) {
              const Ct = s.collisionArrays[Ie];
              if (Ct) {
                let sn = new a.P(0, 0);
                if (Ct.textBox || Ct.verticalTextBox) {
                  let nn = !0;
                  if (G) {
                    const Gt = this.variableOffsets[$e];
                    Gt ? (sn = To(Gt.anchor, Gt.width, Gt.height, Gt.textOffset, Gt.textBoxScale), Z && sn._rotate($ ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : nn = !1;
                  }
                  if (Ct.textBox || Ct.verticalTextBox) {
                    let Gt;
                    Ct.textBox && (Gt = bt), Ct.verticalTextBox && (Gt = Mt), Hr(s.textCollisionBox.collisionVertexArray, Je.text.placed, !nn || Gt, Nt.text, sn.x, sn.y);
                  }
                }
                if (Ct.iconBox || Ct.verticalIconBox) {
                  const nn = !!(!Mt && Ct.verticalIconBox);
                  let Gt;
                  Ct.iconBox && (Gt = nn), Ct.verticalIconBox && (Gt = !nn), Hr(s.iconCollisionBox.collisionVertexArray, Je.icon.placed, Gt, Nt.icon, re ? sn.x : 0, re ? sn.y : 0);
                }
              }
            }
          }
          if (s.sortFeatures(-this.transform.bearingInRadians), this.retainedQueryData[s.bucketInstanceId] && (this.retainedQueryData[s.bucketInstanceId].featureSortOrder = s.featureSortOrder), s.hasTextData() && s.text.opacityVertexBuffer && s.text.opacityVertexBuffer.updateData(s.text.opacityVertexArray), s.hasIconData() && s.icon.opacityVertexBuffer && s.icon.opacityVertexBuffer.updateData(s.icon.opacityVertexArray), s.hasIconCollisionBoxData() && s.iconCollisionBox.collisionVertexBuffer && s.iconCollisionBox.collisionVertexBuffer.updateData(s.iconCollisionBox.collisionVertexArray), s.hasTextCollisionBoxData() && s.textCollisionBox.collisionVertexBuffer && s.textCollisionBox.collisionVertexBuffer.updateData(s.textCollisionBox.collisionVertexArray), s.text.opacityVertexArray.length !== s.text.layoutVertexArray.length / 4) throw new Error(`bucket.text.opacityVertexArray.length (= ${s.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${s.text.layoutVertexArray.length}) / 4`);
          if (s.icon.opacityVertexArray.length !== s.icon.layoutVertexArray.length / 4) throw new Error(`bucket.icon.opacityVertexArray.length (= ${s.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${s.icon.layoutVertexArray.length}) / 4`);
          s.bucketInstanceId in this.collisionCircleArrays && (s.collisionCircleArray = this.collisionCircleArrays[s.bucketInstanceId], delete this.collisionCircleArrays[s.bucketInstanceId]);
        }
        symbolFadeChange(s) {
          return this.fadeDuration === 0 ? 1 : (s - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
        }
        zoomAdjustment(s) {
          return Math.max(0, (this.transform.zoom - s) / 1.5);
        }
        hasTransitions(s) {
          return this.stale || s - this.lastPlacementChangeTime < this.fadeDuration;
        }
        stillRecent(s, u) {
          const p = this.zoomAtLastRecencyCheck === u ? 1 - this.zoomAdjustment(u) : 1;
          return this.zoomAtLastRecencyCheck = u, this.commitTime + this.fadeDuration * p > s;
        }
        setStale() {
          this.stale = !0;
        }
      }
      function Hr(b, s, u, p, m, x) {
        p && p.length !== 0 || (p = [0, 0, 0, 0]);
        const E = p[0] - ui, L = p[1] - ui, B = p[2] - ui, N = p[3] - ui;
        b.emplaceBack(s ? 1 : 0, u ? 1 : 0, m || 0, x || 0, E, L), b.emplaceBack(s ? 1 : 0, u ? 1 : 0, m || 0, x || 0, B, L), b.emplaceBack(s ? 1 : 0, u ? 1 : 0, m || 0, x || 0, B, N), b.emplaceBack(s ? 1 : 0, u ? 1 : 0, m || 0, x || 0, E, N);
      }
      const Hs = Math.pow(2, 25), Wr = Math.pow(2, 24), Ws = Math.pow(2, 17), $o = Math.pow(2, 16), Zs = Math.pow(2, 9), $s = Math.pow(2, 8), Il = Math.pow(2, 1);
      function Xo(b) {
        if (b.opacity === 0 && !b.placed) return 0;
        if (b.opacity === 1 && b.placed) return 4294967295;
        const s = b.placed ? 1 : 0, u = Math.floor(127 * b.opacity);
        return u * Hs + s * Wr + u * Ws + s * $o + u * Zs + s * $s + u * Il + s;
      }
      const Xs = 0;
      class Ti {
        constructor(s) {
          this._sortAcrossTiles = s.layout.get("symbol-z-order") !== "viewport-y" && !s.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
        }
        continuePlacement(s, u, p, m, x) {
          const E = this._bucketParts;
          for (; this._currentTileIndex < s.length; ) if (u.getBucketParts(E, m, s[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, x()) return !0;
          for (this._sortAcrossTiles && (this._sortAcrossTiles = !1, E.sort((L, B) => L.sortKey - B.sortKey)); this._currentPartIndex < E.length; ) if (u.placeLayerBucketPart(E[this._currentPartIndex], this._seenCrossTileIDs, p), this._currentPartIndex++, x()) return !0;
          return !1;
        }
      }
      class ha {
        constructor(s, u, p, m, x, E, L, B) {
          this.placement = new Ia(s, u, E, L, B), this._currentPlacementIndex = p.length - 1, this._forceFullPlacement = m, this._showCollisionBoxes = x, this._done = !1;
        }
        isDone() {
          return this._done;
        }
        continuePlacement(s, u, p) {
          const m = I.now(), x = () => !this._forceFullPlacement && I.now() - m > 2;
          for (; this._currentPlacementIndex >= 0; ) {
            const E = u[s[this._currentPlacementIndex]], L = this.placement.collisionIndex.transform.zoom;
            if (E.type === "symbol" && (!E.minzoom || E.minzoom <= L) && (!E.maxzoom || E.maxzoom > L)) {
              if (this._inProgressLayer || (this._inProgressLayer = new Ti(E)), this._inProgressLayer.continuePlacement(p[E.source], this.placement, this._showCollisionBoxes, E, x)) return;
              delete this._inProgressLayer;
            }
            this._currentPlacementIndex--;
          }
          this._done = !0;
        }
        commit(s) {
          return this.placement.commit(s), this.placement;
        }
      }
      const Ys = 512 / a.Y / 2;
      class da {
        constructor(s, u, p) {
          this.tileID = s, this.bucketInstanceId = p, this._symbolsByKey = {};
          const m = /* @__PURE__ */ new Map();
          for (let x = 0; x < u.length; x++) {
            const E = u.get(x), L = E.key, B = m.get(L);
            B ? B.push(E) : m.set(L, [E]);
          }
          for (const [x, E] of m) {
            const L = { positions: E.map((B) => ({ x: Math.floor(B.anchorX * Ys), y: Math.floor(B.anchorY * Ys) })), crossTileIDs: E.map((B) => B.crossTileID) };
            if (L.positions.length > 128) {
              const B = new a.aA(L.positions.length, 16, Uint16Array);
              for (const { x: N, y: G } of L.positions) B.add(N, G);
              B.finish(), delete L.positions, L.index = B;
            }
            this._symbolsByKey[x] = L;
          }
        }
        getScaledCoordinates(s, u) {
          const { x: p, y: m, z: x } = this.tileID.canonical, { x: E, y: L, z: B } = u.canonical, N = Ys / Math.pow(2, B - x), G = (L * a.Y + s.anchorY) * N, Z = m * a.Y * Ys;
          return { x: Math.floor((E * a.Y + s.anchorX) * N - p * a.Y * Ys), y: Math.floor(G - Z) };
        }
        findMatches(s, u, p) {
          const m = this.tileID.canonical.z < u.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - u.canonical.z);
          for (let x = 0; x < s.length; x++) {
            const E = s.get(x);
            if (E.crossTileID) continue;
            const L = this._symbolsByKey[E.key];
            if (!L) continue;
            const B = this.getScaledCoordinates(E, u);
            if (L.index) {
              const N = L.index.range(B.x - m, B.y - m, B.x + m, B.y + m).sort();
              for (const G of N) {
                const Z = L.crossTileIDs[G];
                if (!p[Z]) {
                  p[Z] = !0, E.crossTileID = Z;
                  break;
                }
              }
            } else if (L.positions) for (let N = 0; N < L.positions.length; N++) {
              const G = L.positions[N], Z = L.crossTileIDs[N];
              if (Math.abs(G.x - B.x) <= m && Math.abs(G.y - B.y) <= m && !p[Z]) {
                p[Z] = !0, E.crossTileID = Z;
                break;
              }
            }
          }
        }
        getCrossTileIDsLists() {
          return Object.values(this._symbolsByKey).map((s) => {
            let { crossTileIDs: u } = s;
            return u;
          });
        }
      }
      class Eo {
        constructor() {
          this.maxCrossTileID = 0;
        }
        generate() {
          return ++this.maxCrossTileID;
        }
      }
      class sl {
        constructor() {
          this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
        }
        handleWrapJump(s) {
          const u = Math.round((s - this.lng) / 360);
          if (u !== 0) for (const p in this.indexes) {
            const m = this.indexes[p], x = {};
            for (const E in m) {
              const L = m[E];
              L.tileID = L.tileID.unwrapTo(L.tileID.wrap + u), x[L.tileID.key] = L;
            }
            this.indexes[p] = x;
          }
          this.lng = s;
        }
        addBucket(s, u, p) {
          if (this.indexes[s.overscaledZ] && this.indexes[s.overscaledZ][s.key]) {
            if (this.indexes[s.overscaledZ][s.key].bucketInstanceId === u.bucketInstanceId) return !1;
            this.removeBucketCrossTileIDs(s.overscaledZ, this.indexes[s.overscaledZ][s.key]);
          }
          for (let x = 0; x < u.symbolInstances.length; x++) u.symbolInstances.get(x).crossTileID = 0;
          this.usedCrossTileIDs[s.overscaledZ] || (this.usedCrossTileIDs[s.overscaledZ] = {});
          const m = this.usedCrossTileIDs[s.overscaledZ];
          for (const x in this.indexes) {
            const E = this.indexes[x];
            if (Number(x) > s.overscaledZ) for (const L in E) {
              const B = E[L];
              B.tileID.isChildOf(s) && B.findMatches(u.symbolInstances, s, m);
            }
            else {
              const L = E[s.scaledTo(Number(x)).key];
              L && L.findMatches(u.symbolInstances, s, m);
            }
          }
          for (let x = 0; x < u.symbolInstances.length; x++) {
            const E = u.symbolInstances.get(x);
            E.crossTileID || (E.crossTileID = p.generate(), m[E.crossTileID] = !0);
          }
          return this.indexes[s.overscaledZ] === void 0 && (this.indexes[s.overscaledZ] = {}), this.indexes[s.overscaledZ][s.key] = new da(s, u.symbolInstances, u.bucketInstanceId), !0;
        }
        removeBucketCrossTileIDs(s, u) {
          for (const p of u.getCrossTileIDsLists()) for (const m of p) delete this.usedCrossTileIDs[s][m];
        }
        removeStaleBuckets(s) {
          let u = !1;
          for (const p in this.indexes) {
            const m = this.indexes[p];
            for (const x in m) s[m[x].bucketInstanceId] || (this.removeBucketCrossTileIDs(p, m[x]), delete m[x], u = !0);
          }
          return u;
        }
      }
      class yr {
        constructor() {
          this.layerIndexes = {}, this.crossTileIDs = new Eo(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
        }
        addLayer(s, u, p) {
          let m = this.layerIndexes[s.id];
          m === void 0 && (m = this.layerIndexes[s.id] = new sl());
          let x = !1;
          const E = {};
          m.handleWrapJump(p);
          for (const L of u) {
            const B = L.getBucket(s);
            B && s.id === B.layerIds[0] && (B.bucketInstanceId || (B.bucketInstanceId = ++this.maxBucketInstanceId), m.addBucket(L.tileID, B, this.crossTileIDs) && (x = !0), E[B.bucketInstanceId] = !0);
          }
          return m.removeStaleBuckets(E) && (x = !0), x;
        }
        pruneUnusedLayers(s) {
          const u = {};
          s.forEach((p) => {
            u[p] = !0;
          });
          for (const p in this.layerIndexes) u[p] || delete this.layerIndexes[p];
        }
      }
      var os = "void main() {fragColor=vec4(1.0);}";
      const nr = { prelude: Xn(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`), projectionMercator: Xn("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"), projectionGlobe: Xn("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`), background: Xn(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), backgroundPattern: Xn(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: Xn(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`), clippingMask: Xn(os, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"), heatmap: Xn(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`), heatmapTexture: Xn(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: Xn("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: Xn("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Xn("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"), depth: Xn(os, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`), fill: Xn(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`), fillOutline: Xn(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillOutlinePattern: Xn(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`), fillPattern: Xn(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`), fillExtrusion: Xn(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`), fillExtrusionPattern: Xn(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`), hillshadePrepare: Xn(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));fragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Xn(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"), line: Xn(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), lineGradient: Xn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`), linePattern: Xn(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`), lineSDF: Xn(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`), raster: Xn(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`), symbolIcon: Xn(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`), symbolSDF: Xn(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`), symbolTextAndIcon: Xn(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`), terrain: Xn("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"), terrainDepth: Xn("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"), terrainCoords: Xn("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"), projectionErrorMeasurement: Xn("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"), atmosphere: Xn(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"), sky: Xn("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}") };
      function Xn(b, s) {
        const u = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, p = s.match(/in ([\w]+) ([\w]+)/g), m = b.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), x = s.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), E = x ? x.concat(m) : m, L = {};
        return { fragmentSource: b = b.replace(u, (B, N, G, Z, $) => (L[$] = !0, N === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
in ${G} ${Z} ${$};
#else
uniform ${G} ${Z} u_${$};
#endif
` : `
#ifdef HAS_UNIFORM_u_${$}
    ${G} ${Z} ${$} = u_${$};
#endif
`)), vertexSource: s = s.replace(u, (B, N, G, Z, $) => {
          const re = Z === "float" ? "vec2" : "vec4", ae = $.match(/color/) ? "color" : re;
          return L[$] ? N === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
uniform lowp float u_${$}_t;
in ${G} ${re} a_${$};
out ${G} ${Z} ${$};
#else
uniform ${G} ${Z} u_${$};
#endif
` : ae === "vec4" ? `
#ifndef HAS_UNIFORM_u_${$}
    ${$} = a_${$};
#else
    ${G} ${Z} ${$} = u_${$};
#endif
` : `
#ifndef HAS_UNIFORM_u_${$}
    ${$} = unpack_mix_${ae}(a_${$}, u_${$}_t);
#else
    ${G} ${Z} ${$} = u_${$};
#endif
` : N === "define" ? `
#ifndef HAS_UNIFORM_u_${$}
uniform lowp float u_${$}_t;
in ${G} ${re} a_${$};
#else
uniform ${G} ${Z} u_${$};
#endif
` : ae === "vec4" ? `
#ifndef HAS_UNIFORM_u_${$}
    ${G} ${Z} ${$} = a_${$};
#else
    ${G} ${Z} ${$} = u_${$};
#endif
` : `
#ifndef HAS_UNIFORM_u_${$}
    ${G} ${Z} ${$} = unpack_mix_${ae}(a_${$}, u_${$}_t);
#else
    ${G} ${Z} ${$} = u_${$};
#endif
`;
        }), staticAttributes: p, staticUniforms: E };
      }
      class as {
        constructor(s, u, p) {
          this.vertexBuffer = s, this.indexBuffer = u, this.segments = p;
        }
        destroy() {
          this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.vertexBuffer = null, this.indexBuffer = null, this.segments = null;
        }
      }
      var Qn = a.aB([{ name: "a_pos", type: "Int16", components: 2 }]);
      const Ma = "#define PROJECTION_MERCATOR", Ec = "mercator";
      class ge {
        constructor() {
          this._cachedMesh = null;
        }
        get name() {
          return "mercator";
        }
        get useSubdivision() {
          return !1;
        }
        get shaderVariantName() {
          return Ec;
        }
        get shaderDefine() {
          return Ma;
        }
        get shaderPreludeCode() {
          return nr.projectionMercator;
        }
        get vertexShaderPreludeCode() {
          return nr.projectionMercator.vertexSource;
        }
        get subdivisionGranularity() {
          return a.aC.noSubdivision;
        }
        get useGlobeControls() {
          return !1;
        }
        get transitionState() {
          return 0;
        }
        get latitudeErrorCorrectionRadians() {
          return 0;
        }
        destroy() {
        }
        updateGPUdependent(s) {
        }
        getMeshFromTileID(s, u, p, m, x) {
          if (this._cachedMesh) return this._cachedMesh;
          const E = new a.aD();
          E.emplaceBack(0, 0), E.emplaceBack(a.Y, 0), E.emplaceBack(0, a.Y), E.emplaceBack(a.Y, a.Y);
          const L = s.createVertexBuffer(E, Qn.members), B = a.aE.simpleSegment(0, 0, 4, 2), N = new a.aF();
          N.emplaceBack(1, 0, 2), N.emplaceBack(1, 2, 3);
          const G = s.createIndexBuffer(N);
          return this._cachedMesh = new as(L, G, B), this._cachedMesh;
        }
        recalculate() {
        }
        hasTransition() {
          return !1;
        }
        setErrorQueryLatitudeDegrees(s) {
        }
      }
      function we(b, s) {
        const u = a.ac(s.lat, -85.051129, a.aH);
        return new a.P(a.S(s.lng) * b, a.Q(u) * b);
      }
      function Ve(b, s) {
        return new a.Z(s.x / b, s.y / b).toLngLat();
      }
      function _t(b) {
        return b.cameraToCenterDistance * Math.min(0.85 * Math.tan(a.ab(90 - b.pitch)), Math.tan(a.ab(89.25 - b.pitch)));
      }
      function Kt(b, s) {
        const u = b.canonical, p = s / a.aG(u.z), m = u.x + Math.pow(2, u.z) * b.wrap, x = a.ar(new Float64Array(16));
        return a.K(x, x, [m * p, u.y * p, 0]), a.L(x, x, [p / a.Y, p / a.Y, 1]), x;
      }
      function gn(b, s, u, p, m) {
        const x = a.Z.fromLngLat(b, s), E = m * a.aI(1, b.lat), L = E * Math.cos(a.ab(u)), B = Math.sqrt(E * E - L * L), N = B * Math.sin(a.ab(-p)), G = B * Math.cos(a.ab(-p));
        return new a.Z(x.x + N, x.y + G, x.z + L);
      }
      class Rn {
        constructor() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          if (isNaN(s) || s < 0 || isNaN(u) || u < 0 || isNaN(p) || p < 0 || isNaN(m) || m < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
          this.top = s, this.bottom = u, this.left = p, this.right = m;
        }
        interpolate(s, u, p) {
          return u.top != null && s.top != null && (this.top = a.z.number(s.top, u.top, p)), u.bottom != null && s.bottom != null && (this.bottom = a.z.number(s.bottom, u.bottom, p)), u.left != null && s.left != null && (this.left = a.z.number(s.left, u.left, p)), u.right != null && s.right != null && (this.right = a.z.number(s.right, u.right, p)), this;
        }
        getCenter(s, u) {
          const p = a.ac((this.left + s - this.right) / 2, 0, s), m = a.ac((this.top + u - this.bottom) / 2, 0, u);
          return new a.P(p, m);
        }
        equals(s) {
          return this.top === s.top && this.bottom === s.bottom && this.left === s.left && this.right === s.right;
        }
        clone() {
          return new Rn(this.top, this.bottom, this.left, this.right);
        }
        toJSON() {
          return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
        }
      }
      function hi(b, s) {
        if (!b.renderWorldCopies || b.lngRange) return;
        const u = s.lng - b.center.lng;
        s.lng += u > 180 ? -360 : u < -180 ? 360 : 0;
      }
      function Ji(b) {
        return Math.max(0, Math.floor(b));
      }
      class Ki {
        constructor(s, u, p, m, x, E) {
          this._callbacks = s, this._tileSize = 512, this._renderWorldCopies = E === void 0 || !!E, this._minZoom = u || 0, this._maxZoom = p || 22, this._minPitch = m ?? 0, this._maxPitch = x ?? 60, this.setMaxBounds(), this._width = 0, this._height = 0, this._center = new a.O(0, 0), this._elevation = 0, this._zoom = 0, this._tileZoom = Ji(this._zoom), this._scale = a.aG(this._zoom), this._bearingInRadians = 0, this._fovInRadians = 0.6435011087932844, this._pitchInRadians = 0, this._rollInRadians = 0, this._unmodified = !0, this._edgeInsets = new Rn(), this._minElevationForCurrentTile = 0, this._autoCalculateNearFarZ = !0;
        }
        apply(s, u, p) {
          this._latRange = s.latRange, this._lngRange = s.lngRange, this._width = s.width, this._height = s.height, this._center = s.center, this._elevation = s.elevation, this._minElevationForCurrentTile = s.minElevationForCurrentTile, this._zoom = s.zoom, this._tileZoom = Ji(this._zoom), this._scale = a.aG(this._zoom), this._bearingInRadians = s.bearingInRadians, this._fovInRadians = s.fovInRadians, this._pitchInRadians = s.pitchInRadians, this._rollInRadians = s.rollInRadians, this._unmodified = s.unmodified, this._edgeInsets = new Rn(s.padding.top, s.padding.bottom, s.padding.left, s.padding.right), this._minZoom = s.minZoom, this._maxZoom = s.maxZoom, this._minPitch = s.minPitch, this._maxPitch = s.maxPitch, this._renderWorldCopies = s.renderWorldCopies, this._cameraToCenterDistance = s.cameraToCenterDistance, this._nearZ = s.nearZ, this._farZ = s.farZ, this._autoCalculateNearFarZ = !p && s.autoCalculateNearFarZ, u && this._constrain(), this._calcMatrices();
        }
        get pixelsToClipSpaceMatrix() {
          return this._pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._clipSpaceToPixelsMatrix;
        }
        get minElevationForCurrentTile() {
          return this._minElevationForCurrentTile;
        }
        setMinElevationForCurrentTile(s) {
          this._minElevationForCurrentTile = s;
        }
        get tileSize() {
          return this._tileSize;
        }
        get tileZoom() {
          return this._tileZoom;
        }
        get scale() {
          return this._scale;
        }
        get width() {
          return this._width;
        }
        get height() {
          return this._height;
        }
        get bearingInRadians() {
          return this._bearingInRadians;
        }
        get lngRange() {
          return this._lngRange;
        }
        get latRange() {
          return this._latRange;
        }
        get pixelsToGLUnits() {
          return this._pixelsToGLUnits;
        }
        get minZoom() {
          return this._minZoom;
        }
        setMinZoom(s) {
          this._minZoom !== s && (this._minZoom = s, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
        }
        get maxZoom() {
          return this._maxZoom;
        }
        setMaxZoom(s) {
          this._maxZoom !== s && (this._maxZoom = s, this.setZoom(this.getConstrained(this._center, this.zoom).zoom));
        }
        get minPitch() {
          return this._minPitch;
        }
        setMinPitch(s) {
          this._minPitch !== s && (this._minPitch = s, this.setPitch(Math.max(this.pitch, s)));
        }
        get maxPitch() {
          return this._maxPitch;
        }
        setMaxPitch(s) {
          this._maxPitch !== s && (this._maxPitch = s, this.setPitch(Math.min(this.pitch, s)));
        }
        get renderWorldCopies() {
          return this._renderWorldCopies;
        }
        setRenderWorldCopies(s) {
          s === void 0 ? s = !0 : s === null && (s = !1), this._renderWorldCopies = s;
        }
        get worldSize() {
          return this._tileSize * this._scale;
        }
        get centerOffset() {
          return this.centerPoint._sub(this.size._div(2));
        }
        get size() {
          return new a.P(this._width, this._height);
        }
        get bearing() {
          return this._bearingInRadians / Math.PI * 180;
        }
        setBearing(s) {
          const u = a.aJ(s, -180, 180) * Math.PI / 180;
          var p, m, x, E, L, B, N, G, Z;
          this._bearingInRadians !== u && (this._unmodified = !1, this._bearingInRadians = u, this._calcMatrices(), this._rotationMatrix = y(), p = this._rotationMatrix, x = -this._bearingInRadians, E = (m = this._rotationMatrix)[0], L = m[1], B = m[2], N = m[3], G = Math.sin(x), Z = Math.cos(x), p[0] = E * Z + B * G, p[1] = L * Z + N * G, p[2] = E * -G + B * Z, p[3] = L * -G + N * Z);
        }
        get rotationMatrix() {
          return this._rotationMatrix;
        }
        get pitchInRadians() {
          return this._pitchInRadians;
        }
        get pitch() {
          return this._pitchInRadians / Math.PI * 180;
        }
        setPitch(s) {
          const u = a.ac(s, this.minPitch, this.maxPitch) / 180 * Math.PI;
          this._pitchInRadians !== u && (this._unmodified = !1, this._pitchInRadians = u, this._calcMatrices());
        }
        get rollInRadians() {
          return this._rollInRadians;
        }
        get roll() {
          return this._rollInRadians / Math.PI * 180;
        }
        setRoll(s) {
          const u = s / 180 * Math.PI;
          this._rollInRadians !== u && (this._unmodified = !1, this._rollInRadians = u, this._calcMatrices());
        }
        get fovInRadians() {
          return this._fovInRadians;
        }
        get fov() {
          return a.aK(this._fovInRadians);
        }
        setFov(s) {
          s = a.ac(s, 0.1, 150), this.fov !== s && (this._unmodified = !1, this._fovInRadians = a.ab(s), this._calcMatrices());
        }
        get zoom() {
          return this._zoom;
        }
        setZoom(s) {
          const u = this.getConstrained(this._center, s).zoom;
          this._zoom !== u && (this._unmodified = !1, this._zoom = u, this._tileZoom = Math.max(0, Math.floor(u)), this._scale = a.aG(u), this._constrain(), this._calcMatrices());
        }
        get center() {
          return this._center;
        }
        setCenter(s) {
          s.lat === this._center.lat && s.lng === this._center.lng || (this._unmodified = !1, this._center = s, this._constrain(), this._calcMatrices());
        }
        get elevation() {
          return this._elevation;
        }
        setElevation(s) {
          s !== this._elevation && (this._elevation = s, this._constrain(), this._calcMatrices());
        }
        get padding() {
          return this._edgeInsets.toJSON();
        }
        setPadding(s) {
          this._edgeInsets.equals(s) || (this._unmodified = !1, this._edgeInsets.interpolate(this._edgeInsets, s, 1), this._calcMatrices());
        }
        get centerPoint() {
          return this._edgeInsets.getCenter(this._width, this._height);
        }
        get pixelsPerMeter() {
          return this._pixelPerMeter;
        }
        get unmodified() {
          return this._unmodified;
        }
        get cameraToCenterDistance() {
          return this._cameraToCenterDistance;
        }
        get nearZ() {
          return this._nearZ;
        }
        get farZ() {
          return this._farZ;
        }
        get autoCalculateNearFarZ() {
          return this._autoCalculateNearFarZ;
        }
        overrideNearFarZ(s, u) {
          this._autoCalculateNearFarZ = !1, this._nearZ = s, this._farZ = u, this._calcMatrices();
        }
        clearNearFarZOverride() {
          this._autoCalculateNearFarZ = !0, this._calcMatrices();
        }
        isPaddingEqual(s) {
          return this._edgeInsets.equals(s);
        }
        interpolatePadding(s, u, p) {
          this._unmodified = !1, this._edgeInsets.interpolate(s, u, p), this._constrain(), this._calcMatrices();
        }
        resize(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
          this._width = s, this._height = u, p && this._constrain(), this._calcMatrices();
        }
        getMaxBounds() {
          return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new wn([this._lngRange[0], this._latRange[0]], [this._lngRange[1], this._latRange[1]]) : null;
        }
        setMaxBounds(s) {
          s ? (this._lngRange = [s.getWest(), s.getEast()], this._latRange = [s.getSouth(), s.getNorth()], this._constrain()) : (this._lngRange = null, this._latRange = [-85.051129, a.aH]);
        }
        getConstrained(s, u) {
          return this._callbacks.getConstrained(s, u);
        }
        getCameraQueryGeometry(s, u) {
          if (u.length === 1) return [u[0], s];
          {
            let p = s.x, m = s.y, x = s.x, E = s.y;
            for (const L of u) p = Math.min(p, L.x), m = Math.min(m, L.y), x = Math.max(x, L.x), E = Math.max(E, L.y);
            return [new a.P(p, m), new a.P(x, m), new a.P(x, E), new a.P(p, E), new a.P(p, m)];
          }
        }
        _constrain() {
          if (!this.center || !this._width || !this._height || this._constraining) return;
          this._constraining = !0;
          const s = this._unmodified, { center: u, zoom: p } = this.getConstrained(this.center, this.zoom);
          this.setCenter(u), this.setZoom(p), this._unmodified = s, this._constraining = !1;
        }
        _calcMatrices() {
          if (this._width && this._height) {
            this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
            let s = a.ar(new Float64Array(16));
            a.L(s, s, [this._width / 2, -this._height / 2, 1]), a.K(s, s, [1, -1, 0]), this._clipSpaceToPixelsMatrix = s, s = a.ar(new Float64Array(16)), a.L(s, s, [1, -1, 1]), a.K(s, s, [-1, -1, 0]), a.L(s, s, [2 / this._width, 2 / this._height, 1]), this._pixelsToClipSpaceMatrix = s, this._cameraToCenterDistance = 0.5 / Math.tan(this.fovInRadians / 2) * this._height;
          }
          this._callbacks.calcMatrices();
        }
        calculateCenterFromCameraLngLatAlt(s, u, p, m) {
          const x = p !== void 0 ? p : this.bearing, E = m = m !== void 0 ? m : this.pitch, L = a.Z.fromLngLat(s, u), B = -Math.cos(a.ab(E)), N = Math.sin(a.ab(E)), G = N * Math.sin(a.ab(x)), Z = -N * Math.cos(a.ab(x));
          let $ = this.elevation;
          const re = u - $;
          let ae;
          B * re >= 0 || Math.abs(B) < 0.1 ? (ae = 1e4, $ = u + ae * B) : ae = -re / B;
          let Pe, Ce, Ie = a.aL(1, L.y), Be = 0;
          do {
            if (Be += 1, Be > 10) break;
            Ce = ae / Ie, Pe = new a.Z(L.x + G * Ce, L.y + Z * Ce), Ie = 1 / Pe.meterInMercatorCoordinateUnits();
          } while (Math.abs(ae - Ce * Ie) > 1e-12);
          return { center: Pe.toLngLat(), elevation: $, zoom: a.a9(this.height / 2 / Math.tan(this.fovInRadians / 2) / Ce / this.tileSize) };
        }
        recalculateZoomAndCenter(s) {
          if (this.elevation - s == 0) return;
          const u = a.aI(1, this.center.lat) * this.worldSize, p = this.cameraToCenterDistance / u, m = a.Z.fromLngLat(this.center, this.elevation), x = gn(this.center, this.elevation, this.pitch, this.bearing, p);
          this._elevation = s;
          const E = this.calculateCenterFromCameraLngLatAlt(x.toLngLat(), a.aL(x.z, m.y), this.bearing, this.pitch);
          this._elevation = E.elevation, this._center = E.center, this.setZoom(E.zoom);
        }
        getCameraPoint() {
          const s = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
          return this.centerPoint.add(new a.P(s * Math.sin(this.rollInRadians), s * Math.cos(this.rollInRadians)));
        }
        getCameraAltitude() {
          return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation;
        }
        getCameraLngLat() {
          const s = a.aI(1, this.center.lat) * this.worldSize;
          return gn(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / s).toLngLat();
        }
        getMercatorTileCoordinates(s) {
          if (!s) return [0, 0, 1, 1];
          const u = s.canonical.z >= 0 ? 1 << s.canonical.z : Math.pow(2, s.canonical.z);
          return [s.canonical.x / u, s.canonical.y / u, 1 / u / a.Y, 1 / u / a.Y];
        }
      }
      class qn {
        constructor(s, u) {
          this.min = s, this.max = u, this.center = a.aM([], a.aN([], this.min, this.max), 0.5);
        }
        quadrant(s) {
          const u = [s % 2 == 0, s < 2], p = a.aO(this.min), m = a.aO(this.max);
          for (let x = 0; x < u.length; x++) p[x] = u[x] ? this.min[x] : this.center[x], m[x] = u[x] ? this.center[x] : this.max[x];
          return m[2] = this.max[2], new qn(p, m);
        }
        distanceX(s) {
          return Math.max(Math.min(this.max[0], s[0]), this.min[0]) - s[0];
        }
        distanceY(s) {
          return Math.max(Math.min(this.max[1], s[1]), this.min[1]) - s[1];
        }
        intersectsFrustum(s) {
          let u = !0;
          for (let p = 0; p < s.planes.length; p++) {
            const m = this.intersectsPlane(s.planes[p]);
            if (m === 0) return 0;
            m === 1 && (u = !1);
          }
          return u ? 2 : s.aabb.min[0] > this.max[0] || s.aabb.min[1] > this.max[1] || s.aabb.min[2] > this.max[2] || s.aabb.max[0] < this.min[0] || s.aabb.max[1] < this.min[1] || s.aabb.max[2] < this.min[2] ? 0 : 1;
        }
        intersectsPlane(s) {
          let u = s[3], p = s[3];
          for (let m = 0; m < 3; m++) s[m] > 0 ? (u += s[m] * this.min[m], p += s[m] * this.max[m]) : (p += s[m] * this.min[m], u += s[m] * this.max[m]);
          return u >= 0 ? 2 : p < 0 ? 0 : 1;
        }
      }
      class Ml {
        distanceToTile2d(s, u, p, m) {
          const x = m.distanceX([s, u]), E = m.distanceY([s, u]);
          return Math.hypot(x, E);
        }
        getWrap(s, u, p) {
          return p;
        }
        getTileAABB(s, u, p, m) {
          var x, E;
          let L = p, B = p;
          if (m.terrain) {
            const G = new a.X(s.z, u, s.z, s.x, s.y), Z = m.terrain.getMinMaxElevation(G);
            L = (x = Z.minElevation) !== null && x !== void 0 ? x : p, B = (E = Z.maxElevation) !== null && E !== void 0 ? E : p;
          }
          const N = 1 << s.z;
          return new qn([u + s.x / N, s.y / N, L], [u + (s.x + 1) / N, (s.y + 1) / N, B]);
        }
        allowVariableZoom(s, u) {
          const p = s.fov * (Math.abs(Math.cos(s.rollInRadians)) * s.height + Math.abs(Math.sin(s.rollInRadians)) * s.width) / s.height, m = a.ac(78.5 - p / 2, 0, 60);
          return !!u.terrain || s.pitch > m;
        }
        allowWorldCopies() {
          return !0;
        }
        recalculateCache() {
        }
      }
      class ho {
        constructor(s, u, p) {
          this.points = s, this.planes = u, this.aabb = p;
        }
        static fromInvProjectionMatrix(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
          const m = Math.pow(2, p), x = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((N) => {
            const G = 1 / (N = a.an([], N, s))[3] / u * m;
            return a.aP(N, N, [G, G, 1 / N[3], G]);
          }), E = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((N) => {
            const G = a.aQ([], x[N[0]], x[N[1]]), Z = a.aQ([], x[N[2]], x[N[1]]), $ = a.aR([], a.aS([], G, Z)), re = -a.aT($, x[N[1]]);
            return $.concat(re);
          }), L = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY], B = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
          for (const N of x) for (let G = 0; G < 3; G++) L[G] = Math.min(L[G], N[G]), B[G] = Math.max(B[G], N[G]);
          return new ho(x, E, new qn(L, B));
        }
      }
      class Vn {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(s) {
          this._helper.setMinZoom(s);
        }
        setMaxZoom(s) {
          this._helper.setMaxZoom(s);
        }
        setMinPitch(s) {
          this._helper.setMinPitch(s);
        }
        setMaxPitch(s) {
          this._helper.setMaxPitch(s);
        }
        setRenderWorldCopies(s) {
          this._helper.setRenderWorldCopies(s);
        }
        setBearing(s) {
          this._helper.setBearing(s);
        }
        setPitch(s) {
          this._helper.setPitch(s);
        }
        setRoll(s) {
          this._helper.setRoll(s);
        }
        setFov(s) {
          this._helper.setFov(s);
        }
        setZoom(s) {
          this._helper.setZoom(s);
        }
        setCenter(s) {
          this._helper.setCenter(s);
        }
        setElevation(s) {
          this._helper.setElevation(s);
        }
        setMinElevationForCurrentTile(s) {
          this._helper.setMinElevationForCurrentTile(s);
        }
        setPadding(s) {
          this._helper.setPadding(s);
        }
        interpolatePadding(s, u, p) {
          return this._helper.interpolatePadding(s, u, p);
        }
        isPaddingEqual(s) {
          return this._helper.isPaddingEqual(s);
        }
        resize(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
          this._helper.resize(s, u, p);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(s) {
          this._helper.setMaxBounds(s);
        }
        overrideNearFarZ(s, u) {
          this._helper.overrideNearFarZ(s, u);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(s) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), s);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        setTransitionState(s, u) {
        }
        constructor(s, u, p, m, x) {
          this._posMatrixCache = /* @__PURE__ */ new Map(), this._alignedPosMatrixCache = /* @__PURE__ */ new Map(), this._fogMatrixCacheF32 = /* @__PURE__ */ new Map(), this._helper = new Ki({ calcMatrices: () => {
            this._calcMatrices();
          }, getConstrained: (E, L) => this.getConstrained(E, L) }, s, u, p, m, x), this._coveringTilesDetailsProvider = new Ml();
        }
        clone() {
          const s = new Vn();
          return s.apply(this), s;
        }
        apply(s, u, p) {
          this._helper.apply(s, u, p);
        }
        get cameraPosition() {
          return this._cameraPosition;
        }
        get projectionMatrix() {
          return this._projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this._viewProjMatrix;
        }
        get inverseProjectionMatrix() {
          return this._invProjMatrix;
        }
        get mercatorMatrix() {
          return this._mercatorMatrix;
        }
        getVisibleUnwrappedCoordinates(s) {
          const u = [new a.aU(0, s)];
          if (this._helper._renderWorldCopies) {
            const p = this.screenPointToMercatorCoordinate(new a.P(0, 0)), m = this.screenPointToMercatorCoordinate(new a.P(this._helper._width, 0)), x = this.screenPointToMercatorCoordinate(new a.P(this._helper._width, this._helper._height)), E = this.screenPointToMercatorCoordinate(new a.P(0, this._helper._height)), L = Math.floor(Math.min(p.x, m.x, x.x, E.x)), B = Math.floor(Math.max(p.x, m.x, x.x, E.x)), N = 1;
            for (let G = L - N; G <= B + N; G++) G !== 0 && u.push(new a.aU(G, s));
          }
          return u;
        }
        getCameraFrustum() {
          return ho.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize);
        }
        getClippingPlane() {
          return null;
        }
        getCoveringTilesDetailsProvider() {
          return this._coveringTilesDetailsProvider;
        }
        recalculateZoomAndCenter(s) {
          const u = this.screenPointToLocation(this.centerPoint, s), p = s ? s.getElevationForLngLatZoom(u, this._helper._tileZoom) : 0;
          this._helper.recalculateZoomAndCenter(p);
        }
        setLocationAtPoint(s, u) {
          const p = a.aI(this.elevation, this.center.lat), m = this.screenPointToMercatorCoordinateAtZ(u, p), x = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, p), E = a.Z.fromLngLat(s), L = new a.Z(E.x - (m.x - x.x), E.y - (m.y - x.y));
          this.setCenter(L == null ? void 0 : L.toLngLat()), this._helper._renderWorldCopies && this.setCenter(this.center.wrap());
        }
        locationToScreenPoint(s, u) {
          return u ? this.coordinatePoint(a.Z.fromLngLat(s), u.getElevationForLngLatZoom(s, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(a.Z.fromLngLat(s));
        }
        screenPointToLocation(s, u) {
          var p;
          return (p = this.screenPointToMercatorCoordinate(s, u)) === null || p === void 0 ? void 0 : p.toLngLat();
        }
        screenPointToMercatorCoordinate(s, u) {
          if (u) {
            const p = u.pointCoordinate(s);
            if (p != null) return p;
          }
          return this.screenPointToMercatorCoordinateAtZ(s);
        }
        screenPointToMercatorCoordinateAtZ(s, u) {
          const p = u || 0, m = [s.x, s.y, 0, 1], x = [s.x, s.y, 1, 1];
          a.an(m, m, this._pixelMatrixInverse), a.an(x, x, this._pixelMatrixInverse);
          const E = m[3], L = x[3], B = m[1] / E, N = x[1] / L, G = m[2] / E, Z = x[2] / L, $ = G === Z ? 0 : (p - G) / (Z - G);
          return new a.Z(a.z.number(m[0] / E, x[0] / L, $) / this.worldSize, a.z.number(B, N, $) / this.worldSize, p);
        }
        coordinatePoint(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this._pixelMatrix;
          const m = [s.x * this.worldSize, s.y * this.worldSize, u, 1];
          return a.an(m, m, p), new a.P(m[0] / m[3], m[1] / m[3]);
        }
        getBounds() {
          const s = Math.max(0, this._helper._height / 2 - _t(this));
          return new wn().extend(this.screenPointToLocation(new a.P(0, s))).extend(this.screenPointToLocation(new a.P(this._helper._width, s))).extend(this.screenPointToLocation(new a.P(this._helper._width, this._helper._height))).extend(this.screenPointToLocation(new a.P(0, this._helper._height)));
        }
        isPointOnMapSurface(s, u) {
          return u ? u.pointCoordinate(s) != null : s.y > this.height / 2 - _t(this);
        }
        calculatePosMatrix(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, p = arguments.length > 2 ? arguments[2] : void 0;
          var m;
          const x = (m = s.key) !== null && m !== void 0 ? m : a.aV(s.wrap, s.canonical.z, s.canonical.z, s.canonical.x, s.canonical.y), E = u ? this._alignedPosMatrixCache : this._posMatrixCache;
          if (E.has(x)) {
            const N = E.get(x);
            return p ? N.f32 : N.f64;
          }
          const L = Kt(s, this.worldSize);
          a.M(L, u ? this._alignedProjMatrix : this._viewProjMatrix, L);
          const B = { f64: L, f32: new Float32Array(L) };
          return E.set(x, B), p ? B.f32 : B.f64;
        }
        calculateFogMatrix(s) {
          const u = s.key, p = this._fogMatrixCacheF32;
          if (p.has(u)) return p.get(u);
          const m = Kt(s, this.worldSize);
          return a.M(m, this._fogMatrix, m), p.set(u, new Float32Array(m)), p.get(u);
        }
        getConstrained(s, u) {
          u = a.ac(+u, this.minZoom, this.maxZoom);
          const p = { center: new a.O(s.lng, s.lat), zoom: u };
          let m = this._helper._lngRange;
          this._helper._renderWorldCopies || m !== null || (m = [-179.9999999999, 180 - 1e-10]);
          const x = this.tileSize * a.aG(p.zoom);
          let E = 0, L = x, B = 0, N = x, G = 0, Z = 0;
          const { x: $, y: re } = this.size;
          if (this._helper._latRange) {
            const He = this._helper._latRange;
            E = a.Q(He[1]) * x, L = a.Q(He[0]) * x, L - E < re && (G = re / (L - E));
          }
          m && (B = a.aJ(a.S(m[0]) * x, 0, x), N = a.aJ(a.S(m[1]) * x, 0, x), N < B && (N += x), N - B < $ && (Z = $ / (N - B)));
          const { x: ae, y: Pe } = we(x, s);
          let Ce, Ie;
          const Be = Math.max(Z || 0, G || 0);
          if (Be) {
            const He = new a.P(Z ? (N + B) / 2 : ae, G ? (L + E) / 2 : Pe);
            return p.center = Ve(x, He).wrap(), p.zoom += a.a9(Be), p;
          }
          if (this._helper._latRange) {
            const He = re / 2;
            Pe - He < E && (Ie = E + He), Pe + He > L && (Ie = L - He);
          }
          if (m) {
            const He = (B + N) / 2;
            let We = ae;
            this._helper._renderWorldCopies && (We = a.aJ(ae, He - x / 2, He + x / 2));
            const $e = $ / 2;
            We - $e < B && (Ce = B + $e), We + $e > N && (Ce = N - $e);
          }
          if (Ce !== void 0 || Ie !== void 0) {
            const He = new a.P(Ce ?? ae, Ie ?? Pe);
            p.center = Ve(x, He).wrap();
          }
          return p;
        }
        calculateCenterFromCameraLngLatAlt(s, u, p, m) {
          return this._helper.calculateCenterFromCameraLngLatAlt(s, u, p, m);
        }
        _calculateNearFarZIfNeeded(s, u, p) {
          if (!this._helper.autoCalculateNearFarZ) return;
          const m = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100), x = s - m * this._helper._pixelPerMeter / Math.cos(u), E = m < 0 ? x : s, L = Math.PI / 2 + this.pitchInRadians, B = a.ab(this.fov) * (Math.abs(Math.cos(a.ab(this.roll))) * this.height + Math.abs(Math.sin(a.ab(this.roll))) * this.width) / this.height * (0.5 + p.y / this.height), N = Math.sin(B) * E / Math.sin(a.ac(Math.PI - L - B, 0.01, Math.PI - 0.01)), G = _t(this), Z = Math.atan(G / this._helper.cameraToCenterDistance), $ = a.ab(0.75), re = Z > $ ? 2 * Z * (0.5 + p.y / (2 * G)) : $, ae = Math.sin(re) * E / Math.sin(a.ac(Math.PI - L - re, 0.01, Math.PI - 0.01)), Pe = Math.min(N, ae);
          this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - u) * Pe + E), this._helper._nearZ = this._helper._height / 50;
        }
        _calcMatrices() {
          if (!this._helper._height) return;
          const s = this.centerOffset, u = we(this.worldSize, this.center), p = u.x, m = u.y;
          this._helper._pixelPerMeter = a.aI(1, this.center.lat) * this.worldSize;
          const x = a.ab(Math.min(this.pitch, 89.25)), E = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(x));
          let L;
          this._calculateNearFarZIfNeeded(E, x, s), L = new Float64Array(16), a.aW(L, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ), this._invProjMatrix = new Float64Array(16), a.ah(this._invProjMatrix, L), L[8] = 2 * -s.x / this._helper._width, L[9] = 2 * s.y / this._helper._height, this._projectionMatrix = a.aX(L), a.L(L, L, [1, -1, 1]), a.K(L, L, [0, 0, -this._helper.cameraToCenterDistance]), a.aY(L, L, -this.rollInRadians), a.aZ(L, L, this.pitchInRadians), a.aY(L, L, -this.bearingInRadians), a.K(L, L, [-p, -m, 0]), this._mercatorMatrix = a.L([], L, [this.worldSize, this.worldSize, this.worldSize]), a.L(L, L, [1, 1, this._helper._pixelPerMeter]), this._pixelMatrix = a.M(new Float64Array(16), this.clipSpaceToPixelsMatrix, L), a.K(L, L, [0, 0, -this.elevation]), this._viewProjMatrix = L, this._invViewProjMatrix = a.ah([], L);
          const B = [0, 0, -1, 1];
          a.an(B, B, this._invViewProjMatrix), this._cameraPosition = [B[0] / B[3], B[1] / B[3], B[2] / B[3]], this._fogMatrix = new Float64Array(16), a.aW(this._fogMatrix, this.fovInRadians, this.width / this.height, E, this._helper._farZ), this._fogMatrix[8] = 2 * -s.x / this.width, this._fogMatrix[9] = 2 * s.y / this.height, a.L(this._fogMatrix, this._fogMatrix, [1, -1, 1]), a.K(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]), a.aY(this._fogMatrix, this._fogMatrix, -this.rollInRadians), a.aZ(this._fogMatrix, this._fogMatrix, this.pitchInRadians), a.aY(this._fogMatrix, this._fogMatrix, -this.bearingInRadians), a.K(this._fogMatrix, this._fogMatrix, [-p, -m, 0]), a.L(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]), a.K(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]), this._pixelMatrix3D = a.M(new Float64Array(16), this.clipSpaceToPixelsMatrix, L);
          const N = this._helper._width % 2 / 2, G = this._helper._height % 2 / 2, Z = Math.cos(this.bearingInRadians), $ = Math.sin(-this.bearingInRadians), re = p - Math.round(p) + Z * N + $ * G, ae = m - Math.round(m) + Z * G + $ * N, Pe = new Float64Array(L);
          if (a.K(Pe, Pe, [re > 0.5 ? re - 1 : re, ae > 0.5 ? ae - 1 : ae, 0]), this._alignedProjMatrix = Pe, L = a.ah(new Float64Array(16), this._pixelMatrix), !L) throw new Error("failed to invert matrix");
          this._pixelMatrixInverse = L, this._clearMatrixCaches();
        }
        _clearMatrixCaches() {
          this._posMatrixCache.clear(), this._alignedPosMatrixCache.clear(), this._fogMatrixCacheF32.clear();
        }
        maxPitchScaleFactor() {
          if (!this._pixelMatrixInverse) return 1;
          const s = this.screenPointToMercatorCoordinate(new a.P(0, 0)), u = [s.x * this.worldSize, s.y * this.worldSize, 0, 1];
          return a.an(u, u, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance;
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          const s = a.aI(1, this.center.lat) * this.worldSize;
          return gn(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / s).toLngLat();
        }
        lngLatToCameraDepth(s, u) {
          const p = a.Z.fromLngLat(s), m = [p.x * this.worldSize, p.y * this.worldSize, u, 1];
          return a.an(m, m, this._viewProjMatrix), m[2] / m[3];
        }
        getProjectionData(s) {
          const { overscaledTileID: u, aligned: p, applyTerrainMatrix: m } = s, x = this._helper.getMercatorTileCoordinates(u), E = u ? this.calculatePosMatrix(u, p, !0) : null;
          let L;
          return L = u && u.terrainRttPosMatrix32f && m ? u.terrainRttPosMatrix32f : E || a.a_(), { mainMatrix: L, tileMercatorCoords: x, clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: L };
        }
        isLocationOccluded(s) {
          return !1;
        }
        getPixelScale() {
          return 1;
        }
        getCircleRadiusCorrection() {
          return 1;
        }
        getPitchedTextCorrection(s, u, p) {
          return 1;
        }
        transformLightDirection(s) {
          return a.aO(s);
        }
        getRayDirectionFromPixel(s) {
          throw new Error("Not implemented.");
        }
        projectTileCoordinates(s, u, p, m) {
          const x = this.calculatePosMatrix(p);
          let E;
          m ? (E = [s, u, m(s, u), 1], a.an(E, E, x)) : (E = [s, u, 0, 1], Ii(E, E, x));
          const L = E[3];
          return { point: new a.P(E[0] / L, E[1] / L), signedDistanceFromCamera: L, isOccluded: !1 };
        }
        populateCache(s) {
          for (const u of s) this.calculatePosMatrix(u);
        }
        getMatrixForModel(s, u) {
          const p = a.Z.fromLngLat(s, u), m = p.meterInMercatorCoordinateUnits(), x = a.a$();
          return a.K(x, x, [p.x, p.y, p.z]), a.aY(x, x, Math.PI), a.aZ(x, x, Math.PI / 2), a.L(x, x, [-m, m, m]), x;
        }
        getProjectionDataForCustomLayer() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          const u = new a.X(0, 0, 0, 0, 0), p = this.getProjectionData({ overscaledTileID: u, applyGlobeMatrix: s }), m = Kt(u, this.worldSize);
          a.M(m, this._viewProjMatrix, m), p.tileMercatorCoords = [0, 0, 1, 1];
          const x = [a.Y, a.Y, this.worldSize / this._helper.pixelsPerMeter], E = a.b0();
          return a.L(E, m, x), p.fallbackMatrix = E, p.mainMatrix = E, p;
        }
        getFastPathSimpleProjectionMatrix(s) {
          return this.calculatePosMatrix(s);
        }
      }
      function Js() {
        a.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
      }
      function ru(b) {
        if (b.useSlerp)
          if (b.k < 1) {
            const s = a.b1(b.startEulerAngles.roll, b.startEulerAngles.pitch, b.startEulerAngles.bearing), u = a.b1(b.endEulerAngles.roll, b.endEulerAngles.pitch, b.endEulerAngles.bearing), p = new Float64Array(4);
            a.b2(p, s, u, b.k);
            const m = a.b3(p);
            b.tr.setRoll(m.roll), b.tr.setPitch(m.pitch), b.tr.setBearing(m.bearing);
          } else b.tr.setRoll(b.endEulerAngles.roll), b.tr.setPitch(b.endEulerAngles.pitch), b.tr.setBearing(b.endEulerAngles.bearing);
        else b.tr.setRoll(a.z.number(b.startEulerAngles.roll, b.endEulerAngles.roll, b.k)), b.tr.setPitch(a.z.number(b.startEulerAngles.pitch, b.endEulerAngles.pitch, b.k)), b.tr.setBearing(a.z.number(b.startEulerAngles.bearing, b.endEulerAngles.bearing, b.k));
      }
      function Zr(b, s, u, p, m) {
        const x = m.padding, E = we(m.worldSize, u.getNorthWest()), L = we(m.worldSize, u.getNorthEast()), B = we(m.worldSize, u.getSouthEast()), N = we(m.worldSize, u.getSouthWest()), G = a.ab(-p), Z = E.rotate(G), $ = L.rotate(G), re = B.rotate(G), ae = N.rotate(G), Pe = new a.P(Math.max(Z.x, $.x, ae.x, re.x), Math.max(Z.y, $.y, ae.y, re.y)), Ce = new a.P(Math.min(Z.x, $.x, ae.x, re.x), Math.min(Z.y, $.y, ae.y, re.y)), Ie = Pe.sub(Ce), Be = (m.width - (x.left + x.right + s.left + s.right)) / Ie.x, He = (m.height - (x.top + x.bottom + s.top + s.bottom)) / Ie.y;
        if (He < 0 || Be < 0) return void Js();
        const We = Math.min(a.a9(m.scale * Math.min(Be, He)), b.maxZoom), $e = a.P.convert(b.offset), Je = new a.P((s.left - s.right) / 2, (s.top - s.bottom) / 2).rotate(a.ab(p)), Qe = $e.add(Je).mult(m.scale / a.aG(We));
        return { center: Ve(m.worldSize, E.add(B).div(2).sub(Qe)), zoom: We, bearing: p };
      }
      class Ll {
        get useGlobeControls() {
          return !1;
        }
        handlePanInertia(s, u) {
          return { easingOffset: s, easingCenter: u.center };
        }
        handleMapControlsRollPitchBearingZoom(s, u) {
          s.bearingDelta && u.setBearing(u.bearing + s.bearingDelta), s.pitchDelta && u.setPitch(u.pitch + s.pitchDelta), s.rollDelta && u.setRoll(u.roll + s.rollDelta), s.zoomDelta && u.setZoom(u.zoom + s.zoomDelta);
        }
        handleMapControlsPan(s, u, p) {
          s.around.distSqr(u.centerPoint) < 0.01 || u.setLocationAtPoint(p, s.around);
        }
        cameraForBoxAndBearing(s, u, p, m, x) {
          return Zr(s, u, p, m, x);
        }
        handleJumpToCenterZoom(s, u) {
          s.zoom !== (u.zoom !== void 0 ? +u.zoom : s.zoom) && s.setZoom(+u.zoom), u.center !== void 0 && s.setCenter(a.O.convert(u.center));
        }
        handleEaseTo(s, u) {
          const p = s.zoom, m = s.padding, x = { roll: s.roll, pitch: s.pitch, bearing: s.bearing }, E = { roll: u.roll === void 0 ? s.roll : u.roll, pitch: u.pitch === void 0 ? s.pitch : u.pitch, bearing: u.bearing === void 0 ? s.bearing : u.bearing }, L = u.zoom !== void 0, B = !s.isPaddingEqual(u.padding);
          let N = !1;
          const G = L ? +u.zoom : s.zoom;
          let Z = s.centerPoint.add(u.offsetAsPoint);
          const $ = s.screenPointToLocation(Z), { center: re, zoom: ae } = s.getConstrained(a.O.convert(u.center || $), G ?? p);
          hi(s, re);
          const Pe = we(s.worldSize, $), Ce = we(s.worldSize, re).sub(Pe), Ie = a.aG(ae - p);
          return N = ae !== p, { easeFunc: (Be) => {
            if (N && s.setZoom(a.z.number(p, ae, Be)), a.b4(x, E) || ru({ startEulerAngles: x, endEulerAngles: E, tr: s, k: Be, useSlerp: x.roll != E.roll }), B && (s.interpolatePadding(m, u.padding, Be), Z = s.centerPoint.add(u.offsetAsPoint)), u.around) s.setLocationAtPoint(u.around, u.aroundPoint);
            else {
              const He = a.aG(s.zoom - p), We = ae > p ? Math.min(2, Ie) : Math.max(0.5, Ie), $e = Math.pow(We, 1 - Be), Je = Ve(s.worldSize, Pe.add(Ce.mult(Be * $e)).mult(He));
              s.setLocationAtPoint(s.renderWorldCopies ? Je.wrap() : Je, Z);
            }
          }, isZooming: N, elevationCenter: re };
        }
        handleFlyTo(s, u) {
          const p = u.zoom !== void 0, m = s.zoom, x = s.getConstrained(a.O.convert(u.center || u.locationAtOffset), p ? +u.zoom : m), E = x.center, L = x.zoom;
          hi(s, E);
          const B = we(s.worldSize, u.locationAtOffset), N = we(s.worldSize, E).sub(B), G = N.mag(), Z = a.aG(L - m);
          let $;
          if (u.minZoom !== void 0) {
            const re = Math.min(+u.minZoom, m, L), ae = s.getConstrained(E, re).zoom;
            $ = a.aG(ae - m);
          }
          return { easeFunc: (re, ae, Pe, Ce) => {
            s.setZoom(re === 1 ? L : m + a.a9(ae));
            const Ie = re === 1 ? E : Ve(s.worldSize, B.add(N.mult(Pe)).mult(ae));
            s.setLocationAtPoint(s.renderWorldCopies ? Ie.wrap() : Ie, Ce);
          }, scaleOfZoom: Z, targetCenter: E, scaleOfMinZoom: $, pixelPathLength: G };
        }
      }
      class Ui {
        constructor(s, u, p) {
          this.blendFunction = s, this.blendColor = u, this.mask = p;
        }
      }
      Ui.Replace = [1, 0], Ui.disabled = new Ui(Ui.Replace, a.b5.transparent, [!1, !1, !1, !1]), Ui.unblended = new Ui(Ui.Replace, a.b5.transparent, [!0, !0, !0, !0]), Ui.alphaBlended = new Ui([1, 771], a.b5.transparent, [!0, !0, !0, !0]);
      const Yo = 2305;
      class li {
        constructor(s, u, p) {
          this.enable = s, this.mode = u, this.frontFace = p;
        }
      }
      li.disabled = new li(!1, 1029, Yo), li.backCCW = new li(!0, 1029, Yo), li.frontCCW = new li(!0, 1028, Yo);
      class Kn {
        constructor(s, u, p) {
          this.func = s, this.mask = u, this.range = p;
        }
      }
      Kn.ReadOnly = !1, Kn.ReadWrite = !0, Kn.disabled = new Kn(519, Kn.ReadOnly, [0, 1]);
      const Rl = 7680;
      class gi {
        constructor(s, u, p, m, x, E) {
          this.test = s, this.ref = u, this.mask = p, this.fail = m, this.depthFail = x, this.pass = E;
        }
      }
      gi.disabled = new gi({ func: 519, mask: 0 }, 0, 0, Rl, Rl, Rl);
      const fa = /* @__PURE__ */ new WeakMap();
      function ls(b) {
        var s;
        if (fa.has(b)) return fa.get(b);
        {
          const u = (s = b.getParameter(b.VERSION)) === null || s === void 0 ? void 0 : s.startsWith("WebGL 2.0");
          return fa.set(b, u), u;
        }
      }
      class So {
        get awaitingQuery() {
          return !!this._readbackQueue;
        }
        constructor(s) {
          this._readbackWaitFrames = 4, this._measureWaitFrames = 6, this._texWidth = 1, this._texHeight = 1, this._measuredError = 0, this._updateCount = 0, this._lastReadbackFrame = -1e3, this._readbackQueue = null, this._cachedRenderContext = s;
          const u = s.context, p = u.gl;
          this._texFormat = p.RGBA, this._texType = p.UNSIGNED_BYTE;
          const m = new a.aD();
          m.emplaceBack(-1, -1), m.emplaceBack(2, -1), m.emplaceBack(-1, 2);
          const x = new a.aF();
          x.emplaceBack(0, 1, 2), this._fullscreenTriangle = new as(u.createVertexBuffer(m, Qn.members), u.createIndexBuffer(x), a.aE.simpleSegment(0, 0, m.length, x.length)), this._resultBuffer = new Uint8Array(4), u.activeTexture.set(p.TEXTURE1);
          const E = p.createTexture();
          p.bindTexture(p.TEXTURE_2D, E), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_S, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_WRAP_T, p.CLAMP_TO_EDGE), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MIN_FILTER, p.NEAREST), p.texParameteri(p.TEXTURE_2D, p.TEXTURE_MAG_FILTER, p.NEAREST), p.texImage2D(p.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null), this._fbo = u.createFramebuffer(this._texWidth, this._texHeight, !1, !1), this._fbo.colorAttachment.set(E), ls(p) && (this._pbo = p.createBuffer(), p.bindBuffer(p.PIXEL_PACK_BUFFER, this._pbo), p.bufferData(p.PIXEL_PACK_BUFFER, 4, p.STREAM_READ), p.bindBuffer(p.PIXEL_PACK_BUFFER, null));
        }
        destroy() {
          const s = this._cachedRenderContext.context.gl;
          this._fullscreenTriangle.destroy(), this._fbo.destroy(), s.deleteBuffer(this._pbo), this._fullscreenTriangle = null, this._fbo = null, this._pbo = null, this._resultBuffer = null;
        }
        updateErrorLoop(s, u) {
          const p = this._updateCount;
          return this._readbackQueue ? p >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : p >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(s, u), this._updateCount++, this._measuredError;
        }
        _bindFramebuffer() {
          const s = this._cachedRenderContext.context, u = s.gl;
          s.activeTexture.set(u.TEXTURE1), u.bindTexture(u.TEXTURE_2D, this._fbo.colorAttachment.get()), s.bindFramebuffer.set(this._fbo.framebuffer);
        }
        _renderErrorTexture(s, u) {
          const p = this._cachedRenderContext.context, m = p.gl;
          if (this._bindFramebuffer(), p.viewport.set([0, 0, this._texWidth, this._texHeight]), p.clear({ color: a.b5.transparent }), this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(p, m.TRIANGLES, Kn.disabled, gi.disabled, Ui.unblended, li.disabled, /* @__PURE__ */ ((x, E) => ({ u_input: x, u_output_expected: E }))(s, u), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments), this._pbo && ls(m)) {
            m.bindBuffer(m.PIXEL_PACK_BUFFER, this._pbo), m.readBuffer(m.COLOR_ATTACHMENT0), m.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0), m.bindBuffer(m.PIXEL_PACK_BUFFER, null);
            const x = m.fenceSync(m.SYNC_GPU_COMMANDS_COMPLETE, 0);
            m.flush(), this._readbackQueue = { frameNumberIssued: this._updateCount, sync: x };
          } else this._readbackQueue = { frameNumberIssued: this._updateCount, sync: null };
        }
        _tryReadback() {
          const s = this._cachedRenderContext.context.gl;
          if (this._pbo && this._readbackQueue && ls(s)) {
            const u = s.clientWaitSync(this._readbackQueue.sync, 0, 0);
            if (u === s.WAIT_FAILED) return a.w("WebGL2 clientWaitSync failed."), this._readbackQueue = null, void (this._lastReadbackFrame = this._updateCount);
            if (u === s.TIMEOUT_EXPIRED) return;
            s.bindBuffer(s.PIXEL_PACK_BUFFER, this._pbo), s.getBufferSubData(s.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4), s.bindBuffer(s.PIXEL_PACK_BUFFER, null);
          } else this._bindFramebuffer(), s.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
          this._readbackQueue = null, this._measuredError = So._parseRGBA8float(this._resultBuffer), this._lastReadbackFrame = this._updateCount;
        }
        static _parseRGBA8float(s) {
          let u = 0;
          return u += s[0] / 256, u += s[1] / 65536, u += s[2] / 16777216, s[3] < 127 && (u = -u), u / 128;
        }
      }
      const Bl = a.Y / 128;
      function Jo(b, s) {
        const u = b.granularity !== void 0 ? Math.max(b.granularity, 1) : 1, p = u + (b.generateBorders ? 2 : 0), m = u + (b.extendToNorthPole || b.generateBorders ? 1 : 0) + (b.extendToSouthPole || b.generateBorders ? 1 : 0), x = p + 1, E = m + 1, L = b.generateBorders ? -1 : 0, B = b.generateBorders || b.extendToNorthPole ? -1 : 0, N = u + (b.generateBorders ? 1 : 0), G = u + (b.generateBorders || b.extendToSouthPole ? 1 : 0), Z = x * E, $ = p * m * 6, re = x * E > 65536;
        if (re && s === "16bit") throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
        const ae = re || s === "32bit", Pe = new Int16Array(2 * Z);
        let Ce = 0;
        for (let He = B; He <= G; He++) for (let We = L; We <= N; We++) {
          let $e = We / u * a.Y;
          We === -1 && ($e = -64), We === u + 1 && ($e = a.Y + Bl);
          let Je = He / u * a.Y;
          He === -1 && (Je = b.extendToNorthPole ? a.b7 : -64), He === u + 1 && (Je = b.extendToSouthPole ? a.b8 : a.Y + Bl), Pe[Ce++] = $e, Pe[Ce++] = Je;
        }
        const Ie = ae ? new Uint32Array($) : new Uint16Array($);
        let Be = 0;
        for (let He = 0; He < m; He++) for (let We = 0; We < p; We++) {
          const $e = We + 1 + He * x, Je = We + (He + 1) * x, Qe = We + 1 + (He + 1) * x;
          Ie[Be++] = We + He * x, Ie[Be++] = Je, Ie[Be++] = $e, Ie[Be++] = $e, Ie[Be++] = Je, Ie[Be++] = Qe;
        }
        return { vertices: Pe.buffer.slice(0), indices: Ie.buffer.slice(0), uses32bitIndices: ae };
      }
      const Ko = new a.aC({ fill: new a.b9(128, 2), line: new a.b9(512, 0), tile: new a.b9(128, 32), stencil: new a.b9(128, 1), circle: 3 });
      class Ol {
        constructor() {
          this._tileMeshCache = {}, this._errorCorrectionUsable = 0, this._errorMeasurementLastValue = 0, this._errorCorrectionPreviousValue = 0, this._errorMeasurementLastChangeTime = -1e3;
        }
        get name() {
          return "vertical-perspective";
        }
        get transitionState() {
          return 1;
        }
        get useSubdivision() {
          return !0;
        }
        get shaderVariantName() {
          return "globe";
        }
        get shaderDefine() {
          return "#define GLOBE";
        }
        get shaderPreludeCode() {
          return nr.projectionGlobe;
        }
        get vertexShaderPreludeCode() {
          return nr.projectionMercator.vertexSource;
        }
        get subdivisionGranularity() {
          return Ko;
        }
        get useGlobeControls() {
          return !0;
        }
        get latitudeErrorCorrectionRadians() {
          return this._errorCorrectionUsable;
        }
        destroy() {
          this._errorMeasurement && this._errorMeasurement.destroy();
        }
        updateGPUdependent(s) {
          this._errorMeasurement || (this._errorMeasurement = new So(s));
          const u = a.Q(this._errorQueryLatitudeDegrees), p = 2 * Math.atan(Math.exp(Math.PI - u * Math.PI * 2)) - 0.5 * Math.PI, m = this._errorMeasurement.updateErrorLoop(u, p), x = I.now();
          m !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable, this._errorMeasurementLastValue = m, this._errorMeasurementLastChangeTime = x);
          const E = Math.min(Math.max((x - this._errorMeasurementLastChangeTime) / 1e3 / 0.5, 0), 1);
          this._errorCorrectionUsable = a.ba(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, a.bb(E));
        }
        _getMeshKey(s) {
          return `${s.granularity.toString(36)}_${s.generateBorders ? "b" : ""}${s.extendToNorthPole ? "n" : ""}${s.extendToSouthPole ? "s" : ""}`;
        }
        getMeshFromTileID(s, u, p, m, x) {
          const E = (x === "stencil" ? Ko.stencil : Ko.tile).getGranularityForZoomLevel(u.z);
          return this._getMesh(s, { granularity: E, generateBorders: p, extendToNorthPole: u.y === 0 && m, extendToSouthPole: u.y === (1 << u.z) - 1 && m });
        }
        _getMesh(s, u) {
          const p = this._getMeshKey(u);
          if (p in this._tileMeshCache) return this._tileMeshCache[p];
          const m = function(x, E) {
            const L = Jo(E, "16bit"), B = a.aD.deserialize({ arrayBuffer: L.vertices, length: L.vertices.byteLength / 2 / 2 }), N = a.aF.deserialize({ arrayBuffer: L.indices, length: L.indices.byteLength / 2 / 3 });
            return new as(x.createVertexBuffer(B, Qn.members), x.createIndexBuffer(N), a.aE.simpleSegment(0, 0, B.length, N.length));
          }(s, u);
          return this._tileMeshCache[p] = m, m;
        }
        recalculate(s) {
        }
        hasTransition() {
          const s = I.now();
          let u = !1;
          return u = u || (s - this._errorMeasurementLastChangeTime) / 1e3 < 0.7, u = u || this._errorMeasurement && this._errorMeasurement.awaitingQuery, u;
        }
        setErrorQueryLatitudeDegrees(s) {
          this._errorQueryLatitudeDegrees = s;
        }
      }
      const Sc = new a.q({ type: new a.D(a.v.projection.type) });
      class Cc extends a.E {
        constructor(s) {
          super(), this._transitionable = new a.T(Sc), this.setProjection(s), this._transitioning = this._transitionable.untransitioned(), this.recalculate(new a.B(0)), this._mercatorProjection = new ge(), this._verticalPerspectiveProjection = new Ol();
        }
        get transitionState() {
          const s = this.properties.get("type");
          if (typeof s == "string" && s === "mercator") return 0;
          if (typeof s == "string" && s === "vertical-perspective") return 1;
          if (s instanceof a.bc) {
            if (s.from === "vertical-perspective" && s.to === "mercator") return 1 - s.transition;
            if (s.from === "mercator" && s.to === "vertical-perspective") return s.transition;
          }
          return 1;
        }
        get useGlobeRendering() {
          return this.transitionState > 0;
        }
        get latitudeErrorCorrectionRadians() {
          return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians;
        }
        get currentProjection() {
          return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection;
        }
        get name() {
          return "globe";
        }
        get useSubdivision() {
          return this.currentProjection.useSubdivision;
        }
        get shaderVariantName() {
          return this.currentProjection.shaderVariantName;
        }
        get shaderDefine() {
          return this.currentProjection.shaderDefine;
        }
        get shaderPreludeCode() {
          return this.currentProjection.shaderPreludeCode;
        }
        get vertexShaderPreludeCode() {
          return this.currentProjection.vertexShaderPreludeCode;
        }
        get subdivisionGranularity() {
          return this.currentProjection.subdivisionGranularity;
        }
        get useGlobeControls() {
          return this.transitionState > 0;
        }
        destroy() {
          this._mercatorProjection.destroy(), this._verticalPerspectiveProjection.destroy();
        }
        updateGPUdependent(s) {
          this._mercatorProjection.updateGPUdependent(s), this._verticalPerspectiveProjection.updateGPUdependent(s);
        }
        getMeshFromTileID(s, u, p, m, x) {
          return this.currentProjection.getMeshFromTileID(s, u, p, m, x);
        }
        setProjection(s) {
          this._transitionable.setValue("type", (s == null ? void 0 : s.type) || "mercator");
        }
        updateTransitions(s) {
          this._transitioning = this._transitionable.transitioned(s, this._transitioning);
        }
        hasTransition() {
          return this._transitioning.hasTransition() || this.currentProjection.hasTransition();
        }
        recalculate(s) {
          this.properties = this._transitioning.possiblyEvaluate(s);
        }
        setErrorQueryLatitudeDegrees(s) {
          this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(s), this._mercatorProjection.setErrorQueryLatitudeDegrees(s);
        }
      }
      function su(b) {
        const s = Ks(b.worldSize, b.center.lat);
        return 2 * Math.PI * s;
      }
      function ol(b, s, u, p, m) {
        const x = 1 / (1 << m), E = s / a.Y * x + p * x, L = a.be((b / a.Y * x + u * x) * Math.PI * 2 + Math.PI, 2 * Math.PI), B = 2 * Math.atan(Math.exp(Math.PI - E * Math.PI * 2)) - 0.5 * Math.PI, N = Math.cos(B), G = new Float64Array(3);
        return G[0] = Math.sin(L) * N, G[1] = Math.sin(B), G[2] = Math.cos(L) * N, G;
      }
      function yi(b) {
        return function(s, u) {
          const p = Math.cos(u), m = new Float64Array(3);
          return m[0] = Math.sin(s) * p, m[1] = Math.sin(u), m[2] = Math.cos(s) * p, m;
        }(b.lng * Math.PI / 180, b.lat * Math.PI / 180);
      }
      function Ks(b, s) {
        return b / (2 * Math.PI) / Math.cos(s * Math.PI / 180);
      }
      function fo(b) {
        const s = Math.asin(b[1]) / Math.PI * 180, u = Math.sqrt(b[0] * b[0] + b[2] * b[2]);
        if (u > 1e-6) {
          const p = b[0] / u, m = Math.acos(b[2] / u), x = (p > 0 ? m : -m) / Math.PI * 180;
          return new a.O(a.aJ(x, -180, 180), s);
        }
        return new a.O(0, s);
      }
      function Qs(b) {
        return Math.cos(b * Math.PI / 180);
      }
      function ji(b, s) {
        const u = Qs(b), p = Qs(s);
        return a.a9(p / u);
      }
      function Dl(b, s) {
        const u = b.rotate(s.bearingInRadians), p = s.zoom + ji(s.center.lat, 0), m = a.ba(1 / Qs(s.center.lat), 1 / Qs(Math.min(Math.abs(s.center.lat), 60)), a.bd(p, 7, 3, 0, 1)), x = 360 / su({ worldSize: s.worldSize, center: { lat: s.center.lat } });
        return new a.O(s.center.lng - u.x * x * m, a.ac(s.center.lat + u.y * x, -85.051129, a.aH));
      }
      function eo(b) {
        const s = 0.5 * b, u = Math.sin(s), p = Math.cos(s);
        return Math.log(u + p) - Math.log(p - u);
      }
      function ku(b, s, u, p) {
        const m = b.lat + u * p;
        if (Math.abs(u) > 1) {
          const x = (Math.sign(b.lat + u) !== Math.sign(b.lat) ? -Math.abs(b.lat) : Math.abs(b.lat)) * Math.PI / 180, E = Math.abs(b.lat + u) * Math.PI / 180, L = eo(x + p * (E - x)), B = eo(x), N = eo(E);
          return new a.O(b.lng + s * ((L - B) / (N - B)), m);
        }
        return new a.O(b.lng + s * p, m);
      }
      class Pc {
        constructor(s) {
          this._cachePrevious = /* @__PURE__ */ new Map(), this._cache = /* @__PURE__ */ new Map(), this._hadAnyChanges = !1, this._aabbFactory = s;
        }
        recalculateCache() {
          if (!this._hadAnyChanges) return;
          const s = this._cachePrevious;
          this._cachePrevious = this._cache, this._cache = s, this._cache.clear(), this._hadAnyChanges = !1;
        }
        getTileAABB(s, u, p, m) {
          const x = `${s.z}_${s.x}_${s.y}`, E = this._cache.get(x);
          if (E) return E;
          const L = this._cachePrevious.get(x);
          if (L) return this._cache.set(x, L), L;
          const B = this._aabbFactory(s, u, p, m);
          return this._cache.set(x, B), this._hadAnyChanges = !0, B;
        }
      }
      function Ic(b, s, u) {
        const p = b - s;
        return p < 0 ? -p : Math.max(0, p - u);
      }
      function Fl(b, s, u, p, m) {
        const x = b - u;
        let E;
        return E = x < 0 ? Math.min(-x, 1 + x - m) : x > 1 ? Math.min(Math.max(x - m, 0), 1 - x) : 0, Math.max(E, Ic(s, p, m));
      }
      class ou {
        constructor() {
          this._aabbCache = new Pc(this._computeTileAABB);
        }
        recalculateCache() {
          this._aabbCache.recalculateCache();
        }
        distanceToTile2d(s, u, p, m) {
          const x = 1 << p.z, E = 1 / x, L = p.x / x, B = p.y / x;
          let N = 2;
          return N = Math.min(N, Fl(s, u, L, B, E)), N = Math.min(N, Fl(s, u, L + 0.5, -B - E, E)), N = Math.min(N, Fl(s, u, L + 0.5, 2 - B - E, E)), N;
        }
        getWrap(s, u, p) {
          const m = 1 << u.z, x = 1 / m, E = u.x / m, L = Ic(s.x, E, x), B = Ic(s.x, E - 1, x), N = Ic(s.x, E + 1, x), G = Math.min(L, B, N);
          return G === N ? 1 : G === B ? -1 : 0;
        }
        allowVariableZoom(s, u) {
          return Dr(s, u) > 4;
        }
        allowWorldCopies() {
          return !1;
        }
        getTileAABB(s, u, p, m) {
          return this._aabbCache.getTileAABB(s, u, p, m);
        }
        _computeTileAABB(s, u, p, m) {
          if (s.z <= 0) return new qn([-1, -1, -1], [1, 1, 1]);
          if (s.z === 1) return new qn([s.x === 0 ? -1 : 0, s.y === 0 ? 0 : -1, -1], [s.x === 0 ? 0 : 1, s.y === 0 ? 1 : 0, 1]);
          {
            const x = [ol(0, 0, s.x, s.y, s.z), ol(a.Y, 0, s.x, s.y, s.z), ol(a.Y, a.Y, s.x, s.y, s.z), ol(0, a.Y, s.x, s.y, s.z)], E = [1, 1, 1], L = [-1, -1, -1];
            for (const B of x) for (let N = 0; N < 3; N++) E[N] = Math.min(E[N], B[N]), L[N] = Math.max(L[N], B[N]);
            if (s.y === 0 || s.y === (1 << s.z) - 1) {
              const B = [0, s.y === 0 ? 1 : -1, 0];
              for (let N = 0; N < 3; N++) E[N] = Math.min(E[N], B[N]), L[N] = Math.max(L[N], B[N]);
            }
            return new qn(E, L);
          }
        }
      }
      class Nl {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(s) {
          this._helper.setMinZoom(s);
        }
        setMaxZoom(s) {
          this._helper.setMaxZoom(s);
        }
        setMinPitch(s) {
          this._helper.setMinPitch(s);
        }
        setMaxPitch(s) {
          this._helper.setMaxPitch(s);
        }
        setRenderWorldCopies(s) {
          this._helper.setRenderWorldCopies(s);
        }
        setBearing(s) {
          this._helper.setBearing(s);
        }
        setPitch(s) {
          this._helper.setPitch(s);
        }
        setRoll(s) {
          this._helper.setRoll(s);
        }
        setFov(s) {
          this._helper.setFov(s);
        }
        setZoom(s) {
          this._helper.setZoom(s);
        }
        setCenter(s) {
          this._helper.setCenter(s);
        }
        setElevation(s) {
          this._helper.setElevation(s);
        }
        setMinElevationForCurrentTile(s) {
          this._helper.setMinElevationForCurrentTile(s);
        }
        setPadding(s) {
          this._helper.setPadding(s);
        }
        interpolatePadding(s, u, p) {
          return this._helper.interpolatePadding(s, u, p);
        }
        isPaddingEqual(s) {
          return this._helper.isPaddingEqual(s);
        }
        resize(s, u) {
          this._helper.resize(s, u);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(s) {
          this._helper.setMaxBounds(s);
        }
        overrideNearFarZ(s, u) {
          this._helper.overrideNearFarZ(s, u);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(s) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), s);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        setTransitionState(s) {
        }
        constructor() {
          this._cachedClippingPlane = a.bf(), this._projectionMatrix = a.a$(), this._globeViewProjMatrix32f = a.a_(), this._globeViewProjMatrixNoCorrection = a.a$(), this._globeViewProjMatrixNoCorrectionInverted = a.a$(), this._globeProjMatrixInverted = a.a$(), this._cameraPosition = a.bg(), this._globeLatitudeErrorCorrectionRadians = 0, this._helper = new Ki({ calcMatrices: () => {
            this._calcMatrices();
          }, getConstrained: (s, u) => this.getConstrained(s, u) }), this._coveringTilesDetailsProvider = new ou();
        }
        clone() {
          const s = new Nl();
          return s.apply(this), s;
        }
        apply(s, u) {
          this._globeLatitudeErrorCorrectionRadians = u || 0, this._helper.apply(s);
        }
        get projectionMatrix() {
          return this._projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this._globeViewProjMatrixNoCorrection;
        }
        get inverseProjectionMatrix() {
          return this._globeProjMatrixInverted;
        }
        get cameraPosition() {
          const s = a.bg();
          return s[0] = this._cameraPosition[0], s[1] = this._cameraPosition[1], s[2] = this._cameraPosition[2], s;
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        getProjectionData(s) {
          const { overscaledTileID: u, applyGlobeMatrix: p } = s, m = this._helper.getMercatorTileCoordinates(u);
          return { mainMatrix: this._globeViewProjMatrix32f, tileMercatorCoords: m, clippingPlane: this._cachedClippingPlane, projectionTransition: p ? 1 : 0, fallbackMatrix: this._globeViewProjMatrix32f };
        }
        _computeClippingPlane(s) {
          const u = this.pitchInRadians, p = this.cameraToCenterDistance / s, m = Math.sin(u) * p, x = Math.cos(u) * p + 1, E = 1 / Math.sqrt(m * m + x * x) * 1;
          let L = -m, B = x;
          const N = Math.sqrt(L * L + B * B);
          L /= N, B /= N;
          const G = [0, L, B];
          return a.bh(G, G, [0, 0, 0], -this.bearingInRadians), a.bi(G, G, [0, 0, 0], -1 * this.center.lat * Math.PI / 180), a.bj(G, G, [0, 0, 0], this.center.lng * Math.PI / 180), a.aM(G, G, 0.25), [...G, 0.25 * -E];
        }
        isLocationOccluded(s) {
          return !this.isSurfacePointVisible(yi(s));
        }
        transformLightDirection(s) {
          const u = this._helper._center.lng * Math.PI / 180, p = this._helper._center.lat * Math.PI / 180, m = Math.cos(p), x = [Math.sin(u) * m, Math.sin(p), Math.cos(u) * m], E = [x[2], 0, -x[0]], L = [0, 0, 0];
          a.aS(L, E, x), a.aR(E, E), a.aR(L, L);
          const B = [0, 0, 0];
          return a.aR(B, [E[0] * s[0] + L[0] * s[1] + x[0] * s[2], E[1] * s[0] + L[1] * s[1] + x[1] * s[2], E[2] * s[0] + L[2] * s[1] + x[2] * s[2]]), B;
        }
        getPixelScale() {
          return 1 / Math.cos(this._helper._center.lat * Math.PI / 180);
        }
        getCircleRadiusCorrection() {
          return Math.cos(this._helper._center.lat * Math.PI / 180);
        }
        getPitchedTextCorrection(s, u, p) {
          const m = function(L, B, N) {
            const G = 1 / (1 << N.z);
            return new a.Z(L / a.Y * G + N.x * G, B / a.Y * G + N.y * G);
          }(s, u, p.canonical), x = (E = m.y, [a.be(m.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - E * Math.PI * 2)) - 0.5 * Math.PI]);
          var E;
          return this.getCircleRadiusCorrection() / Math.cos(x[1]);
        }
        projectTileCoordinates(s, u, p, m) {
          const x = p.canonical, E = ol(s, u, x.x, x.y, x.z), L = 1 + (m ? m(s, u) : 0) / a.bp, B = [E[0] * L, E[1] * L, E[2] * L, 1];
          a.an(B, B, this._globeViewProjMatrixNoCorrection);
          const N = this._cachedClippingPlane, G = N[0] * E[0] + N[1] * E[1] + N[2] * E[2] + N[3] < 0;
          return { point: new a.P(B[0] / B[3], B[1] / B[3]), signedDistanceFromCamera: B[3], isOccluded: G };
        }
        _calcMatrices() {
          if (!this._helper._width || !this._helper._height) return;
          const s = Ks(this.worldSize, this.center.lat), u = a.b0(), p = a.b0();
          this._helper.autoCalculateNearFarZ && (this._helper._nearZ = 0.5, this._helper._farZ = this.cameraToCenterDistance + 2 * s), a.aW(u, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
          const m = this.centerOffset;
          u[8] = 2 * -m.x / this._helper._width, u[9] = 2 * m.y / this._helper._height, this._projectionMatrix = a.aX(u), this._globeProjMatrixInverted = a.b0(), a.ah(this._globeProjMatrixInverted, u), a.K(u, u, [0, 0, -this.cameraToCenterDistance]), a.aY(u, u, this.rollInRadians), a.aZ(u, u, -this.pitchInRadians), a.aY(u, u, this.bearingInRadians), a.K(u, u, [0, 0, -s]);
          const x = a.bg();
          x[0] = s, x[1] = s, x[2] = s, a.aZ(p, u, this.center.lat * Math.PI / 180), a.bk(p, p, -this.center.lng * Math.PI / 180), a.L(p, p, x), this._globeViewProjMatrixNoCorrection = p, a.aZ(u, u, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians), a.bk(u, u, -this.center.lng * Math.PI / 180), a.L(u, u, x), this._globeViewProjMatrix32f = new Float32Array(u), this._globeViewProjMatrixNoCorrectionInverted = a.b0(), a.ah(this._globeViewProjMatrixNoCorrectionInverted, p);
          const E = a.bg();
          this._cameraPosition = a.bg(), this._cameraPosition[2] = this.cameraToCenterDistance / s, a.bh(this._cameraPosition, this._cameraPosition, E, -this.rollInRadians), a.bi(this._cameraPosition, this._cameraPosition, E, this.pitchInRadians), a.bh(this._cameraPosition, this._cameraPosition, E, -this.bearingInRadians), a.aN(this._cameraPosition, this._cameraPosition, [0, 0, 1]), a.bi(this._cameraPosition, this._cameraPosition, E, -this.center.lat * Math.PI / 180), a.bj(this._cameraPosition, this._cameraPosition, E, this.center.lng * Math.PI / 180), this._cachedClippingPlane = this._computeClippingPlane(s);
          const L = a.aX(this._globeViewProjMatrixNoCorrectionInverted);
          a.L(L, L, [1, 1, -1]), this._cachedFrustum = ho.fromInvProjectionMatrix(L);
        }
        calculateFogMatrix(s) {
          a.w("calculateFogMatrix is not supported on globe projection.");
          const u = a.b0();
          return a.ar(u), u;
        }
        getVisibleUnwrappedCoordinates(s) {
          return [new a.aU(0, s)];
        }
        getCameraFrustum() {
          return this._cachedFrustum;
        }
        getClippingPlane() {
          return this._cachedClippingPlane;
        }
        getCoveringTilesDetailsProvider() {
          return this._coveringTilesDetailsProvider;
        }
        recalculateZoomAndCenter(s) {
          s && a.w("terrain is not fully supported on vertical perspective projection."), this._helper.recalculateZoomAndCenter(0);
        }
        maxPitchScaleFactor() {
          return 1;
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          return this._helper.getCameraLngLat();
        }
        lngLatToCameraDepth(s, u) {
          if (!this._globeViewProjMatrixNoCorrection) return 1;
          const p = yi(s);
          a.aM(p, p, 1 + u / a.bp);
          const m = a.bf();
          return a.an(m, [p[0], p[1], p[2], 1], this._globeViewProjMatrixNoCorrection), m[2] / m[3];
        }
        populateCache(s) {
        }
        getBounds() {
          const s = 0.5 * this.width, u = 0.5 * this.height, p = [new a.P(0, 0), new a.P(s, 0), new a.P(this.width, 0), new a.P(this.width, u), new a.P(this.width, this.height), new a.P(s, this.height), new a.P(0, this.height), new a.P(0, u)], m = [];
          for (const Z of p) m.push(this.unprojectScreenPoint(Z));
          let x = 0, E = 0, L = 0, B = 0;
          const N = this.center;
          for (const Z of m) {
            const $ = a.bl(N.lng, Z.lng), re = a.bl(N.lat, Z.lat);
            $ < E && (E = $), $ > x && (x = $), re < B && (B = re), re > L && (L = re);
          }
          const G = [N.lng + E, N.lat + B, N.lng + x, N.lat + L];
          return this.isSurfacePointOnScreen([0, 1, 0]) && (G[3] = 90, G[0] = -180, G[2] = 180), this.isSurfacePointOnScreen([0, -1, 0]) && (G[1] = -90, G[0] = -180, G[2] = 180), new wn(G);
        }
        getConstrained(s, u) {
          const p = a.ac(s.lat, -85.051129, a.aH), m = a.ac(+u, this.minZoom + ji(0, p), this.maxZoom);
          return { center: new a.O(s.lng, p), zoom: m };
        }
        calculateCenterFromCameraLngLatAlt(s, u, p, m) {
          return this._helper.calculateCenterFromCameraLngLatAlt(s, u, p, m);
        }
        setLocationAtPoint(s, u) {
          const p = yi(this.unprojectScreenPoint(u)), m = yi(s), x = a.bg();
          a.bm(x);
          const E = a.bg();
          a.bj(E, p, x, -this.center.lng * Math.PI / 180), a.bi(E, E, x, this.center.lat * Math.PI / 180);
          const L = m[0] * m[0] + m[2] * m[2], B = E[0] * E[0];
          if (L < B) return;
          const N = Math.sqrt(L - B), G = -N, Z = a.bn(m[0], m[2], E[0], N), $ = a.bn(m[0], m[2], E[0], G), re = a.bg();
          a.bj(re, m, x, -Z);
          const ae = a.bn(re[1], re[2], E[1], E[2]), Pe = a.bg();
          a.bj(Pe, m, x, -$);
          const Ce = a.bn(Pe[1], Pe[2], E[1], E[2]), Ie = 0.5 * Math.PI, Be = ae >= -Ie && ae <= Ie, He = Ce >= -Ie && Ce <= Ie;
          let We, $e;
          if (Be && He) {
            const bt = this.center.lng * Math.PI / 180, Mt = this.center.lat * Math.PI / 180;
            a.bq(Z, bt) + a.bq(ae, Mt) < a.bq($, bt) + a.bq(Ce, Mt) ? (We = Z, $e = ae) : (We = $, $e = Ce);
          } else if (Be) We = Z, $e = ae;
          else {
            if (!He) return;
            We = $, $e = Ce;
          }
          const Je = We / Math.PI * 180, Qe = $e / Math.PI * 180, wt = this.center.lat;
          this.setCenter(new a.O(Je, a.ac(Qe, -90, 90))), this.setZoom(this.zoom + ji(wt, this.center.lat));
        }
        locationToScreenPoint(s, u) {
          const p = yi(s);
          if (u) {
            const m = u.getElevationForLngLatZoom(s, this._helper._tileZoom);
            a.aM(p, p, 1 + m / a.bp);
          }
          return this._projectSurfacePointToScreen(p);
        }
        _projectSurfacePointToScreen(s) {
          const u = a.bf();
          return a.an(u, [...s, 1], this._globeViewProjMatrixNoCorrection), u[0] /= u[3], u[1] /= u[3], new a.P((0.5 * u[0] + 0.5) * this.width, (0.5 * -u[1] + 0.5) * this.height);
        }
        screenPointToMercatorCoordinate(s, u) {
          if (u) {
            const p = u.pointCoordinate(s);
            if (p) return p;
          }
          return a.Z.fromLngLat(this.unprojectScreenPoint(s));
        }
        screenPointToLocation(s, u) {
          var p;
          return (p = this.screenPointToMercatorCoordinate(s, u)) === null || p === void 0 ? void 0 : p.toLngLat();
        }
        isPointOnMapSurface(s, u) {
          const p = this._cameraPosition, m = this.getRayDirectionFromPixel(s);
          return !!this.rayPlanetIntersection(p, m);
        }
        getRayDirectionFromPixel(s) {
          const u = a.bf();
          u[0] = s.x / this.width * 2 - 1, u[1] = -1 * (s.y / this.height * 2 - 1), u[2] = 1, u[3] = 1, a.an(u, u, this._globeViewProjMatrixNoCorrectionInverted), u[0] /= u[3], u[1] /= u[3], u[2] /= u[3];
          const p = a.bg();
          p[0] = u[0] - this._cameraPosition[0], p[1] = u[1] - this._cameraPosition[1], p[2] = u[2] - this._cameraPosition[2];
          const m = a.bg();
          return a.aR(m, p), m;
        }
        isSurfacePointVisible(s) {
          const u = this._cachedClippingPlane;
          return u[0] * s[0] + u[1] * s[1] + u[2] * s[2] + u[3] >= 0;
        }
        isSurfacePointOnScreen(s) {
          if (!this.isSurfacePointVisible(s)) return !1;
          const u = a.bf();
          return a.an(u, [...s, 1], this._globeViewProjMatrixNoCorrection), u[0] /= u[3], u[1] /= u[3], u[2] /= u[3], u[0] > -1 && u[0] < 1 && u[1] > -1 && u[1] < 1 && u[2] > -1 && u[2] < 1;
        }
        rayPlanetIntersection(s, u) {
          const p = a.aT(s, u), m = a.bg(), x = a.bg();
          a.aM(x, u, p), a.aQ(m, s, x);
          const E = 1 - a.aT(m, m);
          if (E < 0) return null;
          const L = a.aT(s, s) - 1, B = -p + (p < 0 ? 1 : -1) * Math.sqrt(E), N = L / B, G = B;
          return { tMin: Math.min(N, G), tMax: Math.max(N, G) };
        }
        unprojectScreenPoint(s) {
          const u = this._cameraPosition, p = this.getRayDirectionFromPixel(s), m = this.rayPlanetIntersection(u, p);
          if (m) {
            const N = a.bg();
            a.aN(N, u, [p[0] * m.tMin, p[1] * m.tMin, p[2] * m.tMin]);
            const G = a.bg();
            return a.aR(G, N), fo(G);
          }
          const x = this._cachedClippingPlane[0] * p[0] + this._cachedClippingPlane[1] * p[1] + this._cachedClippingPlane[2] * p[2], E = -a.bo(this._cachedClippingPlane, u) / x, L = a.bg();
          if (E > 0) a.aN(L, u, [p[0] * E, p[1] * E, p[2] * E]);
          else {
            const N = a.bg();
            a.aN(N, u, [2 * p[0], 2 * p[1], 2 * p[2]]);
            const G = a.bo(this._cachedClippingPlane, N);
            a.aQ(L, N, [this._cachedClippingPlane[0] * G, this._cachedClippingPlane[1] * G, this._cachedClippingPlane[2] * G]);
          }
          const B = a.bg();
          return a.aR(B, L), fo(B);
        }
        getMatrixForModel(s, u) {
          const p = a.O.convert(s), m = 1 / a.bp, x = a.a$();
          return a.bk(x, x, p.lng / 180 * Math.PI), a.aZ(x, x, -p.lat / 180 * Math.PI), a.K(x, x, [0, 0, 1 + u / a.bp]), a.aZ(x, x, 0.5 * Math.PI), a.L(x, x, [m, m, m]), x;
        }
        getProjectionDataForCustomLayer() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          const u = this.getProjectionData({ overscaledTileID: new a.X(0, 0, 0, 0, 0), applyGlobeMatrix: s });
          return u.tileMercatorCoords = [0, 0, 1, 1], u;
        }
        getFastPathSimpleProjectionMatrix(s) {
        }
      }
      class Co {
        get pixelsToClipSpaceMatrix() {
          return this._helper.pixelsToClipSpaceMatrix;
        }
        get clipSpaceToPixelsMatrix() {
          return this._helper.clipSpaceToPixelsMatrix;
        }
        get pixelsToGLUnits() {
          return this._helper.pixelsToGLUnits;
        }
        get centerOffset() {
          return this._helper.centerOffset;
        }
        get size() {
          return this._helper.size;
        }
        get rotationMatrix() {
          return this._helper.rotationMatrix;
        }
        get centerPoint() {
          return this._helper.centerPoint;
        }
        get pixelsPerMeter() {
          return this._helper.pixelsPerMeter;
        }
        setMinZoom(s) {
          this._helper.setMinZoom(s);
        }
        setMaxZoom(s) {
          this._helper.setMaxZoom(s);
        }
        setMinPitch(s) {
          this._helper.setMinPitch(s);
        }
        setMaxPitch(s) {
          this._helper.setMaxPitch(s);
        }
        setRenderWorldCopies(s) {
          this._helper.setRenderWorldCopies(s);
        }
        setBearing(s) {
          this._helper.setBearing(s);
        }
        setPitch(s) {
          this._helper.setPitch(s);
        }
        setRoll(s) {
          this._helper.setRoll(s);
        }
        setFov(s) {
          this._helper.setFov(s);
        }
        setZoom(s) {
          this._helper.setZoom(s);
        }
        setCenter(s) {
          this._helper.setCenter(s);
        }
        setElevation(s) {
          this._helper.setElevation(s);
        }
        setMinElevationForCurrentTile(s) {
          this._helper.setMinElevationForCurrentTile(s);
        }
        setPadding(s) {
          this._helper.setPadding(s);
        }
        interpolatePadding(s, u, p) {
          return this._helper.interpolatePadding(s, u, p);
        }
        isPaddingEqual(s) {
          return this._helper.isPaddingEqual(s);
        }
        resize(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
          this._helper.resize(s, u, p);
        }
        getMaxBounds() {
          return this._helper.getMaxBounds();
        }
        setMaxBounds(s) {
          this._helper.setMaxBounds(s);
        }
        overrideNearFarZ(s, u) {
          this._helper.overrideNearFarZ(s, u);
        }
        clearNearFarZOverride() {
          this._helper.clearNearFarZOverride();
        }
        getCameraQueryGeometry(s) {
          return this._helper.getCameraQueryGeometry(this.getCameraPoint(), s);
        }
        get tileSize() {
          return this._helper.tileSize;
        }
        get tileZoom() {
          return this._helper.tileZoom;
        }
        get scale() {
          return this._helper.scale;
        }
        get worldSize() {
          return this._helper.worldSize;
        }
        get width() {
          return this._helper.width;
        }
        get height() {
          return this._helper.height;
        }
        get lngRange() {
          return this._helper.lngRange;
        }
        get latRange() {
          return this._helper.latRange;
        }
        get minZoom() {
          return this._helper.minZoom;
        }
        get maxZoom() {
          return this._helper.maxZoom;
        }
        get zoom() {
          return this._helper.zoom;
        }
        get center() {
          return this._helper.center;
        }
        get minPitch() {
          return this._helper.minPitch;
        }
        get maxPitch() {
          return this._helper.maxPitch;
        }
        get pitch() {
          return this._helper.pitch;
        }
        get pitchInRadians() {
          return this._helper.pitchInRadians;
        }
        get roll() {
          return this._helper.roll;
        }
        get rollInRadians() {
          return this._helper.rollInRadians;
        }
        get bearing() {
          return this._helper.bearing;
        }
        get bearingInRadians() {
          return this._helper.bearingInRadians;
        }
        get fov() {
          return this._helper.fov;
        }
        get fovInRadians() {
          return this._helper.fovInRadians;
        }
        get elevation() {
          return this._helper.elevation;
        }
        get minElevationForCurrentTile() {
          return this._helper.minElevationForCurrentTile;
        }
        get padding() {
          return this._helper.padding;
        }
        get unmodified() {
          return this._helper.unmodified;
        }
        get renderWorldCopies() {
          return this._helper.renderWorldCopies;
        }
        get cameraToCenterDistance() {
          return this._helper.cameraToCenterDistance;
        }
        get nearZ() {
          return this._helper.nearZ;
        }
        get farZ() {
          return this._helper.farZ;
        }
        get autoCalculateNearFarZ() {
          return this._helper.autoCalculateNearFarZ;
        }
        get isGlobeRendering() {
          return this._globeness > 0;
        }
        setTransitionState(s, u) {
          this._globeness = s, this._globeLatitudeErrorCorrectionRadians = u, this._calcMatrices(), this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().recalculateCache(), this._mercatorTransform.getCoveringTilesDetailsProvider().recalculateCache();
        }
        get currentTransform() {
          return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform;
        }
        constructor() {
          this._globeLatitudeErrorCorrectionRadians = 0, this._globeness = 1, this._helper = new Ki({ calcMatrices: () => {
            this._calcMatrices();
          }, getConstrained: (s, u) => this.getConstrained(s, u) }), this._globeness = 1, this._mercatorTransform = new Vn(), this._verticalPerspectiveTransform = new Nl();
        }
        clone() {
          const s = new Co();
          return s._globeness = this._globeness, s._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians, s.apply(this), s;
        }
        apply(s) {
          this._helper.apply(s), this._mercatorTransform.apply(this), this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians);
        }
        get projectionMatrix() {
          return this.currentTransform.projectionMatrix;
        }
        get modelViewProjectionMatrix() {
          return this.currentTransform.modelViewProjectionMatrix;
        }
        get inverseProjectionMatrix() {
          return this.currentTransform.inverseProjectionMatrix;
        }
        get cameraPosition() {
          return this.currentTransform.cameraPosition;
        }
        getProjectionData(s) {
          const u = this._mercatorTransform.getProjectionData(s), p = this._verticalPerspectiveTransform.getProjectionData(s);
          return { mainMatrix: this.isGlobeRendering ? p.mainMatrix : u.mainMatrix, clippingPlane: p.clippingPlane, tileMercatorCoords: p.tileMercatorCoords, projectionTransition: s.applyGlobeMatrix ? this._globeness : 0, fallbackMatrix: u.fallbackMatrix };
        }
        isLocationOccluded(s) {
          return this.currentTransform.isLocationOccluded(s);
        }
        transformLightDirection(s) {
          return this.currentTransform.transformLightDirection(s);
        }
        getPixelScale() {
          return a.ba(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness);
        }
        getCircleRadiusCorrection() {
          return a.ba(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness);
        }
        getPitchedTextCorrection(s, u, p) {
          const m = this._mercatorTransform.getPitchedTextCorrection(s, u, p), x = this._verticalPerspectiveTransform.getPitchedTextCorrection(s, u, p);
          return a.ba(m, x, this._globeness);
        }
        projectTileCoordinates(s, u, p, m) {
          return this.currentTransform.projectTileCoordinates(s, u, p, m);
        }
        _calcMatrices() {
          this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians), this._helper._nearZ = this._verticalPerspectiveTransform.nearZ, this._helper._farZ = this._verticalPerspectiveTransform.farZ, this._mercatorTransform.apply(this, !0, this.isGlobeRendering), this._helper._nearZ = this._mercatorTransform.nearZ, this._helper._farZ = this._mercatorTransform.farZ);
        }
        calculateFogMatrix(s) {
          return this.currentTransform.calculateFogMatrix(s);
        }
        getVisibleUnwrappedCoordinates(s) {
          return this.currentTransform.getVisibleUnwrappedCoordinates(s);
        }
        getCameraFrustum() {
          return this.currentTransform.getCameraFrustum();
        }
        getClippingPlane() {
          return this.currentTransform.getClippingPlane();
        }
        getCoveringTilesDetailsProvider() {
          return this.currentTransform.getCoveringTilesDetailsProvider();
        }
        recalculateZoomAndCenter(s) {
          this._mercatorTransform.recalculateZoomAndCenter(s), this._verticalPerspectiveTransform.recalculateZoomAndCenter(s);
        }
        maxPitchScaleFactor() {
          return this._mercatorTransform.maxPitchScaleFactor();
        }
        getCameraPoint() {
          return this._helper.getCameraPoint();
        }
        getCameraAltitude() {
          return this._helper.getCameraAltitude();
        }
        getCameraLngLat() {
          return this._helper.getCameraLngLat();
        }
        lngLatToCameraDepth(s, u) {
          return this.currentTransform.lngLatToCameraDepth(s, u);
        }
        populateCache(s) {
          this._mercatorTransform.populateCache(s), this._verticalPerspectiveTransform.populateCache(s);
        }
        getBounds() {
          return this.currentTransform.getBounds();
        }
        getConstrained(s, u) {
          return this.currentTransform.getConstrained(s, u);
        }
        calculateCenterFromCameraLngLatAlt(s, u, p, m) {
          return this._helper.calculateCenterFromCameraLngLatAlt(s, u, p, m);
        }
        setLocationAtPoint(s, u) {
          if (!this.isGlobeRendering) return this._mercatorTransform.setLocationAtPoint(s, u), void this.apply(this._mercatorTransform);
          this._verticalPerspectiveTransform.setLocationAtPoint(s, u), this.apply(this._verticalPerspectiveTransform);
        }
        locationToScreenPoint(s, u) {
          return this.currentTransform.locationToScreenPoint(s, u);
        }
        screenPointToMercatorCoordinate(s, u) {
          return this.currentTransform.screenPointToMercatorCoordinate(s, u);
        }
        screenPointToLocation(s, u) {
          return this.currentTransform.screenPointToLocation(s, u);
        }
        isPointOnMapSurface(s, u) {
          return this.currentTransform.isPointOnMapSurface(s, u);
        }
        getRayDirectionFromPixel(s) {
          return this._verticalPerspectiveTransform.getRayDirectionFromPixel(s);
        }
        getMatrixForModel(s, u) {
          return this.currentTransform.getMatrixForModel(s, u);
        }
        getProjectionDataForCustomLayer() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          const u = this._mercatorTransform.getProjectionDataForCustomLayer(s);
          if (!this.isGlobeRendering) return u;
          const p = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(s);
          return p.fallbackMatrix = u.mainMatrix, p;
        }
        getFastPathSimpleProjectionMatrix(s) {
          return this.currentTransform.getFastPathSimpleProjectionMatrix(s);
        }
      }
      class cs {
        get useGlobeControls() {
          return !0;
        }
        handlePanInertia(s, u) {
          const p = Dl(s, u);
          return Math.abs(p.lng - u.center.lng) > 180 && (p.lng = u.center.lng + 179.5 * Math.sign(p.lng - u.center.lng)), { easingCenter: p, easingOffset: new a.P(0, 0) };
        }
        handleMapControlsRollPitchBearingZoom(s, u) {
          const p = s.around, m = u.screenPointToLocation(p);
          s.bearingDelta && u.setBearing(u.bearing + s.bearingDelta), s.pitchDelta && u.setPitch(u.pitch + s.pitchDelta), s.rollDelta && u.setRoll(u.roll + s.rollDelta);
          const x = u.zoom;
          s.zoomDelta && u.setZoom(u.zoom + s.zoomDelta);
          const E = u.zoom - x;
          if (E === 0) return;
          const L = a.bl(u.center.lng, m.lng), B = L / (Math.abs(L / 180) + 1), N = a.bl(u.center.lat, m.lat), G = u.getRayDirectionFromPixel(p), Z = u.cameraPosition, $ = -1 * a.aT(Z, G), re = a.bg();
          a.aN(re, Z, [G[0] * $, G[1] * $, G[2] * $]);
          const ae = a.br(re) - 1, Pe = Math.exp(0.5 * -Math.max(ae - 0.3, 0)), Ce = Ks(u.worldSize, u.center.lat) / Math.min(u.width, u.height), Ie = a.bd(Ce, 0.9, 0.5, 1, 0.25), Be = (1 - a.aG(-E)) * Math.min(Pe, Ie), He = u.center.lat, We = u.zoom, $e = new a.O(u.center.lng + B * Be, a.ac(u.center.lat + N * Be, -85.051129, a.aH));
          u.setLocationAtPoint(m, p);
          const Je = u.center, Qe = a.bd(Math.abs(L), 45, 85, 0, 1), wt = a.bd(Ce, 0.75, 0.35, 0, 1), bt = Math.pow(Math.max(Qe, wt), 0.25), Mt = a.bl(Je.lng, $e.lng), Nt = a.bl(Je.lat, $e.lat);
          u.setCenter(new a.O(Je.lng + Mt * bt, Je.lat + Nt * bt).wrap()), u.setZoom(We + ji(He, u.center.lat));
        }
        handleMapControlsPan(s, u, p) {
          if (!s.panDelta) return;
          const m = u.center.lat, x = u.zoom;
          u.setCenter(Dl(s.panDelta, u).wrap()), u.setZoom(x + ji(m, u.center.lat));
        }
        cameraForBoxAndBearing(s, u, p, m, x) {
          const E = Zr(s, u, p, m, x), L = u.left / x.width * 2 - 1, B = (x.width - u.right) / x.width * 2 - 1, N = u.top / x.height * -2 + 1, G = (x.height - u.bottom) / x.height * -2 + 1, Z = a.bl(p.getWest(), p.getEast()) < 0, $ = Z ? p.getEast() : p.getWest(), re = Z ? p.getWest() : p.getEast(), ae = Math.max(p.getNorth(), p.getSouth()), Pe = Math.min(p.getNorth(), p.getSouth()), Ce = $ + 0.5 * a.bl($, re), Ie = ae + 0.5 * a.bl(ae, Pe), Be = x.clone();
          Be.setCenter(E.center), Be.setBearing(E.bearing), Be.setPitch(0), Be.setRoll(0), Be.setZoom(E.zoom);
          const He = Be.modelViewProjectionMatrix, We = [yi(p.getNorthWest()), yi(p.getNorthEast()), yi(p.getSouthWest()), yi(p.getSouthEast()), yi(new a.O(re, Ie)), yi(new a.O($, Ie)), yi(new a.O(Ce, ae)), yi(new a.O(Ce, Pe))], $e = yi(E.center);
          let Je = Number.POSITIVE_INFINITY;
          for (const Qe of We) L < 0 && (Je = cs.getLesserNonNegativeNonNull(Je, cs.solveVectorScale(Qe, $e, He, "x", L))), B > 0 && (Je = cs.getLesserNonNegativeNonNull(Je, cs.solveVectorScale(Qe, $e, He, "x", B))), N > 0 && (Je = cs.getLesserNonNegativeNonNull(Je, cs.solveVectorScale(Qe, $e, He, "y", N))), G < 0 && (Je = cs.getLesserNonNegativeNonNull(Je, cs.solveVectorScale(Qe, $e, He, "y", G)));
          if (Number.isFinite(Je) && Je !== 0) return E.zoom = Be.zoom + a.a9(Je), E;
          Js();
        }
        handleJumpToCenterZoom(s, u) {
          const p = s.center.lat, m = s.getConstrained(u.center ? a.O.convert(u.center) : s.center, s.zoom).center;
          s.setCenter(m.wrap());
          const x = u.zoom !== void 0 ? +u.zoom : s.zoom + ji(p, m.lat);
          s.zoom !== x && s.setZoom(x);
        }
        handleEaseTo(s, u) {
          const p = s.zoom, m = s.center, x = s.padding, E = { roll: s.roll, pitch: s.pitch, bearing: s.bearing }, L = { roll: u.roll === void 0 ? s.roll : u.roll, pitch: u.pitch === void 0 ? s.pitch : u.pitch, bearing: u.bearing === void 0 ? s.bearing : u.bearing }, B = u.zoom !== void 0, N = !s.isPaddingEqual(u.padding);
          let G = !1;
          const Z = u.center ? a.O.convert(u.center) : m, $ = s.getConstrained(Z, p).center;
          hi(s, $);
          const re = s.clone();
          re.setCenter($), re.setZoom(B ? +u.zoom : p + ji(m.lat, Z.lat)), re.setBearing(u.bearing);
          const ae = new a.P(a.ac(s.centerPoint.x + u.offsetAsPoint.x, 0, s.width), a.ac(s.centerPoint.y + u.offsetAsPoint.y, 0, s.height));
          re.setLocationAtPoint($, ae);
          const Pe = (u.offset && u.offsetAsPoint.mag()) > 0 ? re.center : $, Ce = B ? +u.zoom : p + ji(m.lat, Pe.lat), Ie = p + ji(m.lat, 0), Be = Ce + ji(Pe.lat, 0), He = a.bl(m.lng, Pe.lng), We = a.bl(m.lat, Pe.lat), $e = a.aG(Be - Ie);
          return G = Ce !== p, { easeFunc: (Je) => {
            if (a.b4(E, L) || ru({ startEulerAngles: E, endEulerAngles: L, tr: s, k: Je, useSlerp: E.roll != L.roll }), N && s.interpolatePadding(x, u.padding, Je), u.around) a.w("Easing around a point is not supported under globe projection."), s.setLocationAtPoint(u.around, u.aroundPoint);
            else {
              const Qe = Be > Ie ? Math.min(2, $e) : Math.max(0.5, $e), wt = Math.pow(Qe, 1 - Je), bt = ku(m, He, We, Je * wt);
              s.setCenter(bt.wrap());
            }
            if (G) {
              const Qe = a.z.number(Ie, Be, Je) + ji(0, s.center.lat);
              s.setZoom(Qe);
            }
          }, isZooming: G, elevationCenter: Pe };
        }
        handleFlyTo(s, u) {
          const p = u.zoom !== void 0, m = s.center, x = s.zoom, E = s.padding, L = !s.isPaddingEqual(u.padding), B = s.getConstrained(a.O.convert(u.center || u.locationAtOffset), x).center, N = p ? +u.zoom : s.zoom + ji(s.center.lat, B.lat), G = s.clone();
          G.setCenter(B), G.setZoom(N), G.setBearing(u.bearing);
          const Z = new a.P(a.ac(s.centerPoint.x + u.offsetAsPoint.x, 0, s.width), a.ac(s.centerPoint.y + u.offsetAsPoint.y, 0, s.height));
          G.setLocationAtPoint(B, Z);
          const $ = G.center;
          hi(s, $);
          const re = function(We, $e, Je) {
            const Qe = yi($e), wt = yi(Je), bt = a.aT(Qe, wt), Mt = Math.acos(bt), Nt = su(We);
            return Mt / (2 * Math.PI) * Nt;
          }(s, m, $), ae = x + ji(m.lat, 0), Pe = N + ji($.lat, 0), Ce = a.aG(Pe - ae);
          let Ie;
          if (typeof u.minZoom == "number") {
            const We = +u.minZoom + ji($.lat, 0), $e = Math.min(We, ae, Pe) + ji(0, $.lat), Je = s.getConstrained($, $e).zoom + ji($.lat, 0);
            Ie = a.aG(Je - ae);
          }
          const Be = a.bl(m.lng, $.lng), He = a.bl(m.lat, $.lat);
          return { easeFunc: (We, $e, Je, Qe) => {
            const wt = ku(m, Be, He, Je);
            L && s.interpolatePadding(E, u.padding, We);
            const bt = We === 1 ? $ : wt;
            s.setCenter(bt.wrap());
            const Mt = ae + a.a9($e);
            s.setZoom(We === 1 ? N : Mt + ji(0, bt.lat));
          }, scaleOfZoom: Ce, targetCenter: $, scaleOfMinZoom: Ie, pixelPathLength: re };
        }
        static solveVectorScale(s, u, p, m, x) {
          const E = m === "x" ? [p[0], p[4], p[8], p[12]] : [p[1], p[5], p[9], p[13]], L = [p[3], p[7], p[11], p[15]], B = s[0] * E[0] + s[1] * E[1] + s[2] * E[2], N = s[0] * L[0] + s[1] * L[1] + s[2] * L[2], G = u[0] * E[0] + u[1] * E[1] + u[2] * E[2], Z = u[0] * L[0] + u[1] * L[1] + u[2] * L[2];
          return G + x * N === B + x * Z || L[3] * (B - G) + E[3] * (Z - N) + B * Z == G * N ? null : (G + E[3] - x * Z - x * L[3]) / (G - B - x * Z + x * N);
        }
        static getLesserNonNegativeNonNull(s, u) {
          return u !== null && u >= 0 && u < s ? u : s;
        }
      }
      class La {
        constructor(s) {
          this._globe = s, this._mercatorCameraHelper = new Ll(), this._verticalPerspectiveCameraHelper = new cs();
        }
        get useGlobeControls() {
          return this._globe.useGlobeRendering;
        }
        get currentHelper() {
          return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper;
        }
        handlePanInertia(s, u) {
          return this.currentHelper.handlePanInertia(s, u);
        }
        handleMapControlsRollPitchBearingZoom(s, u) {
          return this.currentHelper.handleMapControlsRollPitchBearingZoom(s, u);
        }
        handleMapControlsPan(s, u, p) {
          this.currentHelper.handleMapControlsPan(s, u, p);
        }
        cameraForBoxAndBearing(s, u, p, m, x) {
          return this.currentHelper.cameraForBoxAndBearing(s, u, p, m, x);
        }
        handleJumpToCenterZoom(s, u) {
          this.currentHelper.handleJumpToCenterZoom(s, u);
        }
        handleEaseTo(s, u) {
          return this.currentHelper.handleEaseTo(s, u);
        }
        handleFlyTo(s, u) {
          return this.currentHelper.handleFlyTo(s, u);
        }
      }
      const Ra = (b, s) => a.t(b, s && s.filter((u) => u.identifier !== "source.canvas")), au = a.bs();
      class us extends a.E {
        constructor(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          super(), this._rtlPluginLoaded = () => {
            for (const p in this.sourceCaches) {
              const m = this.sourceCaches[p].getSource().type;
              m !== "vector" && m !== "geojson" || this.sourceCaches[p].reload();
            }
          }, this.map = s, this.dispatcher = new rt(ot(), s._getMapId()), this.dispatcher.registerMessageHandler("GG", (p, m) => this.getGlyphs(p, m)), this.dispatcher.registerMessageHandler("GI", (p, m) => this.getImages(p, m)), this.imageManager = new ke(), this.imageManager.setEventedParent(this), this.glyphManager = new Me(s._requestManager, u.localIdeographFontFamily), this.lineAtlas = new Ft(256, 512), this.crossTileSymbolIndex = new yr(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new a.bt(), this._loaded = !1, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("SR", a.bu()), fi().on($n, this._rtlPluginLoaded), this.on("data", (p) => {
            if (p.dataType !== "source" || p.sourceDataType !== "metadata") return;
            const m = this.sourceCaches[p.sourceId];
            if (!m) return;
            const x = m.getSource();
            if (x && x.vectorLayerIds) for (const E in this._layers) {
              const L = this._layers[E];
              L.source === x.id && this._validateLayer(L);
            }
          });
        }
        loadURL(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = arguments.length > 2 ? arguments[2] : void 0;
          this.fire(new a.k("dataloading", { dataType: "style" })), u.validate = typeof u.validate != "boolean" || u.validate;
          const m = this.map._requestManager.transformRequest(s, "Style");
          this._loadStyleRequest = new AbortController();
          const x = this._loadStyleRequest;
          a.h(m, this._loadStyleRequest).then((E) => {
            this._loadStyleRequest = null, this._load(E.data, u, p);
          }).catch((E) => {
            this._loadStyleRequest = null, E && !x.signal.aborted && this.fire(new a.j(E));
          });
        }
        loadJSON(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = arguments.length > 2 ? arguments[2] : void 0;
          this.fire(new a.k("dataloading", { dataType: "style" })), this._frameRequest = new AbortController(), I.frameAsync(this._frameRequest).then(() => {
            this._frameRequest = null, u.validate = u.validate !== !1, this._load(s, u, p);
          }).catch(() => {
          });
        }
        loadEmpty() {
          this.fire(new a.k("dataloading", { dataType: "style" })), this._load(au, { validate: !1 });
        }
        _load(s, u, p) {
          var m, x;
          const E = u.transformStyle ? u.transformStyle(p, s) : s;
          if (!u.validate || !Ra(this, a.x(E))) {
            this._loaded = !0, this.stylesheet = E;
            for (const L in E.sources) this.addSource(L, E.sources[L], { validate: !1 });
            E.sprite ? this._loadSprite(E.sprite) : this.imageManager.setLoaded(!0), this.glyphManager.setURL(E.glyphs), this._createLayers(), this.light = new Pt(this.stylesheet.light), this._setProjectionInternal(((m = this.stylesheet.projection) === null || m === void 0 ? void 0 : m.type) || "mercator"), this.sky = new Rt(this.stylesheet.sky), this.map.setTerrain((x = this.stylesheet.terrain) !== null && x !== void 0 ? x : null), this.fire(new a.k("data", { dataType: "style" })), this.fire(new a.k("style.load"));
          }
        }
        _createLayers() {
          const s = a.bv(this.stylesheet.layers);
          this.dispatcher.broadcast("SL", s), this._order = s.map((u) => u.id), this._layers = {}, this._serializedLayers = null;
          for (const u of s) {
            const p = a.bw(u);
            p.setEventedParent(this, { layer: { id: u.id } }), this._layers[u.id] = p;
          }
        }
        _loadSprite(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0, m;
          this.imageManager.setLoaded(!1), this._spriteRequest = new AbortController(), function(x, E, L, B) {
            return a._(this, void 0, void 0, function* () {
              const N = Ae(x), G = L > 1 ? "@2x" : "", Z = {}, $ = {};
              for (const { id: re, url: ae } of N) {
                const Pe = E.transformRequest(Te(ae, G, ".json"), "SpriteJSON");
                Z[re] = a.h(Pe, B);
                const Ce = E.transformRequest(Te(ae, G, ".png"), "SpriteImage");
                $[re] = ie.getImage(Ce, B);
              }
              return yield Promise.all([...Object.values(Z), ...Object.values($)]), function(re, ae) {
                return a._(this, void 0, void 0, function* () {
                  const Pe = {};
                  for (const Ce in re) {
                    Pe[Ce] = {};
                    const Ie = I.getImageCanvasContext((yield ae[Ce]).data), Be = (yield re[Ce]).data;
                    for (const He in Be) {
                      const { width: We, height: $e, x: Je, y: Qe, sdf: wt, pixelRatio: bt, stretchX: Mt, stretchY: Nt, content: Ct, textFitWidth: sn, textFitHeight: nn } = Be[He];
                      Pe[Ce][He] = { data: null, pixelRatio: bt, sdf: wt, stretchX: Mt, stretchY: Nt, content: Ct, textFitWidth: sn, textFitHeight: nn, spriteData: { width: We, height: $e, x: Je, y: Qe, context: Ie } };
                    }
                  }
                  return Pe;
                });
              }(Z, $);
            });
          }(s, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then((x) => {
            if (this._spriteRequest = null, x) for (const E in x) {
              this._spritesImagesIds[E] = [];
              const L = this._spritesImagesIds[E] ? this._spritesImagesIds[E].filter((B) => !(B in x)) : [];
              for (const B of L) this.imageManager.removeImage(B), this._changedImages[B] = !0;
              for (const B in x[E]) {
                const N = E === "default" ? B : `${E}:${B}`;
                this._spritesImagesIds[E].push(N), N in this.imageManager.images ? this.imageManager.updateImage(N, x[E][B], !1) : this.imageManager.addImage(N, x[E][B]), u && (this._changedImages[N] = !0);
              }
            }
          }).catch((x) => {
            this._spriteRequest = null, m = x, this.fire(new a.j(m));
          }).finally(() => {
            this.imageManager.setLoaded(!0), this._availableImages = this.imageManager.listImages(), u && (this._changed = !0), this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.k("data", { dataType: "style" })), p && p(m);
          });
        }
        _unloadSprite() {
          for (const s of Object.values(this._spritesImagesIds).flat()) this.imageManager.removeImage(s), this._changedImages[s] = !0;
          this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.k("data", { dataType: "style" }));
        }
        _validateLayer(s) {
          const u = this.sourceCaches[s.source];
          if (!u) return;
          const p = s.sourceLayer;
          if (!p) return;
          const m = u.getSource();
          (m.type === "geojson" || m.vectorLayerIds && m.vectorLayerIds.indexOf(p) === -1) && this.fire(new a.j(new Error(`Source layer "${p}" does not exist on source "${m.id}" as specified by style layer "${s.id}".`)));
        }
        loaded() {
          if (!this._loaded || Object.keys(this._updatedSources).length) return !1;
          for (const s in this.sourceCaches) if (!this.sourceCaches[s].loaded()) return !1;
          return !!this.imageManager.isLoaded();
        }
        _serializeByIds(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
          const p = this._serializedAllLayers();
          if (!s || s.length === 0) return Object.values(u ? a.bx(p) : p);
          const m = [];
          for (const x of s) if (p[x]) {
            const E = u ? a.bx(p[x]) : p[x];
            m.push(E);
          }
          return m;
        }
        _serializedAllLayers() {
          let s = this._serializedLayers;
          if (s) return s;
          s = this._serializedLayers = {};
          const u = Object.keys(this._layers);
          for (const p of u) {
            const m = this._layers[p];
            m.type !== "custom" && (s[p] = m.serialize());
          }
          return s;
        }
        hasTransitions() {
          var s, u, p;
          if (!((s = this.light) === null || s === void 0) && s.hasTransition() || !((u = this.sky) === null || u === void 0) && u.hasTransition() || !((p = this.projection) === null || p === void 0) && p.hasTransition()) return !0;
          for (const m in this.sourceCaches) if (this.sourceCaches[m].hasTransition()) return !0;
          for (const m in this._layers) if (this._layers[m].hasTransition()) return !0;
          return !1;
        }
        _checkLoaded() {
          if (!this._loaded) throw new Error("Style is not done loading.");
        }
        update(s) {
          if (!this._loaded) return;
          const u = this._changed;
          if (u) {
            const m = Object.keys(this._updatedLayers), x = Object.keys(this._removedLayers);
            (m.length || x.length) && this._updateWorkerLayers(m, x);
            for (const E in this._updatedSources) {
              const L = this._updatedSources[E];
              if (L === "reload") this._reloadSource(E);
              else {
                if (L !== "clear") throw new Error(`Invalid action ${L}`);
                this._clearSource(E);
              }
            }
            this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
            for (const E in this._updatedPaintProps) this._layers[E].updateTransitions(s);
            this.light.updateTransitions(s), this.sky.updateTransitions(s), this._resetUpdates();
          }
          const p = {};
          for (const m in this.sourceCaches) {
            const x = this.sourceCaches[m];
            p[m] = x.used, x.used = !1;
          }
          for (const m of this._order) {
            const x = this._layers[m];
            x.recalculate(s, this._availableImages), !x.isHidden(s.zoom) && x.source && (this.sourceCaches[x.source].used = !0);
          }
          for (const m in p) {
            const x = this.sourceCaches[m];
            !!p[m] != !!x.used && x.fire(new a.k("data", { sourceDataType: "visibility", dataType: "source", sourceId: m }));
          }
          this.light.recalculate(s), this.sky.recalculate(s), this.projection.recalculate(s), this.z = s.zoom, u && this.fire(new a.k("data", { dataType: "style" }));
        }
        _updateTilesForChangedImages() {
          const s = Object.keys(this._changedImages);
          if (s.length) {
            for (const u in this.sourceCaches) this.sourceCaches[u].reloadTilesForDependencies(["icons", "patterns"], s);
            this._changedImages = {};
          }
        }
        _updateTilesForChangedGlyphs() {
          if (this._glyphsDidChange) {
            for (const s in this.sourceCaches) this.sourceCaches[s].reloadTilesForDependencies(["glyphs"], [""]);
            this._glyphsDidChange = !1;
          }
        }
        _updateWorkerLayers(s, u) {
          this.dispatcher.broadcast("UL", { layers: this._serializeByIds(s, !1), removedIds: u });
        }
        _resetUpdates() {
          this._changed = !1, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = !1;
        }
        setState(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          var p;
          this._checkLoaded();
          const m = this.serialize();
          if (s = u.transformStyle ? u.transformStyle(m, s) : s, ((p = u.validate) === null || p === void 0 || p) && Ra(this, a.x(s))) return !1;
          (s = a.bx(s)).layers = a.bv(s.layers);
          const x = a.by(m, s), E = this._getOperationsToPerform(x);
          if (E.unimplemented.length > 0) throw new Error(`Unimplemented: ${E.unimplemented.join(", ")}.`);
          if (E.operations.length === 0) return !1;
          for (const L of E.operations) L();
          return this.stylesheet = s, this._serializedLayers = null, !0;
        }
        _getOperationsToPerform(s) {
          const u = [], p = [];
          for (const m of s) switch (m.command) {
            case "setCenter":
            case "setZoom":
            case "setBearing":
            case "setPitch":
            case "setRoll":
              continue;
            case "addLayer":
              u.push(() => this.addLayer.apply(this, m.args));
              break;
            case "removeLayer":
              u.push(() => this.removeLayer.apply(this, m.args));
              break;
            case "setPaintProperty":
              u.push(() => this.setPaintProperty.apply(this, m.args));
              break;
            case "setLayoutProperty":
              u.push(() => this.setLayoutProperty.apply(this, m.args));
              break;
            case "setFilter":
              u.push(() => this.setFilter.apply(this, m.args));
              break;
            case "addSource":
              u.push(() => this.addSource.apply(this, m.args));
              break;
            case "removeSource":
              u.push(() => this.removeSource.apply(this, m.args));
              break;
            case "setLayerZoomRange":
              u.push(() => this.setLayerZoomRange.apply(this, m.args));
              break;
            case "setLight":
              u.push(() => this.setLight.apply(this, m.args));
              break;
            case "setGeoJSONSourceData":
              u.push(() => this.setGeoJSONSourceData.apply(this, m.args));
              break;
            case "setGlyphs":
              u.push(() => this.setGlyphs.apply(this, m.args));
              break;
            case "setSprite":
              u.push(() => this.setSprite.apply(this, m.args));
              break;
            case "setTerrain":
              u.push(() => this.map.setTerrain.apply(this, m.args));
              break;
            case "setSky":
              u.push(() => this.setSky.apply(this, m.args));
              break;
            case "setProjection":
              this.setProjection.apply(this, m.args);
              break;
            case "setTransition":
              u.push(() => {
              });
              break;
            default:
              p.push(m.command);
          }
          return { operations: u, unimplemented: p };
        }
        addImage(s, u) {
          if (this.getImage(s)) return this.fire(new a.j(new Error(`An image named "${s}" already exists.`)));
          this.imageManager.addImage(s, u), this._afterImageUpdated(s);
        }
        updateImage(s, u) {
          this.imageManager.updateImage(s, u);
        }
        getImage(s) {
          return this.imageManager.getImage(s);
        }
        removeImage(s) {
          if (!this.getImage(s)) return this.fire(new a.j(new Error(`An image named "${s}" does not exist.`)));
          this.imageManager.removeImage(s), this._afterImageUpdated(s);
        }
        _afterImageUpdated(s) {
          this._availableImages = this.imageManager.listImages(), this._changedImages[s] = !0, this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.k("data", { dataType: "style" }));
        }
        listImages() {
          return this._checkLoaded(), this.imageManager.listImages();
        }
        addSource(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          if (this._checkLoaded(), this.sourceCaches[s] !== void 0) throw new Error(`Source "${s}" already exists.`);
          if (!u.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(u).join(", ")}.`);
          if (["vector", "raster", "geojson", "video", "image"].indexOf(u.type) >= 0 && this._validate(a.x.source, `sources.${s}`, u, null, p)) return;
          this.map && this.map._collectResourceTiming && (u.collectResourceTiming = !0);
          const m = this.sourceCaches[s] = new ne(s, u, this.dispatcher);
          m.style = this, m.setEventedParent(this, () => ({ isSourceLoaded: m.loaded(), source: m.serialize(), sourceId: s })), m.onAdd(this.map), this._changed = !0;
        }
        removeSource(s) {
          if (this._checkLoaded(), this.sourceCaches[s] === void 0) throw new Error("There is no source with this ID");
          for (const p in this._layers) if (this._layers[p].source === s) return this.fire(new a.j(new Error(`Source "${s}" cannot be removed while layer "${p}" is using it.`)));
          const u = this.sourceCaches[s];
          delete this.sourceCaches[s], delete this._updatedSources[s], u.fire(new a.k("data", { sourceDataType: "metadata", dataType: "source", sourceId: s })), u.setEventedParent(null), u.onRemove(this.map), this._changed = !0;
        }
        setGeoJSONSourceData(s, u) {
          if (this._checkLoaded(), this.sourceCaches[s] === void 0) throw new Error(`There is no source with this ID=${s}`);
          const p = this.sourceCaches[s].getSource();
          if (p.type !== "geojson") throw new Error(`geojsonSource.type is ${p.type}, which is !== 'geojson`);
          p.setData(u), this._changed = !0;
        }
        getSource(s) {
          return this.sourceCaches[s] && this.sourceCaches[s].getSource();
        }
        addLayer(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this._checkLoaded();
          const m = s.id;
          if (this.getLayer(m)) return void this.fire(new a.j(new Error(`Layer "${m}" already exists on this map.`)));
          let x;
          if (s.type === "custom") {
            if (Ra(this, a.bz(s))) return;
            x = a.bw(s);
          } else {
            if ("source" in s && typeof s.source == "object" && (this.addSource(m, s.source), s = a.bx(s), s = a.e(s, { source: m })), this._validate(a.x.layer, `layers.${m}`, s, { arrayIndex: -1 }, p)) return;
            x = a.bw(s), this._validateLayer(x), x.setEventedParent(this, { layer: { id: m } });
          }
          const E = u ? this._order.indexOf(u) : this._order.length;
          if (u && E === -1) this.fire(new a.j(new Error(`Cannot add layer "${m}" before non-existing layer "${u}".`)));
          else {
            if (this._order.splice(E, 0, m), this._layerOrderChanged = !0, this._layers[m] = x, this._removedLayers[m] && x.source && x.type !== "custom") {
              const L = this._removedLayers[m];
              delete this._removedLayers[m], L.type !== x.type ? this._updatedSources[x.source] = "clear" : (this._updatedSources[x.source] = "reload", this.sourceCaches[x.source].pause());
            }
            this._updateLayer(x), x.onAdd && x.onAdd(this.map);
          }
        }
        moveLayer(s, u) {
          if (this._checkLoaded(), this._changed = !0, !this._layers[s]) return void this.fire(new a.j(new Error(`The layer '${s}' does not exist in the map's style and cannot be moved.`)));
          if (s === u) return;
          const p = this._order.indexOf(s);
          this._order.splice(p, 1);
          const m = u ? this._order.indexOf(u) : this._order.length;
          u && m === -1 ? this.fire(new a.j(new Error(`Cannot move layer "${s}" before non-existing layer "${u}".`))) : (this._order.splice(m, 0, s), this._layerOrderChanged = !0);
        }
        removeLayer(s) {
          this._checkLoaded();
          const u = this._layers[s];
          if (!u) return void this.fire(new a.j(new Error(`Cannot remove non-existing layer "${s}".`)));
          u.setEventedParent(null);
          const p = this._order.indexOf(s);
          this._order.splice(p, 1), this._layerOrderChanged = !0, this._changed = !0, this._removedLayers[s] = u, delete this._layers[s], this._serializedLayers && delete this._serializedLayers[s], delete this._updatedLayers[s], delete this._updatedPaintProps[s], u.onRemove && u.onRemove(this.map);
        }
        getLayer(s) {
          return this._layers[s];
        }
        getLayersOrder() {
          return [...this._order];
        }
        hasLayer(s) {
          return s in this._layers;
        }
        setLayerZoomRange(s, u, p) {
          this._checkLoaded();
          const m = this.getLayer(s);
          m ? m.minzoom === u && m.maxzoom === p || (u != null && (m.minzoom = u), p != null && (m.maxzoom = p), this._updateLayer(m)) : this.fire(new a.j(new Error(`Cannot set the zoom range of non-existing layer "${s}".`)));
        }
        setFilter(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this._checkLoaded();
          const m = this.getLayer(s);
          if (m) {
            if (!a.bA(m.filter, u)) return u == null ? (m.filter = void 0, void this._updateLayer(m)) : void (this._validate(a.x.filter, `layers.${m.id}.filter`, u, null, p) || (m.filter = a.bx(u), this._updateLayer(m)));
          } else this.fire(new a.j(new Error(`Cannot filter non-existing layer "${s}".`)));
        }
        getFilter(s) {
          return a.bx(this.getLayer(s).filter);
        }
        setLayoutProperty(s, u, p) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          this._checkLoaded();
          const x = this.getLayer(s);
          x ? a.bA(x.getLayoutProperty(u), p) || (x.setLayoutProperty(u, p, m), this._updateLayer(x)) : this.fire(new a.j(new Error(`Cannot style non-existing layer "${s}".`)));
        }
        getLayoutProperty(s, u) {
          const p = this.getLayer(s);
          if (p) return p.getLayoutProperty(u);
          this.fire(new a.j(new Error(`Cannot get style of non-existing layer "${s}".`)));
        }
        setPaintProperty(s, u, p) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          this._checkLoaded();
          const x = this.getLayer(s);
          x ? a.bA(x.getPaintProperty(u), p) || (x.setPaintProperty(u, p, m) && this._updateLayer(x), this._changed = !0, this._updatedPaintProps[s] = !0, this._serializedLayers = null) : this.fire(new a.j(new Error(`Cannot style non-existing layer "${s}".`)));
        }
        getPaintProperty(s, u) {
          return this.getLayer(s).getPaintProperty(u);
        }
        setFeatureState(s, u) {
          this._checkLoaded();
          const p = s.source, m = s.sourceLayer, x = this.sourceCaches[p];
          if (x === void 0) return void this.fire(new a.j(new Error(`The source '${p}' does not exist in the map's style.`)));
          const E = x.getSource().type;
          E === "geojson" && m ? this.fire(new a.j(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : E !== "vector" || m ? (s.id === void 0 && this.fire(new a.j(new Error("The feature id parameter must be provided."))), x.setFeatureState(m, s.id, u)) : this.fire(new a.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        removeFeatureState(s, u) {
          this._checkLoaded();
          const p = s.source, m = this.sourceCaches[p];
          if (m === void 0) return void this.fire(new a.j(new Error(`The source '${p}' does not exist in the map's style.`)));
          const x = m.getSource().type, E = x === "vector" ? s.sourceLayer : void 0;
          x !== "vector" || E ? u && typeof s.id != "string" && typeof s.id != "number" ? this.fire(new a.j(new Error("A feature id is required to remove its specific state property."))) : m.removeFeatureState(E, s.id, u) : this.fire(new a.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
        }
        getFeatureState(s) {
          this._checkLoaded();
          const u = s.source, p = s.sourceLayer, m = this.sourceCaches[u];
          if (m !== void 0) return m.getSource().type !== "vector" || p ? (s.id === void 0 && this.fire(new a.j(new Error("The feature id parameter must be provided."))), m.getFeatureState(p, s.id)) : void this.fire(new a.j(new Error("The sourceLayer parameter must be provided for vector source types.")));
          this.fire(new a.j(new Error(`The source '${u}' does not exist in the map's style.`)));
        }
        getTransition() {
          return a.e({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
        }
        serialize() {
          if (!this._loaded) return;
          const s = a.bB(this.sourceCaches, (x) => x.serialize()), u = this._serializeByIds(this._order, !0), p = this.map.getTerrain() || void 0, m = this.stylesheet;
          return a.bC({ version: m.version, name: m.name, metadata: m.metadata, light: m.light, sky: m.sky, center: m.center, zoom: m.zoom, bearing: m.bearing, pitch: m.pitch, sprite: m.sprite, glyphs: m.glyphs, transition: m.transition, projection: m.projection, sources: s, layers: u, terrain: p }, (x) => x !== void 0);
        }
        _updateLayer(s) {
          this._updatedLayers[s.id] = !0, s.source && !this._updatedSources[s.source] && this.sourceCaches[s.source].getSource().type !== "raster" && (this._updatedSources[s.source] = "reload", this.sourceCaches[s.source].pause()), this._serializedLayers = null, this._changed = !0;
        }
        _flattenAndSortRenderedFeatures(s) {
          const u = (E) => this._layers[E].type === "fill-extrusion", p = {}, m = [];
          for (let E = this._order.length - 1; E >= 0; E--) {
            const L = this._order[E];
            if (u(L)) {
              p[L] = E;
              for (const B of s) {
                const N = B[L];
                if (N) for (const G of N) m.push(G);
              }
            }
          }
          m.sort((E, L) => L.intersectionZ - E.intersectionZ);
          const x = [];
          for (let E = this._order.length - 1; E >= 0; E--) {
            const L = this._order[E];
            if (u(L)) for (let B = m.length - 1; B >= 0; B--) {
              const N = m[B].feature;
              if (p[N.layer.id] < E) break;
              x.push(N), m.pop();
            }
            else for (const B of s) {
              const N = B[L];
              if (N) for (const G of N) x.push(G.feature);
            }
          }
          return x;
        }
        queryRenderedFeatures(s, u, p) {
          u && u.filter && this._validate(a.x.filter, "queryRenderedFeatures.filter", u.filter, null, u);
          const m = {};
          if (u && u.layers) {
            if (!(Array.isArray(u.layers) || u.layers instanceof Set)) return this.fire(new a.j(new Error("parameters.layers must be an Array or a Set of strings"))), [];
            for (const N of u.layers) {
              const G = this._layers[N];
              if (!G) return this.fire(new a.j(new Error(`The layer '${N}' does not exist in the map's style and cannot be queried for features.`))), [];
              m[G.source] = !0;
            }
          }
          const x = [];
          u.availableImages = this._availableImages;
          const E = this._serializedAllLayers(), L = u.layers instanceof Set ? u.layers : Array.isArray(u.layers) ? new Set(u.layers) : null, B = Object.assign(Object.assign({}, u), { layers: L });
          for (const N in this.sourceCaches) u.layers && !m[N] || x.push($t(this.sourceCaches[N], this._layers, E, s, B, p));
          return this.placement && x.push(function(N, G, Z, $, re, ae, Pe) {
            const Ce = {}, Ie = ae.queryRenderedSymbols($), Be = [];
            for (const He of Object.keys(Ie).map(Number)) Be.push(Pe[He]);
            Be.sort(Wt);
            for (const He of Be) {
              const We = He.featureIndex.lookupSymbolFeatures(Ie[He.bucketInstanceId], G, He.bucketIndex, He.sourceLayerIndex, re.filter, re.layers, re.availableImages, N);
              for (const $e in We) {
                const Je = Ce[$e] = Ce[$e] || [], Qe = We[$e];
                Qe.sort((wt, bt) => {
                  const Mt = He.featureSortOrder;
                  if (Mt) {
                    const Nt = Mt.indexOf(wt.featureIndex);
                    return Mt.indexOf(bt.featureIndex) - Nt;
                  }
                  return bt.featureIndex - wt.featureIndex;
                });
                for (const wt of Qe) Je.push(wt);
              }
            }
            return function(He, We, $e) {
              for (const Je in He) for (const Qe of He[Je]) on(Qe, $e[We[Je].source]);
              return He;
            }(Ce, N, Z);
          }(this._layers, E, this.sourceCaches, s, B, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(x);
        }
        querySourceFeatures(s, u) {
          u && u.filter && this._validate(a.x.filter, "querySourceFeatures.filter", u.filter, null, u);
          const p = this.sourceCaches[s];
          return p ? function(m, x) {
            const E = m.getRenderableIds().map((N) => m.getTileByID(N)), L = [], B = {};
            for (let N = 0; N < E.length; N++) {
              const G = E[N], Z = G.tileID.canonical.key;
              B[Z] || (B[Z] = !0, G.querySourceFeatures(L, x));
            }
            return L;
          }(p, u) : [];
        }
        getLight() {
          return this.light.getLight();
        }
        setLight(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this._checkLoaded();
          const p = this.light.getLight();
          let m = !1;
          for (const E in s) if (!a.bA(s[E], p[E])) {
            m = !0;
            break;
          }
          if (!m) return;
          const x = { now: I.now(), transition: a.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.light.setLight(s, u), this.light.updateTransitions(x);
        }
        getProjection() {
          var s;
          return (s = this.stylesheet) === null || s === void 0 ? void 0 : s.projection;
        }
        setProjection(s) {
          if (this._checkLoaded(), this.projection) {
            if (this.projection.name === s.type) return;
            this.projection.destroy(), delete this.projection;
          }
          this.stylesheet.projection = s, this._setProjectionInternal(s.type);
        }
        getSky() {
          var s;
          return (s = this.stylesheet) === null || s === void 0 ? void 0 : s.sky;
        }
        setSky(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this._checkLoaded();
          const p = this.getSky();
          let m = !1;
          if (!s && !p) return;
          if (s && !p) m = !0;
          else if (!s && p) m = !0;
          else for (const E in s) if (!a.bA(s[E], p[E])) {
            m = !0;
            break;
          }
          if (!m) return;
          const x = { now: I.now(), transition: a.e({ duration: 300, delay: 0 }, this.stylesheet.transition) };
          this.stylesheet.sky = s, this.sky.setSky(s, u), this.sky.updateTransitions(x);
        }
        _setProjectionInternal(s) {
          const u = function(p) {
            if (Array.isArray(p)) {
              const m = new Cc({ type: p });
              return { projection: m, transform: new Co(), cameraHelper: new La(m) };
            }
            switch (p) {
              case "mercator":
                return { projection: new ge(), transform: new Vn(), cameraHelper: new Ll() };
              case "globe": {
                const m = new Cc({ type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"] });
                return { projection: m, transform: new Co(), cameraHelper: new La(m) };
              }
              case "vertical-perspective":
                return { projection: new Ol(), transform: new Nl(), cameraHelper: new cs() };
              default:
                return a.w(`Unknown projection name: ${p}. Falling back to mercator projection.`), { projection: new ge(), transform: new Vn(), cameraHelper: new Ll() };
            }
          }(s);
          this.projection = u.projection, this.map.migrateProjection(u.transform, u.cameraHelper);
          for (const p in this.sourceCaches) this.sourceCaches[p].reload();
        }
        _validate(s, u, p, m) {
          let x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
          return (!x || x.validate !== !1) && Ra(this, s.call(a.x, a.e({ key: u, style: this.serialize(), value: p, styleSpec: a.v }, m)));
        }
        _remove() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._loadStyleRequest && (this._loadStyleRequest.abort(), this._loadStyleRequest = null), this._spriteRequest && (this._spriteRequest.abort(), this._spriteRequest = null), fi().off($n, this._rtlPluginLoaded);
          for (const u in this._layers) this._layers[u].setEventedParent(null);
          for (const u in this.sourceCaches) {
            const p = this.sourceCaches[u];
            p.setEventedParent(null), p.onRemove(this.map);
          }
          this.imageManager.setEventedParent(null), this.setEventedParent(null), s && this.dispatcher.broadcast("RM", void 0), this.dispatcher.remove(s);
        }
        _clearSource(s) {
          this.sourceCaches[s].clearTiles();
        }
        _reloadSource(s) {
          this.sourceCaches[s].resume(), this.sourceCaches[s].reload();
        }
        _updateSources(s) {
          for (const u in this.sourceCaches) this.sourceCaches[u].update(s, this.map.terrain);
        }
        _generateCollisionBoxes() {
          for (const s in this.sourceCaches) this._reloadSource(s);
        }
        _updatePlacement(s, u, p, m) {
          let x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, E = !1, L = !1;
          const B = {};
          for (const N of this._order) {
            const G = this._layers[N];
            if (G.type !== "symbol") continue;
            if (!B[G.source]) {
              const $ = this.sourceCaches[G.source];
              B[G.source] = $.getRenderableIds(!0).map((re) => $.getTileByID(re)).sort((re, ae) => ae.tileID.overscaledZ - re.tileID.overscaledZ || (re.tileID.isLessThan(ae.tileID) ? -1 : 1));
            }
            const Z = this.crossTileSymbolIndex.addLayer(G, B[G.source], s.center.lng);
            E = E || Z;
          }
          if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((x = x || this._layerOrderChanged || p === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(I.now(), s.zoom)) && (this.pauseablePlacement = new ha(s, this.map.terrain, this._order, x, u, p, m, this.placement), this._layerOrderChanged = !1), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, B), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(I.now()), L = !0), E && this.pauseablePlacement.placement.setStale()), L || E) for (const N of this._order) {
            const G = this._layers[N];
            G.type === "symbol" && this.placement.updateLayerOpacities(G, B[G.source]);
          }
          return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(I.now());
        }
        _releaseSymbolFadeTiles() {
          for (const s in this.sourceCaches) this.sourceCaches[s].releaseSymbolFadeTiles();
        }
        getImages(s, u) {
          return a._(this, void 0, void 0, function* () {
            const p = yield this.imageManager.getImages(u.icons);
            this._updateTilesForChangedImages();
            const m = this.sourceCaches[u.source];
            return m && m.setDependencies(u.tileID.key, u.type, u.icons), p;
          });
        }
        getGlyphs(s, u) {
          return a._(this, void 0, void 0, function* () {
            const p = yield this.glyphManager.getGlyphs(u.stacks), m = this.sourceCaches[u.source];
            return m && m.setDependencies(u.tileID.key, u.type, [""]), p;
          });
        }
        getGlyphsUrl() {
          return this.stylesheet.glyphs || null;
        }
        setGlyphs(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          this._checkLoaded(), s && this._validate(a.x.glyphs, "glyphs", s, null, u) || (this._glyphsDidChange = !0, this.stylesheet.glyphs = s, this.glyphManager.entries = {}, this.glyphManager.setURL(s));
        }
        addSprite(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, m = arguments.length > 3 ? arguments[3] : void 0;
          this._checkLoaded();
          const x = [{ id: s, url: u }], E = [...Ae(this.stylesheet.sprite), ...x];
          this._validate(a.x.sprite, "sprite", E, null, p) || (this.stylesheet.sprite = E, this._loadSprite(x, !0, m));
        }
        removeSprite(s) {
          this._checkLoaded();
          const u = Ae(this.stylesheet.sprite);
          if (u.find((p) => p.id === s)) {
            if (this._spritesImagesIds[s]) for (const p of this._spritesImagesIds[s]) this.imageManager.removeImage(p), this._changedImages[p] = !0;
            u.splice(u.findIndex((p) => p.id === s), 1), this.stylesheet.sprite = u.length > 0 ? u : void 0, delete this._spritesImagesIds[s], this._availableImages = this.imageManager.listImages(), this._changed = !0, this.dispatcher.broadcast("SI", this._availableImages), this.fire(new a.k("data", { dataType: "style" }));
          } else this.fire(new a.j(new Error(`Sprite "${s}" doesn't exists on this map.`)));
        }
        getSprite() {
          return Ae(this.stylesheet.sprite);
        }
        setSprite(s) {
          let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, p = arguments.length > 2 ? arguments[2] : void 0;
          this._checkLoaded(), s && this._validate(a.x.sprite, "sprite", s, null, u) || (this.stylesheet.sprite = s, s ? this._loadSprite(s, !0, p) : (this._unloadSprite(), p && p(null)));
        }
      }
      var kl = a.aB([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
      class zl {
        constructor() {
          this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
        }
        bind(s, u, p, m, x, E, L, B, N) {
          this.context = s;
          let G = this.boundPaintVertexBuffers.length !== m.length;
          for (let Z = 0; !G && Z < m.length; Z++) this.boundPaintVertexBuffers[Z] !== m[Z] && (G = !0);
          !this.vao || this.boundProgram !== u || this.boundLayoutVertexBuffer !== p || G || this.boundIndexBuffer !== x || this.boundVertexOffset !== E || this.boundDynamicVertexBuffer !== L || this.boundDynamicVertexBuffer2 !== B || this.boundDynamicVertexBuffer3 !== N ? this.freshBind(u, p, m, x, E, L, B, N) : (s.bindVertexArray.set(this.vao), L && L.bind(), x && x.dynamicDraw && x.bind(), B && B.bind(), N && N.bind());
        }
        freshBind(s, u, p, m, x, E, L, B) {
          const N = s.numAttributes, G = this.context, Z = G.gl;
          this.vao && this.destroy(), this.vao = G.createVertexArray(), G.bindVertexArray.set(this.vao), this.boundProgram = s, this.boundLayoutVertexBuffer = u, this.boundPaintVertexBuffers = p, this.boundIndexBuffer = m, this.boundVertexOffset = x, this.boundDynamicVertexBuffer = E, this.boundDynamicVertexBuffer2 = L, this.boundDynamicVertexBuffer3 = B, u.enableAttributes(Z, s);
          for (const $ of p) $.enableAttributes(Z, s);
          E && E.enableAttributes(Z, s), L && L.enableAttributes(Z, s), B && B.enableAttributes(Z, s), u.bind(), u.setVertexAttribPointers(Z, s, x);
          for (const $ of p) $.bind(), $.setVertexAttribPointers(Z, s, x);
          E && (E.bind(), E.setVertexAttribPointers(Z, s, x)), m && m.bind(), L && (L.bind(), L.setVertexAttribPointers(Z, s, x)), B && (B.bind(), B.setVertexAttribPointers(Z, s, x)), G.currentNumAttributes = N;
        }
        destroy() {
          this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
        }
      }
      const Po = (b, s, u, p, m) => ({ u_texture: 0, u_ele_delta: b, u_fog_matrix: s, u_fog_color: u ? u.properties.get("fog-color") : a.b5.white, u_fog_ground_blend: u ? u.properties.get("fog-ground-blend") : 1, u_fog_ground_blend_opacity: m ? 0 : u ? u.calculateFogBlendOpacity(p) : 0, u_horizon_color: u ? u.properties.get("horizon-color") : a.b5.white, u_horizon_fog_blend: u ? u.properties.get("horizon-fog-blend") : 1, u_is_globe_mode: m ? 1 : 0 }), Ba = { mainMatrix: "u_projection_matrix", tileMercatorCoords: "u_projection_tile_mercator_coords", clippingPlane: "u_projection_clipping_plane", projectionTransition: "u_projection_transition", fallbackMatrix: "u_projection_fallback_matrix" };
      function O(b) {
        const s = [];
        for (let u = 0; u < b.length; u++) {
          if (b[u] === null) continue;
          const p = b[u].split(" ");
          s.push(p.pop());
        }
        return s;
      }
      class te {
        constructor(s, u, p, m, x, E, L, B) {
          const N = s.gl;
          this.program = N.createProgram();
          const G = O(u.staticAttributes), Z = p ? p.getBinderAttributes() : [], $ = G.concat(Z), re = nr.prelude.staticUniforms ? O(nr.prelude.staticUniforms) : [], ae = L.staticUniforms ? O(L.staticUniforms) : [], Pe = u.staticUniforms ? O(u.staticUniforms) : [], Ce = p ? p.getBinderUniforms() : [], Ie = re.concat(ae).concat(Pe).concat(Ce), Be = [];
          for (const bt of Ie) Be.indexOf(bt) < 0 && Be.push(bt);
          const He = p ? p.defines() : [];
          ls(N) && He.unshift("#version 300 es"), x && He.push("#define OVERDRAW_INSPECTOR;"), E && He.push("#define TERRAIN3D;"), B && He.push(B);
          let We = He.concat(nr.prelude.fragmentSource, L.fragmentSource, u.fragmentSource).join(`
`), $e = He.concat(nr.prelude.vertexSource, L.vertexSource, u.vertexSource).join(`
`);
          ls(N) || (We = function(bt) {
            return bt.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(");
          }(We), $e = function(bt) {
            return bt.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(");
          }($e));
          const Je = N.createShader(N.FRAGMENT_SHADER);
          if (N.isContextLost()) return void (this.failedToCreate = !0);
          if (N.shaderSource(Je, We), N.compileShader(Je), !N.getShaderParameter(Je, N.COMPILE_STATUS)) throw new Error(`Could not compile fragment shader: ${N.getShaderInfoLog(Je)}`);
          N.attachShader(this.program, Je);
          const Qe = N.createShader(N.VERTEX_SHADER);
          if (N.isContextLost()) return void (this.failedToCreate = !0);
          if (N.shaderSource(Qe, $e), N.compileShader(Qe), !N.getShaderParameter(Qe, N.COMPILE_STATUS)) throw new Error(`Could not compile vertex shader: ${N.getShaderInfoLog(Qe)}`);
          N.attachShader(this.program, Qe), this.attributes = {};
          const wt = {};
          this.numAttributes = $.length;
          for (let bt = 0; bt < this.numAttributes; bt++) $[bt] && (N.bindAttribLocation(this.program, bt, $[bt]), this.attributes[$[bt]] = bt);
          if (N.linkProgram(this.program), !N.getProgramParameter(this.program, N.LINK_STATUS)) throw new Error(`Program failed to link: ${N.getProgramInfoLog(this.program)}`);
          N.deleteShader(Qe), N.deleteShader(Je);
          for (let bt = 0; bt < Be.length; bt++) {
            const Mt = Be[bt];
            if (Mt && !wt[Mt]) {
              const Nt = N.getUniformLocation(this.program, Mt);
              Nt && (wt[Mt] = Nt);
            }
          }
          this.fixedUniforms = m(s, wt), this.terrainUniforms = ((bt, Mt) => ({ u_depth: new a.bD(bt, Mt.u_depth), u_terrain: new a.bD(bt, Mt.u_terrain), u_terrain_dim: new a.b6(bt, Mt.u_terrain_dim), u_terrain_matrix: new a.bF(bt, Mt.u_terrain_matrix), u_terrain_unpack: new a.bG(bt, Mt.u_terrain_unpack), u_terrain_exaggeration: new a.b6(bt, Mt.u_terrain_exaggeration) }))(s, wt), this.projectionUniforms = ((bt, Mt) => ({ u_projection_matrix: new a.bF(bt, Mt.u_projection_matrix), u_projection_tile_mercator_coords: new a.bG(bt, Mt.u_projection_tile_mercator_coords), u_projection_clipping_plane: new a.bG(bt, Mt.u_projection_clipping_plane), u_projection_transition: new a.b6(bt, Mt.u_projection_transition), u_projection_fallback_matrix: new a.bF(bt, Mt.u_projection_fallback_matrix) }))(s, wt), this.binderUniforms = p ? p.getUniforms(s, wt) : [];
        }
        draw(s, u, p, m, x, E, L, B, N, G, Z, $, re, ae, Pe, Ce, Ie, Be, He) {
          const We = s.gl;
          if (this.failedToCreate) return;
          if (s.program.set(this.program), s.setDepthMode(p), s.setStencilMode(m), s.setColorMode(x), s.setCullFace(E), B) {
            s.activeTexture.set(We.TEXTURE2), We.bindTexture(We.TEXTURE_2D, B.depthTexture), s.activeTexture.set(We.TEXTURE3), We.bindTexture(We.TEXTURE_2D, B.texture);
            for (const Je in this.terrainUniforms) this.terrainUniforms[Je].set(B[Je]);
          }
          if (N) for (const Je in N) this.projectionUniforms[Ba[Je]].set(N[Je]);
          if (L) for (const Je in this.fixedUniforms) this.fixedUniforms[Je].set(L[Je]);
          Ce && Ce.setUniforms(s, this.binderUniforms, ae, { zoom: Pe });
          let $e = 0;
          switch (u) {
            case We.LINES:
              $e = 2;
              break;
            case We.TRIANGLES:
              $e = 3;
              break;
            case We.LINE_STRIP:
              $e = 1;
          }
          for (const Je of re.get()) {
            const Qe = Je.vaos || (Je.vaos = {});
            (Qe[G] || (Qe[G] = new zl())).bind(s, this, Z, Ce ? Ce.getPaintVertexBuffers() : [], $, Je.vertexOffset, Ie, Be, He), We.drawElements(u, Je.primitiveLength * $e, We.UNSIGNED_SHORT, Je.primitiveOffset * $e * 2);
          }
        }
      }
      function Fe(b, s, u) {
        const p = 1 / a.au(u, 1, s.transform.tileZoom), m = Math.pow(2, u.tileID.overscaledZ), x = u.tileSize * Math.pow(2, s.transform.tileZoom) / m, E = x * (u.tileID.canonical.x + u.tileID.wrap * m), L = x * u.tileID.canonical.y;
        return { u_image: 0, u_texsize: u.imageAtlasTexture.size, u_scale: [p, b.fromScale, b.toScale], u_fade: b.t, u_pixel_coord_upper: [E >> 16, L >> 16], u_pixel_coord_lower: [65535 & E, 65535 & L] };
      }
      const Ke = (b, s, u, p) => {
        const m = b.style.light, x = m.properties.get("position"), E = [x.x, x.y, x.z], L = a.bJ();
        m.properties.get("anchor") === "viewport" && a.bK(L, b.transform.bearingInRadians), a.bL(E, E, L);
        const B = b.transform.transformLightDirection(E), N = m.properties.get("color");
        return { u_lightpos: E, u_lightpos_globe: B, u_lightintensity: m.properties.get("intensity"), u_lightcolor: [N.r, N.g, N.b], u_vertical_gradient: +s, u_opacity: u, u_fill_translate: p };
      }, yt = (b, s, u, p, m, x, E) => a.e(Ke(b, s, u, p), Fe(x, b, E), { u_height_factor: -Math.pow(2, m.overscaledZ) / E.tileSize / 8 }), kt = (b, s, u, p) => a.e(Fe(s, b, u), { u_fill_translate: p }), tn = (b, s) => ({ u_world: b, u_fill_translate: s }), Tn = (b, s, u, p, m) => a.e(kt(b, s, u, m), { u_world: p }), kn = (b, s, u, p, m) => {
        const x = b.transform;
        let E, L, B = 0;
        if (u.paint.get("circle-pitch-alignment") === "map") {
          const N = a.au(s, 1, x.zoom);
          E = !0, L = [N, N], B = N / (a.Y * Math.pow(2, s.tileID.overscaledZ)) * 2 * Math.PI * m;
        } else E = !1, L = x.pixelsToGLUnits;
        return { u_camera_to_center_distance: x.cameraToCenterDistance, u_scale_with_map: +(u.paint.get("circle-pitch-scale") === "map"), u_pitch_with_map: +E, u_device_pixel_ratio: b.pixelRatio, u_extrude_scale: L, u_globe_extrude_scale: B, u_translate: p };
      }, ii = (b) => ({ u_pixel_extrude_scale: [1 / b.width, 1 / b.height] }), ei = (b) => ({ u_viewport_size: [b.width, b.height] }), wi = function(b) {
        let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
        return { u_color: b, u_overlay: 0, u_overlay_scale: s };
      }, ir = (b, s, u, p) => {
        const m = a.au(b, 1, s) / (a.Y * Math.pow(2, b.tileID.overscaledZ)) * 2 * Math.PI * p;
        return { u_extrude_scale: a.au(b, 1, s), u_intensity: u, u_globe_extrude_scale: m };
      }, Wi = (b, s, u, p) => {
        const m = a.J();
        a.bM(m, 0, b.width, b.height, 0, 0, 1);
        const x = b.context.gl;
        return { u_matrix: m, u_world: [x.drawingBufferWidth, x.drawingBufferHeight], u_image: u, u_color_ramp: p, u_opacity: s.paint.get("heatmap-opacity") };
      }, Sr = (b, s, u) => {
        const p = u.paint.get("hillshade-shadow-color"), m = u.paint.get("hillshade-highlight-color"), x = u.paint.get("hillshade-accent-color");
        let E = u.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
        return u.paint.get("hillshade-illumination-anchor") === "viewport" && (E += b.transform.bearingInRadians), { u_image: 0, u_latrange: br(0, s.tileID), u_light: [u.paint.get("hillshade-exaggeration"), E], u_shadow: p, u_highlight: m, u_accent: x };
      }, hs = (b, s) => {
        const u = s.stride, p = a.J();
        return a.bM(p, 0, a.Y, -8192, 0, 0, 1), a.K(p, p, [0, -8192, 0]), { u_matrix: p, u_image: 1, u_dimension: [u, u], u_zoom: b.overscaledZ, u_unpack: s.getUnpackVector() };
      };
      function br(b, s) {
        const u = Math.pow(2, s.canonical.z), p = s.canonical.y;
        return [new a.Z(0, p / u).toLngLat().lat, new a.Z(0, (p + 1) / u).toLngLat().lat];
      }
      const po = (b, s, u, p) => {
        const m = b.transform;
        return { u_translation: jl(b, s, u), u_ratio: p / a.au(s, 1, m.zoom), u_device_pixel_ratio: b.pixelRatio, u_units_to_pixels: [1 / m.pixelsToGLUnits[0], 1 / m.pixelsToGLUnits[1]] };
      }, Bs = (b, s, u, p, m) => a.e(po(b, s, u, p), { u_image: 0, u_image_height: m }), pa = (b, s, u, p, m) => {
        const x = b.transform, E = Ul(s, x);
        return { u_translation: jl(b, s, u), u_texsize: s.imageAtlasTexture.size, u_ratio: p / a.au(s, 1, x.zoom), u_device_pixel_ratio: b.pixelRatio, u_image: 0, u_scale: [E, m.fromScale, m.toScale], u_fade: m.t, u_units_to_pixels: [1 / x.pixelsToGLUnits[0], 1 / x.pixelsToGLUnits[1]] };
      }, zu = (b, s, u, p, m, x) => {
        const E = b.lineAtlas, L = Ul(s, b.transform), B = u.layout.get("line-cap") === "round", N = E.getDash(m.from, B), G = E.getDash(m.to, B), Z = N.width * x.fromScale, $ = G.width * x.toScale;
        return a.e(po(b, s, u, p), { u_patternscale_a: [L / Z, -N.height / 2], u_patternscale_b: [L / $, -G.height / 2], u_sdfgamma: E.width / (256 * Math.min(Z, $) * b.pixelRatio) / 2, u_image: 0, u_tex_y_a: N.y, u_tex_y_b: G.y, u_mix: x.t });
      };
      function Ul(b, s) {
        return 1 / a.au(b, 1, s.tileZoom);
      }
      function jl(b, s, u) {
        return a.av(b.transform, s, u.paint.get("line-translate"), u.paint.get("line-translate-anchor"));
      }
      const Gl = (b, s, u, p, m) => {
        return { u_tl_parent: b, u_scale_parent: s, u_buffer_scale: 1, u_fade_t: u.mix, u_opacity: u.opacity * p.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: p.paint.get("raster-brightness-min"), u_brightness_high: p.paint.get("raster-brightness-max"), u_saturation_factor: (E = p.paint.get("raster-saturation"), E > 0 ? 1 - 1 / (1.001 - E) : -E), u_contrast_factor: (x = p.paint.get("raster-contrast"), x > 0 ? 1 / (1 - x) : 1 + x), u_spin_weights: Vl(p.paint.get("raster-hue-rotate")), u_coords_top: [m[0].x, m[0].y, m[1].x, m[1].y], u_coords_bottom: [m[3].x, m[3].y, m[2].x, m[2].y] };
        var x, E;
      };
      function Vl(b) {
        b *= Math.PI / 180;
        const s = Math.sin(b), u = Math.cos(b);
        return [(2 * u + 1) / 3, (-Math.sqrt(3) * s - u + 1) / 3, (Math.sqrt(3) * s - u + 1) / 3];
      }
      const ql = (b, s, u, p, m, x, E, L, B, N, G, Z, $) => {
        const re = E.transform;
        return { u_is_size_zoom_constant: +(b === "constant" || b === "source"), u_is_size_feature_constant: +(b === "constant" || b === "camera"), u_size_t: s ? s.uSizeT : 0, u_size: s ? s.uSize : 0, u_camera_to_center_distance: re.cameraToCenterDistance, u_pitch: re.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +u, u_aspect_ratio: re.width / re.height, u_fade_change: E.options.fadeDuration ? E.symbolFadeChange : 1, u_label_plane_matrix: L, u_coord_matrix: B, u_is_text: +G, u_pitch_with_map: +p, u_is_along_line: m, u_is_variable_anchor: x, u_texsize: Z, u_texture: 0, u_translation: N, u_pitched_scale: $ };
      }, ga = (b, s, u, p, m, x, E, L, B, N, G, Z, $, re) => {
        const ae = E.transform;
        return a.e(ql(b, s, u, p, m, x, E, L, B, N, G, Z, re), { u_gamma_scale: p ? Math.cos(ae.pitch * Math.PI / 180) * ae.cameraToCenterDistance : 1, u_device_pixel_ratio: E.pixelRatio, u_is_halo: 1 });
      }, rr = (b, s, u, p, m, x, E, L, B, N, G, Z, $) => a.e(ga(b, s, u, p, m, x, E, L, B, N, !0, G, 0, $), { u_texsize_icon: Z, u_texture_icon: 1 }), al = (b, s) => ({ u_opacity: b, u_color: s }), ll = (b, s, u, p, m) => a.e(function(x, E, L, B) {
        const N = L.imageManager.getPattern(x.from.toString()), G = L.imageManager.getPattern(x.to.toString()), { width: Z, height: $ } = L.imageManager.getPixelSize(), re = Math.pow(2, B.tileID.overscaledZ), ae = B.tileSize * Math.pow(2, L.transform.tileZoom) / re, Pe = ae * (B.tileID.canonical.x + B.tileID.wrap * re), Ce = ae * B.tileID.canonical.y;
        return { u_image: 0, u_pattern_tl_a: N.tl, u_pattern_br_a: N.br, u_pattern_tl_b: G.tl, u_pattern_br_b: G.br, u_texsize: [Z, $], u_mix: E.t, u_pattern_size_a: N.displaySize, u_pattern_size_b: G.displaySize, u_scale_a: E.fromScale, u_scale_b: E.toScale, u_tile_units_to_pixels: 1 / a.au(B, 1, L.transform.tileZoom), u_pixel_coord_upper: [Pe >> 16, Ce >> 16], u_pixel_coord_lower: [65535 & Pe, 65535 & Ce] };
      }(u, m, s, p), { u_opacity: b }), Oa = (b, s) => {
      }, Mc = { fillExtrusion: (b, s) => ({ u_lightpos: new a.bH(b, s.u_lightpos), u_lightpos_globe: new a.bH(b, s.u_lightpos_globe), u_lightintensity: new a.b6(b, s.u_lightintensity), u_lightcolor: new a.bH(b, s.u_lightcolor), u_vertical_gradient: new a.b6(b, s.u_vertical_gradient), u_opacity: new a.b6(b, s.u_opacity), u_fill_translate: new a.bI(b, s.u_fill_translate) }), fillExtrusionPattern: (b, s) => ({ u_lightpos: new a.bH(b, s.u_lightpos), u_lightpos_globe: new a.bH(b, s.u_lightpos_globe), u_lightintensity: new a.b6(b, s.u_lightintensity), u_lightcolor: new a.bH(b, s.u_lightcolor), u_vertical_gradient: new a.b6(b, s.u_vertical_gradient), u_height_factor: new a.b6(b, s.u_height_factor), u_opacity: new a.b6(b, s.u_opacity), u_fill_translate: new a.bI(b, s.u_fill_translate), u_image: new a.bD(b, s.u_image), u_texsize: new a.bI(b, s.u_texsize), u_pixel_coord_upper: new a.bI(b, s.u_pixel_coord_upper), u_pixel_coord_lower: new a.bI(b, s.u_pixel_coord_lower), u_scale: new a.bH(b, s.u_scale), u_fade: new a.b6(b, s.u_fade) }), fill: (b, s) => ({ u_fill_translate: new a.bI(b, s.u_fill_translate) }), fillPattern: (b, s) => ({ u_image: new a.bD(b, s.u_image), u_texsize: new a.bI(b, s.u_texsize), u_pixel_coord_upper: new a.bI(b, s.u_pixel_coord_upper), u_pixel_coord_lower: new a.bI(b, s.u_pixel_coord_lower), u_scale: new a.bH(b, s.u_scale), u_fade: new a.b6(b, s.u_fade), u_fill_translate: new a.bI(b, s.u_fill_translate) }), fillOutline: (b, s) => ({ u_world: new a.bI(b, s.u_world), u_fill_translate: new a.bI(b, s.u_fill_translate) }), fillOutlinePattern: (b, s) => ({ u_world: new a.bI(b, s.u_world), u_image: new a.bD(b, s.u_image), u_texsize: new a.bI(b, s.u_texsize), u_pixel_coord_upper: new a.bI(b, s.u_pixel_coord_upper), u_pixel_coord_lower: new a.bI(b, s.u_pixel_coord_lower), u_scale: new a.bH(b, s.u_scale), u_fade: new a.b6(b, s.u_fade), u_fill_translate: new a.bI(b, s.u_fill_translate) }), circle: (b, s) => ({ u_camera_to_center_distance: new a.b6(b, s.u_camera_to_center_distance), u_scale_with_map: new a.bD(b, s.u_scale_with_map), u_pitch_with_map: new a.bD(b, s.u_pitch_with_map), u_extrude_scale: new a.bI(b, s.u_extrude_scale), u_device_pixel_ratio: new a.b6(b, s.u_device_pixel_ratio), u_globe_extrude_scale: new a.b6(b, s.u_globe_extrude_scale), u_translate: new a.bI(b, s.u_translate) }), collisionBox: (b, s) => ({ u_pixel_extrude_scale: new a.bI(b, s.u_pixel_extrude_scale) }), collisionCircle: (b, s) => ({ u_viewport_size: new a.bI(b, s.u_viewport_size) }), debug: (b, s) => ({ u_color: new a.bE(b, s.u_color), u_overlay: new a.bD(b, s.u_overlay), u_overlay_scale: new a.b6(b, s.u_overlay_scale) }), depth: Oa, clippingMask: Oa, heatmap: (b, s) => ({ u_extrude_scale: new a.b6(b, s.u_extrude_scale), u_intensity: new a.b6(b, s.u_intensity), u_globe_extrude_scale: new a.b6(b, s.u_globe_extrude_scale) }), heatmapTexture: (b, s) => ({ u_matrix: new a.bF(b, s.u_matrix), u_world: new a.bI(b, s.u_world), u_image: new a.bD(b, s.u_image), u_color_ramp: new a.bD(b, s.u_color_ramp), u_opacity: new a.b6(b, s.u_opacity) }), hillshade: (b, s) => ({ u_image: new a.bD(b, s.u_image), u_latrange: new a.bI(b, s.u_latrange), u_light: new a.bI(b, s.u_light), u_shadow: new a.bE(b, s.u_shadow), u_highlight: new a.bE(b, s.u_highlight), u_accent: new a.bE(b, s.u_accent) }), hillshadePrepare: (b, s) => ({ u_matrix: new a.bF(b, s.u_matrix), u_image: new a.bD(b, s.u_image), u_dimension: new a.bI(b, s.u_dimension), u_zoom: new a.b6(b, s.u_zoom), u_unpack: new a.bG(b, s.u_unpack) }), line: (b, s) => ({ u_translation: new a.bI(b, s.u_translation), u_ratio: new a.b6(b, s.u_ratio), u_device_pixel_ratio: new a.b6(b, s.u_device_pixel_ratio), u_units_to_pixels: new a.bI(b, s.u_units_to_pixels) }), lineGradient: (b, s) => ({ u_translation: new a.bI(b, s.u_translation), u_ratio: new a.b6(b, s.u_ratio), u_device_pixel_ratio: new a.b6(b, s.u_device_pixel_ratio), u_units_to_pixels: new a.bI(b, s.u_units_to_pixels), u_image: new a.bD(b, s.u_image), u_image_height: new a.b6(b, s.u_image_height) }), linePattern: (b, s) => ({ u_translation: new a.bI(b, s.u_translation), u_texsize: new a.bI(b, s.u_texsize), u_ratio: new a.b6(b, s.u_ratio), u_device_pixel_ratio: new a.b6(b, s.u_device_pixel_ratio), u_image: new a.bD(b, s.u_image), u_units_to_pixels: new a.bI(b, s.u_units_to_pixels), u_scale: new a.bH(b, s.u_scale), u_fade: new a.b6(b, s.u_fade) }), lineSDF: (b, s) => ({ u_translation: new a.bI(b, s.u_translation), u_ratio: new a.b6(b, s.u_ratio), u_device_pixel_ratio: new a.b6(b, s.u_device_pixel_ratio), u_units_to_pixels: new a.bI(b, s.u_units_to_pixels), u_patternscale_a: new a.bI(b, s.u_patternscale_a), u_patternscale_b: new a.bI(b, s.u_patternscale_b), u_sdfgamma: new a.b6(b, s.u_sdfgamma), u_image: new a.bD(b, s.u_image), u_tex_y_a: new a.b6(b, s.u_tex_y_a), u_tex_y_b: new a.b6(b, s.u_tex_y_b), u_mix: new a.b6(b, s.u_mix) }), raster: (b, s) => ({ u_tl_parent: new a.bI(b, s.u_tl_parent), u_scale_parent: new a.b6(b, s.u_scale_parent), u_buffer_scale: new a.b6(b, s.u_buffer_scale), u_fade_t: new a.b6(b, s.u_fade_t), u_opacity: new a.b6(b, s.u_opacity), u_image0: new a.bD(b, s.u_image0), u_image1: new a.bD(b, s.u_image1), u_brightness_low: new a.b6(b, s.u_brightness_low), u_brightness_high: new a.b6(b, s.u_brightness_high), u_saturation_factor: new a.b6(b, s.u_saturation_factor), u_contrast_factor: new a.b6(b, s.u_contrast_factor), u_spin_weights: new a.bH(b, s.u_spin_weights), u_coords_top: new a.bG(b, s.u_coords_top), u_coords_bottom: new a.bG(b, s.u_coords_bottom) }), symbolIcon: (b, s) => ({ u_is_size_zoom_constant: new a.bD(b, s.u_is_size_zoom_constant), u_is_size_feature_constant: new a.bD(b, s.u_is_size_feature_constant), u_size_t: new a.b6(b, s.u_size_t), u_size: new a.b6(b, s.u_size), u_camera_to_center_distance: new a.b6(b, s.u_camera_to_center_distance), u_pitch: new a.b6(b, s.u_pitch), u_rotate_symbol: new a.bD(b, s.u_rotate_symbol), u_aspect_ratio: new a.b6(b, s.u_aspect_ratio), u_fade_change: new a.b6(b, s.u_fade_change), u_label_plane_matrix: new a.bF(b, s.u_label_plane_matrix), u_coord_matrix: new a.bF(b, s.u_coord_matrix), u_is_text: new a.bD(b, s.u_is_text), u_pitch_with_map: new a.bD(b, s.u_pitch_with_map), u_is_along_line: new a.bD(b, s.u_is_along_line), u_is_variable_anchor: new a.bD(b, s.u_is_variable_anchor), u_texsize: new a.bI(b, s.u_texsize), u_texture: new a.bD(b, s.u_texture), u_translation: new a.bI(b, s.u_translation), u_pitched_scale: new a.b6(b, s.u_pitched_scale) }), symbolSDF: (b, s) => ({ u_is_size_zoom_constant: new a.bD(b, s.u_is_size_zoom_constant), u_is_size_feature_constant: new a.bD(b, s.u_is_size_feature_constant), u_size_t: new a.b6(b, s.u_size_t), u_size: new a.b6(b, s.u_size), u_camera_to_center_distance: new a.b6(b, s.u_camera_to_center_distance), u_pitch: new a.b6(b, s.u_pitch), u_rotate_symbol: new a.bD(b, s.u_rotate_symbol), u_aspect_ratio: new a.b6(b, s.u_aspect_ratio), u_fade_change: new a.b6(b, s.u_fade_change), u_label_plane_matrix: new a.bF(b, s.u_label_plane_matrix), u_coord_matrix: new a.bF(b, s.u_coord_matrix), u_is_text: new a.bD(b, s.u_is_text), u_pitch_with_map: new a.bD(b, s.u_pitch_with_map), u_is_along_line: new a.bD(b, s.u_is_along_line), u_is_variable_anchor: new a.bD(b, s.u_is_variable_anchor), u_texsize: new a.bI(b, s.u_texsize), u_texture: new a.bD(b, s.u_texture), u_gamma_scale: new a.b6(b, s.u_gamma_scale), u_device_pixel_ratio: new a.b6(b, s.u_device_pixel_ratio), u_is_halo: new a.bD(b, s.u_is_halo), u_translation: new a.bI(b, s.u_translation), u_pitched_scale: new a.b6(b, s.u_pitched_scale) }), symbolTextAndIcon: (b, s) => ({ u_is_size_zoom_constant: new a.bD(b, s.u_is_size_zoom_constant), u_is_size_feature_constant: new a.bD(b, s.u_is_size_feature_constant), u_size_t: new a.b6(b, s.u_size_t), u_size: new a.b6(b, s.u_size), u_camera_to_center_distance: new a.b6(b, s.u_camera_to_center_distance), u_pitch: new a.b6(b, s.u_pitch), u_rotate_symbol: new a.bD(b, s.u_rotate_symbol), u_aspect_ratio: new a.b6(b, s.u_aspect_ratio), u_fade_change: new a.b6(b, s.u_fade_change), u_label_plane_matrix: new a.bF(b, s.u_label_plane_matrix), u_coord_matrix: new a.bF(b, s.u_coord_matrix), u_is_text: new a.bD(b, s.u_is_text), u_pitch_with_map: new a.bD(b, s.u_pitch_with_map), u_is_along_line: new a.bD(b, s.u_is_along_line), u_is_variable_anchor: new a.bD(b, s.u_is_variable_anchor), u_texsize: new a.bI(b, s.u_texsize), u_texsize_icon: new a.bI(b, s.u_texsize_icon), u_texture: new a.bD(b, s.u_texture), u_texture_icon: new a.bD(b, s.u_texture_icon), u_gamma_scale: new a.b6(b, s.u_gamma_scale), u_device_pixel_ratio: new a.b6(b, s.u_device_pixel_ratio), u_is_halo: new a.bD(b, s.u_is_halo), u_translation: new a.bI(b, s.u_translation), u_pitched_scale: new a.b6(b, s.u_pitched_scale) }), background: (b, s) => ({ u_opacity: new a.b6(b, s.u_opacity), u_color: new a.bE(b, s.u_color) }), backgroundPattern: (b, s) => ({ u_opacity: new a.b6(b, s.u_opacity), u_image: new a.bD(b, s.u_image), u_pattern_tl_a: new a.bI(b, s.u_pattern_tl_a), u_pattern_br_a: new a.bI(b, s.u_pattern_br_a), u_pattern_tl_b: new a.bI(b, s.u_pattern_tl_b), u_pattern_br_b: new a.bI(b, s.u_pattern_br_b), u_texsize: new a.bI(b, s.u_texsize), u_mix: new a.b6(b, s.u_mix), u_pattern_size_a: new a.bI(b, s.u_pattern_size_a), u_pattern_size_b: new a.bI(b, s.u_pattern_size_b), u_scale_a: new a.b6(b, s.u_scale_a), u_scale_b: new a.b6(b, s.u_scale_b), u_pixel_coord_upper: new a.bI(b, s.u_pixel_coord_upper), u_pixel_coord_lower: new a.bI(b, s.u_pixel_coord_lower), u_tile_units_to_pixels: new a.b6(b, s.u_tile_units_to_pixels) }), terrain: (b, s) => ({ u_texture: new a.bD(b, s.u_texture), u_ele_delta: new a.b6(b, s.u_ele_delta), u_fog_matrix: new a.bF(b, s.u_fog_matrix), u_fog_color: new a.bE(b, s.u_fog_color), u_fog_ground_blend: new a.b6(b, s.u_fog_ground_blend), u_fog_ground_blend_opacity: new a.b6(b, s.u_fog_ground_blend_opacity), u_horizon_color: new a.bE(b, s.u_horizon_color), u_horizon_fog_blend: new a.b6(b, s.u_horizon_fog_blend), u_is_globe_mode: new a.b6(b, s.u_is_globe_mode) }), terrainDepth: (b, s) => ({ u_ele_delta: new a.b6(b, s.u_ele_delta) }), terrainCoords: (b, s) => ({ u_texture: new a.bD(b, s.u_texture), u_terrain_coords_id: new a.b6(b, s.u_terrain_coords_id), u_ele_delta: new a.b6(b, s.u_ele_delta) }), projectionErrorMeasurement: (b, s) => ({ u_input: new a.b6(b, s.u_input), u_output_expected: new a.b6(b, s.u_output_expected) }), atmosphere: (b, s) => ({ u_sun_pos: new a.bH(b, s.u_sun_pos), u_atmosphere_blend: new a.b6(b, s.u_atmosphere_blend), u_globe_position: new a.bH(b, s.u_globe_position), u_globe_radius: new a.b6(b, s.u_globe_radius), u_inv_proj_matrix: new a.bF(b, s.u_inv_proj_matrix) }), sky: (b, s) => ({ u_sky_color: new a.bE(b, s.u_sky_color), u_horizon_color: new a.bE(b, s.u_horizon_color), u_horizon: new a.bI(b, s.u_horizon), u_horizon_normal: new a.bI(b, s.u_horizon_normal), u_sky_horizon_blend: new a.b6(b, s.u_sky_horizon_blend), u_sky_blend: new a.b6(b, s.u_sky_blend) }) };
      class As {
        constructor(s, u, p) {
          this.context = s;
          const m = s.gl;
          this.buffer = m.createBuffer(), this.dynamicDraw = !!p, this.context.unbindVAO(), s.bindElementBuffer.set(this.buffer), m.bufferData(m.ELEMENT_ARRAY_BUFFER, u.arrayBuffer, this.dynamicDraw ? m.DYNAMIC_DRAW : m.STATIC_DRAW), this.dynamicDraw || delete u.arrayBuffer;
        }
        bind() {
          this.context.bindElementBuffer.set(this.buffer);
        }
        updateData(s) {
          const u = this.context.gl;
          if (!this.dynamicDraw) throw new Error("Attempted to update data while not in dynamic mode.");
          this.context.unbindVAO(), this.bind(), u.bufferSubData(u.ELEMENT_ARRAY_BUFFER, 0, s.arrayBuffer);
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      const Da = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
      class Hl {
        constructor(s, u, p, m) {
          this.length = u.length, this.attributes = p, this.itemSize = u.bytesPerElement, this.dynamicDraw = m, this.context = s;
          const x = s.gl;
          this.buffer = x.createBuffer(), s.bindVertexBuffer.set(this.buffer), x.bufferData(x.ARRAY_BUFFER, u.arrayBuffer, this.dynamicDraw ? x.DYNAMIC_DRAW : x.STATIC_DRAW), this.dynamicDraw || delete u.arrayBuffer;
        }
        bind() {
          this.context.bindVertexBuffer.set(this.buffer);
        }
        updateData(s) {
          if (s.length !== this.length) throw new Error(`Length of new data is ${s.length}, which doesn't match current length of ${this.length}`);
          const u = this.context.gl;
          this.bind(), u.bufferSubData(u.ARRAY_BUFFER, 0, s.arrayBuffer);
        }
        enableAttributes(s, u) {
          for (let p = 0; p < this.attributes.length; p++) {
            const m = u.attributes[this.attributes[p].name];
            m !== void 0 && s.enableVertexAttribArray(m);
          }
        }
        setVertexAttribPointers(s, u, p) {
          for (let m = 0; m < this.attributes.length; m++) {
            const x = this.attributes[m], E = u.attributes[x.name];
            E !== void 0 && s.vertexAttribPointer(E, x.components, s[Da[x.type]], !1, this.itemSize, x.offset + this.itemSize * (p || 0));
          }
        }
        destroy() {
          this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
        }
      }
      class Ei {
        constructor(s) {
          this.gl = s.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = !1;
        }
        get() {
          return this.current;
        }
        set(s) {
        }
        getDefault() {
          return this.default;
        }
        setDefault() {
          this.set(this.default);
        }
      }
      class Io extends Ei {
        getDefault() {
          return a.b5.transparent;
        }
        set(s) {
          const u = this.current;
          (s.r !== u.r || s.g !== u.g || s.b !== u.b || s.a !== u.a || this.dirty) && (this.gl.clearColor(s.r, s.g, s.b, s.a), this.current = s, this.dirty = !1);
        }
      }
      class Lc extends Ei {
        getDefault() {
          return 1;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.clearDepth(s), this.current = s, this.dirty = !1);
        }
      }
      class Uu extends Ei {
        getDefault() {
          return 0;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.clearStencil(s), this.current = s, this.dirty = !1);
        }
      }
      class lu extends Ei {
        getDefault() {
          return [!0, !0, !0, !0];
        }
        set(s) {
          const u = this.current;
          (s[0] !== u[0] || s[1] !== u[1] || s[2] !== u[2] || s[3] !== u[3] || this.dirty) && (this.gl.colorMask(s[0], s[1], s[2], s[3]), this.current = s, this.dirty = !1);
        }
      }
      class cl extends Ei {
        getDefault() {
          return !0;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.depthMask(s), this.current = s, this.dirty = !1);
        }
      }
      class ul extends Ei {
        getDefault() {
          return 255;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.stencilMask(s), this.current = s, this.dirty = !1);
        }
      }
      class ds extends Ei {
        getDefault() {
          return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
        }
        set(s) {
          const u = this.current;
          (s.func !== u.func || s.ref !== u.ref || s.mask !== u.mask || this.dirty) && (this.gl.stencilFunc(s.func, s.ref, s.mask), this.current = s, this.dirty = !1);
        }
      }
      class $r extends Ei {
        getDefault() {
          const s = this.gl;
          return [s.KEEP, s.KEEP, s.KEEP];
        }
        set(s) {
          const u = this.current;
          (s[0] !== u[0] || s[1] !== u[1] || s[2] !== u[2] || this.dirty) && (this.gl.stencilOp(s[0], s[1], s[2]), this.current = s, this.dirty = !1);
        }
      }
      class Qo extends Ei {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const u = this.gl;
          s ? u.enable(u.STENCIL_TEST) : u.disable(u.STENCIL_TEST), this.current = s, this.dirty = !1;
        }
      }
      class ea extends Ei {
        getDefault() {
          return [0, 1];
        }
        set(s) {
          const u = this.current;
          (s[0] !== u[0] || s[1] !== u[1] || this.dirty) && (this.gl.depthRange(s[0], s[1]), this.current = s, this.dirty = !1);
        }
      }
      class Os extends Ei {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const u = this.gl;
          s ? u.enable(u.DEPTH_TEST) : u.disable(u.DEPTH_TEST), this.current = s, this.dirty = !1;
        }
      }
      class ta extends Ei {
        getDefault() {
          return this.gl.LESS;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.depthFunc(s), this.current = s, this.dirty = !1);
        }
      }
      class Fr extends Ei {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const u = this.gl;
          s ? u.enable(u.BLEND) : u.disable(u.BLEND), this.current = s, this.dirty = !1;
        }
      }
      class vr extends Ei {
        getDefault() {
          const s = this.gl;
          return [s.ONE, s.ZERO];
        }
        set(s) {
          const u = this.current;
          (s[0] !== u[0] || s[1] !== u[1] || this.dirty) && (this.gl.blendFunc(s[0], s[1]), this.current = s, this.dirty = !1);
        }
      }
      class Rc extends Ei {
        getDefault() {
          return a.b5.transparent;
        }
        set(s) {
          const u = this.current;
          (s.r !== u.r || s.g !== u.g || s.b !== u.b || s.a !== u.a || this.dirty) && (this.gl.blendColor(s.r, s.g, s.b, s.a), this.current = s, this.dirty = !1);
        }
      }
      class fs extends Ei {
        getDefault() {
          return this.gl.FUNC_ADD;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.blendEquation(s), this.current = s, this.dirty = !1);
        }
      }
      class Xr extends Ei {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const u = this.gl;
          s ? u.enable(u.CULL_FACE) : u.disable(u.CULL_FACE), this.current = s, this.dirty = !1;
        }
      }
      class Fa extends Ei {
        getDefault() {
          return this.gl.BACK;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.cullFace(s), this.current = s, this.dirty = !1);
        }
      }
      class Wl extends Ei {
        getDefault() {
          return this.gl.CCW;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.frontFace(s), this.current = s, this.dirty = !1);
        }
      }
      class Na extends Ei {
        getDefault() {
          return null;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.useProgram(s), this.current = s, this.dirty = !1);
        }
      }
      class ma extends Ei {
        getDefault() {
          return this.gl.TEXTURE0;
        }
        set(s) {
          (s !== this.current || this.dirty) && (this.gl.activeTexture(s), this.current = s, this.dirty = !1);
        }
      }
      class hl extends Ei {
        getDefault() {
          const s = this.gl;
          return [0, 0, s.drawingBufferWidth, s.drawingBufferHeight];
        }
        set(s) {
          const u = this.current;
          (s[0] !== u[0] || s[1] !== u[1] || s[2] !== u[2] || s[3] !== u[3] || this.dirty) && (this.gl.viewport(s[0], s[1], s[2], s[3]), this.current = s, this.dirty = !1);
        }
      }
      class go extends Ei {
        getDefault() {
          return null;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const u = this.gl;
          u.bindFramebuffer(u.FRAMEBUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      class Mo extends Ei {
        getDefault() {
          return null;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const u = this.gl;
          u.bindRenderbuffer(u.RENDERBUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      class Zl extends Ei {
        getDefault() {
          return null;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const u = this.gl;
          u.bindTexture(u.TEXTURE_2D, s), this.current = s, this.dirty = !1;
        }
      }
      class ka extends Ei {
        getDefault() {
          return null;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const u = this.gl;
          u.bindBuffer(u.ARRAY_BUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      class oi extends Ei {
        getDefault() {
          return null;
        }
        set(s) {
          const u = this.gl;
          u.bindBuffer(u.ELEMENT_ARRAY_BUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      class dl extends Ei {
        getDefault() {
          return null;
        }
        set(s) {
          var u;
          if (s === this.current && !this.dirty) return;
          const p = this.gl;
          ls(p) ? p.bindVertexArray(s) : (u = p.getExtension("OES_vertex_array_object")) === null || u === void 0 || u.bindVertexArrayOES(s), this.current = s, this.dirty = !1;
        }
      }
      class Lo extends Ei {
        getDefault() {
          return 4;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const u = this.gl;
          u.pixelStorei(u.UNPACK_ALIGNMENT, s), this.current = s, this.dirty = !1;
        }
      }
      class mo extends Ei {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const u = this.gl;
          u.pixelStorei(u.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s), this.current = s, this.dirty = !1;
        }
      }
      class Di extends Ei {
        getDefault() {
          return !1;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          const u = this.gl;
          u.pixelStorei(u.UNPACK_FLIP_Y_WEBGL, s), this.current = s, this.dirty = !1;
        }
      }
      class Zi extends Ei {
        constructor(s, u) {
          super(s), this.context = s, this.parent = u;
        }
        getDefault() {
          return null;
        }
      }
      class Cr extends Zi {
        setDirty() {
          this.dirty = !0;
        }
        set(s) {
          if (s === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const u = this.gl;
          u.framebufferTexture2D(u.FRAMEBUFFER, u.COLOR_ATTACHMENT0, u.TEXTURE_2D, s, 0), this.current = s, this.dirty = !1;
        }
      }
      class Nr extends Zi {
        set(s) {
          if (s === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const u = this.gl;
          u.framebufferRenderbuffer(u.FRAMEBUFFER, u.DEPTH_ATTACHMENT, u.RENDERBUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      class za extends Zi {
        set(s) {
          if (s === this.current && !this.dirty) return;
          this.context.bindFramebuffer.set(this.parent);
          const u = this.gl;
          u.framebufferRenderbuffer(u.FRAMEBUFFER, u.DEPTH_STENCIL_ATTACHMENT, u.RENDERBUFFER, s), this.current = s, this.dirty = !1;
        }
      }
      const fl = "Framebuffer is not complete";
      class Ua {
        constructor(s, u, p, m, x) {
          this.context = s, this.width = u, this.height = p;
          const E = s.gl, L = this.framebuffer = E.createFramebuffer();
          if (this.colorAttachment = new Cr(s, L), m) this.depthAttachment = x ? new za(s, L) : new Nr(s, L);
          else if (x) throw new Error("Stencil cannot be set without depth");
          if (E.checkFramebufferStatus(E.FRAMEBUFFER) !== E.FRAMEBUFFER_COMPLETE) throw new Error(fl);
        }
        destroy() {
          const s = this.context.gl, u = this.colorAttachment.get();
          if (u && s.deleteTexture(u), this.depthAttachment) {
            const p = this.depthAttachment.get();
            p && s.deleteRenderbuffer(p);
          }
          s.deleteFramebuffer(this.framebuffer);
        }
      }
      class $l {
        constructor(s) {
          var u, p;
          if (this.gl = s, this.clearColor = new Io(this), this.clearDepth = new Lc(this), this.clearStencil = new Uu(this), this.colorMask = new lu(this), this.depthMask = new cl(this), this.stencilMask = new ul(this), this.stencilFunc = new ds(this), this.stencilOp = new $r(this), this.stencilTest = new Qo(this), this.depthRange = new ea(this), this.depthTest = new Os(this), this.depthFunc = new ta(this), this.blend = new Fr(this), this.blendFunc = new vr(this), this.blendColor = new Rc(this), this.blendEquation = new fs(this), this.cullFace = new Xr(this), this.cullFaceSide = new Fa(this), this.frontFace = new Wl(this), this.program = new Na(this), this.activeTexture = new ma(this), this.viewport = new hl(this), this.bindFramebuffer = new go(this), this.bindRenderbuffer = new Mo(this), this.bindTexture = new Zl(this), this.bindVertexBuffer = new ka(this), this.bindElementBuffer = new oi(this), this.bindVertexArray = new dl(this), this.pixelStoreUnpack = new Lo(this), this.pixelStoreUnpackPremultiplyAlpha = new mo(this), this.pixelStoreUnpackFlipY = new Di(this), this.extTextureFilterAnisotropic = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = s.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = s.getParameter(s.MAX_TEXTURE_SIZE), ls(s)) {
            this.HALF_FLOAT = s.HALF_FLOAT;
            const m = s.getExtension("EXT_color_buffer_half_float");
            this.RGBA16F = (u = s.RGBA16F) !== null && u !== void 0 ? u : m == null ? void 0 : m.RGBA16F_EXT, this.RGB16F = (p = s.RGB16F) !== null && p !== void 0 ? p : m == null ? void 0 : m.RGB16F_EXT, s.getExtension("EXT_color_buffer_float");
          } else {
            s.getExtension("EXT_color_buffer_half_float"), s.getExtension("OES_texture_half_float_linear");
            const m = s.getExtension("OES_texture_half_float");
            this.HALF_FLOAT = m == null ? void 0 : m.HALF_FLOAT_OES;
          }
        }
        setDefault() {
          this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
        }
        setDirty() {
          this.clearColor.dirty = !0, this.clearDepth.dirty = !0, this.clearStencil.dirty = !0, this.colorMask.dirty = !0, this.depthMask.dirty = !0, this.stencilMask.dirty = !0, this.stencilFunc.dirty = !0, this.stencilOp.dirty = !0, this.stencilTest.dirty = !0, this.depthRange.dirty = !0, this.depthTest.dirty = !0, this.depthFunc.dirty = !0, this.blend.dirty = !0, this.blendFunc.dirty = !0, this.blendColor.dirty = !0, this.blendEquation.dirty = !0, this.cullFace.dirty = !0, this.cullFaceSide.dirty = !0, this.frontFace.dirty = !0, this.program.dirty = !0, this.activeTexture.dirty = !0, this.viewport.dirty = !0, this.bindFramebuffer.dirty = !0, this.bindRenderbuffer.dirty = !0, this.bindTexture.dirty = !0, this.bindVertexBuffer.dirty = !0, this.bindElementBuffer.dirty = !0, this.bindVertexArray.dirty = !0, this.pixelStoreUnpack.dirty = !0, this.pixelStoreUnpackPremultiplyAlpha.dirty = !0, this.pixelStoreUnpackFlipY.dirty = !0;
        }
        createIndexBuffer(s, u) {
          return new As(this, s, u);
        }
        createVertexBuffer(s, u, p) {
          return new Hl(this, s, u, p);
        }
        createRenderbuffer(s, u, p) {
          const m = this.gl, x = m.createRenderbuffer();
          return this.bindRenderbuffer.set(x), m.renderbufferStorage(m.RENDERBUFFER, s, u, p), this.bindRenderbuffer.set(null), x;
        }
        createFramebuffer(s, u, p, m) {
          return new Ua(this, s, u, p, m);
        }
        clear(s) {
          let { color: u, depth: p, stencil: m } = s;
          const x = this.gl;
          let E = 0;
          u && (E |= x.COLOR_BUFFER_BIT, this.clearColor.set(u), this.colorMask.set([!0, !0, !0, !0])), p !== void 0 && (E |= x.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(p), this.depthMask.set(!0)), m !== void 0 && (E |= x.STENCIL_BUFFER_BIT, this.clearStencil.set(m), this.stencilMask.set(255)), x.clear(E);
        }
        setCullFace(s) {
          s.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0), this.cullFaceSide.set(s.mode), this.frontFace.set(s.frontFace));
        }
        setDepthMode(s) {
          s.func !== this.gl.ALWAYS || s.mask ? (this.depthTest.set(!0), this.depthFunc.set(s.func), this.depthMask.set(s.mask), this.depthRange.set(s.range)) : this.depthTest.set(!1);
        }
        setStencilMode(s) {
          s.test.func !== this.gl.ALWAYS || s.mask ? (this.stencilTest.set(!0), this.stencilMask.set(s.mask), this.stencilOp.set([s.fail, s.depthFail, s.pass]), this.stencilFunc.set({ func: s.test.func, ref: s.ref, mask: s.test.mask })) : this.stencilTest.set(!1);
        }
        setColorMode(s) {
          a.bA(s.blendFunction, Ui.Replace) ? this.blend.set(!1) : (this.blend.set(!0), this.blendFunc.set(s.blendFunction), this.blendColor.set(s.blendColor)), this.colorMask.set(s.mask);
        }
        createVertexArray() {
          var s;
          return ls(this.gl) ? this.gl.createVertexArray() : (s = this.gl.getExtension("OES_vertex_array_object")) === null || s === void 0 ? void 0 : s.createVertexArrayOES();
        }
        deleteVertexArray(s) {
          var u;
          return ls(this.gl) ? this.gl.deleteVertexArray(s) : (u = this.gl.getExtension("OES_vertex_array_object")) === null || u === void 0 ? void 0 : u.deleteVertexArrayOES(s);
        }
        unbindVAO() {
          this.bindVertexArray.set(null);
        }
      }
      let pl;
      function Xl(b, s, u, p, m) {
        const x = b.context, E = b.transform, L = x.gl, B = b.useProgram("collisionBox"), N = [];
        let G = 0, Z = 0;
        for (let Ie = 0; Ie < p.length; Ie++) {
          const Be = p[Ie], He = s.getTile(Be).getBucket(u);
          if (!He) continue;
          const We = m ? He.textCollisionBox : He.iconCollisionBox, $e = He.collisionCircleArray;
          $e.length > 0 && (N.push({ circleArray: $e, circleOffset: Z, coord: Be }), G += $e.length / 4, Z = G), We && B.draw(x, L.LINES, Kn.disabled, gi.disabled, b.colorModeForRenderPass(), li.disabled, ii(b.transform), b.style.map.terrain && b.style.map.terrain.getTerrainData(Be), E.getProjectionData({ overscaledTileID: Be, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), u.id, We.layoutVertexBuffer, We.indexBuffer, We.segments, null, b.transform.zoom, null, null, We.collisionVertexBuffer);
        }
        if (!m || !N.length) return;
        const $ = b.useProgram("collisionCircle"), re = new a.bN();
        re.resize(4 * G), re._trim();
        let ae = 0;
        for (const Ie of N) for (let Be = 0; Be < Ie.circleArray.length / 4; Be++) {
          const He = 4 * Be, We = Ie.circleArray[He + 0], $e = Ie.circleArray[He + 1], Je = Ie.circleArray[He + 2], Qe = Ie.circleArray[He + 3];
          re.emplace(ae++, We, $e, Je, Qe, 0), re.emplace(ae++, We, $e, Je, Qe, 1), re.emplace(ae++, We, $e, Je, Qe, 2), re.emplace(ae++, We, $e, Je, Qe, 3);
        }
        (!pl || pl.length < 2 * G) && (pl = function(Ie) {
          const Be = 2 * Ie, He = new a.bP();
          He.resize(Be), He._trim();
          for (let We = 0; We < Be; We++) {
            const $e = 6 * We;
            He.uint16[$e + 0] = 4 * We + 0, He.uint16[$e + 1] = 4 * We + 1, He.uint16[$e + 2] = 4 * We + 2, He.uint16[$e + 3] = 4 * We + 2, He.uint16[$e + 4] = 4 * We + 3, He.uint16[$e + 5] = 4 * We + 0;
          }
          return He;
        }(G));
        const Pe = x.createIndexBuffer(pl, !0), Ce = x.createVertexBuffer(re, a.bO.members, !0);
        for (const Ie of N) {
          const Be = ei(b.transform);
          $.draw(x, L.TRIANGLES, Kn.disabled, gi.disabled, b.colorModeForRenderPass(), li.disabled, Be, b.style.map.terrain && b.style.map.terrain.getTerrainData(Ie.coord), null, u.id, Ce, Pe, a.aE.simpleSegment(0, 2 * Ie.circleOffset, Ie.circleArray.length, Ie.circleArray.length / 2), null, b.transform.zoom, null, null, null);
        }
        Ce.destroy(), Pe.destroy();
      }
      const to = a.ar(new Float32Array(16));
      function Ds(b, s, u, p, m, x) {
        const { horizontalAlign: E, verticalAlign: L } = a.az(b);
        return new a.P((-(E - 0.5) * s / m + p[0]) * x, (-(L - 0.5) * u / m + p[1]) * x);
      }
      function Yl(b, s, u, p, m, x) {
        const E = s.tileAnchorPoint.add(new a.P(s.translation[0], s.translation[1]));
        if (s.pitchWithMap) {
          let L = p.mult(x);
          u || (L = L.rotate(-m));
          const B = E.add(L);
          return pt(B.x, B.y, s.pitchedLabelPlaneMatrix, s.getElevation).point;
        }
        if (u) {
          const L = cn(s.tileAnchorPoint.x + 1, s.tileAnchorPoint.y, s).point.sub(b), B = Math.atan(L.y / L.x) + (L.x < 0 ? Math.PI : 0);
          return b.add(p.rotate(B));
        }
        return b.add(p);
      }
      function Bc(b, s, u, p, m, x, E, L, B, N, G, Z) {
        const $ = b.text.placedSymbolArray, re = b.text.dynamicLayoutVertexArray, ae = b.icon.dynamicLayoutVertexArray, Pe = {};
        re.clear();
        for (let Ce = 0; Ce < $.length; Ce++) {
          const Ie = $.get(Ce), Be = Ie.hidden || !Ie.crossTileID || b.allowVerticalPlacement && !Ie.placedOrientation ? null : p[Ie.crossTileID];
          if (Be) {
            const He = new a.P(Ie.anchorX, Ie.anchorY), We = { getElevation: Z, width: m.width, height: m.height, pitchedLabelPlaneMatrix: x, pitchWithMap: u, transform: m, tileAnchorPoint: He, translation: N, unwrappedTileID: G }, $e = u ? Zn(He.x, He.y, We) : cn(He.x, He.y, We), Je = lt(m.cameraToCenterDistance, $e.signedDistanceFromCamera);
            let Qe = a.ag(b.textSizeData, L, Ie) * Je / a.at;
            u && (Qe *= b.tilePixelRatio / E);
            const { width: wt, height: bt, anchor: Mt, textOffset: Nt, textBoxScale: Ct } = Be, sn = Ds(Mt, wt, bt, Nt, Ct, Qe), nn = m.getPitchedTextCorrection(He.x + N[0], He.y + N[1], G), Gt = Yl($e.point, We, s, sn, -m.bearingInRadians, nn), dn = b.allowVerticalPlacement && Ie.placedOrientation === a.af.vertical ? Math.PI / 2 : 0;
            for (let Hn = 0; Hn < Ie.numGlyphs; Hn++) a.am(re, Gt, dn);
            B && Ie.associatedIconIndex >= 0 && (Pe[Ie.associatedIconIndex] = { shiftedAnchor: Gt, angle: dn });
          } else Pi(Ie.numGlyphs, re);
        }
        if (B) {
          ae.clear();
          const Ce = b.icon.placedSymbolArray;
          for (let Ie = 0; Ie < Ce.length; Ie++) {
            const Be = Ce.get(Ie);
            if (Be.hidden) Pi(Be.numGlyphs, ae);
            else {
              const He = Pe[Ie];
              if (He) for (let We = 0; We < Be.numGlyphs; We++) a.am(ae, He.shiftedAnchor, He.angle);
              else Pi(Be.numGlyphs, ae);
            }
          }
          b.icon.dynamicLayoutVertexBuffer.updateData(ae);
        }
        b.text.dynamicLayoutVertexBuffer.updateData(re);
      }
      function ad(b, s, u) {
        return u.iconsInText && s ? "symbolTextAndIcon" : b ? "symbolSDF" : "symbolIcon";
      }
      function Jl(b, s, u, p, m, x, E, L, B, N, G, Z, $) {
        const re = b.context, ae = re.gl, Pe = b.transform, Ce = L === "map", Ie = B === "map", Be = L !== "viewport" && u.layout.get("symbol-placement") !== "point", He = Ce && !Ie && !Be, We = !u.layout.get("symbol-sort-key").isConstant();
        let $e = !1;
        const Je = b.getDepthModeForSublayer(0, Kn.ReadOnly), Qe = u._unevaluatedLayout.hasValue("text-variable-anchor") || u._unevaluatedLayout.hasValue("text-variable-anchor-offset"), wt = [], bt = Pe.getCircleRadiusCorrection();
        for (const Mt of p) {
          const Nt = s.getTile(Mt), Ct = Nt.getBucket(u);
          if (!Ct) continue;
          const sn = m ? Ct.text : Ct.icon;
          if (!sn || !sn.segments.get().length || !sn.hasVisibleVertices) continue;
          const nn = sn.programConfigurations.get(u.id), Gt = m || Ct.sdfIcons, dn = m ? Ct.textSizeData : Ct.iconSizeData, Hn = Ie || Pe.pitch !== 0, bi = b.useProgram(ad(Gt, m, Ct), nn), Qi = a.ae(dn, Pe.zoom), Gi = b.style.map.terrain && b.style.map.terrain.getTerrainData(Mt);
          let er, Ci, Ni, ki, ps = [0, 0], Mr = null;
          if (m) Ci = Nt.glyphAtlasTexture, Ni = ae.LINEAR, er = Nt.glyphAtlasTexture.size, Ct.iconsInText && (ps = Nt.imageAtlasTexture.size, Mr = Nt.imageAtlasTexture, ki = Hn || b.options.rotating || b.options.zooming || dn.kind === "composite" || dn.kind === "camera" ? ae.LINEAR : ae.NEAREST);
          else {
            const Xi = u.layout.get("icon-size").constantOr(0) !== 1 || Ct.iconsNeedLinear;
            Ci = Nt.imageAtlasTexture, Ni = Gt || b.options.rotating || b.options.zooming || Xi || Hn ? ae.LINEAR : ae.NEAREST, er = Nt.imageAtlasTexture.size;
          }
          const zr = a.au(Nt, 1, b.transform.zoom), Gr = mt(Ce, b.transform, zr), ia = a.J();
          a.ah(ia, Gr);
          const bo = Ye(Ie, Ce, b.transform, zr), Lr = a.av(Pe, Nt, x, E), Cs = Pe.getProjectionData({ overscaledTileID: Mt, applyGlobeMatrix: !$, applyTerrainMatrix: !0 }), Oo = Qe && Ct.hasTextData(), bl = u.layout.get("icon-text-fit") !== "none" && Oo && Ct.hasIconData();
          if (Be) {
            const Xi = b.style.map.terrain ? (ra, wr) => b.style.map.terrain.getElevation(Mt, ra, wr) : null, gr = u.layout.get("text-rotation-alignment") === "map";
            an(Ct, b, m, Gr, ia, Ie, N, gr, Mt.toUnwrapped(), Pe.width, Pe.height, Lr, Xi);
          }
          const vl = m && Qe || bl, Ns = Be || vl ? to : Ie ? Gr : b.transform.clipSpaceToPixelsMatrix, Do = Gt && u.paint.get(m ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
          let io;
          io = Gt ? Ct.iconsInText ? rr(dn.kind, Qi, He, Ie, Be, vl, b, Ns, bo, Lr, er, ps, bt) : ga(dn.kind, Qi, He, Ie, Be, vl, b, Ns, bo, Lr, m, er, 0, bt) : ql(dn.kind, Qi, He, Ie, Be, vl, b, Ns, bo, Lr, m, er, bt);
          const ks = { program: bi, buffers: sn, uniformValues: io, projectionData: Cs, atlasTexture: Ci, atlasTextureIcon: Mr, atlasInterpolation: Ni, atlasInterpolationIcon: ki, isSDF: Gt, hasHalo: Do };
          if (We && Ct.canOverlap) {
            $e = !0;
            const Xi = sn.segments.get();
            for (const gr of Xi) wt.push({ segments: new a.aE([gr]), sortKey: gr.sortKey, state: ks, terrainData: Gi });
          } else wt.push({ segments: sn.segments, sortKey: 0, state: ks, terrainData: Gi });
        }
        $e && wt.sort((Mt, Nt) => Mt.sortKey - Nt.sortKey);
        for (const Mt of wt) {
          const Nt = Mt.state;
          if (re.activeTexture.set(ae.TEXTURE0), Nt.atlasTexture.bind(Nt.atlasInterpolation, ae.CLAMP_TO_EDGE), Nt.atlasTextureIcon && (re.activeTexture.set(ae.TEXTURE1), Nt.atlasTextureIcon && Nt.atlasTextureIcon.bind(Nt.atlasInterpolationIcon, ae.CLAMP_TO_EDGE)), Nt.isSDF) {
            const Ct = Nt.uniformValues;
            Nt.hasHalo && (Ct.u_is_halo = 1, cu(Nt.buffers, Mt.segments, u, b, Nt.program, Je, G, Z, Ct, Nt.projectionData, Mt.terrainData)), Ct.u_is_halo = 0;
          }
          cu(Nt.buffers, Mt.segments, u, b, Nt.program, Je, G, Z, Nt.uniformValues, Nt.projectionData, Mt.terrainData);
        }
      }
      function cu(b, s, u, p, m, x, E, L, B, N, G) {
        const Z = p.context;
        m.draw(Z, Z.gl.TRIANGLES, x, E, L, li.backCCW, B, G, N, u.id, b.layoutVertexBuffer, b.indexBuffer, s, u.paint, p.transform.zoom, b.programConfigurations.get(u.id), b.dynamicLayoutVertexBuffer, b.opacityVertexBuffer);
      }
      function ju(b, s, u, p, m) {
        const x = b.context, E = x.gl, L = gi.disabled, B = new Ui([E.ONE, E.ONE], a.b5.transparent, [!0, !0, !0, !0]), N = s.getBucket(u);
        if (!N) return;
        const G = p.key;
        let Z = u.heatmapFbos.get(G);
        Z || (Z = Oc(x, s.tileSize, s.tileSize), u.heatmapFbos.set(G, Z)), x.bindFramebuffer.set(Z.framebuffer), x.viewport.set([0, 0, s.tileSize, s.tileSize]), x.clear({ color: a.b5.transparent });
        const $ = N.programConfigurations.get(u.id), re = b.useProgram("heatmap", $, !m), ae = b.transform.getProjectionData({ overscaledTileID: s.tileID, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), Pe = b.style.map.terrain.getTerrainData(p);
        re.draw(x, E.TRIANGLES, Kn.disabled, L, B, li.disabled, ir(s, b.transform.zoom, u.paint.get("heatmap-intensity"), 1), Pe, ae, u.id, N.layoutVertexBuffer, N.indexBuffer, N.segments, u.paint, b.transform.zoom, $);
      }
      function uu(b, s, u, p, m) {
        const x = b.context, E = x.gl, L = b.transform;
        x.setColorMode(b.colorModeForRenderPass());
        const B = hu(x, s), N = u.key, G = s.heatmapFbos.get(N);
        if (!G) return;
        x.activeTexture.set(E.TEXTURE0), E.bindTexture(E.TEXTURE_2D, G.colorAttachment.get()), x.activeTexture.set(E.TEXTURE1), B.bind(E.LINEAR, E.CLAMP_TO_EDGE);
        const Z = L.getProjectionData({ overscaledTileID: u, applyTerrainMatrix: m, applyGlobeMatrix: !p });
        b.useProgram("heatmapTexture").draw(x, E.TRIANGLES, Kn.disabled, gi.disabled, b.colorModeForRenderPass(), li.disabled, Wi(b, s, 0, 1), null, Z, s.id, b.rasterBoundsBuffer, b.quadTriangleIndexBuffer, b.rasterBoundsSegments, s.paint, L.zoom), G.destroy(), s.heatmapFbos.delete(N);
      }
      function Oc(b, s, u) {
        var p, m;
        const x = b.gl, E = x.createTexture();
        x.bindTexture(x.TEXTURE_2D, E), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_S, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_WRAP_T, x.CLAMP_TO_EDGE), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MIN_FILTER, x.LINEAR), x.texParameteri(x.TEXTURE_2D, x.TEXTURE_MAG_FILTER, x.LINEAR);
        const L = (p = b.HALF_FLOAT) !== null && p !== void 0 ? p : x.UNSIGNED_BYTE, B = (m = b.RGBA16F) !== null && m !== void 0 ? m : x.RGBA;
        x.texImage2D(x.TEXTURE_2D, 0, B, s, u, 0, x.RGBA, L, null);
        const N = b.createFramebuffer(s, u, !1, !1);
        return N.colorAttachment.set(E), N;
      }
      function hu(b, s) {
        return s.colorRampTexture || (s.colorRampTexture = new me(b, s.colorRamp, b.gl.RGBA)), s.colorRampTexture;
      }
      function Dc(b, s, u, p, m) {
        if (!u || !p || !p.imageAtlas) return;
        const x = p.imageAtlas.patternPositions;
        let E = x[u.to.toString()], L = x[u.from.toString()];
        if (!E && L && (E = L), !L && E && (L = E), !E || !L) {
          const B = m.getPaintProperty(s);
          E = x[B], L = x[B];
        }
        E && L && b.setConstantPatternPositions(E, L);
      }
      function Kl(b, s, u, p, m, x, E, L) {
        const B = b.context.gl, N = "fill-pattern", G = u.paint.get(N), Z = G && G.constantOr(1), $ = u.getCrossfadeParameters();
        let re, ae, Pe, Ce, Ie;
        const Be = b.transform, He = u.paint.get("fill-translate"), We = u.paint.get("fill-translate-anchor");
        E ? (ae = Z && !u.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", re = B.LINES) : (ae = Z ? "fillPattern" : "fill", re = B.TRIANGLES);
        const $e = G.constantOr(null);
        for (const Je of p) {
          const Qe = s.getTile(Je);
          if (Z && !Qe.patternsLoaded()) continue;
          const wt = Qe.getBucket(u);
          if (!wt) continue;
          const bt = wt.programConfigurations.get(u.id), Mt = b.useProgram(ae, bt), Nt = b.style.map.terrain && b.style.map.terrain.getTerrainData(Je);
          Z && (b.context.activeTexture.set(B.TEXTURE0), Qe.imageAtlasTexture.bind(B.LINEAR, B.CLAMP_TO_EDGE), bt.updatePaintBuffers($)), Dc(bt, N, $e, Qe, u);
          const Ct = Be.getProjectionData({ overscaledTileID: Je, applyGlobeMatrix: !L, applyTerrainMatrix: !0 }), sn = a.av(Be, Qe, He, We);
          if (E) {
            Ce = wt.indexBuffer2, Ie = wt.segments2;
            const Gt = [B.drawingBufferWidth, B.drawingBufferHeight];
            Pe = ae === "fillOutlinePattern" && Z ? Tn(b, $, Qe, Gt, sn) : tn(Gt, sn);
          } else Ce = wt.indexBuffer, Ie = wt.segments, Pe = Z ? kt(b, $, Qe, sn) : { u_fill_translate: sn };
          let nn;
          if (b.renderPass === "translucent" && L) {
            const [Gt] = b.getStencilConfigForOverlapAndUpdateStencilID(p);
            nn = Gt[Je.overscaledZ];
          } else nn = b.stencilModeForClipping(Je);
          Mt.draw(b.context, re, m, nn, x, li.backCCW, Pe, Nt, Ct, u.id, wt.layoutVertexBuffer, Ce, Ie, u.paint, b.transform.zoom, bt);
        }
      }
      function du(b, s, u, p, m, x, E, L) {
        const B = b.context, N = B.gl, G = "fill-extrusion-pattern", Z = u.paint.get(G), $ = Z.constantOr(1), re = u.getCrossfadeParameters(), ae = u.paint.get("fill-extrusion-opacity"), Pe = Z.constantOr(null), Ce = b.transform;
        for (const Ie of p) {
          const Be = s.getTile(Ie), He = Be.getBucket(u);
          if (!He) continue;
          const We = b.style.map.terrain && b.style.map.terrain.getTerrainData(Ie), $e = He.programConfigurations.get(u.id), Je = b.useProgram($ ? "fillExtrusionPattern" : "fillExtrusion", $e);
          $ && (b.context.activeTexture.set(N.TEXTURE0), Be.imageAtlasTexture.bind(N.LINEAR, N.CLAMP_TO_EDGE), $e.updatePaintBuffers(re));
          const Qe = Ce.getProjectionData({ overscaledTileID: Ie, applyGlobeMatrix: !L, applyTerrainMatrix: !0 });
          Dc($e, G, Pe, Be, u);
          const wt = a.av(Ce, Be, u.paint.get("fill-extrusion-translate"), u.paint.get("fill-extrusion-translate-anchor")), bt = u.paint.get("fill-extrusion-vertical-gradient"), Mt = $ ? yt(b, bt, ae, wt, Ie, re, Be) : Ke(b, bt, ae, wt);
          Je.draw(B, B.gl.TRIANGLES, m, x, E, li.backCCW, Mt, We, Qe, u.id, He.layoutVertexBuffer, He.indexBuffer, He.segments, u.paint, b.transform.zoom, $e, b.style.map.terrain && He.centroidVertexBuffer);
        }
      }
      function bh(b, s, u, p, m, x, E, L, B) {
        var N;
        const G = b.style.projection, Z = b.context, $ = b.transform, re = Z.gl, ae = b.useProgram("hillshade"), Pe = !b.options.moving;
        for (const Ce of p) {
          const Ie = s.getTile(Ce), Be = Ie.fbo;
          if (!Be) continue;
          const He = G.getMeshFromTileID(Z, Ce.canonical, L, !0, "raster"), We = (N = b.style.map.terrain) === null || N === void 0 ? void 0 : N.getTerrainData(Ce);
          Z.activeTexture.set(re.TEXTURE0), re.bindTexture(re.TEXTURE_2D, Be.colorAttachment.get());
          const $e = $.getProjectionData({ overscaledTileID: Ce, aligned: Pe, applyGlobeMatrix: !B, applyTerrainMatrix: !0 });
          ae.draw(Z, re.TRIANGLES, x, m[Ce.overscaledZ], E, li.backCCW, Sr(b, Ie, u), We, $e, u.id, He.vertexBuffer, He.indexBuffer, He.segments);
        }
      }
      const fu = [new a.P(0, 0), new a.P(a.Y, 0), new a.P(a.Y, a.Y), new a.P(0, a.Y)];
      function sr(b, s, u, p, m, x, E, L) {
        let B = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : !1, N = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : !1;
        const G = p[p.length - 1].overscaledZ, Z = b.context, $ = Z.gl, re = b.useProgram("raster"), ae = b.transform, Pe = b.style.projection, Ce = b.colorModeForRenderPass(), Ie = !b.options.moving;
        for (const Be of p) {
          const He = b.getDepthModeForSublayer(Be.overscaledZ - G, u.paint.get("raster-opacity") === 1 ? Kn.ReadWrite : Kn.ReadOnly, $.LESS), We = s.getTile(Be);
          We.registerFadeDuration(u.paint.get("raster-fade-duration"));
          const $e = s.findLoadedParent(Be, 0), Je = s.findLoadedSibling(Be), Qe = Ql(We, $e || Je || null, s, u, b.transform, b.style.map.terrain);
          let wt, bt;
          const Mt = u.paint.get("raster-resampling") === "nearest" ? $.NEAREST : $.LINEAR;
          Z.activeTexture.set($.TEXTURE0), We.texture.bind(Mt, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), Z.activeTexture.set($.TEXTURE1), $e ? ($e.texture.bind(Mt, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), wt = Math.pow(2, $e.tileID.overscaledZ - We.tileID.overscaledZ), bt = [We.tileID.canonical.x * wt % 1, We.tileID.canonical.y * wt % 1]) : We.texture.bind(Mt, $.CLAMP_TO_EDGE, $.LINEAR_MIPMAP_NEAREST), We.texture.useMipmap && Z.extTextureFilterAnisotropic && b.transform.pitch > 20 && $.texParameterf($.TEXTURE_2D, Z.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Z.extTextureFilterAnisotropicMax);
          const Nt = b.style.map.terrain && b.style.map.terrain.getTerrainData(Be), Ct = ae.getProjectionData({ overscaledTileID: Be, aligned: Ie, applyGlobeMatrix: !N, applyTerrainMatrix: !0 }), sn = Gl(bt || [0, 0], wt || 1, Qe, u, L), nn = Pe.getMeshFromTileID(Z, Be.canonical, x, E, "raster");
          re.draw(Z, $.TRIANGLES, He, m ? m[Be.overscaledZ] : gi.disabled, Ce, B ? li.frontCCW : li.backCCW, sn, Nt, Ct, u.id, nn.vertexBuffer, nn.indexBuffer, nn.segments);
        }
      }
      function Ql(b, s, u, p, m, x) {
        const E = p.paint.get("raster-fade-duration");
        if (!x && E > 0) {
          const L = I.now(), B = (L - b.timeAdded) / E, N = s ? (L - s.timeAdded) / E : -1, G = u.getSource(), Z = Dr(m, { tileSize: G.tileSize, roundZoom: G.roundZoom }), $ = !s || Math.abs(s.tileID.overscaledZ - Z) > Math.abs(b.tileID.overscaledZ - Z), re = $ && b.refreshedUponExpiration ? 1 : a.ac($ ? B : 1 - N, 0, 1);
          return b.refreshedUponExpiration && B >= 1 && (b.refreshedUponExpiration = !1), s ? { opacity: 1, mix: 1 - re } : { opacity: re, mix: 0 };
        }
        return { opacity: 1, mix: 0 };
      }
      const Ro = new a.b5(1, 0, 0, 1), vh = new a.b5(0, 1, 0, 1), xh = new a.b5(0, 0, 1, 1), Gu = new a.b5(1, 0, 1, 1), gl = new a.b5(0, 1, 1, 1);
      function _a(b, s, u, p) {
        pu(b, 0, s + u / 2, b.transform.width, u, p);
      }
      function Vu(b, s, u, p) {
        pu(b, s - u / 2, 0, u, b.transform.height, p);
      }
      function pu(b, s, u, p, m, x) {
        const E = b.context, L = E.gl;
        L.enable(L.SCISSOR_TEST), L.scissor(s * b.pixelRatio, u * b.pixelRatio, p * b.pixelRatio, m * b.pixelRatio), E.clear({ color: x }), L.disable(L.SCISSOR_TEST);
      }
      function wh(b, s, u) {
        const p = b.context, m = p.gl, x = b.useProgram("debug"), E = Kn.disabled, L = gi.disabled, B = b.colorModeForRenderPass(), N = "$debug", G = b.style.map.terrain && b.style.map.terrain.getTerrainData(u);
        p.activeTexture.set(m.TEXTURE0);
        const Z = s.getTileByID(u.key).latestRawTileData, $ = Math.floor((Z && Z.byteLength || 0) / 1024), re = s.getTile(u).tileSize, ae = 512 / Math.min(re, 512) * (u.overscaledZ / b.transform.zoom) * 0.5;
        let Pe = u.canonical.toString();
        u.overscaledZ !== u.canonical.z && (Pe += ` => ${u.overscaledZ}`), function(Ie, Be) {
          Ie.initDebugOverlayCanvas();
          const He = Ie.debugOverlayCanvas, We = Ie.context.gl, $e = Ie.debugOverlayCanvas.getContext("2d");
          $e.clearRect(0, 0, He.width, He.height), $e.shadowColor = "white", $e.shadowBlur = 2, $e.lineWidth = 1.5, $e.strokeStyle = "white", $e.textBaseline = "top", $e.font = "bold 36px Open Sans, sans-serif", $e.fillText(Be, 5, 5), $e.strokeText(Be, 5, 5), Ie.debugOverlayTexture.update(He), Ie.debugOverlayTexture.bind(We.LINEAR, We.CLAMP_TO_EDGE);
        }(b, `${Pe} ${$}kB`);
        const Ce = b.transform.getProjectionData({ overscaledTileID: u, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
        x.draw(p, m.TRIANGLES, E, L, Ui.alphaBlended, li.disabled, wi(a.b5.transparent, ae), null, Ce, N, b.debugBuffer, b.quadTriangleIndexBuffer, b.debugSegments), x.draw(p, m.LINE_STRIP, E, L, B, li.disabled, wi(a.b5.red), G, Ce, N, b.debugBuffer, b.tileBorderIndexBuffer, b.debugSegments);
      }
      function Ah(b, s, u, p) {
        const { isRenderingGlobe: m } = p, x = b.context, E = x.gl, L = b.transform, B = b.colorModeForRenderPass(), N = b.getDepthModeFor3D(), G = b.useProgram("terrain");
        x.bindFramebuffer.set(null), x.viewport.set([0, 0, b.width, b.height]);
        for (const Z of u) {
          const $ = s.getTerrainMesh(Z.tileID), re = b.renderToTexture.getTexture(Z), ae = s.getTerrainData(Z.tileID);
          x.activeTexture.set(E.TEXTURE0), E.bindTexture(E.TEXTURE_2D, re.texture);
          const Pe = s.getMeshFrameDelta(L.zoom), Ce = L.calculateFogMatrix(Z.tileID.toUnwrapped()), Ie = Po(Pe, Ce, b.style.sky, L.pitch, m), Be = L.getProjectionData({ overscaledTileID: Z.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
          G.draw(x, E.TRIANGLES, N, gi.disabled, B, li.backCCW, Ie, ae, Be, "terrain", $.vertexBuffer, $.indexBuffer, $.segments);
        }
      }
      function Th(b, s) {
        if (!s.mesh) {
          const u = new a.aD();
          u.emplaceBack(-1, -1), u.emplaceBack(1, -1), u.emplaceBack(1, 1), u.emplaceBack(-1, 1);
          const p = new a.aF();
          p.emplaceBack(0, 1, 2), p.emplaceBack(0, 2, 3), s.mesh = new as(b.createVertexBuffer(u, Qn.members), b.createIndexBuffer(p), a.aE.simpleSegment(0, 0, u.length, p.length));
        }
        return s.mesh;
      }
      class ld {
        constructor(s, u) {
          this.context = new $l(s), this.transform = u, this._tileTextures = {}, this.terrainFacilitator = { dirty: !0, matrix: a.ar(new Float64Array(16)), renderTime: 0 }, this.setup(), this.numSublayers = ne.maxUnderzooming + ne.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new yr();
        }
        resize(s, u, p) {
          if (this.width = Math.floor(s * p), this.height = Math.floor(u * p), this.pixelRatio = p, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const m of this.style._order) this.style._layers[m].resize();
        }
        setup() {
          const s = this.context, u = new a.aD();
          u.emplaceBack(0, 0), u.emplaceBack(a.Y, 0), u.emplaceBack(0, a.Y), u.emplaceBack(a.Y, a.Y), this.tileExtentBuffer = s.createVertexBuffer(u, Qn.members), this.tileExtentSegments = a.aE.simpleSegment(0, 0, 4, 2);
          const p = new a.aD();
          p.emplaceBack(0, 0), p.emplaceBack(a.Y, 0), p.emplaceBack(0, a.Y), p.emplaceBack(a.Y, a.Y), this.debugBuffer = s.createVertexBuffer(p, Qn.members), this.debugSegments = a.aE.simpleSegment(0, 0, 4, 5);
          const m = new a.bU();
          m.emplaceBack(0, 0, 0, 0), m.emplaceBack(a.Y, 0, a.Y, 0), m.emplaceBack(0, a.Y, 0, a.Y), m.emplaceBack(a.Y, a.Y, a.Y, a.Y), this.rasterBoundsBuffer = s.createVertexBuffer(m, kl.members), this.rasterBoundsSegments = a.aE.simpleSegment(0, 0, 4, 2);
          const x = new a.aD();
          x.emplaceBack(0, 0), x.emplaceBack(a.Y, 0), x.emplaceBack(0, a.Y), x.emplaceBack(a.Y, a.Y), this.rasterBoundsBufferPosOnly = s.createVertexBuffer(x, Qn.members), this.rasterBoundsSegmentsPosOnly = a.aE.simpleSegment(0, 0, 4, 5);
          const E = new a.aD();
          E.emplaceBack(0, 0), E.emplaceBack(1, 0), E.emplaceBack(0, 1), E.emplaceBack(1, 1), this.viewportBuffer = s.createVertexBuffer(E, Qn.members), this.viewportSegments = a.aE.simpleSegment(0, 0, 4, 2);
          const L = new a.bV();
          L.emplaceBack(0), L.emplaceBack(1), L.emplaceBack(3), L.emplaceBack(2), L.emplaceBack(0), this.tileBorderIndexBuffer = s.createIndexBuffer(L);
          const B = new a.aF();
          B.emplaceBack(1, 0, 2), B.emplaceBack(1, 2, 3), this.quadTriangleIndexBuffer = s.createIndexBuffer(B);
          const N = this.context.gl;
          this.stencilClearMode = new gi({ func: N.ALWAYS, mask: 0 }, 0, 255, N.ZERO, N.ZERO, N.ZERO), this.tileExtentMesh = new as(this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
        }
        clearStencil() {
          const s = this.context, u = s.gl;
          this.nextStencilID = 1, this.currentStencilSource = void 0;
          const p = a.J();
          a.bM(p, 0, this.width, this.height, 0, 0, 1), a.L(p, p, [u.drawingBufferWidth, u.drawingBufferHeight, 0]);
          const m = { mainMatrix: p, tileMercatorCoords: [0, 0, 1, 1], clippingPlane: [0, 0, 0, 0], projectionTransition: 0, fallbackMatrix: p };
          this.useProgram("clippingMask", null, !0).draw(s, u.TRIANGLES, Kn.disabled, this.stencilClearMode, Ui.disabled, li.disabled, null, null, m, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
        }
        _renderTileClippingMasks(s, u, p) {
          if (this.currentStencilSource === s.source || !s.isTileClipped() || !u || !u.length) return;
          this.currentStencilSource = s.source, this.nextStencilID + u.length > 256 && this.clearStencil();
          const m = this.context;
          m.setColorMode(Ui.disabled), m.setDepthMode(Kn.disabled);
          const x = {};
          for (const E of u) x[E.key] = this.nextStencilID++;
          this._renderTileMasks(x, u, p, !0), this._renderTileMasks(x, u, p, !1), this._tileClippingMaskIDs = x;
        }
        _renderTileMasks(s, u, p, m) {
          const x = this.context, E = x.gl, L = this.style.projection, B = this.transform, N = this.useProgram("clippingMask");
          for (const G of u) {
            const Z = s[G.key], $ = this.style.map.terrain && this.style.map.terrain.getTerrainData(G), re = L.getMeshFromTileID(this.context, G.canonical, m, !0, "stencil"), ae = B.getProjectionData({ overscaledTileID: G, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
            N.draw(x, E.TRIANGLES, Kn.disabled, new gi({ func: E.ALWAYS, mask: 0 }, Z, 255, E.KEEP, E.KEEP, E.REPLACE), Ui.disabled, p ? li.disabled : li.backCCW, null, $, ae, "$clipping", re.vertexBuffer, re.indexBuffer, re.segments);
          }
        }
        _renderTilesDepthBuffer() {
          const s = this.context, u = s.gl, p = this.style.projection, m = this.transform, x = this.useProgram("depth"), E = this.getDepthModeFor3D(), L = be(m, { tileSize: m.tileSize });
          for (const B of L) {
            const N = this.style.map.terrain && this.style.map.terrain.getTerrainData(B), G = p.getMeshFromTileID(this.context, B.canonical, !0, !0, "raster"), Z = m.getProjectionData({ overscaledTileID: B, applyGlobeMatrix: !0, applyTerrainMatrix: !0 });
            x.draw(s, u.TRIANGLES, E, gi.disabled, Ui.disabled, li.backCCW, null, N, Z, "$clipping", G.vertexBuffer, G.indexBuffer, G.segments);
          }
        }
        stencilModeFor3D() {
          this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
          const s = this.nextStencilID++, u = this.context.gl;
          return new gi({ func: u.NOTEQUAL, mask: 255 }, s, 255, u.KEEP, u.KEEP, u.REPLACE);
        }
        stencilModeForClipping(s) {
          const u = this.context.gl;
          return new gi({ func: u.EQUAL, mask: 255 }, this._tileClippingMaskIDs[s.key], 0, u.KEEP, u.KEEP, u.REPLACE);
        }
        getStencilConfigForOverlapAndUpdateStencilID(s) {
          const u = this.context.gl, p = s.sort((E, L) => L.overscaledZ - E.overscaledZ), m = p[p.length - 1].overscaledZ, x = p[0].overscaledZ - m + 1;
          if (x > 1) {
            this.currentStencilSource = void 0, this.nextStencilID + x > 256 && this.clearStencil();
            const E = {};
            for (let L = 0; L < x; L++) E[L + m] = new gi({ func: u.GEQUAL, mask: 255 }, L + this.nextStencilID, 255, u.KEEP, u.KEEP, u.REPLACE);
            return this.nextStencilID += x, [E, p];
          }
          return [{ [m]: gi.disabled }, p];
        }
        stencilConfigForOverlapTwoPass(s) {
          const u = this.context.gl, p = s.sort((E, L) => L.overscaledZ - E.overscaledZ), m = p[p.length - 1].overscaledZ, x = p[0].overscaledZ - m + 1;
          if (this.clearStencil(), x > 1) {
            const E = {}, L = {};
            for (let B = 0; B < x; B++) E[B + m] = new gi({ func: u.GREATER, mask: 255 }, x + 1 + B, 255, u.KEEP, u.KEEP, u.REPLACE), L[B + m] = new gi({ func: u.GREATER, mask: 255 }, 1 + B, 255, u.KEEP, u.KEEP, u.REPLACE);
            return this.nextStencilID = 2 * x + 1, [E, L, p];
          }
          return this.nextStencilID = 3, [{ [m]: new gi({ func: u.GREATER, mask: 255 }, 2, 255, u.KEEP, u.KEEP, u.REPLACE) }, { [m]: new gi({ func: u.GREATER, mask: 255 }, 1, 255, u.KEEP, u.KEEP, u.REPLACE) }, p];
        }
        colorModeForRenderPass() {
          const s = this.context.gl;
          return this._showOverdrawInspector ? new Ui([s.CONSTANT_COLOR, s.ONE], new a.b5(0.125, 0.125, 0.125, 0), [!0, !0, !0, !0]) : this.renderPass === "opaque" ? Ui.unblended : Ui.alphaBlended;
        }
        getDepthModeForSublayer(s, u, p) {
          if (!this.opaquePassEnabledForLayer()) return Kn.disabled;
          const m = 1 - ((1 + this.currentLayer) * this.numSublayers + s) * this.depthEpsilon;
          return new Kn(p || this.context.gl.LEQUAL, u, [m, m]);
        }
        getDepthModeFor3D() {
          return new Kn(this.context.gl.LEQUAL, Kn.ReadWrite, this.depthRangeFor3D);
        }
        opaquePassEnabledForLayer() {
          return this.currentLayer < this.opaquePassCutoff;
        }
        render(s, u) {
          var p, m;
          this.style = s, this.options = u, this.lineAtlas = s.lineAtlas, this.imageManager = s.imageManager, this.glyphManager = s.glyphManager, this.symbolFadeChange = s.placement.symbolFadeChange(I.now()), this.imageManager.beginFrame();
          const x = this.style._order, E = this.style.sourceCaches, L = {}, B = {}, N = {}, G = { isRenderingToTexture: !1, isRenderingGlobe: ((p = s.projection) === null || p === void 0 ? void 0 : p.transitionState) > 0 };
          for (const $ in E) {
            const re = E[$];
            re.used && re.prepare(this.context), L[$] = re.getVisibleCoordinates(!1), B[$] = L[$].slice().reverse(), N[$] = re.getVisibleCoordinates(!0).reverse();
          }
          this.opaquePassCutoff = 1 / 0;
          for (let $ = 0; $ < x.length; $++) if (this.style._layers[x[$]].is3D()) {
            this.opaquePassCutoff = $;
            break;
          }
          this.maybeDrawDepthAndCoords(!1), this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0), this.renderPass = "offscreen";
          for (const $ of x) {
            const re = this.style._layers[$];
            if (!re.hasOffscreenPass() || re.isHidden(this.transform.zoom)) continue;
            const ae = B[re.source];
            (re.type === "custom" || ae.length) && this.renderLayer(this, E[re.source], re, ae, G);
          }
          if ((m = this.style.projection) === null || m === void 0 || m.updateGPUdependent({ context: this.context, useProgram: ($) => this.useProgram($) }), this.context.viewport.set([0, 0, this.width, this.height]), this.context.bindFramebuffer.set(null), this.context.clear({ color: u.showOverdrawInspector ? a.b5.black : a.b5.transparent, depth: 1 }), this.clearStencil(), this.style.sky && function($, re) {
            const ae = $.context, Pe = ae.gl, Ce = ((Je, Qe, wt) => {
              const bt = Math.cos(Qe.rollInRadians), Mt = Math.sin(Qe.rollInRadians), Nt = _t(Qe), Ct = Qe.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }).projectionTransition;
              return { u_sky_color: Je.properties.get("sky-color"), u_horizon_color: Je.properties.get("horizon-color"), u_horizon: [(Qe.width / 2 - Nt * Mt) * wt, (Qe.height / 2 + Nt * bt) * wt], u_horizon_normal: [-Mt, bt], u_sky_horizon_blend: Je.properties.get("sky-horizon-blend") * Qe.height / 2 * wt, u_sky_blend: Ct };
            })(re, $.style.map.transform, $.pixelRatio), Ie = new Kn(Pe.LEQUAL, Kn.ReadWrite, [0, 1]), Be = gi.disabled, He = $.colorModeForRenderPass(), We = $.useProgram("sky"), $e = Th(ae, re);
            We.draw(ae, Pe.TRIANGLES, Ie, Be, He, li.disabled, Ce, null, void 0, "sky", $e.vertexBuffer, $e.indexBuffer, $e.segments);
          }(this, this.style.sky), this._showOverdrawInspector = u.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (s._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture) for (this.renderPass = "opaque", this.currentLayer = x.length - 1; this.currentLayer >= 0; this.currentLayer--) {
            const $ = this.style._layers[x[this.currentLayer]], re = E[$.source], ae = L[$.source];
            this._renderTileClippingMasks($, ae, !1), this.renderLayer(this, re, $, ae, G);
          }
          this.renderPass = "translucent";
          let Z = !1;
          for (this.currentLayer = 0; this.currentLayer < x.length; this.currentLayer++) {
            const $ = this.style._layers[x[this.currentLayer]], re = E[$.source];
            if (this.renderToTexture && this.renderToTexture.renderLayer($, G)) continue;
            this.opaquePassEnabledForLayer() || Z || (Z = !0, G.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
            const ae = ($.type === "symbol" ? N : B)[$.source];
            this._renderTileClippingMasks($, L[$.source], !1), this.renderLayer(this, re, $, ae, G);
          }
          if (G.isRenderingGlobe && function($, re, ae) {
            const Pe = $.context, Ce = Pe.gl, Ie = $.useProgram("atmosphere"), Be = new Kn(Ce.LEQUAL, Kn.ReadOnly, [0, 1]), He = $.transform, We = function(Ct, sn) {
              const nn = Ct.properties.get("position"), Gt = [-nn.x, -nn.y, -nn.z], dn = a.ar(new Float64Array(16));
              return Ct.properties.get("anchor") === "map" && (a.aY(dn, dn, sn.rollInRadians), a.aZ(dn, dn, -sn.pitchInRadians), a.aY(dn, dn, sn.bearingInRadians), a.aZ(dn, dn, sn.center.lat * Math.PI / 180), a.bk(dn, dn, -sn.center.lng * Math.PI / 180)), a.bT(Gt, Gt, dn), Gt;
            }(ae, $.transform), $e = He.getProjectionData({ overscaledTileID: null, applyGlobeMatrix: !0, applyTerrainMatrix: !0 }), Je = re.properties.get("atmosphere-blend") * $e.projectionTransition;
            if (Je === 0) return;
            const Qe = Ks(He.worldSize, He.center.lat), wt = He.inverseProjectionMatrix, bt = new Float64Array(4);
            bt[3] = 1, a.an(bt, bt, He.modelViewProjectionMatrix), bt[0] /= bt[3], bt[1] /= bt[3], bt[2] /= bt[3], bt[3] = 1, a.an(bt, bt, wt), bt[0] /= bt[3], bt[1] /= bt[3], bt[2] /= bt[3], bt[3] = 1;
            const Mt = /* @__PURE__ */ ((Ct, sn, nn, Gt, dn) => ({ u_sun_pos: Ct, u_atmosphere_blend: sn, u_globe_position: nn, u_globe_radius: Gt, u_inv_proj_matrix: dn }))(We, Je, [bt[0], bt[1], bt[2]], Qe, wt), Nt = Th(Pe, re);
            Ie.draw(Pe, Ce.TRIANGLES, Be, gi.disabled, Ui.alphaBlended, li.disabled, Mt, null, null, "atmosphere", Nt.vertexBuffer, Nt.indexBuffer, Nt.segments);
          }(this, this.style.sky, this.style.light), this.options.showTileBoundaries) {
            const $ = function(re, ae) {
              let Pe = null;
              const Ce = Object.values(re._layers).flatMap((We) => We.source && !We.isHidden(ae) ? [re.sourceCaches[We.source]] : []), Ie = Ce.filter((We) => We.getSource().type === "vector"), Be = Ce.filter((We) => We.getSource().type !== "vector"), He = (We) => {
                (!Pe || Pe.getSource().maxzoom < We.getSource().maxzoom) && (Pe = We);
              };
              return Ie.forEach((We) => He(We)), Pe || Be.forEach((We) => He(We)), Pe;
            }(this.style, this.transform.zoom);
            $ && function(re, ae, Pe) {
              for (let Ce = 0; Ce < Pe.length; Ce++) wh(re, ae, Pe[Ce]);
            }(this, $, $.getVisibleCoordinates());
          }
          this.options.showPadding && function($) {
            const re = $.transform.padding;
            _a($, $.transform.height - (re.top || 0), 3, Ro), _a($, re.bottom || 0, 3, vh), Vu($, re.left || 0, 3, xh), Vu($, $.transform.width - (re.right || 0), 3, Gu);
            const ae = $.transform.centerPoint;
            (function(Pe, Ce, Ie, Be) {
              pu(Pe, Ce - 1, Ie - 10, 2, 20, Be), pu(Pe, Ce - 10, Ie - 1, 20, 2, Be);
            })($, ae.x, $.transform.height - ae.y, gl);
          }(this), this.context.setDefault();
        }
        maybeDrawDepthAndCoords(s) {
          if (!this.style || !this.style.map || !this.style.map.terrain) return;
          const u = this.terrainFacilitator.matrix, p = this.transform.modelViewProjectionMatrix;
          let m = this.terrainFacilitator.dirty;
          m || (m = s ? !a.bW(u, p) : !a.bX(u, p)), m || (m = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)), m && (a.bY(u, p), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = !1, function(x, E) {
            const L = x.context, B = L.gl, N = x.transform, G = Ui.unblended, Z = new Kn(B.LEQUAL, Kn.ReadWrite, [0, 1]), $ = E.sourceCache.getRenderableTiles(), re = x.useProgram("terrainDepth");
            L.bindFramebuffer.set(E.getFramebuffer("depth").framebuffer), L.viewport.set([0, 0, x.width / devicePixelRatio, x.height / devicePixelRatio]), L.clear({ color: a.b5.transparent, depth: 1 });
            for (const ae of $) {
              const Pe = E.getTerrainMesh(ae.tileID), Ce = E.getTerrainData(ae.tileID), Ie = N.getProjectionData({ overscaledTileID: ae.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 }), Be = { u_ele_delta: E.getMeshFrameDelta(N.zoom) };
              re.draw(L, B.TRIANGLES, Z, gi.disabled, G, li.backCCW, Be, Ce, Ie, "terrain", Pe.vertexBuffer, Pe.indexBuffer, Pe.segments);
            }
            L.bindFramebuffer.set(null), L.viewport.set([0, 0, x.width, x.height]);
          }(this, this.style.map.terrain), function(x, E) {
            const L = x.context, B = L.gl, N = x.transform, G = Ui.unblended, Z = new Kn(B.LEQUAL, Kn.ReadWrite, [0, 1]), $ = E.getCoordsTexture(), re = E.sourceCache.getRenderableTiles(), ae = x.useProgram("terrainCoords");
            L.bindFramebuffer.set(E.getFramebuffer("coords").framebuffer), L.viewport.set([0, 0, x.width / devicePixelRatio, x.height / devicePixelRatio]), L.clear({ color: a.b5.transparent, depth: 1 }), E.coordsIndex = [];
            for (const Pe of re) {
              const Ce = E.getTerrainMesh(Pe.tileID), Ie = E.getTerrainData(Pe.tileID);
              L.activeTexture.set(B.TEXTURE0), B.bindTexture(B.TEXTURE_2D, $.texture);
              const Be = { u_terrain_coords_id: (255 - E.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: E.getMeshFrameDelta(N.zoom) }, He = N.getProjectionData({ overscaledTileID: Pe.tileID, applyTerrainMatrix: !1, applyGlobeMatrix: !0 });
              ae.draw(L, B.TRIANGLES, Z, gi.disabled, G, li.backCCW, Be, Ie, He, "terrain", Ce.vertexBuffer, Ce.indexBuffer, Ce.segments), E.coordsIndex.push(Pe.tileID.key);
            }
            L.bindFramebuffer.set(null), L.viewport.set([0, 0, x.width, x.height]);
          }(this, this.style.map.terrain));
        }
        renderLayer(s, u, p, m, x) {
          p.isHidden(this.transform.zoom) || (p.type === "background" || p.type === "custom" || (m || []).length) && (this.id = p.id, a.bZ(p) ? function(E, L, B, N, G, Z) {
            if (E.renderPass !== "translucent") return;
            const { isRenderingToTexture: $ } = Z, re = gi.disabled, ae = E.colorModeForRenderPass();
            (B._unevaluatedLayout.hasValue("text-variable-anchor") || B._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(Pe, Ce, Ie, Be, He, We, $e, Je, Qe) {
              const wt = Ce.transform, bt = Ce.style.map.terrain, Mt = He === "map", Nt = We === "map";
              for (const Ct of Pe) {
                const sn = Be.getTile(Ct), nn = sn.getBucket(Ie);
                if (!nn || !nn.text || !nn.text.segments.get().length) continue;
                const Gt = a.ae(nn.textSizeData, wt.zoom), dn = a.au(sn, 1, Ce.transform.zoom), Hn = mt(Mt, Ce.transform, dn), bi = Ie.layout.get("icon-text-fit") !== "none" && nn.hasIconData();
                if (Gt) {
                  const Qi = Math.pow(2, wt.zoom - sn.tileID.overscaledZ), Gi = bt ? (er, Ci) => bt.getElevation(Ct, er, Ci) : null;
                  Bc(nn, Mt, Nt, Qe, wt, Hn, Qi, Gt, bi, a.av(wt, sn, $e, Je), Ct.toUnwrapped(), Gi);
                }
              }
            }(N, E, B, L, B.layout.get("text-rotation-alignment"), B.layout.get("text-pitch-alignment"), B.paint.get("text-translate"), B.paint.get("text-translate-anchor"), G), B.paint.get("icon-opacity").constantOr(1) !== 0 && Jl(E, L, B, N, !1, B.paint.get("icon-translate"), B.paint.get("icon-translate-anchor"), B.layout.get("icon-rotation-alignment"), B.layout.get("icon-pitch-alignment"), B.layout.get("icon-keep-upright"), re, ae, $), B.paint.get("text-opacity").constantOr(1) !== 0 && Jl(E, L, B, N, !0, B.paint.get("text-translate"), B.paint.get("text-translate-anchor"), B.layout.get("text-rotation-alignment"), B.layout.get("text-pitch-alignment"), B.layout.get("text-keep-upright"), re, ae, $), L.map.showCollisionBoxes && (Xl(E, L, B, N, !0), Xl(E, L, B, N, !1));
          }(s, u, p, m, this.style.placement.variableOffsets, x) : a.b_(p) ? function(E, L, B, N, G) {
            if (E.renderPass !== "translucent") return;
            const { isRenderingToTexture: Z } = G, $ = B.paint.get("circle-opacity"), re = B.paint.get("circle-stroke-width"), ae = B.paint.get("circle-stroke-opacity"), Pe = !B.layout.get("circle-sort-key").isConstant();
            if ($.constantOr(1) === 0 && (re.constantOr(1) === 0 || ae.constantOr(1) === 0)) return;
            const Ce = E.context, Ie = Ce.gl, Be = E.transform, He = E.getDepthModeForSublayer(0, Kn.ReadOnly), We = gi.disabled, $e = E.colorModeForRenderPass(), Je = [], Qe = Be.getCircleRadiusCorrection();
            for (let wt = 0; wt < N.length; wt++) {
              const bt = N[wt], Mt = L.getTile(bt), Nt = Mt.getBucket(B);
              if (!Nt) continue;
              const Ct = B.paint.get("circle-translate"), sn = B.paint.get("circle-translate-anchor"), nn = a.av(Be, Mt, Ct, sn), Gt = Nt.programConfigurations.get(B.id), dn = E.useProgram("circle", Gt), Hn = Nt.layoutVertexBuffer, bi = Nt.indexBuffer, Qi = E.style.map.terrain && E.style.map.terrain.getTerrainData(bt), Gi = { programConfiguration: Gt, program: dn, layoutVertexBuffer: Hn, indexBuffer: bi, uniformValues: kn(E, Mt, B, nn, Qe), terrainData: Qi, projectionData: Be.getProjectionData({ overscaledTileID: bt, applyGlobeMatrix: !Z, applyTerrainMatrix: !0 }) };
              if (Pe) {
                const er = Nt.segments.get();
                for (const Ci of er) Je.push({ segments: new a.aE([Ci]), sortKey: Ci.sortKey, state: Gi });
              } else Je.push({ segments: Nt.segments, sortKey: 0, state: Gi });
            }
            Pe && Je.sort((wt, bt) => wt.sortKey - bt.sortKey);
            for (const wt of Je) {
              const { programConfiguration: bt, program: Mt, layoutVertexBuffer: Nt, indexBuffer: Ct, uniformValues: sn, terrainData: nn, projectionData: Gt } = wt.state;
              Mt.draw(Ce, Ie.TRIANGLES, He, We, $e, li.backCCW, sn, nn, Gt, B.id, Nt, Ct, wt.segments, B.paint, E.transform.zoom, bt);
            }
          }(s, u, p, m, x) : a.b$(p) ? function(E, L, B, N, G) {
            if (B.paint.get("heatmap-opacity") === 0) return;
            const Z = E.context, { isRenderingToTexture: $, isRenderingGlobe: re } = G;
            if (E.style.map.terrain) {
              for (const ae of N) {
                const Pe = L.getTile(ae);
                L.hasRenderableParent(ae) || (E.renderPass === "offscreen" ? ju(E, Pe, B, ae, re) : E.renderPass === "translucent" && uu(E, B, ae, $, re));
              }
              Z.viewport.set([0, 0, E.width, E.height]);
            } else E.renderPass === "offscreen" ? function(ae, Pe, Ce, Ie) {
              const Be = ae.context, He = Be.gl, We = ae.transform, $e = gi.disabled, Je = new Ui([He.ONE, He.ONE], a.b5.transparent, [!0, !0, !0, !0]);
              (function(Qe, wt, bt) {
                const Mt = Qe.gl;
                Qe.activeTexture.set(Mt.TEXTURE1), Qe.viewport.set([0, 0, wt.width / 4, wt.height / 4]);
                let Nt = bt.heatmapFbos.get(a.bQ);
                Nt ? (Mt.bindTexture(Mt.TEXTURE_2D, Nt.colorAttachment.get()), Qe.bindFramebuffer.set(Nt.framebuffer)) : (Nt = Oc(Qe, wt.width / 4, wt.height / 4), bt.heatmapFbos.set(a.bQ, Nt));
              })(Be, ae, Ce), Be.clear({ color: a.b5.transparent });
              for (let Qe = 0; Qe < Ie.length; Qe++) {
                const wt = Ie[Qe];
                if (Pe.hasRenderableParent(wt)) continue;
                const bt = Pe.getTile(wt), Mt = bt.getBucket(Ce);
                if (!Mt) continue;
                const Nt = Mt.programConfigurations.get(Ce.id), Ct = ae.useProgram("heatmap", Nt), sn = We.getProjectionData({ overscaledTileID: wt, applyGlobeMatrix: !0, applyTerrainMatrix: !1 }), nn = We.getCircleRadiusCorrection();
                Ct.draw(Be, He.TRIANGLES, Kn.disabled, $e, Je, li.backCCW, ir(bt, We.zoom, Ce.paint.get("heatmap-intensity"), nn), null, sn, Ce.id, Mt.layoutVertexBuffer, Mt.indexBuffer, Mt.segments, Ce.paint, We.zoom, Nt);
              }
              Be.viewport.set([0, 0, ae.width, ae.height]);
            }(E, L, B, N) : E.renderPass === "translucent" && function(ae, Pe) {
              const Ce = ae.context, Ie = Ce.gl;
              Ce.setColorMode(ae.colorModeForRenderPass());
              const Be = Pe.heatmapFbos.get(a.bQ);
              Be && (Ce.activeTexture.set(Ie.TEXTURE0), Ie.bindTexture(Ie.TEXTURE_2D, Be.colorAttachment.get()), Ce.activeTexture.set(Ie.TEXTURE1), hu(Ce, Pe).bind(Ie.LINEAR, Ie.CLAMP_TO_EDGE), ae.useProgram("heatmapTexture").draw(Ce, Ie.TRIANGLES, Kn.disabled, gi.disabled, ae.colorModeForRenderPass(), li.disabled, Wi(ae, Pe, 0, 1), null, null, Pe.id, ae.viewportBuffer, ae.quadTriangleIndexBuffer, ae.viewportSegments, Pe.paint, ae.transform.zoom));
            }(E, B);
          }(s, u, p, m, x) : a.c0(p) ? function(E, L, B, N, G) {
            if (E.renderPass !== "translucent") return;
            const { isRenderingToTexture: Z } = G, $ = B.paint.get("line-opacity"), re = B.paint.get("line-width");
            if ($.constantOr(1) === 0 || re.constantOr(1) === 0) return;
            const ae = E.getDepthModeForSublayer(0, Kn.ReadOnly), Pe = E.colorModeForRenderPass(), Ce = B.paint.get("line-dasharray"), Ie = B.paint.get("line-pattern"), Be = Ie.constantOr(1), He = B.paint.get("line-gradient"), We = B.getCrossfadeParameters(), $e = Be ? "linePattern" : Ce ? "lineSDF" : He ? "lineGradient" : "line", Je = E.context, Qe = Je.gl, wt = E.transform;
            let bt = !0;
            for (const Mt of N) {
              const Nt = L.getTile(Mt);
              if (Be && !Nt.patternsLoaded()) continue;
              const Ct = Nt.getBucket(B);
              if (!Ct) continue;
              const sn = Ct.programConfigurations.get(B.id), nn = E.context.program.get(), Gt = E.useProgram($e, sn), dn = bt || Gt.program !== nn, Hn = E.style.map.terrain && E.style.map.terrain.getTerrainData(Mt), bi = Ie.constantOr(null);
              if (bi && Nt.imageAtlas) {
                const Ni = Nt.imageAtlas, ki = Ni.patternPositions[bi.to.toString()], ps = Ni.patternPositions[bi.from.toString()];
                ki && ps && sn.setConstantPatternPositions(ki, ps);
              }
              const Qi = wt.getProjectionData({ overscaledTileID: Mt, applyGlobeMatrix: !Z, applyTerrainMatrix: !0 }), Gi = wt.getPixelScale(), er = Be ? pa(E, Nt, B, Gi, We) : Ce ? zu(E, Nt, B, Gi, Ce, We) : He ? Bs(E, Nt, B, Gi, Ct.lineClipsArray.length) : po(E, Nt, B, Gi);
              if (Be) Je.activeTexture.set(Qe.TEXTURE0), Nt.imageAtlasTexture.bind(Qe.LINEAR, Qe.CLAMP_TO_EDGE), sn.updatePaintBuffers(We);
              else if (Ce && (dn || E.lineAtlas.dirty)) Je.activeTexture.set(Qe.TEXTURE0), E.lineAtlas.bind(Je);
              else if (He) {
                const Ni = Ct.gradients[B.id];
                let ki = Ni.texture;
                if (B.gradientVersion !== Ni.version) {
                  let ps = 256;
                  if (B.stepInterpolant) {
                    const Mr = L.getSource().maxzoom, zr = Mt.canonical.z === Mr ? Math.ceil(1 << E.transform.maxZoom - Mt.canonical.z) : 1;
                    ps = a.ac(a.bR(Ct.maxLineLength / a.Y * 1024 * zr), 256, Je.maxTextureSize);
                  }
                  Ni.gradient = a.bS({ expression: B.gradientExpression(), evaluationKey: "lineProgress", resolution: ps, image: Ni.gradient || void 0, clips: Ct.lineClipsArray }), Ni.texture ? Ni.texture.update(Ni.gradient) : Ni.texture = new me(Je, Ni.gradient, Qe.RGBA), Ni.version = B.gradientVersion, ki = Ni.texture;
                }
                Je.activeTexture.set(Qe.TEXTURE0), ki.bind(B.stepInterpolant ? Qe.NEAREST : Qe.LINEAR, Qe.CLAMP_TO_EDGE);
              }
              let Ci;
              if (Z) {
                const [Ni] = E.getStencilConfigForOverlapAndUpdateStencilID(N);
                Ci = Ni[Mt.overscaledZ];
              } else Ci = E.stencilModeForClipping(Mt);
              Gt.draw(Je, Qe.TRIANGLES, ae, Ci, Pe, li.disabled, er, Hn, Qi, B.id, Ct.layoutVertexBuffer, Ct.indexBuffer, Ct.segments, B.paint, E.transform.zoom, sn, Ct.layoutVertexBuffer2), bt = !1;
            }
          }(s, u, p, m, x) : a.c1(p) ? function(E, L, B, N, G) {
            const Z = B.paint.get("fill-color"), $ = B.paint.get("fill-opacity");
            if ($.constantOr(1) === 0) return;
            const { isRenderingToTexture: re } = G, ae = E.colorModeForRenderPass(), Pe = B.paint.get("fill-pattern"), Ce = E.opaquePassEnabledForLayer() && !Pe.constantOr(1) && Z.constantOr(a.b5.transparent).a === 1 && $.constantOr(0) === 1 ? "opaque" : "translucent";
            if (E.renderPass === Ce) {
              const Ie = E.getDepthModeForSublayer(1, E.renderPass === "opaque" ? Kn.ReadWrite : Kn.ReadOnly);
              Kl(E, L, B, N, Ie, ae, !1, re);
            }
            if (E.renderPass === "translucent" && B.paint.get("fill-antialias")) {
              const Ie = E.getDepthModeForSublayer(B.getPaintProperty("fill-outline-color") ? 2 : 0, Kn.ReadOnly);
              Kl(E, L, B, N, Ie, ae, !0, re);
            }
          }(s, u, p, m, x) : a.c2(p) ? function(E, L, B, N, G) {
            const Z = B.paint.get("fill-extrusion-opacity");
            if (Z === 0) return;
            const { isRenderingToTexture: $ } = G;
            if (E.renderPass === "translucent") {
              const re = new Kn(E.context.gl.LEQUAL, Kn.ReadWrite, E.depthRangeFor3D);
              if (Z !== 1 || B.paint.get("fill-extrusion-pattern").constantOr(1)) du(E, L, B, N, re, gi.disabled, Ui.disabled, $), du(E, L, B, N, re, E.stencilModeFor3D(), E.colorModeForRenderPass(), $);
              else {
                const ae = E.colorModeForRenderPass();
                du(E, L, B, N, re, gi.disabled, ae, $);
              }
            }
          }(s, u, p, m, x) : a.c3(p) ? function(E, L, B, N, G) {
            if (E.renderPass !== "offscreen" && E.renderPass !== "translucent") return;
            const { isRenderingToTexture: Z } = G, $ = E.context, re = E.style.projection.useSubdivision, ae = E.getDepthModeForSublayer(0, Kn.ReadOnly), Pe = E.colorModeForRenderPass();
            if (E.renderPass === "offscreen") (function(Ce, Ie, Be, He, We, $e, Je) {
              const Qe = Ce.context, wt = Qe.gl;
              for (const bt of Be) {
                const Mt = Ie.getTile(bt), Nt = Mt.dem;
                if (!Nt || !Nt.data || !Mt.needsHillshadePrepare) continue;
                const Ct = Nt.dim, sn = Nt.stride, nn = Nt.getPixels();
                if (Qe.activeTexture.set(wt.TEXTURE1), Qe.pixelStoreUnpackPremultiplyAlpha.set(!1), Mt.demTexture = Mt.demTexture || Ce.getTileTexture(sn), Mt.demTexture) {
                  const dn = Mt.demTexture;
                  dn.update(nn, { premultiply: !1 }), dn.bind(wt.NEAREST, wt.CLAMP_TO_EDGE);
                } else Mt.demTexture = new me(Qe, nn, wt.RGBA, { premultiply: !1 }), Mt.demTexture.bind(wt.NEAREST, wt.CLAMP_TO_EDGE);
                Qe.activeTexture.set(wt.TEXTURE0);
                let Gt = Mt.fbo;
                if (!Gt) {
                  const dn = new me(Qe, { width: Ct, height: Ct, data: null }, wt.RGBA);
                  dn.bind(wt.LINEAR, wt.CLAMP_TO_EDGE), Gt = Mt.fbo = Qe.createFramebuffer(Ct, Ct, !0, !1), Gt.colorAttachment.set(dn.texture);
                }
                Qe.bindFramebuffer.set(Gt.framebuffer), Qe.viewport.set([0, 0, Ct, Ct]), Ce.useProgram("hillshadePrepare").draw(Qe, wt.TRIANGLES, We, $e, Je, li.disabled, hs(Mt.tileID, Nt), null, null, He.id, Ce.rasterBoundsBuffer, Ce.quadTriangleIndexBuffer, Ce.rasterBoundsSegments), Mt.needsHillshadePrepare = !1;
              }
            })(E, L, N, B, ae, gi.disabled, Pe), $.viewport.set([0, 0, E.width, E.height]);
            else if (E.renderPass === "translucent") if (re) {
              const [Ce, Ie, Be] = E.stencilConfigForOverlapTwoPass(N);
              bh(E, L, B, Be, Ce, ae, Pe, !1, Z), bh(E, L, B, Be, Ie, ae, Pe, !0, Z);
            } else {
              const [Ce, Ie] = E.getStencilConfigForOverlapAndUpdateStencilID(N);
              bh(E, L, B, Ie, Ce, ae, Pe, !1, Z);
            }
          }(s, u, p, m, x) : a.c4(p) ? function(E, L, B, N, G) {
            if (E.renderPass !== "translucent" || B.paint.get("raster-opacity") === 0 || !N.length) return;
            const { isRenderingToTexture: Z } = G, $ = L.getSource(), re = E.style.projection.useSubdivision;
            if ($ instanceof ln) sr(E, L, B, N, null, !1, !1, $.tileCoords, $.flippedWindingOrder, Z);
            else if (re) {
              const [ae, Pe, Ce] = E.stencilConfigForOverlapTwoPass(N);
              sr(E, L, B, Ce, ae, !1, !0, fu, !1, Z), sr(E, L, B, Ce, Pe, !0, !0, fu, !1, Z);
            } else {
              const [ae, Pe] = E.getStencilConfigForOverlapAndUpdateStencilID(N);
              sr(E, L, B, Pe, ae, !1, !0, fu, !1, Z);
            }
          }(s, u, p, m, x) : a.c5(p) ? function(E, L, B, N, G) {
            const Z = B.paint.get("background-color"), $ = B.paint.get("background-opacity");
            if ($ === 0) return;
            const { isRenderingToTexture: re } = G, ae = E.context, Pe = ae.gl, Ce = E.style.projection, Ie = E.transform, Be = Ie.tileSize, He = B.paint.get("background-pattern");
            if (E.isPatternMissing(He)) return;
            const We = !He && Z.a === 1 && $ === 1 && E.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (E.renderPass !== We) return;
            const $e = gi.disabled, Je = E.getDepthModeForSublayer(0, We === "opaque" ? Kn.ReadWrite : Kn.ReadOnly), Qe = E.colorModeForRenderPass(), wt = E.useProgram(He ? "backgroundPattern" : "background"), bt = N || be(Ie, { tileSize: Be, terrain: E.style.map.terrain });
            He && (ae.activeTexture.set(Pe.TEXTURE0), E.imageManager.bind(E.context));
            const Mt = B.getCrossfadeParameters();
            for (const Nt of bt) {
              const Ct = Ie.getProjectionData({ overscaledTileID: Nt, applyGlobeMatrix: !re, applyTerrainMatrix: !0 }), sn = He ? ll($, E, He, { tileID: Nt, tileSize: Be }, Mt) : al($, Z), nn = E.style.map.terrain && E.style.map.terrain.getTerrainData(Nt), Gt = Ce.getMeshFromTileID(ae, Nt.canonical, !1, !0, "raster");
              wt.draw(ae, Pe.TRIANGLES, Je, $e, Qe, li.backCCW, sn, nn, Ct, B.id, Gt.vertexBuffer, Gt.indexBuffer, Gt.segments);
            }
          }(s, 0, p, m, x) : a.c6(p) && function(E, L, B, N) {
            const { isRenderingGlobe: G } = N, Z = E.context, $ = B.implementation, re = E.style.projection, ae = E.transform, Pe = ae.getProjectionDataForCustomLayer(G), Ce = { farZ: ae.farZ, nearZ: ae.nearZ, fov: ae.fov * Math.PI / 180, modelViewProjectionMatrix: ae.modelViewProjectionMatrix, projectionMatrix: ae.projectionMatrix, shaderData: { variantName: re.shaderVariantName, vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${re.shaderPreludeCode.vertexSource}`, define: re.shaderDefine }, defaultProjectionData: Pe }, Ie = $.renderingMode ? $.renderingMode : "2d";
            if (E.renderPass === "offscreen") {
              const Be = $.prerender;
              Be && (E.setCustomLayerDefaults(), Z.setColorMode(E.colorModeForRenderPass()), Be.call($, Z.gl, Ce), Z.setDirty(), E.setBaseState());
            } else if (E.renderPass === "translucent") {
              E.setCustomLayerDefaults(), Z.setColorMode(E.colorModeForRenderPass()), Z.setStencilMode(gi.disabled);
              const Be = Ie === "3d" ? E.getDepthModeFor3D() : E.getDepthModeForSublayer(0, Kn.ReadOnly);
              Z.setDepthMode(Be), $.render(Z.gl, Ce), Z.setDirty(), E.setBaseState(), Z.bindFramebuffer.set(null);
            }
          }(s, 0, p, x));
        }
        saveTileTexture(s) {
          const u = this._tileTextures[s.size[0]];
          u ? u.push(s) : this._tileTextures[s.size[0]] = [s];
        }
        getTileTexture(s) {
          const u = this._tileTextures[s];
          return u && u.length > 0 ? u.pop() : null;
        }
        isPatternMissing(s) {
          if (!s) return !1;
          if (!s.from || !s.to) return !0;
          const u = this.imageManager.getPattern(s.from.toString()), p = this.imageManager.getPattern(s.to.toString());
          return !u || !p;
        }
        useProgram(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
          this.cache = this.cache || {};
          const m = !!this.style.map.terrain, x = this.style.projection, E = s + (u ? u.cacheKey : "") + `/${p ? Ec : x.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (m ? "/terrain" : "");
          return this.cache[E] || (this.cache[E] = new te(this.context, nr[s], u, Mc[s], this._showOverdrawInspector, m, p ? nr.projectionMercator : x.shaderPreludeCode, p ? Ma : x.shaderDefine)), this.cache[E];
        }
        setCustomLayerDefaults() {
          this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
        }
        setBaseState() {
          const s = this.context.gl;
          this.context.cullFace.set(!1), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(s.FUNC_ADD);
        }
        initDebugOverlayCanvas() {
          this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new me(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
        }
        destroy() {
          this.debugOverlayTexture && this.debugOverlayTexture.destroy();
        }
        overLimit() {
          const { drawingBufferWidth: s, drawingBufferHeight: u } = this.context.gl;
          return this.width !== s || this.height !== u;
        }
      }
      function ml(b, s) {
        var u = this;
        let p, m = !1, x = null, E = null;
        const L = () => {
          x = null, m && (b.apply(E, p), x = setTimeout(L, s), m = !1);
        };
        return function() {
          for (var B = arguments.length, N = new Array(B), G = 0; G < B; G++)
            N[G] = arguments[G];
          return m = !0, E = u, p = N, x || L(), x;
        };
      }
      class ya {
        constructor(s) {
          this._getCurrentHash = () => {
            const u = window.location.hash.replace("#", "");
            if (this._hashName) {
              let p;
              return u.split("&").map((m) => m.split("=")).forEach((m) => {
                m[0] === this._hashName && (p = m);
              }), (p && p[1] || "").split("/");
            }
            return u.split("/");
          }, this._onHashChange = () => {
            const u = this._getCurrentHash();
            if (!this._isValidHash(u)) return !1;
            const p = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(u[3] || 0) : this._map.getBearing();
            return this._map.jumpTo({ center: [+u[2], +u[1]], zoom: +u[0], bearing: p, pitch: +(u[4] || 0) }), !0;
          }, this._updateHashUnthrottled = () => {
            const u = window.location.href.replace(/(#.*)?$/, this.getHashString());
            window.history.replaceState(window.history.state, null, u);
          }, this._removeHash = () => {
            const u = this._getCurrentHash();
            if (u.length === 0) return;
            const p = u.join("/");
            let m = p;
            m.split("&").length > 0 && (m = m.split("&")[0]), this._hashName && (m = `${this._hashName}=${p}`);
            let x = window.location.hash.replace(m, "");
            x.startsWith("#&") ? x = x.slice(0, 1) + x.slice(2) : x === "#" && (x = "");
            let E = window.location.href.replace(/(#.+)?$/, x);
            E = E.replace("&&", "&"), window.history.replaceState(window.history.state, null, E);
          }, this._updateHash = ml(this._updateHashUnthrottled, 300), this._hashName = s && encodeURIComponent(s);
        }
        addTo(s) {
          return this._map = s, addEventListener("hashchange", this._onHashChange, !1), this._map.on("moveend", this._updateHash), this;
        }
        remove() {
          return removeEventListener("hashchange", this._onHashChange, !1), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), this._removeHash(), delete this._map, this;
        }
        getHashString(s) {
          const u = this._map.getCenter(), p = Math.round(100 * this._map.getZoom()) / 100, m = Math.ceil((p * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), x = Math.pow(10, m), E = Math.round(u.lng * x) / x, L = Math.round(u.lat * x) / x, B = this._map.getBearing(), N = this._map.getPitch();
          let G = "";
          if (G += s ? `/${E}/${L}/${p}` : `${p}/${L}/${E}`, (B || N) && (G += "/" + Math.round(10 * B) / 10), N && (G += `/${Math.round(N)}`), this._hashName) {
            const Z = this._hashName;
            let $ = !1;
            const re = window.location.hash.slice(1).split("&").map((ae) => {
              const Pe = ae.split("=")[0];
              return Pe === Z ? ($ = !0, `${Pe}=${G}`) : ae;
            }).filter((ae) => ae);
            return $ || re.push(`${Z}=${G}`), `#${re.join("&")}`;
          }
          return `#${G}`;
        }
        _isValidHash(s) {
          if (s.length < 3 || s.some(isNaN)) return !1;
          try {
            new a.O(+s[2], +s[1]);
          } catch {
            return !1;
          }
          const u = +s[0], p = +(s[3] || 0), m = +(s[4] || 0);
          return u >= this._map.getMinZoom() && u <= this._map.getMaxZoom() && p >= -180 && p <= 180 && m >= this._map.getMinPitch() && m <= this._map.getMaxPitch();
        }
      }
      const Ts = { linearity: 0.3, easing: a.c7(0, 0, 0.3, 1) }, ba = a.e({ deceleration: 2500, maxSpeed: 1400 }, Ts), cd = a.e({ deceleration: 20, maxSpeed: 1400 }, Ts), Eh = a.e({ deceleration: 1e3, maxSpeed: 360 }, Ts), ja = a.e({ deceleration: 1e3, maxSpeed: 90 }, Ts), _o = a.e({ deceleration: 1e3, maxSpeed: 360 }, Ts);
      class qu {
        constructor(s) {
          this._map = s, this.clear();
        }
        clear() {
          this._inertiaBuffer = [];
        }
        record(s) {
          this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: I.now(), settings: s });
        }
        _drainInertiaBuffer() {
          const s = this._inertiaBuffer, u = I.now();
          for (; s.length > 0 && u - s[0].time > 160; ) s.shift();
        }
        _onMoveEnd(s) {
          if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
          const u = { zoom: 0, bearing: 0, pitch: 0, roll: 0, pan: new a.P(0, 0), pinchAround: void 0, around: void 0 };
          for (const { settings: x } of this._inertiaBuffer) u.zoom += x.zoomDelta || 0, u.bearing += x.bearingDelta || 0, u.pitch += x.pitchDelta || 0, u.roll += x.rollDelta || 0, x.panDelta && u.pan._add(x.panDelta), x.around && (u.around = x.around), x.pinchAround && (u.pinchAround = x.pinchAround);
          const p = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, m = {};
          if (u.pan.mag()) {
            const x = Es(u.pan.mag(), p, a.e({}, ba, s || {})), E = u.pan.mult(x.amount / u.pan.mag()), L = this._map.cameraHelper.handlePanInertia(E, this._map.transform);
            m.center = L.easingCenter, m.offset = L.easingOffset, Fc(m, x);
          }
          if (u.zoom) {
            const x = Es(u.zoom, p, cd);
            m.zoom = this._map.transform.zoom + x.amount, Fc(m, x);
          }
          if (u.bearing) {
            const x = Es(u.bearing, p, Eh);
            m.bearing = this._map.transform.bearing + a.ac(x.amount, -179, 179), Fc(m, x);
          }
          if (u.pitch) {
            const x = Es(u.pitch, p, ja);
            m.pitch = this._map.transform.pitch + x.amount, Fc(m, x);
          }
          if (u.roll) {
            const x = Es(u.roll, p, _o);
            m.roll = this._map.transform.roll + a.ac(x.amount, -179, 179), Fc(m, x);
          }
          if (m.zoom || m.bearing) {
            const x = u.pinchAround === void 0 ? u.around : u.pinchAround;
            m.around = x ? this._map.unproject(x) : this._map.getCenter();
          }
          return this.clear(), a.e(m, { noMoveStart: !0 });
        }
      }
      function Fc(b, s) {
        (!b.duration || b.duration < s.duration) && (b.duration = s.duration, b.easing = s.easing);
      }
      function Es(b, s, u) {
        const { maxSpeed: p, linearity: m, deceleration: x } = u, E = a.ac(b * m / (s / 1e3), -p, p), L = Math.abs(E) / (x * m);
        return { easing: u.easing, duration: 1e3 * L, amount: E * (L / 2) };
      }
      class pr extends a.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(s, u, p) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          const x = S.mousePos(u.getCanvas(), p), E = u.unproject(x);
          super(s, a.e({ point: x, lngLat: E, originalEvent: p }, m)), this._defaultPrevented = !1, this.target = u;
        }
      }
      class ec extends a.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(s, u, p) {
          const m = s === "touchend" ? p.changedTouches : p.touches, x = S.touchPos(u.getCanvasContainer(), m), E = x.map((B) => u.unproject(B)), L = x.reduce((B, N, G, Z) => B.add(N.div(Z.length)), new a.P(0, 0));
          super(s, { points: x, point: L, lngLats: E, lngLat: u.unproject(L), originalEvent: p }), this._defaultPrevented = !1;
        }
      }
      class Bo extends a.k {
        preventDefault() {
          this._defaultPrevented = !0;
        }
        get defaultPrevented() {
          return this._defaultPrevented;
        }
        constructor(s, u, p) {
          super(s, { originalEvent: p }), this._defaultPrevented = !1;
        }
      }
      class Nc {
        constructor(s, u) {
          this._map = s, this._clickTolerance = u.clickTolerance;
        }
        reset() {
          delete this._mousedownPos;
        }
        wheel(s) {
          return this._firePreventable(new Bo(s.type, this._map, s));
        }
        mousedown(s, u) {
          return this._mousedownPos = u, this._firePreventable(new pr(s.type, this._map, s));
        }
        mouseup(s) {
          this._map.fire(new pr(s.type, this._map, s));
        }
        click(s, u) {
          this._mousedownPos && this._mousedownPos.dist(u) >= this._clickTolerance || this._map.fire(new pr(s.type, this._map, s));
        }
        dblclick(s) {
          return this._firePreventable(new pr(s.type, this._map, s));
        }
        mouseover(s) {
          this._map.fire(new pr(s.type, this._map, s));
        }
        mouseout(s) {
          this._map.fire(new pr(s.type, this._map, s));
        }
        touchstart(s) {
          return this._firePreventable(new ec(s.type, this._map, s));
        }
        touchmove(s) {
          this._map.fire(new ec(s.type, this._map, s));
        }
        touchend(s) {
          this._map.fire(new ec(s.type, this._map, s));
        }
        touchcancel(s) {
          this._map.fire(new ec(s.type, this._map, s));
        }
        _firePreventable(s) {
          if (this._map.fire(s), s.defaultPrevented) return {};
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class Hu {
        constructor(s) {
          this._map = s;
        }
        reset() {
          this._delayContextMenu = !1, this._ignoreContextMenu = !0, delete this._contextMenuEvent;
        }
        mousemove(s) {
          this._map.fire(new pr(s.type, this._map, s));
        }
        mousedown() {
          this._delayContextMenu = !0, this._ignoreContextMenu = !1;
        }
        mouseup() {
          this._delayContextMenu = !1, this._contextMenuEvent && (this._map.fire(new pr("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
        }
        contextmenu(s) {
          this._delayContextMenu ? this._contextMenuEvent = s : this._ignoreContextMenu || this._map.fire(new pr(s.type, this._map, s)), this._map.listens("contextmenu") && s.preventDefault();
        }
        isEnabled() {
          return !0;
        }
        isActive() {
          return !1;
        }
        enable() {
        }
        disable() {
        }
      }
      class _l {
        constructor(s) {
          this._map = s;
        }
        get transform() {
          return this._map._requestedCameraState || this._map.transform;
        }
        get center() {
          return { lng: this.transform.center.lng, lat: this.transform.center.lat };
        }
        get zoom() {
          return this.transform.zoom;
        }
        get pitch() {
          return this.transform.pitch;
        }
        get bearing() {
          return this.transform.bearing;
        }
        unproject(s) {
          return this.transform.screenPointToLocation(a.P.convert(s), this._map.terrain);
        }
      }
      class kc {
        constructor(s, u) {
          this._map = s, this._tr = new _l(s), this._el = s.getCanvasContainer(), this._container = s.getContainer(), this._clickTolerance = u.clickTolerance || 1;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
        enable() {
          this.isEnabled() || (this._enabled = !0);
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        mousedown(s, u) {
          this.isEnabled() && s.shiftKey && s.button === 0 && (S.disableDrag(), this._startPos = this._lastPos = u, this._active = !0);
        }
        mousemoveWindow(s, u) {
          if (!this._active) return;
          const p = u;
          if (this._lastPos.equals(p) || !this._box && p.dist(this._startPos) < this._clickTolerance) return;
          const m = this._startPos;
          this._lastPos = p, this._box || (this._box = S.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", s));
          const x = Math.min(m.x, p.x), E = Math.max(m.x, p.x), L = Math.min(m.y, p.y), B = Math.max(m.y, p.y);
          S.setTransform(this._box, `translate(${x}px,${L}px)`), this._box.style.width = E - x + "px", this._box.style.height = B - L + "px";
        }
        mouseupWindow(s, u) {
          if (!this._active || s.button !== 0) return;
          const p = this._startPos, m = u;
          if (this.reset(), S.suppressClick(), p.x !== m.x || p.y !== m.y) return this._map.fire(new a.k("boxzoomend", { originalEvent: s })), { cameraAnimation: (x) => x.fitScreenCoordinates(p, m, this._tr.bearing, { linear: !0 }) };
          this._fireEvent("boxzoomcancel", s);
        }
        keydown(s) {
          this._active && s.keyCode === 27 && (this.reset(), this._fireEvent("boxzoomcancel", s));
        }
        reset() {
          this._active = !1, this._container.classList.remove("maplibregl-crosshair"), this._box && (S.remove(this._box), this._box = null), S.enableDrag(), delete this._startPos, delete this._lastPos;
        }
        _fireEvent(s, u) {
          return this._map.fire(new a.k(s, { originalEvent: u }));
        }
      }
      function gu(b, s) {
        if (b.length !== s.length) throw new Error(`The number of touches and points are not equal - touches ${b.length}, points ${s.length}`);
        const u = {};
        for (let p = 0; p < b.length; p++) u[b[p].identifier] = s[p];
        return u;
      }
      class ud {
        constructor(s) {
          this.reset(), this.numTouches = s.numTouches;
        }
        reset() {
          delete this.centroid, delete this.startTime, delete this.touches, this.aborted = !1;
        }
        touchstart(s, u, p) {
          (this.centroid || p.length > this.numTouches) && (this.aborted = !0), this.aborted || (this.startTime === void 0 && (this.startTime = s.timeStamp), p.length === this.numTouches && (this.centroid = function(m) {
            const x = new a.P(0, 0);
            for (const E of m) x._add(E);
            return x.div(m.length);
          }(u), this.touches = gu(p, u)));
        }
        touchmove(s, u, p) {
          if (this.aborted || !this.centroid) return;
          const m = gu(p, u);
          for (const x in this.touches) {
            const E = m[x];
            (!E || E.dist(this.touches[x]) > 30) && (this.aborted = !0);
          }
        }
        touchend(s, u, p) {
          if ((!this.centroid || s.timeStamp - this.startTime > 500) && (this.aborted = !0), p.length === 0) {
            const m = !this.aborted && this.centroid;
            if (this.reset(), m) return m;
          }
        }
      }
      class yl {
        constructor(s) {
          this.singleTap = new ud(s), this.numTaps = s.numTaps, this.reset();
        }
        reset() {
          this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
        }
        touchstart(s, u, p) {
          this.singleTap.touchstart(s, u, p);
        }
        touchmove(s, u, p) {
          this.singleTap.touchmove(s, u, p);
        }
        touchend(s, u, p) {
          const m = this.singleTap.touchend(s, u, p);
          if (m) {
            const x = s.timeStamp - this.lastTime < 500, E = !this.lastTap || this.lastTap.dist(m) < 30;
            if (x && E || this.reset(), this.count++, this.lastTime = s.timeStamp, this.lastTap = m, this.count === this.numTaps) return this.reset(), m;
          }
        }
      }
      class Ga {
        constructor(s) {
          this._tr = new _l(s), this._zoomIn = new yl({ numTouches: 1, numTaps: 2 }), this._zoomOut = new yl({ numTouches: 2, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, this._zoomIn.reset(), this._zoomOut.reset();
        }
        touchstart(s, u, p) {
          this._zoomIn.touchstart(s, u, p), this._zoomOut.touchstart(s, u, p);
        }
        touchmove(s, u, p) {
          this._zoomIn.touchmove(s, u, p), this._zoomOut.touchmove(s, u, p);
        }
        touchend(s, u, p) {
          const m = this._zoomIn.touchend(s, u, p), x = this._zoomOut.touchend(s, u, p), E = this._tr;
          return m ? (this._active = !0, s.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (L) => L.easeTo({ duration: 300, zoom: E.zoom + 1, around: E.unproject(m) }, { originalEvent: s }) }) : x ? (this._active = !0, s.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (L) => L.easeTo({ duration: 300, zoom: E.zoom - 1, around: E.unproject(x) }, { originalEvent: s }) }) : void 0;
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class vn {
        constructor(s) {
          this._enabled = !!s.enable, this._moveStateManager = s.moveStateManager, this._clickTolerance = s.clickTolerance || 1, this._moveFunction = s.move, this._activateOnStart = !!s.activateOnStart, s.assignEvents(this), this.reset();
        }
        reset(s) {
          this._active = !1, this._moved = !1, delete this._lastPoint, this._moveStateManager.endMove(s);
        }
        _move() {
          const s = this._moveFunction(...arguments);
          if (s.bearingDelta || s.pitchDelta || s.rollDelta || s.around || s.panDelta) return this._active = !0, s;
        }
        dragStart(s, u) {
          this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(s) && (this._moveStateManager.startMove(s), this._lastPoint = Array.isArray(u) ? u[0] : u, this._activateOnStart && this._lastPoint && (this._active = !0));
        }
        dragMove(s, u) {
          if (!this.isEnabled()) return;
          const p = this._lastPoint;
          if (!p) return;
          if (s.preventDefault(), !this._moveStateManager.isValidMoveEvent(s)) return void this.reset(s);
          const m = Array.isArray(u) ? u[0] : u;
          return !this._moved && m.dist(p) < this._clickTolerance ? void 0 : (this._moved = !0, this._lastPoint = m, this._move(p, m));
        }
        dragEnd(s) {
          this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(s) && (this._moved && S.suppressClick(), this.reset(s));
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        getClickTolerance() {
          return this._clickTolerance;
        }
      }
      const hd = { 0: 1, 2: 2 };
      class tc {
        constructor(s) {
          this._correctEvent = s.checkCorrectEvent;
        }
        startMove(s) {
          const u = S.mouseButton(s);
          this._eventButton = u;
        }
        endMove(s) {
          delete this._eventButton;
        }
        isValidStartEvent(s) {
          return this._correctEvent(s);
        }
        isValidMoveEvent(s) {
          return !function(u, p) {
            const m = hd[p];
            return u.buttons === void 0 || (u.buttons & m) !== m;
          }(s, this._eventButton);
        }
        isValidEndEvent(s) {
          return S.mouseButton(s) === this._eventButton;
        }
      }
      class dd {
        constructor() {
          this._firstTouch = void 0;
        }
        _isOneFingerTouch(s) {
          return s.targetTouches.length === 1;
        }
        _isSameTouchEvent(s) {
          return s.targetTouches[0].identifier === this._firstTouch;
        }
        startMove(s) {
          this._firstTouch = s.targetTouches[0].identifier;
        }
        endMove(s) {
          delete this._firstTouch;
        }
        isValidStartEvent(s) {
          return this._isOneFingerTouch(s);
        }
        isValidMoveEvent(s) {
          return this._isOneFingerTouch(s) && this._isSameTouchEvent(s);
        }
        isValidEndEvent(s) {
          return this._isOneFingerTouch(s) && this._isSameTouchEvent(s);
        }
      }
      class mu {
        constructor() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new tc({ checkCorrectEvent: () => !0 }), u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new dd();
          this.mouseMoveStateManager = s, this.oneFingerTouchMoveStateManager = u;
        }
        _executeRelevantHandler(s, u, p) {
          return s instanceof MouseEvent ? u(s) : typeof TouchEvent < "u" && s instanceof TouchEvent ? p(s) : void 0;
        }
        startMove(s) {
          this._executeRelevantHandler(s, (u) => this.mouseMoveStateManager.startMove(u), (u) => this.oneFingerTouchMoveStateManager.startMove(u));
        }
        endMove(s) {
          this._executeRelevantHandler(s, (u) => this.mouseMoveStateManager.endMove(u), (u) => this.oneFingerTouchMoveStateManager.endMove(u));
        }
        isValidStartEvent(s) {
          return this._executeRelevantHandler(s, (u) => this.mouseMoveStateManager.isValidStartEvent(u), (u) => this.oneFingerTouchMoveStateManager.isValidStartEvent(u));
        }
        isValidMoveEvent(s) {
          return this._executeRelevantHandler(s, (u) => this.mouseMoveStateManager.isValidMoveEvent(u), (u) => this.oneFingerTouchMoveStateManager.isValidMoveEvent(u));
        }
        isValidEndEvent(s) {
          return this._executeRelevantHandler(s, (u) => this.mouseMoveStateManager.isValidEndEvent(u), (u) => this.oneFingerTouchMoveStateManager.isValidEndEvent(u));
        }
      }
      const Va = (b) => {
        b.mousedown = b.dragStart, b.mousemoveWindow = b.dragMove, b.mouseup = b.dragEnd, b.contextmenu = (s) => {
          s.preventDefault();
        };
      };
      class _u {
        constructor(s, u) {
          this._clickTolerance = s.clickTolerance || 1, this._map = u, this.reset();
        }
        reset() {
          this._active = !1, this._touches = {}, this._sum = new a.P(0, 0);
        }
        _shouldBePrevented(s) {
          return s < (this._map.cooperativeGestures.isEnabled() ? 2 : 1);
        }
        touchstart(s, u, p) {
          return this._calculateTransform(s, u, p);
        }
        touchmove(s, u, p) {
          if (this._active) {
            if (!this._shouldBePrevented(p.length)) return s.preventDefault(), this._calculateTransform(s, u, p);
            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", s);
          }
        }
        touchend(s, u, p) {
          this._calculateTransform(s, u, p), this._active && this._shouldBePrevented(p.length) && this.reset();
        }
        touchcancel() {
          this.reset();
        }
        _calculateTransform(s, u, p) {
          p.length > 0 && (this._active = !0);
          const m = gu(p, u), x = new a.P(0, 0), E = new a.P(0, 0);
          let L = 0;
          for (const N in m) {
            const G = m[N], Z = this._touches[N];
            Z && (x._add(G), E._add(G.sub(Z)), L++, m[N] = G);
          }
          if (this._touches = m, this._shouldBePrevented(L) || !E.mag()) return;
          const B = E.div(L);
          return this._sum._add(B), this._sum.mag() < this._clickTolerance ? void 0 : { around: x.div(L), panDelta: B };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ci {
        constructor() {
          this.reset();
        }
        reset() {
          this._active = !1, delete this._firstTwoTouches;
        }
        touchstart(s, u, p) {
          this._firstTwoTouches || p.length < 2 || (this._firstTwoTouches = [p[0].identifier, p[1].identifier], this._start([u[0], u[1]]));
        }
        touchmove(s, u, p) {
          if (!this._firstTwoTouches) return;
          s.preventDefault();
          const [m, x] = this._firstTwoTouches, E = zc(p, u, m), L = zc(p, u, x);
          if (!E || !L) return;
          const B = this._aroundCenter ? null : E.add(L).div(2);
          return this._move([E, L], B, s);
        }
        touchend(s, u, p) {
          if (!this._firstTwoTouches) return;
          const [m, x] = this._firstTwoTouches, E = zc(p, u, m), L = zc(p, u, x);
          E && L || (this._active && S.suppressClick(), this.reset());
        }
        touchcancel() {
          this.reset();
        }
        enable(s) {
          this._enabled = !0, this._aroundCenter = !!s && s.around === "center";
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active;
        }
      }
      function zc(b, s, u) {
        for (let p = 0; p < b.length; p++) if (b[p].identifier === u) return s[p];
      }
      function Sh(b, s) {
        return Math.log(b / s) / Math.LN2;
      }
      class T extends ci {
        reset() {
          super.reset(), delete this._distance, delete this._startDistance;
        }
        _start(s) {
          this._startDistance = this._distance = s[0].dist(s[1]);
        }
        _move(s, u) {
          const p = this._distance;
          if (this._distance = s[0].dist(s[1]), this._active || !(Math.abs(Sh(this._distance, this._startDistance)) < 0.1)) return this._active = !0, { zoomDelta: Sh(this._distance, p), pinchAround: u };
        }
      }
      function M(b, s) {
        return 180 * b.angleWith(s) / Math.PI;
      }
      class k extends ci {
        reset() {
          super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
        }
        _start(s) {
          this._startVector = this._vector = s[0].sub(s[1]), this._minDiameter = s[0].dist(s[1]);
        }
        _move(s, u, p) {
          const m = this._vector;
          if (this._vector = s[0].sub(s[1]), this._active || !this._isBelowThreshold(this._vector)) return this._active = !0, { bearingDelta: M(this._vector, m), pinchAround: u };
        }
        _isBelowThreshold(s) {
          this._minDiameter = Math.min(this._minDiameter, s.mag());
          const u = 25 / (Math.PI * this._minDiameter) * 360, p = M(s, this._startVector);
          return Math.abs(p) < u;
        }
      }
      function q(b) {
        return Math.abs(b.y) > Math.abs(b.x);
      }
      class ee extends ci {
        constructor(s) {
          super(), this._currentTouchCount = 0, this._map = s;
        }
        reset() {
          super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
        }
        touchstart(s, u, p) {
          super.touchstart(s, u, p), this._currentTouchCount = p.length;
        }
        _start(s) {
          this._lastPoints = s, q(s[0].sub(s[1])) && (this._valid = !1);
        }
        _move(s, u, p) {
          if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3) return;
          const m = s[0].sub(this._lastPoints[0]), x = s[1].sub(this._lastPoints[1]);
          return this._valid = this.gestureBeginsVertically(m, x, p.timeStamp), this._valid ? (this._lastPoints = s, this._active = !0, { pitchDelta: (m.y + x.y) / 2 * -0.5 }) : void 0;
        }
        gestureBeginsVertically(s, u, p) {
          if (this._valid !== void 0) return this._valid;
          const m = s.mag() >= 2, x = u.mag() >= 2;
          if (!m && !x) return;
          if (!m || !x) return this._firstMove === void 0 && (this._firstMove = p), p - this._firstMove < 100 && void 0;
          const E = s.y > 0 == u.y > 0;
          return q(s) && q(u) && E;
        }
      }
      const le = { panStep: 100, bearingStep: 15, pitchStep: 10 };
      class he {
        constructor(s) {
          this._tr = new _l(s);
          const u = le;
          this._panStep = u.panStep, this._bearingStep = u.bearingStep, this._pitchStep = u.pitchStep, this._rotationDisabled = !1;
        }
        reset() {
          this._active = !1;
        }
        keydown(s) {
          if (s.altKey || s.ctrlKey || s.metaKey) return;
          let u = 0, p = 0, m = 0, x = 0, E = 0;
          switch (s.keyCode) {
            case 61:
            case 107:
            case 171:
            case 187:
              u = 1;
              break;
            case 189:
            case 109:
            case 173:
              u = -1;
              break;
            case 37:
              s.shiftKey ? p = -1 : (s.preventDefault(), x = -1);
              break;
            case 39:
              s.shiftKey ? p = 1 : (s.preventDefault(), x = 1);
              break;
            case 38:
              s.shiftKey ? m = 1 : (s.preventDefault(), E = -1);
              break;
            case 40:
              s.shiftKey ? m = -1 : (s.preventDefault(), E = 1);
              break;
            default:
              return;
          }
          return this._rotationDisabled && (p = 0, m = 0), { cameraAnimation: (L) => {
            const B = this._tr;
            L.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ye, zoom: u ? Math.round(B.zoom) + u * (s.shiftKey ? 2 : 1) : B.zoom, bearing: B.bearing + p * this._bearingStep, pitch: B.pitch + m * this._pitchStep, offset: [-x * this._panStep, -E * this._panStep], center: B.center }, { originalEvent: s });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
        disableRotation() {
          this._rotationDisabled = !0;
        }
        enableRotation() {
          this._rotationDisabled = !1;
        }
      }
      function ye(b) {
        return b * (2 - b);
      }
      const xe = 4.000244140625;
      class Le {
        constructor(s, u) {
          this._onTimeout = (p) => {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(p);
          }, this._map = s, this._tr = new _l(s), this._triggerRenderFrame = u, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
        }
        setZoomRate(s) {
          this._defaultZoomRate = s;
        }
        setWheelZoomRate(s) {
          this._wheelZoomRate = s;
        }
        isEnabled() {
          return !!this._enabled;
        }
        isActive() {
          return !!this._active || this._finishTimeout !== void 0;
        }
        isZooming() {
          return !!this._zooming;
        }
        enable(s) {
          this.isEnabled() || (this._enabled = !0, this._aroundCenter = !!s && s.around === "center");
        }
        disable() {
          this.isEnabled() && (this._enabled = !1);
        }
        _shouldBePrevented(s) {
          return !!this._map.cooperativeGestures.isEnabled() && !(s.ctrlKey || this._map.cooperativeGestures.isBypassed(s));
        }
        wheel(s) {
          if (!this.isEnabled()) return;
          if (this._shouldBePrevented(s)) return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", s);
          let u = s.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * s.deltaY : s.deltaY;
          const p = I.now(), m = p - (this._lastWheelEventTime || 0);
          this._lastWheelEventTime = p, u !== 0 && u % xe == 0 ? this._type = "wheel" : u !== 0 && Math.abs(u) < 4 ? this._type = "trackpad" : m > 400 ? (this._type = null, this._lastValue = u, this._timeout = setTimeout(this._onTimeout, 40, s)) : this._type || (this._type = Math.abs(m * u) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, u += this._lastValue)), s.shiftKey && u && (u /= 4), this._type && (this._lastWheelEvent = s, this._delta -= u, this._active || this._start(s)), s.preventDefault();
        }
        _start(s) {
          if (!this._delta) return;
          this._frameId && (this._frameId = null), this._active = !0, this.isZooming() || (this._zooming = !0), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
          const u = S.mousePos(this._map.getCanvas(), s), p = this._tr;
          this._aroundPoint = this._aroundCenter ? p.transform.locationToScreenPoint(a.O.convert(p.center)) : u, this._frameId || (this._frameId = !0, this._triggerRenderFrame());
        }
        renderFrame() {
          if (!this._frameId || (this._frameId = null, !this.isActive())) return;
          const s = this._tr.transform;
          if (typeof this._lastExpectedZoom == "number") {
            const L = s.zoom - this._lastExpectedZoom;
            typeof this._startZoom == "number" && (this._startZoom += L), typeof this._targetZoom == "number" && (this._targetZoom += L);
          }
          if (this._delta !== 0) {
            const L = this._type === "wheel" && Math.abs(this._delta) > xe ? this._wheelZoomRate : this._defaultZoomRate;
            let B = 2 / (1 + Math.exp(-Math.abs(this._delta * L)));
            this._delta < 0 && B !== 0 && (B = 1 / B);
            const N = typeof this._targetZoom != "number" ? s.scale : a.aG(this._targetZoom);
            this._targetZoom = Math.min(s.maxZoom, Math.max(s.minZoom, a.a9(N * B))), this._type === "wheel" && (this._startZoom = s.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
          }
          const u = typeof this._targetZoom != "number" ? s.zoom : this._targetZoom, p = this._startZoom, m = this._easing;
          let x, E = !1;
          if (this._type === "wheel" && p && m) {
            const L = I.now() - this._lastWheelEventTime, B = Math.min((L + 5) / 200, 1), N = m(B);
            x = a.z.number(p, u, N), B < 1 ? this._frameId || (this._frameId = !0) : E = !0;
          } else x = u, E = !0;
          return this._active = !0, E && (this._active = !1, this._finishTimeout = setTimeout(() => {
            this._zooming = !1, this._triggerRenderFrame(), delete this._targetZoom, delete this._lastExpectedZoom, delete this._finishTimeout;
          }, 200)), this._lastExpectedZoom = x, { noInertia: !0, needsRenderFrame: !E, zoomDelta: x - s.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
        }
        _smoothOutEasing(s) {
          let u = a.c9;
          if (this._prevEase) {
            const p = this._prevEase, m = (I.now() - p.start) / p.duration, x = p.easing(m + 0.01) - p.easing(m), E = 0.27 / Math.sqrt(x * x + 1e-4) * 0.01, L = Math.sqrt(0.0729 - E * E);
            u = a.c7(E, L, 0.25, 1);
          }
          return this._prevEase = { start: I.now(), duration: s, easing: u }, u;
        }
        reset() {
          this._active = !1, this._zooming = !1, delete this._targetZoom, delete this._lastExpectedZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
        }
      }
      class tt {
        constructor(s, u) {
          this._clickZoom = s, this._tapZoom = u;
        }
        enable() {
          this._clickZoom.enable(), this._tapZoom.enable();
        }
        disable() {
          this._clickZoom.disable(), this._tapZoom.disable();
        }
        isEnabled() {
          return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
        }
        isActive() {
          return this._clickZoom.isActive() || this._tapZoom.isActive();
        }
      }
      class ut {
        constructor(s) {
          this._tr = new _l(s), this.reset();
        }
        reset() {
          this._active = !1;
        }
        dblclick(s, u) {
          return s.preventDefault(), { cameraAnimation: (p) => {
            p.easeTo({ duration: 300, zoom: this._tr.zoom + (s.shiftKey ? -1 : 1), around: this._tr.unproject(u) }, { originalEvent: s });
          } };
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class At {
        constructor() {
          this._tap = new yl({ numTouches: 1, numTaps: 1 }), this.reset();
        }
        reset() {
          this._active = !1, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
        }
        touchstart(s, u, p) {
          if (!this._swipePoint) if (this._tapTime) {
            const m = u[0], x = s.timeStamp - this._tapTime < 500, E = this._tapPoint.dist(m) < 30;
            x && E ? p.length > 0 && (this._swipePoint = m, this._swipeTouch = p[0].identifier) : this.reset();
          } else this._tap.touchstart(s, u, p);
        }
        touchmove(s, u, p) {
          if (this._tapTime) {
            if (this._swipePoint) {
              if (p[0].identifier !== this._swipeTouch) return;
              const m = u[0], x = m.y - this._swipePoint.y;
              return this._swipePoint = m, s.preventDefault(), this._active = !0, { zoomDelta: x / 128 };
            }
          } else this._tap.touchmove(s, u, p);
        }
        touchend(s, u, p) {
          if (this._tapTime) this._swipePoint && p.length === 0 && this.reset();
          else {
            const m = this._tap.touchend(s, u, p);
            m && (this._tapTime = s.timeStamp, this._tapPoint = m);
          }
        }
        touchcancel() {
          this.reset();
        }
        enable() {
          this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this.reset();
        }
        isEnabled() {
          return this._enabled;
        }
        isActive() {
          return this._active;
        }
      }
      class ct {
        constructor(s, u, p) {
          this._el = s, this._mousePan = u, this._touchPan = p;
        }
        enable(s) {
          this._inertiaOptions = s || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
        }
        disable() {
          this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
        }
        isEnabled() {
          return this._mousePan.isEnabled() && this._touchPan.isEnabled();
        }
        isActive() {
          return this._mousePan.isActive() || this._touchPan.isActive();
        }
      }
      class qt {
        constructor(s, u, p, m) {
          this._pitchWithRotate = s.pitchWithRotate, this._rollEnabled = s.rollEnabled, this._mouseRotate = u, this._mousePitch = p, this._mouseRoll = m;
        }
        enable() {
          this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable(), this._rollEnabled && this._mouseRoll.enable();
        }
        disable() {
          this._mouseRotate.disable(), this._mousePitch.disable(), this._mouseRoll.disable();
        }
        isEnabled() {
          return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled());
        }
        isActive() {
          return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive();
        }
      }
      class Ot {
        constructor(s, u, p, m) {
          this._el = s, this._touchZoom = u, this._touchRotate = p, this._tapDragZoom = m, this._rotationDisabled = !1, this._enabled = !0;
        }
        enable(s) {
          this._touchZoom.enable(s), this._rotationDisabled || this._touchRotate.enable(s), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
        }
        disable() {
          this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
        }
        isEnabled() {
          return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
        }
        isActive() {
          return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
        }
        disableRotation() {
          this._rotationDisabled = !0, this._touchRotate.disable();
        }
        enableRotation() {
          this._rotationDisabled = !1, this._touchZoom.isEnabled() && this._touchRotate.enable();
        }
      }
      class nt {
        constructor(s, u) {
          this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey", this._map = s, this._options = u, this._enabled = !1;
        }
        isActive() {
          return !1;
        }
        reset() {
        }
        _setupUI() {
          if (this._container) return;
          const s = this._map.getCanvasContainer();
          s.classList.add("maplibregl-cooperative-gestures"), this._container = S.create("div", "maplibregl-cooperative-gesture-screen", s);
          let u = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
          this._bypassKey === "metaKey" && (u = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
          const p = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText"), m = document.createElement("div");
          m.className = "maplibregl-desktop-message", m.textContent = u, this._container.appendChild(m);
          const x = document.createElement("div");
          x.className = "maplibregl-mobile-message", x.textContent = p, this._container.appendChild(x), this._container.setAttribute("aria-hidden", "true");
        }
        _destroyUI() {
          this._container && (S.remove(this._container), this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")), delete this._container;
        }
        enable() {
          this._setupUI(), this._enabled = !0;
        }
        disable() {
          this._enabled = !1, this._destroyUI();
        }
        isEnabled() {
          return this._enabled;
        }
        isBypassed(s) {
          return s[this._bypassKey];
        }
        notifyGestureBlocked(s, u) {
          this._enabled && (this._map.fire(new a.k("cooperativegestureprevented", { gestureType: s, originalEvent: u })), this._container.classList.add("maplibregl-show"), setTimeout(() => {
            this._container.classList.remove("maplibregl-show");
          }, 100));
        }
      }
      const st = (b) => b.zoom || b.drag || b.roll || b.pitch || b.rotate;
      class jt extends a.k {
      }
      function Zt(b) {
        return b.panDelta && b.panDelta.mag() || b.zoomDelta || b.bearingDelta || b.pitchDelta || b.rollDelta;
      }
      class ft {
        constructor(s, u) {
          this.handleWindowEvent = (m) => {
            this.handleEvent(m, `${m.type}Window`);
          }, this.handleEvent = (m, x) => {
            if (m.type === "blur") return void this.stop(!0);
            this._updatingCamera = !0;
            const E = m.type === "renderFrame" ? void 0 : m, L = { needsRenderFrame: !1 }, B = {}, N = {}, G = m.touches, Z = G ? this._getMapTouches(G) : void 0, $ = Z ? S.touchPos(this._map.getCanvas(), Z) : S.mousePos(this._map.getCanvas(), m);
            for (const { handlerName: Pe, handler: Ce, allowed: Ie } of this._handlers) {
              if (!Ce.isEnabled()) continue;
              let Be;
              this._blockedByActive(N, Ie, Pe) ? Ce.reset() : Ce[x || m.type] && (Be = Ce[x || m.type](m, $, Z), this.mergeHandlerResult(L, B, Be, Pe, E), Be && Be.needsRenderFrame && this._triggerRenderFrame()), (Be || Ce.isActive()) && (N[Pe] = Ce);
            }
            const re = {};
            for (const Pe in this._previousActiveHandlers) N[Pe] || (re[Pe] = E);
            this._previousActiveHandlers = N, (Object.keys(re).length || Zt(L)) && (this._changes.push([L, B, re]), this._triggerRenderFrame()), (Object.keys(N).length || Zt(L)) && this._map._stop(!0), this._updatingCamera = !1;
            const { cameraAnimation: ae } = L;
            ae && (this._inertia.clear(), this._fireEvents({}, {}, !0), this._changes = [], ae(this._map));
          }, this._map = s, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new qu(s), this._bearingSnap = u.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(u);
          const p = this._el;
          this._listeners = [[p, "touchstart", { passive: !0 }], [p, "touchmove", { passive: !1 }], [p, "touchend", void 0], [p, "touchcancel", void 0], [p, "mousedown", void 0], [p, "mousemove", void 0], [p, "mouseup", void 0], [document, "mousemove", { capture: !0 }], [document, "mouseup", void 0], [p, "mouseover", void 0], [p, "mouseout", void 0], [p, "dblclick", void 0], [p, "click", void 0], [p, "keydown", { capture: !1 }], [p, "keyup", void 0], [p, "wheel", { passive: !1 }], [p, "contextmenu", void 0], [window, "blur", void 0]];
          for (const [m, x, E] of this._listeners) S.addEventListener(m, x, m === document ? this.handleWindowEvent : this.handleEvent, E);
        }
        destroy() {
          for (const [s, u, p] of this._listeners) S.removeEventListener(s, u, s === document ? this.handleWindowEvent : this.handleEvent, p);
        }
        _addDefaultHandlers(s) {
          const u = this._map, p = u.getCanvasContainer();
          this._add("mapEvent", new Nc(u, s));
          const m = u.boxZoom = new kc(u, s);
          this._add("boxZoom", m), s.interactive && s.boxZoom && m.enable();
          const x = u.cooperativeGestures = new nt(u, s.cooperativeGestures);
          this._add("cooperativeGestures", x), s.cooperativeGestures && x.enable();
          const E = new Ga(u), L = new ut(u);
          u.doubleClickZoom = new tt(L, E), this._add("tapZoom", E), this._add("clickZoom", L), s.interactive && s.doubleClickZoom && u.doubleClickZoom.enable();
          const B = new At();
          this._add("tapDragZoom", B);
          const N = u.touchPitch = new ee(u);
          this._add("touchPitch", N), s.interactive && s.touchPitch && u.touchPitch.enable(s.touchPitch);
          const G = () => u.project(u.getCenter()), Z = function(We, $e) {
            let { enable: Je, clickTolerance: Qe, aroundCenter: wt = !0, minPixelCenterThreshold: bt = 100, rotateDegreesPerPixelMoved: Mt = 0.8 } = We;
            const Nt = new tc({ checkCorrectEvent: (Ct) => S.mouseButton(Ct) === 0 && Ct.ctrlKey || S.mouseButton(Ct) === 2 && !Ct.ctrlKey });
            return new vn({ clickTolerance: Qe, move: (Ct, sn) => {
              const nn = $e();
              if (wt && Math.abs(nn.y - Ct.y) > bt) return { bearingDelta: a.c8(new a.P(Ct.x, sn.y), sn, nn) };
              let Gt = (sn.x - Ct.x) * Mt;
              return wt && sn.y < nn.y && (Gt = -Gt), { bearingDelta: Gt };
            }, moveStateManager: Nt, enable: Je, assignEvents: Va });
          }(s, G), $ = function(We) {
            let { enable: $e, clickTolerance: Je, pitchDegreesPerPixelMoved: Qe = -0.5 } = We;
            const wt = new tc({ checkCorrectEvent: (bt) => S.mouseButton(bt) === 0 && bt.ctrlKey || S.mouseButton(bt) === 2 });
            return new vn({ clickTolerance: Je, move: (bt, Mt) => ({ pitchDelta: (Mt.y - bt.y) * Qe }), moveStateManager: wt, enable: $e, assignEvents: Va });
          }(s), re = function(We, $e) {
            let { enable: Je, clickTolerance: Qe, rollDegreesPerPixelMoved: wt = 0.3 } = We;
            const bt = new tc({ checkCorrectEvent: (Mt) => S.mouseButton(Mt) === 2 && Mt.ctrlKey });
            return new vn({ clickTolerance: Qe, move: (Mt, Nt) => {
              const Ct = $e();
              let sn = (Nt.x - Mt.x) * wt;
              return Nt.y < Ct.y && (sn = -sn), { rollDelta: sn };
            }, moveStateManager: bt, enable: Je, assignEvents: Va });
          }(s, G);
          u.dragRotate = new qt(s, Z, $, re), this._add("mouseRotate", Z, ["mousePitch"]), this._add("mousePitch", $, ["mouseRotate", "mouseRoll"]), this._add("mouseRoll", re, ["mousePitch"]), s.interactive && s.dragRotate && u.dragRotate.enable();
          const ae = function(We) {
            let { enable: $e, clickTolerance: Je } = We;
            const Qe = new tc({ checkCorrectEvent: (wt) => S.mouseButton(wt) === 0 && !wt.ctrlKey });
            return new vn({ clickTolerance: Je, move: (wt, bt) => ({ around: bt, panDelta: bt.sub(wt) }), activateOnStart: !0, moveStateManager: Qe, enable: $e, assignEvents: Va });
          }(s), Pe = new _u(s, u);
          u.dragPan = new ct(p, ae, Pe), this._add("mousePan", ae), this._add("touchPan", Pe, ["touchZoom", "touchRotate"]), s.interactive && s.dragPan && u.dragPan.enable(s.dragPan);
          const Ce = new k(), Ie = new T();
          u.touchZoomRotate = new Ot(p, Ie, Ce, B), this._add("touchRotate", Ce, ["touchPan", "touchZoom"]), this._add("touchZoom", Ie, ["touchPan", "touchRotate"]), s.interactive && s.touchZoomRotate && u.touchZoomRotate.enable(s.touchZoomRotate);
          const Be = u.scrollZoom = new Le(u, () => this._triggerRenderFrame());
          this._add("scrollZoom", Be, ["mousePan"]), s.interactive && s.scrollZoom && u.scrollZoom.enable(s.scrollZoom);
          const He = u.keyboard = new he(u);
          this._add("keyboard", He), s.interactive && s.keyboard && u.keyboard.enable(), this._add("blockableMapEvent", new Hu(u));
        }
        _add(s, u, p) {
          this._handlers.push({ handlerName: s, handler: u, allowed: p }), this._handlersById[s] = u;
        }
        stop(s) {
          if (!this._updatingCamera) {
            for (const { handler: u } of this._handlers) u.reset();
            this._inertia.clear(), this._fireEvents({}, {}, s), this._changes = [];
          }
        }
        isActive() {
          for (const { handler: s } of this._handlers) if (s.isActive()) return !0;
          return !1;
        }
        isZooming() {
          return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
        }
        isRotating() {
          return !!this._eventsInProgress.rotate;
        }
        isMoving() {
          return !!st(this._eventsInProgress) || this.isZooming();
        }
        _blockedByActive(s, u, p) {
          for (const m in s) if (m !== p && (!u || u.indexOf(m) < 0)) return !0;
          return !1;
        }
        _getMapTouches(s) {
          const u = [];
          for (const p of s) this._el.contains(p.target) && u.push(p);
          return u;
        }
        mergeHandlerResult(s, u, p, m, x) {
          if (!p) return;
          a.e(s, p);
          const E = { handlerName: m, originalEvent: p.originalEvent || x };
          p.zoomDelta !== void 0 && (u.zoom = E), p.panDelta !== void 0 && (u.drag = E), p.rollDelta !== void 0 && (u.roll = E), p.pitchDelta !== void 0 && (u.pitch = E), p.bearingDelta !== void 0 && (u.rotate = E);
        }
        _applyChanges() {
          const s = {}, u = {}, p = {};
          for (const [m, x, E] of this._changes) m.panDelta && (s.panDelta = (s.panDelta || new a.P(0, 0))._add(m.panDelta)), m.zoomDelta && (s.zoomDelta = (s.zoomDelta || 0) + m.zoomDelta), m.bearingDelta && (s.bearingDelta = (s.bearingDelta || 0) + m.bearingDelta), m.pitchDelta && (s.pitchDelta = (s.pitchDelta || 0) + m.pitchDelta), m.rollDelta && (s.rollDelta = (s.rollDelta || 0) + m.rollDelta), m.around !== void 0 && (s.around = m.around), m.pinchAround !== void 0 && (s.pinchAround = m.pinchAround), m.noInertia && (s.noInertia = m.noInertia), a.e(u, x), a.e(p, E);
          this._updateMapTransform(s, u, p), this._changes = [];
        }
        _updateMapTransform(s, u, p) {
          const m = this._map, x = m._getTransformForUpdate(), E = m.terrain;
          if (!(Zt(s) || E && this._terrainMovement)) return this._fireEvents(u, p, !0);
          m._stop(!0);
          let { panDelta: L, zoomDelta: B, bearingDelta: N, pitchDelta: G, rollDelta: Z, around: $, pinchAround: re } = s;
          re !== void 0 && ($ = re), $ = $ || m.transform.centerPoint, E && !x.isPointOnMapSurface($) && ($ = x.centerPoint);
          const ae = { panDelta: L, zoomDelta: B, rollDelta: Z, pitchDelta: G, bearingDelta: N, around: $ };
          this._map.cameraHelper.useGlobeControls && !x.isPointOnMapSurface($) && ($ = x.centerPoint);
          const Pe = $.distSqr(x.centerPoint) < 0.01 ? x.center : x.screenPointToLocation(L ? $.sub(L) : $);
          E ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(ae, x), this._terrainMovement || !u.drag && !u.zoom ? u.drag && this._terrainMovement ? x.setCenter(x.screenPointToLocation(x.centerPoint.sub(L))) : this._map.cameraHelper.handleMapControlsPan(ae, x, Pe) : (this._terrainMovement = !0, this._map._elevationFreeze = !0, this._map.cameraHelper.handleMapControlsPan(ae, x, Pe))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(ae, x), this._map.cameraHelper.handleMapControlsPan(ae, x, Pe)), m._applyUpdatedTransform(x), this._map._update(), s.noInertia || this._inertia.record(s), this._fireEvents(u, p, !0);
        }
        _fireEvents(s, u, p) {
          const m = st(this._eventsInProgress), x = st(s), E = {};
          for (const Z in s) {
            const { originalEvent: $ } = s[Z];
            this._eventsInProgress[Z] || (E[`${Z}start`] = $), this._eventsInProgress[Z] = s[Z];
          }
          !m && x && this._fireEvent("movestart", x.originalEvent);
          for (const Z in E) this._fireEvent(Z, E[Z]);
          x && this._fireEvent("move", x.originalEvent);
          for (const Z in s) {
            const { originalEvent: $ } = s[Z];
            this._fireEvent(Z, $);
          }
          const L = {};
          let B;
          for (const Z in this._eventsInProgress) {
            const { handlerName: $, originalEvent: re } = this._eventsInProgress[Z];
            this._handlersById[$].isActive() || (delete this._eventsInProgress[Z], B = u[$] || re, L[`${Z}end`] = B);
          }
          for (const Z in L) this._fireEvent(Z, L[Z]);
          const N = st(this._eventsInProgress), G = (m || x) && !N;
          if (G && this._terrainMovement) {
            this._map._elevationFreeze = !1, this._terrainMovement = !1;
            const Z = this._map._getTransformForUpdate();
            this._map.getCenterClampedToGround() && Z.recalculateZoomAndCenter(this._map.terrain), this._map._applyUpdatedTransform(Z);
          }
          if (p && G) {
            this._updatingCamera = !0;
            const Z = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), $ = (re) => re !== 0 && -this._bearingSnap < re && re < this._bearingSnap;
            !Z || !Z.essential && I.prefersReducedMotion ? (this._map.fire(new a.k("moveend", { originalEvent: B })), $(this._map.getBearing()) && this._map.resetNorth()) : ($(Z.bearing || this._map.getBearing()) && (Z.bearing = 0), Z.freezeElevation = !0, this._map.easeTo(Z, { originalEvent: B })), this._updatingCamera = !1;
          }
        }
        _fireEvent(s, u) {
          this._map.fire(new a.k(s, u ? { originalEvent: u } : {}));
        }
        _requestFrame() {
          return this._map.triggerRepaint(), this._map._renderTaskQueue.add((s) => {
            delete this._frameId, this.handleEvent(new jt("renderFrame", { timeStamp: s })), this._applyChanges();
          });
        }
        _triggerRenderFrame() {
          this._frameId === void 0 && (this._frameId = this._requestFrame());
        }
      }
      class Ut extends a.E {
        constructor(s, u, p) {
          super(), this._renderFrameCallback = () => {
            const m = Math.min((I.now() - this._easeStart) / this._easeOptions.duration, 1);
            this._onEaseFrame(this._easeOptions.easing(m)), m < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
          }, this._moving = !1, this._zooming = !1, this.transform = s, this._bearingSnap = p.bearingSnap, this.cameraHelper = u, this.on("moveend", () => {
            delete this._requestedCameraState;
          });
        }
        migrateProjection(s, u) {
          s.apply(this.transform), this.transform = s, this.cameraHelper = u;
        }
        getCenter() {
          return new a.O(this.transform.center.lng, this.transform.center.lat);
        }
        setCenter(s, u) {
          return this.jumpTo({ center: s }, u);
        }
        getCenterElevation() {
          return this.transform.elevation;
        }
        setCenterElevation(s, u) {
          return this.jumpTo({ elevation: s }, u), this;
        }
        getCenterClampedToGround() {
          return this._centerClampedToGround;
        }
        setCenterClampedToGround(s) {
          this._centerClampedToGround = s;
        }
        panBy(s, u, p) {
          return s = a.P.convert(s).mult(-1), this.panTo(this.transform.center, a.e({ offset: s }, u), p);
        }
        panTo(s, u, p) {
          return this.easeTo(a.e({ center: s }, u), p);
        }
        getZoom() {
          return this.transform.zoom;
        }
        setZoom(s, u) {
          return this.jumpTo({ zoom: s }, u), this;
        }
        zoomTo(s, u, p) {
          return this.easeTo(a.e({ zoom: s }, u), p);
        }
        zoomIn(s, u) {
          return this.zoomTo(this.getZoom() + 1, s, u), this;
        }
        zoomOut(s, u) {
          return this.zoomTo(this.getZoom() - 1, s, u), this;
        }
        getVerticalFieldOfView() {
          return this.transform.fov;
        }
        setVerticalFieldOfView(s, u) {
          return s != this.transform.fov && (this.transform.setFov(s), this.fire(new a.k("movestart", u)).fire(new a.k("move", u)).fire(new a.k("moveend", u))), this;
        }
        getBearing() {
          return this.transform.bearing;
        }
        setBearing(s, u) {
          return this.jumpTo({ bearing: s }, u), this;
        }
        getPadding() {
          return this.transform.padding;
        }
        setPadding(s, u) {
          return this.jumpTo({ padding: s }, u), this;
        }
        rotateTo(s, u, p) {
          return this.easeTo(a.e({ bearing: s }, u), p);
        }
        resetNorth(s, u) {
          return this.rotateTo(0, a.e({ duration: 1e3 }, s), u), this;
        }
        resetNorthPitch(s, u) {
          return this.easeTo(a.e({ bearing: 0, pitch: 0, roll: 0, duration: 1e3 }, s), u), this;
        }
        snapToNorth(s, u) {
          return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(s, u) : this;
        }
        getPitch() {
          return this.transform.pitch;
        }
        setPitch(s, u) {
          return this.jumpTo({ pitch: s }, u), this;
        }
        getRoll() {
          return this.transform.roll;
        }
        setRoll(s, u) {
          return this.jumpTo({ roll: s }, u), this;
        }
        cameraForBounds(s, u) {
          s = wn.convert(s).adjustAntiMeridian();
          const p = u && u.bearing || 0;
          return this._cameraForBoxAndBearing(s.getNorthWest(), s.getSouthEast(), p, u);
        }
        _cameraForBoxAndBearing(s, u, p, m) {
          const x = { top: 0, bottom: 0, right: 0, left: 0 };
          if (typeof (m = a.e({ padding: x, offset: [0, 0], maxZoom: this.transform.maxZoom }, m)).padding == "number") {
            const N = m.padding;
            m.padding = { top: N, bottom: N, right: N, left: N };
          }
          const E = a.e(x, m.padding);
          m.padding = E;
          const L = this.transform, B = new wn(s, u);
          return this.cameraHelper.cameraForBoxAndBearing(m, E, B, p, L);
        }
        fitBounds(s, u, p) {
          return this._fitInternal(this.cameraForBounds(s, u), u, p);
        }
        fitScreenCoordinates(s, u, p, m, x) {
          return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(a.P.convert(s)), this.transform.screenPointToLocation(a.P.convert(u)), p, m), m, x);
        }
        _fitInternal(s, u, p) {
          return s ? (delete (u = a.e(s, u)).padding, u.linear ? this.easeTo(u, p) : this.flyTo(u, p)) : this;
        }
        jumpTo(s, u) {
          this.stop();
          const p = this._getTransformForUpdate();
          let m = !1, x = !1, E = !1;
          const L = p.zoom;
          this.cameraHelper.handleJumpToCenterZoom(p, s);
          const B = p.zoom !== L;
          return "elevation" in s && p.elevation !== +s.elevation && p.setElevation(+s.elevation), "bearing" in s && p.bearing !== +s.bearing && (m = !0, p.setBearing(+s.bearing)), "pitch" in s && p.pitch !== +s.pitch && (x = !0, p.setPitch(+s.pitch)), "roll" in s && p.roll !== +s.roll && (E = !0, p.setRoll(+s.roll)), s.padding == null || p.isPaddingEqual(s.padding) || p.setPadding(s.padding), this._applyUpdatedTransform(p), this.fire(new a.k("movestart", u)).fire(new a.k("move", u)), B && this.fire(new a.k("zoomstart", u)).fire(new a.k("zoom", u)).fire(new a.k("zoomend", u)), m && this.fire(new a.k("rotatestart", u)).fire(new a.k("rotate", u)).fire(new a.k("rotateend", u)), x && this.fire(new a.k("pitchstart", u)).fire(new a.k("pitch", u)).fire(new a.k("pitchend", u)), E && this.fire(new a.k("rollstart", u)).fire(new a.k("roll", u)).fire(new a.k("rollend", u)), this.fire(new a.k("moveend", u));
        }
        calculateCameraOptionsFromTo(s, u, p) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
          const x = a.Z.fromLngLat(s, u), E = a.Z.fromLngLat(p, m), L = E.x - x.x, B = E.y - x.y, N = E.z - x.z, G = Math.hypot(L, B, N);
          if (G === 0) throw new Error("Can't calculate camera options with same From and To");
          const Z = Math.hypot(L, B), $ = a.a9(this.transform.cameraToCenterDistance / G / this.transform.tileSize), re = 180 * Math.atan2(L, -B) / Math.PI;
          let ae = 180 * Math.acos(Z / G) / Math.PI;
          return ae = N < 0 ? 90 - ae : 90 + ae, { center: E.toLngLat(), elevation: m, zoom: $, pitch: ae, bearing: re };
        }
        calculateCameraOptionsFromCameraLngLatAltRotation(s, u, p, m, x) {
          const E = this.transform.calculateCenterFromCameraLngLatAlt(s, u, p, m);
          return { center: E.center, elevation: E.elevation, zoom: E.zoom, bearing: p, pitch: m, roll: x };
        }
        easeTo(s, u) {
          this._stop(!1, s.easeId), ((s = a.e({ offset: [0, 0], duration: 500, easing: a.c9 }, s)).animate === !1 || !s.essential && I.prefersReducedMotion) && (s.duration = 0);
          const p = this._getTransformForUpdate(), m = this.getBearing(), x = p.pitch, E = p.roll, L = "bearing" in s ? this._normalizeBearing(s.bearing, m) : m, B = "pitch" in s ? +s.pitch : x, N = "roll" in s ? this._normalizeBearing(s.roll, E) : E, G = "padding" in s ? s.padding : p.padding, Z = a.P.convert(s.offset);
          let $, re;
          s.around && ($ = a.O.convert(s.around), re = p.locationToScreenPoint($));
          const ae = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching, rolling: this._rolling }, Pe = this.cameraHelper.handleEaseTo(p, { bearing: L, pitch: B, roll: N, padding: G, around: $, aroundPoint: re, offsetAsPoint: Z, offset: s.offset, zoom: s.zoom, center: s.center });
          return this._rotating = this._rotating || m !== L, this._pitching = this._pitching || B !== x, this._rolling = this._rolling || N !== E, this._padding = !p.isPaddingEqual(G), this._zooming = this._zooming || Pe.isZooming, this._easeId = s.easeId, this._prepareEase(u, s.noMoveStart, ae), this.terrain && this._prepareElevation(Pe.elevationCenter), this._ease((Ce) => {
            Pe.easeFunc(Ce), this.terrain && !s.freezeElevation && this._updateElevation(Ce), this._applyUpdatedTransform(p), this._fireMoveEvents(u);
          }, (Ce) => {
            this.terrain && s.freezeElevation && this._finalizeElevation(), this._afterEase(u, Ce);
          }, s), this;
        }
        _prepareEase(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          this._moving = !0, u || p.moving || this.fire(new a.k("movestart", s)), this._zooming && !p.zooming && this.fire(new a.k("zoomstart", s)), this._rotating && !p.rotating && this.fire(new a.k("rotatestart", s)), this._pitching && !p.pitching && this.fire(new a.k("pitchstart", s)), this._rolling && !p.rolling && this.fire(new a.k("rollstart", s));
        }
        _prepareElevation(s) {
          this._elevationCenter = s, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(s, this.transform.tileZoom), this._elevationFreeze = !0;
        }
        _updateElevation(s) {
          this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
          const u = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
          if (s < 1 && u !== this._elevationTarget) {
            const p = this._elevationTarget - this._elevationStart;
            this._elevationStart += s * (p - (u - (p * s + this._elevationStart)) / (1 - s)), this._elevationTarget = u;
          }
          this.transform.setElevation(a.z.number(this._elevationStart, this._elevationTarget, s));
        }
        _finalizeElevation() {
          this._elevationFreeze = !1, this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain);
        }
        _getTransformForUpdate() {
          return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
        }
        _elevateCameraIfInsideTerrain(s) {
          if (!this.terrain && s.elevation >= 0 && s.pitch <= 90) return {};
          const u = s.getCameraLngLat(), p = s.getCameraAltitude(), m = this.terrain ? this.terrain.getElevationForLngLatZoom(u, s.zoom) : 0;
          if (p < m) {
            const x = this.calculateCameraOptionsFromTo(u, m, s.center, s.elevation);
            return { pitch: x.pitch, zoom: x.zoom };
          }
          return {};
        }
        _applyUpdatedTransform(s) {
          const u = [];
          if (u.push((m) => this._elevateCameraIfInsideTerrain(m)), this.transformCameraUpdate && u.push((m) => this.transformCameraUpdate(m)), !u.length) return;
          const p = s.clone();
          for (const m of u) {
            const x = p.clone(), { center: E, zoom: L, roll: B, pitch: N, bearing: G, elevation: Z } = m(x);
            E && x.setCenter(E), Z !== void 0 && x.setElevation(Z), L !== void 0 && x.setZoom(L), B !== void 0 && x.setRoll(B), N !== void 0 && x.setPitch(N), G !== void 0 && x.setBearing(G), p.apply(x);
          }
          this.transform.apply(p);
        }
        _fireMoveEvents(s) {
          this.fire(new a.k("move", s)), this._zooming && this.fire(new a.k("zoom", s)), this._rotating && this.fire(new a.k("rotate", s)), this._pitching && this.fire(new a.k("pitch", s)), this._rolling && this.fire(new a.k("roll", s));
        }
        _afterEase(s, u) {
          if (this._easeId && u && this._easeId === u) return;
          delete this._easeId;
          const p = this._zooming, m = this._rotating, x = this._pitching, E = this._rolling;
          this._moving = !1, this._zooming = !1, this._rotating = !1, this._pitching = !1, this._rolling = !1, this._padding = !1, p && this.fire(new a.k("zoomend", s)), m && this.fire(new a.k("rotateend", s)), x && this.fire(new a.k("pitchend", s)), E && this.fire(new a.k("rollend", s)), this.fire(new a.k("moveend", s));
        }
        flyTo(s, u) {
          if (!s.essential && I.prefersReducedMotion) {
            const Ct = a.N(s, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
            return this.jumpTo(Ct, u);
          }
          this.stop(), s = a.e({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: a.c9 }, s);
          const p = this._getTransformForUpdate(), m = p.bearing, x = p.pitch, E = p.roll, L = p.padding, B = "bearing" in s ? this._normalizeBearing(s.bearing, m) : m, N = "pitch" in s ? +s.pitch : x, G = "roll" in s ? this._normalizeBearing(s.roll, E) : E, Z = "padding" in s ? s.padding : p.padding, $ = a.P.convert(s.offset);
          let re = p.centerPoint.add($);
          const ae = p.screenPointToLocation(re), Pe = this.cameraHelper.handleFlyTo(p, { bearing: B, pitch: N, roll: G, padding: Z, locationAtOffset: ae, offsetAsPoint: $, center: s.center, minZoom: s.minZoom, zoom: s.zoom });
          let Ce = s.curve;
          const Ie = Math.max(p.width, p.height), Be = Ie / Pe.scaleOfZoom, He = Pe.pixelPathLength;
          typeof Pe.scaleOfMinZoom == "number" && (Ce = Math.sqrt(Ie / Pe.scaleOfMinZoom / He * 2));
          const We = Ce * Ce;
          function $e(Ct) {
            const sn = (Be * Be - Ie * Ie + (Ct ? -1 : 1) * We * We * He * He) / (2 * (Ct ? Be : Ie) * We * He);
            return Math.log(Math.sqrt(sn * sn + 1) - sn);
          }
          function Je(Ct) {
            return (Math.exp(Ct) - Math.exp(-Ct)) / 2;
          }
          function Qe(Ct) {
            return (Math.exp(Ct) + Math.exp(-Ct)) / 2;
          }
          const wt = $e(!1);
          let bt = function(Ct) {
            return Qe(wt) / Qe(wt + Ce * Ct);
          }, Mt = function(Ct) {
            return Ie * ((Qe(wt) * (Je(sn = wt + Ce * Ct) / Qe(sn)) - Je(wt)) / We) / He;
            var sn;
          }, Nt = ($e(!0) - wt) / Ce;
          if (Math.abs(He) < 2e-6 || !isFinite(Nt)) {
            if (Math.abs(Ie - Be) < 1e-6) return this.easeTo(s, u);
            const Ct = Be < Ie ? -1 : 1;
            Nt = Math.abs(Math.log(Be / Ie)) / Ce, Mt = () => 0, bt = (sn) => Math.exp(Ct * Ce * sn);
          }
          return s.duration = "duration" in s ? +s.duration : 1e3 * Nt / ("screenSpeed" in s ? +s.screenSpeed / Ce : +s.speed), s.maxDuration && s.duration > s.maxDuration && (s.duration = 0), this._zooming = !0, this._rotating = m !== B, this._pitching = N !== x, this._rolling = G !== E, this._padding = !p.isPaddingEqual(Z), this._prepareEase(u, !1), this.terrain && this._prepareElevation(Pe.targetCenter), this._ease((Ct) => {
            const sn = Ct * Nt, nn = 1 / bt(sn), Gt = Mt(sn);
            this._rotating && p.setBearing(a.z.number(m, B, Ct)), this._pitching && p.setPitch(a.z.number(x, N, Ct)), this._rolling && p.setRoll(a.z.number(E, G, Ct)), this._padding && (p.interpolatePadding(L, Z, Ct), re = p.centerPoint.add($)), Pe.easeFunc(Ct, nn, Gt, re), this.terrain && !s.freezeElevation && this._updateElevation(Ct), this._applyUpdatedTransform(p), this._fireMoveEvents(u);
          }, () => {
            this.terrain && s.freezeElevation && this._finalizeElevation(), this._afterEase(u);
          }, s), this;
        }
        isEasing() {
          return !!this._easeFrameId;
        }
        stop() {
          return this._stop();
        }
        _stop(s, u) {
          var p;
          if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
            const m = this._onEaseEnd;
            delete this._onEaseEnd, m.call(this, u);
          }
          return s || (p = this.handlers) === null || p === void 0 || p.stop(!1), this;
        }
        _ease(s, u, p) {
          p.animate === !1 || p.duration === 0 ? (s(1), u()) : (this._easeStart = I.now(), this._easeOptions = p, this._onEaseFrame = s, this._onEaseEnd = u, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
        }
        _normalizeBearing(s, u) {
          s = a.aJ(s, -180, 180);
          const p = Math.abs(s - u);
          return Math.abs(s - 360 - u) < p && (s -= 360), Math.abs(s + 360 - u) < p && (s += 360), s;
        }
        queryTerrainElevation(s) {
          return this.terrain ? this.terrain.getElevationForLngLatZoom(a.O.convert(s), this.transform.tileZoom) : null;
        }
      }
      const yn = { compact: !0, customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>' };
      class jn {
        constructor() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : yn;
          this._toggleAttribution = () => {
            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
          }, this._updateData = (u) => {
            !u || u.sourceDataType !== "metadata" && u.sourceDataType !== "visibility" && u.dataType !== "style" && u.type !== "terrain" || this._updateAttributions();
          }, this._updateCompact = () => {
            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
          }, this._updateCompactMinimize = () => {
            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
          }, this.options = s;
        }
        getDefaultPosition() {
          return "bottom-right";
        }
        onAdd(s) {
          return this._map = s, this._compact = this.options.compact, this._container = S.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = S.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = S.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
        }
        onRemove() {
          S.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._sanitizedAttributionHTML = void 0;
        }
        _setElementTitle(s, u) {
          const p = this._map._getUIString(`AttributionControl.${u}`);
          s.title = p, s.setAttribute("aria-label", p);
        }
        _updateAttributions() {
          if (!this._map.style) return;
          let s = [];
          if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? s = s.concat(this.options.customAttribution.map((m) => typeof m != "string" ? "" : m)) : typeof this.options.customAttribution == "string" && s.push(this.options.customAttribution)), this._map.style.stylesheet) {
            const m = this._map.style.stylesheet;
            this.styleOwner = m.owner, this.styleId = m.id;
          }
          const u = this._map.style.sourceCaches;
          for (const m in u) {
            const x = u[m];
            if (x.used || x.usedForTerrain) {
              const E = x.getSource();
              E.attribution && s.indexOf(E.attribution) < 0 && s.push(E.attribution);
            }
          }
          s = s.filter((m) => String(m).trim()), s.sort((m, x) => m.length - x.length), s = s.filter((m, x) => {
            for (let E = x + 1; E < s.length; E++) if (s[E].indexOf(m) >= 0) return !1;
            return !0;
          });
          const p = s.join(" | ");
          p !== this._sanitizedAttributionHTML && (this._sanitizedAttributionHTML = S.sanitize(p), s.length ? (this._innerContainer.innerHTML = this._sanitizedAttributionHTML, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
        }
      }
      class xn {
        constructor() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          this._updateCompact = () => {
            const u = this._container.children;
            if (u.length) {
              const p = u[0];
              this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && p.classList.add("maplibregl-compact") : p.classList.remove("maplibregl-compact");
            }
          }, this.options = s;
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(s) {
          this._map = s, this._compact = this.options && this.options.compact, this._container = S.create("div", "maplibregl-ctrl");
          const u = S.create("a", "maplibregl-ctrl-logo");
          return u.target = "_blank", u.rel = "noopener nofollow", u.href = "https://maplibre.org/", u.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), u.setAttribute("rel", "noopener nofollow"), this._container.appendChild(u), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
        }
        onRemove() {
          S.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
        }
      }
      class ri {
        constructor() {
          this._queue = [], this._id = 0, this._cleared = !1, this._currentlyRunning = !1;
        }
        add(s) {
          const u = ++this._id;
          return this._queue.push({ callback: s, id: u, cancelled: !1 }), u;
        }
        remove(s) {
          const u = this._currentlyRunning, p = u ? this._queue.concat(u) : this._queue;
          for (const m of p) if (m.id === s) return void (m.cancelled = !0);
        }
        run() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          if (this._currentlyRunning) throw new Error("Attempting to run(), but is already running.");
          const u = this._currentlyRunning = this._queue;
          this._queue = [];
          for (const p of u) if (!p.cancelled && (p.callback(s), this._cleared)) break;
          this._cleared = !1, this._currentlyRunning = !1;
        }
        clear() {
          this._currentlyRunning && (this._cleared = !0), this._queue = [];
        }
      }
      var Fi = a.aB([{ name: "a_pos3d", type: "Int16", components: 3 }]);
      class ai extends a.E {
        constructor(s) {
          super(), this._lastTilesetChange = I.now(), this.sourceCache = s, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.deltaZoom = 1, this.tileSize = s._source.tileSize * 2 ** this.deltaZoom, s.usedForTerrain = !0, s.tileSize = this.tileSize;
        }
        destruct() {
          this.sourceCache.usedForTerrain = !1, this.sourceCache.tileSize = null;
        }
        update(s, u) {
          this.sourceCache.update(s, u), this._renderableTilesKeys = [];
          const p = {};
          for (const m of be(s, { tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: !1, terrain: u, calculateTileZoom: this.sourceCache._source.calculateTileZoom })) p[m.key] = !0, this._renderableTilesKeys.push(m.key), this._tiles[m.key] || (m.terrainRttPosMatrix32f = new Float64Array(16), a.bM(m.terrainRttPosMatrix32f, 0, a.Y, a.Y, 0, 0, 1), this._tiles[m.key] = new Un(m, this.tileSize), this._lastTilesetChange = I.now());
          for (const m in this._tiles) p[m] || delete this._tiles[m];
        }
        freeRtt(s) {
          for (const u in this._tiles) {
            const p = this._tiles[u];
            (!s || p.tileID.equals(s) || p.tileID.isChildOf(s) || s.isChildOf(p.tileID)) && (p.rtt = []);
          }
        }
        getRenderableTiles() {
          return this._renderableTilesKeys.map((s) => this.getTileByID(s));
        }
        getTileByID(s) {
          return this._tiles[s];
        }
        getTerrainCoords(s) {
          const u = {};
          for (const p of this._renderableTilesKeys) {
            const m = this._tiles[p].tileID, x = s.clone(), E = a.b0();
            if (m.canonical.equals(s.canonical)) a.bM(E, 0, a.Y, a.Y, 0, 0, 1);
            else if (m.canonical.isChildOf(s.canonical)) {
              const L = m.canonical.z - s.canonical.z, B = m.canonical.x - (m.canonical.x >> L << L), N = m.canonical.y - (m.canonical.y >> L << L), G = a.Y >> L;
              a.bM(E, 0, G, G, 0, 0, 1), a.K(E, E, [-B * G, -N * G, 0]);
            } else {
              if (!s.canonical.isChildOf(m.canonical)) continue;
              {
                const L = s.canonical.z - m.canonical.z, B = s.canonical.x - (s.canonical.x >> L << L), N = s.canonical.y - (s.canonical.y >> L << L), G = a.Y >> L;
                a.bM(E, 0, a.Y, a.Y, 0, 0, 1), a.K(E, E, [B * G, N * G, 0]), a.L(E, E, [1 / 2 ** L, 1 / 2 ** L, 0]);
              }
            }
            x.terrainRttPosMatrix32f = new Float32Array(E), u[p] = x;
          }
          return u;
        }
        getSourceTile(s, u) {
          const p = this.sourceCache._source;
          let m = s.overscaledZ - this.deltaZoom;
          if (m > p.maxzoom && (m = p.maxzoom), m < p.minzoom) return null;
          this._sourceTileCache[s.key] || (this._sourceTileCache[s.key] = s.scaledTo(m).key);
          let x = this.sourceCache.getTileByID(this._sourceTileCache[s.key]);
          if ((!x || !x.dem) && u) for (; m >= p.minzoom && (!x || !x.dem); ) x = this.sourceCache.getTileByID(s.scaledTo(m--).key);
          return x;
        }
        anyTilesAfterTime() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Date.now();
          return this._lastTilesetChange >= s;
        }
      }
      class Ai {
        constructor(s, u, p) {
          this._meshCache = {}, this.painter = s, this.sourceCache = new ai(u), this.options = p, this.exaggeration = typeof p.exaggeration == "number" ? p.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
        }
        getDEMElevation(s, u, p) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : a.Y;
          var x;
          if (!(u >= 0 && u < m && p >= 0 && p < m)) return 0;
          const E = this.getTerrainData(s), L = (x = E.tile) === null || x === void 0 ? void 0 : x.dem;
          if (!L) return 0;
          const B = a.ca([], [u / m * a.Y, p / m * a.Y], E.u_terrain_matrix), N = [B[0] * L.dim, B[1] * L.dim], G = Math.floor(N[0]), Z = Math.floor(N[1]), $ = N[0] - G, re = N[1] - Z;
          return L.get(G, Z) * (1 - $) * (1 - re) + L.get(G + 1, Z) * $ * (1 - re) + L.get(G, Z + 1) * (1 - $) * re + L.get(G + 1, Z + 1) * $ * re;
        }
        getElevationForLngLatZoom(s, u) {
          if (!a.cb(u, s.wrap())) return 0;
          const { tileID: p, mercatorX: m, mercatorY: x } = this._getOverscaledTileIDFromLngLatZoom(s, u);
          return this.getElevation(p, m % a.Y, x % a.Y, a.Y);
        }
        getElevation(s, u, p) {
          let m = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : a.Y;
          return this.getDEMElevation(s, u, p, m) * this.exaggeration;
        }
        getTerrainData(s) {
          if (!this._emptyDemTexture) {
            const m = this.painter.context, x = new a.R({ width: 1, height: 1 }, new Uint8Array(4));
            this._emptyDepthTexture = new me(m, x, m.gl.RGBA, { premultiply: !1 }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new me(m, new a.R({ width: 1, height: 1 }), m.gl.RGBA, { premultiply: !1 }), this._emptyDemTexture.bind(m.gl.NEAREST, m.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = a.ar([]);
          }
          const u = this.sourceCache.getSourceTile(s, !0);
          if (u && u.dem && (!u.demTexture || u.needsTerrainPrepare)) {
            const m = this.painter.context;
            u.demTexture = this.painter.getTileTexture(u.dem.stride), u.demTexture ? u.demTexture.update(u.dem.getPixels(), { premultiply: !1 }) : u.demTexture = new me(m, u.dem.getPixels(), m.gl.RGBA, { premultiply: !1 }), u.demTexture.bind(m.gl.NEAREST, m.gl.CLAMP_TO_EDGE), u.needsTerrainPrepare = !1;
          }
          const p = u && u + u.tileID.key + s.key;
          if (p && !this._demMatrixCache[p]) {
            const m = this.sourceCache.sourceCache._source.maxzoom;
            let x = s.canonical.z - u.tileID.canonical.z;
            s.overscaledZ > s.canonical.z && (s.canonical.z >= m ? x = s.canonical.z - m : a.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
            const E = s.canonical.x - (s.canonical.x >> x << x), L = s.canonical.y - (s.canonical.y >> x << x), B = a.cc(new Float64Array(16), [1 / (a.Y << x), 1 / (a.Y << x), 0]);
            a.K(B, B, [E * a.Y, L * a.Y, 0]), this._demMatrixCache[s.key] = { matrix: B, coord: s };
          }
          return { u_depth: 2, u_terrain: 3, u_terrain_dim: u && u.dem && u.dem.dim || 1, u_terrain_matrix: p ? this._demMatrixCache[s.key].matrix : this._emptyDemMatrix, u_terrain_unpack: u && u.dem && u.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (u && u.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: u };
        }
        getFramebuffer(s) {
          const u = this.painter, p = u.width / devicePixelRatio, m = u.height / devicePixelRatio;
          return !this._fbo || this._fbo.width === p && this._fbo.height === m || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new me(u.context, { width: p, height: m, data: null }, u.context.gl.RGBA, { premultiply: !1 }), this._fboCoordsTexture.bind(u.context.gl.NEAREST, u.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new me(u.context, { width: p, height: m, data: null }, u.context.gl.RGBA, { premultiply: !1 }), this._fboDepthTexture.bind(u.context.gl.NEAREST, u.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = u.context.createFramebuffer(p, m, !0, !1), this._fbo.depthAttachment.set(u.context.createRenderbuffer(u.context.gl.DEPTH_COMPONENT16, p, m))), this._fbo.colorAttachment.set(s === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
        }
        getCoordsTexture() {
          const s = this.painter.context;
          if (this._coordsTexture) return this._coordsTexture;
          const u = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
          for (let x = 0, E = 0; x < this._coordsTextureSize; x++) for (let L = 0; L < this._coordsTextureSize; L++, E += 4) u[E + 0] = 255 & L, u[E + 1] = 255 & x, u[E + 2] = L >> 8 << 4 | x >> 8, u[E + 3] = 0;
          const p = new a.R({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(u.buffer)), m = new me(s, p, s.gl.RGBA, { premultiply: !1 });
          return m.bind(s.gl.NEAREST, s.gl.CLAMP_TO_EDGE), this._coordsTexture = m, m;
        }
        pointCoordinate(s) {
          this.painter.maybeDrawDepthAndCoords(!0);
          const u = new Uint8Array(4), p = this.painter.context, m = p.gl, x = Math.round(s.x * this.painter.pixelRatio / devicePixelRatio), E = Math.round(s.y * this.painter.pixelRatio / devicePixelRatio), L = Math.round(this.painter.height / devicePixelRatio);
          p.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), m.readPixels(x, L - E - 1, 1, 1, m.RGBA, m.UNSIGNED_BYTE, u), p.bindFramebuffer.set(null);
          const B = u[0] + (u[2] >> 4 << 8), N = u[1] + ((15 & u[2]) << 8), G = this.coordsIndex[255 - u[3]], Z = G && this.sourceCache.getTileByID(G);
          if (!Z) return null;
          const $ = this._coordsTextureSize, re = (1 << Z.tileID.canonical.z) * $;
          return new a.Z((Z.tileID.canonical.x * $ + B) / re + Z.tileID.wrap, (Z.tileID.canonical.y * $ + N) / re, this.getElevation(Z.tileID, B, N, $));
        }
        depthAtPoint(s) {
          const u = new Uint8Array(4), p = this.painter.context, m = p.gl;
          return p.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer), m.readPixels(s.x, this.painter.height / devicePixelRatio - s.y - 1, 1, 1, m.RGBA, m.UNSIGNED_BYTE, u), p.bindFramebuffer.set(null), (u[0] / 16777216 + u[1] / 65536 + u[2] / 256 + u[3]) / 256;
        }
        getTerrainMesh(s) {
          var u;
          const p = ((u = this.painter.style.projection) === null || u === void 0 ? void 0 : u.transitionState) > 0, m = p && s.canonical.y === 0, x = p && s.canonical.y === (1 << s.canonical.z) - 1, E = `m_${m ? "n" : ""}_${x ? "s" : ""}`;
          if (this._meshCache[E]) return this._meshCache[E];
          const L = this.painter.context, B = new a.cd(), N = new a.aF(), G = this.meshSize, Z = a.Y / G, $ = G * G;
          for (let Qe = 0; Qe <= G; Qe++) for (let wt = 0; wt <= G; wt++) B.emplaceBack(wt * Z, Qe * Z, 0);
          for (let Qe = 0; Qe < $; Qe += G + 1) for (let wt = 0; wt < G; wt++) N.emplaceBack(wt + Qe, G + wt + Qe + 1, G + wt + Qe + 2), N.emplaceBack(wt + Qe, G + wt + Qe + 2, wt + Qe + 1);
          const re = B.length, ae = re + (G + 1), Pe = (G + 1) * G, Ce = m ? a.b7 : 0, Ie = m ? 0 : 1, Be = x ? a.b8 : a.Y, He = x ? 0 : 1;
          for (let Qe = 0; Qe <= G; Qe++) B.emplaceBack(Qe * Z, Ce, Ie);
          for (let Qe = 0; Qe <= G; Qe++) B.emplaceBack(Qe * Z, Be, He);
          for (let Qe = 0; Qe < G; Qe++) N.emplaceBack(Pe + Qe, ae + Qe, ae + Qe + 1), N.emplaceBack(Pe + Qe, ae + Qe + 1, Pe + Qe + 1), N.emplaceBack(0 + Qe, re + Qe + 1, re + Qe), N.emplaceBack(0 + Qe, 0 + Qe + 1, re + Qe + 1);
          const We = B.length, $e = We + 2 * (G + 1);
          for (const Qe of [0, 1]) for (let wt = 0; wt <= G; wt++) for (const bt of [0, 1]) B.emplaceBack(Qe * a.Y, wt * Z, bt);
          for (let Qe = 0; Qe < 2 * G; Qe += 2) N.emplaceBack(We + Qe, We + Qe + 1, We + Qe + 3), N.emplaceBack(We + Qe, We + Qe + 3, We + Qe + 2), N.emplaceBack($e + Qe, $e + Qe + 3, $e + Qe + 1), N.emplaceBack($e + Qe, $e + Qe + 2, $e + Qe + 3);
          const Je = new as(L.createVertexBuffer(B, Fi.members), L.createIndexBuffer(N), a.aE.simpleSegment(0, 0, B.length, N.length));
          return this._meshCache[E] = Je, Je;
        }
        getMeshFrameDelta(s) {
          return 2 * Math.PI * a.bp / Math.pow(2, Math.max(s, 0)) / 5;
        }
        getMinTileElevationForLngLatZoom(s, u) {
          var p;
          const { tileID: m } = this._getOverscaledTileIDFromLngLatZoom(s, u);
          return (p = this.getMinMaxElevation(m).minElevation) !== null && p !== void 0 ? p : 0;
        }
        getMinMaxElevation(s) {
          const u = this.getTerrainData(s).tile, p = { minElevation: null, maxElevation: null };
          return u && u.dem && (p.minElevation = u.dem.min * this.exaggeration, p.maxElevation = u.dem.max * this.exaggeration), p;
        }
        _getOverscaledTileIDFromLngLatZoom(s, u) {
          const p = a.Z.fromLngLat(s.wrap()), m = (1 << u) * a.Y, x = p.x * m, E = p.y * m, L = Math.floor(x / a.Y), B = Math.floor(E / a.Y);
          return { tileID: new a.X(u, 0, u, L, B), mercatorX: x, mercatorY: E };
        }
      }
      class Li {
        constructor(s, u, p) {
          this._context = s, this._size = u, this._tileSize = p, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
        }
        destruct() {
          for (const s of this._objects) s.texture.destroy(), s.fbo.destroy();
        }
        _createObject(s) {
          const u = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0), p = new me(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
          return p.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax), u.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), u.colorAttachment.set(p.texture), { id: s, fbo: u, texture: p, stamp: -1, inUse: !1 };
        }
        getObjectForId(s) {
          return this._objects[s];
        }
        useObject(s) {
          s.inUse = !0, this._recentlyUsed = this._recentlyUsed.filter((u) => s.id !== u), this._recentlyUsed.push(s.id);
        }
        stampObject(s) {
          s.stamp = ++this._stamp;
        }
        getOrCreateFreeObject() {
          for (const u of this._recentlyUsed) if (!this._objects[u].inUse) return this._objects[u];
          if (this._objects.length >= this._size) throw new Error("No free RenderPool available, call freeAllObjects() required!");
          const s = this._createObject(this._objects.length);
          return this._objects.push(s), s;
        }
        freeObject(s) {
          s.inUse = !1;
        }
        freeAllObjects() {
          for (const s of this._objects) this.freeObject(s);
        }
        isFull() {
          return !(this._objects.length < this._size) && this._objects.some((s) => !s.inUse) === !1;
        }
      }
      const Gn = { background: !0, fill: !0, line: !0, raster: !0, hillshade: !0 };
      class Bn {
        constructor(s, u) {
          this.painter = s, this.terrain = u, this.pool = new Li(s.context, 30, u.sourceCache.tileSize * u.qualityFactor);
        }
        destruct() {
          this.pool.destruct();
        }
        getTexture(s) {
          return this.pool.getObjectForId(s.rtt[this._stacks.length - 1].id).texture;
        }
        prepareForRender(s, u) {
          this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = s._order.filter((p) => !s._layers[p].isHidden(u)), this._coordsAscending = {};
          for (const p in s.sourceCaches) {
            this._coordsAscending[p] = {};
            const m = s.sourceCaches[p].getVisibleCoordinates();
            for (const x of m) {
              const E = this.terrain.sourceCache.getTerrainCoords(x);
              for (const L in E) this._coordsAscending[p][L] || (this._coordsAscending[p][L] = []), this._coordsAscending[p][L].push(E[L]);
            }
          }
          this._coordsAscendingStr = {};
          for (const p of s._order) {
            const m = s._layers[p], x = m.source;
            if (Gn[m.type] && !this._coordsAscendingStr[x]) {
              this._coordsAscendingStr[x] = {};
              for (const E in this._coordsAscending[x]) this._coordsAscendingStr[x][E] = this._coordsAscending[x][E].map((L) => L.key).sort().join();
            }
          }
          for (const p of this._renderableTiles) for (const m in this._coordsAscendingStr) {
            const x = this._coordsAscendingStr[m][p.tileID.key];
            x && x !== p.rttCoords[m] && (p.rtt = []);
          }
        }
        renderLayer(s, u) {
          if (s.isHidden(this.painter.transform.zoom)) return !1;
          const p = Object.assign(Object.assign({}, u), { isRenderingToTexture: !0 }), m = s.type, x = this.painter, E = this._renderableLayerIds[this._renderableLayerIds.length - 1] === s.id;
          if (Gn[m] && (this._prevType && Gn[this._prevType] || this._stacks.push([]), this._prevType = m, this._stacks[this._stacks.length - 1].push(s.id), !E)) return !0;
          if (Gn[this._prevType] || Gn[m] && E) {
            this._prevType = m;
            const L = this._stacks.length - 1, B = this._stacks[L] || [];
            for (const N of this._renderableTiles) {
              if (this.pool.isFull() && (Ah(this.painter, this.terrain, this._rttTiles, p), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(N), N.rtt[L]) {
                const Z = this.pool.getObjectForId(N.rtt[L].id);
                if (Z.stamp === N.rtt[L].stamp) {
                  this.pool.useObject(Z);
                  continue;
                }
              }
              const G = this.pool.getOrCreateFreeObject();
              this.pool.useObject(G), this.pool.stampObject(G), N.rtt[L] = { id: G.id, stamp: G.stamp }, x.context.bindFramebuffer.set(G.fbo.framebuffer), x.context.clear({ color: a.b5.transparent, stencil: 0 }), x.currentStencilSource = void 0;
              for (let Z = 0; Z < B.length; Z++) {
                const $ = x.style._layers[B[Z]], re = $.source ? this._coordsAscending[$.source][N.tileID.key] : [N.tileID];
                x.context.viewport.set([0, 0, G.fbo.width, G.fbo.height]), x._renderTileClippingMasks($, re, !0), x.renderLayer(x, x.style.sourceCaches[$.source], $, re, p), $.source && (N.rttCoords[$.source] = this._coordsAscendingStr[$.source][N.tileID.key]);
              }
            }
            return Ah(this.painter, this.terrain, this._rttTiles, p), this._rttTiles = [], this.pool.freeAllObjects(), Gn[m];
          }
          return !1;
        }
      }
      const Pr = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "MapLibre logo", "Map.Title": "Map", "Marker.Title": "Map marker", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "Popup.Close": "Close popup", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "GlobeControl.Enable": "Enable globe", "GlobeControl.Disable": "Disable globe", "TerrainControl.Enable": "Enable terrain", "TerrainControl.Disable": "Disable terrain", "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map", "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map", "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map" }, Yr = g, lr = { hash: !1, interactive: !0, bearingSnap: 7, attributionControl: yn, maplibreLogo: !1, refreshExpiredTiles: !0, canvasContextAttributes: { antialias: !1, preserveDrawingBuffer: !1, powerPreference: "high-performance", failIfMajorPerformanceCaveat: !1, desynchronized: !1, contextType: void 0 }, scrollZoom: !0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, boxZoom: !0, dragRotate: !0, dragPan: !0, keyboard: !0, doubleClickZoom: !0, touchZoomRotate: !0, touchPitch: !0, cooperativeGestures: !1, trackResize: !0, center: [0, 0], elevation: 0, zoom: 0, bearing: 0, pitch: 0, roll: 0, renderWorldCopies: !0, maxTileCacheSize: null, maxTileCacheZoomLevels: a.a.MAX_TILE_CACHE_ZOOM_LEVELS, transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: !0, clickTolerance: 3, localIdeographFontFamily: "sans-serif", pitchWithRotate: !0, rollEnabled: !1, validateStyle: !0, maxCanvasSize: [4096, 4096], cancelPendingTileRequestsWhileZooming: !0, centerClampedToGround: !0 }, Ss = { showCompass: !0, showZoom: !0, visualizePitch: !1, visualizeRoll: !0 };
      class Ri {
        constructor(s, u) {
          let p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
          this.mousedown = (x) => {
            this.startMove(x, S.mousePos(this.element, x)), S.addEventListener(window, "mousemove", this.mousemove), S.addEventListener(window, "mouseup", this.mouseup);
          }, this.mousemove = (x) => {
            this.move(x, S.mousePos(this.element, x));
          }, this.mouseup = (x) => {
            this._rotatePitchHanlder.dragEnd(x), this.offTemp();
          }, this.touchstart = (x) => {
            x.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = S.touchPos(this.element, x.targetTouches)[0], this.startMove(x, this._startPos), S.addEventListener(window, "touchmove", this.touchmove, { passive: !1 }), S.addEventListener(window, "touchend", this.touchend));
          }, this.touchmove = (x) => {
            x.targetTouches.length !== 1 ? this.reset() : (this._lastPos = S.touchPos(this.element, x.targetTouches)[0], this.move(x, this._lastPos));
          }, this.touchend = (x) => {
            x.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this.reset = () => {
            this._rotatePitchHanlder.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          }, this._clickTolerance = 10, this.element = u;
          const m = new mu();
          this._rotatePitchHanlder = new vn({ clickTolerance: 3, move: (x, E) => {
            const L = u.getBoundingClientRect(), B = new a.P((L.bottom - L.top) / 2, (L.right - L.left) / 2);
            return { bearingDelta: a.c8(new a.P(x.x, E.y), E, B), pitchDelta: p ? -0.5 * (E.y - x.y) : void 0 };
          }, moveStateManager: m, enable: !0, assignEvents: () => {
          } }), this.map = s, S.addEventListener(u, "mousedown", this.mousedown), S.addEventListener(u, "touchstart", this.touchstart, { passive: !1 }), S.addEventListener(u, "touchcancel", this.reset);
        }
        startMove(s, u) {
          this._rotatePitchHanlder.dragStart(s, u), S.disableDrag();
        }
        move(s, u) {
          const p = this.map, { bearingDelta: m, pitchDelta: x } = this._rotatePitchHanlder.dragMove(s, u) || {};
          m && p.setBearing(p.getBearing() + m), x && p.setPitch(p.getPitch() + x);
        }
        off() {
          const s = this.element;
          S.removeEventListener(s, "mousedown", this.mousedown), S.removeEventListener(s, "touchstart", this.touchstart, { passive: !1 }), S.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), S.removeEventListener(window, "touchend", this.touchend), S.removeEventListener(s, "touchcancel", this.reset), this.offTemp();
        }
        offTemp() {
          S.enableDrag(), S.removeEventListener(window, "mousemove", this.mousemove), S.removeEventListener(window, "mouseup", this.mouseup), S.removeEventListener(window, "touchmove", this.touchmove, { passive: !1 }), S.removeEventListener(window, "touchend", this.touchend);
        }
      }
      let Ir;
      function Jr(b, s, u) {
        const p = new a.O(b.lng, b.lat);
        if (b = new a.O(b.lng, b.lat), s) {
          const m = new a.O(b.lng - 360, b.lat), x = new a.O(b.lng + 360, b.lat), E = u.locationToScreenPoint(b).distSqr(s);
          u.locationToScreenPoint(m).distSqr(s) < E ? b = m : u.locationToScreenPoint(x).distSqr(s) < E && (b = x);
        }
        for (; Math.abs(b.lng - u.center.lng) > 180; ) {
          const m = u.locationToScreenPoint(b);
          if (m.x >= 0 && m.y >= 0 && m.x <= u.width && m.y <= u.height) break;
          b.lng > u.center.lng ? b.lng -= 360 : b.lng += 360;
        }
        return b.lng !== p.lng && u.isPointOnMapSurface(u.locationToScreenPoint(b)) ? b : p;
      }
      const xr = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
      function kr(b, s, u) {
        const p = b.classList;
        for (const m in xr) p.remove(`maplibregl-${u}-anchor-${m}`);
        p.add(`maplibregl-${u}-anchor-${s}`);
      }
      class jr extends a.E {
        constructor(s) {
          if (super(), this._onKeyPress = (u) => {
            const p = u.code, m = u.charCode || u.keyCode;
            p !== "Space" && p !== "Enter" && m !== 32 && m !== 13 || this.togglePopup();
          }, this._onMapClick = (u) => {
            const p = u.originalEvent.target, m = this._element;
            this._popup && (p === m || m.contains(p)) && this.togglePopup();
          }, this._update = (u) => {
            var p;
            if (!this._map) return;
            const m = this._map.loaded() && !this._map.isMoving();
            ((u == null ? void 0 : u.type) === "terrain" || (u == null ? void 0 : u.type) === "render" && !m) && this._map.once("render", this._update), this._lngLat = this._map.transform.renderWorldCopies ? Jr(this._lngLat, this._flatPos, this._map.transform) : (p = this._lngLat) === null || p === void 0 ? void 0 : p.wrap(), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
            let x = "";
            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? x = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (x = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
            let E = "";
            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? E = "rotateX(0deg)" : this._pitchAlignment === "map" && (E = `rotateX(${this._map.getPitch()}deg)`), this._subpixelPositioning || u && u.type !== "moveend" || (this._pos = this._pos.round()), S.setTransform(this._element, `${xr[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${E} ${x}`), I.frameAsync(new AbortController()).then(() => {
              this._updateOpacity(u && u.type === "moveend");
            }).catch(() => {
            });
          }, this._onMove = (u) => {
            if (!this._isDragging) {
              const p = this._clickTolerance || this._map._clickTolerance;
              this._isDragging = u.point.dist(this._pointerdownPos) >= p;
            }
            this._isDragging && (this._pos = u.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", this._state === "pending" && (this._state = "active", this.fire(new a.k("dragstart"))), this.fire(new a.k("drag")));
          }, this._onUp = () => {
            this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = !1, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), this._state === "active" && this.fire(new a.k("dragend")), this._state = "inactive";
          }, this._addDragHandler = (u) => {
            this._element.contains(u.originalEvent.target) && (u.preventDefault(), this._positionDelta = u.point.sub(this._pos).add(this._offset), this._pointerdownPos = u.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
          }, this._anchor = s && s.anchor || "center", this._color = s && s.color || "#3FB1CE", this._scale = s && s.scale || 1, this._draggable = s && s.draggable || !1, this._clickTolerance = s && s.clickTolerance || 0, this._subpixelPositioning = s && s.subpixelPositioning || !1, this._isDragging = !1, this._state = "inactive", this._rotation = s && s.rotation || 0, this._rotationAlignment = s && s.rotationAlignment || "auto", this._pitchAlignment = s && s.pitchAlignment && s.pitchAlignment !== "auto" ? s.pitchAlignment : this._rotationAlignment, this.setOpacity(s == null ? void 0 : s.opacity, s == null ? void 0 : s.opacityWhenCovered), s && s.element) this._element = s.element, this._offset = a.P.convert(s && s.offset || [0, 0]);
          else {
            this._defaultMarker = !0, this._element = S.create("div");
            const u = S.createNS("http://www.w3.org/2000/svg", "svg"), p = 41, m = 27;
            u.setAttributeNS(null, "display", "block"), u.setAttributeNS(null, "height", `${p}px`), u.setAttributeNS(null, "width", `${m}px`), u.setAttributeNS(null, "viewBox", `0 0 ${m} ${p}`);
            const x = S.createNS("http://www.w3.org/2000/svg", "g");
            x.setAttributeNS(null, "stroke", "none"), x.setAttributeNS(null, "stroke-width", "1"), x.setAttributeNS(null, "fill", "none"), x.setAttributeNS(null, "fill-rule", "evenodd");
            const E = S.createNS("http://www.w3.org/2000/svg", "g");
            E.setAttributeNS(null, "fill-rule", "nonzero");
            const L = S.createNS("http://www.w3.org/2000/svg", "g");
            L.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), L.setAttributeNS(null, "fill", "#000000");
            const B = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
            for (const Ie of B) {
              const Be = S.createNS("http://www.w3.org/2000/svg", "ellipse");
              Be.setAttributeNS(null, "opacity", "0.04"), Be.setAttributeNS(null, "cx", "10.5"), Be.setAttributeNS(null, "cy", "5.80029008"), Be.setAttributeNS(null, "rx", Ie.rx), Be.setAttributeNS(null, "ry", Ie.ry), L.appendChild(Be);
            }
            const N = S.createNS("http://www.w3.org/2000/svg", "g");
            N.setAttributeNS(null, "fill", this._color);
            const G = S.createNS("http://www.w3.org/2000/svg", "path");
            G.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), N.appendChild(G);
            const Z = S.createNS("http://www.w3.org/2000/svg", "g");
            Z.setAttributeNS(null, "opacity", "0.25"), Z.setAttributeNS(null, "fill", "#000000");
            const $ = S.createNS("http://www.w3.org/2000/svg", "path");
            $.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), Z.appendChild($);
            const re = S.createNS("http://www.w3.org/2000/svg", "g");
            re.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), re.setAttributeNS(null, "fill", "#FFFFFF");
            const ae = S.createNS("http://www.w3.org/2000/svg", "g");
            ae.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
            const Pe = S.createNS("http://www.w3.org/2000/svg", "circle");
            Pe.setAttributeNS(null, "fill", "#000000"), Pe.setAttributeNS(null, "opacity", "0.25"), Pe.setAttributeNS(null, "cx", "5.5"), Pe.setAttributeNS(null, "cy", "5.5"), Pe.setAttributeNS(null, "r", "5.4999962");
            const Ce = S.createNS("http://www.w3.org/2000/svg", "circle");
            Ce.setAttributeNS(null, "fill", "#FFFFFF"), Ce.setAttributeNS(null, "cx", "5.5"), Ce.setAttributeNS(null, "cy", "5.5"), Ce.setAttributeNS(null, "r", "5.4999962"), ae.appendChild(Pe), ae.appendChild(Ce), E.appendChild(L), E.appendChild(N), E.appendChild(Z), E.appendChild(re), E.appendChild(ae), u.appendChild(E), u.setAttributeNS(null, "height", p * this._scale + "px"), u.setAttributeNS(null, "width", m * this._scale + "px"), this._element.appendChild(u), this._offset = a.P.convert(s && s.offset || [0, -14]);
          }
          if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (u) => {
            u.preventDefault();
          }), this._element.addEventListener("mousedown", (u) => {
            u.preventDefault();
          }), kr(this._element, this._anchor, "marker"), s && s.className) for (const u of s.className.split(" ")) this._element.classList.add(u);
          this._popup = null;
        }
        addTo(s) {
          return this.remove(), this._map = s, this._element.setAttribute("aria-label", s._getUIString("Marker.Title")), s.getCanvasContainer().appendChild(this._element), s.on("move", this._update), s.on("moveend", this._update), s.on("terrain", this._update), s.on("projectiontransition", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
        }
        remove() {
          return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("terrain", this._update), this._map.off("projectiontransition", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), S.remove(this._element), this._popup && this._popup.remove(), this;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(s) {
          return this._lngLat = a.O.convert(s), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
        }
        getElement() {
          return this._element;
        }
        setPopup(s) {
          if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), s) {
            if (!("offset" in s.options)) {
              const m = Math.abs(13.5) / Math.SQRT2;
              s.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [m, -1 * (38.1 - 13.5 + m)], "bottom-right": [-m, -1 * (38.1 - 13.5 + m)], left: [13.5, -1 * (38.1 - 13.5)], right: [-13.5, -1 * (38.1 - 13.5)] } : this._offset;
            }
            this._popup = s, this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
          }
          return this;
        }
        setSubpixelPositioning(s) {
          return this._subpixelPositioning = s, this;
        }
        getPopup() {
          return this._popup;
        }
        togglePopup() {
          const s = this._popup;
          return this._element.style.opacity === this._opacityWhenCovered ? this : s ? (s.isOpen() ? s.remove() : (s.setLngLat(this._lngLat), s.addTo(this._map)), this) : this;
        }
        _updateOpacity() {
          let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
          var u, p;
          if (!(!((u = this._map) === null || u === void 0) && u.terrain)) {
            const Z = this._map.transform.isLocationOccluded(this._lngLat) ? this._opacityWhenCovered : this._opacity;
            return void (this._element.style.opacity !== Z && (this._element.style.opacity = Z));
          }
          if (s) this._opacityTimeout = null;
          else {
            if (this._opacityTimeout) return;
            this._opacityTimeout = setTimeout(() => {
              this._opacityTimeout = null;
            }, 100);
          }
          const m = this._map, x = m.terrain.depthAtPoint(this._pos), E = m.terrain.getElevationForLngLatZoom(this._lngLat, m.transform.tileZoom);
          if (m.transform.lngLatToCameraDepth(this._lngLat, E) - x < 6e-3) return void (this._element.style.opacity = this._opacity);
          const L = -this._offset.y / m.transform.pixelsPerMeter, B = Math.sin(m.getPitch() * Math.PI / 180) * L, N = m.terrain.depthAtPoint(new a.P(this._pos.x, this._pos.y - this._offset.y)), G = m.transform.lngLatToCameraDepth(this._lngLat, E + B) - N > 6e-3;
          !((p = this._popup) === null || p === void 0) && p.isOpen() && G && this._popup.remove(), this._element.style.opacity = G ? this._opacityWhenCovered : this._opacity;
        }
        getOffset() {
          return this._offset;
        }
        setOffset(s) {
          return this._offset = a.P.convert(s), this._update(), this;
        }
        addClassName(s) {
          this._element.classList.add(s);
        }
        removeClassName(s) {
          this._element.classList.remove(s);
        }
        toggleClassName(s) {
          return this._element.classList.toggle(s);
        }
        setDraggable(s) {
          return this._draggable = !!s, this._map && (s ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
        }
        isDraggable() {
          return this._draggable;
        }
        setRotation(s) {
          return this._rotation = s || 0, this._update(), this;
        }
        getRotation() {
          return this._rotation;
        }
        setRotationAlignment(s) {
          return this._rotationAlignment = s || "auto", this._update(), this;
        }
        getRotationAlignment() {
          return this._rotationAlignment;
        }
        setPitchAlignment(s) {
          return this._pitchAlignment = s && s !== "auto" ? s : this._rotationAlignment, this._update(), this;
        }
        getPitchAlignment() {
          return this._pitchAlignment;
        }
        setOpacity(s, u) {
          return (this._opacity === void 0 || s === void 0 && u === void 0) && (this._opacity = "1", this._opacityWhenCovered = "0.2"), s !== void 0 && (this._opacity = s), u !== void 0 && (this._opacityWhenCovered = u), this._map && this._updateOpacity(!0), this;
        }
      }
      const no = { positionOptions: { enableHighAccuracy: !1, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: !1, showAccuracyCircle: !0, showUserLocation: !0 };
      let Fs = 0, cr = !1;
      const na = { maxWidth: 100, unit: "metric" };
      function va(b, s, u) {
        const p = u && u.maxWidth || 100, m = b._container.clientHeight / 2, x = b._container.clientWidth / 2, E = b.unproject([x - p / 2, m]), L = b.unproject([x + p / 2, m]), B = Math.round(b.project(L).x - b.project(E).x), N = Math.min(p, B, b._container.clientWidth), G = E.distanceTo(L);
        if (u && u.unit === "imperial") {
          const Z = 3.2808 * G;
          Z > 5280 ? yo(s, N, Z / 5280, b._getUIString("ScaleControl.Miles")) : yo(s, N, Z, b._getUIString("ScaleControl.Feet"));
        } else u && u.unit === "nautical" ? yo(s, N, G / 1852, b._getUIString("ScaleControl.NauticalMiles")) : G >= 1e3 ? yo(s, N, G / 1e3, b._getUIString("ScaleControl.Kilometers")) : yo(s, N, G, b._getUIString("ScaleControl.Meters"));
      }
      function yo(b, s, u, p) {
        const m = function(x) {
          const E = Math.pow(10, `${Math.floor(x)}`.length - 1);
          let L = x / E;
          return L = L >= 10 ? 10 : L >= 5 ? 5 : L >= 3 ? 3 : L >= 2 ? 2 : L >= 1 ? 1 : function(B) {
            const N = Math.pow(10, Math.ceil(-Math.log(B) / Math.LN10));
            return Math.round(B * N) / N;
          }(L), E * L;
        }(u);
        b.style.width = s * (m / u) + "px", b.innerHTML = `${m}&nbsp;${p}`;
      }
      const xa = { closeButton: !0, closeOnClick: !0, focusAfterOpen: !0, className: "", maxWidth: "240px", subpixelPositioning: !1 }, ur = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
      function nc(b) {
        if (b) {
          if (typeof b == "number") {
            const s = Math.round(Math.abs(b) / Math.SQRT2);
            return { center: new a.P(0, 0), top: new a.P(0, b), "top-left": new a.P(s, s), "top-right": new a.P(-s, s), bottom: new a.P(0, -b), "bottom-left": new a.P(s, -s), "bottom-right": new a.P(-s, -s), left: new a.P(b, 0), right: new a.P(-b, 0) };
          }
          if (b instanceof a.P || Array.isArray(b)) {
            const s = a.P.convert(b);
            return { center: s, top: s, "top-left": s, "top-right": s, bottom: s, "bottom-left": s, "bottom-right": s, left: s, right: s };
          }
          return { center: a.P.convert(b.center || [0, 0]), top: a.P.convert(b.top || [0, 0]), "top-left": a.P.convert(b["top-left"] || [0, 0]), "top-right": a.P.convert(b["top-right"] || [0, 0]), bottom: a.P.convert(b.bottom || [0, 0]), "bottom-left": a.P.convert(b["bottom-left"] || [0, 0]), "bottom-right": a.P.convert(b["bottom-right"] || [0, 0]), left: a.P.convert(b.left || [0, 0]), right: a.P.convert(b.right || [0, 0]) };
        }
        return nc(new a.P(0, 0));
      }
      const Wu = g;
      c.AJAXError = a.ch, c.Event = a.k, c.Evented = a.E, c.LngLat = a.O, c.MercatorCoordinate = a.Z, c.Point = a.P, c.addProtocol = a.ci, c.config = a.a, c.removeProtocol = a.cj, c.AttributionControl = jn, c.BoxZoomHandler = kc, c.CanvasSource = _n, c.CooperativeGesturesHandler = nt, c.DoubleClickZoomHandler = tt, c.DragPanHandler = ct, c.DragRotateHandler = qt, c.EdgeInsets = Rn, c.FullscreenControl = class extends a.E {
        constructor() {
          let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          super(), this._onFullscreenChange = () => {
            var s;
            let u = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
            for (; !((s = u == null ? void 0 : u.shadowRoot) === null || s === void 0) && s.fullscreenElement; ) u = u.shadowRoot.fullscreenElement;
            u === this._container !== this._fullscreen && this._handleFullscreenChange();
          }, this._onClickFullscreen = () => {
            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
          }, this._fullscreen = !1, b && b.container && (b.container instanceof HTMLElement ? this._container = b.container : a.w("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
        }
        onAdd(b) {
          return this._map = b, this._container || (this._container = this._map.getContainer()), this._controlContainer = S.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
        }
        onRemove() {
          S.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _setupUI() {
          const b = this._fullscreenButton = S.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
          S.create("span", "maplibregl-ctrl-icon", b).setAttribute("aria-hidden", "true"), b.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
        }
        _updateTitle() {
          const b = this._getTitle();
          this._fullscreenButton.setAttribute("aria-label", b), this._fullscreenButton.title = b;
        }
        _getTitle() {
          return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
        }
        _isFullscreen() {
          return this._fullscreen;
        }
        _handleFullscreenChange() {
          this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new a.k("fullscreenstart")), this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(), this._map.cooperativeGestures.disable()) : (this.fire(new a.k("fullscreenend")), this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable());
        }
        _exitFullscreen() {
          window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
        }
        _requestFullscreen() {
          this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
        }
        _togglePseudoFullScreen() {
          this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
        }
      }, c.GeoJSONSource = en, c.GeolocateControl = class extends a.E {
        constructor(b) {
          super(), this._onSuccess = (s) => {
            if (this._map) {
              if (this._isOutOfMapMaxBounds(s)) return this._setErrorState(), this.fire(new a.k("outofmaxbounds", s)), this._updateMarker(), void this._finish();
              if (this.options.trackUserLocation) switch (this._lastKnownPosition = s, this._watchState) {
                case "WAITING_ACTIVE":
                case "ACTIVE_LOCK":
                case "ACTIVE_ERROR":
                  this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                  break;
                case "BACKGROUND":
                case "BACKGROUND_ERROR":
                  this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
              this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(s), this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(s), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new a.k("geolocate", s)), this._finish();
            }
          }, this._updateCamera = (s) => {
            const u = new a.O(s.coords.longitude, s.coords.latitude), p = s.coords.accuracy, m = this._map.getBearing(), x = a.e({ bearing: m }, this.options.fitBoundsOptions), E = wn.fromLngLat(u, p);
            this._map.fitBounds(E, x, { geolocateSource: !0 });
          }, this._updateMarker = (s) => {
            if (s) {
              const u = new a.O(s.coords.longitude, s.coords.latitude);
              this._accuracyCircleMarker.setLngLat(u).addTo(this._map), this._userLocationDotMarker.setLngLat(u).addTo(this._map), this._accuracy = s.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
          }, this._onZoom = () => {
            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
          }, this._onError = (s) => {
            if (this._map) {
              if (this.options.trackUserLocation) if (s.code === 1) {
                this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = !0;
                const u = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.title = u, this._geolocateButton.setAttribute("aria-label", u), this._geolocationWatchID !== void 0 && this._clearWatch();
              } else {
                if (s.code === 3 && cr) return;
                this._setErrorState();
              }
              this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new a.k("error", s)), this._finish();
            }
          }, this._finish = () => {
            this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
          }, this._setupUI = () => {
            this._map && (this._container.addEventListener("contextmenu", (s) => s.preventDefault()), this._geolocateButton = S.create("button", "maplibregl-ctrl-geolocate", this._container), S.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", this._geolocateButton.disabled = !0);
          }, this._finishSetupUI = (s) => {
            if (this._map) {
              if (s === !1) {
                a.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                const u = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = !0, this._geolocateButton.title = u, this._geolocateButton.setAttribute("aria-label", u);
              } else {
                const u = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.disabled = !1, this._geolocateButton.title = u, this._geolocateButton.setAttribute("aria-label", u);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = S.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new jr({ element: this._dotElement }), this._circleElement = S.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new jr({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", () => this.trigger()), this._setup = !0, this.options.trackUserLocation && this._map.on("movestart", (u) => {
                u.geolocateSource || this._watchState !== "ACTIVE_LOCK" || u.originalEvent && u.originalEvent.type === "resize" || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new a.k("trackuserlocationend")), this.fire(new a.k("userlocationlostfocus")));
              });
            }
          }, this.options = a.e({}, no, b);
        }
        onAdd(b) {
          return this._map = b, this._container = S.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), function() {
            return a._(this, arguments, void 0, function() {
              let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
              return function* () {
                if (Ir !== void 0 && !s) return Ir;
                if (window.navigator.permissions === void 0) return Ir = !!window.navigator.geolocation, Ir;
                try {
                  Ir = (yield window.navigator.permissions.query({ name: "geolocation" })).state !== "denied";
                } catch {
                  Ir = !!window.navigator.geolocation;
                }
                return Ir;
              }();
            });
          }().then((s) => this._finishSetupUI(s)), this._container;
        }
        onRemove() {
          this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), S.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fs = 0, cr = !1;
        }
        _isOutOfMapMaxBounds(b) {
          const s = this._map.getMaxBounds(), u = b.coords;
          return s && (u.longitude < s.getWest() || u.longitude > s.getEast() || u.latitude < s.getSouth() || u.latitude > s.getNorth());
        }
        _setErrorState() {
          switch (this._watchState) {
            case "WAITING_ACTIVE":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
              break;
            case "ACTIVE_LOCK":
              this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "BACKGROUND":
              this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
              break;
            case "ACTIVE_ERROR":
              break;
            default:
              throw new Error(`Unexpected watchState ${this._watchState}`);
          }
        }
        _updateCircleRadius() {
          const b = this._map.getBounds(), s = b.getSouthEast(), u = b.getNorthEast(), p = s.distanceTo(u), m = Math.ceil(this._accuracy / (p / this._map._container.clientHeight) * 2);
          this._circleElement.style.width = `${m}px`, this._circleElement.style.height = `${m}px`;
        }
        trigger() {
          if (!this._setup) return a.w("Geolocate control triggered before added to a map"), !1;
          if (this.options.trackUserLocation) {
            switch (this._watchState) {
              case "OFF":
                this._watchState = "WAITING_ACTIVE", this.fire(new a.k("trackuserlocationstart"));
                break;
              case "WAITING_ACTIVE":
              case "ACTIVE_LOCK":
              case "ACTIVE_ERROR":
              case "BACKGROUND_ERROR":
                Fs--, cr = !1, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new a.k("trackuserlocationend"));
                break;
              case "BACKGROUND":
                this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new a.k("trackuserlocationstart")), this.fire(new a.k("userlocationfocus"));
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            switch (this._watchState) {
              case "WAITING_ACTIVE":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "ACTIVE_LOCK":
                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                break;
              case "OFF":
                break;
              default:
                throw new Error(`Unexpected watchState ${this._watchState}`);
            }
            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0) this._clearWatch();
            else if (this._geolocationWatchID === void 0) {
              let b;
              this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Fs++, Fs > 1 ? (b = { maximumAge: 6e5, timeout: 0 }, cr = !0) : (b = this.options.positionOptions, cr = !1), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, b);
            }
          } else window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
          return !0;
        }
        _clearWatch() {
          window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
        }
      }, c.GlobeControl = class {
        constructor() {
          this._toggleProjection = () => {
            var b;
            const s = (b = this._map.getProjection()) === null || b === void 0 ? void 0 : b.type;
            this._map.setProjection(s !== "mercator" && s ? { type: "mercator" } : { type: "globe" }), this._updateGlobeIcon();
          }, this._updateGlobeIcon = () => {
            var b;
            this._globeButton.classList.remove("maplibregl-ctrl-globe"), this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"), ((b = this._map.getProjection()) === null || b === void 0 ? void 0 : b.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"), this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"), this._globeButton.title = this._map._getUIString("GlobeControl.Enable"));
          };
        }
        onAdd(b) {
          return this._map = b, this._container = S.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._globeButton = S.create("button", "maplibregl-ctrl-globe", this._container), S.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"), this._globeButton.type = "button", this._globeButton.addEventListener("click", this._toggleProjection), this._updateGlobeIcon(), this._map.on("styledata", this._updateGlobeIcon), this._container;
        }
        onRemove() {
          S.remove(this._container), this._map.off("styledata", this._updateGlobeIcon), this._globeButton.removeEventListener("click", this._toggleProjection), this._map = void 0;
        }
      }, c.Hash = ya, c.ImageSource = ln, c.KeyboardHandler = he, c.LngLatBounds = wn, c.LogoControl = xn, c.Map = class extends Ut {
        constructor(b) {
          var s, u;
          a.ce.mark(a.cf.create);
          const p = Object.assign(Object.assign(Object.assign({}, lr), b), { canvasContextAttributes: Object.assign(Object.assign({}, lr.canvasContextAttributes), b.canvasContextAttributes) });
          if (p.minZoom != null && p.maxZoom != null && p.minZoom > p.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
          if (p.minPitch != null && p.maxPitch != null && p.minPitch > p.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
          if (p.minPitch != null && p.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (p.maxPitch != null && p.maxPitch > 180) throw new Error("maxPitch must be less than or equal to 180");
          const m = new Vn(), x = new Ll();
          if (p.minZoom !== void 0 && m.setMinZoom(p.minZoom), p.maxZoom !== void 0 && m.setMaxZoom(p.maxZoom), p.minPitch !== void 0 && m.setMinPitch(p.minPitch), p.maxPitch !== void 0 && m.setMaxPitch(p.maxPitch), p.renderWorldCopies !== void 0 && m.setRenderWorldCopies(p.renderWorldCopies), super(m, x, { bearingSnap: p.bearingSnap }), this._idleTriggered = !1, this._crossFadingFactor = 1, this._renderTaskQueue = new ri(), this._controls = [], this._mapId = a.a2(), this._contextLost = (L) => {
            L.preventDefault(), this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this.fire(new a.k("webglcontextlost", { originalEvent: L }));
          }, this._contextRestored = (L) => {
            this._setupPainter(), this.resize(), this._update(), this.fire(new a.k("webglcontextrestored", { originalEvent: L }));
          }, this._onMapScroll = (L) => {
            if (L.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, !1;
          }, this._onWindowOnline = () => {
            this._update();
          }, this._interactive = p.interactive, this._maxTileCacheSize = p.maxTileCacheSize, this._maxTileCacheZoomLevels = p.maxTileCacheZoomLevels, this._canvasContextAttributes = Object.assign({}, p.canvasContextAttributes), this._trackResize = p.trackResize === !0, this._bearingSnap = p.bearingSnap, this._centerClampedToGround = p.centerClampedToGround, this._refreshExpiredTiles = p.refreshExpiredTiles === !0, this._fadeDuration = p.fadeDuration, this._crossSourceCollisions = p.crossSourceCollisions === !0, this._collectResourceTiming = p.collectResourceTiming === !0, this._locale = Object.assign(Object.assign({}, Pr), p.locale), this._clickTolerance = p.clickTolerance, this._overridePixelRatio = p.pixelRatio, this._maxCanvasSize = p.maxCanvasSize, this.transformCameraUpdate = p.transformCameraUpdate, this.cancelPendingTileRequestsWhileZooming = p.cancelPendingTileRequestsWhileZooming === !0, this._imageQueueHandle = ie.addThrottleControl(() => this.isMoving()), this._requestManager = new fe(p.transformRequest), typeof p.container == "string") {
            if (this._container = document.getElementById(p.container), !this._container) throw new Error(`Container '${p.container}' not found.`);
          } else {
            if (!(p.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
            this._container = p.container;
          }
          if (p.maxBounds && this.setMaxBounds(p.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(!1)), this.on("moveend", () => this._update(!1)), this.on("zoom", () => this._update(!0)), this.on("terrain", () => {
            this.painter.terrainFacilitator.dirty = !0, this._update(!0);
          }), this.once("idle", () => {
            this._idleTriggered = !0;
          }), typeof window < "u") {
            addEventListener("online", this._onWindowOnline, !1);
            let L = !1;
            const B = ml((N) => {
              this._trackResize && !this._removed && (this.resize(N), this.redraw());
            }, 50);
            this._resizeObserver = new ResizeObserver((N) => {
              L ? B(N) : L = !0;
            }), this._resizeObserver.observe(this._container);
          }
          this.handlers = new ft(this, p), this._hash = p.hash && new ya(typeof p.hash == "string" && p.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: p.center, elevation: p.elevation, zoom: p.zoom, bearing: p.bearing, pitch: p.pitch, roll: p.roll }), p.bounds && (this.resize(), this.fitBounds(p.bounds, a.e({}, p.fitBoundsOptions, { duration: 0 }))));
          const E = typeof p.style == "string" || ((u = (s = p.style) === null || s === void 0 ? void 0 : s.projection) === null || u === void 0 ? void 0 : u.type) !== "globe";
          this.resize(null, E), this._localIdeographFontFamily = p.localIdeographFontFamily, this._validateStyle = p.validateStyle, p.style && this.setStyle(p.style, { localIdeographFontFamily: p.localIdeographFontFamily }), p.attributionControl && this.addControl(new jn(typeof p.attributionControl == "boolean" ? void 0 : p.attributionControl)), p.maplibreLogo && this.addControl(new xn(), p.logoPosition), this.on("style.load", () => {
            if (E || this._resizeTransform(), this.transform.unmodified) {
              const L = a.N(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
              this.jumpTo(L);
            }
          }), this.on("data", (L) => {
            this._update(L.dataType === "style"), this.fire(new a.k(`${L.dataType}data`, L));
          }), this.on("dataloading", (L) => {
            this.fire(new a.k(`${L.dataType}dataloading`, L));
          }), this.on("dataabort", (L) => {
            this.fire(new a.k("sourcedataabort", L));
          });
        }
        _getMapId() {
          return this._mapId;
        }
        addControl(b, s) {
          if (s === void 0 && (s = b.getDefaultPosition ? b.getDefaultPosition() : "top-right"), !b || !b.onAdd) return this.fire(new a.j(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
          const u = b.onAdd(this);
          this._controls.push(b);
          const p = this._controlPositions[s];
          return s.indexOf("bottom") !== -1 ? p.insertBefore(u, p.firstChild) : p.appendChild(u), this;
        }
        removeControl(b) {
          if (!b || !b.onRemove) return this.fire(new a.j(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
          const s = this._controls.indexOf(b);
          return s > -1 && this._controls.splice(s, 1), b.onRemove(this), this;
        }
        hasControl(b) {
          return this._controls.indexOf(b) > -1;
        }
        calculateCameraOptionsFromTo(b, s, u, p) {
          return p == null && this.terrain && (p = this.terrain.getElevationForLngLatZoom(u, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(b, s, u, p);
        }
        resize(b) {
          let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
          const [u, p] = this._containerDimensions(), m = this._getClampedPixelRatio(u, p);
          if (this._resizeCanvas(u, p, m), this.painter.resize(u, p, m), this.painter.overLimit()) {
            const E = this.painter.context.gl;
            this._maxCanvasSize = [E.drawingBufferWidth, E.drawingBufferHeight];
            const L = this._getClampedPixelRatio(u, p);
            this._resizeCanvas(u, p, L), this.painter.resize(u, p, L);
          }
          this._resizeTransform(s);
          const x = !this._moving;
          return x && (this.stop(), this.fire(new a.k("movestart", b)).fire(new a.k("move", b))), this.fire(new a.k("resize", b)), x && this.fire(new a.k("moveend", b)), this;
        }
        _resizeTransform() {
          let b = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
          var s;
          const [u, p] = this._containerDimensions();
          this.transform.resize(u, p, b), (s = this._requestedCameraState) === null || s === void 0 || s.resize(u, p, b);
        }
        _getClampedPixelRatio(b, s) {
          const { 0: u, 1: p } = this._maxCanvasSize, m = this.getPixelRatio(), x = b * m, E = s * m;
          return Math.min(x > u ? u / x : 1, E > p ? p / E : 1) * m;
        }
        getPixelRatio() {
          var b;
          return (b = this._overridePixelRatio) !== null && b !== void 0 ? b : devicePixelRatio;
        }
        setPixelRatio(b) {
          this._overridePixelRatio = b, this.resize();
        }
        getBounds() {
          return this.transform.getBounds();
        }
        getMaxBounds() {
          return this.transform.getMaxBounds();
        }
        setMaxBounds(b) {
          return this.transform.setMaxBounds(wn.convert(b)), this._update();
        }
        setMinZoom(b) {
          if ((b = b ?? -2) >= -2 && b <= this.transform.maxZoom) return this.transform.setMinZoom(b), this._update(), this.getZoom() < b && this.setZoom(b), this;
          throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
        }
        getMinZoom() {
          return this.transform.minZoom;
        }
        setMaxZoom(b) {
          if ((b = b ?? 22) >= this.transform.minZoom) return this.transform.setMaxZoom(b), this._update(), this.getZoom() > b && this.setZoom(b), this;
          throw new Error("maxZoom must be greater than the current minZoom");
        }
        getMaxZoom() {
          return this.transform.maxZoom;
        }
        setMinPitch(b) {
          if ((b = b ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
          if (b >= 0 && b <= this.transform.maxPitch) return this.transform.setMinPitch(b), this._update(), this.getPitch() < b && this.setPitch(b), this;
          throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
        }
        getMinPitch() {
          return this.transform.minPitch;
        }
        setMaxPitch(b) {
          if ((b = b ?? 60) > 180) throw new Error("maxPitch must be less than or equal to 180");
          if (b >= this.transform.minPitch) return this.transform.setMaxPitch(b), this._update(), this.getPitch() > b && this.setPitch(b), this;
          throw new Error("maxPitch must be greater than the current minPitch");
        }
        getMaxPitch() {
          return this.transform.maxPitch;
        }
        getRenderWorldCopies() {
          return this.transform.renderWorldCopies;
        }
        setRenderWorldCopies(b) {
          return this.transform.setRenderWorldCopies(b), this._update();
        }
        project(b) {
          return this.transform.locationToScreenPoint(a.O.convert(b), this.style && this.terrain);
        }
        unproject(b) {
          return this.transform.screenPointToLocation(a.P.convert(b), this.terrain);
        }
        isMoving() {
          var b;
          return this._moving || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isMoving());
        }
        isZooming() {
          var b;
          return this._zooming || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isZooming());
        }
        isRotating() {
          var b;
          return this._rotating || ((b = this.handlers) === null || b === void 0 ? void 0 : b.isRotating());
        }
        _createDelegatedListener(b, s, u) {
          if (b === "mouseenter" || b === "mouseover") {
            let p = !1;
            return { layers: s, listener: u, delegates: { mousemove: (x) => {
              const E = s.filter((B) => this.getLayer(B)), L = E.length !== 0 ? this.queryRenderedFeatures(x.point, { layers: E }) : [];
              L.length ? p || (p = !0, u.call(this, new pr(b, this, x.originalEvent, { features: L }))) : p = !1;
            }, mouseout: () => {
              p = !1;
            } } };
          }
          if (b === "mouseleave" || b === "mouseout") {
            let p = !1;
            return { layers: s, listener: u, delegates: { mousemove: (E) => {
              const L = s.filter((B) => this.getLayer(B));
              (L.length !== 0 ? this.queryRenderedFeatures(E.point, { layers: L }) : []).length ? p = !0 : p && (p = !1, u.call(this, new pr(b, this, E.originalEvent)));
            }, mouseout: (E) => {
              p && (p = !1, u.call(this, new pr(b, this, E.originalEvent)));
            } } };
          }
          {
            const p = (m) => {
              const x = s.filter((L) => this.getLayer(L)), E = x.length !== 0 ? this.queryRenderedFeatures(m.point, { layers: x }) : [];
              E.length && (m.features = E, u.call(this, m), delete m.features);
            };
            return { layers: s, listener: u, delegates: { [b]: p } };
          }
        }
        _saveDelegatedListener(b, s) {
          this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[b] = this._delegatedListeners[b] || [], this._delegatedListeners[b].push(s);
        }
        _removeDelegatedListener(b, s, u) {
          if (!this._delegatedListeners || !this._delegatedListeners[b]) return;
          const p = this._delegatedListeners[b];
          for (let m = 0; m < p.length; m++) {
            const x = p[m];
            if (x.listener === u && x.layers.length === s.length && x.layers.every((E) => s.includes(E))) {
              for (const E in x.delegates) this.off(E, x.delegates[E]);
              return void p.splice(m, 1);
            }
          }
        }
        on(b, s, u) {
          if (u === void 0) return super.on(b, s);
          const p = typeof s == "string" ? [s] : s, m = this._createDelegatedListener(b, p, u);
          this._saveDelegatedListener(b, m);
          for (const x in m.delegates) this.on(x, m.delegates[x]);
          return { unsubscribe: () => {
            this._removeDelegatedListener(b, p, u);
          } };
        }
        once(b, s, u) {
          var p = this;
          if (u === void 0) return super.once(b, s);
          const m = typeof s == "string" ? [s] : s, x = this._createDelegatedListener(b, m, u);
          for (const E in x.delegates) {
            const L = x.delegates[E];
            x.delegates[E] = function() {
              p._removeDelegatedListener(b, m, u), L(...arguments);
            };
          }
          this._saveDelegatedListener(b, x);
          for (const E in x.delegates) this.once(E, x.delegates[E]);
          return this;
        }
        off(b, s, u) {
          return u === void 0 ? super.off(b, s) : (this._removeDelegatedListener(b, typeof s == "string" ? [s] : s, u), this);
        }
        queryRenderedFeatures(b, s) {
          if (!this.style) return [];
          let u;
          const p = b instanceof a.P || Array.isArray(b), m = p ? b : [[0, 0], [this.transform.width, this.transform.height]];
          if (s = s || (p ? {} : b) || {}, m instanceof a.P || typeof m[0] == "number") u = [a.P.convert(m)];
          else {
            const x = a.P.convert(m[0]), E = a.P.convert(m[1]);
            u = [x, new a.P(E.x, x.y), E, new a.P(x.x, E.y), x];
          }
          return this.style.queryRenderedFeatures(u, s, this.transform);
        }
        querySourceFeatures(b, s) {
          return this.style.querySourceFeatures(b, s);
        }
        setStyle(b, s) {
          return (s = a.e({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, s)).diff !== !1 && s.localIdeographFontFamily === this._localIdeographFontFamily && this.style && b ? (this._diffStyle(b, s), this) : (this._localIdeographFontFamily = s.localIdeographFontFamily, this._updateStyle(b, s));
        }
        setTransformRequest(b) {
          return this._requestManager.setTransformRequest(b), this;
        }
        _getUIString(b) {
          const s = this._locale[b];
          if (s == null) throw new Error(`Missing UI string '${b}'`);
          return s;
        }
        _updateStyle(b, s) {
          var u, p;
          if (s.transformStyle && this.style && !this.style._loaded) return void this.style.once("style.load", () => this._updateStyle(b, s));
          const m = this.style && s.transformStyle ? this.style.serialize() : void 0;
          return this.style && (this.style.setEventedParent(null), this.style._remove(!b)), b ? (this.style = new us(this, s || {}), this.style.setEventedParent(this, { style: this.style }), typeof b == "string" ? this.style.loadURL(b, s, m) : this.style.loadJSON(b, s, m), this) : ((p = (u = this.style) === null || u === void 0 ? void 0 : u.projection) === null || p === void 0 || p.destroy(), delete this.style, this);
        }
        _lazyInitEmptyStyle() {
          this.style || (this.style = new us(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
        }
        _diffStyle(b, s) {
          if (typeof b == "string") {
            const u = this._requestManager.transformRequest(b, "Style");
            a.h(u, new AbortController()).then((p) => {
              this._updateDiff(p.data, s);
            }).catch((p) => {
              p && this.fire(new a.j(p));
            });
          } else typeof b == "object" && this._updateDiff(b, s);
        }
        _updateDiff(b, s) {
          try {
            this.style.setState(b, s) && this._update(!0);
          } catch (u) {
            a.w(`Unable to perform style diff: ${u.message || u.error || u}.  Rebuilding the style from scratch.`), this._updateStyle(b, s);
          }
        }
        getStyle() {
          if (this.style) return this.style.serialize();
        }
        isStyleLoaded() {
          return this.style ? this.style.loaded() : a.w("There is no style added to the map.");
        }
        addSource(b, s) {
          return this._lazyInitEmptyStyle(), this.style.addSource(b, s), this._update(!0);
        }
        isSourceLoaded(b) {
          const s = this.style && this.style.sourceCaches[b];
          if (s !== void 0) return s.loaded();
          this.fire(new a.j(new Error(`There is no source with ID '${b}'`)));
        }
        setTerrain(b) {
          if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), b) {
            const s = this.style.sourceCaches[b.source];
            if (!s) throw new Error(`cannot load terrain, because there exists no source with ID: ${b.source}`);
            this.terrain === null && s.reload();
            for (const u in this.style._layers) {
              const p = this.style._layers[u];
              p.type === "hillshade" && p.source === b.source && a.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
            }
            this.terrain = new Ai(this.painter, s, b), this.painter.renderToTexture = new Bn(this.painter, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._terrainDataCallback = (u) => {
              u.dataType === "style" ? this.terrain.sourceCache.freeRtt() : u.dataType === "source" && u.tile && (u.sourceId !== b.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))), this.terrain.sourceCache.freeRtt(u.tile.tileID));
            }, this.style.on("data", this._terrainDataCallback);
          } else this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0);
          return this.fire(new a.k("terrain", { terrain: b })), this;
        }
        getTerrain() {
          var b, s;
          return (s = (b = this.terrain) === null || b === void 0 ? void 0 : b.options) !== null && s !== void 0 ? s : null;
        }
        areTilesLoaded() {
          const b = this.style && this.style.sourceCaches;
          for (const s in b) {
            const u = b[s]._tiles;
            for (const p in u) {
              const m = u[p];
              if (m.state !== "loaded" && m.state !== "errored") return !1;
            }
          }
          return !0;
        }
        removeSource(b) {
          return this.style.removeSource(b), this._update(!0);
        }
        getSource(b) {
          return this.style.getSource(b);
        }
        addImage(b, s) {
          let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          const { pixelRatio: p = 1, sdf: m = !1, stretchX: x, stretchY: E, content: L, textFitWidth: B, textFitHeight: N } = u;
          if (this._lazyInitEmptyStyle(), !(s instanceof HTMLImageElement || a.b(s))) {
            if (s.width === void 0 || s.height === void 0) return this.fire(new a.j(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
            {
              const { width: G, height: Z, data: $ } = s, re = s;
              return this.style.addImage(b, { data: new a.R({ width: G, height: Z }, new Uint8Array($)), pixelRatio: p, stretchX: x, stretchY: E, content: L, textFitWidth: B, textFitHeight: N, sdf: m, version: 0, userImage: re }), re.onAdd && re.onAdd(this, b), this;
            }
          }
          {
            const { width: G, height: Z, data: $ } = I.getImageData(s);
            this.style.addImage(b, { data: new a.R({ width: G, height: Z }, $), pixelRatio: p, stretchX: x, stretchY: E, content: L, textFitWidth: B, textFitHeight: N, sdf: m, version: 0 });
          }
        }
        updateImage(b, s) {
          const u = this.style.getImage(b);
          if (!u) return this.fire(new a.j(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
          const p = s instanceof HTMLImageElement || a.b(s) ? I.getImageData(s) : s, { width: m, height: x, data: E } = p;
          if (m === void 0 || x === void 0) return this.fire(new a.j(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
          if (m !== u.data.width || x !== u.data.height) return this.fire(new a.j(new Error("The width and height of the updated image must be that same as the previous version of the image")));
          const L = !(s instanceof HTMLImageElement || a.b(s));
          return u.data.replace(E, L), this.style.updateImage(b, u), this;
        }
        getImage(b) {
          return this.style.getImage(b);
        }
        hasImage(b) {
          return b ? !!this.style.getImage(b) : (this.fire(new a.j(new Error("Missing required image id"))), !1);
        }
        removeImage(b) {
          this.style.removeImage(b);
        }
        loadImage(b) {
          return ie.getImage(this._requestManager.transformRequest(b, "Image"), new AbortController());
        }
        listImages() {
          return this.style.listImages();
        }
        addLayer(b, s) {
          return this._lazyInitEmptyStyle(), this.style.addLayer(b, s), this._update(!0);
        }
        moveLayer(b, s) {
          return this.style.moveLayer(b, s), this._update(!0);
        }
        removeLayer(b) {
          return this.style.removeLayer(b), this._update(!0);
        }
        getLayer(b) {
          return this.style.getLayer(b);
        }
        getLayersOrder() {
          return this.style.getLayersOrder();
        }
        setLayerZoomRange(b, s, u) {
          return this.style.setLayerZoomRange(b, s, u), this._update(!0);
        }
        setFilter(b, s) {
          let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return this.style.setFilter(b, s, u), this._update(!0);
        }
        getFilter(b) {
          return this.style.getFilter(b);
        }
        setPaintProperty(b, s, u) {
          let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          return this.style.setPaintProperty(b, s, u, p), this._update(!0);
        }
        getPaintProperty(b, s) {
          return this.style.getPaintProperty(b, s);
        }
        setLayoutProperty(b, s, u) {
          let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
          return this.style.setLayoutProperty(b, s, u, p), this._update(!0);
        }
        getLayoutProperty(b, s) {
          return this.style.getLayoutProperty(b, s);
        }
        setGlyphs(b) {
          let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this._lazyInitEmptyStyle(), this.style.setGlyphs(b, s), this._update(!0);
        }
        getGlyphs() {
          return this.style.getGlyphsUrl();
        }
        addSprite(b, s) {
          let u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
          return this._lazyInitEmptyStyle(), this.style.addSprite(b, s, u, (p) => {
            p || this._update(!0);
          }), this;
        }
        removeSprite(b) {
          return this._lazyInitEmptyStyle(), this.style.removeSprite(b), this._update(!0);
        }
        getSprite() {
          return this.style.getSprite();
        }
        setSprite(b) {
          let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this._lazyInitEmptyStyle(), this.style.setSprite(b, s, (u) => {
            u || this._update(!0);
          }), this;
        }
        setLight(b) {
          let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this._lazyInitEmptyStyle(), this.style.setLight(b, s), this._update(!0);
        }
        getLight() {
          return this.style.getLight();
        }
        setSky(b) {
          let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          return this._lazyInitEmptyStyle(), this.style.setSky(b, s), this._update(!0);
        }
        getSky() {
          return this.style.getSky();
        }
        setFeatureState(b, s) {
          return this.style.setFeatureState(b, s), this._update();
        }
        removeFeatureState(b, s) {
          return this.style.removeFeatureState(b, s), this._update();
        }
        getFeatureState(b) {
          return this.style.getFeatureState(b);
        }
        getContainer() {
          return this._container;
        }
        getCanvasContainer() {
          return this._canvasContainer;
        }
        getCanvas() {
          return this._canvas;
        }
        _containerDimensions() {
          let b = 0, s = 0;
          return this._container && (b = this._container.clientWidth || 400, s = this._container.clientHeight || 300), [b, s];
        }
        _setupContainer() {
          const b = this._container;
          b.classList.add("maplibregl-map");
          const s = this._canvasContainer = S.create("div", "maplibregl-canvas-container", b);
          this._interactive && s.classList.add("maplibregl-interactive"), this._canvas = S.create("canvas", "maplibregl-canvas", s), this._canvas.addEventListener("webglcontextlost", this._contextLost, !1), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region");
          const u = this._containerDimensions(), p = this._getClampedPixelRatio(u[0], u[1]);
          this._resizeCanvas(u[0], u[1], p);
          const m = this._controlContainer = S.create("div", "maplibregl-control-container", b), x = this._controlPositions = {};
          ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((E) => {
            x[E] = S.create("div", `maplibregl-ctrl-${E} `, m);
          }), this._container.addEventListener("scroll", this._onMapScroll, !1);
        }
        _resizeCanvas(b, s, u) {
          this._canvas.width = Math.floor(u * b), this._canvas.height = Math.floor(u * s), this._canvas.style.width = `${b}px`, this._canvas.style.height = `${s}px`;
        }
        _setupPainter() {
          const b = Object.assign(Object.assign({}, this._canvasContextAttributes), { alpha: !0, depth: !0, stencil: !0, premultipliedAlpha: !0 });
          let s = null;
          this._canvas.addEventListener("webglcontextcreationerror", (p) => {
            s = { requestedAttributes: b }, p && (s.statusMessage = p.statusMessage, s.type = p.type);
          }, { once: !0 });
          let u = null;
          if (u = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, b) : this._canvas.getContext("webgl2", b) || this._canvas.getContext("webgl", b), !u) {
            const p = "Failed to initialize WebGL";
            throw s ? (s.message = p, new Error(JSON.stringify(s))) : new Error(p);
          }
          this.painter = new ld(u, this.transform), F.testSupport(u);
        }
        migrateProjection(b, s) {
          super.migrateProjection(b, s), this.painter.transform = b, this.fire(new a.k("projectiontransition", { newProjection: this.style.projection.name }));
        }
        loaded() {
          return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
        }
        _update(b) {
          return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || b, this._sourcesDirty = !0, this.triggerRepaint(), this) : this;
        }
        _requestRenderFrame(b) {
          return this._update(), this._renderTaskQueue.add(b);
        }
        _cancelRenderFrame(b) {
          this._renderTaskQueue.remove(b);
        }
        _render(b) {
          var s, u, p, m, x;
          const E = this._idleTriggered ? this._fadeDuration : 0, L = ((s = this.style.projection) === null || s === void 0 ? void 0 : s.transitionState) > 0;
          if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(b), this._removed) return;
          let B = !1;
          if (this.style && this._styleDirty) {
            this._styleDirty = !1;
            const Z = this.transform.zoom, $ = I.now();
            this.style.zoomHistory.update(Z, $);
            const re = new a.B(Z, { now: $, fadeDuration: E, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), ae = re.crossFadingFactor();
            ae === 1 && ae === this._crossFadingFactor || (B = !0, this._crossFadingFactor = ae), this.style.update(re);
          }
          const N = ((u = this.style.projection) === null || u === void 0 ? void 0 : u.transitionState) > 0 !== L;
          (p = this.style.projection) === null || p === void 0 || p.setErrorQueryLatitudeDegrees(this.transform.center.lat), this.transform.setTransitionState((m = this.style.projection) === null || m === void 0 ? void 0 : m.transitionState, (x = this.style.projection) === null || x === void 0 ? void 0 : x.latitudeErrorCorrectionRadians), this.style && (this._sourcesDirty || N) && (this._sourcesDirty = !1, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0), this._centerClampedToGround && this.transform.setElevation(0)), this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, E, this._crossSourceCollisions, N), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: E, showPadding: this.showPadding }), this.fire(new a.k("render")), this.loaded() && !this._loaded && (this._loaded = !0, a.ce.mark(a.cf.load), this.fire(new a.k("load"))), this.style && (this.style.hasTransitions() || B) && (this._styleDirty = !0), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
          const G = this._sourcesDirty || this._styleDirty || this._placementDirty;
          return G || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new a.k("idle")), !this._loaded || this._fullyLoaded || G || (this._fullyLoaded = !0, a.ce.mark(a.cf.fullLoad)), this;
        }
        redraw() {
          return this.style && (this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._render(0)), this;
        }
        remove() {
          var b;
          this._hash && this._hash.remove();
          for (const u of this._controls) u.onRemove(this);
          this._controls = [], this._frameRequest && (this._frameRequest.abort(), this._frameRequest = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1), ie.removeThrottleControl(this._imageQueueHandle), (b = this._resizeObserver) === null || b === void 0 || b.disconnect();
          const s = this.painter.context.gl.getExtension("WEBGL_lose_context");
          s != null && s.loseContext && s.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1), this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1), S.remove(this._canvasContainer), S.remove(this._controlContainer), this._container.removeEventListener("scroll", this._onMapScroll, !1), this._container.classList.remove("maplibregl-map"), a.ce.clearMetrics(), this._removed = !0, this.fire(new a.k("remove"));
        }
        triggerRepaint() {
          this.style && !this._frameRequest && (this._frameRequest = new AbortController(), I.frame(this._frameRequest, (b) => {
            a.ce.frame(b), this._frameRequest = null;
            try {
              this._render(b);
            } catch (s) {
              if (!a.cg(s) && !function(u) {
                return u.message === fl;
              }(s)) throw s;
            }
          }, () => {
          }));
        }
        get showTileBoundaries() {
          return !!this._showTileBoundaries;
        }
        set showTileBoundaries(b) {
          this._showTileBoundaries !== b && (this._showTileBoundaries = b, this._update());
        }
        get showPadding() {
          return !!this._showPadding;
        }
        set showPadding(b) {
          this._showPadding !== b && (this._showPadding = b, this._update());
        }
        get showCollisionBoxes() {
          return !!this._showCollisionBoxes;
        }
        set showCollisionBoxes(b) {
          this._showCollisionBoxes !== b && (this._showCollisionBoxes = b, b ? this.style._generateCollisionBoxes() : this._update());
        }
        get showOverdrawInspector() {
          return !!this._showOverdrawInspector;
        }
        set showOverdrawInspector(b) {
          this._showOverdrawInspector !== b && (this._showOverdrawInspector = b, this._update());
        }
        get repaint() {
          return !!this._repaint;
        }
        set repaint(b) {
          this._repaint !== b && (this._repaint = b, this.triggerRepaint());
        }
        get vertices() {
          return !!this._vertices;
        }
        set vertices(b) {
          this._vertices = b, this._update();
        }
        get version() {
          return Yr;
        }
        getCameraTargetElevation() {
          return this.transform.elevation;
        }
        getProjection() {
          return this.style.getProjection();
        }
        setProjection(b) {
          return this._lazyInitEmptyStyle(), this.style.setProjection(b), this._update(!0);
        }
      }, c.MapMouseEvent = pr, c.MapTouchEvent = ec, c.MapWheelEvent = Bo, c.Marker = jr, c.NavigationControl = class {
        constructor(b) {
          this._updateZoomButtons = () => {
            const s = this._map.getZoom(), u = s === this._map.getMaxZoom(), p = s === this._map.getMinZoom();
            this._zoomInButton.disabled = u, this._zoomOutButton.disabled = p, this._zoomInButton.setAttribute("aria-disabled", u.toString()), this._zoomOutButton.setAttribute("aria-disabled", p.toString());
          }, this._rotateCompassArrow = () => {
            this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`;
          }, this._setButtonTitle = (s, u) => {
            const p = this._map._getUIString(`NavigationControl.${u}`);
            s.title = p, s.setAttribute("aria-label", p);
          }, this.options = a.e({}, Ss, b), this._container = S.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (s) => s.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (s) => this._map.zoomIn({}, { originalEvent: s })), S.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (s) => this._map.zoomOut({}, { originalEvent: s })), S.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (s) => {
            this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: s }) : this._map.resetNorth({}, { originalEvent: s });
          }), this._compassIcon = S.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
        }
        onAdd(b) {
          return this._map = b, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ri(this._map, this._compass, this.options.visualizePitch)), this._container;
        }
        onRemove() {
          S.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
        }
        _createButton(b, s) {
          const u = S.create("button", b, this._container);
          return u.type = "button", u.addEventListener("click", s), u;
        }
      }, c.Popup = class extends a.E {
        constructor(b) {
          super(), this.remove = () => (this._content && S.remove(this._content), this._container && (S.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), this._map._canvasContainer.classList.remove("maplibregl-track-pointer"), delete this._map, this.fire(new a.k("close"))), this), this._onMouseUp = (s) => {
            this._update(s.point);
          }, this._onMouseMove = (s) => {
            this._update(s.point);
          }, this._onDrag = (s) => {
            this._update(s.point);
          }, this._update = (s) => {
            var u;
            if (!this._map || !this._lngLat && !this._trackPointer || !this._content) return;
            if (!this._container) {
              if (this._container = S.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = S.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className) for (const L of this.options.className.split(" ")) this._container.classList.add(L);
              this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")), this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
            }
            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? Jr(this._lngLat, this._flatPos, this._map.transform) : (u = this._lngLat) === null || u === void 0 ? void 0 : u.wrap(), this._trackPointer && !s) return;
            const p = this._flatPos = this._pos = this._trackPointer && s ? s : this._map.project(this._lngLat);
            this._map.terrain && (this._flatPos = this._trackPointer && s ? s : this._map.transform.locationToScreenPoint(this._lngLat));
            let m = this.options.anchor;
            const x = nc(this.options.offset);
            if (!m) {
              const L = this._container.offsetWidth, B = this._container.offsetHeight;
              let N;
              N = p.y + x.bottom.y < B ? ["top"] : p.y > this._map.transform.height - B ? ["bottom"] : [], p.x < L / 2 ? N.push("left") : p.x > this._map.transform.width - L / 2 && N.push("right"), m = N.length === 0 ? "bottom" : N.join("-");
            }
            let E = p.add(x[m]);
            this.options.subpixelPositioning || (E = E.round()), S.setTransform(this._container, `${xr[m]} translate(${E.x}px,${E.y}px)`), kr(this._container, m, "popup");
          }, this._onClose = () => {
            this.remove();
          }, this.options = a.e(Object.create(xa), b);
        }
        addTo(b) {
          return this._map && this.remove(), this._map = b, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new a.k("open")), this;
        }
        isOpen() {
          return !!this._map;
        }
        getLngLat() {
          return this._lngLat;
        }
        setLngLat(b) {
          return this._lngLat = a.O.convert(b), this._pos = null, this._flatPos = null, this._trackPointer = !1, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
        }
        trackPointer() {
          return this._trackPointer = !0, this._pos = null, this._flatPos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
        }
        getElement() {
          return this._container;
        }
        setText(b) {
          return this.setDOMContent(document.createTextNode(b));
        }
        setHTML(b) {
          const s = document.createDocumentFragment(), u = document.createElement("body");
          let p;
          for (u.innerHTML = b; p = u.firstChild, p; ) s.appendChild(p);
          return this.setDOMContent(s);
        }
        getMaxWidth() {
          var b;
          return (b = this._container) === null || b === void 0 ? void 0 : b.style.maxWidth;
        }
        setMaxWidth(b) {
          return this.options.maxWidth = b, this._update(), this;
        }
        setDOMContent(b) {
          if (this._content) for (; this._content.hasChildNodes(); ) this._content.firstChild && this._content.removeChild(this._content.firstChild);
          else this._content = S.create("div", "maplibregl-popup-content", this._container);
          return this._content.appendChild(b), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
        }
        addClassName(b) {
          return this._container && this._container.classList.add(b), this;
        }
        removeClassName(b) {
          return this._container && this._container.classList.remove(b), this;
        }
        setOffset(b) {
          return this.options.offset = b, this._update(), this;
        }
        toggleClassName(b) {
          if (this._container) return this._container.classList.toggle(b);
        }
        setSubpixelPositioning(b) {
          this.options.subpixelPositioning = b;
        }
        _createCloseButton() {
          this.options.closeButton && (this._closeButton = S.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
        }
        _focusFirstElement() {
          if (!this.options.focusAfterOpen || !this._container) return;
          const b = this._container.querySelector(ur);
          b && b.focus();
        }
      }, c.RasterDEMTileSource = Sn, c.RasterTileSource = On, c.ScaleControl = class {
        constructor(b) {
          this._onMove = () => {
            va(this._map, this._container, this.options);
          }, this.setUnit = (s) => {
            this.options.unit = s, va(this._map, this._container, this.options);
          }, this.options = Object.assign(Object.assign({}, na), b);
        }
        getDefaultPosition() {
          return "bottom-left";
        }
        onAdd(b) {
          return this._map = b, this._container = S.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", b.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
        }
        onRemove() {
          S.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
        }
      }, c.ScrollZoomHandler = Le, c.Style = us, c.TerrainControl = class {
        constructor(b) {
          this._toggleTerrain = () => {
            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
          }, this._updateTerrainIcon = () => {
            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
          }, this.options = b;
        }
        onAdd(b) {
          return this._map = b, this._container = S.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = S.create("button", "maplibregl-ctrl-terrain", this._container), S.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
        }
        onRemove() {
          S.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
        }
      }, c.TwoFingersTouchPitchHandler = ee, c.TwoFingersTouchRotateHandler = k, c.TwoFingersTouchZoomHandler = T, c.TwoFingersTouchZoomRotateHandler = Ot, c.VectorTileSource = Ue, c.VideoSource = un, c.addSourceType = (b, s) => a._(void 0, void 0, void 0, function* () {
        if (Wn(b)) throw new Error(`A source type called "${b}" already exists.`);
        ((u, p) => {
          Mn[u] = p;
        })(b, s);
      }), c.clearPrewarmedResources = function() {
        const b = ze;
        b && (b.isPreloaded() && b.numActive() === 1 ? (b.release(mn), ze = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
      }, c.createTileMesh = Jo, c.getMaxParallelImageRequests = function() {
        return a.a.MAX_PARALLEL_IMAGE_REQUESTS;
      }, c.getRTLTextPluginStatus = function() {
        return fi().getRTLTextPluginStatus();
      }, c.getVersion = function() {
        return Wu;
      }, c.getWorkerCount = function() {
        return oe.workerCount;
      }, c.getWorkerUrl = function() {
        return a.a.WORKER_URL;
      }, c.importScriptInWorkers = function(b) {
        return xt().broadcast("IS", b);
      }, c.prewarm = function() {
        ot().acquire(mn);
      }, c.setMaxParallelImageRequests = function(b) {
        a.a.MAX_PARALLEL_IMAGE_REQUESTS = b;
      }, c.setRTLTextPlugin = function(b, s) {
        return fi().setRTLTextPlugin(b, s);
      }, c.setWorkerCount = function(b) {
        oe.workerCount = b;
      }, c.setWorkerUrl = function(b) {
        a.a.WORKER_URL = b;
      };
    });
    var l = t;
    return l;
  });
})(aT);
var cT = aT.exports;
const so = /* @__PURE__ */ $m(cT);
var co;
(function(n) {
  n[n.Unknown = 0] = "Unknown", n[n.Point = 1] = "Point", n[n.LineString = 2] = "LineString", n[n.Polygon = 3] = "Polygon", n[n.MultiPoint = 4] = "MultiPoint", n[n.MultiLineString = 5] = "MultiLineString", n[n.MultiPolygon = 6] = "MultiPolygon", n[n.GeometryCollection = 7] = "GeometryCollection", n[n.CircularString = 8] = "CircularString", n[n.CompoundCurve = 9] = "CompoundCurve", n[n.CurvePolygon = 10] = "CurvePolygon", n[n.MultiCurve = 11] = "MultiCurve", n[n.MultiSurface = 12] = "MultiSurface", n[n.Curve = 13] = "Curve", n[n.Surface = 14] = "Surface", n[n.PolyhedralSurface = 15] = "PolyhedralSurface", n[n.TIN = 16] = "TIN", n[n.Triangle = 17] = "Triangle";
})(co || (co = {}));
const Hf = 4, Wf = 4, Np = 4, lh = new Int32Array(2), W2 = new Float32Array(lh.buffer), Z2 = new Float64Array(lh.buffer), wg = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var Iy;
(function(n) {
  n[n.UTF8_BYTES = 1] = "UTF8_BYTES", n[n.UTF16_STRING = 2] = "UTF16_STRING";
})(Iy || (Iy = {}));
class Ru {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(e) {
    this.bytes_ = e, this.position_ = 0, this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(e) {
    return new Ru(new Uint8Array(e));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(e) {
    this.position_ = e;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(e) {
    return this.readUint8(e) << 24 >> 24;
  }
  readUint8(e) {
    return this.bytes_[e];
  }
  readInt16(e) {
    return this.readUint16(e) << 16 >> 16;
  }
  readUint16(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8;
  }
  readInt32(e) {
    return this.bytes_[e] | this.bytes_[e + 1] << 8 | this.bytes_[e + 2] << 16 | this.bytes_[e + 3] << 24;
  }
  readUint32(e) {
    return this.readInt32(e) >>> 0;
  }
  readInt64(e) {
    return BigInt.asIntN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readUint64(e) {
    return BigInt.asUintN(64, BigInt(this.readUint32(e)) + (BigInt(this.readUint32(e + 4)) << BigInt(32)));
  }
  readFloat32(e) {
    return lh[0] = this.readInt32(e), W2[0];
  }
  readFloat64(e) {
    return lh[wg ? 0 : 1] = this.readInt32(e), lh[wg ? 1 : 0] = this.readInt32(e + 4), Z2[0];
  }
  writeInt8(e, t) {
    this.bytes_[e] = t;
  }
  writeUint8(e, t) {
    this.bytes_[e] = t;
  }
  writeInt16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeUint16(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8;
  }
  writeInt32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeUint32(e, t) {
    this.bytes_[e] = t, this.bytes_[e + 1] = t >> 8, this.bytes_[e + 2] = t >> 16, this.bytes_[e + 3] = t >> 24;
  }
  writeInt64(e, t) {
    this.writeInt32(e, Number(BigInt.asIntN(32, t))), this.writeInt32(e + 4, Number(BigInt.asIntN(32, t >> BigInt(32))));
  }
  writeUint64(e, t) {
    this.writeUint32(e, Number(BigInt.asUintN(32, t))), this.writeUint32(e + 4, Number(BigInt.asUintN(32, t >> BigInt(32))));
  }
  writeFloat32(e, t) {
    W2[0] = t, this.writeInt32(e, lh[0]);
  }
  writeFloat64(e, t) {
    Z2[0] = t, this.writeInt32(e, lh[wg ? 0 : 1]), this.writeInt32(e + 4, lh[wg ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + Hf + Wf)
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    let e = "";
    for (let t = 0; t < Wf; t++)
      e += String.fromCharCode(this.readInt8(this.position_ + Hf + t));
    return e;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(e, t) {
    const i = e - this.readInt32(e);
    return t < this.readInt16(i) ? this.readInt16(i + t) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(e, t) {
    return e.bb_pos = t + this.readInt32(t), e.bb = this, e;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(e, t) {
    e += this.readInt32(e);
    const i = this.readInt32(e);
    e += Hf;
    const r = this.bytes_.subarray(e, e + i);
    return t === Iy.UTF8_BYTES ? r : this.text_decoder_.decode(r);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(e, t) {
    return typeof e == "string" ? this.__string(t) : this.__union(e, t);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(e) {
    return e + this.readInt32(e);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(e) {
    return e + this.readInt32(e) + Hf;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(e) {
    return this.readInt32(e + this.readInt32(e));
  }
  __has_identifier(e) {
    if (e.length != Wf)
      throw new Error("FlatBuffers: file identifier must be length " + Wf);
    for (let t = 0; t < Wf; t++)
      if (e.charCodeAt(t) != this.readInt8(this.position() + Hf + t))
        return !1;
    return !0;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(e, t) {
    const i = [];
    for (let r = 0; r < t; ++r) {
      const l = e(r);
      l !== null && i.push(l);
    }
    return i;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(e, t) {
    const i = [];
    for (let r = 0; r < t; ++r) {
      const l = e(r);
      l !== null && i.push(l.unpack());
    }
    return i;
  }
}
let qP = class Aa {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsGeometry(e, t) {
    return (t || new Aa()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsGeometry(e, t) {
    return e.setPosition(e.position() + Np), (t || new Aa()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  ends(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.readUint32(this.bb.__vector(this.bb_pos + t) + e * 4) : 0;
  }
  endsLength() {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  endsArray() {
    const e = this.bb.__offset(this.bb_pos, 4);
    return e ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  xy(e) {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  xyLength() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  xyArray() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  z(e) {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  zLength() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  zArray() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  m(e) {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  mLength() {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  mArray() {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  t(e) {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  tLength() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  tArray() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  tm(e) {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.readUint64(this.bb.__vector(this.bb_pos + t) + e * 8) : BigInt(0);
  }
  tmLength() {
    const e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  type() {
    const e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readUint8(this.bb_pos + e) : co.Unknown;
  }
  parts(e, t) {
    const i = this.bb.__offset(this.bb_pos, 18);
    return i ? (t || new Aa()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + e * 4), this.bb) : null;
  }
  partsLength() {
    const e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startGeometry(e) {
    e.startObject(8);
  }
  static addEnds(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static createEndsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--)
      e.addInt32(t[i]);
    return e.endVector();
  }
  static startEndsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addXy(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createXyVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addFloat64(t[i]);
    return e.endVector();
  }
  static startXyVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addZ(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createZVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addFloat64(t[i]);
    return e.endVector();
  }
  static startZVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addM(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static createMVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addFloat64(t[i]);
    return e.endVector();
  }
  static startMVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addT(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static createTVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addFloat64(t[i]);
    return e.endVector();
  }
  static startTVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addTm(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static createTmVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addInt64(t[i]);
    return e.endVector();
  }
  static startTmVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addType(e, t) {
    e.addFieldInt8(6, t, co.Unknown);
  }
  static addParts(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createPartsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--)
      e.addOffset(t[i]);
    return e.endVector();
  }
  static startPartsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endGeometry(e) {
    return e.endObject();
  }
  static createGeometry(e, t, i, r, l, c, a, g, y) {
    return Aa.startGeometry(e), Aa.addEnds(e, t), Aa.addXy(e, i), Aa.addZ(e, r), Aa.addM(e, l), Aa.addT(e, c), Aa.addTm(e, a), Aa.addType(e, g), Aa.addParts(e, y), Aa.endGeometry(e);
  }
};
function My(n, e) {
  const t = [];
  for (let i = 0; i < n.length; i += 2) {
    const r = [n[i], n[i + 1]];
    e && r.push(e[i >> 1]), t.push(r);
  }
  return t;
}
function $2(n, e, t) {
  if (!t || t.length === 0) return [My(n, e)];
  let i = 0;
  const r = Array.from(t).map((c) => n.slice(i, i = c << 1));
  let l;
  return e && (i = 0, l = Array.from(t).map((c) => e.slice(i, i = c))), r.map((c, a) => My(c, l ? l[a] : void 0));
}
function HP(n, e) {
  const t = n.xyArray(), i = n.zArray();
  switch (e) {
    case co.Point: {
      const r = Array.from(t);
      return i && r.push(i[0]), r;
    }
    case co.MultiPoint:
    case co.LineString:
      return My(t, i);
    case co.MultiLineString:
      return $2(t, i, n.endsArray());
    case co.Polygon:
      return $2(t, i, n.endsArray());
  }
}
function Ly(n, e) {
  let t = e;
  if (t === co.Unknown && (t = n.type()), t === co.GeometryCollection) {
    const r = [];
    for (let l = 0; l < n.partsLength(); l++) {
      const c = n.parts(l), a = c.type();
      r.push(Ly(c, a));
    }
    return {
      type: co[t],
      geometries: r
    };
  } else if (t === co.MultiPolygon) {
    const r = [];
    for (let l = 0; l < n.partsLength(); l++) r.push(Ly(n.parts(l), co.Polygon));
    return {
      type: co[t],
      coordinates: r.map((l) => l.coordinates)
    };
  }
  const i = HP(n, t);
  return {
    type: co[t],
    coordinates: i
  };
}
var ao;
(function(n) {
  n[n.Byte = 0] = "Byte", n[n.UByte = 1] = "UByte", n[n.Bool = 2] = "Bool", n[n.Short = 3] = "Short", n[n.UShort = 4] = "UShort", n[n.Int = 5] = "Int", n[n.UInt = 6] = "UInt", n[n.Long = 7] = "Long", n[n.ULong = 8] = "ULong", n[n.Float = 9] = "Float", n[n.Double = 10] = "Double", n[n.String = 11] = "String", n[n.Json = 12] = "Json", n[n.DateTime = 13] = "DateTime", n[n.Binary = 14] = "Binary";
})(ao || (ao = {}));
class oo {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsColumn(e, t) {
    return (t || new oo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsColumn(e, t) {
    return e.setPosition(e.position() + Np), (t || new oo()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  type() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readUint8(this.bb_pos + e) : ao.Byte;
  }
  title(e) {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  width() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  precision() {
    const e = this.bb.__offset(this.bb_pos, 14);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  scale() {
    const e = this.bb.__offset(this.bb_pos, 16);
    return e ? this.bb.readInt32(this.bb_pos + e) : -1;
  }
  nullable() {
    const e = this.bb.__offset(this.bb_pos, 18);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !0;
  }
  unique() {
    const e = this.bb.__offset(this.bb_pos, 20);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  primaryKey() {
    const e = this.bb.__offset(this.bb_pos, 22);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  metadata(e) {
    const t = this.bb.__offset(this.bb_pos, 24);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startColumn(e) {
    e.startObject(11);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addType(e, t) {
    e.addFieldInt8(1, t, ao.Byte);
  }
  static addTitle(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWidth(e, t) {
    e.addFieldInt32(4, t, -1);
  }
  static addPrecision(e, t) {
    e.addFieldInt32(5, t, -1);
  }
  static addScale(e, t) {
    e.addFieldInt32(6, t, -1);
  }
  static addNullable(e, t) {
    e.addFieldInt8(7, +t, 1);
  }
  static addUnique(e, t) {
    e.addFieldInt8(8, +t, 0);
  }
  static addPrimaryKey(e, t) {
    e.addFieldInt8(9, +t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static endColumn(e) {
    const t = e.endObject();
    return e.requiredField(t, 4), t;
  }
  static createColumn(e, t, i, r, l, c, a, g, y, A, C, I) {
    return oo.startColumn(e), oo.addName(e, t), oo.addType(e, i), oo.addTitle(e, r), oo.addDescription(e, l), oo.addWidth(e, c), oo.addPrecision(e, a), oo.addScale(e, g), oo.addNullable(e, y), oo.addUnique(e, A), oo.addPrimaryKey(e, C), oo.addMetadata(e, I), oo.endColumn(e);
  }
}
class fc {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsFeature(e, t) {
    return (t || new fc()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsFeature(e, t) {
    return e.setPosition(e.position() + Np), (t || new fc()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  geometry(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? (e || new qP()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  properties(e) {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readUint8(this.bb.__vector(this.bb_pos + t) + e) : 0;
  }
  propertiesLength() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  propertiesArray() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  columns(e, t) {
    const i = this.bb.__offset(this.bb_pos, 8);
    return i ? (t || new oo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + e * 4), this.bb) : null;
  }
  columnsLength() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  static startFeature(e) {
    e.startObject(3);
  }
  static addGeometry(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addProperties(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createPropertiesVector(e, t) {
    e.startVector(1, t.length, 1);
    for (let i = t.length - 1; i >= 0; i--)
      e.addInt8(t[i]);
    return e.endVector();
  }
  static startPropertiesVector(e, t) {
    e.startVector(1, t, 1);
  }
  static addColumns(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--)
      e.addOffset(t[i]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static endFeature(e) {
    return e.endObject();
  }
  static finishFeatureBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedFeatureBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
  static createFeature(e, t, i, r) {
    return fc.startFeature(e), fc.addGeometry(e, t), fc.addProperties(e, i), fc.addColumns(e, r), fc.endFeature(e);
  }
}
new TextEncoder();
const X2 = new TextDecoder();
function WP(n, e) {
  const t = {};
  if (!e || e.length === 0) return t;
  const i = n.propertiesArray();
  if (!i) return t;
  const r = new DataView(i.buffer, i.byteOffset), l = n.propertiesLength();
  let c = 0;
  for (; c < l; ) {
    const a = r.getUint16(c, !0);
    c += 2;
    const g = e[a], y = g.name;
    switch (g.type) {
      case ao.Bool: {
        t[y] = !!r.getUint8(c), c += 1;
        break;
      }
      case ao.Byte: {
        t[y] = r.getInt8(c), c += 1;
        break;
      }
      case ao.UByte: {
        t[y] = r.getUint8(c), c += 1;
        break;
      }
      case ao.Short: {
        t[y] = r.getInt16(c, !0), c += 2;
        break;
      }
      case ao.UShort: {
        t[y] = r.getUint16(c, !0), c += 2;
        break;
      }
      case ao.Int: {
        t[y] = r.getInt32(c, !0), c += 4;
        break;
      }
      case ao.UInt: {
        t[y] = r.getUint32(c, !0), c += 4;
        break;
      }
      case ao.Long: {
        t[y] = Number(r.getBigInt64(c, !0)), c += 8;
        break;
      }
      case ao.ULong: {
        t[y] = Number(r.getBigUint64(c, !0)), c += 8;
        break;
      }
      case ao.Float: {
        t[y] = r.getFloat32(c, !0), c += 4;
        break;
      }
      case ao.Double: {
        t[y] = r.getFloat64(c, !0), c += 8;
        break;
      }
      case ao.DateTime:
      case ao.String: {
        const A = r.getUint32(c, !0);
        c += 4, t[y] = X2.decode(i.subarray(c, c + A)), c += A;
        break;
      }
      case ao.Json: {
        const A = r.getUint32(c, !0);
        c += 4;
        const C = X2.decode(i.subarray(c, c + A));
        t[y] = JSON.parse(C), c += A;
        break;
      }
      default:
        throw new Error("Unknown type " + g.type);
    }
  }
  return t;
}
function z1(n, e) {
  const t = e.columns;
  return {
    type: "Feature",
    geometry: Ly(n.geometry(), e.geometryType),
    properties: WP(n, t)
  };
}
const U1 = new Uint8Array(0);
function ZP() {
  return this._source.cancel();
}
function $P(n, e) {
  if (!n.length) return e;
  if (!e.length) return n;
  var t = new Uint8Array(n.length + e.length);
  return t.set(n), t.set(e, n.length), t;
}
function XP() {
  var n = this, e = n._array.subarray(n._index);
  return n._source.read().then(function(t) {
    return n._array = U1, n._index = 0, t.done ? e.length > 0 ? {
      done: !1,
      value: e
    } : {
      done: !0,
      value: void 0
    } : {
      done: !1,
      value: $P(e, t.value)
    };
  });
}
function YP(n) {
  if ((n |= 0) < 0) throw new Error("invalid length");
  var e = this, t = this._array.length - this._index;
  if (this._index + n <= this._array.length)
    return Promise.resolve(this._array.subarray(this._index, this._index += n));
  var i = new Uint8Array(n);
  return i.set(this._array.subarray(this._index)), function r() {
    return e._source.read().then(function(l) {
      return l.done ? (e._array = U1, e._index = 0, t > 0 ? i.subarray(0, t) : null) : t + l.value.length >= n ? (e._array = l.value, e._index = n - t, i.set(l.value.subarray(0, n - t), t), i) : (i.set(l.value, t), t += l.value.length, r());
    });
  }();
}
function JP(n) {
  return typeof n.slice == "function" ? n : new Xm(typeof n.read == "function" ? n : n.getReader());
}
function Xm(n) {
  this._source = n, this._array = U1, this._index = 0;
}
Xm.prototype.read = XP;
Xm.prototype.slice = YP;
Xm.prototype.cancel = ZP;
class xl {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsCrs(e, t) {
    return (t || new xl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsCrs(e, t) {
    return e.setPosition(e.position() + Np), (t || new xl()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  org(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  code() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.readInt32(this.bb_pos + e) : 0;
  }
  name(e) {
    const t = this.bb.__offset(this.bb_pos, 8);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    const t = this.bb.__offset(this.bb_pos, 10);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  wkt(e) {
    const t = this.bb.__offset(this.bb_pos, 12);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  codeString(e) {
    const t = this.bb.__offset(this.bb_pos, 14);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startCrs(e) {
    e.startObject(6);
  }
  static addOrg(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addCode(e, t) {
    e.addFieldInt32(1, t, 0);
  }
  static addName(e, t) {
    e.addFieldOffset(2, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(3, t, 0);
  }
  static addWkt(e, t) {
    e.addFieldOffset(4, t, 0);
  }
  static addCodeString(e, t) {
    e.addFieldOffset(5, t, 0);
  }
  static endCrs(e) {
    return e.endObject();
  }
  static createCrs(e, t, i, r, l, c, a) {
    return xl.startCrs(e), xl.addOrg(e, t), xl.addCode(e, i), xl.addName(e, r), xl.addDescription(e, l), xl.addWkt(e, c), xl.addCodeString(e, a), xl.endCrs(e);
  }
}
class wm {
  constructor() {
    this.bb = null, this.bb_pos = 0;
  }
  __init(e, t) {
    return this.bb_pos = e, this.bb = t, this;
  }
  static getRootAsHeader(e, t) {
    return (t || new wm()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  static getSizePrefixedRootAsHeader(e, t) {
    return e.setPosition(e.position() + Np), (t || new wm()).__init(e.readInt32(e.position()) + e.position(), e);
  }
  name(e) {
    const t = this.bb.__offset(this.bb_pos, 4);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  envelope(e) {
    const t = this.bb.__offset(this.bb_pos, 6);
    return t ? this.bb.readFloat64(this.bb.__vector(this.bb_pos + t) + e * 8) : 0;
  }
  envelopeLength() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  envelopeArray() {
    const e = this.bb.__offset(this.bb_pos, 6);
    return e ? new Float64Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + e), this.bb.__vector_len(this.bb_pos + e)) : null;
  }
  geometryType() {
    const e = this.bb.__offset(this.bb_pos, 8);
    return e ? this.bb.readUint8(this.bb_pos + e) : co.Unknown;
  }
  hasZ() {
    const e = this.bb.__offset(this.bb_pos, 10);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  hasM() {
    const e = this.bb.__offset(this.bb_pos, 12);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  hasT() {
    const e = this.bb.__offset(this.bb_pos, 14);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  hasTm() {
    const e = this.bb.__offset(this.bb_pos, 16);
    return e ? !!this.bb.readInt8(this.bb_pos + e) : !1;
  }
  columns(e, t) {
    const i = this.bb.__offset(this.bb_pos, 18);
    return i ? (t || new oo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + i) + e * 4), this.bb) : null;
  }
  columnsLength() {
    const e = this.bb.__offset(this.bb_pos, 18);
    return e ? this.bb.__vector_len(this.bb_pos + e) : 0;
  }
  featuresCount() {
    const e = this.bb.__offset(this.bb_pos, 20);
    return e ? this.bb.readUint64(this.bb_pos + e) : BigInt("0");
  }
  indexNodeSize() {
    const e = this.bb.__offset(this.bb_pos, 22);
    return e ? this.bb.readUint16(this.bb_pos + e) : 16;
  }
  crs(e) {
    const t = this.bb.__offset(this.bb_pos, 24);
    return t ? (e || new xl()).__init(this.bb.__indirect(this.bb_pos + t), this.bb) : null;
  }
  title(e) {
    const t = this.bb.__offset(this.bb_pos, 26);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  description(e) {
    const t = this.bb.__offset(this.bb_pos, 28);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  metadata(e) {
    const t = this.bb.__offset(this.bb_pos, 30);
    return t ? this.bb.__string(this.bb_pos + t, e) : null;
  }
  static startHeader(e) {
    e.startObject(14);
  }
  static addName(e, t) {
    e.addFieldOffset(0, t, 0);
  }
  static addEnvelope(e, t) {
    e.addFieldOffset(1, t, 0);
  }
  static createEnvelopeVector(e, t) {
    e.startVector(8, t.length, 8);
    for (let i = t.length - 1; i >= 0; i--)
      e.addFloat64(t[i]);
    return e.endVector();
  }
  static startEnvelopeVector(e, t) {
    e.startVector(8, t, 8);
  }
  static addGeometryType(e, t) {
    e.addFieldInt8(2, t, co.Unknown);
  }
  static addHasZ(e, t) {
    e.addFieldInt8(3, +t, 0);
  }
  static addHasM(e, t) {
    e.addFieldInt8(4, +t, 0);
  }
  static addHasT(e, t) {
    e.addFieldInt8(5, +t, 0);
  }
  static addHasTm(e, t) {
    e.addFieldInt8(6, +t, 0);
  }
  static addColumns(e, t) {
    e.addFieldOffset(7, t, 0);
  }
  static createColumnsVector(e, t) {
    e.startVector(4, t.length, 4);
    for (let i = t.length - 1; i >= 0; i--)
      e.addOffset(t[i]);
    return e.endVector();
  }
  static startColumnsVector(e, t) {
    e.startVector(4, t, 4);
  }
  static addFeaturesCount(e, t) {
    e.addFieldInt64(8, t, BigInt("0"));
  }
  static addIndexNodeSize(e, t) {
    e.addFieldInt16(9, t, 16);
  }
  static addCrs(e, t) {
    e.addFieldOffset(10, t, 0);
  }
  static addTitle(e, t) {
    e.addFieldOffset(11, t, 0);
  }
  static addDescription(e, t) {
    e.addFieldOffset(12, t, 0);
  }
  static addMetadata(e, t) {
    e.addFieldOffset(13, t, 0);
  }
  static endHeader(e) {
    return e.endObject();
  }
  static finishHeaderBuffer(e, t) {
    e.finish(t);
  }
  static finishSizePrefixedHeaderBuffer(e, t) {
    e.finish(t, void 0, !0);
  }
}
function j1(n) {
  const e = wm.getRootAsHeader(n), t = e.featuresCount(), i = e.indexNodeSize(), r = [];
  for (let g = 0; g < e.columnsLength(); g++) {
    const y = e.columns(g);
    if (!y) throw new Error("Column unexpectedly missing");
    if (!y.name()) throw new Error("Column name unexpectedly missing");
    r.push({
      name: y.name(),
      type: y.type(),
      title: y.title(),
      description: y.description(),
      width: y.width(),
      precision: y.precision(),
      scale: y.scale(),
      nullable: y.nullable(),
      unique: y.unique(),
      primary_key: y.primaryKey()
    });
  }
  const l = e.crs(), c = l ? {
    org: l.org(),
    code: l.code(),
    name: l.name(),
    description: l.description(),
    wkt: l.wkt(),
    code_string: l.codeString()
  } : null;
  return {
    geometryType: e.geometryType(),
    columns: r,
    envelope: null,
    featuresCount: Number(t),
    indexNodeSize: i,
    crs: c,
    title: e.title(),
    description: e.description(),
    metadata: e.metadata()
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ry = function(n, e) {
  return Ry = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var r in i) i.hasOwnProperty(r) && (t[r] = i[r]);
  }, Ry(n, e);
};
function KP(n, e) {
  Ry(n, e);
  function t() {
    this.constructor = n;
  }
  n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
function rf(n, e, t, i) {
  function r(l) {
    return l instanceof t ? l : new t(function(c) {
      c(l);
    });
  }
  return new (t || (t = Promise))(function(l, c) {
    function a(A) {
      try {
        y(i.next(A));
      } catch (C) {
        c(C);
      }
    }
    function g(A) {
      try {
        y(i.throw(A));
      } catch (C) {
        c(C);
      }
    }
    function y(A) {
      A.done ? l(A.value) : r(A.value).then(a, g);
    }
    y((i = i.apply(n, [])).next());
  });
}
function ph(n, e) {
  var t = {
    label: 0,
    sent: function() {
      if (l[0] & 1) throw l[1];
      return l[1];
    },
    trys: [],
    ops: []
  }, i, r, l, c;
  return c = {
    next: a(0),
    throw: a(1),
    return: a(2)
  }, typeof Symbol == "function" && (c[Symbol.iterator] = function() {
    return this;
  }), c;
  function a(y) {
    return function(A) {
      return g([y, A]);
    };
  }
  function g(y) {
    if (i) throw new TypeError("Generator is already executing.");
    for (; t; ) try {
      if (i = 1, r && (l = y[0] & 2 ? r.return : y[0] ? r.throw || ((l = r.return) && l.call(r), 0) : r.next) && !(l = l.call(r, y[1])).done) return l;
      switch (r = 0, l && (y = [y[0] & 2, l.value]), y[0]) {
        case 0:
        case 1:
          l = y;
          break;
        case 4:
          return t.label++, {
            value: y[1],
            done: !1
          };
        case 5:
          t.label++, r = y[1], y = [0];
          continue;
        case 7:
          y = t.ops.pop(), t.trys.pop();
          continue;
        default:
          if (l = t.trys, !(l = l.length > 0 && l[l.length - 1]) && (y[0] === 6 || y[0] === 2)) {
            t = 0;
            continue;
          }
          if (y[0] === 3 && (!l || y[1] > l[0] && y[1] < l[3])) {
            t.label = y[1];
            break;
          }
          if (y[0] === 6 && t.label < l[1]) {
            t.label = l[1], l = y;
            break;
          }
          if (l && t.label < l[2]) {
            t.label = l[2], t.ops.push(y);
            break;
          }
          l[2] && t.ops.pop(), t.trys.pop();
          continue;
      }
      y = e.call(n, t);
    } catch (A) {
      y = [6, A], r = 0;
    } finally {
      i = l = 0;
    }
    if (y[0] & 5) throw y[1];
    return {
      value: y[0] ? y[1] : void 0,
      done: !0
    };
  }
}
function gf(n) {
  var e = typeof Symbol == "function" && Symbol.iterator, t = e && n[e], i = 0;
  if (t) return t.call(n);
  if (n && typeof n.length == "number") return {
    next: function() {
      return n && i >= n.length && (n = void 0), {
        value: n && n[i++],
        done: !n
      };
    }
  };
  throw new TypeError(e ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function Tp(n) {
  return this instanceof Tp ? (this.v = n, this) : new Tp(n);
}
function QP(n, e, t) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var i = t.apply(n, e || []), r, l = [];
  return r = {}, c("next"), c("throw"), c("return"), r[Symbol.asyncIterator] = function() {
    return this;
  }, r;
  function c(I) {
    i[I] && (r[I] = function(S) {
      return new Promise(function(F, U) {
        l.push([I, S, F, U]) > 1 || a(I, S);
      });
    });
  }
  function a(I, S) {
    try {
      g(i[I](S));
    } catch (F) {
      C(l[0][3], F);
    }
  }
  function g(I) {
    I.value instanceof Tp ? Promise.resolve(I.value.v).then(y, A) : C(l[0][2], I);
  }
  function y(I) {
    a("next", I);
  }
  function A(I) {
    a("throw", I);
  }
  function C(I, S) {
    I(S), l.shift(), l.length && a(l[0][0], l[0][1]);
  }
}
var uT = (
  /** @class */
  function(n) {
    KP(e, n);
    function e(t) {
      var i = n.call(this, t) || this;
      return Object.defineProperty(i, "name", {
        value: "RepeaterOverflowError",
        enumerable: !1
      }), typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf(i, i.constructor.prototype) : i.__proto__ = i.constructor.prototype, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(i, i.constructor), i;
    }
    return e;
  }(Error)
);
(function() {
  function n(e) {
    if (e < 0)
      throw new RangeError("Capacity may not be less than 0");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(n.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "full", {
    get: function() {
      return this._q.length >= this._c;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.add = function(e) {
    if (this.full)
      throw new Error("Buffer full");
    this._q.push(e);
  }, n.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, n;
})();
(function() {
  function n(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(n.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.add = function(e) {
    for (; this._q.length >= this._c; )
      this._q.shift();
    this._q.push(e);
  }, n.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, n;
})();
(function() {
  function n(e) {
    if (e < 1)
      throw new RangeError("Capacity may not be less than 1");
    this._c = e, this._q = [];
  }
  return Object.defineProperty(n.prototype, "empty", {
    get: function() {
      return this._q.length === 0;
    },
    enumerable: !1,
    configurable: !0
  }), Object.defineProperty(n.prototype, "full", {
    get: function() {
      return !1;
    },
    enumerable: !1,
    configurable: !0
  }), n.prototype.add = function(e) {
    this._q.length < this._c && this._q.push(e);
  }, n.prototype.remove = function() {
    if (this.empty)
      throw new Error("Buffer empty");
    return this._q.shift();
  }, n;
})();
function By(n) {
  n != null && typeof n.then == "function" && n.then(Em, Em);
}
var l0 = 0, Y2 = 1, Jh = 2, Am = 3, Oy = 4, Tm = 1024, Em = function() {
};
function Zd(n) {
  var e = n.err, t = Promise.resolve(n.execution).then(function(i) {
    if (e != null)
      throw e;
    return i;
  });
  return n.err = void 0, n.execution = t.then(function() {
  }, function() {
  }), n.pending === void 0 ? t : n.pending.then(function() {
    return t;
  });
}
function zh(n, e) {
  var t = n.state >= Am;
  return Promise.resolve(e).then(function(i) {
    return !t && n.state >= Oy ? Zd(n).then(function(r) {
      return {
        value: r,
        done: !0
      };
    }) : {
      value: i,
      done: t
    };
  });
}
function G1(n, e) {
  var t, i;
  if (!(n.state >= Jh))
    if (n.state = Jh, n.onnext(), n.onstop(), n.err == null && (n.err = e), n.pushes.length === 0 && (typeof n.buffer > "u" || n.buffer.empty))
      gp(n);
    else
      try {
        for (var r = gf(n.pushes), l = r.next(); !l.done; l = r.next()) {
          var c = l.value;
          c.resolve();
        }
      } catch (a) {
        t = {
          error: a
        };
      } finally {
        try {
          l && !l.done && (i = r.return) && i.call(r);
        } finally {
          if (t) throw t.error;
        }
      }
}
function gp(n) {
  var e, t;
  if (!(n.state >= Am)) {
    n.state < Jh && G1(n), n.state = Am, n.buffer = void 0;
    try {
      for (var i = gf(n.nexts), r = i.next(); !r.done; r = i.next()) {
        var l = r.value, c = n.pending === void 0 ? Zd(n) : n.pending.then(function() {
          return Zd(n);
        });
        l.resolve(zh(n, c));
      }
    } catch (a) {
      e = {
        error: a
      };
    } finally {
      try {
        r && !r.done && (t = i.return) && t.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    n.pushes = [], n.nexts = [];
  }
}
function J2(n) {
  n.state >= Oy || (n.state < Am && gp(n), n.state = Oy);
}
function eI(n, e) {
  if (By(e), n.pushes.length >= Tm)
    throw new uT("No more than " + Tm + " pending calls to push are allowed on a single repeater.");
  if (n.state >= Jh)
    return Promise.resolve(void 0);
  var t = n.pending === void 0 ? Promise.resolve(e) : n.pending.then(function() {
    return e;
  });
  t = t.catch(function(g) {
    n.state < Jh && (n.err = g), J2(n);
  });
  var i;
  if (n.nexts.length) {
    var r = n.nexts.shift();
    r.resolve(zh(n, t)), n.nexts.length ? i = Promise.resolve(n.nexts[0].value) : i = new Promise(function(g) {
      return n.onnext = g;
    });
  } else typeof n.buffer < "u" && !n.buffer.full ? (n.buffer.add(t), i = Promise.resolve(void 0)) : i = new Promise(function(g) {
    return n.pushes.push({
      resolve: g,
      value: t
    });
  });
  var l = !0, c = {}, a = i.catch(function(g) {
    if (l)
      throw g;
  });
  return c.then = function(g, y) {
    return l = !1, Promise.prototype.then.call(i, g, y);
  }, c.catch = function(g) {
    return l = !1, Promise.prototype.catch.call(i, g);
  }, c.finally = i.finally.bind(i), n.pending = t.then(function() {
    return a;
  }).catch(function(g) {
    n.err = g, J2(n);
  }), c;
}
function tI(n) {
  var e = G1.bind(null, n), t = new Promise(function(i) {
    return n.onstop = i;
  });
  return e.then = t.then.bind(t), e.catch = t.catch.bind(t), e.finally = t.finally.bind(t), e;
}
function nI(n) {
  if (!(n.state >= Y2)) {
    n.state = Y2;
    var e = eI.bind(null, n), t = tI(n);
    n.execution = new Promise(function(i) {
      return i(n.executor(e, t));
    }), n.execution.catch(function() {
      return G1(n);
    });
  }
}
var Ag = /* @__PURE__ */ new WeakMap(), kp = (
  /** @class */
  function() {
    function n(e, t) {
      Ag.set(this, {
        executor: e,
        buffer: t,
        err: void 0,
        state: l0,
        pushes: [],
        nexts: [],
        pending: void 0,
        execution: void 0,
        onnext: Em,
        onstop: Em
      });
    }
    return n.prototype.next = function(e) {
      By(e);
      var t = Ag.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      if (t.nexts.length >= Tm)
        throw new uT("No more than " + Tm + " pending calls to next are allowed on a single repeater.");
      if (t.state <= l0 && nI(t), t.onnext(e), typeof t.buffer < "u" && !t.buffer.empty) {
        var i = zh(t, t.buffer.remove());
        if (t.pushes.length) {
          var r = t.pushes.shift();
          t.buffer.add(r.value), t.onnext = r.resolve;
        }
        return i;
      } else if (t.pushes.length) {
        var l = t.pushes.shift();
        return t.onnext = l.resolve, zh(t, l.value);
      } else if (t.state >= Jh)
        return gp(t), zh(t, Zd(t));
      return new Promise(function(c) {
        return t.nexts.push({
          resolve: c,
          value: e
        });
      });
    }, n.prototype.return = function(e) {
      By(e);
      var t = Ag.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return gp(t), t.execution = Promise.resolve(t.execution).then(function() {
        return e;
      }), zh(t, Zd(t));
    }, n.prototype.throw = function(e) {
      var t = Ag.get(this);
      if (t === void 0)
        throw new Error("WeakMap error");
      return t.state <= l0 || t.state >= Jh || typeof t.buffer < "u" && !t.buffer.empty ? (gp(t), t.err == null && (t.err = e), zh(t, Zd(t))) : this.next(Promise.reject(e));
    }, n.prototype[Symbol.asyncIterator] = function() {
      return this;
    }, n.race = iI, n.merge = rI, n.zip = sI, n.latest = oI, n;
  }()
);
function Ym(n, e) {
  var t, i, r = [], l = function(y) {
    y != null && typeof y[Symbol.asyncIterator] == "function" ? r.push(y[Symbol.asyncIterator]()) : y != null && typeof y[Symbol.iterator] == "function" ? r.push(y[Symbol.iterator]()) : r.push(function() {
      return QP(this, arguments, function() {
        return ph(this, function(I) {
          switch (I.label) {
            case 0:
              return e.yieldValues ? [4, Tp(y)] : [3, 3];
            case 1:
              return [4, I.sent()];
            case 2:
              I.sent(), I.label = 3;
            case 3:
              return e.returnValues ? [4, Tp(y)] : [3, 5];
            case 4:
              return [2, I.sent()];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    }());
  };
  try {
    for (var c = gf(n), a = c.next(); !a.done; a = c.next()) {
      var g = a.value;
      l(g);
    }
  } catch (y) {
    t = {
      error: y
    };
  } finally {
    try {
      a && !a.done && (i = c.return) && i.call(c);
    } finally {
      if (t) throw t.error;
    }
  }
  return r;
}
function iI(n) {
  var e = this, t = Ym(n, {
    returnValues: !0
  });
  return new kp(function(i, r) {
    return rf(e, void 0, void 0, function() {
      var l, c, a, g, y, A;
      return ph(this, function(C) {
        switch (C.label) {
          case 0:
            if (!t.length)
              return r(), [
                2
                /*return*/
              ];
            c = !1, r.then(function() {
              l(), c = !0;
            }), C.label = 1;
          case 1:
            C.trys.push([1, , 5, 7]), g = void 0, y = 0, A = function() {
              var I, S, F, U, V, W;
              return ph(this, function(X) {
                switch (X.label) {
                  case 0:
                    I = y;
                    try {
                      for (S = (V = void 0, gf(t)), F = S.next(); !F.done; F = S.next())
                        U = F.value, Promise.resolve(U.next()).then(function(de) {
                          de.done ? (r(), a === void 0 && (a = de)) : y === I && (y++, l(de));
                        }, function(de) {
                          return r(de);
                        });
                    } catch (de) {
                      V = {
                        error: de
                      };
                    } finally {
                      try {
                        F && !F.done && (W = S.return) && W.call(S);
                      } finally {
                        if (V) throw V.error;
                      }
                    }
                    return [4, new Promise(function(de) {
                      return l = de;
                    })];
                  case 1:
                    return g = X.sent(), g === void 0 ? [3, 3] : [4, i(g.value)];
                  case 2:
                    X.sent(), X.label = 3;
                  case 3:
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            }, C.label = 2;
          case 2:
            return c ? [3, 4] : [5, A()];
          case 3:
            return C.sent(), [3, 2];
          case 4:
            return [2, a && a.value];
          case 5:
            return r(), [4, Promise.race(t.map(function(I) {
              return I.return && I.return();
            }))];
          case 6:
            return C.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function rI(n) {
  var e = this, t = Ym(n, {
    yieldValues: !0
  });
  return new kp(function(i, r) {
    return rf(e, void 0, void 0, function() {
      var l, c, a, g = this;
      return ph(this, function(y) {
        switch (y.label) {
          case 0:
            if (!t.length)
              return r(), [
                2
                /*return*/
              ];
            l = [], c = !1, r.then(function() {
              var A, C;
              c = !0;
              try {
                for (var I = gf(l), S = I.next(); !S.done; S = I.next()) {
                  var F = S.value;
                  F();
                }
              } catch (U) {
                A = {
                  error: U
                };
              } finally {
                try {
                  S && !S.done && (C = I.return) && C.call(I);
                } finally {
                  if (A) throw A.error;
                }
              }
            }), y.label = 1;
          case 1:
            return y.trys.push([1, , 3, 4]), [4, Promise.all(t.map(function(A, C) {
              return rf(g, void 0, void 0, function() {
                var I, S;
                return ph(this, function(F) {
                  switch (F.label) {
                    case 0:
                      F.trys.push([0, , 6, 9]), F.label = 1;
                    case 1:
                      return c ? [3, 5] : (Promise.resolve(A.next()).then(function(U) {
                        return l[C](U);
                      }, function(U) {
                        return r(U);
                      }), [4, new Promise(function(U) {
                        l[C] = U;
                      })]);
                    case 2:
                      return I = F.sent(), I === void 0 ? [3, 4] : I.done ? (a = I, [
                        2
                        /*return*/
                      ]) : [4, i(I.value)];
                    case 3:
                      F.sent(), F.label = 4;
                    case 4:
                      return [3, 1];
                    case 5:
                      return [3, 9];
                    case 6:
                      return S = A.return, S ? [4, A.return()] : [3, 8];
                    case 7:
                      S = F.sent(), F.label = 8;
                    case 8:
                      return [
                        7
                        /*endfinally*/
                      ];
                    case 9:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 2:
            return y.sent(), [2, a && a.value];
          case 3:
            return r(), [
              7
              /*endfinally*/
            ];
          case 4:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function sI(n) {
  var e = this, t = Ym(n, {
    returnValues: !0
  });
  return new kp(function(i, r) {
    return rf(e, void 0, void 0, function() {
      var l, c, a, g;
      return ph(this, function(y) {
        switch (y.label) {
          case 0:
            if (!t.length)
              return r(), [2, []];
            c = !1, r.then(function() {
              l(), c = !0;
            }), y.label = 1;
          case 1:
            y.trys.push([1, , 6, 8]), y.label = 2;
          case 2:
            return c ? [3, 5] : (Promise.all(t.map(function(A) {
              return A.next();
            })).then(function(A) {
              return l(A);
            }, function(A) {
              return r(A);
            }), [4, new Promise(function(A) {
              return l = A;
            })]);
          case 3:
            return a = y.sent(), a === void 0 ? [
              2
              /*return*/
            ] : (g = a.map(function(A) {
              return A.value;
            }), a.some(function(A) {
              return A.done;
            }) ? [2, g] : [4, i(g)]);
          case 4:
            return y.sent(), [3, 2];
          case 5:
            return [3, 8];
          case 6:
            return r(), [4, Promise.all(t.map(function(A) {
              return A.return && A.return();
            }))];
          case 7:
            return y.sent(), [
              7
              /*endfinally*/
            ];
          case 8:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
function oI(n) {
  var e = this, t = Ym(n, {
    yieldValues: !0,
    returnValues: !0
  });
  return new kp(function(i, r) {
    return rf(e, void 0, void 0, function() {
      var l, c, a, g, y, A = this;
      return ph(this, function(C) {
        switch (C.label) {
          case 0:
            if (!t.length)
              return r(), [2, []];
            c = [], a = !1, r.then(function() {
              var I, S;
              l();
              try {
                for (var F = gf(c), U = F.next(); !U.done; U = F.next()) {
                  var V = U.value;
                  V();
                }
              } catch (W) {
                I = {
                  error: W
                };
              } finally {
                try {
                  U && !U.done && (S = F.return) && S.call(F);
                } finally {
                  if (I) throw I.error;
                }
              }
              a = !0;
            }), C.label = 1;
          case 1:
            return C.trys.push([1, , 5, 7]), Promise.all(t.map(function(I) {
              return I.next();
            })).then(function(I) {
              return l(I);
            }, function(I) {
              return r(I);
            }), [4, new Promise(function(I) {
              return l = I;
            })];
          case 2:
            return g = C.sent(), g === void 0 ? [
              2
              /*return*/
            ] : (y = g.map(function(I) {
              return I.value;
            }), g.every(function(I) {
              return I.done;
            }) ? [2, y] : [4, i(y.slice())]);
          case 3:
            return C.sent(), [4, Promise.all(t.map(function(I, S) {
              return rf(A, void 0, void 0, function() {
                var F;
                return ph(this, function(U) {
                  switch (U.label) {
                    case 0:
                      if (g[S].done)
                        return [2, g[S].value];
                      U.label = 1;
                    case 1:
                      return a ? [3, 4] : (Promise.resolve(I.next()).then(function(V) {
                        return c[S](V);
                      }, function(V) {
                        return r(V);
                      }), [4, new Promise(function(V) {
                        return c[S] = V;
                      })]);
                    case 2:
                      return F = U.sent(), F === void 0 ? [2, g[S].value] : F.done ? [2, F.value] : (y[S] = F.value, [4, i(y.slice())]);
                    case 3:
                      return U.sent(), [3, 1];
                    case 4:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            }))];
          case 4:
            return [2, C.sent()];
          case 5:
            return r(), [4, Promise.all(t.map(function(I) {
              return I.return && I.return();
            }))];
          case 6:
            return C.sent(), [
              7
              /*endfinally*/
            ];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  });
}
let Sm = class {
  constructor() {
    this._extraRequestThreshold = 256 * 1024;
  }
  extraRequestThreshold() {
    return this._extraRequestThreshold;
  }
  setExtraRequestThreshold(e) {
    if (e < 0)
      throw new Error("extraRequestThreshold cannot be negative");
    this._extraRequestThreshold = e;
  }
};
Sm.global = new Sm();
var hc;
(function(n) {
  n[n.Debug = 0] = "Debug", n[n.Info = 1] = "Info", n[n.Warn = 2] = "Warn", n[n.Error = 3] = "Error";
})(hc || (hc = {}));
class uo {
  static debug() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    this.log(hc.Debug, ...t);
  }
  static info() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    this.log(hc.Info, ...t);
  }
  static warn() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    this.log(hc.Warn, ...t);
  }
  static error() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    this.log(hc.Error, ...t);
  }
  static log(e) {
    if (!(this.logLevel > e)) {
      for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
        i[r - 1] = arguments[r];
      switch (e) {
        case hc.Debug: {
          console.debug(...i);
          break;
        }
        case hc.Info: {
          console.info(...i);
          break;
        }
        case hc.Warn: {
          console.warn(...i);
          break;
        }
        case hc.Error: {
          console.error(...i);
          break;
        }
      }
    }
  }
}
uo.logLevel = hc.Warn;
const Uh = 8 * 4 + 8, aI = 16;
function V1(n, e) {
  e = Math.min(Math.max(+e, 2), 65535);
  let t = n, i = t;
  do
    t = Math.ceil(t / e), i += t;
  while (t !== 1);
  return i * Uh;
}
function lI(n, e) {
  if (e < 2) throw new Error("Node size must be at least 2");
  if (n === 0) throw new Error("Number of items must be greater than 0");
  let t = n, i = t;
  const r = [t];
  do
    t = Math.ceil(t / e), i += t, r.push(t);
  while (t !== 1);
  const l = [];
  t = i;
  for (const a of r)
    l.push(t - a), t -= a;
  const c = [];
  for (let a = 0; a < r.length; a++) c.push([l[a], l[a] + r[a]]);
  return c;
}
async function* cI(n, e, t, i) {
  class r {
    constructor(F, U) {
      this._level = U, this.nodes = F;
    }
    level() {
      return this._level;
    }
    startNodeIdx() {
      return this.nodes[0];
    }
    endNodeIdx() {
      return this.nodes[1];
    }
    extendEndNodeIdx(F) {
      console.assert(F > this.nodes[1]), this.nodes[1] = F;
    }
    toString() {
      return `[NodeRange level: ${this._level}, nodes: ${this.nodes[0]}-${this.nodes[1]}]`;
    }
  }
  const {
    minX: l,
    minY: c,
    maxX: a,
    maxY: g
  } = t;
  uo.info(`tree items: ${n}, nodeSize: ${e}`);
  const y = lI(n, e), A = y[0][0], I = [(() => {
    const S = [0, 1], F = y.length - 1;
    return new r(S, F);
  })()];
  for (uo.debug(`starting stream search with queue: ${I}, numItems: ${n}, nodeSize: ${e}, levelBounds: ${y}`); I.length != 0; ) {
    const S = I.shift();
    uo.debug(`popped node: ${S}, queueLength: ${I.length}`);
    const F = S.startNodeIdx(), U = F >= A, V = (() => {
      const [, ie] = y[S.level()], fe = Math.min(S.endNodeIdx() + e, ie);
      return U && fe < ie ? fe + 1 : fe;
    })(), W = V - F, X = await i(F * Uh, W * Uh), de = new DataView(X);
    for (let ie = F; ie < V; ie++) {
      const fe = ie - F, Ae = fe * Uh;
      if (a < de.getFloat64(Ae + 0, !0) || g < de.getFloat64(Ae + 8, !0) || l > de.getFloat64(Ae + 16, !0) || c > de.getFloat64(Ae + 24, !0)) continue;
      const Te = de.getBigUint64(Ae + 32, !0);
      if (U) {
        const _e = Te, De = (() => {
          if (ie < n - 1) {
            const St = (fe + 1) * Uh;
            return de.getBigUint64(St + 32, !0) - _e;
          } else
            return null;
        })(), Me = ie - A;
        yield [Number(_e), Me, Number(De)];
        continue;
      }
      const me = Te, Ge = Sm.global.extraRequestThreshold() / Uh, ke = I[I.length - 1];
      if (ke !== void 0 && ke.level() == S.level() - 1 && me < ke.endNodeIdx() + Ge) {
        uo.debug(`Merging "nodeRange" request into existing range: ${ke}, newEndNodeIdx: ${ke.endNodeIdx()} -> ${me}`), ke.extendEndNodeIdx(Number(me));
        continue;
      }
      const pe = (() => {
        const _e = S.level() - 1, De = [Number(me), Number(me) + 1];
        return new r(De, _e);
      })();
      ke !== void 0 && ke.level() == pe.level() ? uo.info(`Same level, but too far away. Pushing new request for nodeIdx: ${me} rather than merging with distant ${ke}`) : uo.info(`Pushing new level for ${pe} onto queue with nearestNodeRange: ${ke} since there's not already a range for this level.`), I.push(pe);
    }
  }
}
const ch = new Uint8Array([102, 103, 98, 3, 102, 103, 98, 0]), Su = 4;
class q1 {
  constructor(e, t, i, r, l) {
    this.headerClient = e, this.header = t, this.headerLength = i, this.indexLength = r, this.nocache = l;
  }
  static async open(e, t) {
    const r = new K2(e, t), l = (() => {
      const I = aI, S = 3;
      let F = 0, U;
      for (U = 0; U < S; U++) {
        const V = I ** U * Uh;
        F += V;
      }
      return F;
    })(), c = 2024 + l;
    uo.debug(`fetching header. minReqLength: ${c} (assumedHeaderLength: 2024, assumedIndexLength: ${l})`);
    {
      const I = new Uint8Array(await r.getRange(0, 8, c, "header"));
      if (!I.subarray(0, 3).every((S, F) => ch[F] === S))
        throw uo.error(`bytes: ${I} != ${ch}`), new Error("Not a FlatGeobuf file");
      uo.debug("magic bytes look good");
    }
    let a;
    {
      const I = await r.getRange(8, 4, c, "header");
      a = new DataView(I).getUint32(0, !0);
      const S = 1048576 * 10;
      if (a > S || a < 8)
        throw new Error("Invalid header size");
      uo.debug(`headerLength: ${a}`);
    }
    const g = await r.getRange(12, a, c, "header"), y = new Ru(new Uint8Array(g)), A = j1(y), C = V1(A.featuresCount, A.indexNodeSize);
    return uo.debug("completed: opening http reader"), new q1(r, A, a, C, t);
  }
  async *selectBbox(e) {
    const t = this.lengthBeforeTree(), i = this.headerClient, r = async function(g, y) {
      return i.getRange(t + g, y, 0, "index");
    }, l = [];
    let c = [];
    for await (const g of cI(this.header.featuresCount, this.header.indexNodeSize, e, r)) {
      const [y, ,] = g;
      let [, , A] = g;
      if (A || (uo.info("final feature"), A = 4), c.length == 0) {
        c.push([y, A]);
        continue;
      }
      const C = c[c.length - 1], I = y - (C[0] + C[1]);
      I > Sm.global.extraRequestThreshold() && (uo.info(`Pushing new feature batch, since gap ${I} was too large`), l.push(c), c = []), c.push([y, A]);
    }
    this.headerClient.logUsage("header+index"), c.length > 0 && l.push(c);
    const a = l.flatMap((g) => this.readFeatureBatch(g, this.nocache));
    yield* kp.merge(a);
  }
  lengthBeforeTree() {
    return ch.length + Su + this.headerLength;
  }
  lengthBeforeFeatures() {
    return this.lengthBeforeTree() + this.indexLength;
  }
  buildFeatureClient(e) {
    return new K2(this.headerClient.httpClient, e);
  }
  async *readFeatureBatch(e, t) {
    const [i] = e[0], [r, l] = e[e.length - 1], c = i, g = r + l - c, y = this.buildFeatureClient(t);
    let A = g;
    for (const [C] of e)
      yield await this.readFeature(y, C, A), A = 0;
    y.logUsage("feature");
  }
  async readFeature(e, t, i) {
    const r = t + this.lengthBeforeFeatures();
    let l;
    {
      const A = await e.getRange(r, 4, i, "feature length");
      l = new DataView(A).getUint32(0, !0);
    }
    const c = await e.getRange(r + 4, l, i, "feature data"), a = new Uint8Array(c), g = new Uint8Array(l + Su);
    g.set(a, Su);
    const y = new Ru(g);
    return y.setPosition(Su), fc.getRootAsFeature(y);
  }
}
class K2 {
  constructor(e, t) {
    if (this.bytesEverUsed = 0, this.bytesEverFetched = 0, this.buffer = new ArrayBuffer(0), this.head = 0, typeof e == "string")
      this.httpClient = new Q2(e, t);
    else if (e instanceof Q2)
      this.httpClient = e;
    else
      throw new Error("Unknown source ");
  }
  async getRange(e, t, i, r) {
    this.bytesEverUsed += t;
    const l = e - this.head, c = l + t;
    if (l >= 0 && c <= this.buffer.byteLength)
      return this.buffer.slice(l, c);
    const a = Math.max(t, i);
    return this.bytesEverFetched += a, uo.debug(`requesting for new Range: ${e}-${e + a - 1}`), this.buffer = await this.httpClient.getRange(e, a, r), this.head = e, this.buffer.slice(0, t);
  }
  logUsage(e) {
    const t = e.split(" ")[0], i = this.bytesEverUsed, r = this.bytesEverFetched, l = (100 * i / r).toFixed(2);
    uo.info(`${t} bytes used/requested: ${i} / ${r} = ${l}%`);
  }
}
class Q2 {
  constructor(e, t) {
    this.requestsEverMade = 0, this.bytesEverRequested = 0, this.url = e, this.nocache = t;
  }
  async getRange(e, t, i) {
    this.requestsEverMade += 1, this.bytesEverRequested += t;
    const r = `bytes=${e}-${e + t - 1}`;
    uo.info(`request: #${this.requestsEverMade}, purpose: ${i}), bytes: (this_request: ${t}, ever: ${this.bytesEverRequested}), Range: ${r}`);
    const l = {
      Range: r
    };
    return this.nocache && (l["Cache-Control"] = "no-cache, no-store"), (await fetch(this.url, {
      headers: l
    })).arrayBuffer();
  }
}
function uI(n, e, t) {
  if (!n.subarray(0, 3).every((A, C) => ch[C] === A)) throw new Error("Not a FlatGeobuf file");
  const i = new Ru(n), r = i.readUint32(ch.length);
  i.setPosition(ch.length + Su);
  const l = j1(i);
  let c = ch.length + Su + r;
  const {
    indexNodeSize: a,
    featuresCount: g
  } = l;
  a > 0 && (c += V1(g, a));
  const y = [];
  for (; c < i.capacity(); ) {
    const A = i.readUint32(c);
    i.setPosition(c + Su);
    const C = fc.getRootAsFeature(i);
    y.push(e(C, l)), c += Su + A;
  }
  return y;
}
async function* hI(n, e, t) {
  const i = JP(n), r = async (I) => await i.slice(I);
  let l = new Uint8Array(await r(8));
  if (!l.subarray(0, 3).every((I, S) => ch[S] === I)) throw new Error("Not a FlatGeobuf file");
  l = new Uint8Array(await r(4));
  let c = new Ru(l);
  const a = c.readUint32(0);
  l = new Uint8Array(await r(a)), c = new Ru(l);
  const g = j1(c), {
    indexNodeSize: y,
    featuresCount: A
  } = g;
  if (y > 0) {
    const I = V1(A, y);
    await r(I);
  }
  let C;
  for (; C = await fI(r, g, e); ) yield C;
}
function dI(n, e, t, i) {
  try {
    let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    return async function* () {
      const l = await q1.open(n, r);
      uo.debug("opened reader");
      for await (const c of l.selectBbox(e))
        yield t(c, l.header);
    }();
  } catch (r) {
    return Promise.reject(r);
  }
}
async function fI(n, e, t) {
  let i = new Uint8Array(await n(4, "feature length"));
  if (i.byteLength === 0) return;
  let r = new Ru(i);
  const l = r.readUint32(0);
  i = new Uint8Array(await n(l, "feature data"));
  const c = new Uint8Array(l + 4);
  c.set(i, 4), r = new Ru(c), r.setPosition(Su);
  const a = fc.getRootAsFeature(r);
  return t(a, e);
}
function pI(n, e) {
  return {
    type: "FeatureCollection",
    features: uI(n, z1)
  };
}
function gI(n, e) {
  return hI(n, z1);
}
function mI(n, e, t) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return dI(n, e, z1, t, i);
}
function ex(n, e, t) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return n instanceof Uint8Array ? pI(n) : n instanceof ReadableStream ? gI(n) : mI(n, e, t, i);
}
class _I {
  constructor() {
    this._bearing = 0, this._pitch = 60, this._minpitchzoom = null;
  }
  onAdd(e) {
    this._map = e;
    let t = this;
    return this._btn = document.createElement("button"), this._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-2d", this._btn.id = "bt3D", this._btn.type = "button", this._btn["aria-label"] = "Vista 3D", this._btn.onclick = function() {
      if (t._btn.className.indexOf("3d") != -1) {
        let y = {
          pitch: t._pitch,
          bearing: t._bearing
        };
        t._minpitchzoom && e.getZoom() > t._minpitchzoom && (y.zoom = t._minpitchzoom);
        var i = 0, r = 38.5, l = 6, c = 62.33, {
          longitude: a,
          latitude: g
        } = e.getCenter();
        e.getZoom() < 10 ? e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.5
        }) : a >= i && a <= l && g >= r && g <= c ? e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.2
        }) : e.setTerrain({
          source: "terrainICGC",
          exaggeration: 1.5
        }), e.easeTo(y), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-2d";
      } else
        e.setTerrain(null), e.easeTo({
          pitch: 0,
          bearing: 0
        }), t._btn.className = "maplibregl-ctrl-icon maplibregl-ctrl-pitchtoggle-3d";
    }, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl maplibregl-ctrl-group", this._container.title = "Vista 3D", this._container.appendChild(this._btn), this._container;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
function Ep(n) {
  "@babel/helpers - typeof";
  return Ep = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Ep(n);
}
function yI(n, e) {
  if (Ep(n) != "object" || !n) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e || "default");
    if (Ep(i) != "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function bI(n) {
  var e = yI(n, "string");
  return Ep(e) == "symbol" ? e : e + "";
}
function H(n, e, t) {
  return e = bI(e), e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function _r(n, e) {
  if (!n)
    throw new Error(e || "loader assertion failed.");
}
const Jm = !!(typeof process != "object" || String(process) !== "[object process]" || process.browser), tx = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
tx && parseFloat(tx[1]);
const vI = "3.4.15";
function nu(n, e) {
  if (!n)
    throw new Error(e || "loaders.gl assertion failed.");
}
const c0 = {
  self: typeof self < "u" && self,
  window: typeof window < "u" && window,
  global: typeof global < "u" && global,
  document: typeof document < "u" && document
}, xI = c0.global || c0.self || c0.window || {}, Mu = typeof process != "object" || String(process) !== "[object process]" || process.browser, H1 = typeof importScripts == "function", wI = typeof window < "u" && typeof window.orientation < "u", nx = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
nx && parseFloat(nx[1]);
class AI {
  constructor(e, t) {
    H(this, "name", void 0), H(this, "workerThread", void 0), H(this, "isRunning", !0), H(this, "result", void 0), H(this, "_resolve", () => {
    }), H(this, "_reject", () => {
    }), this.name = e, this.workerThread = t, this.result = new Promise((i, r) => {
      this._resolve = i, this._reject = r;
    });
  }
  postMessage(e, t) {
    this.workerThread.postMessage({
      source: "loaders.gl",
      type: e,
      payload: t
    });
  }
  done(e) {
    nu(this.isRunning), this.isRunning = !1, this._resolve(e);
  }
  error(e) {
    nu(this.isRunning), this.isRunning = !1, this._reject(e);
  }
}
let u0 = class {
  terminate() {
  }
};
const h0 = /* @__PURE__ */ new Map();
function TI(n) {
  nu(n.source && !n.url || !n.source && n.url);
  let e = h0.get(n.source || n.url);
  return e || (n.url && (e = EI(n.url), h0.set(n.url, e)), n.source && (e = hT(n.source), h0.set(n.source, e))), nu(e), e;
}
function EI(n) {
  if (!n.startsWith("http"))
    return n;
  const e = SI(n);
  return hT(e);
}
function hT(n) {
  const e = new Blob([n], {
    type: "application/javascript"
  });
  return URL.createObjectURL(e);
}
function SI(n) {
  return `try {
  importScripts('`.concat(n, `');
} catch (error) {
  console.error(error);
  throw error;
}`);
}
function dT(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, t = arguments.length > 2 ? arguments[2] : void 0;
  const i = t || /* @__PURE__ */ new Set();
  if (n) {
    if (ix(n))
      i.add(n);
    else if (ix(n.buffer))
      i.add(n.buffer);
    else if (!ArrayBuffer.isView(n)) {
      if (e && typeof n == "object")
        for (const r in n)
          dT(n[r], e, i);
    }
  }
  return t === void 0 ? Array.from(i) : [];
}
function ix(n) {
  return n ? n instanceof ArrayBuffer || typeof MessagePort < "u" && n instanceof MessagePort || typeof ImageBitmap < "u" && n instanceof ImageBitmap || typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas : !1;
}
const d0 = () => {
};
class Dy {
  static isSupported() {
    return typeof Worker < "u" && Mu || typeof u0 < "u" && !Mu;
  }
  constructor(e) {
    H(this, "name", void 0), H(this, "source", void 0), H(this, "url", void 0), H(this, "terminated", !1), H(this, "worker", void 0), H(this, "onMessage", void 0), H(this, "onError", void 0), H(this, "_loadableURL", "");
    const {
      name: t,
      source: i,
      url: r
    } = e;
    nu(i || r), this.name = t, this.source = i, this.url = r, this.onMessage = d0, this.onError = (l) => console.log(l), this.worker = Mu ? this._createBrowserWorker() : this._createNodeWorker();
  }
  destroy() {
    this.onMessage = d0, this.onError = d0, this.worker.terminate(), this.terminated = !0;
  }
  get isRunning() {
    return !!this.onMessage;
  }
  postMessage(e, t) {
    t = t || dT(e), this.worker.postMessage(e, t);
  }
  _getErrorFromErrorEvent(e) {
    let t = "Failed to load ";
    return t += "worker ".concat(this.name, " from ").concat(this.url, ". "), e.message && (t += "".concat(e.message, " in ")), e.lineno && (t += ":".concat(e.lineno, ":").concat(e.colno)), new Error(t);
  }
  _createBrowserWorker() {
    this._loadableURL = TI({
      source: this.source,
      url: this.url
    });
    const e = new Worker(this._loadableURL, {
      name: this.name
    });
    return e.onmessage = (t) => {
      t.data ? this.onMessage(t.data) : this.onError(new Error("No data received"));
    }, e.onerror = (t) => {
      this.onError(this._getErrorFromErrorEvent(t)), this.terminated = !0;
    }, e.onmessageerror = (t) => console.error(t), e;
  }
  _createNodeWorker() {
    let e;
    if (this.url) {
      const i = this.url.includes(":/") || this.url.startsWith("/") ? this.url : "./".concat(this.url);
      e = new u0(i, {
        eval: !1
      });
    } else if (this.source)
      e = new u0(this.source, {
        eval: !0
      });
    else
      throw new Error("no worker");
    return e.on("message", (t) => {
      this.onMessage(t);
    }), e.on("error", (t) => {
      this.onError(t);
    }), e.on("exit", (t) => {
    }), e;
  }
}
class CI {
  static isSupported() {
    return Dy.isSupported();
  }
  constructor(e) {
    H(this, "name", "unnamed"), H(this, "source", void 0), H(this, "url", void 0), H(this, "maxConcurrency", 1), H(this, "maxMobileConcurrency", 1), H(this, "onDebug", () => {
    }), H(this, "reuseWorkers", !0), H(this, "props", {}), H(this, "jobQueue", []), H(this, "idleQueue", []), H(this, "count", 0), H(this, "isDestroyed", !1), this.source = e.source, this.url = e.url, this.setProps(e);
  }
  destroy() {
    this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = !0;
  }
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
  }
  async startJob(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (l, c, a) => l.done(a), i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (l, c) => l.error(c);
    const r = new Promise((l) => (this.jobQueue.push({
      name: e,
      onMessage: t,
      onError: i,
      onStart: l
    }), this));
    return this._startQueuedJob(), await r;
  }
  async _startQueuedJob() {
    if (!this.jobQueue.length)
      return;
    const e = this._getAvailableWorker();
    if (!e)
      return;
    const t = this.jobQueue.shift();
    if (t) {
      this.onDebug({
        message: "Starting job",
        name: t.name,
        workerThread: e,
        backlog: this.jobQueue.length
      });
      const i = new AI(t.name, e);
      e.onMessage = (r) => t.onMessage(i, r.type, r.payload), e.onError = (r) => t.onError(i, r), t.onStart(i);
      try {
        await i.result;
      } finally {
        this.returnWorkerToQueue(e);
      }
    }
  }
  returnWorkerToQueue(e) {
    this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
  }
  _getAvailableWorker() {
    if (this.idleQueue.length > 0)
      return this.idleQueue.shift() || null;
    if (this.count < this._getMaxConcurrency()) {
      this.count++;
      const e = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
      return new Dy({
        name: e,
        source: this.source,
        url: this.url
      });
    }
    return null;
  }
  _getMaxConcurrency() {
    return wI ? this.maxMobileConcurrency : this.maxConcurrency;
  }
}
const PI = {
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: !0,
  onDebug: () => {
  }
};
class Tu {
  static isSupported() {
    return Dy.isSupported();
  }
  static getWorkerFarm() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Tu._workerFarm = Tu._workerFarm || new Tu({}), Tu._workerFarm.setProps(e), Tu._workerFarm;
  }
  constructor(e) {
    H(this, "props", void 0), H(this, "workerPools", /* @__PURE__ */ new Map()), this.props = {
      ...PI
    }, this.setProps(e), this.workerPools = /* @__PURE__ */ new Map();
  }
  destroy() {
    for (const e of this.workerPools.values())
      e.destroy();
    this.workerPools = /* @__PURE__ */ new Map();
  }
  setProps(e) {
    this.props = {
      ...this.props,
      ...e
    };
    for (const t of this.workerPools.values())
      t.setProps(this._getWorkerPoolProps());
  }
  getWorkerPool(e) {
    const {
      name: t,
      source: i,
      url: r
    } = e;
    let l = this.workerPools.get(t);
    return l || (l = new CI({
      name: t,
      source: i,
      url: r
    }), l.setProps(this._getWorkerPoolProps()), this.workerPools.set(t, l)), l;
  }
  _getWorkerPoolProps() {
    return {
      maxConcurrency: this.props.maxConcurrency,
      maxMobileConcurrency: this.props.maxMobileConcurrency,
      reuseWorkers: this.props.reuseWorkers,
      onDebug: this.props.onDebug
    };
  }
}
H(Tu, "_workerFarm", void 0);
const II = "latest";
function MI(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = e[n.id] || {}, i = "".concat(n.id, "-worker.js");
  let r = t.workerUrl;
  if (!r && n.id === "compression" && (r = e.workerUrl), e._workerType === "test" && (r = "modules/".concat(n.module, "/dist/").concat(i)), !r) {
    let l = n.version;
    l === "latest" && (l = II);
    const c = l ? "@".concat(l) : "";
    r = "https://unpkg.com/@loaders.gl/".concat(n.module).concat(c, "/dist/").concat(i);
  }
  return nu(r), r;
}
function LI(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : vI;
  nu(n, "no worker provided");
  const t = n.version;
  return !(!e || !t);
}
const RI = null, BI = null, Fy = null, fT = null, OI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  readFileAsArrayBuffer: RI,
  readFileAsText: BI,
  requireFromFile: Fy,
  requireFromString: fT
}, Symbol.toStringTag, { value: "Module" })), DI = "3.4.15", f0 = {};
async function Zh(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  return e && (n = FI(n, e, t)), f0[n] = f0[n] || NI(n), await f0[n];
}
function FI(n, e, t) {
  if (n.startsWith("http"))
    return n;
  const i = t.modules || {};
  return i[n] ? i[n] : Mu ? t.CDN ? (nu(t.CDN.startsWith("http")), "".concat(t.CDN, "/").concat(e, "@").concat(DI, "/dist/libs/").concat(n)) : H1 ? "../src/libs/".concat(n) : "modules/".concat(e, "/src/libs/").concat(n) : "modules/".concat(e, "/dist/libs/").concat(n);
}
async function NI(n) {
  if (n.endsWith("wasm"))
    return await (await fetch(n)).arrayBuffer();
  if (!Mu)
    try {
      return OI && Fy && await Fy(n);
    } catch {
      return null;
    }
  if (H1)
    return importScripts(n);
  const t = await (await fetch(n)).text();
  return kI(t, n);
}
function kI(n, e) {
  if (!Mu)
    return fT;
  if (H1)
    return eval.call(xI, n), null;
  const t = document.createElement("script");
  t.id = e;
  try {
    t.appendChild(document.createTextNode(n));
  } catch {
    t.text = n;
  }
  return document.body.appendChild(t), null;
}
function zI(n, e) {
  return !Tu.isSupported() || !Mu && !(e != null && e._nodeWorkers) ? !1 : n.worker && (e == null ? void 0 : e.worker);
}
async function UI(n, e, t, i, r) {
  const l = n.id, c = MI(n, t), g = Tu.getWorkerFarm(t).getWorkerPool({
    name: l,
    url: c
  });
  t = JSON.parse(JSON.stringify(t)), i = JSON.parse(JSON.stringify(i || {}));
  const y = await g.startJob("process-on-worker", jI.bind(null, r));
  return y.postMessage("process", {
    input: e,
    options: t,
    context: i
  }), await (await y.result).result;
}
async function jI(n, e, t, i) {
  switch (t) {
    case "done":
      e.done(i);
      break;
    case "error":
      e.error(new Error(i.error));
      break;
    case "process":
      const {
        id: r,
        input: l,
        options: c
      } = i;
      try {
        const a = await n(l, c);
        e.postMessage("done", {
          id: r,
          result: a
        });
      } catch (a) {
        const g = a instanceof Error ? a.message : "unknown error";
        e.postMessage("error", {
          id: r,
          error: g
        });
      }
      break;
    default:
      console.warn("parse-with-worker unknown message ".concat(t));
  }
}
function GI(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  return typeof n == "string" ? n.slice(0, e) : ArrayBuffer.isView(n) ? rx(n.buffer, n.byteOffset, e) : n instanceof ArrayBuffer ? rx(n, 0, e) : "";
}
function rx(n, e, t) {
  if (n.byteLength <= e + t)
    return "";
  const i = new DataView(n);
  let r = "";
  for (let l = 0; l < t; l++)
    r += String.fromCharCode(i.getUint8(e + l));
  return r;
}
function VI(n) {
  try {
    return JSON.parse(n);
  } catch {
    throw new Error('Failed to parse JSON from data starting with "'.concat(GI(n), '"'));
  }
}
function qI(n, e, t) {
  if (t = t || n.byteLength, n.byteLength < t || e.byteLength < t)
    return !1;
  const i = new Uint8Array(n), r = new Uint8Array(e);
  for (let l = 0; l < i.length; ++l)
    if (i[l] !== r[l])
      return !1;
  return !0;
}
function HI() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  const i = e.map((a) => a instanceof ArrayBuffer ? new Uint8Array(a) : a), r = i.reduce((a, g) => a + g.byteLength, 0), l = new Uint8Array(r);
  let c = 0;
  for (const a of i)
    l.set(a, c), c += a.byteLength;
  return l.buffer;
}
function W1(n, e, t) {
  const i = t !== void 0 ? new Uint8Array(n).subarray(e, e + t) : new Uint8Array(n).subarray(e);
  return new Uint8Array(i).buffer;
}
function zp(n, e) {
  return _r(n >= 0), _r(e > 0), n + (e - 1) & ~(e - 1);
}
function WI(n, e, t) {
  let i;
  if (n instanceof ArrayBuffer)
    i = new Uint8Array(n);
  else {
    const r = n.byteOffset, l = n.byteLength;
    i = new Uint8Array(n.buffer || n.arrayBuffer, r, l);
  }
  return e.set(i, t), t + zp(i.byteLength, 4);
}
async function ZI(n) {
  const e = [];
  for await (const t of n)
    e.push(t);
  return HI(...e);
}
function sx() {
  let n;
  if (typeof window < "u" && window.performance)
    n = window.performance.now();
  else if (typeof process < "u" && process.hrtime) {
    const e = process.hrtime();
    n = e[0] * 1e3 + e[1] / 1e6;
  } else
    n = Date.now();
  return n;
}
class ox {
  constructor(e, t) {
    H(this, "name", void 0), H(this, "type", void 0), H(this, "sampleSize", 1), H(this, "time", void 0), H(this, "count", void 0), H(this, "samples", void 0), H(this, "lastTiming", void 0), H(this, "lastSampleTime", void 0), H(this, "lastSampleCount", void 0), H(this, "_count", 0), H(this, "_time", 0), H(this, "_samples", 0), H(this, "_startTime", 0), H(this, "_timerPending", !1), this.name = e, this.type = t, this.reset();
  }
  setSampleSize(e) {
    return this.sampleSize = e, this;
  }
  incrementCount() {
    return this.addCount(1), this;
  }
  decrementCount() {
    return this.subtractCount(1), this;
  }
  addCount(e) {
    return this._count += e, this._samples++, this._checkSampling(), this;
  }
  subtractCount(e) {
    return this._count -= e, this._samples++, this._checkSampling(), this;
  }
  addTime(e) {
    return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
  }
  timeStart() {
    return this._startTime = sx(), this._timerPending = !0, this;
  }
  timeEnd() {
    return this._timerPending ? (this.addTime(sx() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
  }
  getSampleAverageCount() {
    return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
  }
  getSampleAverageTime() {
    return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
  }
  getSampleHz() {
    return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
  }
  getAverageCount() {
    return this.samples > 0 ? this.count / this.samples : 0;
  }
  getAverageTime() {
    return this.samples > 0 ? this.time / this.samples : 0;
  }
  getHz() {
    return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
  }
  reset() {
    return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
  }
  _checkSampling() {
    this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
  }
}
class Up {
  constructor(e) {
    H(this, "id", void 0), H(this, "stats", {}), this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
  }
  get(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
    return this._getOrCreate({
      name: e,
      type: t
    });
  }
  get size() {
    return Object.keys(this.stats).length;
  }
  reset() {
    for (const e in this.stats)
      this.stats[e].reset();
    return this;
  }
  forEach(e) {
    for (const t in this.stats)
      e(this.stats[t]);
  }
  getTable() {
    const e = {};
    return this.forEach((t) => {
      e[t.name] = {
        time: t.time || 0,
        count: t.count || 0,
        average: t.getAverageTime() || 0,
        hz: t.getHz() || 0
      };
    }), e;
  }
  _initializeStats() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((t) => this._getOrCreate(t));
  }
  _getOrCreate(e) {
    if (!e || !e.name)
      return null;
    const {
      name: t,
      type: i
    } = e;
    return this.stats[t] || (e instanceof ox ? this.stats[t] = e : this.stats[t] = new ox(t, i)), this.stats[t];
  }
}
const $I = "Queued Requests", XI = "Active Requests", YI = "Cancelled Requests", JI = "Queued Requests Ever", KI = "Active Requests Ever", QI = {
  id: "request-scheduler",
  throttleRequests: !0,
  maxRequests: 6
};
class eM {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    H(this, "props", void 0), H(this, "stats", void 0), H(this, "activeRequestCount", 0), H(this, "requestQueue", []), H(this, "requestMap", /* @__PURE__ */ new Map()), H(this, "deferredUpdate", null), this.props = {
      ...QI,
      ...e
    }, this.stats = new Up({
      id: this.props.id
    }), this.stats.get($I), this.stats.get(XI), this.stats.get(YI), this.stats.get(JI), this.stats.get(KI);
  }
  scheduleRequest(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => 0;
    if (!this.props.throttleRequests)
      return Promise.resolve({
        done: () => {
        }
      });
    if (this.requestMap.has(e))
      return this.requestMap.get(e);
    const i = {
      handle: e,
      priority: 0,
      getPriority: t
    }, r = new Promise((l) => (i.resolve = l, i));
    return this.requestQueue.push(i), this.requestMap.set(e, r), this._issueNewRequests(), r;
  }
  _issueRequest(e) {
    const {
      handle: t,
      resolve: i
    } = e;
    let r = !1;
    const l = () => {
      r || (r = !0, this.requestMap.delete(t), this.activeRequestCount--, this._issueNewRequests());
    };
    return this.activeRequestCount++, i ? i({
      done: l
    }) : Promise.resolve({
      done: l
    });
  }
  _issueNewRequests() {
    this.deferredUpdate || (this.deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0));
  }
  _issueNewRequestsAsync() {
    this.deferredUpdate = null;
    const e = Math.max(this.props.maxRequests - this.activeRequestCount, 0);
    if (e !== 0) {
      this._updateAllRequests();
      for (let t = 0; t < e; ++t) {
        const i = this.requestQueue.shift();
        i && this._issueRequest(i);
      }
    }
  }
  _updateAllRequests() {
    const e = this.requestQueue;
    for (let t = 0; t < e.length; ++t) {
      const i = e[t];
      this._updateRequest(i) || (e.splice(t, 1), this.requestMap.delete(i.handle), t--);
    }
    e.sort((t, i) => t.priority - i.priority);
  }
  _updateRequest(e) {
    return e.priority = e.getPriority(e.handle), e.priority < 0 ? (e.resolve(null), !1) : !0;
  }
}
let tM = "";
const ax = {};
function nM(n) {
  for (const e in ax)
    if (n.startsWith(e)) {
      const t = ax[e];
      n = n.replace(e, t);
    }
  return !n.startsWith("http://") && !n.startsWith("https://") && (n = "".concat(tM).concat(n)), n;
}
function iM(n) {
  return n && typeof n == "object" && n.isBuffer;
}
function pT(n) {
  if (iM(n))
    return n;
  if (n instanceof ArrayBuffer)
    return n;
  if (ArrayBuffer.isView(n))
    return n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength);
  if (typeof n == "string") {
    const e = n;
    return new TextEncoder().encode(e).buffer;
  }
  if (n && typeof n == "object" && n._toArrayBuffer)
    return n._toArrayBuffer();
  throw new Error("toArrayBuffer");
}
function gT(n) {
  const e = n ? n.lastIndexOf("/") : -1;
  return e >= 0 ? n.substr(e + 1) : "";
}
function Z1(n) {
  const e = n ? n.lastIndexOf("/") : -1;
  return e >= 0 ? n.substr(0, e) : "";
}
const rM = (n) => typeof n == "boolean", mp = (n) => typeof n == "function", jp = (n) => n !== null && typeof n == "object", lx = (n) => jp(n) && n.constructor === {}.constructor, sM = (n) => n && typeof n[Symbol.iterator] == "function", oM = (n) => n && typeof n[Symbol.asyncIterator] == "function", nd = (n) => typeof Response < "u" && n instanceof Response || n && n.arrayBuffer && n.text && n.json, id = (n) => typeof Blob < "u" && n instanceof Blob, aM = (n) => n && typeof n == "object" && n.isBuffer, lM = (n) => typeof ReadableStream < "u" && n instanceof ReadableStream || jp(n) && mp(n.tee) && mp(n.cancel) && mp(n.getReader), cM = (n) => jp(n) && mp(n.read) && mp(n.pipe) && rM(n.readable), mT = (n) => lM(n) || cM(n), uM = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, hM = /^([-\w.]+\/[-\w.+]+)/;
function dM(n) {
  const e = hM.exec(n);
  return e ? e[1] : n;
}
function cx(n) {
  const e = uM.exec(n);
  return e ? e[1] : "";
}
const _T = /\?.*/;
function fM(n) {
  const e = n.match(_T);
  return e && e[0];
}
function $1(n) {
  return n.replace(_T, "");
}
function Km(n) {
  return nd(n) ? n.url : id(n) ? n.name || "" : typeof n == "string" ? n : "";
}
function X1(n) {
  if (nd(n)) {
    const e = n, t = e.headers.get("content-type") || "", i = $1(e.url);
    return dM(t) || cx(i);
  }
  return id(n) ? n.type || "" : typeof n == "string" ? cx(n) : "";
}
function pM(n) {
  return nd(n) ? n.headers["content-length"] || -1 : id(n) ? n.size : typeof n == "string" ? n.length : n instanceof ArrayBuffer || ArrayBuffer.isView(n) ? n.byteLength : -1;
}
async function yT(n) {
  if (nd(n))
    return n;
  const e = {}, t = pM(n);
  t >= 0 && (e["content-length"] = String(t));
  const i = Km(n), r = X1(n);
  r && (e["content-type"] = r);
  const l = await _M(n);
  l && (e["x-first-bytes"] = l), typeof n == "string" && (n = new TextEncoder().encode(n));
  const c = new Response(n, {
    headers: e
  });
  return Object.defineProperty(c, "url", {
    value: i
  }), c;
}
async function gM(n) {
  if (!n.ok) {
    const e = await mM(n);
    throw new Error(e);
  }
}
async function mM(n) {
  let e = "Failed to fetch resource ".concat(n.url, " (").concat(n.status, "): ");
  try {
    const t = n.headers.get("Content-Type");
    let i = n.statusText;
    t.includes("application/json") && (i += " ".concat(await n.text())), e += i, e = e.length > 60 ? "".concat(e.slice(0, 60), "...") : e;
  } catch {
  }
  return e;
}
async function _M(n) {
  if (typeof n == "string")
    return "data:,".concat(n.slice(0, 5));
  if (n instanceof Blob) {
    const t = n.slice(0, 5);
    return await new Promise((i) => {
      const r = new FileReader();
      r.onload = (l) => {
        var c;
        return i(l == null || (c = l.target) === null || c === void 0 ? void 0 : c.result);
      }, r.readAsDataURL(t);
    });
  }
  if (n instanceof ArrayBuffer) {
    const t = n.slice(0, 5), i = yM(t);
    return "data:base64,".concat(i);
  }
  return null;
}
function yM(n) {
  let e = "";
  const t = new Uint8Array(n);
  for (let i = 0; i < t.byteLength; i++)
    e += String.fromCharCode(t[i]);
  return btoa(e);
}
async function ux(n, e) {
  if (typeof n == "string") {
    n = nM(n);
    let t = e;
    return e != null && e.fetch && typeof (e == null ? void 0 : e.fetch) != "function" && (t = e.fetch), await fetch(n, t);
  }
  return await yT(n);
}
function bT(n) {
  if (typeof window < "u" && typeof window.process == "object" && window.process.type === "renderer" || typeof process < "u" && typeof process.versions == "object" && process.versions.electron)
    return !0;
  const t = typeof navigator == "object" && typeof navigator.userAgent == "string" && navigator.userAgent;
  return !!(t && t.indexOf("Electron") >= 0);
}
function Fu() {
  return !(typeof process == "object" && String(process) === "[object process]" && !process.browser) || bT();
}
const nm = {
  self: typeof self < "u" && self,
  window: typeof window < "u" && window,
  global: typeof global < "u" && global,
  document: typeof document < "u" && document,
  process: typeof process == "object" && process
}, Tg = nm.window || nm.self || nm.global, Zf = nm.process || {}, vT = typeof __VERSION__ < "u" ? __VERSION__ : "untranspiled source";
Fu();
const p0 = globalThis;
function xT(n) {
  if (!Fu())
    return "Node";
  if (bT())
    return "Electron";
  const t = (typeof navigator < "u" ? navigator : {}).userAgent || "";
  if (t.indexOf("Edge") > -1)
    return "Edge";
  const i = t.indexOf("MSIE ") !== -1, r = t.indexOf("Trident/") !== -1;
  return i || r ? "IE" : p0.chrome ? "Chrome" : p0.safari ? "Safari" : p0.mozInnerScreenX ? "Firefox" : "Unknown";
}
function bM(n) {
  try {
    const e = window[n], t = "__storage_test__";
    return e.setItem(t, t), e.removeItem(t), e;
  } catch {
    return null;
  }
}
class vM {
  constructor(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
    H(this, "storage", void 0), H(this, "id", void 0), H(this, "config", void 0), this.storage = bM(i), this.id = e, this.config = t, this._loadConfiguration();
  }
  getConfiguration() {
    return this.config;
  }
  setConfiguration(e) {
    if (Object.assign(this.config, e), this.storage) {
      const t = JSON.stringify(this.config);
      this.storage.setItem(this.id, t);
    }
  }
  _loadConfiguration() {
    let e = {};
    if (this.storage) {
      const t = this.storage.getItem(this.id);
      e = t ? JSON.parse(t) : {};
    }
    return Object.assign(this.config, e), this;
  }
}
function xM(n) {
  let e;
  return n < 10 ? e = "".concat(n.toFixed(2), "ms") : n < 100 ? e = "".concat(n.toFixed(1), "ms") : n < 1e3 ? e = "".concat(n.toFixed(0), "ms") : e = "".concat((n / 1e3).toFixed(2), "s"), e;
}
function wM(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
  const t = Math.max(e - n.length, 0);
  return "".concat(" ".repeat(t)).concat(n);
}
function g0(n, e, t) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
  const r = n.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
  n.width > i && (t = Math.min(t, i / n.width));
  const l = n.width * t, c = n.height * t, a = ["font-size:1px;", "padding:".concat(Math.floor(c / 2), "px ").concat(Math.floor(l / 2), "px;"), "line-height:".concat(c, "px;"), "background:url(".concat(r, ");"), "background-size:".concat(l, "px ").concat(c, "px;"), "color:transparent;"].join("");
  return ["".concat(e, " %c+"), a];
}
let Cm;
(function(n) {
  n[n.BLACK = 30] = "BLACK", n[n.RED = 31] = "RED", n[n.GREEN = 32] = "GREEN", n[n.YELLOW = 33] = "YELLOW", n[n.BLUE = 34] = "BLUE", n[n.MAGENTA = 35] = "MAGENTA", n[n.CYAN = 36] = "CYAN", n[n.WHITE = 37] = "WHITE", n[n.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", n[n.BRIGHT_RED = 91] = "BRIGHT_RED", n[n.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", n[n.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", n[n.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", n[n.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", n[n.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", n[n.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
})(Cm || (Cm = {}));
function hx(n) {
  return typeof n == "string" ? Cm[n.toUpperCase()] || Cm.WHITE : n;
}
function AM(n, e, t) {
  return !Fu && typeof n == "string" && (e && (e = hx(e), n = "\x1B[".concat(e, "m").concat(n, "\x1B[39m")), t && (e = hx(t), n = "\x1B[".concat(t + 10, "m").concat(n, "\x1B[49m"))), n;
}
function TM(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
  const t = Object.getPrototypeOf(n), i = Object.getOwnPropertyNames(t);
  for (const r of i)
    typeof n[r] == "function" && (e.find((l) => r === l) || (n[r] = n[r].bind(n)));
}
function Pm(n, e) {
  if (!n)
    throw new Error(e || "Assertion failed");
}
function Cd() {
  let n;
  if (Fu && "performance" in Tg) {
    var e, t;
    n = Tg == null || (e = Tg.performance) === null || e === void 0 || (t = e.now) === null || t === void 0 ? void 0 : t.call(e);
  } else if ("hrtime" in Zf) {
    var i;
    const r = Zf == null || (i = Zf.hrtime) === null || i === void 0 ? void 0 : i.call(Zf);
    n = r[0] * 1e3 + r[1] / 1e6;
  } else
    n = Date.now();
  return n;
}
const Pd = {
  debug: Fu && console.debug || console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
}, EM = {
  enabled: !0,
  level: 0
};
function Tl() {
}
const dx = {}, fx = {
  once: !0
};
class Gp {
  constructor() {
    let {
      id: e
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      id: ""
    };
    H(this, "id", void 0), H(this, "VERSION", vT), H(this, "_startTs", Cd()), H(this, "_deltaTs", Cd()), H(this, "_storage", void 0), H(this, "userData", {}), H(this, "LOG_THROTTLE_TIMEOUT", 0), this.id = e, this.userData = {}, this._storage = new vM("__probe-".concat(this.id, "__"), EM), this.timeStamp("".concat(this.id, " started")), TM(this), Object.seal(this);
  }
  set level(e) {
    this.setLevel(e);
  }
  get level() {
    return this.getLevel();
  }
  isEnabled() {
    return this._storage.config.enabled;
  }
  getLevel() {
    return this._storage.config.level;
  }
  getTotal() {
    return Number((Cd() - this._startTs).toPrecision(10));
  }
  getDelta() {
    return Number((Cd() - this._deltaTs).toPrecision(10));
  }
  set priority(e) {
    this.level = e;
  }
  get priority() {
    return this.level;
  }
  getPriority() {
    return this.level;
  }
  enable() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    return this._storage.setConfiguration({
      enabled: e
    }), this;
  }
  setLevel(e) {
    return this._storage.setConfiguration({
      level: e
    }), this;
  }
  get(e) {
    return this._storage.config[e];
  }
  set(e, t) {
    this._storage.setConfiguration({
      [e]: t
    });
  }
  settings() {
    console.table ? console.table(this._storage.config) : console.log(this._storage.config);
  }
  assert(e, t) {
    Pm(e, t);
  }
  warn(e) {
    return this._getLogFunction(0, e, Pd.warn, arguments, fx);
  }
  error(e) {
    return this._getLogFunction(0, e, Pd.error, arguments);
  }
  deprecated(e, t) {
    return this.warn("`".concat(e, "` is deprecated and will be removed in a later version. Use `").concat(t, "` instead"));
  }
  removed(e, t) {
    return this.error("`".concat(e, "` has been removed. Use `").concat(t, "` instead"));
  }
  probe(e, t) {
    return this._getLogFunction(e, t, Pd.log, arguments, {
      time: !0,
      once: !0
    });
  }
  log(e, t) {
    return this._getLogFunction(e, t, Pd.debug, arguments);
  }
  info(e, t) {
    return this._getLogFunction(e, t, console.info, arguments);
  }
  once(e, t) {
    for (var i = arguments.length, r = new Array(i > 2 ? i - 2 : 0), l = 2; l < i; l++)
      r[l - 2] = arguments[l];
    return this._getLogFunction(e, t, Pd.debug || Pd.info, arguments, fx);
  }
  table(e, t, i) {
    return t ? this._getLogFunction(e, t, console.table || Tl, i && [i], {
      tag: IM(t)
    }) : Tl;
  }
  image(e) {
    let {
      logLevel: t,
      priority: i,
      image: r,
      message: l = "",
      scale: c = 1
    } = e;
    return this._shouldLog(t || i) ? Fu ? PM({
      image: r,
      message: l,
      scale: c
    }) : CM() : Tl;
  }
  time(e, t) {
    return this._getLogFunction(e, t, console.time ? console.time : console.info);
  }
  timeEnd(e, t) {
    return this._getLogFunction(e, t, console.timeEnd ? console.timeEnd : console.info);
  }
  timeStamp(e, t) {
    return this._getLogFunction(e, t, console.timeStamp || Tl);
  }
  group(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      collapsed: !1
    };
    const r = px({
      logLevel: e,
      message: t,
      opts: i
    }), {
      collapsed: l
    } = i;
    return r.method = (l ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(r);
  }
  groupCollapsed(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.group(e, t, Object.assign({}, i, {
      collapsed: !0
    }));
  }
  groupEnd(e) {
    return this._getLogFunction(e, "", console.groupEnd || Tl);
  }
  withGroup(e, t, i) {
    this.group(e, t)();
    try {
      i();
    } finally {
      this.groupEnd(e)();
    }
  }
  trace() {
    console.trace && console.trace();
  }
  _shouldLog(e) {
    return this.isEnabled() && this.getLevel() >= wT(e);
  }
  _getLogFunction(e, t, i, r, l) {
    if (this._shouldLog(e)) {
      l = px({
        logLevel: e,
        message: t,
        args: r,
        opts: l
      }), i = i || l.method, Pm(i), l.total = this.getTotal(), l.delta = this.getDelta(), this._deltaTs = Cd();
      const c = l.tag || l.message;
      if (l.once)
        if (!dx[c])
          dx[c] = Cd();
        else
          return Tl;
      return t = SM(this.id, l.message, l), i.bind(console, t, ...l.args);
    }
    return Tl;
  }
}
H(Gp, "VERSION", vT);
function wT(n) {
  if (!n)
    return 0;
  let e;
  switch (typeof n) {
    case "number":
      e = n;
      break;
    case "object":
      e = n.logLevel || n.priority || 0;
      break;
    default:
      return 0;
  }
  return Pm(Number.isFinite(e) && e >= 0), e;
}
function px(n) {
  const {
    logLevel: e,
    message: t
  } = n;
  n.logLevel = wT(e);
  const i = n.args ? Array.from(n.args) : [];
  for (; i.length && i.shift() !== t; )
    ;
  switch (typeof e) {
    case "string":
    case "function":
      t !== void 0 && i.unshift(t), n.message = e;
      break;
    case "object":
      Object.assign(n, e);
      break;
  }
  typeof n.message == "function" && (n.message = n.message());
  const r = typeof n.message;
  return Pm(r === "string" || r === "object"), Object.assign(n, {
    args: i
  }, n.opts);
}
function SM(n, e, t) {
  if (typeof e == "string") {
    const i = t.time ? wM(xM(t.total)) : "";
    e = t.time ? "".concat(n, ": ").concat(i, "  ").concat(e) : "".concat(n, ": ").concat(e), e = AM(e, t.color, t.background);
  }
  return e;
}
function CM(n) {
  return console.warn("removed"), Tl;
}
function PM(n) {
  let {
    image: e,
    message: t = "",
    scale: i = 1
  } = n;
  if (typeof e == "string") {
    const l = new Image();
    return l.onload = () => {
      const c = g0(l, t, i);
      console.log(...c);
    }, l.src = e, Tl;
  }
  const r = e.nodeName || "";
  if (r.toLowerCase() === "img")
    return console.log(...g0(e, t, i)), Tl;
  if (r.toLowerCase() === "canvas") {
    const l = new Image();
    return l.onload = () => console.log(...g0(l, t, i)), l.src = e.toDataURL(), Tl;
  }
  return Tl;
}
function IM(n) {
  for (const e in n)
    for (const t in n[e])
      return t || "untitled";
  return "empty";
}
const gx = new Gp({
  id: "loaders.gl"
});
class MM {
  log() {
    return () => {
    };
  }
  info() {
    return () => {
    };
  }
  warn() {
    return () => {
    };
  }
  error() {
    return () => {
    };
  }
}
class LM {
  constructor() {
    H(this, "console", void 0), this.console = console;
  }
  log() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.console.log.bind(this.console, ...t);
  }
  info() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.console.info.bind(this.console, ...t);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.console.warn.bind(this.console, ...t);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.console.error.bind(this.console, ...t);
  }
}
const AT = {
  fetch: null,
  mimeType: void 0,
  nothrow: !1,
  log: new LM(),
  CDN: "https://unpkg.com/@loaders.gl",
  worker: !0,
  maxConcurrency: 3,
  maxMobileConcurrency: 1,
  reuseWorkers: Jm,
  _nodeWorkers: !1,
  _workerType: "",
  limit: 0,
  _limitMB: 0,
  batchSize: "auto",
  batchDebounceMs: 0,
  metadata: !1,
  transforms: []
}, RM = {
  throws: "nothrow",
  dataType: "(no longer used)",
  uri: "baseUri",
  method: "fetch.method",
  headers: "fetch.headers",
  body: "fetch.body",
  mode: "fetch.mode",
  credentials: "fetch.credentials",
  cache: "fetch.cache",
  redirect: "fetch.redirect",
  referrer: "fetch.referrer",
  referrerPolicy: "fetch.referrerPolicy",
  integrity: "fetch.integrity",
  keepalive: "fetch.keepalive",
  signal: "fetch.signal"
};
function TT() {
  globalThis.loaders = globalThis.loaders || {};
  const {
    loaders: n
  } = globalThis;
  return n._state = n._state || {}, n._state;
}
const ET = () => {
  const n = TT();
  return n.globalOptions = n.globalOptions || {
    ...AT
  }, n.globalOptions;
};
function BM(n, e, t, i) {
  return t = t || [], t = Array.isArray(t) ? t : [t], OM(n, t), FM(e, n, i);
}
function OM(n, e) {
  mx(n, null, AT, RM, e);
  for (const t of e) {
    const i = n && n[t.id] || {}, r = t.options && t.options[t.id] || {}, l = t.deprecatedOptions && t.deprecatedOptions[t.id] || {};
    mx(i, t.id, r, l, e);
  }
}
function mx(n, e, t, i, r) {
  const l = e || "Top level", c = e ? "".concat(e, ".") : "";
  for (const a in n) {
    const g = !e && jp(n[a]), y = a === "baseUri" && !e, A = a === "workerUrl" && e;
    if (!(a in t) && !y && !A) {
      if (a in i)
        gx.warn("".concat(l, " loader option '").concat(c).concat(a, "' no longer supported, use '").concat(i[a], "'"))();
      else if (!g) {
        const C = DM(a, r);
        gx.warn("".concat(l, " loader option '").concat(c).concat(a, "' not recognized. ").concat(C))();
      }
    }
  }
}
function DM(n, e) {
  const t = n.toLowerCase();
  let i = "";
  for (const r of e)
    for (const l in r.options) {
      if (n === l)
        return "Did you mean '".concat(r.id, ".").concat(l, "'?");
      const c = l.toLowerCase();
      (t.startsWith(c) || c.startsWith(t)) && (i = i || "Did you mean '".concat(r.id, ".").concat(l, "'?"));
    }
  return i;
}
function FM(n, e, t) {
  const r = {
    ...n.options || {}
  };
  return NM(r, t), r.log === null && (r.log = new MM()), _x(r, ET()), _x(r, e), r;
}
function _x(n, e) {
  for (const t in e)
    if (t in e) {
      const i = e[t];
      lx(i) && lx(n[t]) ? n[t] = {
        ...n[t],
        ...e[t]
      } : n[t] = e[t];
    }
}
function NM(n, e) {
  e && !("baseUri" in n) && (n.baseUri = e);
}
function Y1(n) {
  var e;
  return n ? (Array.isArray(n) && (n = n[0]), Array.isArray((e = n) === null || e === void 0 ? void 0 : e.extensions)) : !1;
}
function J1(n) {
  var e, t;
  _r(n, "null loader"), _r(Y1(n), "invalid loader");
  let i;
  return Array.isArray(n) && (i = n[1], n = n[0], n = {
    ...n,
    options: {
      ...n.options,
      ...i
    }
  }), ((e = n) !== null && e !== void 0 && e.parseTextSync || (t = n) !== null && t !== void 0 && t.parseText) && (n.text = !0), n.text || (n.binary = !0), n;
}
const ST = () => {
  const n = TT();
  return n.loaderRegistry = n.loaderRegistry || [], n.loaderRegistry;
};
function kM(n) {
  const e = ST();
  n = Array.isArray(n) ? n : [n];
  for (const t of n) {
    const i = J1(t);
    e.find((r) => i === r) || e.unshift(i);
  }
}
function zM() {
  return ST();
}
const UM = new Gp({
  id: "loaders.gl"
}), jM = /\.([^.]+)$/;
async function GM(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 ? arguments[3] : void 0;
  if (!CT(n))
    return null;
  let r = yx(n, e, {
    ...t,
    nothrow: !0
  }, i);
  if (r)
    return r;
  if (id(n) && (n = await n.slice(0, 10).arrayBuffer(), r = yx(n, e, t, i)), !r && !(t != null && t.nothrow))
    throw new Error(PT(n));
  return r;
}
function yx(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 ? arguments[3] : void 0;
  if (!CT(n))
    return null;
  if (e && !Array.isArray(e))
    return J1(e);
  let r = [];
  e && (r = r.concat(e)), t != null && t.ignoreRegisteredLoaders || r.push(...zM()), qM(r);
  const l = VM(n, r, t, i);
  if (!l && !(t != null && t.nothrow))
    throw new Error(PT(n));
  return l;
}
function VM(n, e, t, i) {
  const r = Km(n), l = X1(n), c = $1(r) || (i == null ? void 0 : i.url);
  let a = null, g = "";
  if (t != null && t.mimeType && (a = m0(e, t == null ? void 0 : t.mimeType), g = "match forced by supplied MIME type ".concat(t == null ? void 0 : t.mimeType)), a = a || HM(e, c), g = g || (a ? "matched url ".concat(c) : ""), a = a || m0(e, l), g = g || (a ? "matched MIME type ".concat(l) : ""), a = a || ZM(e, n), g = g || (a ? "matched initial data ".concat(IT(n)) : ""), a = a || m0(e, t == null ? void 0 : t.fallbackMimeType), g = g || (a ? "matched fallback MIME type ".concat(l) : ""), g) {
    var y;
    UM.log(1, "selectLoader selected ".concat((y = a) === null || y === void 0 ? void 0 : y.name, ": ").concat(g, "."));
  }
  return a;
}
function CT(n) {
  return !(n instanceof Response && n.status === 204);
}
function PT(n) {
  const e = Km(n), t = X1(n);
  let i = "No valid loader found (";
  i += e ? "".concat(gT(e), ", ") : "no url provided, ", i += "MIME type: ".concat(t ? '"'.concat(t, '"') : "not provided", ", ");
  const r = n ? IT(n) : "";
  return i += r ? ' first bytes: "'.concat(r, '"') : "first bytes: not available", i += ")", i;
}
function qM(n) {
  for (const e of n)
    J1(e);
}
function HM(n, e) {
  const t = e && jM.exec(e), i = t && t[1];
  return i ? WM(n, i) : null;
}
function WM(n, e) {
  e = e.toLowerCase();
  for (const t of n)
    for (const i of t.extensions)
      if (i.toLowerCase() === e)
        return t;
  return null;
}
function m0(n, e) {
  for (const t of n)
    if (t.mimeTypes && t.mimeTypes.includes(e) || e === "application/x.".concat(t.id))
      return t;
  return null;
}
function ZM(n, e) {
  if (!e)
    return null;
  for (const t of n)
    if (typeof e == "string") {
      if ($M(e, t))
        return t;
    } else if (ArrayBuffer.isView(e)) {
      if (bx(e.buffer, e.byteOffset, t))
        return t;
    } else if (e instanceof ArrayBuffer && bx(e, 0, t))
      return t;
  return null;
}
function $M(n, e) {
  return e.testText ? e.testText(n) : (Array.isArray(e.tests) ? e.tests : [e.tests]).some((i) => n.startsWith(i));
}
function bx(n, e, t) {
  return (Array.isArray(t.tests) ? t.tests : [t.tests]).some((r) => XM(n, e, t, r));
}
function XM(n, e, t, i) {
  if (i instanceof ArrayBuffer)
    return qI(i, n, i.byteLength);
  switch (typeof i) {
    case "function":
      return i(n, t);
    case "string":
      const r = Ny(n, e, i.length);
      return i === r;
    default:
      return !1;
  }
}
function IT(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
  return typeof n == "string" ? n.slice(0, e) : ArrayBuffer.isView(n) ? Ny(n.buffer, n.byteOffset, e) : n instanceof ArrayBuffer ? Ny(n, 0, e) : "";
}
function Ny(n, e, t) {
  if (n.byteLength < e + t)
    return "";
  const i = new DataView(n);
  let r = "";
  for (let l = 0; l < t; l++)
    r += String.fromCharCode(i.getUint8(e + l));
  return r;
}
const YM = 256 * 1024;
function* JM(n, e) {
  const t = (e == null ? void 0 : e.chunkSize) || YM;
  let i = 0;
  const r = new TextEncoder();
  for (; i < n.length; ) {
    const l = Math.min(n.length - i, t), c = n.slice(i, i + l);
    i += l, yield r.encode(c);
  }
}
const KM = 256 * 1024;
function QM(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    const {
      chunkSize: t = KM
    } = e;
    let i = 0;
    for (; i < n.byteLength; ) {
      const r = Math.min(n.byteLength - i, t), l = new ArrayBuffer(r), c = new Uint8Array(n, i, r);
      new Uint8Array(l).set(c), i += r, yield l;
    }
  }();
}
const eL = 1024 * 1024;
async function* tL(n, e) {
  const t = (e == null ? void 0 : e.chunkSize) || eL;
  let i = 0;
  for (; i < n.size; ) {
    const r = i + t, l = await n.slice(i, r).arrayBuffer();
    i = r, yield l;
  }
}
function vx(n, e) {
  return Jm ? nL(n, e) : iL(n);
}
async function* nL(n, e) {
  const t = n.getReader();
  let i;
  try {
    for (; ; ) {
      const r = i || t.read();
      e != null && e._streamReadAhead && (i = t.read());
      const {
        done: l,
        value: c
      } = await r;
      if (l)
        return;
      yield pT(c);
    }
  } catch {
    t.releaseLock();
  }
}
async function* iL(n, e) {
  for await (const t of n)
    yield pT(t);
}
function rL(n, e) {
  if (typeof n == "string")
    return JM(n, e);
  if (n instanceof ArrayBuffer)
    return QM(n, e);
  if (id(n))
    return tL(n, e);
  if (mT(n))
    return vx(n, e);
  if (nd(n))
    return vx(n.body, e);
  throw new Error("makeIterator");
}
const MT = "Cannot convert supplied data type";
function sL(n, e, t) {
  if (e.text && typeof n == "string")
    return n;
  if (aM(n) && (n = n.buffer), n instanceof ArrayBuffer) {
    const i = n;
    return e.text && !e.binary ? new TextDecoder("utf8").decode(i) : i;
  }
  if (ArrayBuffer.isView(n)) {
    if (e.text && !e.binary)
      return new TextDecoder("utf8").decode(n);
    let i = n.buffer;
    const r = n.byteLength || n.length;
    return (n.byteOffset !== 0 || r !== i.byteLength) && (i = i.slice(n.byteOffset, n.byteOffset + r)), i;
  }
  throw new Error(MT);
}
async function oL(n, e, t) {
  const i = n instanceof ArrayBuffer || ArrayBuffer.isView(n);
  if (typeof n == "string" || i)
    return sL(n, e);
  if (id(n) && (n = await yT(n)), nd(n)) {
    const r = n;
    return await gM(r), e.binary ? await r.arrayBuffer() : await r.text();
  }
  if (mT(n) && (n = rL(n, t)), sM(n) || oM(n))
    return ZI(n);
  throw new Error(MT);
}
function LT(n, e) {
  const t = ET(), i = n || t;
  return typeof i.fetch == "function" ? i.fetch : jp(i.fetch) ? (r) => ux(r, i) : e != null && e.fetch ? e == null ? void 0 : e.fetch : ux;
}
function aL(n, e, t) {
  if (t)
    return t;
  const i = {
    fetch: LT(e, n),
    ...n
  };
  if (i.url) {
    const r = $1(i.url);
    i.baseUrl = r, i.queryString = fM(i.url), i.filename = gT(r), i.baseUrl = Z1(r);
  }
  return Array.isArray(i.loaders) || (i.loaders = null), i;
}
function lL(n, e) {
  if (!e && n && !Array.isArray(n))
    return n;
  let t;
  if (n && (t = Array.isArray(n) ? n : [n]), e && e.loaders) {
    const i = Array.isArray(e.loaders) ? e.loaders : [e.loaders];
    t = t ? [...t, ...i] : i;
  }
  return t && t.length ? t : null;
}
async function K1(n, e, t, i) {
  nu(!i || typeof i == "object"), e && !Array.isArray(e) && !Y1(e) && (i = void 0, t = e, e = void 0), n = await n, t = t || {};
  const r = Km(n), c = lL(e, i), a = await GM(n, c, t);
  return a ? (t = BM(t, a, c, r), i = aL({
    url: r,
    parse: K1,
    loaders: c
  }, t, i || null), await cL(a, n, t, i)) : null;
}
async function cL(n, e, t, i) {
  if (LI(n), nd(e)) {
    const r = e, {
      ok: l,
      redirected: c,
      status: a,
      statusText: g,
      type: y,
      url: A
    } = r, C = Object.fromEntries(r.headers.entries());
    i.response = {
      headers: C,
      ok: l,
      redirected: c,
      status: a,
      statusText: g,
      type: y,
      url: A
    };
  }
  if (e = await oL(e, n, t), n.parseTextSync && typeof e == "string")
    return t.dataType = "text", n.parseTextSync(e, t, i, n);
  if (zI(n, t))
    return await UI(n, e, t, i, K1);
  if (n.parseText && typeof e == "string")
    return await n.parseText(e, t, i, n);
  if (n.parse)
    return await n.parse(e, t, i, n);
  throw nu(!n.parseSync), new Error("".concat(n.id, " loader - no parser found and worker is disabled"));
}
async function gh(n, e, t, i) {
  !Array.isArray(e) && !Y1(e) && (t = e, e = void 0);
  const r = LT(t);
  let l = n;
  return typeof n == "string" && (l = await r(n)), id(n) && (l = await r(n)), await K1(l, e, t);
}
const uL = "3.4.15", {
  _parseImageNode: hL
} = globalThis, ky = typeof Image < "u", zy = typeof ImageBitmap < "u", dL = !!hL, Uy = Jm ? !0 : dL;
function fL(n) {
  switch (n) {
    case "auto":
      return zy || ky || Uy;
    case "imagebitmap":
      return zy;
    case "image":
      return ky;
    case "data":
      return Uy;
    default:
      throw new Error("@loaders.gl/images: image ".concat(n, " not supported in this environment"));
  }
}
function pL() {
  if (zy)
    return "imagebitmap";
  if (ky)
    return "image";
  if (Uy)
    return "data";
  throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
}
function gL(n) {
  const e = _L(n);
  if (!e)
    throw new Error("Not an image");
  return e;
}
function mL(n) {
  switch (gL(n)) {
    case "data":
      return n;
    case "image":
    case "imagebitmap":
      const e = document.createElement("canvas"), t = e.getContext("2d");
      if (!t)
        throw new Error("getImageData");
      return e.width = n.width, e.height = n.height, t.drawImage(n, 0, 0), t.getImageData(0, 0, n.width, n.height);
    default:
      throw new Error("getImageData");
  }
}
function _L(n) {
  return typeof ImageBitmap < "u" && n instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && n instanceof Image ? "image" : n && typeof n == "object" && n.data && n.width && n.height ? "data" : null;
}
const yL = /^data:image\/svg\+xml/, bL = /\.svg((\?|#).*)?$/;
function Q1(n) {
  return n && (yL.test(n) || bL.test(n));
}
function vL(n, e) {
  if (Q1(e)) {
    let i = new TextDecoder().decode(n);
    try {
      typeof unescape == "function" && typeof encodeURIComponent == "function" && (i = unescape(encodeURIComponent(i)));
    } catch (l) {
      throw new Error(l.message);
    }
    return "data:image/svg+xml;base64,".concat(btoa(i));
  }
  return RT(n, e);
}
function RT(n, e) {
  if (Q1(e))
    throw new Error("SVG cannot be parsed directly to imagebitmap");
  return new Blob([new Uint8Array(n)]);
}
async function BT(n, e, t) {
  const i = vL(n, t), r = self.URL || self.webkitURL, l = typeof i != "string" && r.createObjectURL(i);
  try {
    return await xL(l || i, e);
  } finally {
    l && r.revokeObjectURL(l);
  }
}
async function xL(n, e) {
  const t = new Image();
  return t.src = n, e.image && e.image.decode && t.decode ? (await t.decode(), t) : await new Promise((i, r) => {
    try {
      t.onload = () => i(t), t.onerror = (l) => r(new Error("Could not load image ".concat(n, ": ").concat(l)));
    } catch (l) {
      r(l);
    }
  });
}
const wL = {};
let xx = !0;
async function AL(n, e, t) {
  let i;
  Q1(t) ? i = await BT(n, e, t) : i = RT(n, t);
  const r = e && e.imagebitmap;
  return await TL(i, r);
}
async function TL(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  if ((EL(e) || !xx) && (e = null), e)
    try {
      return await createImageBitmap(n, e);
    } catch (t) {
      console.warn(t), xx = !1;
    }
  return await createImageBitmap(n);
}
function EL(n) {
  for (const e in n || wL)
    return !1;
  return !0;
}
function SL(n) {
  return !ML(n, "ftyp", 4) || !(n[8] & 96) ? null : CL(n);
}
function CL(n) {
  switch (PL(n, 8, 12).replace("\0", " ").trim()) {
    case "avif":
    case "avis":
      return {
        extension: "avif",
        mimeType: "image/avif"
      };
    default:
      return null;
  }
}
function PL(n, e, t) {
  return String.fromCharCode(...n.slice(e, t));
}
function IL(n) {
  return [...n].map((e) => e.charCodeAt(0));
}
function ML(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const i = IL(e);
  for (let r = 0; r < i.length; ++r)
    if (i[r] !== n[r + t])
      return !1;
  return !0;
}
const Xc = !1, _p = !0;
function eb(n) {
  const e = Vp(n);
  return RL(e) || DL(e) || BL(e) || OL(e) || LL(e);
}
function LL(n) {
  const e = new Uint8Array(n instanceof DataView ? n.buffer : n), t = SL(e);
  return t ? {
    mimeType: t.mimeType,
    width: 0,
    height: 0
  } : null;
}
function RL(n) {
  const e = Vp(n);
  return e.byteLength >= 24 && e.getUint32(0, Xc) === 2303741511 ? {
    mimeType: "image/png",
    width: e.getUint32(16, Xc),
    height: e.getUint32(20, Xc)
  } : null;
}
function BL(n) {
  const e = Vp(n);
  return e.byteLength >= 10 && e.getUint32(0, Xc) === 1195984440 ? {
    mimeType: "image/gif",
    width: e.getUint16(6, _p),
    height: e.getUint16(8, _p)
  } : null;
}
function OL(n) {
  const e = Vp(n);
  return e.byteLength >= 14 && e.getUint16(0, Xc) === 16973 && e.getUint32(2, _p) === e.byteLength ? {
    mimeType: "image/bmp",
    width: e.getUint32(18, _p),
    height: e.getUint32(22, _p)
  } : null;
}
function DL(n) {
  const e = Vp(n);
  if (!(e.byteLength >= 3 && e.getUint16(0, Xc) === 65496 && e.getUint8(2) === 255))
    return null;
  const {
    tableMarkers: i,
    sofMarkers: r
  } = FL();
  let l = 2;
  for (; l + 9 < e.byteLength; ) {
    const c = e.getUint16(l, Xc);
    if (r.has(c))
      return {
        mimeType: "image/jpeg",
        height: e.getUint16(l + 5, Xc),
        width: e.getUint16(l + 7, Xc)
      };
    if (!i.has(c))
      return null;
    l += 2, l += e.getUint16(l, Xc);
  }
  return null;
}
function FL() {
  const n = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
  for (let t = 65504; t < 65520; ++t)
    n.add(t);
  return {
    tableMarkers: n,
    sofMarkers: /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502])
  };
}
function Vp(n) {
  if (n instanceof DataView)
    return n;
  if (ArrayBuffer.isView(n))
    return new DataView(n.buffer);
  if (n instanceof ArrayBuffer)
    return new DataView(n);
  throw new Error("toDataView");
}
async function NL(n, e) {
  const {
    mimeType: t
  } = eb(n) || {}, i = globalThis._parseImageNode;
  return _r(i), await i(n, t);
}
async function kL(n, e, t) {
  e = e || {};
  const r = (e.image || {}).type || "auto", {
    url: l
  } = t || {}, c = zL(r);
  let a;
  switch (c) {
    case "imagebitmap":
      a = await AL(n, e, l);
      break;
    case "image":
      a = await BT(n, e, l);
      break;
    case "data":
      a = await NL(n);
      break;
    default:
      _r(!1);
  }
  return r === "data" && (a = mL(a)), a;
}
function zL(n) {
  switch (n) {
    case "auto":
    case "data":
      return pL();
    default:
      return fL(n), n;
  }
}
const UL = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"], jL = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"], VL = {
  image: {
    type: "auto",
    decode: !0
  }
}, OT = {
  id: "image",
  module: "images",
  name: "Images",
  version: uL,
  mimeTypes: jL,
  extensions: UL,
  parse: kL,
  tests: [(n) => !!eb(new DataView(n))],
  options: VL
}, _0 = {};
function qL(n) {
  if (_0[n] === void 0) {
    const e = Jm ? WL(n) : HL(n);
    _0[n] = e;
  }
  return _0[n];
}
function HL(n) {
  const e = ["image/png", "image/jpeg", "image/gif"], {
    _parseImageNode: t,
    _imageFormatsNode: i = e
  } = globalThis;
  return !!t && i.includes(n);
}
function WL(n) {
  switch (n) {
    case "image/avif":
    case "image/webp":
      return ZL(n);
    default:
      return !0;
  }
}
function ZL(n) {
  try {
    return document.createElement("canvas").toDataURL(n).indexOf("data:".concat(n)) === 0;
  } catch {
    return !1;
  }
}
const zi = new Gp({
  id: "deck"
}), Ku = {
  attributeUpdateStart: -1,
  attributeManagerUpdateStart: -1,
  attributeUpdateMessages: []
}, y0 = 1, $f = 2, b0 = 3, v0 = 4, $L = 2, XL = (n) => ({
  "layer.changeFlag": (e, t, i) => {
    n.log(b0, "".concat(e.id, " ").concat(t, ": "), i[t])();
  },
  "layer.initialize": (e) => {
    n.log(y0, "Initializing ".concat(e))();
  },
  "layer.update": (e, t) => {
    if (t) {
      const i = e.getChangeFlags();
      n.log($f, "Updating ".concat(e, " because: ").concat(Object.keys(i).filter((r) => i[r]).join(", ")))();
    } else
      n.log(v0, "".concat(e, " does not need update"))();
  },
  "layer.matched": (e, t) => {
    t && n.log(v0, "Matched ".concat(e, ", state transfered"))();
  },
  "layer.finalize": (e) => {
    n.log(y0, "Finalizing ".concat(e))();
  },
  "compositeLayer.renderLayers": (e, t, i) => {
    t ? n.log($f, "Composite layer rendered new subLayers ".concat(e), i)() : n.log(v0, "Composite layer reused subLayers ".concat(e), i)();
  },
  "layerManager.setLayers": (e, t, i) => {
    t && n.log($f, "Updating ".concat(i.length, " deck layers"))();
  },
  "layerManager.activateViewport": (e, t) => {
    n.log(b0, "Viewport changed", t)();
  },
  "attributeManager.invalidate": (e, t, i) => {
    n.log(y0, i ? "invalidated attributes ".concat(i, " (").concat(t, ") for ").concat(e.id) : "invalidated all attributes for ".concat(e.id))();
  },
  "attributeManager.updateStart": (e) => {
    Ku.attributeUpdateMessages.length = 0, Ku.attributeManagerUpdateStart = Date.now();
  },
  "attributeManager.updateEnd": (e, t) => {
    const i = Math.round(Date.now() - Ku.attributeManagerUpdateStart);
    n.groupCollapsed($f, "Updated attributes for ".concat(t, " instances in ").concat(e.id, " in ").concat(i, "ms"))();
    for (const r of Ku.attributeUpdateMessages)
      n.log(b0, r)();
    n.groupEnd($f)();
  },
  "attribute.updateStart": (e) => {
    Ku.attributeUpdateStart = Date.now();
  },
  "attribute.allocate": (e, t) => {
    const i = "".concat(e.id, " allocated ").concat(t);
    Ku.attributeUpdateMessages.push(i);
  },
  "attribute.updateEnd": (e, t) => {
    const i = Math.round(Date.now() - Ku.attributeUpdateStart), r = "".concat(e.id, " updated ").concat(t, " in ").concat(i, "ms");
    Ku.attributeUpdateMessages.push(r);
  },
  "deckRenderer.renderLayers": (e, t, i) => {
    const {
      pass: r,
      redrawReason: l,
      stats: c
    } = i;
    for (const a of t) {
      const {
        totalCount: g,
        visibleCount: y,
        compositeCount: A,
        pickableCount: C
      } = a, S = g - A - y;
      n.log($L, "RENDER #".concat(e.renderCount, "   ").concat(y, " (of ").concat(g, " layers) to ").concat(r, " because ").concat(l, "   (").concat(S, " hidden, ").concat(A, " composite ").concat(C, " pickable)"))(), c && c.get("Redraw Layers").add(y);
    }
  }
});
var YL = {};
let Im = {};
YL.NODE_ENV !== "production" && (Im = XL(zi));
function JL(n) {
  Im = n;
}
function Vo(n, e, t, i) {
  zi.level > 0 && Im[n] && Im[n].call(null, e, t, i);
}
function KL(n) {
  const e = n[0], t = n[n.length - 1];
  return e === "{" && t === "}" || e === "[" && t === "]";
}
const QL = {
  id: "JSON",
  name: "JSON",
  module: "",
  version: "",
  options: {},
  extensions: ["json", "geojson"],
  mimeTypes: ["application/json", "application/geo+json"],
  testText: KL,
  parseTextSync: JSON.parse
};
function eR() {
  const n = "8.9.36", e = globalThis.deck && globalThis.deck.VERSION;
  if (e && e !== n)
    throw new Error("deck.gl - multiple versions detected: ".concat(e, " vs ").concat(n));
  return e || (zi.log(1, "deck.gl ".concat(n))(), globalThis.deck = {
    ...globalThis.deck,
    VERSION: n,
    version: n,
    log: zi,
    _registerLoggers: JL
  }, kM([QL, [OT, {
    imagebitmap: {
      premultiplyAlpha: "none"
    }
  }]])), n;
}
const tR = eR(), Bi = {
  DEFAULT: -1,
  LNGLAT: 1,
  METER_OFFSETS: 2,
  LNGLAT_OFFSETS: 3,
  CARTESIAN: 0
};
Object.defineProperty(Bi, "IDENTITY", {
  get: () => (zi.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
});
const Jc = {
  WEB_MERCATOR: 1,
  GLOBE: 2,
  WEB_MERCATOR_AUTO_OFFSET: 4,
  IDENTITY: 0
}, jy = {
  common: 0,
  meters: 1,
  pixels: 2
}, wx = {
  click: {
    handler: "onClick"
  },
  panstart: {
    handler: "onDragStart"
  },
  panmove: {
    handler: "onDrag"
  },
  panend: {
    handler: "onDragEnd"
  }
}, Fn = new Gp({
  id: "luma.gl"
});
function ca(n, e) {
  if (!n)
    throw new Error(e || "luma.gl: assertion failed.");
}
const nR = "Invalid WebGLRenderingContext", iR = "Requires WebGL2";
function Qm(n) {
  return typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext || typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? !0 : !!(n && Number.isFinite(n._version));
}
function Si(n) {
  return typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? !0 : !!(n && n._version === 2);
}
function rR(n) {
  return Si(n) ? n : null;
}
function e_(n) {
  return ca(Qm(n), nR), n;
}
function ua(n) {
  return ca(Si(n), iR), n;
}
const hp = {};
function sR(n) {
  globalThis.console && globalThis.console.error && globalThis.console.error(n);
}
function oR(n) {
  globalThis.console && globalThis.console.log && globalThis.console.log(n);
}
function aR(n, e) {
  hp[n] = !0, sR(e);
}
function lR(n) {
  const e = n.getError;
  n.getError = function() {
    let i;
    do
      i = e.apply(n), i !== 0 && (hp[i] = !0);
    while (i !== 0);
    for (i in hp)
      if (hp[i])
        return delete hp[i], parseInt(i, 10);
    return 0;
  };
}
const qp = function n(e) {
  const t = e.gl;
  this.ext = e, this.isAlive = !0, this.hasBeenBound = !1, this.elementArrayBuffer = null, this.attribs = new Array(e.maxVertexAttribs);
  for (let i = 0; i < this.attribs.length; i++) {
    const r = new n.VertexAttrib(t);
    this.attribs[i] = r;
  }
  this.maxAttrib = 0;
};
qp.VertexAttrib = function(e) {
  this.enabled = !1, this.buffer = null, this.size = 4, this.type = 5126, this.normalized = !1, this.stride = 16, this.offset = 0, this.cached = "", this.recache();
};
qp.VertexAttrib.prototype.recache = function() {
  this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
};
const rd = function(e) {
  const t = this;
  this.gl = e, lR(e);
  const i = this.original = {
    getParameter: e.getParameter,
    enableVertexAttribArray: e.enableVertexAttribArray,
    disableVertexAttribArray: e.disableVertexAttribArray,
    bindBuffer: e.bindBuffer,
    getVertexAttrib: e.getVertexAttrib,
    vertexAttribPointer: e.vertexAttribPointer
  };
  e.getParameter = function(l) {
    return l === t.VERTEX_ARRAY_BINDING_OES ? t.currentVertexArrayObject === t.defaultVertexArrayObject ? null : t.currentVertexArrayObject : i.getParameter.apply(this, arguments);
  }, e.enableVertexAttribArray = function(l) {
    const c = t.currentVertexArrayObject;
    c.maxAttrib = Math.max(c.maxAttrib, l);
    const a = c.attribs[l];
    return a.enabled = !0, i.enableVertexAttribArray.apply(this, arguments);
  }, e.disableVertexAttribArray = function(l) {
    const c = t.currentVertexArrayObject;
    c.maxAttrib = Math.max(c.maxAttrib, l);
    const a = c.attribs[l];
    return a.enabled = !1, i.disableVertexAttribArray.apply(this, arguments);
  }, e.bindBuffer = function(l, c) {
    switch (l) {
      case 34962:
        t.currentArrayBuffer = c;
        break;
      case 34963:
        t.currentVertexArrayObject.elementArrayBuffer = c;
        break;
    }
    return i.bindBuffer.apply(this, arguments);
  }, e.getVertexAttrib = function(l, c) {
    const g = t.currentVertexArrayObject.attribs[l];
    switch (c) {
      case 34975:
        return g.buffer;
      case 34338:
        return g.enabled;
      case 34339:
        return g.size;
      case 34340:
        return g.stride;
      case 34341:
        return g.type;
      case 34922:
        return g.normalized;
      default:
        return i.getVertexAttrib.apply(this, arguments);
    }
  }, e.vertexAttribPointer = function(l, c, a, g, y, A) {
    const C = t.currentVertexArrayObject;
    C.maxAttrib = Math.max(C.maxAttrib, l);
    const I = C.attribs[l];
    return I.buffer = t.currentArrayBuffer, I.size = c, I.type = a, I.normalized = g, I.stride = y, I.offset = A, I.recache(), i.vertexAttribPointer.apply(this, arguments);
  }, e.instrumentExtension && e.instrumentExtension(this, "OES_vertex_array_object"), e.canvas && e.canvas.addEventListener("webglcontextrestored", () => {
    oR("OESVertexArrayObject emulation library context restored"), t.reset_();
  }, !0), this.reset_();
};
rd.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
rd.prototype.reset_ = function() {
  if (this.vertexArrayObjects !== void 0)
    for (let i = 0; i < this.vertexArrayObjects.length; ++i)
      this.vertexArrayObjects.isAlive = !1;
  const t = this.gl;
  this.maxVertexAttribs = t.getParameter(34921), this.defaultVertexArrayObject = new qp(this), this.currentVertexArrayObject = null, this.currentArrayBuffer = null, this.vertexArrayObjects = [this.defaultVertexArrayObject], this.bindVertexArrayOES(null);
};
rd.prototype.createVertexArrayOES = function() {
  const e = new qp(this);
  return this.vertexArrayObjects.push(e), e;
};
rd.prototype.deleteVertexArrayOES = function(e) {
  e.isAlive = !1, this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(e), 1), this.currentVertexArrayObject === e && this.bindVertexArrayOES(null);
};
rd.prototype.isVertexArrayOES = function(e) {
  return !!(e && e instanceof qp && e.hasBeenBound && e.ext === this);
};
rd.prototype.bindVertexArrayOES = function(e) {
  const t = this.gl;
  if (e && !e.isAlive) {
    aR(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
    return;
  }
  const i = this.original, r = this.currentVertexArrayObject;
  this.currentVertexArrayObject = e || this.defaultVertexArrayObject, this.currentVertexArrayObject.hasBeenBound = !0;
  const l = this.currentVertexArrayObject;
  if (r === l)
    return;
  (!r || l.elementArrayBuffer !== r.elementArrayBuffer) && i.bindBuffer.call(t, 34963, l.elementArrayBuffer);
  let c = this.currentArrayBuffer;
  const a = Math.max(r ? r.maxAttrib : 0, l.maxAttrib);
  for (let g = 0; g <= a; g++) {
    const y = l.attribs[g], A = r ? r.attribs[g] : null;
    if ((!r || y.enabled !== A.enabled) && (y.enabled ? i.enableVertexAttribArray.call(t, g) : i.disableVertexAttribArray.call(t, g)), y.enabled) {
      let C = !1;
      (!r || y.buffer !== A.buffer) && (c !== y.buffer && (i.bindBuffer.call(t, 34962, y.buffer), c = y.buffer), C = !0), (C || y.cached !== A.cached) && i.vertexAttribPointer.call(t, g, y.size, y.type, y.normalized, y.stride, y.offset);
    }
  }
  this.currentArrayBuffer !== c && i.bindBuffer.call(t, 34962, this.currentArrayBuffer);
};
function cR(n) {
  if (typeof n.createVertexArray == "function")
    return;
  const e = n.getSupportedExtensions;
  n.getSupportedExtensions = function() {
    const r = e.call(this) || [];
    return r.indexOf("OES_vertex_array_object") < 0 && r.push("OES_vertex_array_object"), r;
  };
  const t = n.getExtension;
  n.getExtension = function(r) {
    const l = t.call(this, r);
    return l || (r !== "OES_vertex_array_object" ? null : (n.__OESVertexArrayObject || (this.__OESVertexArrayObject = new rd(this)), this.__OESVertexArrayObject));
  };
}
const Ax = "OES_element_index", Tx = "WEBGL_draw_buffers", uR = "EXT_disjoint_timer_query", hR = "EXT_disjoint_timer_query_webgl2", dR = "EXT_texture_filter_anisotropic", Ex = "WEBGL_debug_renderer_info", fR = 35723, pR = 4352, gR = 36795, mR = 34047, _R = 37445, yR = 37446, Ar = (n) => Si(n) ? void 0 : 0, bR = {
  3074: (n) => Si(n) ? void 0 : 36064,
  [fR]: (n) => Si(n) ? void 0 : pR,
  35977: Ar,
  32937: Ar,
  [gR]: (n, e) => {
    const t = Si(n) ? n.getExtension(hR) : n.getExtension(uR);
    return t && t.GPU_DISJOINT_EXT ? e(t.GPU_DISJOINT_EXT) : 0;
  },
  [_R]: (n, e) => {
    const t = n.getExtension(Ex);
    return e(t && t.UNMASKED_VENDOR_WEBGL || 7936);
  },
  [yR]: (n, e) => {
    const t = n.getExtension(Ex);
    return e(t && t.UNMASKED_RENDERER_WEBGL || 7937);
  },
  [mR]: (n, e) => {
    const t = n.luma.extensions[dR];
    return t ? e(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
  },
  32883: Ar,
  35071: Ar,
  37447: Ar,
  36063: (n, e) => {
    if (!Si(n)) {
      const t = n.getExtension(Tx);
      return t ? e(t.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }
  },
  35379: Ar,
  35374: Ar,
  35377: Ar,
  34852: (n) => {
    if (!Si(n)) {
      const e = n.getExtension(Tx);
      return e ? e.MAX_DRAW_BUFFERS_WEBGL : 0;
    }
  },
  36203: (n) => n.getExtension(Ax) ? 2147483647 : 65535,
  33001: (n) => n.getExtension(Ax) ? 16777216 : 65535,
  33e3: (n) => 16777216,
  37157: Ar,
  35373: Ar,
  35657: Ar,
  36183: Ar,
  37137: Ar,
  34045: Ar,
  35978: Ar,
  35979: Ar,
  35968: Ar,
  35376: Ar,
  35375: Ar,
  35659: Ar,
  37154: Ar,
  35371: Ar,
  35658: Ar,
  35076: Ar,
  35077: Ar,
  35380: Ar
};
function vR(n, e, t) {
  const i = bR[t], r = typeof i == "function" ? i(n, e, t) : i;
  return r !== void 0 ? r : e(t);
}
const xR = "OES_vertex_array_object", DT = "ANGLE_instanced_arrays", wR = "WEBGL_draw_buffers", AR = "EXT_disjoint_timer_query", TR = "EXT_texture_filter_anisotropic", ER = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
function SR(n, e) {
  return {
    webgl2: Si(n),
    ext: n.getExtension(e)
  };
}
const FT = {
  [xR]: {
    meta: {
      suffix: "OES"
    },
    createVertexArray: () => {
      ca(!1, ER);
    },
    deleteVertexArray: () => {
    },
    bindVertexArray: () => {
    },
    isVertexArray: () => !1
  },
  [DT]: {
    meta: {
      suffix: "ANGLE"
    },
    vertexAttribDivisor(n, e) {
      ca(e === 0, "WebGL instanced rendering not supported");
    },
    drawElementsInstanced: () => {
    },
    drawArraysInstanced: () => {
    }
  },
  [wR]: {
    meta: {
      suffix: "WEBGL"
    },
    drawBuffers: () => {
      ca(!1);
    }
  },
  [AR]: {
    meta: {
      suffix: "EXT"
    },
    createQuery: () => {
      ca(!1);
    },
    deleteQuery: () => {
      ca(!1);
    },
    beginQuery: () => {
      ca(!1);
    },
    endQuery: () => {
    },
    getQuery(n, e) {
      return this.getQueryObject(n, e);
    },
    getQueryParameter(n, e) {
      return this.getQueryObject(n, e);
    },
    getQueryObject: () => {
    }
  }
}, x0 = {
  readBuffer: (n, e, t) => {
    Si(n) && e(t);
  },
  getVertexAttrib: (n, e, t, i) => {
    const {
      webgl2: r,
      ext: l
    } = SR(n, DT);
    let c;
    switch (i) {
      case 35069:
        c = r ? void 0 : !1;
        break;
      case 35070:
        c = !r && !l ? 0 : void 0;
        break;
    }
    return c !== void 0 ? c : e(t, i);
  },
  getProgramParameter: (n, e, t, i) => {
    if (!Si(n))
      switch (i) {
        case 35967:
          return 35981;
        case 35971:
          return 0;
        case 35382:
          return 0;
      }
    return e(t, i);
  },
  getInternalformatParameter: (n, e, t, i, r) => {
    if (!Si(n))
      switch (r) {
        case 32937:
          return new Int32Array([0]);
      }
    return n.getInternalformatParameter(t, i, r);
  },
  getTexParameter(n, e, t, i) {
    switch (i) {
      case 34046:
        const {
          extensions: r
        } = n.luma, l = r[TR];
        i = l && l.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
        break;
    }
    return e(t, i);
  },
  getParameter: vR,
  hint(n, e, t, i) {
    return e(t, i);
  }
};
function CR(n) {
  n.luma = n.luma || {};
  const {
    luma: e
  } = n;
  return e.polyfilled || (cR(n), PR(n), MR(n, FT), IR(n, {
    target: e,
    target2: n
  }), e.polyfilled = !0), n;
}
globalThis.polyfillContext = CR;
function PR(n) {
  n.luma.extensions = {};
  const e = n.getSupportedExtensions() || [];
  for (const t of e)
    n.luma[t] = n.getExtension(t);
}
function IR(n, e) {
  let {
    target: t,
    target2: i
  } = e;
  Object.keys(x0).forEach((r) => {
    if (typeof x0[r] == "function") {
      const l = n[r] ? n[r].bind(n) : () => {
      }, c = x0[r].bind(null, n, l);
      t[r] = c, i[r] = c;
    }
  });
}
function MR(n, e) {
  for (const t of Object.getOwnPropertyNames(e))
    t !== "overrides" && LR(n, {
      extension: t,
      target: n.luma,
      target2: n
    });
}
function LR(n, e) {
  let {
    extension: t,
    target: i,
    target2: r
  } = e;
  const l = FT[t];
  ca(l);
  const {
    meta: c = {}
  } = l, {
    suffix: a = ""
  } = c, g = n.getExtension(t);
  for (const y of Object.keys(l)) {
    const A = "".concat(y).concat(a);
    let C = null;
    y === "meta" || typeof n[y] == "function" || (g && typeof g[A] == "function" ? C = function() {
      return g[A](...arguments);
    } : typeof l[y] == "function" && (C = l[y].bind(i))), C && (i[y] = C, r[y] = C);
  }
}
const tb = {
  3042: !1,
  32773: new Float32Array([0, 0, 0, 0]),
  32777: 32774,
  34877: 32774,
  32969: 1,
  32968: 0,
  32971: 1,
  32970: 0,
  3106: new Float32Array([0, 0, 0, 0]),
  3107: [!0, !0, !0, !0],
  2884: !1,
  2885: 1029,
  2929: !1,
  2931: 1,
  2932: 513,
  2928: new Float32Array([0, 1]),
  2930: !0,
  3024: !0,
  36006: null,
  2886: 2305,
  33170: 4352,
  2849: 1,
  32823: !1,
  32824: 0,
  10752: 0,
  32938: 1,
  32939: !1,
  3089: !1,
  3088: new Int32Array([0, 0, 1024, 1024]),
  2960: !1,
  2961: 0,
  2968: 4294967295,
  36005: 4294967295,
  2962: 519,
  2967: 0,
  2963: 4294967295,
  34816: 519,
  36003: 0,
  36004: 4294967295,
  2964: 7680,
  2965: 7680,
  2966: 7680,
  34817: 7680,
  34818: 7680,
  34819: 7680,
  2978: [0, 0, 1024, 1024],
  3333: 4,
  3317: 4,
  37440: !1,
  37441: !1,
  37443: 37444,
  35723: 4352,
  36010: null,
  35977: !1,
  3330: 0,
  3332: 0,
  3331: 0,
  3314: 0,
  32878: 0,
  3316: 0,
  3315: 0,
  32877: 0
}, Qu = (n, e, t) => e ? n.enable(t) : n.disable(t), Sx = (n, e, t) => n.hint(t, e), $a = (n, e, t) => n.pixelStorei(t, e), RR = (n, e) => {
  const t = Si(n) ? 36009 : 36160;
  return n.bindFramebuffer(t, e);
}, BR = (n, e) => n.bindFramebuffer(36008, e);
function Xf(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n);
}
const OR = {
  3042: Qu,
  32773: (n, e) => n.blendColor(...e),
  32777: "blendEquation",
  34877: "blendEquation",
  32969: "blendFunc",
  32968: "blendFunc",
  32971: "blendFunc",
  32970: "blendFunc",
  3106: (n, e) => n.clearColor(...e),
  3107: (n, e) => n.colorMask(...e),
  2884: Qu,
  2885: (n, e) => n.cullFace(e),
  2929: Qu,
  2931: (n, e) => n.clearDepth(e),
  2932: (n, e) => n.depthFunc(e),
  2928: (n, e) => n.depthRange(...e),
  2930: (n, e) => n.depthMask(e),
  3024: Qu,
  35723: Sx,
  36006: RR,
  2886: (n, e) => n.frontFace(e),
  33170: Sx,
  2849: (n, e) => n.lineWidth(e),
  32823: Qu,
  32824: "polygonOffset",
  10752: "polygonOffset",
  35977: Qu,
  32938: "sampleCoverage",
  32939: "sampleCoverage",
  3089: Qu,
  3088: (n, e) => n.scissor(...e),
  2960: Qu,
  2961: (n, e) => n.clearStencil(e),
  2968: (n, e) => n.stencilMaskSeparate(1028, e),
  36005: (n, e) => n.stencilMaskSeparate(1029, e),
  2962: "stencilFuncFront",
  2967: "stencilFuncFront",
  2963: "stencilFuncFront",
  34816: "stencilFuncBack",
  36003: "stencilFuncBack",
  36004: "stencilFuncBack",
  2964: "stencilOpFront",
  2965: "stencilOpFront",
  2966: "stencilOpFront",
  34817: "stencilOpBack",
  34818: "stencilOpBack",
  34819: "stencilOpBack",
  2978: (n, e) => n.viewport(...e),
  3333: $a,
  3317: $a,
  37440: $a,
  37441: $a,
  37443: $a,
  3330: $a,
  3332: $a,
  3331: $a,
  36010: BR,
  3314: $a,
  32878: $a,
  3316: $a,
  3315: $a,
  32877: $a,
  framebuffer: (n, e) => {
    const t = e && "handle" in e ? e.handle : e;
    return n.bindFramebuffer(36160, t);
  },
  blend: (n, e) => e ? n.enable(3042) : n.disable(3042),
  blendColor: (n, e) => n.blendColor(...e),
  blendEquation: (n, e) => {
    e = Xf(e) ? e : [e, e], n.blendEquationSeparate(...e);
  },
  blendFunc: (n, e) => {
    e = Xf(e) && e.length === 2 ? [...e, ...e] : e, n.blendFuncSeparate(...e);
  },
  clearColor: (n, e) => n.clearColor(...e),
  clearDepth: (n, e) => n.clearDepth(e),
  clearStencil: (n, e) => n.clearStencil(e),
  colorMask: (n, e) => n.colorMask(...e),
  cull: (n, e) => e ? n.enable(2884) : n.disable(2884),
  cullFace: (n, e) => n.cullFace(e),
  depthTest: (n, e) => e ? n.enable(2929) : n.disable(2929),
  depthFunc: (n, e) => n.depthFunc(e),
  depthMask: (n, e) => n.depthMask(e),
  depthRange: (n, e) => n.depthRange(...e),
  dither: (n, e) => e ? n.enable(3024) : n.disable(3024),
  derivativeHint: (n, e) => {
    n.hint(35723, e);
  },
  frontFace: (n, e) => n.frontFace(e),
  mipmapHint: (n, e) => n.hint(33170, e),
  lineWidth: (n, e) => n.lineWidth(e),
  polygonOffsetFill: (n, e) => e ? n.enable(32823) : n.disable(32823),
  polygonOffset: (n, e) => n.polygonOffset(...e),
  sampleCoverage: (n, e) => n.sampleCoverage(...e),
  scissorTest: (n, e) => e ? n.enable(3089) : n.disable(3089),
  scissor: (n, e) => n.scissor(...e),
  stencilTest: (n, e) => e ? n.enable(2960) : n.disable(2960),
  stencilMask: (n, e) => {
    e = Xf(e) ? e : [e, e];
    const [t, i] = e;
    n.stencilMaskSeparate(1028, t), n.stencilMaskSeparate(1029, i);
  },
  stencilFunc: (n, e) => {
    e = Xf(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, i, r, l, c, a] = e;
    n.stencilFuncSeparate(1028, t, i, r), n.stencilFuncSeparate(1029, l, c, a);
  },
  stencilOp: (n, e) => {
    e = Xf(e) && e.length === 3 ? [...e, ...e] : e;
    const [t, i, r, l, c, a] = e;
    n.stencilOpSeparate(1028, t, i, r), n.stencilOpSeparate(1029, l, c, a);
  },
  viewport: (n, e) => n.viewport(...e)
};
function ts(n, e, t) {
  return e[n] !== void 0 ? e[n] : t[n];
}
const DR = {
  blendEquation: (n, e, t) => n.blendEquationSeparate(ts(32777, e, t), ts(34877, e, t)),
  blendFunc: (n, e, t) => n.blendFuncSeparate(ts(32969, e, t), ts(32968, e, t), ts(32971, e, t), ts(32970, e, t)),
  polygonOffset: (n, e, t) => n.polygonOffset(ts(32824, e, t), ts(10752, e, t)),
  sampleCoverage: (n, e, t) => n.sampleCoverage(ts(32938, e, t), ts(32939, e, t)),
  stencilFuncFront: (n, e, t) => n.stencilFuncSeparate(1028, ts(2962, e, t), ts(2967, e, t), ts(2963, e, t)),
  stencilFuncBack: (n, e, t) => n.stencilFuncSeparate(1029, ts(34816, e, t), ts(36003, e, t), ts(36004, e, t)),
  stencilOpFront: (n, e, t) => n.stencilOpSeparate(1028, ts(2964, e, t), ts(2965, e, t), ts(2966, e, t)),
  stencilOpBack: (n, e, t) => n.stencilOpSeparate(1029, ts(34817, e, t), ts(34818, e, t), ts(34819, e, t))
}, Cx = {
  enable: (n, e) => n({
    [e]: !0
  }),
  disable: (n, e) => n({
    [e]: !1
  }),
  pixelStorei: (n, e, t) => n({
    [e]: t
  }),
  hint: (n, e, t) => n({
    [e]: t
  }),
  bindFramebuffer: (n, e, t) => {
    switch (e) {
      case 36160:
        return n({
          36006: t,
          36010: t
        });
      case 36009:
        return n({
          36006: t
        });
      case 36008:
        return n({
          36010: t
        });
      default:
        return null;
    }
  },
  blendColor: (n, e, t, i, r) => n({
    32773: new Float32Array([e, t, i, r])
  }),
  blendEquation: (n, e) => n({
    32777: e,
    34877: e
  }),
  blendEquationSeparate: (n, e, t) => n({
    32777: e,
    34877: t
  }),
  blendFunc: (n, e, t) => n({
    32969: e,
    32968: t,
    32971: e,
    32970: t
  }),
  blendFuncSeparate: (n, e, t, i, r) => n({
    32969: e,
    32968: t,
    32971: i,
    32970: r
  }),
  clearColor: (n, e, t, i, r) => n({
    3106: new Float32Array([e, t, i, r])
  }),
  clearDepth: (n, e) => n({
    2931: e
  }),
  clearStencil: (n, e) => n({
    2961: e
  }),
  colorMask: (n, e, t, i, r) => n({
    3107: [e, t, i, r]
  }),
  cullFace: (n, e) => n({
    2885: e
  }),
  depthFunc: (n, e) => n({
    2932: e
  }),
  depthRange: (n, e, t) => n({
    2928: new Float32Array([e, t])
  }),
  depthMask: (n, e) => n({
    2930: e
  }),
  frontFace: (n, e) => n({
    2886: e
  }),
  lineWidth: (n, e) => n({
    2849: e
  }),
  polygonOffset: (n, e, t) => n({
    32824: e,
    10752: t
  }),
  sampleCoverage: (n, e, t) => n({
    32938: e,
    32939: t
  }),
  scissor: (n, e, t, i, r) => n({
    3088: new Int32Array([e, t, i, r])
  }),
  stencilMask: (n, e) => n({
    2968: e,
    36005: e
  }),
  stencilMaskSeparate: (n, e, t) => n({
    [e === 1028 ? 2968 : 36005]: t
  }),
  stencilFunc: (n, e, t, i) => n({
    2962: e,
    2967: t,
    2963: i,
    34816: e,
    36003: t,
    36004: i
  }),
  stencilFuncSeparate: (n, e, t, i, r) => n({
    [e === 1028 ? 2962 : 34816]: t,
    [e === 1028 ? 2967 : 36003]: i,
    [e === 1028 ? 2963 : 36004]: r
  }),
  stencilOp: (n, e, t, i) => n({
    2964: e,
    2965: t,
    2966: i,
    34817: e,
    34818: t,
    34819: i
  }),
  stencilOpSeparate: (n, e, t, i, r) => n({
    [e === 1028 ? 2964 : 34817]: t,
    [e === 1028 ? 2965 : 34818]: i,
    [e === 1028 ? 2966 : 34819]: r
  }),
  viewport: (n, e, t, i, r) => n({
    2978: [e, t, i, r]
  })
}, Vc = (n, e) => n.isEnabled(e), Px = {
  3042: Vc,
  2884: Vc,
  2929: Vc,
  3024: Vc,
  32823: Vc,
  32926: Vc,
  32928: Vc,
  3089: Vc,
  2960: Vc,
  35977: Vc
};
function NT(n) {
  for (const e in n)
    return !1;
  return !0;
}
function FR(n, e) {
  if (n === e)
    return !0;
  const t = Array.isArray(n) || ArrayBuffer.isView(n), i = Array.isArray(e) || ArrayBuffer.isView(e);
  if (t && i && n.length === e.length) {
    for (let r = 0; r < n.length; ++r)
      if (n[r] !== e[r])
        return !1;
    return !0;
  }
  return !1;
}
function Ix(n, e) {
  const t = n[e].bind(n);
  n[e] = function() {
    const r = arguments.length <= 0 ? void 0 : arguments[0];
    return r in n.state.cache ? n.state.enable ? n.state.cache[r] : t(...arguments) : t(...arguments);
  }, Object.defineProperty(n[e], "name", {
    value: "".concat(e, "-from-cache"),
    configurable: !1
  });
}
function NR(n, e, t) {
  const i = n[e].bind(n);
  n[e] = function() {
    for (var l = arguments.length, c = new Array(l), a = 0; a < l; a++)
      c[a] = arguments[a];
    const {
      valueChanged: g,
      oldValue: y
    } = t(n.state._updateCache, ...c);
    return g && i(...c), y;
  }, Object.defineProperty(n[e], "name", {
    value: "".concat(e, "-to-cache"),
    configurable: !1
  });
}
function kR(n) {
  const e = n.useProgram.bind(n);
  n.useProgram = function(i) {
    n.state.program !== i && (e(i), n.state.program = i);
  };
}
class zR {
  constructor(e) {
    let {
      copyState: t = !1,
      log: i = () => {
      }
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.program = null, this.stateStack = [], this.enable = !0, this.cache = t ? jR(e) : Object.assign({}, tb), this.log = i, this._updateCache = this._updateCache.bind(this), Object.seal(this);
  }
  push() {
    this.stateStack.push({});
  }
  pop() {
    ca(this.stateStack.length > 0);
    const e = this.stateStack[this.stateStack.length - 1];
    Bu(this.gl, e), this.stateStack.pop();
  }
  _updateCache(e) {
    let t = !1, i;
    const r = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
    for (const l in e) {
      ca(l !== void 0);
      const c = e[l], a = this.cache[l];
      FR(c, a) || (t = !0, i = a, r && !(l in r) && (r[l] = a), this.cache[l] = c);
    }
    return {
      valueChanged: t,
      oldValue: i
    };
  }
}
function kT(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    enable: t = !0,
    copyState: i
  } = e;
  if (ca(i !== void 0), !n.state) {
    const {
      polyfillContext: r
    } = globalThis;
    r && r(n), n.state = new zR(n, {
      copyState: i
    }), kR(n);
    for (const l in Cx) {
      const c = Cx[l];
      NR(n, l, c);
    }
    Ix(n, "getParameter"), Ix(n, "isEnabled");
  }
  return n.state.enable = t, n;
}
function UR(n) {
  n.state || kT(n, {
    copyState: !1
  }), n.state.push();
}
function Mx(n) {
  ca(n.state), n.state.pop();
}
function Bu(n, e) {
  if (ca(Qm(n), "setParameters requires a WebGL context"), NT(e))
    return;
  const t = {};
  for (const r in e) {
    const l = Number(r), c = OR[r];
    c && (typeof c == "string" ? t[c] = !0 : c(n, e[r], l));
  }
  const i = n.state && n.state.cache;
  if (i)
    for (const r in t) {
      const l = DR[r];
      l(n, e, i);
    }
}
function jR(n, e) {
  if (e = e || tb, typeof e == "number") {
    const r = e, l = Px[r];
    return l ? l(n, r) : n.getParameter(r);
  }
  const t = Array.isArray(e) ? e : Object.keys(e), i = {};
  for (const r of t) {
    const l = Px[r];
    i[r] = l ? l(n, Number(r)) : n.getParameter(Number(r));
  }
  return i;
}
function GR(n) {
  Bu(n, tb);
}
function yc(n, e, t) {
  if (NT(e))
    return t(n);
  const {
    nocatch: i = !0
  } = e;
  UR(n), Bu(n, e);
  let r;
  if (i)
    r = t(n), Mx(n);
  else
    try {
      r = t(n);
    } finally {
      Mx(n);
    }
  return r;
}
function sf(n) {
  const {
    luma: e
  } = n;
  if (n.canvas && e) {
    const t = e.canvasSizeInfo, i = "clientWidth" in t ? t.clientWidth : n.canvas.clientWidth;
    return i ? n.drawingBufferWidth / i : 1;
  }
  return 1;
}
function w0(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  const i = sf(n), r = n.drawingBufferWidth, l = n.drawingBufferHeight;
  return qR(e, i, r, l, t);
}
function VR(n) {
  const e = typeof window > "u" ? 1 : window.devicePixelRatio || 1;
  return Number.isFinite(n) ? n <= 0 ? 1 : n : n ? e : 1;
}
function qR(n, e, t, i, r) {
  const l = Lx(n[0], e, t);
  let c = Rx(n[1], e, i, r), a = Lx(n[0] + 1, e, t);
  const g = a === t - 1 ? a : a - 1;
  a = Rx(n[1] + 1, e, i, r);
  let y;
  return r ? (a = a === 0 ? a : a + 1, y = c, c = a) : y = a === i - 1 ? a : a - 1, {
    x: l,
    y: c,
    width: Math.max(g - l + 1, 1),
    height: Math.max(y - c + 1, 1)
  };
}
function Lx(n, e, t) {
  return Math.min(Math.round(n * e), t - 1);
}
function Rx(n, e, t, i) {
  return i ? Math.max(0, t - 1 - Math.round(n * e)) : Math.min(Math.round(n * e), t - 1);
}
const nb = Fu(), HR = nb && typeof document < "u", zT = {
  webgl2: !0,
  webgl1: !0,
  throwOnError: !0,
  manageState: !0,
  canvas: null,
  debug: !1,
  width: 800,
  height: 600
};
function UT() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  ca(nb, `createGLContext only available in the browser.
Create your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils`), n = Object.assign({}, zT, n);
  const {
    width: e,
    height: t
  } = n;
  function i(a) {
    if (n.throwOnError)
      throw new Error(a);
    return console.error(a), null;
  }
  n.onError = i;
  let r;
  const {
    canvas: l
  } = n, c = XR({
    canvas: l,
    width: e,
    height: t,
    onError: i
  });
  return r = $R(c, n), r ? (r = ib(r, n), YR(r), r) : null;
}
function ib(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!n || n._instrumented)
    return n;
  n._version = n._version || JR(n), n.luma = n.luma || {}, n.luma.canvasSizeInfo = n.luma.canvasSizeInfo || {}, e = Object.assign({}, zT, e);
  const {
    manageState: t,
    debug: i
  } = e;
  return t && kT(n, {
    copyState: !1,
    log: function() {
      for (var r = arguments.length, l = new Array(r), c = 0; c < r; c++)
        l[c] = arguments[c];
      return Fn.log(1, ...l)();
    }
  }), nb && i && (globalThis.makeDebugContext ? (n = globalThis.makeDebugContext(n, e), Fn.level = Math.max(Fn.level, 1)) : Fn.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')()), n._instrumented = !0, n;
}
function WR(n) {
  const e = n.getParameter(7936), t = n.getParameter(7937), i = n.getExtension("WEBGL_debug_renderer_info"), r = i && n.getParameter(i.UNMASKED_VENDOR_WEBGL || 7936), l = i && n.getParameter(i.UNMASKED_RENDERER_WEBGL || 7937);
  return {
    vendor: r || e,
    renderer: l || t,
    vendorMasked: e,
    rendererMasked: t,
    version: n.getParameter(7938),
    shadingLanguageVersion: n.getParameter(35724)
  };
}
function ZR(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (n.canvas) {
    const i = VR(e.useDevicePixels);
    KR(n, i, e);
    return;
  }
  const t = n.getExtension("STACKGL_resize_drawingbuffer");
  t && "width" in e && "height" in e && t.resize(e.width, e.height);
}
function $R(n, e) {
  const {
    onError: t
  } = e;
  let i = null;
  const r = (g) => i = g.statusMessage || i;
  n.addEventListener("webglcontextcreationerror", r, !1);
  const {
    webgl1: l = !0,
    webgl2: c = !0
  } = e;
  let a = null;
  return c && (a = a || n.getContext("webgl2", e), a = a || n.getContext("experimental-webgl2", e)), l && (a = a || n.getContext("webgl", e), a = a || n.getContext("experimental-webgl", e)), n.removeEventListener("webglcontextcreationerror", r, !1), a ? (e.onContextLost && n.addEventListener("webglcontextlost", e.onContextLost, !1), e.onContextRestored && n.addEventListener("webglcontextrestored", e.onContextRestored, !1), a) : t("Failed to create ".concat(c && !l ? "WebGL2" : "WebGL", " context: ").concat(i || "Unknown error"));
}
function XR(n) {
  let {
    canvas: e,
    width: t = 800,
    height: i = 600,
    onError: r
  } = n, l;
  return typeof e == "string" ? (HR && document.readyState === "complete" || r("createGLContext called on canvas '".concat(e, "' before page was loaded")), l = document.getElementById(e)) : e ? l = e : (l = document.createElement("canvas"), l.id = "lumagl-canvas", l.style.width = Number.isFinite(t) ? "".concat(t, "px") : "100%", l.style.height = Number.isFinite(i) ? "".concat(i, "px") : "100%", document.body.insertBefore(l, document.body.firstChild)), l;
}
function YR(n) {
  const e = Si(n) ? "WebGL2" : "WebGL1", t = WR(n), i = t ? "(".concat(t.vendor, ",").concat(t.renderer, ")") : "", r = n.debug ? " debug" : "";
  Fn.info(1, "".concat(e).concat(r, " context ").concat(i))();
}
function JR(n) {
  return typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? 2 : 1;
}
function KR(n, e, t) {
  let i = "width" in t ? t.width : n.canvas.clientWidth, r = "height" in t ? t.height : n.canvas.clientHeight;
  (!i || !r) && (Fn.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, i = n.canvas.width || 1, r = n.canvas.height || 1), n.luma = n.luma || {}, n.luma.canvasSizeInfo = n.luma.canvasSizeInfo || {};
  const l = n.luma.canvasSizeInfo;
  if (l.clientWidth !== i || l.clientHeight !== r || l.devicePixelRatio !== e) {
    let c = e;
    const a = Math.floor(i * c), g = Math.floor(r * c);
    n.canvas.width = a, n.canvas.height = g, (n.drawingBufferWidth !== a || n.drawingBufferHeight !== g) && (Fn.warn("Device pixel ratio clamped")(), c = Math.min(n.drawingBufferWidth / i, n.drawingBufferHeight / r), n.canvas.width = Math.floor(i * c), n.canvas.height = Math.floor(r * c)), Object.assign(n.luma.canvasSizeInfo, {
      clientWidth: i,
      clientHeight: r,
      devicePixelRatio: e
    });
  }
}
const yp = "8.5.21", QR = "set luma.log.level=1 (or higher) to trace rendering";
class eB {
  constructor() {
    this.stats = /* @__PURE__ */ new Map();
  }
  get(e) {
    return this.stats.has(e) || this.stats.set(e, new Up({
      id: e
    })), this.stats.get(e);
  }
}
const Gh = new eB();
if (globalThis.luma && globalThis.luma.VERSION !== yp)
  throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(yp));
globalThis.luma || (Fu() && Fn.log(1, "luma.gl ".concat(yp, " - ").concat(QR))(), globalThis.luma = globalThis.luma || {
  VERSION: yp,
  version: yp,
  log: Fn,
  stats: Gh,
  globals: {
    modules: {},
    nodeIO: {}
  }
});
function tB(n) {
  return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(n) : setTimeout(n, 1e3 / 60);
}
function nB(n) {
  return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(n) : clearTimeout(n);
}
function En(n, e) {
  if (!n)
    throw new Error(e || "luma.gl: assertion failed.");
}
function A0(n, e) {
  if (typeof e != "string")
    return e;
  const t = Number(e);
  if (!isNaN(t))
    return t;
  e = e.replace(/^.*\./, "");
  const i = n[e];
  return En(i !== void 0, "Accessing undefined constant GL.".concat(e)), i;
}
function dh(n, e) {
  e = Number(e);
  for (const t in n)
    if (n[t] === e)
      return "GL.".concat(t);
  return String(e);
}
const T0 = {};
function Ou() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
  T0[n] = T0[n] || 1;
  const e = T0[n]++;
  return "".concat(n, "-").concat(e);
}
function Bx(n) {
  return En(typeof n == "number", "Input must be a number"), n && (n & n - 1) === 0;
}
function of(n) {
  let e = !0;
  for (const t in n) {
    e = !1;
    break;
  }
  return e;
}
function jT(n, e, t, i) {
  const r = "See luma.gl ".concat(t, " Upgrade Guide at https://luma.gl/docs/upgrade-guide"), l = Object.getPrototypeOf(n);
  i.forEach((c) => {
    l.methodName || (l[c] = () => {
      throw Fn.removed("Calling removed method ".concat(e, ".").concat(c, ": "), r)(), new Error(c);
    });
  });
}
const Id = "Resource subclass must define virtual methods";
let Nu = class {
  get [Symbol.toStringTag]() {
    return "Resource";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e_(e);
    const {
      id: i,
      userData: r = {}
    } = t;
    this.gl = e, this.gl2 = e, this.id = i || Ou(this[Symbol.toStringTag]), this.userData = r, this._bound = !1, this._handle = t.handle, this._handle === void 0 && (this._handle = this._createHandle()), this.byteLength = 0, this._addStats();
  }
  toString() {
    return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
  }
  get handle() {
    return this._handle;
  }
  delete() {
    let {
      deleteChildren: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this._handle && this._deleteHandle(this._handle);
    return this._handle && this._removeStats(), this._handle = null, t && e && t.filter(Boolean).forEach((i) => i.delete()), this;
  }
  bind() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
    if (typeof e != "function")
      return this._bindHandle(e), this;
    let t;
    return this._bound ? t = e() : (this._bindHandle(this.handle), this._bound = !0, t = e(), this._bound = !1, this._bindHandle(null)), t;
  }
  unbind() {
    this.bind(null);
  }
  getParameter(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e = A0(this.gl, e), En(e);
    const r = (this.constructor.PARAMETERS || {})[e];
    if (r) {
      const l = Si(this.gl);
      if (!((!("webgl2" in r) || l) && (!("extension" in r) || this.gl.getExtension(r.extension)))) {
        const a = r.webgl1, g = "webgl2" in r ? r.webgl2 : r.webgl1;
        return l ? g : a;
      }
    }
    return this._getParameter(e, t);
  }
  getParameters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      parameters: t,
      keys: i
    } = e, r = this.constructor.PARAMETERS || {}, l = Si(this.gl), c = {}, a = t || Object.keys(r);
    for (const g of a) {
      const y = r[g];
      if (y && (!("webgl2" in y) || l) && (!("extension" in y) || this.gl.getExtension(y.extension))) {
        const C = i ? dh(this.gl, g) : g;
        c[C] = this.getParameter(g, e), i && y.type === "GLenum" && (c[C] = dh(this.gl, c[C]));
      }
    }
    return c;
  }
  setParameter(e, t) {
    e = A0(this.gl, e), En(e);
    const r = (this.constructor.PARAMETERS || {})[e];
    if (r) {
      const l = Si(this.gl);
      if (!((!("webgl2" in r) || l) && (!("extension" in r) || this.gl.getExtension(r.extension))))
        throw new Error("Parameter not available on this platform");
      r.type === "GLenum" && (t = A0(t));
    }
    return this._setParameter(e, t), this;
  }
  setParameters(e) {
    for (const t in e)
      this.setParameter(t, e[t]);
    return this;
  }
  stubRemovedMethods(e, t, i) {
    return jT(this, e, t, i);
  }
  initialize(e) {
  }
  _createHandle() {
    throw new Error(Id);
  }
  _deleteHandle() {
    throw new Error(Id);
  }
  _bindHandle(e) {
    throw new Error(Id);
  }
  _getOptsFromHandle() {
    throw new Error(Id);
  }
  _getParameter(e, t) {
    throw new Error(Id);
  }
  _setParameter(e, t) {
    throw new Error(Id);
  }
  _context() {
    return this.gl.luma = this.gl.luma || {}, this.gl.luma;
  }
  _addStats() {
    const e = this[Symbol.toStringTag], t = Gh.get("Resource Counts");
    t.get("Resources Created").incrementCount(), t.get("".concat(e, "s Created")).incrementCount(), t.get("".concat(e, "s Active")).incrementCount();
  }
  _removeStats() {
    const e = this[Symbol.toStringTag];
    Gh.get("Resource Counts").get("".concat(e, "s Active")).decrementCount();
  }
  _trackAllocatedMemory(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
    this._trackAllocatedMemoryForContext(e, t), this._trackAllocatedMemoryForContext(e, t, this.gl.canvas && this.gl.canvas.id), this.byteLength = e;
  }
  _trackAllocatedMemoryForContext(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag], i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
    const r = Gh.get("Memory Usage".concat(i));
    r.get("GPU Memory").addCount(e), r.get("".concat(t, " Memory")).addCount(e);
  }
  _trackDeallocatedMemory() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
    this._trackDeallocatedMemoryForContext(e), this._trackDeallocatedMemoryForContext(e, this.gl.canvas && this.gl.canvas.id), this.byteLength = 0;
  }
  _trackDeallocatedMemoryForContext() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const i = Gh.get("Memory Usage".concat(t));
    i.get("GPU Memory").subtractCount(this.byteLength), i.get("".concat(e, " Memory")).subtractCount(this.byteLength);
  }
};
const iB = "Failed to deduce GL constant from typed array";
function Gy(n) {
  switch (ArrayBuffer.isView(n) ? n.constructor : n) {
    case Float32Array:
      return 5126;
    case Uint16Array:
      return 5123;
    case Uint32Array:
      return 5125;
    case Uint8Array:
      return 5121;
    case Uint8ClampedArray:
      return 5121;
    case Int8Array:
      return 5120;
    case Int16Array:
      return 5122;
    case Int32Array:
      return 5124;
    default:
      throw new Error(iB);
  }
}
function Sp(n) {
  let {
    clamped: e = !0
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  switch (n) {
    case 5126:
      return Float32Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return e ? Uint8ClampedArray : Uint8Array;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Failed to deduce typed array type from GL constant");
  }
}
function rB(n) {
  let {
    data: e,
    width: t,
    height: i,
    bytesPerPixel: r = 4,
    temp: l
  } = n;
  const c = t * r;
  l = l || new Uint8Array(c);
  for (let a = 0; a < i / 2; ++a) {
    const g = a * c, y = (i - a - 1) * c;
    l.set(e.subarray(g, g + c)), e.copyWithin(g, y, y + c), e.set(l, y);
  }
}
function sB(n) {
  let {
    data: e,
    width: t,
    height: i
  } = n;
  const r = Math.round(t / 2), l = Math.round(i / 2), c = new Uint8Array(r * l * 4);
  for (let a = 0; a < l; a++)
    for (let g = 0; g < r; g++)
      for (let y = 0; y < 4; y++)
        c[(a * r + g) * 4 + y] = e[(a * 2 * t + g * 2) * 4 + y];
  return {
    data: c,
    width: r,
    height: l
  };
}
function Vy(n, e, t) {
  const {
    removedProps: i = {},
    deprecatedProps: r = {},
    replacedProps: l = {}
  } = t;
  for (const a in i)
    if (a in e) {
      const y = i[a] ? "".concat(n, ".").concat(i[a]) : "N/A";
      Fn.removed("".concat(n, ".").concat(a), y)();
    }
  for (const a in r)
    if (a in e) {
      const g = r[a];
      Fn.deprecated("".concat(n, ".").concat(a), "".concat(n, ".").concat(g))();
    }
  let c = null;
  for (const a in l)
    if (a in e) {
      const g = l[a];
      Fn.deprecated("".concat(n, ".").concat(a), "".concat(n, ".").concat(g))(), c = c || Object.assign({}, e), c[g] = e[a], delete c[a];
    }
  return c || e;
}
const oB = {
  offset: 0,
  stride: 0,
  type: 5126,
  size: 1,
  divisor: 0,
  normalized: !1,
  integer: !1
}, aB = {
  deprecatedProps: {
    instanced: "divisor",
    isInstanced: "divisor"
  }
};
class Ta {
  static getBytesPerElement(e) {
    return Sp(e.type || 5126).BYTES_PER_ELEMENT;
  }
  static getBytesPerVertex(e) {
    return En(e.size), Sp(e.type || 5126).BYTES_PER_ELEMENT * e.size;
  }
  static resolve() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return new Ta(oB, ...t);
  }
  constructor() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    t.forEach((r) => this._assign(r)), Object.freeze(this);
  }
  toString() {
    return JSON.stringify(this);
  }
  get BYTES_PER_ELEMENT() {
    return Ta.getBytesPerElement(this);
  }
  get BYTES_PER_VERTEX() {
    return Ta.getBytesPerVertex(this);
  }
  _assign() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e = Vy("Accessor", e, aB), e.type !== void 0 && (this.type = e.type, (e.type === 5124 || e.type === 5125) && (this.integer = !0)), e.size !== void 0 && (this.size = e.size), e.offset !== void 0 && (this.offset = e.offset), e.stride !== void 0 && (this.stride = e.stride), e.normalized !== void 0 && (this.normalized = e.normalized), e.integer !== void 0 && (this.integer = e.integer), e.divisor !== void 0 && (this.divisor = e.divisor), e.buffer !== void 0 && (this.buffer = e.buffer), e.index !== void 0 && (typeof e.index == "boolean" ? this.index = e.index ? 1 : 0 : this.index = e.index), e.instanced !== void 0 && (this.divisor = e.instanced ? 1 : 0), e.isInstanced !== void 0 && (this.divisor = e.isInstanced ? 1 : 0), this;
  }
}
const Ox = 10, GT = {
  offset: "accessor.offset",
  stride: "accessor.stride",
  type: "accessor.type",
  size: "accessor.size",
  divisor: "accessor.divisor",
  normalized: "accessor.normalized",
  integer: "accessor.integer",
  instanced: "accessor.divisor",
  isInstanced: "accessor.divisor"
}, lB = {
  removedProps: {},
  replacedProps: {
    bytes: "byteLength"
  },
  deprecatedProps: GT
}, cB = {
  removedProps: GT
};
let dr = class extends Nu {
  get [Symbol.toStringTag]() {
    return "Buffer";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]), this.target = t.target || (this.gl.webgl2 ? 36662 : 34962), this.initialize(t), Object.seal(this);
  }
  getElementCount() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / Ta.getBytesPerElement(e));
  }
  getVertexCount() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
    return Math.round(this.byteLength / Ta.getBytesPerVertex(e));
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return ArrayBuffer.isView(e) && (e = {
      data: e
    }), Number.isFinite(e) && (e = {
      byteLength: e
    }), e = Vy("Buffer", e, lB), this.usage = e.usage || 35044, this.debugData = null, this.setAccessor(Object.assign({}, e, e.accessor)), e.data ? this._setData(e.data, e.offset, e.byteLength) : this._setByteLength(e.byteLength || 0), this;
  }
  setProps(e) {
    return e = Vy("Buffer", e, cB), "accessor" in e && this.setAccessor(e.accessor), this;
  }
  setAccessor(e) {
    return e = Object.assign({}, e), delete e.buffer, this.accessor = new Ta(e), this;
  }
  reallocate(e) {
    return e > this.byteLength ? (this._setByteLength(e), !0) : (this.bytesUsed = e, !1);
  }
  setData(e) {
    return this.initialize(e);
  }
  subData(e) {
    ArrayBuffer.isView(e) && (e = {
      data: e
    });
    const {
      data: t,
      offset: i = 0,
      srcOffset: r = 0
    } = e, l = e.byteLength || e.length;
    En(t);
    const c = this.gl.webgl2 ? 36663 : this.target;
    return this.gl.bindBuffer(c, this.handle), r !== 0 || l !== void 0 ? (ua(this.gl), this.gl.bufferSubData(this.target, i, t, r, l)) : this.gl.bufferSubData(c, i, t), this.gl.bindBuffer(c, null), this.debugData = null, this._inferType(t), this;
  }
  copyData(e) {
    let {
      sourceBuffer: t,
      readOffset: i = 0,
      writeOffset: r = 0,
      size: l
    } = e;
    const {
      gl: c
    } = this;
    return ua(c), c.bindBuffer(36662, t.handle), c.bindBuffer(36663, this.handle), c.copyBufferSubData(36662, 36663, i, r, l), c.bindBuffer(36662, null), c.bindBuffer(36663, null), this.debugData = null, this;
  }
  getData() {
    let {
      dstData: e = null,
      srcByteOffset: t = 0,
      dstOffset: i = 0,
      length: r = 0
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    ua(this.gl);
    const l = Sp(this.accessor.type || 5126, {
      clamped: !1
    }), c = this._getAvailableElementCount(t), a = i;
    let g, y;
    e ? (y = e.length, g = y - a) : (g = Math.min(c, r || c), y = a + g);
    const A = Math.min(c, g);
    return r = r || A, En(r <= A), e = e || new l(y), this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, t, e, i, r), this.gl.bindBuffer(36662, null), e;
  }
  bind() {
    let {
      target: e = this.target,
      index: t = this.accessor && this.accessor.index,
      offset: i = 0,
      size: r
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e === 35345 || e === 35982 ? r !== void 0 ? this.gl.bindBufferRange(e, t, this.handle, i, r) : (En(i === 0), this.gl.bindBufferBase(e, t, this.handle)) : this.gl.bindBuffer(e, this.handle), this;
  }
  unbind() {
    let {
      target: e = this.target,
      index: t = this.accessor && this.accessor.index
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e === 35345 || e === 35982 ? this.gl.bindBufferBase(e, t, null) : this.gl.bindBuffer(e, null), this;
  }
  getDebugData() {
    return this.debugData ? {
      data: this.debugData,
      changed: !1
    } : (this.debugData = this.getData({
      length: Math.min(Ox, this.byteLength)
    }), {
      data: this.debugData,
      changed: !0
    });
  }
  invalidateDebugData() {
    this.debugData = null;
  }
  _setData(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e.byteLength + t;
    En(ArrayBuffer.isView(e)), this._trackDeallocatedMemory();
    const r = this._getTarget();
    this.gl.bindBuffer(r, this.handle), this.gl.bufferData(r, i, this.usage), this.gl.bufferSubData(r, t, e), this.gl.bindBuffer(r, null), this.debugData = e.slice(0, Ox), this.bytesUsed = i, this._trackAllocatedMemory(i);
    const l = Gy(e);
    return En(l), this.setAccessor(new Ta(this.accessor, {
      type: l
    })), this;
  }
  _setByteLength(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
    En(e >= 0), this._trackDeallocatedMemory();
    let i = e;
    e === 0 && (i = new Float32Array(0));
    const r = this._getTarget();
    return this.gl.bindBuffer(r, this.handle), this.gl.bufferData(r, i, t), this.gl.bindBuffer(r, null), this.usage = t, this.debugData = null, this.bytesUsed = e, this._trackAllocatedMemory(e), this;
  }
  _getTarget() {
    return this.gl.webgl2 ? 36663 : this.target;
  }
  _getAvailableElementCount(e) {
    const t = Sp(this.accessor.type || 5126, {
      clamped: !1
    }), i = e / t.BYTES_PER_ELEMENT;
    return this.getElementCount() - i;
  }
  _inferType(e) {
    this.accessor.type || this.setAccessor(new Ta(this.accessor, {
      type: Gy(e)
    }));
  }
  _createHandle() {
    return this.gl.createBuffer();
  }
  _deleteHandle() {
    this.gl.deleteBuffer(this.handle), this._trackDeallocatedMemory();
  }
  _getParameter(e) {
    this.gl.bindBuffer(this.target, this.handle);
    const t = this.gl.getBufferParameter(this.target, e);
    return this.gl.bindBuffer(this.target, null), t;
  }
  get type() {
    return Fn.deprecated("Buffer.type", "Buffer.accessor.type")(), this.accessor.type;
  }
  get bytes() {
    return Fn.deprecated("Buffer.bytes", "Buffer.byteLength")(), this.byteLength;
  }
  setByteLength(e) {
    return Fn.deprecated("setByteLength", "reallocate")(), this.reallocate(e);
  }
  updateAccessor(e) {
    return Fn.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")(), this.accessor = new Ta(this.accessor, e), this;
  }
};
const rb = {
  6407: {
    dataFormat: 6407,
    types: [5121, 33635]
  },
  6408: {
    dataFormat: 6408,
    types: [5121, 32819, 32820]
  },
  6406: {
    dataFormat: 6406,
    types: [5121]
  },
  6409: {
    dataFormat: 6409,
    types: [5121]
  },
  6410: {
    dataFormat: 6410,
    types: [5121]
  },
  33326: {
    dataFormat: 6403,
    types: [5126],
    gl2: !0
  },
  33328: {
    dataFormat: 33319,
    types: [5126],
    gl2: !0
  },
  34837: {
    dataFormat: 6407,
    types: [5126],
    gl2: !0
  },
  34836: {
    dataFormat: 6408,
    types: [5126],
    gl2: !0
  }
}, VT = {
  6403: 1,
  36244: 1,
  33319: 2,
  33320: 2,
  6407: 3,
  36248: 3,
  6408: 4,
  36249: 4,
  6402: 1,
  34041: 1,
  6406: 1,
  6409: 1,
  6410: 2
}, qT = {
  5126: 4,
  5125: 4,
  5124: 4,
  5123: 2,
  5122: 2,
  5131: 2,
  5120: 1,
  5121: 1
};
function uB(n, e) {
  const t = rb[e];
  if (!t)
    return !1;
  if (t.gl1 === void 0 && t.gl2 === void 0)
    return !0;
  const i = Si(n) && t.gl2 || t.gl1;
  return typeof i == "string" ? n.getExtension(i) : i;
}
function hB(n, e) {
  const t = rb[e];
  switch (t && t.types[0]) {
    case 5126:
      return n.getExtension("OES_texture_float_linear");
    case 5131:
      return n.getExtension("OES_texture_half_float_linear");
    default:
      return !0;
  }
}
const dB = [9729, 9728], Dx = globalThis.WebGLBuffer || function() {
};
class af extends Nu {
  get [Symbol.toStringTag]() {
    return "Texture";
  }
  static isSupported(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      format: i,
      linearFiltering: r
    } = t;
    let l = !0;
    return i && (l = l && uB(e, i), l = l && (!r || hB(e, i))), l;
  }
  constructor(e, t) {
    const {
      id: i = Ou("texture"),
      handle: r,
      target: l
    } = t;
    super(e, {
      id: i,
      handle: r
    }), this.target = l, this.textureUnit = void 0, this.loaded = !1, this.width = void 0, this.height = void 0, this.depth = void 0, this.format = void 0, this.type = void 0, this.dataFormat = void 0, this.border = void 0, this.textureUnit = void 0, this.mipmaps = void 0;
  }
  toString() {
    return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.data;
    if (t instanceof Promise)
      return t.then((X) => this.initialize(Object.assign({}, e, {
        pixels: X,
        data: X
      }))), this;
    const i = typeof HTMLVideoElement < "u" && t instanceof HTMLVideoElement;
    if (i && t.readyState < HTMLVideoElement.HAVE_METADATA)
      return this._video = null, t.addEventListener("loadeddata", () => this.initialize(e)), this;
    const {
      pixels: r = null,
      format: l = 6408,
      border: c = 0,
      recreate: a = !1,
      parameters: g = {},
      pixelStore: y = {},
      textureUnit: A = void 0
    } = e;
    t || (t = r);
    let {
      width: C,
      height: I,
      dataFormat: S,
      type: F,
      compressed: U = !1,
      mipmaps: V = !0
    } = e;
    const {
      depth: W = 0
    } = e;
    return {
      width: C,
      height: I,
      compressed: U,
      dataFormat: S,
      type: F
    } = this._deduceParameters({
      format: l,
      type: F,
      dataFormat: S,
      compressed: U,
      data: t,
      width: C,
      height: I
    }), this.width = C, this.height = I, this.depth = W, this.format = l, this.type = F, this.dataFormat = S, this.border = c, this.textureUnit = A, Number.isFinite(this.textureUnit) && (this.gl.activeTexture(33984 + this.textureUnit), this.gl.bindTexture(this.target, this.handle)), V && this._isNPOT() && (Fn.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), V = !1, this._updateForNPOT(g)), this.mipmaps = V, this.setImageData({
      data: t,
      width: C,
      height: I,
      depth: W,
      format: l,
      type: F,
      dataFormat: S,
      border: c,
      mipmaps: V,
      parameters: y,
      compressed: U
    }), V && this.generateMipmap(), this.setParameters(g), a && (this.data = t), i && (this._video = {
      video: t,
      parameters: g,
      lastTime: t.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? t.currentTime : -1
    }), this;
  }
  update() {
    if (this._video) {
      const {
        video: e,
        parameters: t,
        lastTime: i
      } = this._video;
      if (i === e.currentTime || e.readyState < HTMLVideoElement.HAVE_CURRENT_DATA)
        return;
      this.setSubImageData({
        data: e,
        parameters: t
      }), this.mipmaps && this.generateMipmap(), this._video.lastTime = e.currentTime;
    }
  }
  resize(e) {
    let {
      height: t,
      width: i,
      mipmaps: r = !1
    } = e;
    return i !== this.width || t !== this.height ? this.initialize({
      width: i,
      height: t,
      format: this.format,
      type: this.type,
      dataFormat: this.dataFormat,
      border: this.border,
      mipmaps: r
    }) : this;
  }
  generateMipmap() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this._isNPOT() ? (Fn.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))(), this) : (this.mipmaps = !0, this.gl.bindTexture(this.target, this.handle), yc(this.gl, e, () => {
      this.gl.generateMipmap(this.target);
    }), this.gl.bindTexture(this.target, null), this);
  }
  setImageData(e) {
    this._trackDeallocatedMemory("Texture");
    const {
      target: t = this.target,
      pixels: i = null,
      level: r = 0,
      format: l = this.format,
      border: c = this.border,
      offset: a = 0,
      parameters: g = {}
    } = e;
    let {
      data: y = null,
      type: A = this.type,
      width: C = this.width,
      height: I = this.height,
      dataFormat: S = this.dataFormat,
      compressed: F = !1
    } = e;
    y || (y = i), {
      type: A,
      dataFormat: S,
      compressed: F,
      width: C,
      height: I
    } = this._deduceParameters({
      format: l,
      type: A,
      dataFormat: S,
      compressed: F,
      data: y,
      width: C,
      height: I
    });
    const {
      gl: U
    } = this;
    U.bindTexture(this.target, this.handle);
    let V = null;
    ({
      data: y,
      dataType: V
    } = this._getDataType({
      data: y,
      compressed: F
    }));
    let W, X = 0;
    if (yc(this.gl, g, () => {
      switch (V) {
        case "null":
          U.texImage2D(t, r, l, C, I, c, S, A, y);
          break;
        case "typed-array":
          U.texImage2D(t, r, l, C, I, c, S, A, y, a);
          break;
        case "buffer":
          W = ua(U), W.bindBuffer(35052, y.handle || y), W.texImage2D(t, r, l, C, I, c, S, A, a), W.bindBuffer(35052, null);
          break;
        case "browser-object":
          Si(U) ? U.texImage2D(t, r, l, C, I, c, S, A, y) : U.texImage2D(t, r, l, S, A, y);
          break;
        case "compressed":
          for (const [de, ie] of y.entries())
            U.compressedTexImage2D(t, de, ie.format, ie.width, ie.height, c, ie.data), X += ie.levelSize;
          break;
        default:
          En(!1, "Unknown image data type");
      }
    }), V === "compressed")
      this._trackAllocatedMemory(X, "Texture");
    else if (y && y.byteLength)
      this._trackAllocatedMemory(y.byteLength, "Texture");
    else {
      const de = VT[this.dataFormat] || 4, ie = qT[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * de * ie, "Texture");
    }
    return this.loaded = !0, this;
  }
  setSubImageData(e) {
    let {
      target: t = this.target,
      pixels: i = null,
      data: r = null,
      x: l = 0,
      y: c = 0,
      width: a = this.width,
      height: g = this.height,
      level: y = 0,
      format: A = this.format,
      type: C = this.type,
      dataFormat: I = this.dataFormat,
      compressed: S = !1,
      offset: F = 0,
      border: U = this.border,
      parameters: V = {}
    } = e;
    if ({
      type: C,
      dataFormat: I,
      compressed: S,
      width: a,
      height: g
    } = this._deduceParameters({
      format: A,
      type: C,
      dataFormat: I,
      compressed: S,
      data: r,
      width: a,
      height: g
    }), En(this.depth === 0, "texSubImage not supported for 3D textures"), r || (r = i), r && r.data) {
      const W = r;
      r = W.data, a = W.shape[0], g = W.shape[1];
    }
    r instanceof dr && (r = r.handle), this.gl.bindTexture(this.target, this.handle), yc(this.gl, V, () => {
      if (S)
        this.gl.compressedTexSubImage2D(t, y, l, c, a, g, A, r);
      else if (r === null)
        this.gl.texSubImage2D(t, y, l, c, a, g, I, C, null);
      else if (ArrayBuffer.isView(r))
        this.gl.texSubImage2D(t, y, l, c, a, g, I, C, r, F);
      else if (r instanceof Dx) {
        const W = ua(this.gl);
        W.bindBuffer(35052, r), W.texSubImage2D(t, y, l, c, a, g, I, C, F), W.bindBuffer(35052, null);
      } else Si(this.gl) ? ua(this.gl).texSubImage2D(t, y, l, c, a, g, I, C, r) : this.gl.texSubImage2D(t, y, l, c, I, C, r);
    }), this.gl.bindTexture(this.target, null);
  }
  copyFramebuffer() {
    return Fn.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null;
  }
  getActiveUnit() {
    return this.gl.getParameter(34016) - 33984;
  }
  bind() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
    const {
      gl: t
    } = this;
    return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.target, this.handle), e;
  }
  unbind() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
    const {
      gl: t
    } = this;
    return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.target, null), e;
  }
  _getDataType(e) {
    let {
      data: t,
      compressed: i = !1
    } = e;
    return i ? {
      data: t,
      dataType: "compressed"
    } : t === null ? {
      data: t,
      dataType: "null"
    } : ArrayBuffer.isView(t) ? {
      data: t,
      dataType: "typed-array"
    } : t instanceof dr ? {
      data: t.handle,
      dataType: "buffer"
    } : t instanceof Dx ? {
      data: t,
      dataType: "buffer"
    } : {
      data: t,
      dataType: "browser-object"
    };
  }
  _deduceParameters(e) {
    const {
      format: t,
      data: i
    } = e;
    let {
      width: r,
      height: l,
      dataFormat: c,
      type: a,
      compressed: g
    } = e;
    const y = rb[t];
    return c = c || y && y.dataFormat, a = a || y && y.types[0], g = g || y && y.compressed, {
      width: r,
      height: l
    } = this._deduceImageSize(i, r, l), {
      dataFormat: c,
      type: a,
      compressed: g,
      width: r,
      height: l,
      format: t,
      data: i
    };
  }
  _deduceImageSize(e, t, i) {
    let r;
    return typeof ImageData < "u" && e instanceof ImageData ? r = {
      width: e.width,
      height: e.height
    } : typeof HTMLImageElement < "u" && e instanceof HTMLImageElement ? r = {
      width: e.naturalWidth,
      height: e.naturalHeight
    } : typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement ? r = {
      width: e.width,
      height: e.height
    } : typeof ImageBitmap < "u" && e instanceof ImageBitmap ? r = {
      width: e.width,
      height: e.height
    } : typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement ? r = {
      width: e.videoWidth,
      height: e.videoHeight
    } : e ? r = {
      width: t,
      height: i
    } : r = {
      width: t >= 0 ? t : 1,
      height: i >= 0 ? i : 1
    }, En(r, "Could not deduced texture size"), En(t === void 0 || r.width === t, "Deduced texture width does not match supplied width"), En(i === void 0 || r.height === i, "Deduced texture height does not match supplied height"), r;
  }
  _createHandle() {
    return this.gl.createTexture();
  }
  _deleteHandle() {
    this.gl.deleteTexture(this.handle), this._trackDeallocatedMemory("Texture");
  }
  _getParameter(e) {
    switch (e) {
      case 4096:
        return this.width;
      case 4097:
        return this.height;
      default:
        this.gl.bindTexture(this.target, this.handle);
        const t = this.gl.getTexParameter(this.target, e);
        return this.gl.bindTexture(this.target, null), t;
    }
  }
  _setParameter(e, t) {
    switch (this.gl.bindTexture(this.target, this.handle), t = this._getNPOTParam(e, t), e) {
      case 33082:
      case 33083:
        this.gl.texParameterf(this.handle, e, t);
        break;
      case 4096:
      case 4097:
        En(!1);
        break;
      default:
        this.gl.texParameteri(this.target, e, t);
        break;
    }
    return this.gl.bindTexture(this.target, null), this;
  }
  _isNPOT() {
    return Si(this.gl) || !this.width || !this.height ? !1 : !Bx(this.width) || !Bx(this.height);
  }
  _updateForNPOT(e) {
    e[this.gl.TEXTURE_MIN_FILTER] === void 0 && (e[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR), e[this.gl.TEXTURE_WRAP_S] === void 0 && (e[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE), e[this.gl.TEXTURE_WRAP_T] === void 0 && (e[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE);
  }
  _getNPOTParam(e, t) {
    if (this._isNPOT())
      switch (e) {
        case 10241:
          dB.indexOf(t) === -1 && (t = 9729);
          break;
        case 10242:
        case 10243:
          t !== 33071 && (t = 33071);
          break;
      }
    return t;
  }
}
let fB = "";
function pB(n, e) {
  return En(typeof n == "string"), n = fB + n, new Promise((t, i) => {
    try {
      const r = new Image();
      r.onload = () => t(r), r.onerror = () => i(new Error("Could not load image ".concat(n, "."))), r.crossOrigin = e && e.crossOrigin || "anonymous", r.src = n;
    } catch (r) {
      i(r);
    }
  });
}
class rl extends af {
  get [Symbol.toStringTag]() {
    return "Texture2D";
  }
  static isSupported(e, t) {
    return af.isSupported(e, t);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e_(e), (t instanceof Promise || typeof t == "string") && (t = {
      data: t
    }), typeof t.data == "string" && (t = Object.assign({}, t, {
      data: pB(t.data)
    })), super(e, Object.assign({}, t, {
      target: 3553
    })), this.initialize(t), Object.seal(this);
  }
}
const qy = [34069, 34070, 34071, 34072, 34073, 34074];
class HT extends af {
  get [Symbol.toStringTag]() {
    return "TextureCube";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e_(e), super(e, Object.assign({}, t, {
      target: 34067
    })), this.initialize(t), Object.seal(this);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      mipmaps: t = !0,
      parameters: i = {}
    } = e;
    return this.opts = e, this.setCubeMapImageData(e).then(() => {
      this.loaded = !0, t && this.generateMipmap(e), this.setParameters(i);
    }), this;
  }
  subImage(e) {
    let {
      face: t,
      data: i,
      x: r = 0,
      y: l = 0,
      mipmapLevel: c = 0
    } = e;
    return this._subImage({
      target: t,
      data: i,
      x: r,
      y: l,
      mipmapLevel: c
    });
  }
  async setCubeMapImageData(e) {
    let {
      width: t,
      height: i,
      pixels: r,
      data: l,
      border: c = 0,
      format: a = 6408,
      type: g = 5121
    } = e;
    const {
      gl: y
    } = this, A = r || l, C = await Promise.all(qy.map((I) => {
      const S = A[I];
      return Promise.all(Array.isArray(S) ? S : [S]);
    }));
    this.bind(), qy.forEach((I, S) => {
      C[S].length > 1 && this.opts.mipmaps !== !1 && Fn.warn("".concat(this.id, " has mipmap and multiple LODs."))(), C[S].forEach((F, U) => {
        t && i ? y.texImage2D(I, U, a, t, i, c, a, g, F) : y.texImage2D(I, U, a, a, g, F);
      });
    }), this.unbind();
  }
  setImageDataForFace(e) {
    const {
      face: t,
      width: i,
      height: r,
      pixels: l,
      data: c,
      border: a = 0,
      format: g = 6408,
      type: y = 5121
    } = e, {
      gl: A
    } = this, C = l || c;
    return this.bind(), C instanceof Promise ? C.then((I) => this.setImageDataForFace(Object.assign({}, e, {
      face: t,
      data: I,
      pixels: I
    }))) : this.width || this.height ? A.texImage2D(t, 0, g, i, r, a, g, y, C) : A.texImage2D(t, 0, g, g, y, C), this;
  }
}
HT.FACES = qy;
class gB extends af {
  get [Symbol.toStringTag]() {
    return "Texture3D";
  }
  static isSupported(e) {
    return Si(e);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    ua(e), t = Object.assign({
      depth: 1
    }, t, {
      target: 32879,
      unpackFlipY: !1
    }), super(e, t), this.initialize(t), Object.seal(this);
  }
  setImageData(e) {
    let {
      level: t = 0,
      dataFormat: i = 6408,
      width: r,
      height: l,
      depth: c = 1,
      border: a = 0,
      format: g,
      type: y = 5121,
      offset: A = 0,
      data: C,
      parameters: I = {}
    } = e;
    if (this._trackDeallocatedMemory("Texture"), this.gl.bindTexture(this.target, this.handle), yc(this.gl, I, () => {
      ArrayBuffer.isView(C) && this.gl.texImage3D(this.target, t, i, r, l, c, a, g, y, C), C instanceof dr && (this.gl.bindBuffer(35052, C.handle), this.gl.texImage3D(this.target, t, i, r, l, c, a, g, y, A));
    }), C && C.byteLength)
      this._trackAllocatedMemory(C.byteLength, "Texture");
    else {
      const S = VT[this.dataFormat] || 4, F = qT[this.type] || 1;
      this._trackAllocatedMemory(this.width * this.height * this.depth * S * F, "Texture");
    }
    return this.loaded = !0, this;
  }
}
const Rh = "EXT_color_buffer_float", Fx = {
  33189: {
    bpp: 2
  },
  33190: {
    gl2: !0,
    bpp: 3
  },
  36012: {
    gl2: !0,
    bpp: 4
  },
  36168: {
    bpp: 1
  },
  34041: {
    bpp: 4
  },
  35056: {
    gl2: !0,
    bpp: 4
  },
  36013: {
    gl2: !0,
    bpp: 5
  },
  32854: {
    bpp: 2
  },
  36194: {
    bpp: 2
  },
  32855: {
    bpp: 2
  },
  33321: {
    gl2: !0,
    bpp: 1
  },
  33330: {
    gl2: !0,
    bpp: 1
  },
  33329: {
    gl2: !0,
    bpp: 1
  },
  33332: {
    gl2: !0,
    bpp: 2
  },
  33331: {
    gl2: !0,
    bpp: 2
  },
  33334: {
    gl2: !0,
    bpp: 4
  },
  33333: {
    gl2: !0,
    bpp: 4
  },
  33323: {
    gl2: !0,
    bpp: 2
  },
  33336: {
    gl2: !0,
    bpp: 2
  },
  33335: {
    gl2: !0,
    bpp: 2
  },
  33338: {
    gl2: !0,
    bpp: 4
  },
  33337: {
    gl2: !0,
    bpp: 4
  },
  33340: {
    gl2: !0,
    bpp: 8
  },
  33339: {
    gl2: !0,
    bpp: 8
  },
  32849: {
    gl2: !0,
    bpp: 3
  },
  32856: {
    gl2: !0,
    bpp: 4
  },
  32857: {
    gl2: !0,
    bpp: 4
  },
  36220: {
    gl2: !0,
    bpp: 4
  },
  36238: {
    gl2: !0,
    bpp: 4
  },
  36975: {
    gl2: !0,
    bpp: 4
  },
  36214: {
    gl2: !0,
    bpp: 8
  },
  36232: {
    gl2: !0,
    bpp: 8
  },
  36226: {
    gl2: !0,
    bpp: 16
  },
  36208: {
    gl2: !0,
    bpp: 16
  },
  33325: {
    gl2: Rh,
    bpp: 2
  },
  33327: {
    gl2: Rh,
    bpp: 4
  },
  34842: {
    gl2: Rh,
    bpp: 8
  },
  33326: {
    gl2: Rh,
    bpp: 4
  },
  33328: {
    gl2: Rh,
    bpp: 8
  },
  34836: {
    gl2: Rh,
    bpp: 16
  },
  35898: {
    gl2: Rh,
    bpp: 4
  }
};
function mB(n, e, t) {
  const i = t[e];
  if (!i)
    return !1;
  const r = Si(n) && i.gl2 || i.gl1;
  return typeof r == "string" ? n.getExtension(r) : r;
}
class Gd extends Nu {
  get [Symbol.toStringTag]() {
    return "Renderbuffer";
  }
  static isSupported(e) {
    let {
      format: t
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      format: null
    };
    return !t || mB(e, t, Fx);
  }
  static getSamplesForFormat(e, t) {
    let {
      format: i
    } = t;
    return e.getInternalformatParameter(36161, i, 32937);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.initialize(t), Object.seal(this);
  }
  initialize(e) {
    let {
      format: t,
      width: i = 1,
      height: r = 1,
      samples: l = 0
    } = e;
    return En(t, "Needs format"), this._trackDeallocatedMemory(), this.gl.bindRenderbuffer(36161, this.handle), l !== 0 && Si(this.gl) ? this.gl.renderbufferStorageMultisample(36161, l, t, i, r) : this.gl.renderbufferStorage(36161, t, i, r), this.format = t, this.width = i, this.height = r, this.samples = l, this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * Fx[this.format].bpp), this;
  }
  resize(e) {
    let {
      width: t,
      height: i
    } = e;
    return t !== this.width || i !== this.height ? this.initialize({
      width: t,
      height: i,
      format: this.format,
      samples: this.samples
    }) : this;
  }
  _createHandle() {
    return this.gl.createRenderbuffer();
  }
  _deleteHandle() {
    this.gl.deleteRenderbuffer(this.handle), this._trackDeallocatedMemory();
  }
  _bindHandle(e) {
    this.gl.bindRenderbuffer(36161, e);
  }
  _syncHandle(e) {
    this.format = this.getParameter(36164), this.width = this.getParameter(36162), this.height = this.getParameter(36163), this.samples = this.getParameter(36011);
  }
  _getParameter(e) {
    return this.gl.bindRenderbuffer(36161, this.handle), this.gl.getRenderbufferParameter(36161, e);
  }
}
const _B = 256, yB = 1024, bB = 16384, Nx = 6144, kx = 6145, zx = 6146, Ux = 34041, WT = "clear: bad arguments";
function sb(n) {
  let {
    framebuffer: e = null,
    color: t = null,
    depth: i = null,
    stencil: r = null
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const l = {};
  e && (l.framebuffer = e);
  let c = 0;
  t && (c |= bB, t !== !0 && (l.clearColor = t)), i && (c |= _B, i !== !0 && (l.clearDepth = i)), r && (c |= yB, i !== !0 && (l.clearStencil = i)), En(c !== 0, WT), yc(n, l, () => {
    n.clear(c);
  });
}
function vB(n) {
  let {
    framebuffer: e = null,
    buffer: t = Nx,
    drawBuffer: i = 0,
    value: r = [0, 0, 0, 0]
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  ua(n), yc(n, {
    framebuffer: e
  }, () => {
    switch (t) {
      case Nx:
        switch (r.constructor) {
          case Int32Array:
            n.clearBufferiv(t, i, r);
            break;
          case Uint32Array:
            n.clearBufferuiv(t, i, r);
            break;
          case Float32Array:
          default:
            n.clearBufferfv(t, i, r);
        }
        break;
      case kx:
        n.clearBufferfv(kx, 0, [r]);
        break;
      case zx:
        n.clearBufferiv(zx, 0, [r]);
        break;
      case Ux:
        const [l, c] = r;
        n.clearBufferfi(Ux, 0, l, c);
        break;
      default:
        En(!1, WT);
    }
  });
}
function xB(n) {
  switch (n) {
    case 6406:
    case 33326:
    case 6403:
      return 1;
    case 33328:
    case 33319:
      return 2;
    case 6407:
    case 34837:
      return 3;
    case 6408:
    case 34836:
      return 4;
    default:
      return En(!1), 0;
  }
}
function t_(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    sourceX: t = 0,
    sourceY: i = 0,
    sourceFormat: r = 6408
  } = e;
  let {
    sourceAttachment: l = 36064,
    target: c = null,
    sourceWidth: a,
    sourceHeight: g,
    sourceType: y
  } = e;
  const {
    framebuffer: A,
    deleteFramebuffer: C
  } = wB(n);
  En(A);
  const {
    gl: I,
    handle: S,
    attachments: F
  } = A;
  a = a || A.width, g = g || A.height, l === 36064 && S === null && (l = 1028), En(F[l]), y = y || F[l].type, c = AB(c, y, r, a, g), y = y || Gy(c);
  const U = I.bindFramebuffer(36160, S);
  return I.readPixels(t, i, a, g, r, y, c), I.bindFramebuffer(36160, U || null), C && A.delete(), c;
}
function jx(n) {
  let {
    sourceAttachment: e = 36064,
    targetMaxHeight: t = Number.MAX_SAFE_INTEGER
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = t_(n, {
    sourceAttachment: e
  }), {
    width: r,
    height: l
  } = n;
  for (; l > t; )
    ({
      data: i,
      width: r,
      height: l
    } = sB({
      data: i,
      width: r,
      height: l
    }));
  rB({
    data: i,
    width: r,
    height: l
  });
  const c = document.createElement("canvas");
  c.width = r, c.height = l;
  const a = c.getContext("2d"), g = a.createImageData(r, l);
  return g.data.set(i), a.putImageData(g, 0, 0), c.toDataURL();
}
function wB(n) {
  return n instanceof Vs ? {
    framebuffer: n,
    deleteFramebuffer: !1
  } : {
    framebuffer: RB(n),
    deleteFramebuffer: !0
  };
}
function AB(n, e, t, i, r) {
  if (n)
    return n;
  e = e || 5121;
  const l = Sp(e, {
    clamped: !1
  }), c = xB(t);
  return new l(i * r * c);
}
const Tr = {
  WEBGL2: "WEBGL2",
  VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
  TIMER_QUERY: "TIMER_QUERY",
  INSTANCED_RENDERING: "INSTANCED_RENDERING",
  MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
  ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
  BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
  FLOAT_BLEND: "FLOAT_BLEND",
  COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
  TEXTURE_DEPTH: "TEXTURE_DEPTH",
  TEXTURE_FLOAT: "TEXTURE_FLOAT",
  TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
  TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
  TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
  TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
  COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
  COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
  COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
  GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
  GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
  GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
  GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
};
function TB(n) {
  const e = new rl(n, {
    format: 6408,
    type: 5126,
    dataFormat: 6408
  }), t = new Vs(n, {
    id: "test-framebuffer",
    check: !1,
    attachments: {
      36064: e
    }
  }), i = t.getStatus();
  return e.delete(), t.delete(), i === 36053;
}
const ZT = {
  [Tr.WEBGL2]: [!1, !0],
  [Tr.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", !0],
  [Tr.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
  [Tr.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", !0],
  [Tr.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", !0],
  [Tr.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", !0],
  [Tr.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", !0],
  [Tr.FLOAT_BLEND]: ["EXT_float_blend"],
  [Tr.COLOR_ENCODING_SRGB]: ["EXT_sRGB", !0],
  [Tr.TEXTURE_DEPTH]: ["WEBGL_depth_texture", !0],
  [Tr.TEXTURE_FLOAT]: ["OES_texture_float", !0],
  [Tr.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", !0],
  [Tr.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"],
  [Tr.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"],
  [Tr.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"],
  [Tr.COLOR_ATTACHMENT_RGBA32F]: [TB, "EXT_color_buffer_float"],
  [Tr.COLOR_ATTACHMENT_FLOAT]: [!1, "EXT_color_buffer_float"],
  [Tr.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"],
  [Tr.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", !0],
  [Tr.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", !0],
  [Tr.GLSL_DERIVATIVES]: ["OES_standard_derivatives", !0],
  [Tr.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", !0]
}, EB = 2;
function ob(n, e) {
  return $T(n, e);
}
function $T(n, e) {
  return e = Array.isArray(e) ? e : [e], e.every((t) => XT(n, t));
}
function SB(n) {
  n.luma = n.luma || {}, n.luma.caps = n.luma.caps || {};
  for (const e in ZT)
    n.luma.caps[e] === void 0 && (n.luma.caps[e] = XT(n, e));
  return n.luma.caps;
}
function XT(n, e) {
  return n.luma = n.luma || {}, n.luma.caps = n.luma.caps || {}, n.luma.caps[e] === void 0 && (n.luma.caps[e] = CB(n, e)), n.luma.caps[e] || Fn.log(EB, "Feature: ".concat(e, " not supported"))(), n.luma.caps[e];
}
function CB(n, e) {
  const t = ZT[e];
  En(t, e);
  let i;
  const r = Si(n) && t[1] || t[0];
  if (typeof r == "function")
    i = r(n);
  else if (Array.isArray(r)) {
    i = !0;
    for (const l of r)
      i = i && !!n.getExtension(l);
  } else typeof r == "string" ? i = !!n.getExtension(r) : typeof r == "boolean" ? i = r : En(!1);
  return i;
}
const Gx = "Multiple render targets not supported";
class Vs extends Nu {
  get [Symbol.toStringTag]() {
    return "Framebuffer";
  }
  static isSupported(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      colorBufferFloat: i,
      colorBufferHalfFloat: r
    } = t;
    let l = !0;
    return i && (l = !!(e.getExtension("EXT_color_buffer_float") || e.getExtension("WEBGL_color_buffer_float") || e.getExtension("OES_texture_float"))), r && (l = l && !!(e.getExtension("EXT_color_buffer_float") || e.getExtension("EXT_color_buffer_half_float"))), l;
  }
  static getDefaultFramebuffer(e) {
    return e.luma = e.luma || {}, e.luma.defaultFramebuffer = e.luma.defaultFramebuffer || new Vs(e, {
      id: "default-framebuffer",
      handle: null,
      attachments: {}
    }), e.luma.defaultFramebuffer;
  }
  get MAX_COLOR_ATTACHMENTS() {
    const e = ua(this.gl);
    return e.getParameter(e.MAX_COLOR_ATTACHMENTS);
  }
  get MAX_DRAW_BUFFERS() {
    const e = ua(this.gl);
    return e.getParameter(e.MAX_DRAW_BUFFERS);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.width = null, this.height = null, this.attachments = {}, this.readBuffer = 36064, this.drawBuffers = [36064], this.ownResources = [], this.initialize(t), Object.seal(this);
  }
  get color() {
    return this.attachments[36064] || null;
  }
  get texture() {
    return this.attachments[36064] || null;
  }
  get depth() {
    return this.attachments[36096] || this.attachments[33306] || null;
  }
  get stencil() {
    return this.attachments[36128] || this.attachments[33306] || null;
  }
  initialize(e) {
    let {
      width: t = 1,
      height: i = 1,
      attachments: r = null,
      color: l = !0,
      depth: c = !0,
      stencil: a = !1,
      check: g = !0,
      readBuffer: y = void 0,
      drawBuffers: A = void 0
    } = e;
    if (En(t >= 0 && i >= 0, "Width and height need to be integers"), this.width = t, this.height = i, r)
      for (const C in r) {
        const I = r[C];
        (Array.isArray(I) ? I[0] : I).resize({
          width: t,
          height: i
        });
      }
    else
      r = this._createDefaultAttachments(l, c, a, t, i);
    this.update({
      clearAttachments: !0,
      attachments: r,
      readBuffer: y,
      drawBuffers: A
    }), r && g && this.checkStatus();
  }
  delete() {
    for (const e of this.ownResources)
      e.delete();
    return super.delete(), this;
  }
  update(e) {
    let {
      attachments: t = {},
      readBuffer: i,
      drawBuffers: r,
      clearAttachments: l = !1,
      resizeAttachments: c = !0
    } = e;
    this.attach(t, {
      clearAttachments: l,
      resizeAttachments: c
    });
    const {
      gl: a
    } = this, g = a.bindFramebuffer(36160, this.handle);
    return i && this._setReadBuffer(i), r && this._setDrawBuffers(r), a.bindFramebuffer(36160, g || null), this;
  }
  resize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, {
      width: t,
      height: i
    } = e;
    if (this.handle === null)
      return En(t === void 0 && i === void 0), this.width = this.gl.drawingBufferWidth, this.height = this.gl.drawingBufferHeight, this;
    t === void 0 && (t = this.gl.drawingBufferWidth), i === void 0 && (i = this.gl.drawingBufferHeight), t !== this.width && i !== this.height && Fn.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(t, "x").concat(i))();
    for (const r in this.attachments)
      this.attachments[r].resize({
        width: t,
        height: i
      });
    return this.width = t, this.height = i, this;
  }
  attach(e) {
    let {
      clearAttachments: t = !1,
      resizeAttachments: i = !0
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const r = {};
    t && Object.keys(this.attachments).forEach((c) => {
      r[c] = null;
    }), Object.assign(r, e);
    const l = this.gl.bindFramebuffer(36160, this.handle);
    for (const c in r) {
      En(c !== void 0, "Misspelled framebuffer binding point?");
      const a = Number(c), g = r[a];
      let y = g;
      if (!y)
        this._unattach(a);
      else if (y instanceof Gd)
        this._attachRenderbuffer({
          attachment: a,
          renderbuffer: y
        });
      else if (Array.isArray(g)) {
        const [A, C = 0, I = 0] = g;
        y = A, this._attachTexture({
          attachment: a,
          texture: A,
          layer: C,
          level: I
        });
      } else
        this._attachTexture({
          attachment: a,
          texture: y,
          layer: 0,
          level: 0
        });
      i && y && y.resize({
        width: this.width,
        height: this.height
      });
    }
    this.gl.bindFramebuffer(36160, l || null), Object.assign(this.attachments, e), Object.keys(this.attachments).filter((c) => !this.attachments[c]).forEach((c) => {
      delete this.attachments[c];
    });
  }
  checkStatus() {
    const e = this.getStatus();
    if (e !== 36053)
      throw new Error(IB(e));
    return this;
  }
  getStatus() {
    const {
      gl: e
    } = this, t = e.bindFramebuffer(36160, this.handle), i = e.checkFramebufferStatus(36160);
    return e.bindFramebuffer(36160, t || null), i;
  }
  clear() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      color: t,
      depth: i,
      stencil: r,
      drawBuffers: l = []
    } = e, c = this.gl.bindFramebuffer(36160, this.handle);
    return (t || i || r) && sb(this.gl, {
      color: t,
      depth: i,
      stencil: r
    }), l.forEach((a, g) => {
      vB(this.gl, {
        drawBuffer: g,
        value: a
      });
    }), this.gl.bindFramebuffer(36160, c || null), this;
  }
  readPixels() {
    return Fn.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")(), null;
  }
  readPixelsToBuffer() {
    return Fn.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")(), null;
  }
  copyToDataUrl() {
    return Fn.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")(), null;
  }
  copyToImage() {
    return Fn.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")(), null;
  }
  copyToTexture() {
    return Fn.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")(), null;
  }
  blit() {
    return Fn.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")(), null;
  }
  invalidate(e) {
    let {
      attachments: t = [],
      x: i = 0,
      y: r = 0,
      width: l,
      height: c
    } = e;
    const a = ua(this.gl), g = a.bindFramebuffer(36008, this.handle);
    return i === 0 && r === 0 && l === void 0 && c === void 0 ? a.invalidateFramebuffer(36008, t) : a.invalidateFramebuffer(36008, t, i, r, l, c), a.bindFramebuffer(36008, g), this;
  }
  getAttachmentParameter(e, t, i) {
    let r = this._getAttachmentParameterFallback(t);
    return r === null && (this.gl.bindFramebuffer(36160, this.handle), r = this.gl.getFramebufferAttachmentParameter(36160, e, t), this.gl.bindFramebuffer(36160, null)), i && r > 1e3 && (r = dh(this.gl, r)), r;
  }
  getAttachmentParameters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064, t = arguments.length > 1 ? arguments[1] : void 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
    const r = {};
    for (const l of i) {
      const c = t ? dh(this.gl, l) : l;
      r[c] = this.getAttachmentParameter(e, l, t);
    }
    return r;
  }
  getParameters() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
    const t = Object.keys(this.attachments), i = {};
    for (const r of t) {
      const l = Number(r), c = e ? dh(this.gl, l) : l;
      i[c] = this.getAttachmentParameters(l, e);
    }
    return i;
  }
  show() {
    return typeof window < "u" && window.open(jx(this), "luma-debug-texture"), this;
  }
  log() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    if (e > Fn.level || typeof window > "u")
      return this;
    t = t || "Framebuffer ".concat(this.id);
    const i = jx(this, {
      targetMaxHeight: 100
    });
    return Fn.image({
      logLevel: e,
      message: t,
      image: i
    }, t)(), this;
  }
  bind() {
    let {
      target: e = 36160
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.gl.bindFramebuffer(e, this.handle), this;
  }
  unbind() {
    let {
      target: e = 36160
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.gl.bindFramebuffer(e, null), this;
  }
  _createDefaultAttachments(e, t, i, r, l) {
    let c = null;
    return e && (c = c || {}, c[36064] = new rl(this.gl, {
      id: "".concat(this.id, "-color0"),
      pixels: null,
      format: 6408,
      type: 5121,
      width: r,
      height: l,
      mipmaps: !1,
      parameters: {
        10241: 9729,
        10240: 9729,
        10242: 33071,
        10243: 33071
      }
    }), this.ownResources.push(c[36064])), t && i ? (c = c || {}, c[33306] = new Gd(this.gl, {
      id: "".concat(this.id, "-depth-stencil"),
      format: 35056,
      width: r,
      height: 111
    }), this.ownResources.push(c[33306])) : t ? (c = c || {}, c[36096] = new Gd(this.gl, {
      id: "".concat(this.id, "-depth"),
      format: 33189,
      width: r,
      height: l
    }), this.ownResources.push(c[36096])) : i && En(!1), c;
  }
  _unattach(e) {
    const t = this.attachments[e];
    t && (t instanceof Gd ? this.gl.framebufferRenderbuffer(36160, e, 36161, null) : this.gl.framebufferTexture2D(36160, e, 3553, null, 0), delete this.attachments[e]);
  }
  _attachRenderbuffer(e) {
    let {
      attachment: t = 36064,
      renderbuffer: i
    } = e;
    const {
      gl: r
    } = this;
    r.framebufferRenderbuffer(36160, t, 36161, i.handle), this.attachments[t] = i;
  }
  _attachTexture(e) {
    let {
      attachment: t = 36064,
      texture: i,
      layer: r,
      level: l
    } = e;
    const {
      gl: c
    } = this;
    switch (c.bindTexture(i.target, i.handle), i.target) {
      case 35866:
      case 32879:
        ua(c).framebufferTextureLayer(36160, t, i.target, l, r);
        break;
      case 34067:
        const g = PB(r);
        c.framebufferTexture2D(36160, t, g, i.handle, l);
        break;
      case 3553:
        c.framebufferTexture2D(36160, t, 3553, i.handle, l);
        break;
      default:
        En(!1, "Illegal texture type");
    }
    c.bindTexture(i.target, null), this.attachments[t] = i;
  }
  _setReadBuffer(e) {
    const t = rR(this.gl);
    t ? t.readBuffer(e) : En(e === 36064 || e === 1029, Gx), this.readBuffer = e;
  }
  _setDrawBuffers(e) {
    const {
      gl: t
    } = this, i = ua(t);
    if (i)
      i.drawBuffers(e);
    else {
      const r = t.getExtension("WEBGL_draw_buffers");
      r ? r.drawBuffersWEBGL(e) : En(e.length === 1 && (e[0] === 36064 || e[0] === 1029), Gx);
    }
    this.drawBuffers = e;
  }
  _getAttachmentParameterFallback(e) {
    const t = SB(this.gl);
    switch (e) {
      case 36052:
        return t.WEBGL2 ? null : 0;
      case 33298:
      case 33299:
      case 33300:
      case 33301:
      case 33302:
      case 33303:
        return t.WEBGL2 ? null : 8;
      case 33297:
        return t.WEBGL2 ? null : 5125;
      case 33296:
        return !t.WEBGL2 && !t.EXT_sRGB ? 9729 : null;
      default:
        return null;
    }
  }
  _createHandle() {
    return this.gl.createFramebuffer();
  }
  _deleteHandle() {
    this.gl.deleteFramebuffer(this.handle);
  }
  _bindHandle(e) {
    return this.gl.bindFramebuffer(36160, e);
  }
}
function PB(n) {
  return n < 34069 ? n + 34069 : n;
}
function IB(n) {
  return (Vs.STATUS || {})[n] || "Framebuffer error ".concat(n);
}
const MB = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
Vs.ATTACHMENT_PARAMETERS = MB;
function LB(n, e) {
  En(n instanceof rl || n instanceof HT || n instanceof gB);
  const t = n.constructor, {
    gl: i,
    width: r,
    height: l,
    format: c,
    type: a,
    dataFormat: g,
    border: y,
    mipmaps: A
  } = n, C = Object.assign({
    width: r,
    height: l,
    format: c,
    type: a,
    dataFormat: g,
    border: y,
    mipmaps: A
  }, e);
  return new t(i, C);
}
function RB(n, e) {
  const {
    gl: t,
    width: i,
    height: r,
    id: l
  } = n;
  return new Vs(t, Object.assign({}, e, {
    id: "framebuffer-for-".concat(l),
    width: i,
    height: r,
    attachments: {
      36064: n
    }
  }));
}
function im(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
  const t = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/, i = n.match(t);
  return i ? i[1] : e;
}
const BB = 35632, OB = 35633;
function DB(n) {
  switch (n) {
    case BB:
      return "fragment";
    case OB:
      return "vertex";
    default:
      return "unknown type";
  }
}
function FB(n, e, t, i) {
  const r = n.split(/\r?\n/), l = {}, c = {}, a = i || im(e) || "(unnamed)", g = "".concat(DB(t), " shader ").concat(a);
  for (let A = 0; A < r.length; A++) {
    const C = r[A];
    if (C.length <= 1)
      continue;
    const I = C.split(":"), S = I[0], F = parseInt(I[2], 10);
    if (isNaN(F))
      throw new Error("GLSL compilation error in ".concat(g, ": ").concat(n));
    S !== "WARNING" ? l[F] = C : c[F] = C;
  }
  const y = NB(e);
  return {
    shaderName: g,
    errors: Vx(l, y),
    warnings: Vx(c, y)
  };
}
function Vx(n, e) {
  let t = "";
  for (let i = 0; i < e.length; i++) {
    const r = e[i];
    if (!(!n[i + 3] && !n[i + 2] && !n[i + 1]) && (t += "".concat(r, `
`), n[i + 1])) {
      const l = n[i + 1], c = l.split(":", 3), a = c[0], g = parseInt(c[1], 10) || 0, y = l.substring(c.join(":").length + 1).trim();
      t += YT("^^^ ".concat(a, ": ").concat(y, `

`), g);
    }
  }
  return t;
}
function NB(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ": ";
  const i = n.split(/\r?\n/), r = String(i.length + e - 1).length;
  return i.map((l, c) => {
    const a = String(c + e), g = a.length;
    return YT(a, r - g) + t + l;
  });
}
function YT(n, e) {
  let t = "";
  for (let i = 0; i < e; ++i)
    t += " ";
  return "".concat(t).concat(n);
}
function JT(n) {
  let e = 100;
  const t = n.match(/[^\s]+/g);
  if (t.length >= 2 && t[0] === "#version") {
    const i = parseInt(t[1], 10);
    Number.isFinite(i) && (e = i);
  }
  return e;
}
const kB = "Shader: GLSL source code must be a JavaScript string";
class Cp extends Nu {
  get [Symbol.toStringTag]() {
    return "Shader";
  }
  static getTypeName(e) {
    switch (e) {
      case 35633:
        return "vertex-shader";
      case 35632:
        return "fragment-shader";
      default:
        return En(!1), "unknown";
    }
  }
  constructor(e, t) {
    e_(e), En(typeof t.source == "string", kB);
    const i = im(t.source, null) || t.id || Ou("unnamed ".concat(Cp.getTypeName(t.shaderType)));
    super(e, {
      id: i
    }), this.shaderType = t.shaderType, this.source = t.source, this.initialize(t);
  }
  initialize(e) {
    let {
      source: t
    } = e;
    const i = im(t, null);
    i && (this.id = Ou(i)), this._compile(t);
  }
  getParameter(e) {
    return this.gl.getShaderParameter(this.handle, e);
  }
  toString() {
    return "".concat(Cp.getTypeName(this.shaderType), ":").concat(this.id);
  }
  getName() {
    return im(this.source) || "unnamed-shader";
  }
  getSource() {
    return this.gl.getShaderSource(this.handle);
  }
  getTranslatedSource() {
    const e = this.gl.getExtension("WEBGL_debug_shaders");
    return e ? e.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
  }
  _compile() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.source;
    if (e.startsWith("#version ") || (e = `#version 100
`.concat(e)), this.source = e, this.gl.shaderSource(this.handle, this.source), this.gl.compileShader(this.handle), !this.getParameter(35713)) {
      const i = this.gl.getShaderInfoLog(this.handle), {
        shaderName: r,
        errors: l,
        warnings: c
      } = FB(i, this.source, this.shaderType, this.id);
      throw Fn.error("GLSL compilation errors in ".concat(r, `
`).concat(l))(), Fn.warn("GLSL compilation warnings in ".concat(r, `
`).concat(c))(), new Error("GLSL compilation errors in ".concat(r));
    }
  }
  _deleteHandle() {
    this.gl.deleteShader(this.handle);
  }
  _getOptsFromHandle() {
    return {
      type: this.getParameter(35663),
      source: this.getSource()
    };
  }
}
class E0 extends Cp {
  get [Symbol.toStringTag]() {
    return "VertexShader";
  }
  constructor(e, t) {
    typeof t == "string" && (t = {
      source: t
    }), super(e, Object.assign({}, t, {
      shaderType: 35633
    }));
  }
  _createHandle() {
    return this.gl.createShader(35633);
  }
}
class S0 extends Cp {
  get [Symbol.toStringTag]() {
    return "FragmentShader";
  }
  constructor(e, t) {
    typeof t == "string" && (t = {
      source: t
    }), super(e, Object.assign({}, t, {
      shaderType: 35632
    }));
  }
  _createHandle() {
    return this.gl.createShader(35632);
  }
}
const zB = {
  5126: Br.bind(null, "uniform1fv", Xa, 1, ko),
  35664: Br.bind(null, "uniform2fv", Xa, 2, ko),
  35665: Br.bind(null, "uniform3fv", Xa, 3, ko),
  35666: Br.bind(null, "uniform4fv", Xa, 4, ko),
  5124: Br.bind(null, "uniform1iv", eh, 1, ko),
  35667: Br.bind(null, "uniform2iv", eh, 2, ko),
  35668: Br.bind(null, "uniform3iv", eh, 3, ko),
  35669: Br.bind(null, "uniform4iv", eh, 4, ko),
  35670: Br.bind(null, "uniform1iv", eh, 1, ko),
  35671: Br.bind(null, "uniform2iv", eh, 2, ko),
  35672: Br.bind(null, "uniform3iv", eh, 3, ko),
  35673: Br.bind(null, "uniform4iv", eh, 4, ko),
  35674: Br.bind(null, "uniformMatrix2fv", Xa, 4, xu),
  35675: Br.bind(null, "uniformMatrix3fv", Xa, 9, xu),
  35676: Br.bind(null, "uniformMatrix4fv", Xa, 16, xu),
  35678: xo,
  35680: xo,
  5125: Br.bind(null, "uniform1uiv", Eg, 1, ko),
  36294: Br.bind(null, "uniform2uiv", Eg, 2, ko),
  36295: Br.bind(null, "uniform3uiv", Eg, 3, ko),
  36296: Br.bind(null, "uniform4uiv", Eg, 4, ko),
  35685: Br.bind(null, "uniformMatrix2x3fv", Xa, 6, xu),
  35686: Br.bind(null, "uniformMatrix2x4fv", Xa, 8, xu),
  35687: Br.bind(null, "uniformMatrix3x2fv", Xa, 6, xu),
  35688: Br.bind(null, "uniformMatrix3x4fv", Xa, 12, xu),
  35689: Br.bind(null, "uniformMatrix4x2fv", Xa, 8, xu),
  35690: Br.bind(null, "uniformMatrix4x3fv", Xa, 12, xu),
  35678: xo,
  35680: xo,
  35679: xo,
  35682: xo,
  36289: xo,
  36292: xo,
  36293: xo,
  36298: xo,
  36299: xo,
  36300: xo,
  36303: xo,
  36306: xo,
  36307: xo,
  36308: xo,
  36311: xo
}, UB = {}, jB = {}, GB = {}, qx = [0];
function ab(n, e, t, i) {
  e === 1 && typeof n == "boolean" && (n = n ? 1 : 0), Number.isFinite(n) && (qx[0] = n, n = qx);
  const r = n.length;
  if (r % e && Fn.warn("Uniform size should be multiples of ".concat(e), n)(), n instanceof t)
    return n;
  let l = i[r];
  l || (l = new t(r), i[r] = l);
  for (let c = 0; c < r; c++)
    l[c] = n[c];
  return l;
}
function Xa(n, e) {
  return ab(n, e, Float32Array, UB);
}
function eh(n, e) {
  return ab(n, e, Int32Array, jB);
}
function Eg(n, e) {
  return ab(n, e, Uint32Array, GB);
}
function Hx(n, e, t) {
  const i = zB[t.type];
  if (!i)
    throw new Error("Unknown GLSL uniform type ".concat(t.type));
  return i().bind(null, n, e);
}
function VB(n) {
  if (n[n.length - 1] !== "]")
    return {
      name: n,
      length: 1,
      isArray: !1
    };
  const e = /([^[]*)(\[[0-9]+\])?/, t = n.match(e);
  if (!t || t.length < 2)
    throw new Error("Failed to parse GLSL uniform name ".concat(n));
  return {
    name: t[1],
    length: t[2] || 1,
    isArray: !!t[2]
  };
}
function qB(n, e, t) {
  for (const i in n) {
    const r = n[i];
    if ((!t || !!t[i]) && !HB(r))
      throw e = e ? "".concat(e, " ") : "", console.error("".concat(e, " Bad uniform ").concat(i), r), new Error("".concat(e, " Bad uniform ").concat(i));
  }
  return !0;
}
function HB(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n) ? ZB(n) : isFinite(n) || n === !0 || n === !1 || n instanceof af || n instanceof Gd ? !0 : n instanceof Vs ? !!n.texture : !1;
}
function WB(n, e, t) {
  if (Array.isArray(t) || ArrayBuffer.isView(t))
    if (n[e]) {
      const i = n[e];
      for (let r = 0, l = t.length; r < l; ++r)
        i[r] = t[r];
    } else
      n[e] = t.slice();
  else
    n[e] = t;
}
function ZB(n) {
  if (n.length === 0)
    return !1;
  const e = Math.min(n.length, 16);
  for (let t = 0; t < e; ++t)
    if (!Number.isFinite(n[t]))
      return !1;
  return !0;
}
function xo() {
  let n = null;
  return (e, t, i) => {
    const r = n !== i;
    return r && (e.uniform1i(t, i), n = i), r;
  };
}
function Br(n, e, t, i) {
  let r = null, l = null;
  return (c, a, g) => {
    const y = e(g, t), A = y.length;
    let C = !1;
    if (r === null)
      r = new Float32Array(A), l = A, C = !0;
    else {
      En(l === A, "Uniform length cannot change.");
      for (let I = 0; I < A; ++I)
        if (y[I] !== r[I]) {
          C = !0;
          break;
        }
    }
    return C && (i(c, n, a, y), r.set(y)), C;
  };
}
function ko(n, e, t, i) {
  n[e](t, i);
}
function xu(n, e, t, i) {
  n[e](t, !1, i);
}
const $B = 5120, XB = 5121, YB = 5122, JB = 5123, Wx = 0, Sg = 1, KB = 2, QB = 3, Cg = 4, e4 = 5, t4 = 6, js = 5126, n4 = 35664, i4 = 35665, r4 = 35666, Yf = 5124, s4 = 35667, o4 = 35668, a4 = 35669, Jf = 5125, l4 = 36294, c4 = 36295, u4 = 36296, h4 = 35670, d4 = 35671, f4 = 35672, p4 = 35673, g4 = 35674, m4 = 35675, _4 = 35676, y4 = 35685, b4 = 35686, v4 = 35687, x4 = 35688, w4 = 35689, A4 = 35690, Hy = {
  [js]: [js, 1, "float"],
  [n4]: [js, 2, "vec2"],
  [i4]: [js, 3, "vec3"],
  [r4]: [js, 4, "vec4"],
  [Yf]: [Yf, 1, "int"],
  [s4]: [Yf, 2, "ivec2"],
  [o4]: [Yf, 3, "ivec3"],
  [a4]: [Yf, 4, "ivec4"],
  [Jf]: [Jf, 1, "uint"],
  [l4]: [Jf, 2, "uvec2"],
  [c4]: [Jf, 3, "uvec3"],
  [u4]: [Jf, 4, "uvec4"],
  [h4]: [js, 1, "bool"],
  [d4]: [js, 2, "bvec2"],
  [f4]: [js, 3, "bvec3"],
  [p4]: [js, 4, "bvec4"],
  [g4]: [js, 8, "mat2"],
  [y4]: [js, 8, "mat2x3"],
  [b4]: [js, 8, "mat2x4"],
  [m4]: [js, 12, "mat3"],
  [v4]: [js, 12, "mat3x2"],
  [x4]: [js, 12, "mat3x4"],
  [_4]: [js, 16, "mat4"],
  [w4]: [js, 16, "mat4x2"],
  [A4]: [js, 16, "mat4x3"]
};
function T4(n) {
  switch (n) {
    case Wx:
      return Wx;
    case Sg:
      return Sg;
    case QB:
      return Sg;
    case KB:
      return Sg;
    case Cg:
      return Cg;
    case e4:
      return Cg;
    case t4:
      return Cg;
    default:
      return En(!1), 0;
  }
}
function Zx(n) {
  const e = Hy[n];
  if (!e)
    return null;
  const [t, i] = e;
  return {
    type: t,
    components: i
  };
}
function KT(n, e) {
  switch (n) {
    case $B:
    case XB:
    case YB:
    case JB:
      n = js;
      break;
  }
  for (const t in Hy) {
    const [i, r, l] = Hy[t];
    if (i === n && r === e)
      return {
        glType: t,
        name: l
      };
  }
  return null;
}
class E4 {
  constructor(e) {
    this.id = e.id, this.attributeInfos = [], this.attributeInfosByName = {}, this.attributeInfosByLocation = [], this.varyingInfos = [], this.varyingInfosByName = {}, Object.seal(this), this._readAttributesFromProgram(e), this._readVaryingsFromProgram(e);
  }
  getAttributeInfo(e) {
    const t = Number(e);
    return Number.isFinite(t) ? this.attributeInfosByLocation[t] : this.attributeInfosByName[e] || null;
  }
  getAttributeLocation(e) {
    const t = this.getAttributeInfo(e);
    return t ? t.location : -1;
  }
  getAttributeAccessor(e) {
    const t = this.getAttributeInfo(e);
    return t ? t.accessor : null;
  }
  getVaryingInfo(e) {
    const t = Number(e);
    return Number.isFinite(t) ? this.varyingInfos[t] : this.varyingInfosByName[e] || null;
  }
  getVaryingIndex(e) {
    const t = this.getVaryingInfo();
    return t ? t.location : -1;
  }
  getVaryingAccessor(e) {
    const t = this.getVaryingInfo();
    return t ? t.accessor : null;
  }
  _readAttributesFromProgram(e) {
    const {
      gl: t
    } = e, i = t.getProgramParameter(e.handle, 35721);
    for (let r = 0; r < i; r++) {
      const {
        name: l,
        type: c,
        size: a
      } = t.getActiveAttrib(e.handle, r), g = t.getAttribLocation(e.handle, l);
      g >= 0 && this._addAttribute(g, l, c, a);
    }
    this.attributeInfos.sort((r, l) => r.location - l.location);
  }
  _readVaryingsFromProgram(e) {
    const {
      gl: t
    } = e;
    if (!Si(t))
      return;
    const i = t.getProgramParameter(e.handle, 35971);
    for (let r = 0; r < i; r++) {
      const {
        name: l,
        type: c,
        size: a
      } = t.getTransformFeedbackVarying(e.handle, r);
      this._addVarying(r, l, c, a);
    }
    this.varyingInfos.sort((r, l) => r.location - l.location);
  }
  _addAttribute(e, t, i, r) {
    const {
      type: l,
      components: c
    } = Zx(i), a = {
      type: l,
      size: r * c
    };
    this._inferProperties(e, t, a);
    const g = {
      location: e,
      name: t,
      accessor: new Ta(a)
    };
    this.attributeInfos.push(g), this.attributeInfosByLocation[e] = g, this.attributeInfosByName[g.name] = g;
  }
  _inferProperties(e, t, i) {
    /instance/i.test(t) && (i.divisor = 1);
  }
  _addVarying(e, t, i, r) {
    const {
      type: l,
      components: c
    } = Zx(i), a = new Ta({
      type: l,
      size: r * c
    }), g = {
      location: e,
      name: t,
      accessor: a
    };
    this.varyingInfos.push(g), this.varyingInfosByName[g.name] = g;
  }
}
const $x = 4, S4 = 35981, C4 = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
class QT extends Nu {
  get [Symbol.toStringTag]() {
    return "Program";
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.stubRemovedMethods("Program", "v6.0", C4), this._isCached = !1, this.initialize(t), Object.seal(this), this._setId(t.id);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      hash: t,
      vs: i,
      fs: r,
      varyings: l,
      bufferMode: c = S4
    } = e;
    return this.hash = t || "", this.vs = typeof i == "string" ? new E0(this.gl, {
      id: "".concat(e.id, "-vs"),
      source: i
    }) : i, this.fs = typeof r == "string" ? new S0(this.gl, {
      id: "".concat(e.id, "-fs"),
      source: r
    }) : r, En(this.vs instanceof E0), En(this.fs instanceof S0), this.uniforms = {}, this._textureUniforms = {}, l && l.length > 0 && (ua(this.gl), this.varyings = l, this.gl2.transformFeedbackVaryings(this.handle, l, c)), this._compileAndLink(), this._readUniformLocationsFromLinkedProgram(), this.configuration = new E4(this), this.setProps(e);
  }
  delete() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this._isCached ? this : super.delete(e);
  }
  setProps(e) {
    return "uniforms" in e && this.setUniforms(e.uniforms), this;
  }
  draw(e) {
    let {
      logPriority: t,
      drawMode: i = 4,
      vertexCount: r,
      offset: l = 0,
      start: c,
      end: a,
      isIndexed: g = !1,
      indexType: y = 5123,
      instanceCount: A = 0,
      isInstanced: C = A > 0,
      vertexArray: I = null,
      transformFeedback: S,
      framebuffer: F,
      parameters: U = {},
      uniforms: V,
      samplers: W
    } = e;
    if ((V || W) && (Fn.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")(), this.setUniforms(V || {})), Fn.priority >= t) {
      const X = F ? F.id : "default", de = "mode=".concat(dh(this.gl, i), " verts=").concat(r, " ") + "instances=".concat(A, " indexType=").concat(dh(this.gl, y), " ") + "isInstanced=".concat(C, " isIndexed=").concat(g, " ") + "Framebuffer=".concat(X);
      Fn.log(t, de)();
    }
    return En(I), this.gl.useProgram(this.handle), !this._areTexturesRenderable() || r === 0 || C && A === 0 ? !1 : (I.bindForDraw(r, A, () => {
      if (F !== void 0 && (U = Object.assign({}, U, {
        framebuffer: F
      })), S) {
        const X = T4(i);
        S.begin(X);
      }
      this._bindTextures(), yc(this.gl, U, () => {
        g && C ? this.gl2.drawElementsInstanced(i, r, y, l, A) : g && Si(this.gl) && !isNaN(c) && !isNaN(a) ? this.gl2.drawRangeElements(i, c, a, r, y, l) : g ? this.gl.drawElements(i, r, y, l) : C ? this.gl2.drawArraysInstanced(i, l, r, A) : this.gl.drawArrays(i, l, r);
      }), S && S.end();
    }), !0);
  }
  setUniforms() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Fn.priority >= 2 && qB(e, this.id, this._uniformSetters), this.gl.useProgram(this.handle);
    for (const t in e) {
      const i = e[t], r = this._uniformSetters[t];
      if (r) {
        let l = i, c = !1;
        if (l instanceof Vs && (l = l.texture), l instanceof af)
          if (c = this.uniforms[t] !== i, c) {
            r.textureIndex === void 0 && (r.textureIndex = this._textureIndexCounter++);
            const a = l, {
              textureIndex: g
            } = r;
            a.bind(g), l = g, this._textureUniforms[t] = a;
          } else
            l = r.textureIndex;
        else this._textureUniforms[t] && delete this._textureUniforms[t];
        (r(l) || c) && WB(this.uniforms, t, i);
      }
    }
    return this;
  }
  _areTexturesRenderable() {
    let e = !0;
    for (const t in this._textureUniforms) {
      const i = this._textureUniforms[t];
      i.update(), e = e && i.loaded;
    }
    return e;
  }
  _bindTextures() {
    for (const e in this._textureUniforms) {
      const t = this._uniformSetters[e].textureIndex;
      this._textureUniforms[e].bind(t);
    }
  }
  _createHandle() {
    return this.gl.createProgram();
  }
  _deleteHandle() {
    this.gl.deleteProgram(this.handle);
  }
  _getOptionsFromHandle(e) {
    const t = this.gl.getAttachedShaders(e), i = {};
    for (const r of t)
      switch (this.gl.getShaderParameter(this.handle, 35663)) {
        case 35633:
          i.vs = new E0({
            handle: r
          });
          break;
        case 35632:
          i.fs = new S0({
            handle: r
          });
          break;
      }
    return i;
  }
  _getParameter(e) {
    return this.gl.getProgramParameter(this.handle, e);
  }
  _setId(e) {
    if (!e) {
      const t = this._getName();
      this.id = Ou(t);
    }
  }
  _getName() {
    let e = this.vs.getName() || this.fs.getName();
    return e = e.replace(/shader/i, ""), e = e ? "".concat(e, "-program") : "program", e;
  }
  _compileAndLink() {
    const {
      gl: e
    } = this;
    if (e.attachShader(this.handle, this.vs.handle), e.attachShader(this.handle, this.fs.handle), Fn.time($x, "linkProgram for ".concat(this._getName()))(), e.linkProgram(this.handle), Fn.timeEnd($x, "linkProgram for ".concat(this._getName()))(), e.debug || Fn.level > 0) {
      if (!e.getProgramParameter(this.handle, 35714))
        throw new Error("Error linking: ".concat(e.getProgramInfoLog(this.handle)));
      if (e.validateProgram(this.handle), !e.getProgramParameter(this.handle, 35715))
        throw new Error("Error validating: ".concat(e.getProgramInfoLog(this.handle)));
    }
  }
  _readUniformLocationsFromLinkedProgram() {
    const {
      gl: e
    } = this;
    this._uniformSetters = {}, this._uniformCount = this._getParameter(35718);
    for (let t = 0; t < this._uniformCount; t++) {
      const i = this.gl.getActiveUniform(this.handle, t), {
        name: r
      } = VB(i.name);
      let l = e.getUniformLocation(this.handle, r);
      if (this._uniformSetters[r] = Hx(e, l, i), i.size > 1)
        for (let c = 0; c < i.size; c++)
          l = e.getUniformLocation(this.handle, "".concat(r, "[").concat(c, "]")), this._uniformSetters["".concat(r, "[").concat(c, "]")] = Hx(e, l, i);
    }
    this._textureIndexCounter = 0;
  }
  getActiveUniforms(e, t) {
    return this.gl2.getActiveUniforms(this.handle, e, t);
  }
  getUniformBlockIndex(e) {
    return this.gl2.getUniformBlockIndex(this.handle, e);
  }
  getActiveUniformBlockParameter(e, t) {
    return this.gl2.getActiveUniformBlockParameter(this.handle, e, t);
  }
  uniformBlockBinding(e, t) {
    this.gl2.uniformBlockBinding(this.handle, e, t);
  }
}
const P4 = 34918, I4 = 34919, M4 = 35007, L4 = 36795, R4 = 35976, B4 = 35887, O4 = 36202;
class Mm extends Nu {
  get [Symbol.toStringTag]() {
    return "Query";
  }
  static isSupported(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    const i = Si(e), r = $T(e, Tr.TIMER_QUERY);
    let l = i || r;
    for (const c of t)
      switch (c) {
        case "queries":
          l = l && i;
          break;
        case "timers":
          l = l && r;
          break;
        default:
          En(!1);
      }
    return l;
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(e, t), this.target = null, this._queryPending = !1, this._pollingPromise = null, Object.seal(this);
  }
  beginTimeElapsedQuery() {
    return this.begin(M4);
  }
  beginOcclusionQuery() {
    let {
      conservative: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.begin(e ? O4 : B4);
  }
  beginTransformFeedbackQuery() {
    return this.begin(R4);
  }
  begin(e) {
    return this._queryPending ? this : (this.target = e, this.gl2.beginQuery(this.target, this.handle), this);
  }
  end() {
    return this._queryPending ? this : (this.target && (this.gl2.endQuery(this.target), this.target = null, this._queryPending = !0), this);
  }
  isResultAvailable() {
    if (!this._queryPending)
      return !1;
    const e = this.gl2.getQueryParameter(this.handle, I4);
    return e && (this._queryPending = !1), e;
  }
  isTimerDisjoint() {
    return this.gl2.getParameter(L4);
  }
  getResult() {
    return this.gl2.getQueryParameter(this.handle, P4);
  }
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }
  createPoll() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
    if (this._pollingPromise)
      return this._pollingPromise;
    let t = 0;
    return this._pollingPromise = new Promise((i, r) => {
      const l = () => {
        this.isResultAvailable() ? (i(this.getResult()), this._pollingPromise = null) : t++ > e ? (r("Timed out"), this._pollingPromise = null) : requestAnimationFrame(l);
      };
      requestAnimationFrame(l);
    }), this._pollingPromise;
  }
  _createHandle() {
    return Mm.isSupported(this.gl) ? this.gl2.createQuery() : null;
  }
  _deleteHandle() {
    this.gl2.deleteQuery(this.handle);
  }
}
class eE extends Nu {
  get [Symbol.toStringTag]() {
    return "TransformFeedback";
  }
  static isSupported(e) {
    return Si(e);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    ua(e), super(e, t), this.initialize(t), this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]), Object.seal(this);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.buffers = {}, this.unused = {}, this.configuration = null, this.bindOnUse = !0, of(this.buffers) || this.bind(() => this._unbindBuffers()), this.setProps(e), this;
  }
  setProps(e) {
    "program" in e && (this.configuration = e.program && e.program.configuration), "configuration" in e && (this.configuration = e.configuration), "bindOnUse" in e && (e = e.bindOnUse), "buffers" in e && this.setBuffers(e.buffers);
  }
  setBuffers() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.bind(() => {
      for (const t in e)
        this.setBuffer(t, e[t]);
    }), this;
  }
  setBuffer(e, t) {
    const i = this._getVaryingIndex(e), {
      buffer: r,
      byteSize: l,
      byteOffset: c
    } = this._getBufferParams(t);
    return i < 0 ? (this.unused[e] = r, Fn.warn("".concat(this.id, " unused varying buffer ").concat(e))(), this) : (this.buffers[i] = t, this.bindOnUse || this._bindBuffer(i, r, c, l), this);
  }
  begin() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.gl.bindTransformFeedback(36386, this.handle), this._bindBuffers(), this.gl.beginTransformFeedback(e), this;
  }
  end() {
    return this.gl.endTransformFeedback(), this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null), this;
  }
  _getBufferParams(e) {
    let t, i, r;
    return e instanceof dr ? r = e : (r = e.buffer, i = e.byteSize, t = e.byteOffset), (t !== void 0 || i !== void 0) && (t = t || 0, i = i || r.byteLength - t), {
      buffer: r,
      byteOffset: t,
      byteSize: i
    };
  }
  _getVaryingInfo(e) {
    return this.configuration && this.configuration.getVaryingInfo(e);
  }
  _getVaryingIndex(e) {
    if (this.configuration)
      return this.configuration.getVaryingInfo(e).location;
    const t = Number(e);
    return Number.isFinite(t) ? t : -1;
  }
  _bindBuffers() {
    if (this.bindOnUse)
      for (const e in this.buffers) {
        const {
          buffer: t,
          byteSize: i,
          byteOffset: r
        } = this._getBufferParams(this.buffers[e]);
        this._bindBuffer(e, t, r, i);
      }
  }
  _unbindBuffers() {
    if (this.bindOnUse)
      for (const e in this.buffers)
        this._bindBuffer(e, null);
  }
  _bindBuffer(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 ? arguments[3] : void 0;
    const l = t && t.handle;
    return !l || r === void 0 ? this.gl.bindBufferBase(35982, e, l) : this.gl.bindBufferRange(35982, e, l, i, r), this;
  }
  _createHandle() {
    return this.gl.createTransformFeedback();
  }
  _deleteHandle() {
    this.gl.deleteTransformFeedback(this.handle);
  }
  _bindHandle(e) {
    this.gl.bindTransformFeedback(36386, this.handle);
  }
}
let Pg = null;
function D4(n) {
  return (!Pg || Pg.byteLength < n) && (Pg = new ArrayBuffer(n)), Pg;
}
function F4(n, e) {
  const t = D4(n.BYTES_PER_ELEMENT * e);
  return new n(t, 0, e);
}
function N4(n) {
  let {
    target: e,
    source: t,
    start: i = 0,
    count: r = 1
  } = n;
  const l = t.length, c = r * l;
  let a = 0;
  for (let g = i; a < l; a++)
    e[g++] = t[a];
  for (; a < c; )
    a < c - a ? (e.copyWithin(i + a, i, i + a), a *= 2) : (e.copyWithin(i + a, i, i + c - a), a = c);
  return e;
}
const k4 = "elements must be GL.ELEMENT_ARRAY_BUFFER";
class Ka extends Nu {
  get [Symbol.toStringTag]() {
    return "VertexArrayObject";
  }
  static isSupported(e) {
    return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}).constantAttributeZero ? Si(e) || xT() === "Chrome" : !0;
  }
  static getDefaultArray(e) {
    return e.luma = e.luma || {}, e.luma.defaultVertexArray || (e.luma.defaultVertexArray = new Ka(e, {
      handle: null,
      isDefaultArray: !0
    })), e.luma.defaultVertexArray;
  }
  static getMaxAttributes(e) {
    return Ka.MAX_ATTRIBUTES = Ka.MAX_ATTRIBUTES || e.getParameter(34921), Ka.MAX_ATTRIBUTES;
  }
  static setConstant(e, t, i) {
    switch (i.constructor) {
      case Float32Array:
        Ka._setConstantFloatArray(e, t, i);
        break;
      case Int32Array:
        Ka._setConstantIntArray(e, t, i);
        break;
      case Uint32Array:
        Ka._setConstantUintArray(e, t, i);
        break;
      default:
        En(!1);
    }
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = t.id || t.program && t.program.id;
    super(e, Object.assign({}, t, {
      id: i
    })), this.buffer = null, this.bufferValue = null, this.isDefaultArray = t.isDefaultArray || !1, this.gl2 = e, this.initialize(t), Object.seal(this);
  }
  delete() {
    return super.delete(), this.buffer && this.buffer.delete(), this;
  }
  get MAX_ATTRIBUTES() {
    return Ka.getMaxAttributes(this.gl);
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.setProps(e);
  }
  setProps(e) {
    return this;
  }
  setElementBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return En(!e || e.target === 34963, k4), this.bind(() => {
      this.gl.bindBuffer(34963, e ? e.handle : null);
    }), this;
  }
  setBuffer(e, t, i) {
    if (t.target === 34963)
      return this.setElementBuffer(t, i);
    const {
      size: r,
      type: l,
      stride: c,
      offset: a,
      normalized: g,
      integer: y,
      divisor: A
    } = i, {
      gl: C,
      gl2: I
    } = this;
    return e = Number(e), this.bind(() => {
      C.bindBuffer(34962, t.handle), y ? (En(Si(C)), I.vertexAttribIPointer(e, r, l, c, a)) : C.vertexAttribPointer(e, r, l, g, c, a), C.enableVertexAttribArray(e), I.vertexAttribDivisor(e, A || 0);
    }), this;
  }
  enable(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
    return !t && e === 0 && !Ka.isSupported(this.gl, {
      constantAttributeZero: !0
    }) || (e = Number(e), this.bind(() => t ? this.gl.enableVertexAttribArray(e) : this.gl.disableVertexAttribArray(e))), this;
  }
  getConstantBuffer(e, t) {
    const i = this._normalizeConstantArrayValue(t), r = i.byteLength * e, l = i.length * e;
    let c = !this.buffer;
    if (this.buffer = this.buffer || new dr(this.gl, r), c = c || this.buffer.reallocate(r), c = c || !this._compareConstantArrayValues(i, this.bufferValue), c) {
      const a = F4(t.constructor, l);
      N4({
        target: a,
        source: i,
        start: 0,
        count: l
      }), this.buffer.subData(a), this.bufferValue = t;
    }
    return this.buffer;
  }
  _normalizeConstantArrayValue(e) {
    return Array.isArray(e) ? new Float32Array(e) : e;
  }
  _compareConstantArrayValues(e, t) {
    if (!e || !t || e.length !== t.length || e.constructor !== t.constructor)
      return !1;
    for (let i = 0; i < e.length; ++i)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  static _setConstantFloatArray(e, t, i) {
    switch (i.length) {
      case 1:
        e.vertexAttrib1fv(t, i);
        break;
      case 2:
        e.vertexAttrib2fv(t, i);
        break;
      case 3:
        e.vertexAttrib3fv(t, i);
        break;
      case 4:
        e.vertexAttrib4fv(t, i);
        break;
      default:
        En(!1);
    }
  }
  static _setConstantIntArray(e, t, i) {
    switch (En(Si(e)), i.length) {
      case 1:
        e.vertexAttribI1iv(t, i);
        break;
      case 2:
        e.vertexAttribI2iv(t, i);
        break;
      case 3:
        e.vertexAttribI3iv(t, i);
        break;
      case 4:
        e.vertexAttribI4iv(t, i);
        break;
      default:
        En(!1);
    }
  }
  static _setConstantUintArray(e, t, i) {
    switch (En(Si(e)), i.length) {
      case 1:
        e.vertexAttribI1uiv(t, i);
        break;
      case 2:
        e.vertexAttribI2uiv(t, i);
        break;
      case 3:
        e.vertexAttribI3uiv(t, i);
        break;
      case 4:
        e.vertexAttribI4uiv(t, i);
        break;
      default:
        En(!1);
    }
  }
  _createHandle() {
    return this.gl.createVertexArray();
  }
  _deleteHandle(e) {
    return this.gl2.deleteVertexArray(e), [this.elements];
  }
  _bindHandle(e) {
    this.gl2.bindVertexArray(e);
  }
  _getParameter(e, t) {
    let {
      location: i
    } = t;
    return En(Number.isFinite(i)), this.bind(() => {
      switch (e) {
        case 34373:
          return this.gl.getVertexAttribOffset(i, e);
        default:
          return this.gl.getVertexAttrib(i, e);
      }
    });
  }
}
const z4 = "VertexArray: attributes must be Buffers or constants (i.e. typed array)", U4 = /^(.+)__LOCATION_([0-9]+)$/, j4 = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
class G4 {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = t.id || t.program && t.program.id;
    this.id = i, this.gl = e, this.configuration = null, this.elements = null, this.elementsAccessor = null, this.values = null, this.accessors = null, this.unused = null, this.drawParams = null, this.buffer = null, this.attributes = {}, this.vertexArrayObject = new Ka(e), jT(this, "VertexArray", "v6.0", j4), this.initialize(t), Object.seal(this);
  }
  delete() {
    this.buffer && this.buffer.delete(), this.vertexArrayObject.delete();
  }
  initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return this.reset(), this.configuration = null, this.bindOnUse = !1, this.setProps(e);
  }
  reset() {
    this.elements = null, this.elementsAccessor = null;
    const {
      MAX_ATTRIBUTES: e
    } = this.vertexArrayObject;
    return this.values = new Array(e).fill(null), this.accessors = new Array(e).fill(null), this.unused = {}, this.drawParams = null, this;
  }
  setProps(e) {
    return "program" in e && (this.configuration = e.program && e.program.configuration), "configuration" in e && (this.configuration = e.configuration), "attributes" in e && this.setAttributes(e.attributes), "elements" in e && this.setElementBuffer(e.elements), "bindOnUse" in e && (e = e.bindOnUse), this;
  }
  clearDrawParams() {
    this.drawParams = null;
  }
  getDrawParams() {
    return this.drawParams = this.drawParams || this._updateDrawParams(), this.drawParams;
  }
  setAttributes(e) {
    return Object.assign(this.attributes, e), this.vertexArrayObject.bind(() => {
      for (const t in e) {
        const i = e[t];
        this._setAttribute(t, i);
      }
      this.gl.bindBuffer(34962, null);
    }), this;
  }
  setElementBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return this.elements = e, this.elementsAccessor = t, this.clearDrawParams(), this.vertexArrayObject.setElementBuffer(e, t), this;
  }
  setBuffer(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (t.target === 34963)
      return this.setElementBuffer(t, i);
    const {
      location: r,
      accessor: l
    } = this._resolveLocationAndAccessor(e, t, t.accessor, i);
    return r >= 0 && (this.values[r] = t, this.accessors[r] = l, this.clearDrawParams(), this.vertexArrayObject.setBuffer(r, t, l)), this;
  }
  setConstant(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const {
      location: r,
      accessor: l
    } = this._resolveLocationAndAccessor(e, t, Object.assign({
      size: t.length
    }, i));
    return r >= 0 && (t = this.vertexArrayObject._normalizeConstantArrayValue(t), this.values[r] = t, this.accessors[r] = l, this.clearDrawParams(), this.vertexArrayObject.enable(r, !1)), this;
  }
  unbindBuffers() {
    return this.vertexArrayObject.bind(() => {
      this.elements && this.vertexArrayObject.setElementBuffer(null), this.buffer = this.buffer || new dr(this.gl, {
        accessor: {
          size: 4
        }
      });
      for (let e = 0; e < this.vertexArrayObject.MAX_ATTRIBUTES; e++)
        this.values[e] instanceof dr && (this.gl.disableVertexAttribArray(e), this.gl.bindBuffer(34962, this.buffer.handle), this.gl.vertexAttribPointer(e, 1, 5126, !1, 0, 0));
    }), this;
  }
  bindBuffers() {
    return this.vertexArrayObject.bind(() => {
      this.elements && this.setElementBuffer(this.elements);
      for (let e = 0; e < this.vertexArrayObject.MAX_ATTRIBUTES; e++) {
        const t = this.values[e];
        t instanceof dr && this.setBuffer(e, t);
      }
    }), this;
  }
  bindForDraw(e, t, i) {
    let r;
    return this.vertexArrayObject.bind(() => {
      this._setConstantAttributes(e, t), r = i();
    }), r;
  }
  _resolveLocationAndAccessor(e, t, i, r) {
    const l = {
      location: -1,
      accessor: null
    }, {
      location: c,
      name: a
    } = this._getAttributeIndex(e);
    if (!Number.isFinite(c) || c < 0)
      return this.unused[e] = t, Fn.once(3, () => "unused value ".concat(e, " in ").concat(this.id))(), l;
    const g = this._getAttributeInfo(a || c);
    if (!g)
      return l;
    const y = this.accessors[c] || {}, A = Ta.resolve(g.accessor, y, i, r), {
      size: C,
      type: I
    } = A;
    return En(Number.isFinite(C) && Number.isFinite(I)), {
      location: c,
      accessor: A
    };
  }
  _getAttributeInfo(e) {
    return this.configuration && this.configuration.getAttributeInfo(e);
  }
  _getAttributeIndex(e) {
    const t = Number(e);
    if (Number.isFinite(t))
      return {
        location: t
      };
    const i = U4.exec(e), r = i ? i[1] : e, l = i ? Number(i[2]) : 0;
    return this.configuration ? {
      location: this.configuration.getAttributeLocation(r) + l,
      name: r
    } : {
      location: -1
    };
  }
  _setAttribute(e, t) {
    if (t instanceof dr)
      this.setBuffer(e, t);
    else if (Array.isArray(t) && t.length && t[0] instanceof dr) {
      const i = t[0], r = t[1];
      this.setBuffer(e, i, r);
    } else if (ArrayBuffer.isView(t) || Array.isArray(t)) {
      const i = t;
      this.setConstant(e, i);
    } else if (t.buffer instanceof dr) {
      const i = t;
      this.setBuffer(e, i.buffer, i);
    } else
      throw new Error(z4);
  }
  _setConstantAttributes(e, t) {
    const i = Math.max(e | 0, t | 0);
    let r = this.values[0];
    ArrayBuffer.isView(r) && this._setConstantAttributeZero(r, i);
    for (let l = 1; l < this.vertexArrayObject.MAX_ATTRIBUTES; l++)
      r = this.values[l], ArrayBuffer.isView(r) && this._setConstantAttribute(l, r);
  }
  _setConstantAttributeZero(e, t) {
    if (Ka.isSupported(this.gl, {
      constantAttributeZero: !0
    })) {
      this._setConstantAttribute(0, e);
      return;
    }
    const i = this.vertexArrayObject.getConstantBuffer(t, e);
    this.vertexArrayObject.setBuffer(0, i, this.accessors[0]);
  }
  _setConstantAttribute(e, t) {
    Ka.setConstant(this.gl, e, t);
  }
  _updateDrawParams() {
    const e = {
      isIndexed: !1,
      isInstanced: !1,
      indexCount: 1 / 0,
      vertexCount: 1 / 0,
      instanceCount: 1 / 0
    };
    for (let t = 0; t < this.vertexArrayObject.MAX_ATTRIBUTES; t++)
      this._updateDrawParamsForLocation(e, t);
    return this.elements && (e.elementCount = this.elements.getElementCount(this.elements.accessor), e.isIndexed = !0, e.indexType = this.elementsAccessor.type || this.elements.accessor.type, e.indexOffset = this.elementsAccessor.offset || 0), e.indexCount === 1 / 0 && (e.indexCount = 0), e.vertexCount === 1 / 0 && (e.vertexCount = 0), e.instanceCount === 1 / 0 && (e.instanceCount = 0), e;
  }
  _updateDrawParamsForLocation(e, t) {
    const i = this.values[t], r = this.accessors[t];
    if (!i)
      return;
    const {
      divisor: l
    } = r, c = l > 0;
    if (e.isInstanced = e.isInstanced || c, i instanceof dr) {
      const a = i;
      if (c) {
        const g = a.getVertexCount(r);
        e.instanceCount = Math.min(e.instanceCount, g);
      } else {
        const g = a.getVertexCount(r);
        e.vertexCount = Math.min(e.vertexCount, g);
      }
    }
  }
  setElements() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Fn.deprecated("setElements", "setElementBuffer")(), this.setElementBuffer(e, t);
  }
}
function V4(n, e) {
  const {
    maxElts: t = 16,
    size: i = 1
  } = e;
  let r = "[";
  for (let c = 0; c < n.length && c < t; ++c)
    c > 0 && (r += ",".concat(c % i === 0 ? " " : "")), r += Pp(n[c], e);
  const l = n.length > t ? "..." : "]";
  return "".concat(r).concat(l);
}
function Pp(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = 1e-16, {
    isInteger: i = !1
  } = e;
  if (Array.isArray(n) || ArrayBuffer.isView(n))
    return V4(n, e);
  if (!Number.isFinite(n))
    return String(n);
  if (Math.abs(n) < t)
    return i ? "0" : "0.";
  if (i || Math.abs(n) > 100 && Math.abs(n) < 1e4)
    return n.toFixed(0);
  const r = n.toPrecision(2);
  return r.indexOf(".0") === r.length - 2 ? r.slice(0, -1) : r;
}
function Xx(n) {
  let {
    header: e = "Uniforms",
    program: t,
    uniforms: i,
    undefinedOnly: r = !1
  } = n;
  En(t);
  const l = ".*_.*", c = ".*Matrix", a = t._uniformSetters, g = {}, y = Object.keys(a).sort();
  let A = 0;
  for (const S of y)
    !S.match(l) && !S.match(c) && C0({
      table: g,
      header: e,
      uniforms: i,
      uniformName: S,
      undefinedOnly: r
    }) && A++;
  for (const S of y)
    S.match(c) && C0({
      table: g,
      header: e,
      uniforms: i,
      uniformName: S,
      undefinedOnly: r
    }) && A++;
  for (const S of y)
    g[S] || C0({
      table: g,
      header: e,
      uniforms: i,
      uniformName: S,
      undefinedOnly: r
    }) && A++;
  let C = 0;
  const I = {};
  if (!r)
    for (const S in i) {
      const F = i[S];
      g[S] || (C++, I[S] = {
        Type: "NOT USED: ".concat(F),
        [e]: Pp(F)
      });
    }
  return {
    table: g,
    count: A,
    unusedTable: I,
    unusedCount: C
  };
}
function C0(n) {
  let {
    table: e,
    header: t,
    uniforms: i,
    uniformName: r,
    undefinedOnly: l
  } = n;
  const c = i[r], a = q4(c);
  return !l || !a ? (e[r] = {
    [t]: a ? Pp(c) : "N/A",
    "Uniform Type": a ? c : "NOT PROVIDED"
  }, !0) : !1;
}
function q4(n) {
  return n != null;
}
function H4(n) {
  let {
    vertexArray: e,
    header: t = "Attributes"
  } = n;
  if (!e.configuration)
    return {};
  const i = {};
  e.elements && (i.ELEMENT_ARRAY_BUFFER = Yx(e, e.elements, null, t));
  const r = e.values;
  for (const l in r) {
    const c = e._getAttributeInfo(l);
    if (c) {
      let a = "".concat(l, ": ").concat(c.name);
      const g = e.accessors[c.location];
      g && (a = "".concat(l, ": ").concat(W4(c.name, g))), i[a] = Yx(e, r[l], g, t);
    }
  }
  return i;
}
function Yx(n, e, t, i) {
  const {
    gl: r
  } = n;
  if (!e)
    return {
      [i]: "null",
      "Format ": "N/A"
    };
  let l = "NOT PROVIDED", c = 1, a = 0, g = 0, y, A, C;
  if (t && (l = t.type, c = t.size, l = String(l).replace("Array", ""), y = l.indexOf("nt") !== -1), e instanceof dr) {
    const I = e, {
      data: S,
      changed: F
    } = I.getDebugData();
    A = F ? "*" : "", C = S, g = I.byteLength, a = g / S.BYTES_PER_ELEMENT / c;
    let U;
    if (t) {
      const V = t.divisor > 0;
      U = "".concat(V ? "I " : "P ", " ").concat(a, " (x").concat(c, "=").concat(g, " bytes ").concat(dh(r, l), ")");
    } else
      y = !0, U = "".concat(g, " bytes");
    return {
      [i]: "".concat(A).concat(Pp(C, {
        size: c,
        isInteger: y
      })),
      "Format ": U
    };
  }
  return C = e, c = e.length, l = String(e.constructor.name).replace("Array", ""), y = l.indexOf("nt") !== -1, {
    [i]: "".concat(Pp(C, {
      size: c,
      isInteger: y
    }), " (constant)"),
    "Format ": "".concat(c, "x").concat(l, " (constant)")
  };
}
function W4(n, e) {
  const {
    type: t,
    size: i
  } = e, r = KT(t, i);
  return r ? "".concat(n, " (").concat(r.name, ")") : n;
}
function Z4(n) {
  const e = {}, t = "Accessors for ".concat(n.id);
  for (const i of n.attributeInfos)
    if (i) {
      const r = Jx(i);
      e["in ".concat(r)] = {
        [t]: JSON.stringify(i.accessor)
      };
    }
  for (const i of n.varyingInfos)
    if (i) {
      const r = Jx(i);
      e["out ".concat(r)] = {
        [t]: JSON.stringify(i.accessor)
      };
    }
  return e;
}
function Jx(n) {
  const {
    type: e,
    size: t
  } = n.accessor, i = KT(e, t);
  return i ? "".concat(i.name, " ").concat(n.name) : n.name;
}
const Kx = Fu() && typeof document < "u";
let $4 = 0;
class X4 {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      onCreateContext: t = (V) => UT(V),
      onAddHTML: i = null,
      onInitialize: r = () => {
      },
      onRender: l = () => {
      },
      onFinalize: c = () => {
      },
      onError: a,
      gl: g = null,
      glOptions: y = {},
      debug: A = !1,
      createFramebuffer: C = !1,
      autoResizeViewport: I = !0,
      autoResizeDrawingBuffer: S = !0,
      stats: F = Gh.get("animation-loop-".concat($4++))
    } = e;
    let {
      useDevicePixels: U = !0
    } = e;
    "useDevicePixelRatio" in e && (Fn.deprecated("useDevicePixelRatio", "useDevicePixels")(), U = e.useDevicePixelRatio), this.props = {
      onCreateContext: t,
      onAddHTML: i,
      onInitialize: r,
      onRender: l,
      onFinalize: c,
      onError: a,
      gl: g,
      glOptions: y,
      debug: A,
      createFramebuffer: C
    }, this.gl = g, this.needsRedraw = null, this.timeline = null, this.stats = F, this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this._initialized = !1, this._running = !1, this._animationFrameId = null, this._nextFramePromise = null, this._resolveNextFrame = null, this._cpuStartTime = 0, this.setProps({
      autoResizeViewport: I,
      autoResizeDrawingBuffer: S,
      useDevicePixels: U
    }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._pageLoadPromise = null, this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
  }
  delete() {
    this.stop(), this._setDisplay(null);
  }
  setNeedsRedraw(e) {
    return En(typeof e == "string"), this.needsRedraw = this.needsRedraw || e, this;
  }
  setProps(e) {
    return "autoResizeViewport" in e && (this.autoResizeViewport = e.autoResizeViewport), "autoResizeDrawingBuffer" in e && (this.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer), "useDevicePixels" in e && (this.useDevicePixels = e.useDevicePixels), this;
  }
  start() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (this._running)
      return this;
    this._running = !0;
    const t = this._getPageLoadPromise().then(() => !this._running || this._initialized ? null : (this._createWebGLContext(e), this._createFramebuffer(), this._startEventHandling(), this._initializeCallbackData(), this._updateCallbackData(), this._resizeCanvasDrawingBuffer(), this._resizeViewport(), this._gpuTimeQuery = Mm.isSupported(this.gl, ["timers"]) ? new Mm(this.gl) : null, this._initialized = !0, this.onInitialize(this.animationProps))).then((i) => {
      this._running && (this._addCallbackData(i || {}), i !== !1 && this._startLoop());
    });
    return this.props.onError && t.catch(this.props.onError), this;
  }
  redraw() {
    return this.isContextLost() ? this : (this._beginTimers(), this._setupFrame(), this._updateCallbackData(), this._renderFrame(this.animationProps), this._clearNeedsRedraw(), this.offScreen && this.gl.commit && this.gl.commit(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endTimers(), this);
  }
  stop() {
    return this._running && (this._finalizeCallbackData(), this._cancelAnimationFrame(this._animationFrameId), this._nextFramePromise = null, this._resolveNextFrame = null, this._animationFrameId = null, this._running = !1), this;
  }
  attachTimeline(e) {
    return this.timeline = e, this.timeline;
  }
  detachTimeline() {
    this.timeline = null;
  }
  waitForRender() {
    return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
      this._resolveNextFrame = e;
    })), this._nextFramePromise;
  }
  async toDataURL() {
    return this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.gl.canvas.toDataURL();
  }
  isContextLost() {
    return this.gl.isContextLost();
  }
  onCreateContext() {
    return this.props.onCreateContext(...arguments);
  }
  onInitialize() {
    return this.props.onInitialize(...arguments);
  }
  onRender() {
    return this.props.onRender(...arguments);
  }
  onFinalize() {
    return this.props.onFinalize(...arguments);
  }
  getHTMLControlValue(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const i = document.getElementById(e);
    return i ? Number(i.value) : t;
  }
  setViewParameters() {
    return Fn.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")(), this;
  }
  _startLoop() {
    const e = () => {
      this._running && (this.redraw(), this._animationFrameId = this._requestAnimationFrame(e));
    };
    this._cancelAnimationFrame(this._animationFrameId), this._animationFrameId = this._requestAnimationFrame(e);
  }
  _getPageLoadPromise() {
    return this._pageLoadPromise || (this._pageLoadPromise = Kx ? new Promise((e, t) => {
      if (Kx && document.readyState === "complete") {
        e(document);
        return;
      }
      window.addEventListener("load", () => {
        e(document);
      });
    }) : Promise.resolve({})), this._pageLoadPromise;
  }
  _setDisplay(e) {
    this.display && (this.display.delete(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
  }
  _cancelAnimationFrame(e) {
    return this.display && this.display.cancelAnimationFrame ? this.display.cancelAnimationFrame(e) : nB(e);
  }
  _requestAnimationFrame(e) {
    if (this._running)
      return this.display && this.display.requestAnimationFrame ? this.display.requestAnimationFrame(e) : tB(e);
  }
  _renderFrame() {
    if (this.display) {
      this.display._renderFrame(...arguments);
      return;
    }
    this.onRender(...arguments);
  }
  _clearNeedsRedraw() {
    this.needsRedraw = null;
  }
  _setupFrame() {
    this._resizeCanvasDrawingBuffer(), this._resizeViewport(), this._resizeFramebuffer();
  }
  _initializeCallbackData() {
    this.animationProps = {
      gl: this.gl,
      stop: this.stop,
      canvas: this.gl.canvas,
      framebuffer: this.framebuffer,
      useDevicePixels: this.useDevicePixels,
      needsRedraw: null,
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,
      time: 0,
      _timeline: this.timeline,
      _loop: this,
      _animationLoop: this,
      _mousePosition: null
    };
  }
  _updateCallbackData() {
    const {
      width: e,
      height: t,
      aspect: i
    } = this._getSizeAndAspect();
    (e !== this.animationProps.width || t !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), i !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = t, this.animationProps.aspect = i, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime, this.animationProps._offScreen = this.offScreen;
  }
  _finalizeCallbackData() {
    this.onFinalize(this.animationProps);
  }
  _addCallbackData(e) {
    typeof e == "object" && e !== null && (this.animationProps = Object.assign({}, this.animationProps, e));
  }
  _createWebGLContext(e) {
    if (this.offScreen = e.canvas && typeof OffscreenCanvas < "u" && e.canvas instanceof OffscreenCanvas, e = Object.assign({}, e, this.props.glOptions), this.gl = this.props.gl ? ib(this.props.gl, e) : this.onCreateContext(e), !Qm(this.gl))
      throw new Error("AnimationLoop.onCreateContext - illegal context returned");
    GR(this.gl), this._createInfoDiv();
  }
  _createInfoDiv() {
    if (this.gl.canvas && this.props.onAddHTML) {
      const e = document.createElement("div");
      document.body.appendChild(e), e.style.position = "relative";
      const t = document.createElement("div");
      t.style.position = "absolute", t.style.left = "10px", t.style.bottom = "10px", t.style.width = "300px", t.style.background = "white", e.appendChild(this.gl.canvas), e.appendChild(t);
      const i = this.props.onAddHTML(t);
      i && (t.innerHTML = i);
    }
  }
  _getSizeAndAspect() {
    const e = this.gl.drawingBufferWidth, t = this.gl.drawingBufferHeight;
    let i = 1;
    const {
      canvas: r
    } = this.gl;
    return r && r.clientHeight ? i = r.clientWidth / r.clientHeight : e > 0 && t > 0 && (i = e / t), {
      width: e,
      height: t,
      aspect: i
    };
  }
  _resizeViewport() {
    this.autoResizeViewport && this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
  }
  _resizeCanvasDrawingBuffer() {
    this.autoResizeDrawingBuffer && ZR(this.gl, {
      useDevicePixels: this.useDevicePixels
    });
  }
  _createFramebuffer() {
    this.props.createFramebuffer && (this.framebuffer = new Vs(this.gl));
  }
  _resizeFramebuffer() {
    this.framebuffer && this.framebuffer.resize({
      width: this.gl.drawingBufferWidth,
      height: this.gl.drawingBufferHeight
    });
  }
  _beginTimers() {
    this.frameRate.timeEnd(), this.frameRate.timeStart(), this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint() && this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds()), this._gpuTimeQuery && this._gpuTimeQuery.beginTimeElapsedQuery(), this.cpuTime.timeStart();
  }
  _endTimers() {
    this.cpuTime.timeEnd(), this._gpuTimeQuery && this._gpuTimeQuery.end();
  }
  _startEventHandling() {
    const {
      canvas: e
    } = this.gl;
    e && (e.addEventListener("mousemove", this._onMousemove), e.addEventListener("mouseleave", this._onMouseleave));
  }
  _onMousemove(e) {
    this.animationProps._mousePosition = [e.offsetX, e.offsetY];
  }
  _onMouseleave(e) {
    this.animationProps._mousePosition = null;
  }
}
const Hp = "vs", lb = "fs";
function nl(n, e) {
  if (!n)
    throw new Error(e || "shadertools: assertion failed.");
}
const P0 = {
  number: {
    validate(n, e) {
      return Number.isFinite(n) && (!("max" in e) || n <= e.max) && (!("min" in e) || n >= e.min);
    }
  },
  array: {
    validate(n, e) {
      return Array.isArray(n) || ArrayBuffer.isView(n);
    }
  }
};
function Y4(n) {
  const e = {};
  for (const t in n) {
    const i = n[t], r = J4(i);
    e[t] = r;
  }
  return e;
}
function J4(n) {
  let e = Qx(n);
  return e === "object" ? n ? "type" in n ? Object.assign({}, n, P0[n.type]) : "value" in n ? (e = Qx(n.value), Object.assign({
    type: e
  }, n, P0[e])) : {
    type: "object",
    value: n
  } : {
    type: "object",
    value: null
  } : Object.assign({
    type: e,
    value: n
  }, P0[e]);
}
function Qx(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n) ? "array" : typeof n;
}
const K4 = "vs", Q4 = "fs";
class ew {
  constructor(e) {
    let {
      name: t,
      vs: i,
      fs: r,
      dependencies: l = [],
      uniforms: c,
      getUniforms: a,
      deprecations: g = [],
      defines: y = {},
      inject: A = {},
      vertexShader: C,
      fragmentShader: I
    } = e;
    nl(typeof t == "string"), this.name = t, this.vs = i || C, this.fs = r || I, this.getModuleUniforms = a, this.dependencies = l, this.deprecations = this._parseDeprecationDefinitions(g), this.defines = y, this.injections = eO(A), c && (this.uniforms = Y4(c));
  }
  getModuleSource(e) {
    let t;
    switch (e) {
      case K4:
        t = this.vs || "";
        break;
      case Q4:
        t = this.fs || "";
        break;
      default:
        nl(!1);
    }
    return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), `
`).concat(t, "// END MODULE_").concat(this.name, `

`);
  }
  getUniforms(e, t) {
    return this.getModuleUniforms ? this.getModuleUniforms(e, t) : this.uniforms ? this._defaultGetUniforms(e) : {};
  }
  getDefines() {
    return this.defines;
  }
  checkDeprecations(e, t) {
    this.deprecations.forEach((i) => {
      i.regex.test(e) && (i.deprecated ? t.deprecated(i.old, i.new)() : t.removed(i.old, i.new)());
    });
  }
  _parseDeprecationDefinitions(e) {
    return e.forEach((t) => {
      switch (t.type) {
        case "function":
          t.regex = new RegExp("\\b".concat(t.old, "\\("));
          break;
        default:
          t.regex = new RegExp("".concat(t.type, " ").concat(t.old, ";"));
      }
    }), e;
  }
  _defaultGetUniforms() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = {}, i = this.uniforms;
    for (const r in i) {
      const l = i[r];
      r in e && !l.private ? (l.validate && nl(l.validate(e[r], l), "".concat(this.name, ": invalid ").concat(r)), t[r] = e[r]) : t[r] = l.value;
    }
    return t;
  }
}
function eO(n) {
  const e = {
    vs: {},
    fs: {}
  };
  for (const t in n) {
    let i = n[t];
    const r = t.slice(0, 2);
    typeof i == "string" && (i = {
      order: 0,
      injection: i
    }), e[r][t] = i;
  }
  return e;
}
function tO(n) {
  return nO(nE(n));
}
function nO(n) {
  const e = {}, t = {};
  return tE({
    modules: n,
    level: 0,
    moduleMap: e,
    moduleDepth: t
  }), Object.keys(t).sort((i, r) => t[r] - t[i]).map((i) => e[i]);
}
function tE(n) {
  let {
    modules: e,
    level: t,
    moduleMap: i,
    moduleDepth: r
  } = n;
  if (t >= 5)
    throw new Error("Possible loop in shader dependency graph");
  for (const l of e)
    i[l.name] = l, (r[l.name] === void 0 || r[l.name] < t) && (r[l.name] = t);
  for (const l of e)
    l.dependencies && tE({
      modules: l.dependencies,
      level: t + 1,
      moduleMap: i,
      moduleDepth: r
    });
}
function nE(n, e) {
  return n.map((t) => (t instanceof ew || (nl(typeof t != "string", "Shader module use by name is deprecated. Import shader module '".concat(t, "' and use it directly.")), nl(t.name, "shader module has no name"), t = new ew(t), t.dependencies = nE(t.dependencies)), t));
}
function iO() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const e = typeof window < "u" ? window.navigator || {} : {}, t = n.userAgent || e.userAgent || "", i = t.indexOf("MSIE ") !== -1, r = t.indexOf("Trident/") !== -1;
  return i || r;
}
const rO = 7936, sO = 7937, oO = 7938, aO = 35724, cb = {
  GLSL_FRAG_DATA: ["WEBGL_draw_buffers", !0],
  GLSL_FRAG_DEPTH: ["EXT_frag_depth", !0],
  GLSL_DERIVATIVES: ["OES_standard_derivatives", !0],
  GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", !0]
}, Nh = {};
Object.keys(cb).forEach((n) => {
  Nh[n] = n;
});
function lO(n) {
  return typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? !0 : !!(n && n._version === 2);
}
function cO(n) {
  const e = n.getExtension("WEBGL_debug_renderer_info"), t = n.getParameter(e && e.UNMASKED_VENDOR_WEBGL || rO), i = n.getParameter(e && e.UNMASKED_RENDERER_WEBGL || sO);
  return {
    gpuVendor: uO(t, i),
    vendor: t,
    renderer: i,
    version: n.getParameter(oO),
    shadingLanguageVersion: n.getParameter(aO)
  };
}
function uO(n, e) {
  return n.match(/NVIDIA/i) || e.match(/NVIDIA/i) ? "NVIDIA" : n.match(/INTEL/i) || e.match(/INTEL/i) ? "INTEL" : n.match(/AMD/i) || e.match(/AMD/i) || n.match(/ATI/i) || e.match(/ATI/i) ? "AMD" : "UNKNOWN GPU";
}
const I0 = {};
function tw(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const i = cb[e];
  if (nl(i, e), !iO(t))
    return !0;
  if (e in I0)
    return I0[e];
  const r = i[0], l = t.behavior || "enable", c = "#extension GL_".concat(r, " : ").concat(l, `
void main(void) {}`), a = n.createShader(35633);
  n.shaderSource(a, c), n.compileShader(a);
  const g = n.getShaderParameter(a, 35713);
  return n.deleteShader(a), I0[e] = g, g;
}
function hO(n, e) {
  const t = cb[e];
  nl(t, e);
  const i = lO(n) && t[1] || t[0], r = typeof i == "string" ? !!n.getExtension(i) : i;
  return nl(r === !1 || r === !0), r;
}
function Ig(n, e) {
  return e = Array.isArray(e) ? e : [e], e.every((t) => hO(n, t));
}
function dO(n) {
  switch (cO(n).gpuVendor.toLowerCase()) {
    case "nvidia":
      return `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
    case "intel":
      return `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    case "amd":
      return `#define AMD_GPU
`;
    default:
      return `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
  }
}
function fO(n, e, t) {
  let i = `#if (__VERSION__ > 120)

# define FEATURE_GLSL_DERIVATIVES
# define FEATURE_GLSL_DRAW_BUFFERS
# define FEATURE_GLSL_FRAG_DEPTH
# define FEATURE_GLSL_TEXTURE_LOD

// DEPRECATED FLAGS, remove in v9
# define FRAG_DEPTH
# define DERIVATIVES
# define DRAW_BUFFERS
# define TEXTURE_LOD

#endif // __VERSION
`;
  return Ig(n, Nh.GLSL_FRAG_DEPTH) && (i += `
// FRAG_DEPTH => gl_FragDepth is available
#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
# define FEATURE_GLSL_FRAG_DEPTH
# define FRAG_DEPTH
# define gl_FragDepth gl_FragDepthEXT
#endif
`), Ig(n, Nh.GLSL_DERIVATIVES) && tw(n, Nh.GLSL_DERIVATIVES) && (i += `
// DERIVATIVES => dxdF, dxdY and fwidth are available
#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
# define FEATURE_GLSL_DERIVATIVES
# define DERIVATIVES
#endif
`), Ig(n, Nh.GLSL_FRAG_DATA) && tw(n, Nh.GLSL_FRAG_DATA, {
    behavior: "require"
  }) && (i += `
// DRAW_BUFFERS => gl_FragData[] is available
#ifdef GL_EXT_draw_buffers
#extension GL_EXT_draw_buffers : require
#define FEATURE_GLSL_DRAW_BUFFERS
#define DRAW_BUFFERS
#endif
`), Ig(n, Nh.GLSL_TEXTURE_LOD) && (i += `// TEXTURE_LOD => texture2DLod etc are available
#ifdef GL_EXT_shader_texture_lod
#extension GL_EXT_shader_texture_lod : enable

# define FEATURE_GLSL_TEXTURE_LOD
# define TEXTURE_LOD

#endif
`), i;
}
const pO = `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`, gO = `#ifdef MODULE_MATERIAL
  gl_FragColor = material_filterColor(gl_FragColor);
#endif

#ifdef MODULE_LIGHTING
  gl_FragColor = lighting_filterColor(gl_FragColor);
#endif

#ifdef MODULE_FOG
  gl_FragColor = fog_filterColor(gl_FragColor);
#endif

#ifdef MODULE_PICKING
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`, mO = {
  [Hp]: pO,
  [lb]: gO
}, rm = "__LUMA_INJECT_DECLARATIONS__", nw = /void\s+main\s*\([^)]*\)\s*\{\n?/, iw = /}\n?[^{}]*$/, M0 = [];
function rw(n, e, t) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  const r = e === Hp;
  for (const l in t) {
    const c = t[l];
    c.sort((g, y) => g.order - y.order), M0.length = c.length;
    for (let g = 0, y = c.length; g < y; ++g)
      M0[g] = c[g].injection;
    const a = "".concat(M0.join(`
`), `
`);
    switch (l) {
      case "vs:#decl":
        r && (n = n.replace(rm, a));
        break;
      case "vs:#main-start":
        r && (n = n.replace(nw, (g) => g + a));
        break;
      case "vs:#main-end":
        r && (n = n.replace(iw, (g) => a + g));
        break;
      case "fs:#decl":
        r || (n = n.replace(rm, a));
        break;
      case "fs:#main-start":
        r || (n = n.replace(nw, (g) => g + a));
        break;
      case "fs:#main-end":
        r || (n = n.replace(iw, (g) => a + g));
        break;
      default:
        n = n.replace(l, (g) => g + a);
    }
  }
  return n = n.replace(rm, ""), i && (n = n.replace(/\}\s*$/, (l) => l + mO[e])), n;
}
function Wy(n) {
  const e = {};
  return nl(Array.isArray(n) && n.length > 1), n.forEach((t) => {
    for (const i in t)
      e[i] = e[i] ? "".concat(e[i], `
`).concat(t[i]) : t[i];
  }), e;
}
function lf(n) {
  return new RegExp("\\b".concat(n, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
}
const iE = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, `#version 300 es
`], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]], _O = [...iE, [lf("attribute"), "in $1"], [lf("varying"), "out $1"]], yO = [...iE, [lf("varying"), "in $1"]], rE = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]], bO = [...rE, [lf("in"), "attribute $1"], [lf("out"), "varying $1"]], vO = [...rE, [lf("in"), "varying $1"]], Zy = "gl_FragColor", $y = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/, xO = /void\s+main\s*\([^)]*\)\s*\{\n?/;
function wO(n, e, t) {
  switch (e) {
    case 300:
      return t ? Lm(n, _O) : AO(n);
    case 100:
      return t ? Lm(n, bO) : TO(n);
    default:
      throw new Error("unknown GLSL version ".concat(e));
  }
}
function Lm(n, e) {
  for (const [t, i] of e)
    n = n.replace(t, i);
  return n;
}
function AO(n) {
  n = Lm(n, yO);
  const e = n.match($y);
  if (e) {
    const t = e[1];
    n = n.replace(new RegExp("\\b".concat(Zy, "\\b"), "g"), t);
  } else {
    const t = "fragmentColor";
    n = n.replace(xO, (i) => "out vec4 ".concat(t, `;
`).concat(i)).replace(new RegExp("\\b".concat(Zy, "\\b"), "g"), t);
  }
  return n;
}
function TO(n) {
  n = Lm(n, vO);
  const e = n.match($y);
  if (e) {
    const t = e[1];
    n = n.replace($y, "").replace(new RegExp("\\b".concat(t, "\\b"), "g"), Zy);
  }
  return n;
}
const EO = `

`.concat(rm, `

`), sE = {
  [Hp]: "vertex",
  [lb]: "fragment"
}, SO = `precision highp float;

`;
function CO(n, e) {
  const {
    vs: t,
    fs: i
  } = e, r = tO(e.modules || []);
  return {
    gl: n,
    vs: sw(n, Object.assign({}, e, {
      source: t,
      type: Hp,
      modules: r
    })),
    fs: sw(n, Object.assign({}, e, {
      source: i,
      type: lb,
      modules: r
    })),
    getUniforms: PO(r)
  };
}
function sw(n, e) {
  let {
    id: t,
    source: i,
    type: r,
    modules: l,
    defines: c = {},
    hookFunctions: a = [],
    inject: g = {},
    transpileToGLSL100: y = !1,
    prologue: A = !0,
    log: C
  } = e;
  nl(typeof i == "string", "shader source must be a string");
  const I = r === Hp, S = i.split(`
`);
  let F = 100, U = "", V = i;
  S[0].indexOf("#version ") === 0 ? (F = 300, U = S[0], V = S.slice(1).join(`
`)) : U = "#version ".concat(F);
  const W = {};
  l.forEach((Te) => {
    Object.assign(W, Te.getDefines());
  }), Object.assign(W, c);
  let X = A ? "".concat(U, `
`).concat(MO({
    id: t,
    source: i,
    type: r
  }), `
`).concat(IO({
    type: r
  }), `
`).concat(dO(n), `
`).concat(fO(n), `
`).concat(LO(W), `
`).concat(I ? "" : SO, `
`) : "".concat(U, `
`);
  const de = BO(a), ie = {}, fe = {}, Ae = {};
  for (const Te in g) {
    const me = typeof g[Te] == "string" ? {
      injection: g[Te],
      order: 0
    } : g[Te], Ge = Te.match(/^(v|f)s:(#)?([\w-]+)$/);
    if (Ge) {
      const ke = Ge[2], pe = Ge[3];
      ke ? pe === "decl" ? fe[Te] = [me] : Ae[Te] = [me] : ie[Te] = [me];
    } else
      Ae[Te] = [me];
  }
  for (const Te of l) {
    C && Te.checkDeprecations(V, C);
    const me = Te.getModuleSource(r, F);
    X += me;
    const Ge = Te.injections[r];
    for (const ke in Ge) {
      const pe = ke.match(/^(v|f)s:#([\w-]+)$/);
      if (pe) {
        const De = pe[2] === "decl" ? fe : Ae;
        De[ke] = De[ke] || [], De[ke].push(Ge[ke]);
      } else
        ie[ke] = ie[ke] || [], ie[ke].push(Ge[ke]);
    }
  }
  return X += EO, X = rw(X, r, fe), X += RO(de[r], ie), X += V, X = rw(X, r, Ae), X = wO(X, y ? 100 : F, I), X;
}
function PO(n) {
  return function(t) {
    const i = {};
    for (const r of n) {
      const l = r.getUniforms(t, i);
      Object.assign(i, l);
    }
    return i;
  };
}
function IO(n) {
  let {
    type: e
  } = n;
  return `
#define SHADER_TYPE_`.concat(sE[e].toUpperCase(), `
`);
}
function MO(n) {
  let {
    id: e,
    source: t,
    type: i
  } = n;
  return e && typeof e == "string" && t.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME `.concat(e, "_").concat(sE[i], `

`) : "";
}
function LO() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = 0, t = "";
  for (const i in n) {
    e === 0 && (t += `
// APPLICATION DEFINES
`), e++;
    const r = n[i];
    (r || Number.isFinite(r)) && (t += "#define ".concat(i.toUpperCase(), " ").concat(n[i], `
`));
  }
  return e === 0 && (t += `
`), t;
}
function RO(n, e) {
  let t = "";
  for (const i in n) {
    const r = n[i];
    if (t += "void ".concat(r.signature, ` {
`), r.header && (t += "  ".concat(r.header)), e[i]) {
      const l = e[i];
      l.sort((c, a) => c.order - a.order);
      for (const c of l)
        t += "  ".concat(c.injection, `
`);
    }
    r.footer && (t += "  ".concat(r.footer)), t += `}
`;
  }
  return t;
}
function BO(n) {
  const e = {
    vs: {},
    fs: {}
  };
  return n.forEach((t) => {
    let i;
    typeof t != "string" ? (i = t, t = i.hook) : i = {}, t = t.trim();
    const [r, l] = t.split(":"), c = t.replace(/\(.+/, "");
    e[r][c] = Object.assign(i, {
      signature: l
    });
  }), e;
}
const OO = "void main() {gl_FragColor = vec4(0);}", oE = `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`, DO = `#version 300 es
`.concat(oE);
function aE(n, e) {
  e = Array.isArray(e) ? e : [e];
  const t = n.replace(/^\s+/, "").split(/\s+/), [i, r, l] = t;
  if (!e.includes(i) || !r || !l)
    return null;
  const c = l.split(";")[0];
  return {
    qualifier: i,
    type: r,
    name: c
  };
}
function lE() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    version: e = 100,
    input: t,
    inputType: i,
    output: r
  } = n;
  if (!t)
    return e === 300 ? DO : e > 300 ? "#version ".concat(e, `
`).concat(oE) : OO;
  const l = kO(t, i);
  return e >= 300 ? "#version ".concat(e, " ").concat(e === 300 ? "es" : "", `
in `).concat(i, " ").concat(t, `;
out vec4 `).concat(r, `;
void main() {
  `).concat(r, " = ").concat(l, `;
}`) : "varying ".concat(i, " ").concat(t, `;
void main() {
  gl_FragColor = `).concat(l, `;
}`);
}
function FO(n) {
  switch (n) {
    case "float":
      return "x";
    case "vec2":
      return "xy";
    case "vec3":
      return "xyz";
    case "vec4":
      return "xyzw";
    default:
      return nl(!1), null;
  }
}
function NO(n) {
  switch (n) {
    case "float":
      return 1;
    case "vec2":
      return 2;
    case "vec3":
      return 3;
    case "vec4":
      return 4;
    default:
      return nl(!1), null;
  }
}
function kO(n, e) {
  switch (e) {
    case "float":
      return "vec4(".concat(n, ", 0.0, 0.0, 1.0)");
    case "vec2":
      return "vec4(".concat(n, ", 0.0, 1.0)");
    case "vec3":
      return "vec4(".concat(n, ", 1.0)");
    case "vec4":
      return n;
    default:
      return nl(!1), null;
  }
}
const zO = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`, UO = {
  name: "fp32",
  vs: zO,
  fs: null
};
function gc(n, e) {
  if (!n)
    throw new Error("math.gl assertion ".concat(e));
}
const jO = 1 / Math.PI * 180, GO = 1 / 180 * Math.PI, Gs = {
  EPSILON: 1e-12,
  debug: !1,
  precision: 4,
  printTypes: !1,
  printDegrees: !1,
  printRowMajor: !0
};
function VO(n) {
  let {
    precision: e = Gs.precision
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return n = ZO(n), "".concat(parseFloat(n.toPrecision(e)));
}
function mh(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function qO(n) {
  return WO(n);
}
function HO(n) {
  return Cu(n);
}
function WO(n, e) {
  return ub(n, (t) => t * GO, e);
}
function Cu(n, e) {
  return ub(n, (t) => t * jO, e);
}
function Pu(n, e, t) {
  return ub(n, (i) => Math.max(e, Math.min(t, i)));
}
function Rm(n, e, t) {
  return mh(n) ? n.map((i, r) => Rm(i, e[r], t)) : t * e + (1 - t) * n;
}
function bc(n, e, t) {
  const i = Gs.EPSILON;
  t && (Gs.EPSILON = t);
  try {
    if (n === e)
      return !0;
    if (mh(n) && mh(e)) {
      if (n.length !== e.length)
        return !1;
      for (let r = 0; r < n.length; ++r)
        if (!bc(n[r], e[r]))
          return !1;
      return !0;
    }
    return n && n.equals ? n.equals(e) : e && e.equals ? e.equals(n) : typeof n == "number" && typeof e == "number" ? Math.abs(n - e) <= Gs.EPSILON * Math.max(1, Math.abs(n), Math.abs(e)) : !1;
  } finally {
    Gs.EPSILON = i;
  }
}
function ZO(n) {
  return Math.round(n / Gs.EPSILON) * Gs.EPSILON;
}
function $O(n) {
  return n.clone ? n.clone() : new Array(n.length);
}
function ub(n, e, t) {
  if (mh(n)) {
    const i = n;
    t = t || $O(i);
    for (let r = 0; r < t.length && r < i.length; ++r)
      t[r] = e(n[r], r, t);
    return t;
  }
  return e(n);
}
function XO(n) {
  function e() {
    var t = Reflect.construct(n, Array.from(arguments));
    return Object.setPrototypeOf(t, Object.getPrototypeOf(this)), t;
  }
  return e.prototype = Object.create(n.prototype, {
    constructor: {
      value: n,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }), Object.setPrototypeOf ? Object.setPrototypeOf(e, n) : e.__proto__ = n, e;
}
class hb extends XO(Array) {
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = e[i + t];
    return this.check();
  }
  toArray() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    for (let i = 0; i < this.ELEMENTS; ++i)
      e[t + i] = this[i];
    return e;
  }
  from(e) {
    return Array.isArray(e) ? this.copy(e) : this.fromObject(e);
  }
  to(e) {
    return e === this ? this : mh(e) ? this.toArray(e) : this.toObject(e);
  }
  toTarget(e) {
    return e ? this.to(e) : this;
  }
  toFloat32Array() {
    return new Float32Array(this);
  }
  toString() {
    return this.formatString(Gs);
  }
  formatString(e) {
    let t = "";
    for (let i = 0; i < this.ELEMENTS; ++i)
      t += (i > 0 ? ", " : "") + VO(this[i], e);
    return "".concat(e.printTypes ? this.constructor.name : "", "[").concat(t, "]");
  }
  equals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (!bc(this[t], e[t]))
        return !1;
    return !0;
  }
  exactEquals(e) {
    if (!e || this.length !== e.length)
      return !1;
    for (let t = 0; t < this.ELEMENTS; ++t)
      if (this[t] !== e[t])
        return !1;
    return !0;
  }
  negate() {
    for (let e = 0; e < this.ELEMENTS; ++e)
      this[e] = -this[e];
    return this.check();
  }
  lerp(e, t, i) {
    if (i === void 0)
      return this.lerp(this, e, t);
    for (let r = 0; r < this.ELEMENTS; ++r) {
      const l = e[r];
      this[r] = l + i * (t[r] - l);
    }
    return this.check();
  }
  min(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.min(e[t], this[t]);
    return this.check();
  }
  max(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = Math.max(e[t], this[t]);
    return this.check();
  }
  clamp(e, t) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = Math.min(Math.max(this[i], e[i]), t[i]);
    return this.check();
  }
  add() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    for (const r of t)
      for (let l = 0; l < this.ELEMENTS; ++l)
        this[l] += r[l];
    return this.check();
  }
  subtract() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    for (const r of t)
      for (let l = 0; l < this.ELEMENTS; ++l)
        this[l] -= r[l];
    return this.check();
  }
  scale(e) {
    if (typeof e == "number")
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] *= e;
    else
      for (let t = 0; t < this.ELEMENTS && t < e.length; ++t)
        this[t] *= e[t];
    return this.check();
  }
  multiplyByScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  check() {
    if (Gs.debug && !this.validate())
      throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
    return this;
  }
  validate() {
    let e = this.length === this.ELEMENTS;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e = e && Number.isFinite(this[t]);
    return e;
  }
  sub(e) {
    return this.subtract(e);
  }
  setScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] = e;
    return this.check();
  }
  addScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] += e;
    return this.check();
  }
  subScalar(e) {
    return this.addScalar(-e);
  }
  multiplyScalar(e) {
    for (let t = 0; t < this.ELEMENTS; ++t)
      this[t] *= e;
    return this.check();
  }
  divideScalar(e) {
    return this.multiplyByScalar(1 / e);
  }
  clampScalar(e, t) {
    for (let i = 0; i < this.ELEMENTS; ++i)
      this[i] = Math.min(Math.max(this[i], e), t);
    return this.check();
  }
  get elements() {
    return this;
  }
}
function YO(n, e) {
  if (n.length !== e)
    return !1;
  for (let t = 0; t < n.length; ++t)
    if (!Number.isFinite(n[t]))
      return !1;
  return !0;
}
function Yi(n) {
  if (!Number.isFinite(n))
    throw new Error("Invalid number ".concat(n));
  return n;
}
function bp(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  if (Gs.debug && !YO(n, e))
    throw new Error("math.gl: ".concat(t, " some fields set to invalid numbers'"));
  return n;
}
class db extends hb {
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Yi(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Yi(e);
  }
  len() {
    return Math.sqrt(this.lengthSquared());
  }
  magnitude() {
    return this.len();
  }
  lengthSquared() {
    let e = 0;
    for (let t = 0; t < this.ELEMENTS; ++t)
      e += this[t] * this[t];
    return e;
  }
  magnitudeSquared() {
    return this.lengthSquared();
  }
  distance(e) {
    return Math.sqrt(this.distanceSquared(e));
  }
  distanceSquared(e) {
    let t = 0;
    for (let i = 0; i < this.ELEMENTS; ++i) {
      const r = this[i] - e[i];
      t += r * r;
    }
    return Yi(t);
  }
  dot(e) {
    let t = 0;
    for (let i = 0; i < this.ELEMENTS; ++i)
      t += this[i] * e[i];
    return Yi(t);
  }
  normalize() {
    const e = this.magnitude();
    if (e !== 0)
      for (let t = 0; t < this.ELEMENTS; ++t)
        this[t] /= e;
    return this.check();
  }
  multiply() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    for (const r of t)
      for (let l = 0; l < this.ELEMENTS; ++l)
        this[l] *= r[l];
    return this.check();
  }
  divide() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    for (const r of t)
      for (let l = 0; l < this.ELEMENTS; ++l)
        this[l] /= r[l];
    return this.check();
  }
  lengthSq() {
    return this.lengthSquared();
  }
  distanceTo(e) {
    return this.distance(e);
  }
  distanceToSquared(e) {
    return this.distanceSquared(e);
  }
  getComponent(e) {
    return gc(e >= 0 && e < this.ELEMENTS, "index is out of range"), Yi(this[e]);
  }
  setComponent(e, t) {
    return gc(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = t, this.check();
  }
  addVectors(e, t) {
    return this.copy(e).add(t);
  }
  subVectors(e, t) {
    return this.copy(e).subtract(t);
  }
  multiplyVectors(e, t) {
    return this.copy(e).multiply(t);
  }
  addScaledVector(e, t) {
    return this.add(new this.constructor(e).multiplyScalar(t));
  }
}
var vp = 1e-6, vc = typeof Float32Array < "u" ? Float32Array : Array;
Math.hypot || (Math.hypot = function() {
  for (var n = 0, e = arguments.length; e--; )
    n += arguments[e] * arguments[e];
  return Math.sqrt(n);
});
function JO() {
  var n = new vc(2);
  return vc != Float32Array && (n[0] = 0, n[1] = 0), n;
}
function ow(n, e, t) {
  return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n;
}
function KO(n, e) {
  return n[0] = -e[0], n[1] = -e[1], n;
}
function cE(n, e, t, i) {
  var r = e[0], l = e[1];
  return n[0] = r + i * (t[0] - r), n[1] = l + i * (t[1] - l), n;
}
function QO(n, e, t) {
  var i = e[0], r = e[1];
  return n[0] = t[0] * i + t[2] * r, n[1] = t[1] * i + t[3] * r, n;
}
function e6(n, e, t) {
  var i = e[0], r = e[1];
  return n[0] = t[0] * i + t[2] * r + t[4], n[1] = t[1] * i + t[3] * r + t[5], n;
}
function uE(n, e, t) {
  var i = e[0], r = e[1];
  return n[0] = t[0] * i + t[3] * r + t[6], n[1] = t[1] * i + t[4] * r + t[7], n;
}
function hE(n, e, t) {
  var i = e[0], r = e[1];
  return n[0] = t[0] * i + t[4] * r + t[12], n[1] = t[1] * i + t[5] * r + t[13], n;
}
(function() {
  var n = JO();
  return function(e, t, i, r, l, c) {
    var a, g;
    for (t || (t = 2), i || (i = 0), r ? g = Math.min(r * t + i, e.length) : g = e.length, a = i; a < g; a += t)
      n[0] = e[a], n[1] = e[a + 1], l(n, n, c), e[a] = n[0], e[a + 1] = n[1];
    return e;
  };
})();
function dE(n, e, t) {
  const i = e[0], r = e[1], l = t[3] * i + t[7] * r || 1;
  return n[0] = (t[0] * i + t[4] * r) / l, n[1] = (t[1] * i + t[5] * r) / l, n;
}
function fE(n, e, t) {
  const i = e[0], r = e[1], l = e[2], c = t[3] * i + t[7] * r + t[11] * l || 1;
  return n[0] = (t[0] * i + t[4] * r + t[8] * l) / c, n[1] = (t[1] * i + t[5] * r + t[9] * l) / c, n[2] = (t[2] * i + t[6] * r + t[10] * l) / c, n;
}
function t6(n, e, t) {
  const i = e[0], r = e[1];
  return n[0] = t[0] * i + t[2] * r, n[1] = t[1] * i + t[3] * r, n[2] = e[2], n;
}
function n6(n, e, t) {
  const i = e[0], r = e[1];
  return n[0] = t[0] * i + t[2] * r, n[1] = t[1] * i + t[3] * r, n[2] = e[2], n[3] = e[3], n;
}
function pE(n, e, t) {
  const i = e[0], r = e[1], l = e[2];
  return n[0] = t[0] * i + t[3] * r + t[6] * l, n[1] = t[1] * i + t[4] * r + t[7] * l, n[2] = t[2] * i + t[5] * r + t[8] * l, n[3] = e[3], n;
}
class fb extends db {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    super(2), mh(e) && arguments.length === 1 ? this.copy(e) : (Gs.debug && (Yi(e), Yi(t)), this[0] = e, this[1] = t);
  }
  set(e, t) {
    return this[0] = e, this[1] = t, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this.check();
  }
  fromObject(e) {
    return Gs.debug && (Yi(e.x), Yi(e.y)), this[0] = e.x, this[1] = e.y, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e;
  }
  get ELEMENTS() {
    return 2;
  }
  horizontalAngle() {
    return Math.atan2(this.y, this.x);
  }
  verticalAngle() {
    return Math.atan2(this.x, this.y);
  }
  transform(e) {
    return this.transformAsPoint(e);
  }
  transformAsPoint(e) {
    return hE(this, this, e), this.check();
  }
  transformAsVector(e) {
    return dE(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return uE(this, this, e), this.check();
  }
  transformByMatrix2x3(e) {
    return e6(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return QO(this, this, e), this.check();
  }
}
function gE() {
  var n = new vc(3);
  return vc != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n;
}
function mE(n) {
  var e = n[0], t = n[1], i = n[2];
  return Math.hypot(e, t, i);
}
function aw(n, e, t) {
  var i = new vc(3);
  return i[0] = n, i[1] = e, i[2] = t, i;
}
function i6(n, e, t) {
  return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n;
}
function r6(n, e) {
  return n[0] = -e[0], n[1] = -e[1], n[2] = -e[2], n;
}
function s6(n, e) {
  var t = e[0], i = e[1], r = e[2], l = t * t + i * i + r * r;
  return l > 0 && (l = 1 / Math.sqrt(l)), n[0] = e[0] * l, n[1] = e[1] * l, n[2] = e[2] * l, n;
}
function pb(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2];
}
function sm(n, e, t) {
  var i = e[0], r = e[1], l = e[2], c = t[0], a = t[1], g = t[2];
  return n[0] = r * g - l * a, n[1] = l * c - i * g, n[2] = i * a - r * c, n;
}
function gb(n, e, t) {
  var i = e[0], r = e[1], l = e[2], c = t[3] * i + t[7] * r + t[11] * l + t[15];
  return c = c || 1, n[0] = (t[0] * i + t[4] * r + t[8] * l + t[12]) / c, n[1] = (t[1] * i + t[5] * r + t[9] * l + t[13]) / c, n[2] = (t[2] * i + t[6] * r + t[10] * l + t[14]) / c, n;
}
function _E(n, e, t) {
  var i = e[0], r = e[1], l = e[2];
  return n[0] = i * t[0] + r * t[3] + l * t[6], n[1] = i * t[1] + r * t[4] + l * t[7], n[2] = i * t[2] + r * t[5] + l * t[8], n;
}
function yE(n, e, t) {
  var i = t[0], r = t[1], l = t[2], c = t[3], a = e[0], g = e[1], y = e[2], A = r * y - l * g, C = l * a - i * y, I = i * g - r * a, S = r * I - l * C, F = l * A - i * I, U = i * C - r * A, V = c * 2;
  return A *= V, C *= V, I *= V, S *= 2, F *= 2, U *= 2, n[0] = a + A + S, n[1] = g + C + F, n[2] = y + I + U, n;
}
function o6(n, e, t, i) {
  var r = [], l = [];
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], l[0] = r[0], l[1] = r[1] * Math.cos(i) - r[2] * Math.sin(i), l[2] = r[1] * Math.sin(i) + r[2] * Math.cos(i), n[0] = l[0] + t[0], n[1] = l[1] + t[1], n[2] = l[2] + t[2], n;
}
function a6(n, e, t, i) {
  var r = [], l = [];
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], l[0] = r[2] * Math.sin(i) + r[0] * Math.cos(i), l[1] = r[1], l[2] = r[2] * Math.cos(i) - r[0] * Math.sin(i), n[0] = l[0] + t[0], n[1] = l[1] + t[1], n[2] = l[2] + t[2], n;
}
function l6(n, e, t, i) {
  var r = [], l = [];
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], l[0] = r[0] * Math.cos(i) - r[1] * Math.sin(i), l[1] = r[0] * Math.sin(i) + r[1] * Math.cos(i), l[2] = r[2], n[0] = l[0] + t[0], n[1] = l[1] + t[1], n[2] = l[2] + t[2], n;
}
function c6(n, e) {
  var t = n[0], i = n[1], r = n[2], l = e[0], c = e[1], a = e[2], g = Math.sqrt(t * t + i * i + r * r), y = Math.sqrt(l * l + c * c + a * a), A = g * y, C = A && pb(n, e) / A;
  return Math.acos(Math.min(Math.max(C, -1), 1));
}
var u6 = i6, h6 = mE;
(function() {
  var n = gE();
  return function(e, t, i, r, l, c) {
    var a, g;
    for (t || (t = 3), i || (i = 0), r ? g = Math.min(r * t + i, e.length) : g = e.length, a = i; a < g; a += t)
      n[0] = e[a], n[1] = e[a + 1], n[2] = e[a + 2], l(n, n, c), e[a] = n[0], e[a + 1] = n[1], e[a + 2] = n[2];
    return e;
  };
})();
const L0 = [0, 0, 0];
let Mg;
class Tt extends db {
  static get ZERO() {
    return Mg || (Mg = new Tt(0, 0, 0), Object.freeze(Mg)), Mg;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    super(-0, -0, -0), arguments.length === 1 && mh(e) ? this.copy(e) : (Gs.debug && (Yi(e), Yi(t), Yi(i)), this[0] = e, this[1] = t, this[2] = i);
  }
  set(e, t, i) {
    return this[0] = e, this[1] = t, this[2] = i, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
  }
  fromObject(e) {
    return Gs.debug && (Yi(e.x), Yi(e.y), Yi(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e;
  }
  get ELEMENTS() {
    return 3;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Yi(e);
  }
  angle(e) {
    return c6(this, e);
  }
  cross(e) {
    return sm(this, this, e), this.check();
  }
  rotateX(e) {
    let {
      radians: t,
      origin: i = L0
    } = e;
    return o6(this, this, i, t), this.check();
  }
  rotateY(e) {
    let {
      radians: t,
      origin: i = L0
    } = e;
    return a6(this, this, i, t), this.check();
  }
  rotateZ(e) {
    let {
      radians: t,
      origin: i = L0
    } = e;
    return l6(this, this, i, t), this.check();
  }
  transform(e) {
    return this.transformAsPoint(e);
  }
  transformAsPoint(e) {
    return gb(this, this, e), this.check();
  }
  transformAsVector(e) {
    return fE(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return _E(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return t6(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return yE(this, this, e), this.check();
  }
}
let Lg;
class mb extends db {
  static get ZERO() {
    return Lg || (Lg = new mb(0, 0, 0, 0), Object.freeze(Lg)), Lg;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    super(-0, -0, -0, -0), mh(e) && arguments.length === 1 ? this.copy(e) : (Gs.debug && (Yi(e), Yi(t), Yi(i), Yi(r)), this[0] = e, this[1] = t, this[2] = i, this[3] = r);
  }
  set(e, t, i, r) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = r, this.check();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  fromObject(e) {
    return Gs.debug && (Yi(e.x), Yi(e.y), Yi(e.z), Yi(e.w)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this;
  }
  toObject(e) {
    return e.x = this[0], e.y = this[1], e.z = this[2], e.w = this[3], e;
  }
  get ELEMENTS() {
    return 4;
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Yi(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Yi(e);
  }
  transform(e) {
    return gb(this, this, e), this.check();
  }
  transformByMatrix3(e) {
    return pE(this, this, e), this.check();
  }
  transformByMatrix2(e) {
    return n6(this, this, e), this.check();
  }
  transformByQuaternion(e) {
    return yE(this, this, e), this.check();
  }
  applyMatrix4(e) {
    return e.transform(this, this), this;
  }
}
class bE extends hb {
  toString() {
    let e = "[";
    if (Gs.printRowMajor) {
      e += "row-major:";
      for (let t = 0; t < this.RANK; ++t)
        for (let i = 0; i < this.RANK; ++i)
          e += " ".concat(this[i * this.RANK + t]);
    } else {
      e += "column-major:";
      for (let t = 0; t < this.ELEMENTS; ++t)
        e += " ".concat(this[t]);
    }
    return e += "]", e;
  }
  getElementIndex(e, t) {
    return t * this.RANK + e;
  }
  getElement(e, t) {
    return this[t * this.RANK + e];
  }
  setElement(e, t, i) {
    return this[t * this.RANK + e] = Yi(i), this;
  }
  getColumn(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Array(this.RANK).fill(-0);
    const i = e * this.RANK;
    for (let r = 0; r < this.RANK; ++r)
      t[r] = this[i + r];
    return t;
  }
  setColumn(e, t) {
    const i = e * this.RANK;
    for (let r = 0; r < this.RANK; ++r)
      this[i + r] = t[r];
    return this;
  }
}
function d6() {
  var n = new vc(9);
  return vc != Float32Array && (n[1] = 0, n[2] = 0, n[3] = 0, n[5] = 0, n[6] = 0, n[7] = 0), n[0] = 1, n[4] = 1, n[8] = 1, n;
}
function f6(n, e) {
  if (n === e) {
    var t = e[1], i = e[2], r = e[5];
    n[1] = e[3], n[2] = e[6], n[3] = t, n[5] = e[7], n[6] = i, n[7] = r;
  } else
    n[0] = e[0], n[1] = e[3], n[2] = e[6], n[3] = e[1], n[4] = e[4], n[5] = e[7], n[6] = e[2], n[7] = e[5], n[8] = e[8];
  return n;
}
function p6(n, e) {
  var t = e[0], i = e[1], r = e[2], l = e[3], c = e[4], a = e[5], g = e[6], y = e[7], A = e[8], C = A * c - a * y, I = -A * l + a * g, S = y * l - c * g, F = t * C + i * I + r * S;
  return F ? (F = 1 / F, n[0] = C * F, n[1] = (-A * i + r * y) * F, n[2] = (a * i - r * c) * F, n[3] = I * F, n[4] = (A * t - r * g) * F, n[5] = (-a * t + r * l) * F, n[6] = S * F, n[7] = (-y * t + i * g) * F, n[8] = (c * t - i * l) * F, n) : null;
}
function g6(n) {
  var e = n[0], t = n[1], i = n[2], r = n[3], l = n[4], c = n[5], a = n[6], g = n[7], y = n[8];
  return e * (y * l - c * g) + t * (-y * r + c * a) + i * (g * r - l * a);
}
function lw(n, e, t) {
  var i = e[0], r = e[1], l = e[2], c = e[3], a = e[4], g = e[5], y = e[6], A = e[7], C = e[8], I = t[0], S = t[1], F = t[2], U = t[3], V = t[4], W = t[5], X = t[6], de = t[7], ie = t[8];
  return n[0] = I * i + S * c + F * y, n[1] = I * r + S * a + F * A, n[2] = I * l + S * g + F * C, n[3] = U * i + V * c + W * y, n[4] = U * r + V * a + W * A, n[5] = U * l + V * g + W * C, n[6] = X * i + de * c + ie * y, n[7] = X * r + de * a + ie * A, n[8] = X * l + de * g + ie * C, n;
}
function m6(n, e, t) {
  var i = e[0], r = e[1], l = e[2], c = e[3], a = e[4], g = e[5], y = e[6], A = e[7], C = e[8], I = t[0], S = t[1];
  return n[0] = i, n[1] = r, n[2] = l, n[3] = c, n[4] = a, n[5] = g, n[6] = I * i + S * c + y, n[7] = I * r + S * a + A, n[8] = I * l + S * g + C, n;
}
function _6(n, e, t) {
  var i = e[0], r = e[1], l = e[2], c = e[3], a = e[4], g = e[5], y = e[6], A = e[7], C = e[8], I = Math.sin(t), S = Math.cos(t);
  return n[0] = S * i + I * c, n[1] = S * r + I * a, n[2] = S * l + I * g, n[3] = S * c - I * i, n[4] = S * a - I * r, n[5] = S * g - I * l, n[6] = y, n[7] = A, n[8] = C, n;
}
function cw(n, e, t) {
  var i = t[0], r = t[1];
  return n[0] = i * e[0], n[1] = i * e[1], n[2] = i * e[2], n[3] = r * e[3], n[4] = r * e[4], n[5] = r * e[5], n[6] = e[6], n[7] = e[7], n[8] = e[8], n;
}
function y6(n, e) {
  var t = e[0], i = e[1], r = e[2], l = e[3], c = t + t, a = i + i, g = r + r, y = t * c, A = i * c, C = i * a, I = r * c, S = r * a, F = r * g, U = l * c, V = l * a, W = l * g;
  return n[0] = 1 - C - F, n[3] = A - W, n[6] = I + V, n[1] = A + W, n[4] = 1 - y - F, n[7] = S - U, n[2] = I - V, n[5] = S + U, n[8] = 1 - y - C, n;
}
var Xy;
(function(n) {
  n[n.COL0ROW0 = 0] = "COL0ROW0", n[n.COL0ROW1 = 1] = "COL0ROW1", n[n.COL0ROW2 = 2] = "COL0ROW2", n[n.COL1ROW0 = 3] = "COL1ROW0", n[n.COL1ROW1 = 4] = "COL1ROW1", n[n.COL1ROW2 = 5] = "COL1ROW2", n[n.COL2ROW0 = 6] = "COL2ROW0", n[n.COL2ROW1 = 7] = "COL2ROW1", n[n.COL2ROW2 = 8] = "COL2ROW2";
})(Xy || (Xy = {}));
const b6 = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
class ss extends bE {
  static get IDENTITY() {
    return x6();
  }
  static get ZERO() {
    return v6();
  }
  get ELEMENTS() {
    return 9;
  }
  get RANK() {
    return 3;
  }
  get INDICES() {
    return Xy;
  }
  constructor(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
      i[r - 1] = arguments[r];
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : i.length > 0 ? this.copy([e, ...i]) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this.check();
  }
  identity() {
    return this.copy(b6);
  }
  fromObject(e) {
    return this.check();
  }
  fromQuaternion(e) {
    return y6(this, e), this.check();
  }
  set(e, t, i, r, l, c, a, g, y) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = r, this[4] = l, this[5] = c, this[6] = a, this[7] = g, this[8] = y, this.check();
  }
  setRowMajor(e, t, i, r, l, c, a, g, y) {
    return this[0] = e, this[1] = r, this[2] = a, this[3] = t, this[4] = l, this[5] = g, this[6] = i, this[7] = c, this[8] = y, this.check();
  }
  determinant() {
    return g6(this);
  }
  transpose() {
    return f6(this, this), this.check();
  }
  invert() {
    return p6(this, this), this.check();
  }
  multiplyLeft(e) {
    return lw(this, e, this), this.check();
  }
  multiplyRight(e) {
    return lw(this, this, e), this.check();
  }
  rotate(e) {
    return _6(this, this, e), this.check();
  }
  scale(e) {
    return Array.isArray(e) ? cw(this, this, e) : cw(this, this, [e, e]), this.check();
  }
  translate(e) {
    return m6(this, this, e), this.check();
  }
  transform(e, t) {
    let i;
    switch (e.length) {
      case 2:
        i = uE(t || [-0, -0], e, this);
        break;
      case 3:
        i = _E(t || [-0, -0, -0], e, this);
        break;
      case 4:
        i = pE(t || [-0, -0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return bp(i, e.length), i;
  }
  transformVector(e, t) {
    return this.transform(e, t);
  }
  transformVector2(e, t) {
    return this.transform(e, t);
  }
  transformVector3(e, t) {
    return this.transform(e, t);
  }
}
let Rg, Bg;
function v6() {
  return Rg || (Rg = new ss([0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Rg)), Rg;
}
function x6() {
  return Bg || (Bg = new ss(), Object.freeze(Bg)), Bg;
}
function w6(n) {
  return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
}
function A6(n, e) {
  if (n === e) {
    var t = e[1], i = e[2], r = e[3], l = e[6], c = e[7], a = e[11];
    n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = t, n[6] = e[9], n[7] = e[13], n[8] = i, n[9] = l, n[11] = e[14], n[12] = r, n[13] = c, n[14] = a;
  } else
    n[0] = e[0], n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = e[1], n[5] = e[5], n[6] = e[9], n[7] = e[13], n[8] = e[2], n[9] = e[6], n[10] = e[10], n[11] = e[14], n[12] = e[3], n[13] = e[7], n[14] = e[11], n[15] = e[15];
  return n;
}
function Yy(n, e) {
  var t = e[0], i = e[1], r = e[2], l = e[3], c = e[4], a = e[5], g = e[6], y = e[7], A = e[8], C = e[9], I = e[10], S = e[11], F = e[12], U = e[13], V = e[14], W = e[15], X = t * a - i * c, de = t * g - r * c, ie = t * y - l * c, fe = i * g - r * a, Ae = i * y - l * a, Te = r * y - l * g, me = A * U - C * F, Ge = A * V - I * F, ke = A * W - S * F, pe = C * V - I * U, _e = C * W - S * U, De = I * W - S * V, Me = X * De - de * _e + ie * pe + fe * ke - Ae * Ge + Te * me;
  return Me ? (Me = 1 / Me, n[0] = (a * De - g * _e + y * pe) * Me, n[1] = (r * _e - i * De - l * pe) * Me, n[2] = (U * Te - V * Ae + W * fe) * Me, n[3] = (I * Ae - C * Te - S * fe) * Me, n[4] = (g * ke - c * De - y * Ge) * Me, n[5] = (t * De - r * ke + l * Ge) * Me, n[6] = (V * ie - F * Te - W * de) * Me, n[7] = (A * Te - I * ie + S * de) * Me, n[8] = (c * _e - a * ke + y * me) * Me, n[9] = (i * ke - t * _e - l * me) * Me, n[10] = (F * Ae - U * ie + W * X) * Me, n[11] = (C * ie - A * Ae - S * X) * Me, n[12] = (a * Ge - c * pe - g * me) * Me, n[13] = (t * pe - i * Ge + r * me) * Me, n[14] = (U * de - F * fe - V * X) * Me, n[15] = (A * fe - C * de + I * X) * Me, n) : null;
}
function T6(n) {
  var e = n[0], t = n[1], i = n[2], r = n[3], l = n[4], c = n[5], a = n[6], g = n[7], y = n[8], A = n[9], C = n[10], I = n[11], S = n[12], F = n[13], U = n[14], V = n[15], W = e * c - t * l, X = e * a - i * l, de = e * g - r * l, ie = t * a - i * c, fe = t * g - r * c, Ae = i * g - r * a, Te = y * F - A * S, me = y * U - C * S, Ge = y * V - I * S, ke = A * U - C * F, pe = A * V - I * F, _e = C * V - I * U;
  return W * _e - X * pe + de * ke + ie * Ge - fe * me + Ae * Te;
}
function $h(n, e, t) {
  var i = e[0], r = e[1], l = e[2], c = e[3], a = e[4], g = e[5], y = e[6], A = e[7], C = e[8], I = e[9], S = e[10], F = e[11], U = e[12], V = e[13], W = e[14], X = e[15], de = t[0], ie = t[1], fe = t[2], Ae = t[3];
  return n[0] = de * i + ie * a + fe * C + Ae * U, n[1] = de * r + ie * g + fe * I + Ae * V, n[2] = de * l + ie * y + fe * S + Ae * W, n[3] = de * c + ie * A + fe * F + Ae * X, de = t[4], ie = t[5], fe = t[6], Ae = t[7], n[4] = de * i + ie * a + fe * C + Ae * U, n[5] = de * r + ie * g + fe * I + Ae * V, n[6] = de * l + ie * y + fe * S + Ae * W, n[7] = de * c + ie * A + fe * F + Ae * X, de = t[8], ie = t[9], fe = t[10], Ae = t[11], n[8] = de * i + ie * a + fe * C + Ae * U, n[9] = de * r + ie * g + fe * I + Ae * V, n[10] = de * l + ie * y + fe * S + Ae * W, n[11] = de * c + ie * A + fe * F + Ae * X, de = t[12], ie = t[13], fe = t[14], Ae = t[15], n[12] = de * i + ie * a + fe * C + Ae * U, n[13] = de * r + ie * g + fe * I + Ae * V, n[14] = de * l + ie * y + fe * S + Ae * W, n[15] = de * c + ie * A + fe * F + Ae * X, n;
}
function Bm(n, e, t) {
  var i = t[0], r = t[1], l = t[2], c, a, g, y, A, C, I, S, F, U, V, W;
  return e === n ? (n[12] = e[0] * i + e[4] * r + e[8] * l + e[12], n[13] = e[1] * i + e[5] * r + e[9] * l + e[13], n[14] = e[2] * i + e[6] * r + e[10] * l + e[14], n[15] = e[3] * i + e[7] * r + e[11] * l + e[15]) : (c = e[0], a = e[1], g = e[2], y = e[3], A = e[4], C = e[5], I = e[6], S = e[7], F = e[8], U = e[9], V = e[10], W = e[11], n[0] = c, n[1] = a, n[2] = g, n[3] = y, n[4] = A, n[5] = C, n[6] = I, n[7] = S, n[8] = F, n[9] = U, n[10] = V, n[11] = W, n[12] = c * i + A * r + F * l + e[12], n[13] = a * i + C * r + U * l + e[13], n[14] = g * i + I * r + V * l + e[14], n[15] = y * i + S * r + W * l + e[15]), n;
}
function _b(n, e, t) {
  var i = t[0], r = t[1], l = t[2];
  return n[0] = e[0] * i, n[1] = e[1] * i, n[2] = e[2] * i, n[3] = e[3] * i, n[4] = e[4] * r, n[5] = e[5] * r, n[6] = e[6] * r, n[7] = e[7] * r, n[8] = e[8] * l, n[9] = e[9] * l, n[10] = e[10] * l, n[11] = e[11] * l, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n;
}
function E6(n, e, t, i) {
  var r = i[0], l = i[1], c = i[2], a = Math.hypot(r, l, c), g, y, A, C, I, S, F, U, V, W, X, de, ie, fe, Ae, Te, me, Ge, ke, pe, _e, De, Me, St;
  return a < vp ? null : (a = 1 / a, r *= a, l *= a, c *= a, g = Math.sin(t), y = Math.cos(t), A = 1 - y, C = e[0], I = e[1], S = e[2], F = e[3], U = e[4], V = e[5], W = e[6], X = e[7], de = e[8], ie = e[9], fe = e[10], Ae = e[11], Te = r * r * A + y, me = l * r * A + c * g, Ge = c * r * A - l * g, ke = r * l * A - c * g, pe = l * l * A + y, _e = c * l * A + r * g, De = r * c * A + l * g, Me = l * c * A - r * g, St = c * c * A + y, n[0] = C * Te + U * me + de * Ge, n[1] = I * Te + V * me + ie * Ge, n[2] = S * Te + W * me + fe * Ge, n[3] = F * Te + X * me + Ae * Ge, n[4] = C * ke + U * pe + de * _e, n[5] = I * ke + V * pe + ie * _e, n[6] = S * ke + W * pe + fe * _e, n[7] = F * ke + X * pe + Ae * _e, n[8] = C * De + U * Me + de * St, n[9] = I * De + V * Me + ie * St, n[10] = S * De + W * Me + fe * St, n[11] = F * De + X * Me + Ae * St, e !== n && (n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n);
}
function vE(n, e, t) {
  var i = Math.sin(t), r = Math.cos(t), l = e[4], c = e[5], a = e[6], g = e[7], y = e[8], A = e[9], C = e[10], I = e[11];
  return e !== n && (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[4] = l * r + y * i, n[5] = c * r + A * i, n[6] = a * r + C * i, n[7] = g * r + I * i, n[8] = y * r - l * i, n[9] = A * r - c * i, n[10] = C * r - a * i, n[11] = I * r - g * i, n;
}
function S6(n, e, t) {
  var i = Math.sin(t), r = Math.cos(t), l = e[0], c = e[1], a = e[2], g = e[3], y = e[8], A = e[9], C = e[10], I = e[11];
  return e !== n && (n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = l * r - y * i, n[1] = c * r - A * i, n[2] = a * r - C * i, n[3] = g * r - I * i, n[8] = l * i + y * r, n[9] = c * i + A * r, n[10] = a * i + C * r, n[11] = g * i + I * r, n;
}
function xE(n, e, t) {
  var i = Math.sin(t), r = Math.cos(t), l = e[0], c = e[1], a = e[2], g = e[3], y = e[4], A = e[5], C = e[6], I = e[7];
  return e !== n && (n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = l * r + y * i, n[1] = c * r + A * i, n[2] = a * r + C * i, n[3] = g * r + I * i, n[4] = y * r - l * i, n[5] = A * r - c * i, n[6] = C * r - a * i, n[7] = I * r - g * i, n;
}
function C6(n, e) {
  var t = e[0], i = e[1], r = e[2], l = e[4], c = e[5], a = e[6], g = e[8], y = e[9], A = e[10];
  return n[0] = Math.hypot(t, i, r), n[1] = Math.hypot(l, c, a), n[2] = Math.hypot(g, y, A), n;
}
function P6(n, e) {
  var t = e[0], i = e[1], r = e[2], l = e[3], c = t + t, a = i + i, g = r + r, y = t * c, A = i * c, C = i * a, I = r * c, S = r * a, F = r * g, U = l * c, V = l * a, W = l * g;
  return n[0] = 1 - C - F, n[1] = A + W, n[2] = I - V, n[3] = 0, n[4] = A - W, n[5] = 1 - y - F, n[6] = S + U, n[7] = 0, n[8] = I + V, n[9] = S - U, n[10] = 1 - y - C, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
}
function I6(n, e, t, i, r, l, c) {
  var a = 1 / (t - e), g = 1 / (r - i), y = 1 / (l - c);
  return n[0] = l * 2 * a, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = l * 2 * g, n[6] = 0, n[7] = 0, n[8] = (t + e) * a, n[9] = (r + i) * g, n[10] = (c + l) * y, n[11] = -1, n[12] = 0, n[13] = 0, n[14] = c * l * 2 * y, n[15] = 0, n;
}
function M6(n, e, t, i, r) {
  var l = 1 / Math.tan(e / 2), c;
  return n[0] = l / t, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = l, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, r != null && r !== 1 / 0 ? (c = 1 / (i - r), n[10] = (r + i) * c, n[14] = 2 * r * i * c) : (n[10] = -1, n[14] = -2 * i), n;
}
var L6 = M6;
function R6(n, e, t, i, r, l, c) {
  var a = 1 / (e - t), g = 1 / (i - r), y = 1 / (l - c);
  return n[0] = -2 * a, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * g, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * y, n[11] = 0, n[12] = (e + t) * a, n[13] = (r + i) * g, n[14] = (c + l) * y, n[15] = 1, n;
}
var B6 = R6;
function O6(n, e, t, i) {
  var r, l, c, a, g, y, A, C, I, S, F = e[0], U = e[1], V = e[2], W = i[0], X = i[1], de = i[2], ie = t[0], fe = t[1], Ae = t[2];
  return Math.abs(F - ie) < vp && Math.abs(U - fe) < vp && Math.abs(V - Ae) < vp ? w6(n) : (A = F - ie, C = U - fe, I = V - Ae, S = 1 / Math.hypot(A, C, I), A *= S, C *= S, I *= S, r = X * I - de * C, l = de * A - W * I, c = W * C - X * A, S = Math.hypot(r, l, c), S ? (S = 1 / S, r *= S, l *= S, c *= S) : (r = 0, l = 0, c = 0), a = C * c - I * l, g = I * r - A * c, y = A * l - C * r, S = Math.hypot(a, g, y), S ? (S = 1 / S, a *= S, g *= S, y *= S) : (a = 0, g = 0, y = 0), n[0] = r, n[1] = a, n[2] = A, n[3] = 0, n[4] = l, n[5] = g, n[6] = C, n[7] = 0, n[8] = c, n[9] = y, n[10] = I, n[11] = 0, n[12] = -(r * F + l * U + c * V), n[13] = -(a * F + g * U + y * V), n[14] = -(A * F + C * U + I * V), n[15] = 1, n);
}
function D6() {
  var n = new vc(4);
  return vc != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 0), n;
}
function F6(n, e, t) {
  return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n[2] = e[2] + t[2], n[3] = e[3] + t[3], n;
}
function wE(n, e, t) {
  return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n;
}
function N6(n) {
  var e = n[0], t = n[1], i = n[2], r = n[3];
  return Math.hypot(e, t, i, r);
}
function k6(n) {
  var e = n[0], t = n[1], i = n[2], r = n[3];
  return e * e + t * t + i * i + r * r;
}
function z6(n, e) {
  var t = e[0], i = e[1], r = e[2], l = e[3], c = t * t + i * i + r * r + l * l;
  return c > 0 && (c = 1 / Math.sqrt(c)), n[0] = t * c, n[1] = i * c, n[2] = r * c, n[3] = l * c, n;
}
function U6(n, e) {
  return n[0] * e[0] + n[1] * e[1] + n[2] * e[2] + n[3] * e[3];
}
function j6(n, e, t, i) {
  var r = e[0], l = e[1], c = e[2], a = e[3];
  return n[0] = r + i * (t[0] - r), n[1] = l + i * (t[1] - l), n[2] = c + i * (t[2] - c), n[3] = a + i * (t[3] - a), n;
}
function Wp(n, e, t) {
  var i = e[0], r = e[1], l = e[2], c = e[3];
  return n[0] = t[0] * i + t[4] * r + t[8] * l + t[12] * c, n[1] = t[1] * i + t[5] * r + t[9] * l + t[13] * c, n[2] = t[2] * i + t[6] * r + t[10] * l + t[14] * c, n[3] = t[3] * i + t[7] * r + t[11] * l + t[15] * c, n;
}
function G6(n, e, t) {
  var i = e[0], r = e[1], l = e[2], c = t[0], a = t[1], g = t[2], y = t[3], A = y * i + a * l - g * r, C = y * r + g * i - c * l, I = y * l + c * r - a * i, S = -c * i - a * r - g * l;
  return n[0] = A * y + S * -c + C * -g - I * -a, n[1] = C * y + S * -a + I * -c - A * -g, n[2] = I * y + S * -g + A * -a - C * -c, n[3] = e[3], n;
}
(function() {
  var n = D6();
  return function(e, t, i, r, l, c) {
    var a, g;
    for (t || (t = 4), i || (i = 0), r ? g = Math.min(r * t + i, e.length) : g = e.length, a = i; a < g; a += t)
      n[0] = e[a], n[1] = e[a + 1], n[2] = e[a + 2], n[3] = e[a + 3], l(n, n, c), e[a] = n[0], e[a + 1] = n[1], e[a + 2] = n[2], e[a + 3] = n[3];
    return e;
  };
})();
var Jy;
(function(n) {
  n[n.COL0ROW0 = 0] = "COL0ROW0", n[n.COL0ROW1 = 1] = "COL0ROW1", n[n.COL0ROW2 = 2] = "COL0ROW2", n[n.COL0ROW3 = 3] = "COL0ROW3", n[n.COL1ROW0 = 4] = "COL1ROW0", n[n.COL1ROW1 = 5] = "COL1ROW1", n[n.COL1ROW2 = 6] = "COL1ROW2", n[n.COL1ROW3 = 7] = "COL1ROW3", n[n.COL2ROW0 = 8] = "COL2ROW0", n[n.COL2ROW1 = 9] = "COL2ROW1", n[n.COL2ROW2 = 10] = "COL2ROW2", n[n.COL2ROW3 = 11] = "COL2ROW3", n[n.COL3ROW0 = 12] = "COL3ROW0", n[n.COL3ROW1 = 13] = "COL3ROW1", n[n.COL3ROW2 = 14] = "COL3ROW2", n[n.COL3ROW3 = 15] = "COL3ROW3";
})(Jy || (Jy = {}));
const V6 = 45 * Math.PI / 180, q6 = 1, R0 = 0.1, B0 = 500, H6 = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
class Mi extends bE {
  static get IDENTITY() {
    return Z6();
  }
  static get ZERO() {
    return W6();
  }
  get ELEMENTS() {
    return 16;
  }
  get RANK() {
    return 4;
  }
  get INDICES() {
    return Jy;
  }
  constructor(e) {
    super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
  }
  set(e, t, i, r, l, c, a, g, y, A, C, I, S, F, U, V) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = r, this[4] = l, this[5] = c, this[6] = a, this[7] = g, this[8] = y, this[9] = A, this[10] = C, this[11] = I, this[12] = S, this[13] = F, this[14] = U, this[15] = V, this.check();
  }
  setRowMajor(e, t, i, r, l, c, a, g, y, A, C, I, S, F, U, V) {
    return this[0] = e, this[1] = l, this[2] = y, this[3] = S, this[4] = t, this[5] = c, this[6] = A, this[7] = F, this[8] = i, this[9] = a, this[10] = C, this[11] = U, this[12] = r, this[13] = g, this[14] = I, this[15] = V, this.check();
  }
  toRowMajor(e) {
    return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
  }
  identity() {
    return this.copy(H6);
  }
  fromObject(e) {
    return this.check();
  }
  fromQuaternion(e) {
    return P6(this, e), this.check();
  }
  frustum(e) {
    const {
      left: t,
      right: i,
      bottom: r,
      top: l,
      near: c = R0,
      far: a = B0
    } = e;
    return a === 1 / 0 ? $6(this, t, i, r, l, c) : I6(this, t, i, r, l, c, a), this.check();
  }
  lookAt(e) {
    const {
      eye: t,
      center: i = [0, 0, 0],
      up: r = [0, 1, 0]
    } = e;
    return O6(this, t, i, r), this.check();
  }
  ortho(e) {
    const {
      left: t,
      right: i,
      bottom: r,
      top: l,
      near: c = R0,
      far: a = B0
    } = e;
    return B6(this, t, i, r, l, c, a), this.check();
  }
  orthographic(e) {
    const {
      fovy: t = V6,
      aspect: i = q6,
      focalDistance: r = 1,
      near: l = R0,
      far: c = B0
    } = e;
    uw(t);
    const a = t / 2, g = r * Math.tan(a), y = g * i;
    return this.ortho({
      left: -y,
      right: y,
      bottom: -g,
      top: g,
      near: l,
      far: c
    });
  }
  perspective(e) {
    const {
      fovy: t = 45 * Math.PI / 180,
      aspect: i = 1,
      near: r = 0.1,
      far: l = 500
    } = e;
    return uw(t), L6(this, t, i, r, l), this.check();
  }
  determinant() {
    return T6(this);
  }
  getScale() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
    return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
  }
  getTranslation() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [-0, -0, -0];
    return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
  }
  getRotation(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const i = this.getScale(t), r = 1 / i[0], l = 1 / i[1], c = 1 / i[2];
    return e[0] = this[0] * r, e[1] = this[1] * l, e[2] = this[2] * c, e[3] = 0, e[4] = this[4] * r, e[5] = this[5] * l, e[6] = this[6] * c, e[7] = 0, e[8] = this[8] * r, e[9] = this[9] * l, e[10] = this[10] * c, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
  }
  getRotationMatrix3(e, t) {
    e = e || [-0, -0, -0, -0, -0, -0, -0, -0, -0], t = t || [-0, -0, -0];
    const i = this.getScale(t), r = 1 / i[0], l = 1 / i[1], c = 1 / i[2];
    return e[0] = this[0] * r, e[1] = this[1] * l, e[2] = this[2] * c, e[3] = this[4] * r, e[4] = this[5] * l, e[5] = this[6] * c, e[6] = this[8] * r, e[7] = this[9] * l, e[8] = this[10] * c, e;
  }
  transpose() {
    return A6(this, this), this.check();
  }
  invert() {
    return Yy(this, this), this.check();
  }
  multiplyLeft(e) {
    return $h(this, e, this), this.check();
  }
  multiplyRight(e) {
    return $h(this, this, e), this.check();
  }
  rotateX(e) {
    return vE(this, this, e), this.check();
  }
  rotateY(e) {
    return S6(this, this, e), this.check();
  }
  rotateZ(e) {
    return xE(this, this, e), this.check();
  }
  rotateXYZ(e) {
    return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
  }
  rotateAxis(e, t) {
    return E6(this, this, e, t), this.check();
  }
  scale(e) {
    return _b(this, this, Array.isArray(e) ? e : [e, e, e]), this.check();
  }
  translate(e) {
    return Bm(this, this, e), this.check();
  }
  transform(e, t) {
    return e.length === 4 ? (t = Wp(t || [-0, -0, -0, -0], e, this), bp(t, 4), t) : this.transformAsPoint(e, t);
  }
  transformAsPoint(e, t) {
    const {
      length: i
    } = e;
    let r;
    switch (i) {
      case 2:
        r = hE(t || [-0, -0], e, this);
        break;
      case 3:
        r = gb(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return bp(r, e.length), r;
  }
  transformAsVector(e, t) {
    let i;
    switch (e.length) {
      case 2:
        i = dE(t || [-0, -0], e, this);
        break;
      case 3:
        i = fE(t || [-0, -0, -0], e, this);
        break;
      default:
        throw new Error("Illegal vector");
    }
    return bp(i, e.length), i;
  }
  transformPoint(e, t) {
    return this.transformAsPoint(e, t);
  }
  transformVector(e, t) {
    return this.transformAsPoint(e, t);
  }
  transformDirection(e, t) {
    return this.transformAsVector(e, t);
  }
  makeRotationX(e) {
    return this.identity().rotateX(e);
  }
  makeTranslation(e, t, i) {
    return this.identity().translate([e, t, i]);
  }
}
let Og, Dg;
function W6() {
  return Og || (Og = new Mi([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), Object.freeze(Og)), Og;
}
function Z6() {
  return Dg || (Dg = new Mi(), Object.freeze(Dg)), Dg;
}
function uw(n) {
  if (n > Math.PI * 2)
    throw Error("expected radians");
}
function $6(n, e, t, i, r, l) {
  const c = 2 * l / (t - e), a = 2 * l / (r - i), g = (t + e) / (t - e), y = (r + i) / (r - i), A = -1, C = -1, I = -2 * l;
  return n[0] = c, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = a, n[6] = 0, n[7] = 0, n[8] = g, n[9] = y, n[10] = A, n[11] = C, n[12] = 0, n[13] = 0, n[14] = I, n[15] = 0, n;
}
function hw() {
  var n = new vc(4);
  return vc != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n[3] = 1, n;
}
function X6(n) {
  return n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 1, n;
}
function AE(n, e, t) {
  t = t * 0.5;
  var i = Math.sin(t);
  return n[0] = i * e[0], n[1] = i * e[1], n[2] = i * e[2], n[3] = Math.cos(t), n;
}
function dw(n, e, t) {
  var i = e[0], r = e[1], l = e[2], c = e[3], a = t[0], g = t[1], y = t[2], A = t[3];
  return n[0] = i * A + c * a + r * y - l * g, n[1] = r * A + c * g + l * a - i * y, n[2] = l * A + c * y + i * g - r * a, n[3] = c * A - i * a - r * g - l * y, n;
}
function Y6(n, e, t) {
  t *= 0.5;
  var i = e[0], r = e[1], l = e[2], c = e[3], a = Math.sin(t), g = Math.cos(t);
  return n[0] = i * g + c * a, n[1] = r * g + l * a, n[2] = l * g - r * a, n[3] = c * g - i * a, n;
}
function J6(n, e, t) {
  t *= 0.5;
  var i = e[0], r = e[1], l = e[2], c = e[3], a = Math.sin(t), g = Math.cos(t);
  return n[0] = i * g - l * a, n[1] = r * g + c * a, n[2] = l * g + i * a, n[3] = c * g - r * a, n;
}
function K6(n, e, t) {
  t *= 0.5;
  var i = e[0], r = e[1], l = e[2], c = e[3], a = Math.sin(t), g = Math.cos(t);
  return n[0] = i * g + r * a, n[1] = r * g - i * a, n[2] = l * g + c * a, n[3] = c * g - l * a, n;
}
function Q6(n, e) {
  var t = e[0], i = e[1], r = e[2];
  return n[0] = t, n[1] = i, n[2] = r, n[3] = Math.sqrt(Math.abs(1 - t * t - i * i - r * r)), n;
}
function om(n, e, t, i) {
  var r = e[0], l = e[1], c = e[2], a = e[3], g = t[0], y = t[1], A = t[2], C = t[3], I, S, F, U, V;
  return S = r * g + l * y + c * A + a * C, S < 0 && (S = -S, g = -g, y = -y, A = -A, C = -C), 1 - S > vp ? (I = Math.acos(S), F = Math.sin(I), U = Math.sin((1 - i) * I) / F, V = Math.sin(i * I) / F) : (U = 1 - i, V = i), n[0] = U * r + V * g, n[1] = U * l + V * y, n[2] = U * c + V * A, n[3] = U * a + V * C, n;
}
function eD(n, e) {
  var t = e[0], i = e[1], r = e[2], l = e[3], c = t * t + i * i + r * r + l * l, a = c ? 1 / c : 0;
  return n[0] = -t * a, n[1] = -i * a, n[2] = -r * a, n[3] = l * a, n;
}
function tD(n, e) {
  return n[0] = -e[0], n[1] = -e[1], n[2] = -e[2], n[3] = e[3], n;
}
function TE(n, e) {
  var t = e[0] + e[4] + e[8], i;
  if (t > 0)
    i = Math.sqrt(t + 1), n[3] = 0.5 * i, i = 0.5 / i, n[0] = (e[5] - e[7]) * i, n[1] = (e[6] - e[2]) * i, n[2] = (e[1] - e[3]) * i;
  else {
    var r = 0;
    e[4] > e[0] && (r = 1), e[8] > e[r * 3 + r] && (r = 2);
    var l = (r + 1) % 3, c = (r + 2) % 3;
    i = Math.sqrt(e[r * 3 + r] - e[l * 3 + l] - e[c * 3 + c] + 1), n[r] = 0.5 * i, i = 0.5 / i, n[3] = (e[l * 3 + c] - e[c * 3 + l]) * i, n[l] = (e[l * 3 + r] + e[r * 3 + l]) * i, n[c] = (e[c * 3 + r] + e[r * 3 + c]) * i;
  }
  return n;
}
var nD = F6, iD = wE, rD = U6, sD = j6, oD = N6, aD = k6, EE = z6, lD = function() {
  var n = gE(), e = aw(1, 0, 0), t = aw(0, 1, 0);
  return function(i, r, l) {
    var c = pb(r, l);
    return c < -0.999999 ? (sm(n, e, r), h6(n) < 1e-6 && sm(n, t, r), s6(n, n), AE(i, n, Math.PI), i) : c > 0.999999 ? (i[0] = 0, i[1] = 0, i[2] = 0, i[3] = 1, i) : (sm(n, r, l), i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = 1 + c, EE(i, i));
  };
}();
(function() {
  var n = hw(), e = hw();
  return function(t, i, r, l, c, a) {
    return om(n, i, c, a), om(e, r, l, a), om(t, n, e, 2 * a * (1 - a)), t;
  };
})();
(function() {
  var n = d6();
  return function(e, t, i, r) {
    return n[0] = i[0], n[3] = i[1], n[6] = i[2], n[1] = r[0], n[4] = r[1], n[7] = r[2], n[2] = -t[0], n[5] = -t[1], n[8] = -t[2], EE(e, TE(e, n));
  };
})();
const cD = [0, 0, 0, 1];
class Ip extends hb {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
    super(-0, -0, -0, -0), Array.isArray(e) && arguments.length === 1 ? this.copy(e) : this.set(e, t, i, r);
  }
  copy(e) {
    return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this.check();
  }
  set(e, t, i, r) {
    return this[0] = e, this[1] = t, this[2] = i, this[3] = r, this.check();
  }
  fromObject(e) {
    return this[0] = e.x, this[1] = e.y, this[2] = e.z, this[3] = e.w, this.check();
  }
  fromMatrix3(e) {
    return TE(this, e), this.check();
  }
  fromAxisRotation(e, t) {
    return AE(this, e, t), this.check();
  }
  identity() {
    return X6(this), this.check();
  }
  setAxisAngle(e, t) {
    return this.fromAxisRotation(e, t);
  }
  get ELEMENTS() {
    return 4;
  }
  get x() {
    return this[0];
  }
  set x(e) {
    this[0] = Yi(e);
  }
  get y() {
    return this[1];
  }
  set y(e) {
    this[1] = Yi(e);
  }
  get z() {
    return this[2];
  }
  set z(e) {
    this[2] = Yi(e);
  }
  get w() {
    return this[3];
  }
  set w(e) {
    this[3] = Yi(e);
  }
  len() {
    return oD(this);
  }
  lengthSquared() {
    return aD(this);
  }
  dot(e) {
    return rD(this, e);
  }
  rotationTo(e, t) {
    return lD(this, e, t), this.check();
  }
  add(e) {
    return nD(this, this, e), this.check();
  }
  calculateW() {
    return Q6(this, this), this.check();
  }
  conjugate() {
    return tD(this, this), this.check();
  }
  invert() {
    return eD(this, this), this.check();
  }
  lerp(e, t, i) {
    return i === void 0 ? this.lerp(this, e, t) : (sD(this, e, t, i), this.check());
  }
  multiplyRight(e) {
    return dw(this, this, e), this.check();
  }
  multiplyLeft(e) {
    return dw(this, e, this), this.check();
  }
  normalize() {
    const e = this.len(), t = e > 0 ? 1 / e : 0;
    return this[0] = this[0] * t, this[1] = this[1] * t, this[2] = this[2] * t, this[3] = this[3] * t, e === 0 && (this[3] = 1), this.check();
  }
  rotateX(e) {
    return Y6(this, this, e), this.check();
  }
  rotateY(e) {
    return J6(this, this, e), this.check();
  }
  rotateZ(e) {
    return K6(this, this, e), this.check();
  }
  scale(e) {
    return iD(this, this, e), this.check();
  }
  slerp(e, t, i) {
    let r, l, c;
    switch (arguments.length) {
      case 1:
        ({
          start: r = cD,
          target: l,
          ratio: c
        } = e);
        break;
      case 2:
        r = this, l = e, c = t;
        break;
      default:
        r = e, l = t, c = i;
    }
    return om(this, r, l, c), this.check();
  }
  transformVector4(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new mb();
    return G6(t, e, this), bp(t, 4);
  }
  lengthSq() {
    return this.lengthSquared();
  }
  setFromAxisAngle(e, t) {
    return this.setAxisAngle(e, t);
  }
  premultiply(e) {
    return this.multiplyLeft(e);
  }
  multiply(e) {
    return this.multiplyRight(e);
  }
}
const Mp = {
  EPSILON1: 0.1,
  EPSILON2: 0.01,
  EPSILON3: 1e-3,
  EPSILON4: 1e-4,
  EPSILON5: 1e-5,
  EPSILON6: 1e-6,
  EPSILON7: 1e-7,
  EPSILON8: 1e-8,
  EPSILON9: 1e-9,
  EPSILON10: 1e-10,
  EPSILON11: 1e-11,
  EPSILON12: 1e-12,
  EPSILON13: 1e-13,
  EPSILON14: 1e-14,
  EPSILON15: 1e-15,
  EPSILON16: 1e-16,
  EPSILON17: 1e-17,
  EPSILON18: 1e-18,
  EPSILON19: 1e-19,
  EPSILON20: 1e-20,
  PI_OVER_TWO: Math.PI / 2,
  PI_OVER_FOUR: Math.PI / 4,
  PI_OVER_SIX: Math.PI / 6,
  TWO_PI: Math.PI * 2
}, fw = `#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))

struct AmbientLight {
 vec3 color;
};

struct PointLight {
 vec3 color;
 vec3 position;
 vec3 attenuation;
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;

uniform bool lighting_uEnabled;

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

#endif
`, uD = {
  lightSources: {}
};
function O0() {
  let {
    color: n = [0, 0, 0],
    intensity: e = 1
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return n.map((t) => t * e / 255);
}
function hD(n) {
  let {
    ambientLight: e,
    pointLights: t = [],
    directionalLights: i = []
  } = n;
  const r = {};
  return e ? r["lighting_uAmbientLight.color"] = O0(e) : r["lighting_uAmbientLight.color"] = [0, 0, 0], t.forEach((l, c) => {
    r["lighting_uPointLight[".concat(c, "].color")] = O0(l), r["lighting_uPointLight[".concat(c, "].position")] = l.position, r["lighting_uPointLight[".concat(c, "].attenuation")] = l.attenuation || [1, 0, 0];
  }), r.lighting_uPointLightCount = t.length, i.forEach((l, c) => {
    r["lighting_uDirectionalLight[".concat(c, "].color")] = O0(l), r["lighting_uDirectionalLight[".concat(c, "].direction")] = l.direction;
  }), r.lighting_uDirectionalLightCount = i.length, r;
}
function SE() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : uD;
  if ("lightSources" in n) {
    const {
      ambientLight: e,
      pointLights: t,
      directionalLights: i
    } = n.lightSources || {};
    return e || t && t.length > 0 || i && i.length > 0 ? Object.assign({}, hD({
      ambientLight: e,
      pointLights: t,
      directionalLights: i
    }), {
      lighting_uEnabled: !0
    }) : {
      lighting_uEnabled: !1
    };
  }
  if ("lights" in n) {
    const e = {
      pointLights: [],
      directionalLights: []
    };
    for (const t of n.lights || [])
      switch (t.type) {
        case "ambient":
          e.ambientLight = t;
          break;
        case "directional":
          e.directionalLights.push(t);
          break;
        case "point":
          e.pointLights.push(t);
          break;
      }
    return SE({
      lightSources: e
    });
  }
  return {};
}
const yb = {
  name: "lights",
  vs: fw,
  fs: fw,
  getUniforms: SE,
  defines: {
    MAX_LIGHTS: 3
  }
}, dD = new Uint8Array([0, 255, 255, 255]), fD = {
  pickingSelectedColor: null,
  pickingHighlightColor: dD,
  pickingActive: !1,
  pickingAttribute: !1
};
function pD() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : fD;
  const e = {};
  if (n.pickingSelectedColor !== void 0)
    if (!n.pickingSelectedColor)
      e.picking_uSelectedColorValid = 0;
    else {
      const t = n.pickingSelectedColor.slice(0, 3);
      e.picking_uSelectedColorValid = 1, e.picking_uSelectedColor = t;
    }
  if (n.pickingHighlightColor) {
    const t = Array.from(n.pickingHighlightColor, (i) => i / 255);
    Number.isFinite(t[3]) || (t[3] = 1), e.picking_uHighlightColor = t;
  }
  return n.pickingActive !== void 0 && (e.picking_uActive = !!n.pickingActive, e.picking_uAttribute = !!n.pickingAttribute), e;
}
const gD = `uniform bool picking_uActive;
uniform bool picking_uAttribute;
uniform vec3 picking_uSelectedColor;
uniform bool picking_uSelectedColorValid;

out vec4 picking_vRGBcolor_Avalid;

const float COLOR_SCALE = 1. / 255.;

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.001;
}

bool isVertexPicked(vec3 vertexColor) {
  return
    picking_uSelectedColorValid &&
    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));
}

void picking_setPickingColor(vec3 pickingColor) {
  if (picking_uActive) {
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!picking_uAttribute) {
      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;
    }
  } else {
    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.r = value;
  }
}
void picking_setPickingAttribute(vec2 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}
void picking_setPickingAttribute(vec3 value) {
  if (picking_uAttribute) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`, mD = `uniform bool picking_uActive;
uniform vec3 picking_uSelectedColor;
uniform vec4 picking_uHighlightColor;

in vec4 picking_vRGBcolor_Avalid;
vec4 picking_filterHighlightColor(vec4 color) {
  if (picking_uActive) {
    return color;
  }
  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    float highLightAlpha = picking_uHighlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}
vec4 picking_filterPickingColor(vec4 color) {
  if (picking_uActive) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}
vec4 picking_filterColor(vec4 color) {
  vec4 highightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highightColor);
}

`, _D = {
  name: "picking",
  vs: gD,
  fs: mD,
  getUniforms: pD
}, CE = `
uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
    vec3 halfway_direction = normalize(light_direction + view_direction);
    float lambertian = dot(light_direction, normal_worldspace);
    float specular = 0.0;
    if (lambertian > 0.0) {
      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
      specular = pow(specular_angle, lighting_uShininess);
    }
    lambertian = max(lambertian, 0.0);
    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);
    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}

vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = vec3(0, 0, 0);
  vec3 surfaceColor = vec3(0, 0, 0);

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}
`, yD = {};
function bD(n) {
  const {
    ambient: e = 0.35,
    diffuse: t = 0.6,
    shininess: i = 32,
    specularColor: r = [30, 30, 30]
  } = n;
  return {
    lighting_uAmbient: e,
    lighting_uDiffuse: t,
    lighting_uShininess: i,
    lighting_uSpecularColor: r.map((l) => l / 255)
  };
}
function PE() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : yD;
  if (!("material" in n))
    return {};
  const {
    material: e
  } = n;
  return e ? bD(e) : {
    lighting_uEnabled: !1
  };
}
const vD = {
  name: "gouraud-lighting",
  dependencies: [yb],
  vs: CE,
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms: PE
}, xD = {
  name: "phong-lighting",
  dependencies: [yb],
  fs: CE,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms: PE
}, wD = `uniform mat4 u_MVPMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;

varying vec3 pbr_vPosition;
varying vec2 pbr_vUV;

#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
# else
varying vec3 pbr_vNormal;
# endif
#endif

void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
  vec4 pos = u_ModelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
  pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else
  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}
`, AD = `#if defined(USE_TEX_LOD) && !defined(FEATURE_GLSL_TEXTURE_LOD)
# error PBR fragment shader: Texture LOD is not available
#endif

#if !defined(HAS_TANGENTS) && !defined(FEATURE_GLSL_DERIVATIVES)
# error PBR fragment shader: Derivatives are not available
#endif


#if (__VERSION__ < 300)
  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)
#else
  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)
#endif

precision highp float;

uniform bool pbr_uUnlit;

#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
uniform vec2 u_ScaleIBLAmbient;
#endif

#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
uniform vec3 u_EmissiveFactor;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
uniform float u_OcclusionStrength;
#endif

#ifdef ALPHA_CUTOFF
uniform float u_AlphaCutoff;
#endif

uniform vec2 u_MetallicRoughnessValues;
uniform vec4 u_BaseColorFactor;

uniform vec3 u_Camera;
#ifdef PBR_DEBUG
uniform vec4 u_ScaleDiffBaseMR;
uniform vec4 u_ScaleFGDSpec;
#endif

varying vec3 pbr_vPosition;

varying vec2 pbr_vUV;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
#else
varying vec3 pbr_vNormal;
#endif
#endif


struct PBRInfo
{
  float NdotL;
  float NdotV;
  float NdotH;
  float LdotH;
  float VdotH;
  float perceptualRoughness;
  float metalness;
  vec3 reflectance0;
  vec3 reflectance90;
  float alphaRoughness;
  vec3 diffuseColor;
  vec3 specularColor;
  vec3 n;
  vec3 v;
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else
  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif
  return vec4(linOut,srgbIn.w);;
#else
  return srgbIn;
#endif
}

vec3 getNormal()
{
#ifndef HAS_TANGENTS
  vec3 pos_dx = dFdx(pbr_vPosition);
  vec3 pos_dy = dFdy(pbr_vPosition);
  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  vec3 ng = normalize(pbr_vNormal);
#else
  vec3 ng = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  vec3 b = normalize(cross(ng, t));
  mat3 tbn = mat3(t, b, ng);
#else
  mat3 tbn = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}


#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
  float mipCount = 9.0;
  float lod = (pbrInputs.perceptualRoughness * mipCount);
  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,
    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(textureCubeLod(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);
  diffuse *= u_ScaleIBLAmbient.x;
  specular *= u_ScaleIBLAmbient.y;

  return diffuse + specular;
}
#endif


vec3 diffuse(PBRInfo pbrInputs)
{
  return pbrInputs.diffuseColor / M_PI;
}

vec3 specularReflection(PBRInfo pbrInputs)
{
  return pbrInputs.reflectance0 +
    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *
    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}



float geometricOcclusion(PBRInfo pbrInputs)
{
  float NdotL = pbrInputs.NdotL;
  float NdotV = pbrInputs.NdotV;
  float r = pbrInputs.alphaRoughness;

  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}





float microfacetDistribution(PBRInfo pbrInputs)
{
  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
  return roughnessSq / (M_PI * f * f);
}

void PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {
  pbrInputs.NdotL = 1.0;
  pbrInputs.NdotH = 0.0;
  pbrInputs.LdotH = 0.0;
  pbrInputs.VdotH = 1.0;
}

void PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {
  vec3 n = pbrInputs.n;
  vec3 v = pbrInputs.v;
  vec3 l = normalize(lightDirection);
  vec3 h = normalize(l+v);

  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);
  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);
  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);
  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);
}

void PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {
  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInputs, light_direction);
}

vec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {
  vec3 F = specularReflection(pbrInputs);
  float G = geometricOcclusion(pbrInputs);
  float D = microfacetDistribution(pbrInputs);
  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);
  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);
}

vec4 pbr_filterColor(vec4 colorUnused)
{
#ifdef HAS_BASECOLORMAP
  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;
#else
  vec4 baseColor = u_BaseColorFactor;
#endif

#ifdef ALPHA_CUTOFF
  if (baseColor.a < u_AlphaCutoff) {
    discard;
  }
#endif

  vec3 color = vec3(0, 0, 0);

  if(pbr_uUnlit){
    color.rgb = baseColor.rgb;
  }
  else{


    float perceptualRoughness = u_MetallicRoughnessValues.y;
    float metallic = u_MetallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP

    vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
#endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);

    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);



    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();
    vec3 v = normalize(u_Camera - pbr_vPosition);

    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    vec3 reflection = -normalize(reflect(v, n));

    PBRInfo pbrInputs = PBRInfo(
      0.0,
      NdotV,
      0.0,
      0.0,
      0.0,
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );

#ifdef USE_LIGHTS
    PBRInfo_setAmbientLight(pbrInputs);
    color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);
    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {
      if (i < lighting_uDirectionalLightCount) {
        PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);
        color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);
      }
    }
    SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {
      if (i < lighting_uPointLightCount) {
        PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);
        float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
        color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);
      }
    }
#endif
#ifdef USE_IBL
    color += getIBLContribution(pbrInputs, n, reflection);
#endif
#ifdef HAS_OCCLUSIONMAP
    float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;
    color = mix(color, color * ao, u_OcclusionStrength);
#endif

#ifdef HAS_EMISSIVEMAP
    vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;
    color += emissive;
#endif

#ifdef PBR_DEBUG





    color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);
    color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);
    color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);
#endif

  }

  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`, bb = {
  name: "pbr",
  vs: wD,
  fs: AD,
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [yb]
}, TD = `attribute float transform_elementID;
vec2 transform_getPixelSizeHalf(vec2 size) {
  return vec2(1.) / (2. * size);
}

vec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {
  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);
  float xIndex = transform_elementID - (yIndex * texSize[0]);
  return vec2(xIndex, yIndex);
}
vec2 transform_getTexCoord(vec2 size) {
  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);
  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);
  vec2 coord = indices / size + pixelSizeHalf;
  return coord;
}
vec2 transform_getPos(vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);
  return pos;
}
vec4 transform_getInput(sampler2D texSampler, vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  vec4 textureColor = texture2D(texSampler, texCoord);
  return textureColor;
}
`, ED = {
  name: "transform",
  vs: TD,
  fs: null
};
class Zp {
  static getDefaultProgramManager(e) {
    return e.luma = e.luma || {}, e.luma.defaultProgramManager = e.luma.defaultProgramManager || new Zp(e), e.luma.defaultProgramManager;
  }
  constructor(e) {
    this.gl = e, this._programCache = {}, this._getUniforms = {}, this._registeredModules = {}, this._hookFunctions = [], this._defaultModules = [], this._hashes = {}, this._hashCounter = 0, this.stateHash = 0, this._useCounts = {};
  }
  addDefaultModule(e) {
    this._defaultModules.find((t) => t.name === e.name) || this._defaultModules.push(e), this.stateHash++;
  }
  removeDefaultModule(e) {
    const t = typeof e == "string" ? e : e.name;
    this._defaultModules = this._defaultModules.filter((i) => i.name !== t), this.stateHash++;
  }
  addShaderHook(e, t) {
    t && (e = Object.assign(t, {
      hook: e
    })), this._hookFunctions.push(e), this.stateHash++;
  }
  get() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      vs: t = "",
      fs: i = "",
      defines: r = {},
      inject: l = {},
      varyings: c = [],
      bufferMode: a = 35981,
      transpileToGLSL100: g = !1
    } = e, y = this._getModuleList(e.modules), A = this._getHash(t), C = this._getHash(i), I = y.map((de) => this._getHash(de.name)).sort(), S = c.map((de) => this._getHash(de)), F = Object.keys(r).sort(), U = Object.keys(l).sort(), V = [], W = [];
    for (const de of F)
      V.push(this._getHash(de)), V.push(this._getHash(r[de]));
    for (const de of U)
      W.push(this._getHash(de)), W.push(this._getHash(l[de]));
    const X = "".concat(A, "/").concat(C, "D").concat(V.join("/"), "M").concat(I.join("/"), "I").concat(W.join("/"), "V").concat(S.join("/"), "H").concat(this.stateHash, "B").concat(a).concat(g ? "T" : "");
    if (!this._programCache[X]) {
      const de = CO(this.gl, {
        vs: t,
        fs: i,
        modules: y,
        inject: l,
        defines: r,
        hookFunctions: this._hookFunctions,
        transpileToGLSL100: g
      });
      this._programCache[X] = new QT(this.gl, {
        hash: X,
        vs: de.vs,
        fs: de.fs,
        varyings: c,
        bufferMode: a
      }), this._getUniforms[X] = de.getUniforms || ((ie) => {
      }), this._useCounts[X] = 0;
    }
    return this._useCounts[X]++, this._programCache[X];
  }
  getUniforms(e) {
    return this._getUniforms[e.hash] || null;
  }
  release(e) {
    const t = e.hash;
    this._useCounts[t]--, this._useCounts[t] === 0 && (this._programCache[t].delete(), delete this._programCache[t], delete this._getUniforms[t], delete this._useCounts[t]);
  }
  _getHash(e) {
    return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
  }
  _getModuleList() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    const t = new Array(this._defaultModules.length + e.length), i = {};
    let r = 0;
    for (let l = 0, c = this._defaultModules.length; l < c; ++l) {
      const a = this._defaultModules[l], g = a.name;
      t[r++] = a, i[g] = !0;
    }
    for (let l = 0, c = e.length; l < c; ++l) {
      const a = e[l], g = a.name;
      i[g] || (t[r++] = a, i[g] = !0);
    }
    return t.length = r, t;
  }
}
const SD = {
  POSITION: "positions",
  NORMAL: "normals",
  COLOR_0: "colors",
  TEXCOORD_0: "texCoords",
  TEXCOORD_1: "texCoords1",
  TEXCOORD_2: "texCoords2"
};
function CD(n, e, t) {
  const i = {};
  let r = e.indices;
  for (const l in e.attributes) {
    const c = e.attributes[l], a = PD(l);
    if (l === "indices")
      r = c;
    else if (c.constant)
      i[a] = c.value;
    else {
      const g = c.value, y = {
        ...c
      };
      delete y.value, i[a] = [new dr(n, g), y], ID(l, y);
    }
  }
  if (r) {
    const l = r.value || r;
    En(l instanceof Uint16Array || l instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
    const c = {
      size: 1,
      isIndexed: r.isIndexed === void 0 ? !0 : r.isIndexed
    };
    i.indices = [new dr(n, {
      data: l,
      target: 34963
    }), c];
  }
  return i;
}
function PD(n, e) {
  const {
    attributeMap: t = SD
  } = {};
  return t && t[n] || n;
}
function ID(n, e) {
  let t;
  switch (n) {
    case "texCoords":
    case "texCoord1":
    case "texCoord2":
    case "texCoord3":
      t = "uvs";
      break;
    case "vertices":
    case "positions":
    case "normals":
    case "pickingColors":
      t = "vectors";
      break;
  }
  switch (t) {
    case "vectors":
      e.size = e.size || 3;
      break;
    case "uvs":
      e.size = e.size || 2;
      break;
  }
  En(Number.isFinite(e.size), "attribute ".concat(n, " needs size"));
}
const Md = 2, MD = 1e4, LD = "Model needs drawMode and vertexCount", pw = () => {
}, RD = {};
class cf {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      id: i = Ou("model")
    } = t;
    En(Qm(e)), this.id = i, this.gl = e, this.id = t.id || Ou("Model"), this.lastLogTime = 0, this.animated = !1, this.initialize(t);
  }
  initialize(e) {
    this.props = {}, this.programManager = e.programManager || Zp.getDefaultProgramManager(this.gl), this._programManagerState = -1, this._managedProgram = !1;
    const {
      program: t = null,
      vs: i,
      fs: r,
      modules: l,
      defines: c,
      inject: a,
      varyings: g,
      bufferMode: y,
      transpileToGLSL100: A
    } = e;
    this.programProps = {
      program: t,
      vs: i,
      fs: r,
      modules: l,
      defines: c,
      inject: a,
      varyings: g,
      bufferMode: y,
      transpileToGLSL100: A
    }, this.program = null, this.vertexArray = null, this._programDirty = !0, this.userData = {}, this.needsRedraw = !0, this._attributes = {}, this.attributes = {}, this.uniforms = {}, this.pickable = !0, this._checkProgram(), this.setUniforms(Object.assign({}, this.getModuleUniforms(e.moduleSettings))), this.drawMode = e.drawMode !== void 0 ? e.drawMode : 4, this.vertexCount = e.vertexCount || 0, this.geometryBuffers = {}, this.isInstanced = e.isInstanced || e.instanced || e.instanceCount > 0, this._setModelProps(e), this.geometry = {}, En(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), LD);
  }
  setProps(e) {
    this._setModelProps(e);
  }
  delete() {
    for (const e in this._attributes)
      this._attributes[e] !== this.attributes[e] && this._attributes[e].delete();
    this._managedProgram && (this.programManager.release(this.program), this._managedProgram = !1), this.vertexArray.delete(), this._deleteGeometryBuffers();
  }
  getDrawMode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getInstanceCount() {
    return this.instanceCount;
  }
  getAttributes() {
    return this.attributes;
  }
  getProgram() {
    return this.program;
  }
  setProgram(e) {
    const {
      program: t,
      vs: i,
      fs: r,
      modules: l,
      defines: c,
      inject: a,
      varyings: g,
      bufferMode: y,
      transpileToGLSL100: A
    } = e;
    this.programProps = {
      program: t,
      vs: i,
      fs: r,
      modules: l,
      defines: c,
      inject: a,
      varyings: g,
      bufferMode: y,
      transpileToGLSL100: A
    }, this._programDirty = !0;
  }
  getUniforms() {
    return this.uniforms;
  }
  setDrawMode(e) {
    return this.drawMode = e, this;
  }
  setVertexCount(e) {
    return En(Number.isFinite(e)), this.vertexCount = e, this;
  }
  setInstanceCount(e) {
    return En(Number.isFinite(e)), this.instanceCount = e, this;
  }
  setGeometry(e) {
    return this.drawMode = e.drawMode, this.vertexCount = e.getVertexCount(), this._deleteGeometryBuffers(), this.geometryBuffers = CD(this.gl, e), this.vertexArray.setAttributes(this.geometryBuffers), this;
  }
  setAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (of(e))
      return this;
    const t = {};
    for (const i in e) {
      const r = e[i];
      t[i] = r.getValue ? r.getValue() : r;
    }
    return this.vertexArray.setAttributes(t), this;
  }
  setUniforms() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.assign(this.uniforms, e), this;
  }
  getModuleUniforms(e) {
    this._checkProgram();
    const t = this.programManager.getUniforms(this.program);
    return t ? t(e) : {};
  }
  updateModuleSettings(e) {
    const t = this.getModuleUniforms(e || {});
    return this.setUniforms(t);
  }
  clear(e) {
    return sb(this.program.gl, e), this;
  }
  draw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._checkProgram();
    const {
      moduleSettings: t = null,
      framebuffer: i,
      uniforms: r = {},
      attributes: l = {},
      transformFeedback: c = this.transformFeedback,
      parameters: a = {},
      vertexArray: g = this.vertexArray
    } = e;
    this.setAttributes(l), this.updateModuleSettings(t), this.setUniforms(r);
    let y;
    Fn.priority >= Md && (y = this._logDrawCallStart(Md));
    const A = this.vertexArray.getDrawParams(), {
      isIndexed: C = A.isIndexed,
      indexType: I = A.indexType,
      indexOffset: S = A.indexOffset,
      vertexArrayInstanced: F = A.isInstanced
    } = this.props;
    F && !this.isInstanced && Fn.warn("Found instanced attributes on non-instanced model", this.id)();
    const {
      isInstanced: U,
      instanceCount: V
    } = this, {
      onBeforeRender: W = pw,
      onAfterRender: X = pw
    } = this.props;
    W(), this.program.setUniforms(this.uniforms);
    const de = this.program.draw(Object.assign(RD, e, {
      logPriority: y,
      uniforms: null,
      framebuffer: i,
      parameters: a,
      drawMode: this.getDrawMode(),
      vertexCount: this.getVertexCount(),
      vertexArray: g,
      transformFeedback: c,
      isIndexed: C,
      indexType: I,
      isInstanced: U,
      instanceCount: V,
      offset: C ? S : 0
    }));
    return X(), Fn.priority >= Md && this._logDrawCallEnd(y, g, i), de;
  }
  transform() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      discard: t = !0,
      feedbackBuffers: i,
      unbindModels: r = []
    } = e;
    let {
      parameters: l
    } = e;
    i && this._setFeedbackBuffers(i), t && (l = Object.assign({}, l, {
      35977: t
    })), r.forEach((c) => c.vertexArray.unbindBuffers());
    try {
      this.draw(Object.assign({}, e, {
        parameters: l
      }));
    } finally {
      r.forEach((c) => c.vertexArray.bindBuffers());
    }
    return this;
  }
  render() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Fn.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")(), this.setUniforms(e).draw();
  }
  _setModelProps(e) {
    Object.assign(this.props, e), "uniforms" in e && this.setUniforms(e.uniforms), "pickable" in e && (this.pickable = e.pickable), "instanceCount" in e && (this.instanceCount = e.instanceCount), "geometry" in e && this.setGeometry(e.geometry), "attributes" in e && this.setAttributes(e.attributes), "_feedbackBuffers" in e && this._setFeedbackBuffers(e._feedbackBuffers);
  }
  _checkProgram() {
    if (!(this._programDirty || this.programManager.stateHash !== this._programManagerState))
      return;
    let {
      program: t
    } = this.programProps;
    if (t)
      this._managedProgram = !1;
    else {
      const {
        vs: i,
        fs: r,
        modules: l,
        inject: c,
        defines: a,
        varyings: g,
        bufferMode: y,
        transpileToGLSL100: A
      } = this.programProps;
      t = this.programManager.get({
        vs: i,
        fs: r,
        modules: l,
        inject: c,
        defines: a,
        varyings: g,
        bufferMode: y,
        transpileToGLSL100: A
      }), this.program && this._managedProgram && this.programManager.release(this.program), this._programManagerState = this.programManager.stateHash, this._managedProgram = !0;
    }
    En(t instanceof QT, "Model needs a program"), this._programDirty = !1, t !== this.program && (this.program = t, this.vertexArray ? this.vertexArray.setProps({
      program: this.program,
      attributes: this.vertexArray.attributes
    }) : this.vertexArray = new G4(this.gl, {
      program: this.program
    }), this.setUniforms(Object.assign({}, this.getModuleUniforms())));
  }
  _deleteGeometryBuffers() {
    for (const e in this.geometryBuffers) {
      const t = this.geometryBuffers[e][0] || this.geometryBuffers[e];
      t instanceof dr && t.delete();
    }
  }
  _setAnimationProps(e) {
    this.animated && En(e, "Model.draw(): animated uniforms but no animationProps");
  }
  _setFeedbackBuffers() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (of(e))
      return this;
    const {
      gl: t
    } = this.program;
    return this.transformFeedback = this.transformFeedback || new eE(t, {
      program: this.program
    }), this.transformFeedback.setBuffers(e), this;
  }
  _logDrawCallStart(e) {
    const t = e > 3 ? 0 : MD;
    if (!(Date.now() - this.lastLogTime < t))
      return this.lastLogTime = Date.now(), Fn.group(Md, ">>> DRAWING MODEL ".concat(this.id), {
        collapsed: Fn.level <= 2
      })(), e;
  }
  _logDrawCallEnd(e, t, i, r) {
    if (e === void 0)
      return;
    const l = H4({
      vertexArray: t,
      header: "".concat(this.id, " attributes"),
      attributes: this._attributes
    }), {
      table: c,
      unusedTable: a,
      unusedCount: g
    } = Xx({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, i)
    }), {
      table: y,
      count: A
    } = Xx({
      header: "".concat(this.id, " uniforms"),
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, i),
      undefinedOnly: !0
    });
    A > 0 && Fn.log("MISSING UNIFORMS", Object.keys(y))(), g > 0 && Fn.log("UNUSED UNIFORMS", Object.keys(a))();
    const C = Z4(this.vertexArray.configuration);
    Fn.table(e, l)(), Fn.table(e, c)(), Fn.table(e + 1, C)(), r && r.log({
      logLevel: Md,
      message: "Rendered to ".concat(r.id)
    }), Fn.groupEnd(Md)();
  }
}
class BD {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.currentIndex = 0, this.feedbackMap = {}, this.varyings = null, this.bindings = [], this.resources = {}, this._initialize(t), Object.seal(this);
  }
  setupResources(e) {
    for (const t of this.bindings)
      this._setupTransformFeedback(t, e);
  }
  updateModelProps() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      varyings: t
    } = this;
    return t.length > 0 && (e = Object.assign({}, e, {
      varyings: t
    })), e;
  }
  getDrawOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this.bindings[this.currentIndex], {
      sourceBuffers: i,
      transformFeedback: r
    } = t;
    return {
      attributes: Object.assign({}, i, e.attributes),
      transformFeedback: r
    };
  }
  swap() {
    return this.feedbackMap ? (this.currentIndex = this._getNextIndex(), !0) : !1;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupBuffers(e);
  }
  getBuffer(e) {
    const {
      feedbackBuffers: t
    } = this.bindings[this.currentIndex], i = e ? t[e] : null;
    return i ? i instanceof dr ? i : i.buffer : null;
  }
  getData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      varyingName: t
    } = e, i = this.getBuffer(t);
    return i ? i.getData() : null;
  }
  delete() {
    for (const e in this.resources)
      this.resources[e].delete();
  }
  _initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupBuffers(e), this.varyings = e.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers), this.varyings.length > 0 && En(Si(this.gl));
  }
  _getFeedbackBuffers(e) {
    const {
      sourceBuffers: t = {}
    } = e, i = {};
    if (this.bindings[this.currentIndex] && Object.assign(i, this.bindings[this.currentIndex].feedbackBuffers), this.feedbackMap)
      for (const r in this.feedbackMap) {
        const l = this.feedbackMap[r];
        r in t && (i[l] = r);
      }
    Object.assign(i, e.feedbackBuffers);
    for (const r in i) {
      const l = i[r];
      if (typeof l == "string") {
        const c = t[l], {
          byteLength: a,
          usage: g,
          accessor: y
        } = c;
        i[r] = this._createNewBuffer(r, {
          byteLength: a,
          usage: g,
          accessor: y
        });
      }
    }
    return i;
  }
  _setupBuffers() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers: t = null
    } = e;
    Object.assign(this.feedbackMap, e.feedbackMap);
    const i = this._getFeedbackBuffers(e);
    this._updateBindings({
      sourceBuffers: t,
      feedbackBuffers: i
    });
  }
  _setupTransformFeedback(e, t) {
    let {
      model: i
    } = t;
    const {
      program: r
    } = i;
    e.transformFeedback = new eE(this.gl, {
      program: r,
      buffers: e.feedbackBuffers
    });
  }
  _updateBindings(e) {
    if (this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], e), this.feedbackMap) {
      const {
        sourceBuffers: t,
        feedbackBuffers: i
      } = this._swapBuffers(this.bindings[this.currentIndex]), r = this._getNextIndex();
      this.bindings[r] = this._updateBinding(this.bindings[r], {
        sourceBuffers: t,
        feedbackBuffers: i
      });
    }
  }
  _updateBinding(e, t) {
    return e ? (Object.assign(e.sourceBuffers, t.sourceBuffers), Object.assign(e.feedbackBuffers, t.feedbackBuffers), e.transformFeedback && e.transformFeedback.setBuffers(e.feedbackBuffers), e) : {
      sourceBuffers: Object.assign({}, t.sourceBuffers),
      feedbackBuffers: Object.assign({}, t.feedbackBuffers)
    };
  }
  _swapBuffers(e) {
    if (!this.feedbackMap)
      return null;
    const t = Object.assign({}, e.sourceBuffers), i = Object.assign({}, e.feedbackBuffers);
    for (const r in this.feedbackMap) {
      const l = this.feedbackMap[r];
      t[r] = e.feedbackBuffers[l], i[l] = e.sourceBuffers[r], En(i[l] instanceof dr);
    }
    return {
      sourceBuffers: t,
      feedbackBuffers: i
    };
  }
  _createNewBuffer(e, t) {
    const i = new dr(this.gl, t);
    return this.resources[e] && this.resources[e].delete(), this.resources[e] = i, i;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
}
const OD = "transform_uSampler_", Om = "transform_uSize_", gw = "transform_position";
function DD(n) {
  let {
    vs: e,
    sourceTextureMap: t,
    targetTextureVarying: i,
    targetTexture: r
  } = n, c = Object.keys(t).length, a = null;
  const g = {};
  let y = e, A = {};
  if (c > 0 || i) {
    const C = y.split(`
`), I = C.slice();
    if (C.forEach((S, F, U) => {
      if (c > 0) {
        const V = UD(S, t);
        if (V) {
          const {
            updatedLine: W,
            inject: X
          } = V;
          I[F] = W, A = Wy([A, X]), Object.assign(g, V.samplerTextureMap), c--;
        }
      }
      i && !a && (a = zD(S, i));
    }), i) {
      En(r);
      const S = "".concat(Om).concat(i), F = "uniform vec2 ".concat(S, `;
`), U = "     vec2 ".concat(gw, " = transform_getPos(").concat(S, `);
     gl_Position = vec4(`).concat(gw, `, 0, 1.);
`);
      A = Wy([A, {
        "vs:#decl": F,
        "vs:#main-start": U
      }]);
    }
    y = I.join(`
`);
  }
  return {
    vs: y,
    targetTextureType: a,
    inject: A,
    samplerTextureMap: g
  };
}
function FD(n) {
  let {
    sourceTextureMap: e,
    targetTextureVarying: t,
    targetTexture: i
  } = n;
  const r = {};
  let l, c;
  t && ({
    width: l,
    height: c
  } = i, r["".concat(Om).concat(t)] = [l, c]);
  for (const a in e)
    ({
      width: l,
      height: c
    } = e[a]), r["".concat(Om).concat(a)] = [l, c];
  return r;
}
function ND(n) {
  return aE(n, ["attribute", "in"]);
}
function kD(n) {
  const e = "".concat(OD).concat(n), t = "".concat(Om).concat(n), i = "  uniform sampler2D ".concat(e, `;
  uniform vec2 `).concat(t, ";");
  return {
    samplerName: e,
    sizeName: t,
    uniformDeclerations: i
  };
}
function zD(n, e) {
  const t = aE(n, ["varying", "out"]);
  return t && t.name === e ? t.type : null;
}
function UD(n, e) {
  const t = {}, i = ND(n);
  if (!i)
    return null;
  const {
    type: r,
    name: l
  } = i;
  if (l && e[l]) {
    const c = "// ".concat(n, " => Replaced by Transform with a sampler"), {
      samplerName: a,
      sizeName: g,
      uniformDeclerations: y
    } = kD(l), A = FO(r), C = "  ".concat(r, " ").concat(l, " = transform_getInput(").concat(a, ", ").concat(g, ").").concat(A, `;
`);
    return t[a] = l, {
      updatedLine: c,
      inject: {
        "vs:#decl": y,
        "vs:#main-start": C
      },
      samplerTextureMap: t
    };
  }
  return null;
}
const jD = {
  10241: 9728,
  10240: 9728,
  10242: 33071,
  10243: 33071
}, GD = "transform_output";
class VD {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.id = this.currentIndex = 0, this._swapTexture = null, this.targetTextureVarying = null, this.targetTextureType = null, this.samplerTextureMap = null, this.bindings = [], this.resources = {}, this._initialize(t), Object.seal(this);
  }
  updateModelProps() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this._processVertexShader(e);
    return Object.assign({}, e, t);
  }
  getDrawOptions() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers: t,
      sourceTextures: i,
      framebuffer: r,
      targetTexture: l
    } = this.bindings[this.currentIndex], c = Object.assign({}, t, e.attributes), a = Object.assign({}, e.uniforms), g = Object.assign({}, e.parameters);
    let y = e.discard;
    if (this.hasSourceTextures || this.hasTargetTexture) {
      c.transform_elementID = this.elementIDBuffer;
      for (const C in this.samplerTextureMap) {
        const I = this.samplerTextureMap[C];
        a[C] = i[I];
      }
      this._setSourceTextureParameters();
      const A = FD({
        sourceTextureMap: i,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture: l
      });
      Object.assign(a, A);
    }
    return this.hasTargetTexture && (y = !1, g.viewport = [0, 0, r.width, r.height]), {
      attributes: c,
      framebuffer: r,
      uniforms: a,
      discard: y,
      parameters: g
    };
  }
  swap() {
    return this._swapTexture ? (this.currentIndex = this._getNextIndex(), !0) : !1;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this._setupTextures(e);
  }
  getTargetTexture() {
    const {
      targetTexture: e
    } = this.bindings[this.currentIndex];
    return e;
  }
  getData() {
    let {
      packed: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      framebuffer: t
    } = this.bindings[this.currentIndex], i = t_(t);
    if (!e)
      return i;
    const r = i.constructor, l = NO(this.targetTextureType), c = new r(i.length * l / 4);
    let a = 0;
    for (let g = 0; g < i.length; g += 4)
      for (let y = 0; y < l; y++)
        c[a++] = i[g + y];
    return c;
  }
  getFramebuffer() {
    return this.bindings[this.currentIndex].framebuffer;
  }
  delete() {
    this.ownTexture && this.ownTexture.delete(), this.elementIDBuffer && this.elementIDBuffer.delete();
  }
  _initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      _targetTextureVarying: t,
      _swapTexture: i
    } = e;
    this._swapTexture = i, this.targetTextureVarying = t, this.hasTargetTexture = t, this._setupTextures(e);
  }
  _createTargetTexture(e) {
    const {
      sourceTextures: t,
      textureOrReference: i
    } = e;
    if (i instanceof rl)
      return i;
    const r = t[i];
    return r ? (this._targetRefTexName = i, this._createNewTexture(r)) : null;
  }
  _setupTextures() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceBuffers: t,
      _sourceTextures: i = {},
      _targetTexture: r
    } = e, l = this._createTargetTexture({
      sourceTextures: i,
      textureOrReference: r
    });
    this.hasSourceTextures = this.hasSourceTextures || i && Object.keys(i).length > 0, this._updateBindings({
      sourceBuffers: t,
      sourceTextures: i,
      targetTexture: l
    }), "elementCount" in e && this._updateElementIDBuffer(e.elementCount);
  }
  _updateElementIDBuffer(e) {
    if (typeof e != "number" || this.elementCount >= e)
      return;
    const t = new Float32Array(e);
    t.forEach((i, r, l) => {
      l[r] = r;
    }), this.elementIDBuffer ? this.elementIDBuffer.setData({
      data: t
    }) : this.elementIDBuffer = new dr(this.gl, {
      data: t,
      accessor: {
        size: 1
      }
    }), this.elementCount = e;
  }
  _updateBindings(e) {
    if (this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], e), this._swapTexture) {
      const {
        sourceTextures: t,
        targetTexture: i
      } = this._swapTextures(this.bindings[this.currentIndex]), r = this._getNextIndex();
      this.bindings[r] = this._updateBinding(this.bindings[r], {
        sourceTextures: t,
        targetTexture: i
      });
    }
  }
  _updateBinding(e, t) {
    const {
      sourceBuffers: i,
      sourceTextures: r,
      targetTexture: l
    } = t;
    if (e || (e = {
      sourceBuffers: {},
      sourceTextures: {},
      targetTexture: null
    }), Object.assign(e.sourceTextures, r), Object.assign(e.sourceBuffers, i), l) {
      e.targetTexture = l;
      const {
        width: c,
        height: a
      } = l, {
        framebuffer: g
      } = e;
      g ? (g.update({
        attachments: {
          36064: l
        },
        resizeAttachments: !1
      }), g.resize({
        width: c,
        height: a
      })) : e.framebuffer = new Vs(this.gl, {
        id: "transform-framebuffer",
        width: c,
        height: a,
        attachments: {
          36064: l
        }
      });
    }
    return e;
  }
  _setSourceTextureParameters() {
    const e = this.currentIndex, {
      sourceTextures: t
    } = this.bindings[e];
    for (const i in t)
      t[i].setParameters(jD);
  }
  _swapTextures(e) {
    if (!this._swapTexture)
      return null;
    const t = Object.assign({}, e.sourceTextures);
    t[this._swapTexture] = e.targetTexture;
    const i = e.sourceTextures[this._swapTexture];
    return {
      sourceTextures: t,
      targetTexture: i
    };
  }
  _createNewTexture(e) {
    const t = LB(e, {
      parameters: {
        10241: 9728,
        10240: 9728,
        10242: 33071,
        10243: 33071
      },
      pixelStore: {
        37440: !1
      }
    });
    return this.ownTexture && this.ownTexture.delete(), this.ownTexture = t, t;
  }
  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
  _processVertexShader() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      sourceTextures: t,
      targetTexture: i
    } = this.bindings[this.currentIndex], {
      vs: r,
      uniforms: l,
      targetTextureType: c,
      inject: a,
      samplerTextureMap: g
    } = DD({
      vs: e.vs,
      sourceTextureMap: t,
      targetTextureVarying: this.targetTextureVarying,
      targetTexture: i
    }), y = Wy([e.inject || {}, a]);
    this.targetTextureType = c, this.samplerTextureMap = g;
    const A = e._fs || lE({
      version: JT(r),
      input: this.targetTextureVarying,
      inputType: c,
      output: GD
    }), C = this.hasSourceTextures || this.targetTextureVarying ? [ED].concat(e.modules || []) : e.modules;
    return {
      vs: r,
      fs: A,
      modules: C,
      uniforms: l,
      inject: y
    };
  }
}
class vb {
  static isSupported(e) {
    return Si(e);
  }
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.model = null, this.elementCount = 0, this.bufferTransform = null, this.textureTransform = null, this.elementIDBuffer = null, this._initialize(t), Object.seal(this);
  }
  delete() {
    const {
      model: e,
      bufferTransform: t,
      textureTransform: i
    } = this;
    e && e.delete(), t && t.delete(), i && i.delete();
  }
  run() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      clearRenderTarget: t = !0
    } = e, i = this._updateDrawOptions(e);
    t && i.framebuffer && i.framebuffer.clear({
      color: !0
    }), this.model.transform(i);
  }
  swap() {
    let e = !1;
    const t = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const i of t)
      e = e || i.swap();
    En(e, "Nothing to swap");
  }
  getBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return this.bufferTransform && this.bufferTransform.getBuffer(e);
  }
  getData() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const i of t) {
      const r = i.getData(e);
      if (r)
        return r;
    }
    return null;
  }
  getFramebuffer() {
    return this.textureTransform && this.textureTransform.getFramebuffer();
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    "elementCount" in e && this.model.setVertexCount(e.elementCount);
    const t = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const i of t)
      i.update(e);
  }
  _initialize() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      gl: t
    } = this;
    this._buildResourceTransforms(t, e), e = this._updateModelProps(e), this.model = new cf(t, Object.assign({}, e, {
      fs: e.fs || lE({
        version: JT(e.vs)
      }),
      id: e.id || "transform-model",
      drawMode: e.drawMode || 0,
      vertexCount: e.elementCount
    })), this.bufferTransform && this.bufferTransform.setupResources({
      model: this.model
    });
  }
  _updateModelProps(e) {
    let t = Object.assign({}, e);
    const i = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const r of i)
      t = r.updateModelProps(t);
    return t;
  }
  _buildResourceTransforms(e, t) {
    qD(t) && (this.bufferTransform = new BD(e, t)), HD(t) && (this.textureTransform = new VD(e, t)), En(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
  }
  _updateDrawOptions(e) {
    let t = Object.assign({}, e);
    const i = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const r of i)
      t = Object.assign(t, r.getDrawOptions(t));
    return t;
  }
}
function qD(n) {
  return !!(!of(n.feedbackBuffers) || !of(n.feedbackMap) || n.varyings && n.varyings.length > 0);
}
function HD(n) {
  return !!(!of(n._sourceTextures) || n._targetTexture || n._targetTextureVarying);
}
const mw = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
};
class xp {
  static get DRAW_MODE() {
    return mw;
  }
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      id: t = Ou("geometry"),
      drawMode: i = mw.TRIANGLES,
      attributes: r = {},
      indices: l = null,
      vertexCount: c = null
    } = e;
    this.id = t, this.drawMode = i | 0, this.attributes = {}, this.userData = {}, this._setAttributes(r, l), this.vertexCount = c || this._calculateVertexCount(this.attributes, this.indices);
  }
  get mode() {
    return this.drawMode;
  }
  getVertexCount() {
    return this.vertexCount;
  }
  getAttributes() {
    return this.indices ? {
      indices: this.indices,
      ...this.attributes
    } : this.attributes;
  }
  _print(e) {
    return "Geometry ".concat(this.id, " attribute ").concat(e);
  }
  _setAttributes(e, t) {
    t && (this.indices = ArrayBuffer.isView(t) ? {
      value: t,
      size: 1
    } : t);
    for (const i in e) {
      let r = e[i];
      r = ArrayBuffer.isView(r) ? {
        value: r
      } : r, En(ArrayBuffer.isView(r.value), "".concat(this._print(i), ": must be typed array or object with value as typed array")), (i === "POSITION" || i === "positions") && !r.size && (r.size = 3), i === "indices" ? (En(!this.indices), this.indices = r) : this.attributes[i] = r;
    }
    return this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this;
  }
  _calculateVertexCount(e, t) {
    if (t)
      return t.value.length;
    let i = 1 / 0;
    for (const r in e) {
      const l = e[r], {
        value: c,
        size: a,
        constant: g
      } = l;
      !g && c && a >= 1 && (i = Math.min(i, c.length / a));
    }
    return En(Number.isFinite(i)), i;
  }
}
let WD = 1, ZD = 1;
class IE {
  constructor() {
    this.time = 0, this.channels = /* @__PURE__ */ new Map(), this.animations = /* @__PURE__ */ new Map(), this.playing = !1, this.lastEngineTime = -1;
  }
  addChannel(e) {
    const {
      delay: t = 0,
      duration: i = Number.POSITIVE_INFINITY,
      rate: r = 1,
      repeat: l = 1
    } = e, c = WD++, a = {
      time: 0,
      delay: t,
      duration: i,
      rate: r,
      repeat: l
    };
    return this._setChannelTime(a, this.time), this.channels.set(c, a), c;
  }
  removeChannel(e) {
    this.channels.delete(e);
    for (const [t, i] of this.animations)
      i.channel === e && this.detachAnimation(t);
  }
  isFinished(e) {
    const t = this.channels.get(e);
    return t === void 0 ? !1 : this.time >= t.delay + t.duration * t.repeat;
  }
  getTime(e) {
    if (e === void 0)
      return this.time;
    const t = this.channels.get(e);
    return t === void 0 ? -1 : t.time;
  }
  setTime(e) {
    this.time = Math.max(0, e);
    const t = this.channels.values();
    for (const r of t)
      this._setChannelTime(r, this.time);
    const i = this.animations.values();
    for (const r of i) {
      const {
        animation: l,
        channel: c
      } = r;
      l.setTime(this.getTime(c));
    }
  }
  play() {
    this.playing = !0;
  }
  pause() {
    this.playing = !1, this.lastEngineTime = -1;
  }
  reset() {
    this.setTime(0);
  }
  attachAnimation(e, t) {
    const i = ZD++;
    return this.animations.set(i, {
      animation: e,
      channel: t
    }), e.setTime(this.getTime(t)), i;
  }
  detachAnimation(e) {
    this.animations.delete(e);
  }
  update(e) {
    this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
  }
  _setChannelTime(e, t) {
    const i = t - e.delay, r = e.duration * e.repeat;
    i >= r ? e.time = e.duration * e.rate : (e.time = Math.max(0, i) % e.duration, e.time *= e.rate);
  }
}
const $D = [255, 255, 255], XD = 1;
let YD = 0;
class ME {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    H(this, "id", void 0), H(this, "color", void 0), H(this, "intensity", void 0), H(this, "type", "ambient");
    const {
      color: t = $D
    } = e, {
      intensity: i = XD
    } = e;
    this.id = e.id || "ambient-".concat(YD++), this.color = t, this.intensity = i;
  }
}
const JD = [255, 255, 255], KD = 1, QD = [0, 0, -1];
let eF = 0;
class _w {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    H(this, "id", void 0), H(this, "color", void 0), H(this, "intensity", void 0), H(this, "type", "directional"), H(this, "direction", void 0), H(this, "shadow", void 0);
    const {
      color: t = JD
    } = e, {
      intensity: i = KD
    } = e, {
      direction: r = QD
    } = e, {
      _shadow: l = !1
    } = e;
    this.id = e.id || "directional-".concat(eF++), this.color = t, this.intensity = i, this.type = "directional", this.direction = new Tt(r).normalize().toArray(), this.shadow = l;
  }
  getProjectedLight(e) {
    return this;
  }
}
class tF {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      id: "pass"
    };
    H(this, "id", void 0), H(this, "gl", void 0), H(this, "props", void 0);
    const {
      id: i
    } = t;
    this.id = i, this.gl = e, this.props = {
      ...t
    };
  }
  setProps(e) {
    Object.assign(this.props, e);
  }
  render(e) {
  }
  cleanup() {
  }
}
class xb extends tF {
  constructor() {
    super(...arguments), H(this, "_lastRenderIndex", -1);
  }
  render(e) {
    const t = this.gl;
    return Bu(t, {
      framebuffer: e.target
    }), this._drawLayers(e);
  }
  _drawLayers(e) {
    const {
      target: t,
      moduleParameters: i,
      viewports: r,
      views: l,
      onViewportActive: c,
      clearStack: a = !0,
      clearCanvas: g = !0
    } = e;
    e.pass = e.pass || "unknown";
    const y = this.gl;
    g && iF(y, t), a && (this._lastRenderIndex = -1);
    const A = [];
    for (const C of r) {
      const I = l && l[C.id];
      c == null || c(C);
      const S = this._getDrawLayerParams(C, e), F = C.subViewports || [C];
      for (const U of F) {
        const V = this._drawLayersInViewport(y, {
          target: t,
          moduleParameters: i,
          viewport: U,
          view: I,
          pass: e.pass,
          layers: e.layers
        }, S);
        A.push(V);
      }
    }
    return A;
  }
  _getDrawLayerParams(e, t) {
    let {
      layers: i,
      pass: r,
      isPicking: l = !1,
      layerFilter: c,
      cullRect: a,
      effects: g,
      moduleParameters: y
    } = t, A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const C = [], I = LE(this._lastRenderIndex + 1), S = {
      layer: i[0],
      viewport: e,
      isPicking: l,
      renderPass: r,
      cullRect: a
    }, F = {};
    for (let U = 0; U < i.length; U++) {
      const V = i[U], W = this._shouldDrawLayer(V, S, c, F), X = {
        shouldDrawLayer: W
      };
      W && !A && (X.layerRenderIndex = I(V, W), X.moduleParameters = this._getModuleParameters(V, g, r, y), X.layerParameters = this.getLayerParameters(V, U, e)), C[U] = X;
    }
    return C;
  }
  _drawLayersInViewport(e, t, i) {
    let {
      layers: r,
      moduleParameters: l,
      pass: c,
      target: a,
      viewport: g,
      view: y
    } = t;
    const A = nF(e, {
      moduleParameters: l,
      target: a,
      viewport: g
    });
    if (y && y.props.clear) {
      const I = y.props.clear === !0 ? {
        color: !0,
        depth: !0
      } : y.props.clear;
      yc(e, {
        scissorTest: !0,
        scissor: A
      }, () => sb(e, I));
    }
    const C = {
      totalCount: r.length,
      visibleCount: 0,
      compositeCount: 0,
      pickableCount: 0
    };
    Bu(e, {
      viewport: A
    });
    for (let I = 0; I < r.length; I++) {
      const S = r[I], {
        shouldDrawLayer: F,
        layerRenderIndex: U,
        moduleParameters: V,
        layerParameters: W
      } = i[I];
      if (F && S.props.pickable && C.pickableCount++, S.isComposite)
        C.compositeCount++;
      else if (F) {
        C.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, U), V.viewport = g;
        try {
          S._drawLayer({
            moduleParameters: V,
            uniforms: {
              layerIndex: U
            },
            parameters: W
          });
        } catch (X) {
          S.raiseError(X, "drawing ".concat(S, " to ").concat(c));
        }
      }
    }
    return C;
  }
  shouldDrawLayer(e) {
    return !0;
  }
  getModuleParameters(e, t) {
    return null;
  }
  getLayerParameters(e, t, i) {
    return e.props.parameters;
  }
  _shouldDrawLayer(e, t, i, r) {
    if (!(e.props.visible && this.shouldDrawLayer(e)))
      return !1;
    t.layer = e;
    let c = e.parent;
    for (; c; ) {
      if (!c.props.visible || !c.filterSubLayer(t))
        return !1;
      t.layer = c, c = c.parent;
    }
    if (i) {
      const a = t.layer.id;
      if (a in r || (r[a] = i(t)), !r[a])
        return !1;
    }
    return e.activateViewport(t.viewport), !0;
  }
  _getModuleParameters(e, t, i, r) {
    var l;
    const c = Object.assign(Object.create(((l = e.internalState) === null || l === void 0 ? void 0 : l.propsInTransition) || e.props), {
      autoWrapLongitude: e.wrapLongitude,
      viewport: e.context.viewport,
      mousePosition: e.context.mousePosition,
      pickingActive: 0,
      devicePixelRatio: sf(this.gl)
    });
    if (t)
      for (const g of t) {
        var a;
        Object.assign(c, (a = g.getModuleParameters) === null || a === void 0 ? void 0 : a.call(g, e));
      }
    return Object.assign(c, this.getModuleParameters(e, t), r);
  }
}
function LE() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = {}, i = (r, l) => {
    const c = r.props._offset, a = r.id, g = r.parent && r.parent.id;
    let y;
    if (g && !(g in e) && i(r.parent, !1), g in t) {
      const A = t[g] = t[g] || LE(e[g], e);
      y = A(r, l), t[a] = A;
    } else Number.isFinite(c) ? (y = c + (e[g] || 0), t[a] = null) : y = n;
    return l && y >= n && (n = y + 1), e[a] = y, y;
  };
  return i;
}
function nF(n, e) {
  let {
    moduleParameters: t,
    target: i,
    viewport: r
  } = e;
  const l = i && i.id !== "default-framebuffer", c = t && t.devicePixelRatio || sf(n), a = l ? i.height : n.drawingBufferHeight, g = r;
  return [g.x * c, a - (g.y + g.height) * c, g.width * c, g.height * c];
}
function iF(n, e) {
  const t = e ? e.width : n.drawingBufferWidth, i = e ? e.height : n.drawingBufferHeight;
  Bu(n, {
    viewport: [0, 0, t, i]
  }), n.clear(16640);
}
class rF extends xb {
  constructor(e, t) {
    super(e, t), H(this, "shadowMap", void 0), H(this, "depthBuffer", void 0), H(this, "fbo", void 0), this.shadowMap = new rl(e, {
      width: 1,
      height: 1,
      parameters: {
        10241: 9729,
        10240: 9729,
        10242: 33071,
        10243: 33071
      }
    }), this.depthBuffer = new Gd(e, {
      format: 33189,
      width: 1,
      height: 1
    }), this.fbo = new Vs(e, {
      id: "shadowmap",
      width: 1,
      height: 1,
      attachments: {
        36064: this.shadowMap,
        36096: this.depthBuffer
      }
    });
  }
  render(e) {
    const t = this.fbo;
    yc(this.gl, {
      depthRange: [0, 1],
      depthTest: !0,
      blend: !1,
      clearColor: [1, 1, 1, 1]
    }, () => {
      const i = e.viewports[0], r = sf(this.gl), l = i.width * r, c = i.height * r;
      (l !== t.width || c !== t.height) && t.resize({
        width: l,
        height: c
      }), super.render({
        ...e,
        target: t,
        pass: "shadow"
      });
    });
  }
  shouldDrawLayer(e) {
    return e.props.shadowEnabled !== !1;
  }
  getModuleParameters() {
    return {
      drawToShadowMap: !0
    };
  }
  delete() {
    this.fbo && (this.fbo.delete(), this.fbo = null), this.shadowMap && (this.shadowMap.delete(), this.shadowMap = null), this.depthBuffer && (this.depthBuffer.delete(), this.depthBuffer = null);
  }
}
const RE = "#define SMOOTH_EDGE_RADIUS 0.5", sF = `
`.concat(RE, `

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`), oF = `
`.concat(RE, `

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`), aF = {
  name: "geometry",
  vs: sF,
  fs: oF
}, lF = Object.keys(Bi).map((n) => "const int COORDINATE_SYSTEM_".concat(n, " = ").concat(Bi[n], ";")).join(""), cF = Object.keys(Jc).map((n) => "const int PROJECTION_MODE_".concat(n, " = ").concat(Jc[n], ";")).join(""), uF = Object.keys(jy).map((n) => "const int UNIT_".concat(n.toUpperCase(), " = ").concat(jy[n], ";")).join(""), hF = "".concat(lF, `
`).concat(cF, `
`).concat(uF, `

uniform int project_uCoordinateSystem;
uniform int project_uProjectionMode;
uniform float project_uScale;
uniform bool project_uWrapLongitude;
uniform vec3 project_uCommonUnitsPerMeter;
uniform vec3 project_uCommonUnitsPerWorldUnit;
uniform vec3 project_uCommonUnitsPerWorldUnit2;
uniform vec4 project_uCenter;
uniform mat4 project_uModelMatrix;
uniform mat4 project_uViewProjectionMatrix;
uniform vec2 project_uViewportSize;
uniform float project_uDevicePixelRatio;
uniform float project_uFocalDistance;
uniform vec3 project_uCameraPosition;
uniform vec3 project_uCoordinateOrigin;
uniform vec3 project_uCommonOrigin;
uniform bool project_uPseudoMeters;

const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
  float y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

float project_size() {
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&
    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
    project_uPseudoMeters == false) {
    
    if (geometry.position.w == 0.0) {
      return project_size_at_latitude(geometry.worldPosition.y);
    }
  
    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    float y2 = y * y;
    float y4 = y2 * y2;
    float y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

float project_size_at_latitude(float meters, float lat) {
  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
  return meters * project_uCommonUnitsPerMeter.z * project_size();
}

vec2 project_size(vec2 meters) {
  return meters * project_uCommonUnitsPerMeter.xy * project_size();
}

vec3 project_size(vec3 meters) {
  return meters * project_uCommonUnitsPerMeter * project_size();
}

vec4 project_size(vec4 meters) {
  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
  vec3 uz = normalize(up);
  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
  vec3 uy = cross(uz, ux);
  return mat3(ux, uy, uz);
}

bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    transform = project_get_orientation_matrix(commonPosition);
    return true;
  }
  return false;
}
vec3 project_normal(vec3 vector) {
  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);
  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);
  mat3 rotation;
  if (project_needs_rotation(geometry.position.xyz, rotation)) {
    n = rotation * n;
  }
  return n;
}

vec4 project_offset_(vec4 offset) {
  float dy = offset.y;
  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;
  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
  float x = lnglat.x;
  if (project_uWrapLongitude) {
    x = mod(x + 180., 360.0) - 180.;
  }
  float y = clamp(lnglat.y, -89.9, 89.9);
  return vec2(
    radians(x) + PI,
    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

vec3 project_globe_(vec3 lnglatz) {
  float lambda = radians(lnglatz.x);
  float phi = radians(lnglatz.y);
  float cosPhi = cos(phi);
  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;

  return vec3(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
  vec4 position_world = project_uModelMatrix * position;
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_mercator_(position_world.xy),
        project_size_at_latitude(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world.xyz += project_uCoordinateOrigin;
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {
        return vec4(
          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,
          project_size(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||
    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world.xyz -= project_uCoordinateOrigin;
  }
  return project_offset_(position_world) + project_offset_(project_uModelMatrix * vec4(position64Low, 0.0));
}

vec4 project_position(vec4 position) {
  return project_position(position, ZERO_64_LOW);
}

vec3 project_position(vec3 position, vec3 position64Low) {
  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
  return projected_position.xyz;
}

vec3 project_position(vec3 position) {
  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

vec2 project_position(vec2 position) {
  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
  return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;
  return offset * project_uFocalDistance;
}

float project_size_to_pixel(float meters) {
  return project_size(meters) * project_uScale;
}
float project_size_to_pixel(float size, int unit) {
  if (unit == UNIT_METERS) return project_size_to_pixel(size);
  if (unit == UNIT_COMMON) return size * project_uScale;
  return size;
}
float project_pixel_size(float pixels) {
  return pixels / project_uScale;
}
vec2 project_pixel_size(vec2 pixels) {
  return pixels / project_uScale;
}
`);
function dF(n, e) {
  if (n === e)
    return !0;
  if (Array.isArray(n)) {
    const t = n.length;
    if (!e || e.length !== t)
      return !1;
    for (let i = 0; i < t; i++)
      if (n[i] !== e[i])
        return !1;
    return !0;
  }
  return !1;
}
function $p(n) {
  let e = {}, t;
  return (i) => {
    for (const r in i)
      if (!dF(i[r], e[r])) {
        t = n(i), e = i;
        break;
      }
    return t;
  };
}
const yw = [0, 0, 0, 0], fF = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], BE = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], pF = [0, 0, 0], OE = [0, 0, 0], gF = $p(yF);
function DE(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : OE;
  t.length < 3 && (t = [t[0], t[1], 0]);
  let i = t, r, l = !0;
  switch (e === Bi.LNGLAT_OFFSETS || e === Bi.METER_OFFSETS ? r = t : r = n.isGeospatial ? [Math.fround(n.longitude), Math.fround(n.latitude), 0] : null, n.projectionMode) {
    case Jc.WEB_MERCATOR:
      (e === Bi.LNGLAT || e === Bi.CARTESIAN) && (r = [0, 0, 0], l = !1);
      break;
    case Jc.WEB_MERCATOR_AUTO_OFFSET:
      e === Bi.LNGLAT ? i = r : e === Bi.CARTESIAN && (i = [Math.fround(n.center[0]), Math.fround(n.center[1]), 0], r = n.unprojectPosition(i), i[0] -= t[0], i[1] -= t[1], i[2] -= t[2]);
      break;
    case Jc.IDENTITY:
      i = n.position.map(Math.fround), i[2] = i[2] || 0;
      break;
    case Jc.GLOBE:
      l = !1, r = null;
      break;
    default:
      l = !1;
  }
  return {
    geospatialOrigin: r,
    shaderCoordinateOrigin: i,
    offsetMode: l
  };
}
function mF(n, e, t) {
  const {
    viewMatrixUncentered: i,
    projectionMatrix: r
  } = n;
  let {
    viewMatrix: l,
    viewProjectionMatrix: c
  } = n, a = yw, g = yw, y = n.cameraPosition;
  const {
    geospatialOrigin: A,
    shaderCoordinateOrigin: C,
    offsetMode: I
  } = DE(n, e, t);
  return I && (g = n.projectPosition(A || C), y = [y[0] - g[0], y[1] - g[1], y[2] - g[2]], g[3] = 1, a = Wp([], g, c), l = i || l, c = $h([], r, l), c = $h([], c, fF)), {
    viewMatrix: l,
    viewProjectionMatrix: c,
    projectionCenter: a,
    originCommon: g,
    cameraPosCommon: y,
    shaderCoordinateOrigin: C,
    geospatialOrigin: A
  };
}
function _F(n) {
  let {
    viewport: e,
    devicePixelRatio: t = 1,
    modelMatrix: i = null,
    coordinateSystem: r = Bi.DEFAULT,
    coordinateOrigin: l = OE,
    autoWrapLongitude: c = !1
  } = n;
  r === Bi.DEFAULT && (r = e.isGeospatial ? Bi.LNGLAT : Bi.CARTESIAN);
  const a = gF({
    viewport: e,
    devicePixelRatio: t,
    coordinateSystem: r,
    coordinateOrigin: l
  });
  return a.project_uWrapLongitude = c, a.project_uModelMatrix = i || BE, a;
}
function yF(n) {
  let {
    viewport: e,
    devicePixelRatio: t,
    coordinateSystem: i,
    coordinateOrigin: r
  } = n;
  const {
    projectionCenter: l,
    viewProjectionMatrix: c,
    originCommon: a,
    cameraPosCommon: g,
    shaderCoordinateOrigin: y,
    geospatialOrigin: A
  } = mF(e, i, r), C = e.getDistanceScales(), I = [e.width * t, e.height * t], S = Wp([], [0, 0, -e.focalDistance, 1], e.projectionMatrix)[3] || 1, F = {
    project_uCoordinateSystem: i,
    project_uProjectionMode: e.projectionMode,
    project_uCoordinateOrigin: y,
    project_uCommonOrigin: a.slice(0, 3),
    project_uCenter: l,
    project_uPseudoMeters: !!e._pseudoMeters,
    project_uViewportSize: I,
    project_uDevicePixelRatio: t,
    project_uFocalDistance: S,
    project_uCommonUnitsPerMeter: C.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit: C.unitsPerMeter,
    project_uCommonUnitsPerWorldUnit2: pF,
    project_uScale: e.scale,
    project_uWrapLongitude: !1,
    project_uViewProjectionMatrix: c,
    project_uModelMatrix: BE,
    project_uCameraPosition: g
  };
  if (A) {
    const U = e.getDistanceScales(A);
    switch (i) {
      case Bi.METER_OFFSETS:
        F.project_uCommonUnitsPerWorldUnit = U.unitsPerMeter, F.project_uCommonUnitsPerWorldUnit2 = U.unitsPerMeter2;
        break;
      case Bi.LNGLAT:
      case Bi.LNGLAT_OFFSETS:
        e._pseudoMeters || (F.project_uCommonUnitsPerMeter = U.unitsPerMeter), F.project_uCommonUnitsPerWorldUnit = U.unitsPerDegree, F.project_uCommonUnitsPerWorldUnit2 = U.unitsPerDegree2;
        break;
      case Bi.CARTESIAN:
        F.project_uCommonUnitsPerWorldUnit = [1, 1, U.unitsPerMeter[2]], F.project_uCommonUnitsPerWorldUnit2 = [0, 0, U.unitsPerMeter2[2]];
        break;
    }
  }
  return F;
}
const bF = {};
function vF() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : bF;
  return "viewport" in n ? _F(n) : {};
}
const wb = {
  name: "project",
  dependencies: [UO, aF],
  vs: hF,
  getUniforms: vF
};
function xF() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function $d(n, e) {
  const t = Wp([], e, n);
  return wE(t, t, 1 / t[3]), t;
}
function bw(n, e) {
  const t = n % e;
  return t < 0 ? e + t : t;
}
function Ky(n, e, t) {
  return n < e ? e : n > t ? t : n;
}
function wF(n) {
  return Math.log(n) * Math.LOG2E;
}
const Ab = Math.log2 || wF;
function Du(n, e) {
  if (!n)
    throw new Error(e || "@math.gl/web-mercator: assertion failed.");
}
const mc = Math.PI, FE = mc / 4, Pl = mc / 180, Qy = 180 / mc, uf = 512, Dm = 4003e4, Fg = 85.051129, AF = 1.5;
function TF(n) {
  return Ab(n);
}
function Lp(n) {
  const [e, t] = n;
  Du(Number.isFinite(e)), Du(Number.isFinite(t) && t >= -90 && t <= 90, "invalid latitude");
  const i = e * Pl, r = t * Pl, l = uf * (i + mc) / (2 * mc), c = uf * (mc + Math.log(Math.tan(FE + r * 0.5))) / (2 * mc);
  return [l, c];
}
function hf(n) {
  const [e, t] = n, i = e / uf * (2 * mc) - mc, r = 2 * (Math.atan(Math.exp(t / uf * (2 * mc) - mc)) - FE);
  return [i * Qy, r * Qy];
}
function EF(n) {
  const {
    latitude: e
  } = n;
  Du(Number.isFinite(e));
  const t = Math.cos(e * Pl);
  return TF(Dm * t) - 9;
}
function am(n) {
  const e = Math.cos(n * Pl);
  return uf / Dm / e;
}
function e1(n) {
  const {
    latitude: e,
    longitude: t,
    highPrecision: i = !1
  } = n;
  Du(Number.isFinite(e) && Number.isFinite(t));
  const r = uf, l = Math.cos(e * Pl), c = r / 360, a = c / l, g = r / Dm / l, y = {
    unitsPerMeter: [g, g, g],
    metersPerUnit: [1 / g, 1 / g, 1 / g],
    unitsPerDegree: [c, a, g],
    degreesPerUnit: [1 / c, 1 / a, 1 / g]
  };
  if (i) {
    const A = Pl * Math.tan(e * Pl) / l, C = c * A / 2, I = r / Dm * A, S = I / a * g;
    y.unitsPerDegree2 = [0, C, I], y.unitsPerMeter2 = [S, 0, S];
  }
  return y;
}
function NE(n, e) {
  const [t, i, r] = n, [l, c, a] = e, {
    unitsPerMeter: g,
    unitsPerMeter2: y
  } = e1({
    longitude: t,
    latitude: i,
    highPrecision: !0
  }), A = Lp(n);
  A[0] += l * (g[0] + y[0] * c), A[1] += c * (g[1] + y[1] * c);
  const C = hf(A), I = (r || 0) + (a || 0);
  return Number.isFinite(r) || Number.isFinite(a) ? [C[0], C[1], I] : C;
}
function SF(n) {
  const {
    height: e,
    pitch: t,
    bearing: i,
    altitude: r,
    scale: l,
    center: c
  } = n, a = xF();
  Bm(a, a, [0, 0, -r]), vE(a, a, -t * Pl), xE(a, a, i * Pl);
  const g = l / e;
  return _b(a, a, [g, g, g]), c && Bm(a, a, r6([], c)), a;
}
function CF(n) {
  const {
    width: e,
    height: t,
    altitude: i,
    pitch: r = 0,
    offset: l,
    center: c,
    scale: a,
    nearZMultiplier: g = 1,
    farZMultiplier: y = 1
  } = n;
  let {
    fovy: A = Fm(AF)
  } = n;
  i !== void 0 && (A = Fm(i));
  const C = A * Pl, I = r * Pl, S = kE(A);
  let F = S;
  c && (F += c[2] * a / Math.cos(I) / t);
  const U = C * (0.5 + (l ? l[1] : 0) / t), V = Math.sin(U) * F / Math.sin(Ky(Math.PI / 2 - I - U, 0.01, Math.PI - 0.01)), W = Math.sin(I) * V + F, X = F * 10, de = Math.min(W * y, X);
  return {
    fov: C,
    aspect: e / t,
    focalDistance: S,
    near: g,
    far: de
  };
}
function Fm(n) {
  return 2 * Math.atan(0.5 / n) * Qy;
}
function kE(n) {
  return 0.5 / Math.tan(0.5 * n * Pl);
}
function zE(n, e) {
  const [t, i, r = 0] = n;
  return Du(Number.isFinite(t) && Number.isFinite(i) && Number.isFinite(r)), $d(e, [t, i, r, 1]);
}
function Tb(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const [i, r, l] = n;
  if (Du(Number.isFinite(i) && Number.isFinite(r), "invalid pixel coordinate"), Number.isFinite(l))
    return $d(e, [i, r, l, 1]);
  const c = $d(e, [i, r, 0, 1]), a = $d(e, [i, r, 1, 1]), g = c[2], y = a[2], A = g === y ? 0 : ((t || 0) - g) / (y - g);
  return cE([], c, a, A);
}
function PF(n) {
  const {
    width: e,
    height: t,
    bounds: i,
    minExtent: r = 0,
    maxZoom: l = 24,
    offset: c = [0, 0]
  } = n, [[a, g], [y, A]] = i, C = IF(n.padding), I = Lp([a, Ky(A, -Fg, Fg)]), S = Lp([y, Ky(g, -Fg, Fg)]), F = [Math.max(Math.abs(S[0] - I[0]), r), Math.max(Math.abs(S[1] - I[1]), r)], U = [e - C.left - C.right - Math.abs(c[0]) * 2, t - C.top - C.bottom - Math.abs(c[1]) * 2];
  Du(U[0] > 0 && U[1] > 0);
  const V = U[0] / F[0], W = U[1] / F[1], X = (C.right - C.left) / 2 / V, de = (C.top - C.bottom) / 2 / W, ie = [(S[0] + I[0]) / 2 + X, (S[1] + I[1]) / 2 + de], fe = hf(ie), Ae = Math.min(l, Ab(Math.abs(Math.min(V, W))));
  return Du(Number.isFinite(Ae)), {
    longitude: fe[0],
    latitude: fe[1],
    zoom: Ae
  };
}
function IF() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return typeof n == "number" ? {
    top: n,
    bottom: n,
    left: n,
    right: n
  } : (Du(Number.isFinite(n.top) && Number.isFinite(n.bottom) && Number.isFinite(n.left) && Number.isFinite(n.right)), n);
}
const vw = Math.PI / 180;
function MF(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const {
    width: t,
    height: i,
    unproject: r
  } = n, l = {
    targetZ: e
  }, c = r([0, i], l), a = r([t, i], l);
  let g, y;
  const A = n.fovy ? 0.5 * n.fovy * vw : Math.atan(0.5 / n.altitude), C = (90 - n.pitch) * vw;
  return A > C - 0.01 ? (g = xw(n, 0, e), y = xw(n, t, e)) : (g = r([0, 0], l), y = r([t, 0], l)), [c, a, y, g];
}
function xw(n, e, t) {
  const {
    pixelUnprojectionMatrix: i
  } = n, r = $d(i, [e, 0, 1, 1]), l = $d(i, [e, n.height, 1, 1]), a = (t * n.distanceScales.unitsPerMeter[2] - r[2]) / (l[2] - r[2]), g = cE([], r, l, a), y = hf(g);
  return y.push(t), y;
}
const ww = 512;
function LF(n) {
  const {
    width: e,
    height: t,
    pitch: i = 0
  } = n;
  let {
    longitude: r,
    latitude: l,
    zoom: c,
    bearing: a = 0
  } = n;
  (r < -180 || r > 180) && (r = bw(r + 180, 360) - 180), (a < -180 || a > 180) && (a = bw(a + 180, 360) - 180);
  const g = Ab(t / ww);
  if (c <= g)
    c = g, l = 0;
  else {
    const y = t / 2 / Math.pow(2, c), A = hf([0, y])[1];
    if (l < A)
      l = A;
    else {
      const C = hf([0, ww - y])[1];
      l > C && (l = C);
    }
  }
  return {
    width: e,
    height: t,
    longitude: r,
    latitude: l,
    zoom: c,
    pitch: i,
    bearing: a
  };
}
const RF = `
const int max_lights = 2;
uniform mat4 shadow_uViewProjectionMatrices[max_lights];
uniform vec4 shadow_uProjectCenters[max_lights];
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform int shadow_uLightId;
uniform float shadow_uLightCount;

varying vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  if (shadow_uDrawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);
  }
  if (shadow_uUseShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow_uLightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`, BF = `
const int max_lights = 2;
uniform bool shadow_uDrawShadowMap;
uniform bool shadow_uUseShadowMap;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;
uniform vec4 shadow_uColor;
uniform float shadow_uLightCount;

varying vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture2D(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow_uDrawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow_uUseShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow_uLightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`, OF = $p(zF), DF = $p(UF), FF = [0, 0, 0, 1], NF = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
function kF(n, e) {
  const [t, i, r] = n, l = Tb([t, i, r], e);
  return Number.isFinite(r) ? l : [l[0], l[1], 0];
}
function zF(n) {
  let {
    viewport: e,
    center: t
  } = n;
  return new Mi(e.viewProjectionMatrix).invert().transform(t);
}
function UF(n) {
  let {
    viewport: e,
    shadowMatrices: t
  } = n;
  const i = [], r = e.pixelUnprojectionMatrix, l = e.isGeospatial ? void 0 : 1, c = [[0, 0, l], [e.width, 0, l], [0, e.height, l], [e.width, e.height, l], [0, 0, -1], [e.width, 0, -1], [0, e.height, -1], [e.width, e.height, -1]].map((a) => kF(a, r));
  for (const a of t) {
    const g = a.clone().translate(new Tt(e.center).negate()), y = c.map((C) => g.transform(C)), A = new Mi().ortho({
      left: Math.min(...y.map((C) => C[0])),
      right: Math.max(...y.map((C) => C[0])),
      bottom: Math.min(...y.map((C) => C[1])),
      top: Math.max(...y.map((C) => C[1])),
      near: Math.min(...y.map((C) => -C[2])),
      far: Math.max(...y.map((C) => -C[2]))
    });
    i.push(A.multiplyRight(a));
  }
  return i;
}
function jF(n, e) {
  const {
    shadowEnabled: t = !0
  } = n;
  if (!t || !n.shadowMatrices || !n.shadowMatrices.length)
    return {
      shadow_uDrawShadowMap: !1,
      shadow_uUseShadowMap: !1
    };
  const i = {
    shadow_uDrawShadowMap: !!n.drawToShadowMap,
    shadow_uUseShadowMap: n.shadowMaps ? n.shadowMaps.length > 0 : !1,
    shadow_uColor: n.shadowColor || FF,
    shadow_uLightId: n.shadowLightId || 0,
    shadow_uLightCount: n.shadowMatrices.length
  }, r = OF({
    viewport: n.viewport,
    center: e.project_uCenter
  }), l = [], c = DF({
    shadowMatrices: n.shadowMatrices,
    viewport: n.viewport
  }).slice();
  for (let a = 0; a < n.shadowMatrices.length; a++) {
    const g = c[a], y = g.clone().translate(new Tt(n.viewport.center).negate());
    e.project_uCoordinateSystem === Bi.LNGLAT && e.project_uProjectionMode === Jc.WEB_MERCATOR ? (c[a] = y, l[a] = r) : (c[a] = g.clone().multiplyRight(NF), l[a] = y.transform(r));
  }
  for (let a = 0; a < c.length; a++)
    i["shadow_uViewProjectionMatrices[".concat(a, "]")] = c[a], i["shadow_uProjectCenters[".concat(a, "]")] = l[a], n.shadowMaps && n.shadowMaps.length > 0 ? i["shadow_uShadowMap".concat(a)] = n.shadowMaps[a] : i["shadow_uShadowMap".concat(a)] = n.dummyShadowMap;
  return i;
}
const D0 = {
  name: "shadow",
  dependencies: [wb],
  vs: RF,
  fs: BF,
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
    "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
  },
  getUniforms: function() {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return "viewport" in n && (n.drawToShadowMap || n.shadowMaps && n.shadowMaps.length > 0) ? jF(n, e) : {};
  }
}, GF = {
  color: [255, 255, 255],
  intensity: 1
}, Aw = [{
  color: [255, 255, 255],
  intensity: 1,
  direction: [-1, 3, -1]
}, {
  color: [255, 255, 255],
  intensity: 0.9,
  direction: [1, -8, -2.5]
}], VF = [0, 0, 0, 200 / 255];
class Eb {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    H(this, "id", "lighting-effect"), H(this, "props", void 0), H(this, "shadowColor", VF), H(this, "shadow", void 0), H(this, "ambientLight", void 0), H(this, "directionalLights", void 0), H(this, "pointLights", void 0), H(this, "shadowPasses", []), H(this, "shadowMaps", []), H(this, "dummyShadowMap", null), H(this, "programManager", void 0), H(this, "shadowMatrices", void 0), this.setProps(e);
  }
  setProps(e) {
    this.ambientLight = null, this.directionalLights = [], this.pointLights = [];
    for (const t in e) {
      const i = e[t];
      switch (i.type) {
        case "ambient":
          this.ambientLight = i;
          break;
        case "directional":
          this.directionalLights.push(i);
          break;
        case "point":
          this.pointLights.push(i);
          break;
      }
    }
    this._applyDefaultLights(), this.shadow = this.directionalLights.some((t) => t.shadow), this.props = e;
  }
  preRender(e, t) {
    let {
      layers: i,
      layerFilter: r,
      viewports: l,
      onViewportActive: c,
      views: a
    } = t;
    if (this.shadow) {
      this.shadowMatrices = this._calculateMatrices(), this.shadowPasses.length === 0 && this._createShadowPasses(e), this.programManager || (this.programManager = Zp.getDefaultProgramManager(e), D0 && this.programManager.addDefaultModule(D0)), this.dummyShadowMap || (this.dummyShadowMap = new rl(e, {
        width: 1,
        height: 1
      }));
      for (let g = 0; g < this.shadowPasses.length; g++)
        this.shadowPasses[g].render({
          layers: i,
          layerFilter: r,
          viewports: l,
          onViewportActive: c,
          views: a,
          moduleParameters: {
            shadowLightId: g,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        });
    }
  }
  getModuleParameters(e) {
    const t = this.shadow ? {
      shadowMaps: this.shadowMaps,
      dummyShadowMap: this.dummyShadowMap,
      shadowColor: this.shadowColor,
      shadowMatrices: this.shadowMatrices
    } : {};
    return t.lightSources = {
      ambientLight: this.ambientLight,
      directionalLights: this.directionalLights.map((i) => i.getProjectedLight({
        layer: e
      })),
      pointLights: this.pointLights.map((i) => i.getProjectedLight({
        layer: e
      }))
    }, t;
  }
  cleanup() {
    for (const e of this.shadowPasses)
      e.delete();
    this.shadowPasses.length = 0, this.shadowMaps.length = 0, this.dummyShadowMap && (this.dummyShadowMap.delete(), this.dummyShadowMap = null), this.shadow && this.programManager && (this.programManager.removeDefaultModule(D0), this.programManager = null);
  }
  _calculateMatrices() {
    const e = [];
    for (const t of this.directionalLights) {
      const i = new Mi().lookAt({
        eye: new Tt(t.direction).negate()
      });
      e.push(i);
    }
    return e;
  }
  _createShadowPasses(e) {
    for (let t = 0; t < this.directionalLights.length; t++) {
      const i = new rF(e);
      this.shadowPasses[t] = i, this.shadowMaps[t] = i.shadowMap;
    }
  }
  _applyDefaultLights() {
    const {
      ambientLight: e,
      pointLights: t,
      directionalLights: i
    } = this;
    !e && t.length === 0 && i.length === 0 && (this.ambientLight = new ME(GF), this.directionalLights.push(new _w(Aw[0]), new _w(Aw[1])));
  }
}
class qF {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    H(this, "_pool", []), H(this, "opts", {
      overAlloc: 2,
      poolSize: 100
    }), this.setOptions(e);
  }
  setOptions(e) {
    Object.assign(this.opts, e);
  }
  allocate(e, t, i) {
    let {
      size: r = 1,
      type: l,
      padding: c = 0,
      copy: a = !1,
      initialize: g = !1,
      maxCount: y
    } = i;
    const A = l || e && e.constructor || Float32Array, C = t * r + c;
    if (ArrayBuffer.isView(e)) {
      if (C <= e.length)
        return e;
      if (C * e.BYTES_PER_ELEMENT <= e.buffer.byteLength)
        return new A(e.buffer, 0, C);
    }
    let I = 1 / 0;
    y && (I = y * r + c);
    const S = this._allocate(A, C, g, I);
    return e && a ? S.set(e) : g || S.fill(0, 0, 4), this._release(e), S;
  }
  release(e) {
    this._release(e);
  }
  _allocate(e, t, i, r) {
    let l = Math.max(Math.ceil(t * this.opts.overAlloc), 1);
    l > r && (l = r);
    const c = this._pool, a = e.BYTES_PER_ELEMENT * l, g = c.findIndex((y) => y.byteLength >= a);
    if (g >= 0) {
      const y = new e(c.splice(g, 1)[0], 0, l);
      return i && y.fill(0), y;
    }
    return new e(l);
  }
  _release(e) {
    if (!ArrayBuffer.isView(e))
      return;
    const t = this._pool, {
      buffer: i
    } = e, {
      byteLength: r
    } = i, l = t.findIndex((c) => c.byteLength >= r);
    l < 0 ? t.push(i) : (l > 0 || t.length < this.opts.poolSize) && t.splice(l, 0, i), t.length > this.opts.poolSize && t.shift();
  }
}
const Rp = new qF();
function dp() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
function HF(n) {
  return [n[12], n[13], n[14]];
}
function WF(n) {
  return {
    left: Ld(n[3] + n[0], n[7] + n[4], n[11] + n[8], n[15] + n[12]),
    right: Ld(n[3] - n[0], n[7] - n[4], n[11] - n[8], n[15] - n[12]),
    bottom: Ld(n[3] + n[1], n[7] + n[5], n[11] + n[9], n[15] + n[13]),
    top: Ld(n[3] - n[1], n[7] - n[5], n[11] - n[9], n[15] - n[13]),
    near: Ld(n[3] + n[2], n[7] + n[6], n[11] + n[10], n[15] + n[14]),
    far: Ld(n[3] - n[2], n[7] - n[6], n[11] - n[10], n[15] - n[14])
  };
}
const Tw = new Tt();
function Ld(n, e, t, i) {
  Tw.set(n, e, t);
  const r = Tw.len();
  return {
    distance: i / r,
    normal: new Tt(-n / r, -e / r, -t / r)
  };
}
function ZF(n) {
  return n - Math.fround(n);
}
let Kf;
function F0(n, e) {
  const {
    size: t = 1,
    startIndex: i = 0
  } = e, r = e.endIndex !== void 0 ? e.endIndex : n.length, l = (r - i) / t;
  Kf = Rp.allocate(Kf, l, {
    type: Float32Array,
    size: t * 2
  });
  let c = i, a = 0;
  for (; c < r; ) {
    for (let g = 0; g < t; g++) {
      const y = n[c++];
      Kf[a + g] = y, Kf[a + g + t] = ZF(y);
    }
    a += t * 2;
  }
  return Kf.subarray(0, l * t * 2);
}
function $F(n) {
  let e = null, t = !1;
  for (const i of n)
    i && (e ? (t || (e = [[e[0][0], e[0][1]], [e[1][0], e[1][1]]], t = !0), e[0][0] = Math.min(e[0][0], i[0][0]), e[0][1] = Math.min(e[0][1], i[0][1]), e[1][0] = Math.max(e[1][0], i[1][0]), e[1][1] = Math.max(e[1][1], i[1][1])) : e = i);
  return e;
}
const XF = Math.PI / 180, YF = dp(), Ew = [0, 0, 0], JF = {
  unitsPerMeter: [1, 1, 1],
  metersPerUnit: [1, 1, 1]
};
function KF(n) {
  let {
    width: e,
    height: t,
    orthographic: i,
    fovyRadians: r,
    focalDistance: l,
    padding: c,
    near: a,
    far: g
  } = n;
  const y = e / t, A = i ? new Mi().orthographic({
    fovy: r,
    aspect: y,
    focalDistance: l,
    near: a,
    far: g
  }) : new Mi().perspective({
    fovy: r,
    aspect: y,
    near: a,
    far: g
  });
  if (c) {
    const {
      left: C = 0,
      right: I = 0,
      top: S = 0,
      bottom: F = 0
    } = c, U = Pu((C + e - I) / 2, 0, e) - e / 2, V = Pu((S + t - F) / 2, 0, t) - t / 2;
    A[8] -= U * 2 / e, A[9] += V * 2 / t;
  }
  return A;
}
class mf {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    H(this, "id", void 0), H(this, "x", void 0), H(this, "y", void 0), H(this, "width", void 0), H(this, "height", void 0), H(this, "padding", void 0), H(this, "isGeospatial", void 0), H(this, "zoom", void 0), H(this, "focalDistance", void 0), H(this, "position", void 0), H(this, "modelMatrix", void 0), H(this, "distanceScales", void 0), H(this, "scale", void 0), H(this, "center", void 0), H(this, "cameraPosition", void 0), H(this, "projectionMatrix", void 0), H(this, "viewMatrix", void 0), H(this, "viewMatrixUncentered", void 0), H(this, "viewMatrixInverse", void 0), H(this, "viewProjectionMatrix", void 0), H(this, "pixelProjectionMatrix", void 0), H(this, "pixelUnprojectionMatrix", void 0), H(this, "resolution", void 0), H(this, "_frustumPlanes", {}), this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || JF, this.focalDistance = e.focalDistance || 1, this.position = e.position || Ew, this.modelMatrix = e.modelMatrix || null;
    const {
      longitude: t,
      latitude: i
    } = e;
    this.isGeospatial = Number.isFinite(i) && Number.isFinite(t), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
  }
  get subViewports() {
    return null;
  }
  get metersPerPixel() {
    return this.distanceScales.metersPerUnit[2] / this.scale;
  }
  get projectionMode() {
    return this.isGeospatial ? this.zoom < 12 ? Jc.WEB_MERCATOR : Jc.WEB_MERCATOR_AUTO_OFFSET : Jc.IDENTITY;
  }
  equals(e) {
    return e instanceof mf ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && bc(e.projectionMatrix, this.projectionMatrix) && bc(e.viewMatrix, this.viewMatrix) : !1;
  }
  project(e) {
    let {
      topLeft: t = !0
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = this.projectPosition(e), r = zE(i, this.pixelProjectionMatrix), [l, c] = r, a = t ? c : this.height - c;
    return e.length === 2 ? [l, a] : [l, a, r[2]];
  }
  unproject(e) {
    let {
      topLeft: t = !0,
      targetZ: i
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const [r, l, c] = e, a = t ? l : this.height - l, g = i && i * this.distanceScales.unitsPerMeter[2], y = Tb([r, a, c], this.pixelUnprojectionMatrix, g), [A, C, I] = this.unprojectPosition(y);
    return Number.isFinite(c) ? [A, C, I] : Number.isFinite(i) ? [A, C, i] : [A, C];
  }
  projectPosition(e) {
    const [t, i] = this.projectFlat(e), r = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
    return [t, i, r];
  }
  unprojectPosition(e) {
    const [t, i] = this.unprojectFlat(e), r = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
    return [t, i, r];
  }
  projectFlat(e) {
    if (this.isGeospatial) {
      const t = Lp(e);
      return t[1] = Pu(t[1], -318, 830), t;
    }
    return e;
  }
  unprojectFlat(e) {
    return this.isGeospatial ? hf(e) : e;
  }
  getBounds() {
    const t = {
      targetZ: (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).z || 0
    }, i = this.unproject([0, 0], t), r = this.unproject([this.width, 0], t), l = this.unproject([0, this.height], t), c = this.unproject([this.width, this.height], t);
    return [Math.min(i[0], r[0], l[0], c[0]), Math.min(i[1], r[1], l[1], c[1]), Math.max(i[0], r[0], l[0], c[0]), Math.max(i[1], r[1], l[1], c[1])];
  }
  getDistanceScales(e) {
    return e ? e1({
      longitude: e[0],
      latitude: e[1],
      highPrecision: !0
    }) : this.distanceScales;
  }
  containsPixel(e) {
    let {
      x: t,
      y: i,
      width: r = 1,
      height: l = 1
    } = e;
    return t < this.x + this.width && this.x < t + r && i < this.y + this.height && this.y < i + l;
  }
  getFrustumPlanes() {
    return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, WF(this.viewProjectionMatrix)), this._frustumPlanes);
  }
  panByPosition(e, t) {
    return null;
  }
  _initProps(e) {
    const t = e.longitude, i = e.latitude;
    this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = EF({
      latitude: i
    }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || e1({
      latitude: i,
      longitude: t
    }));
    const r = Math.pow(2, this.zoom);
    this.scale = r;
    const {
      position: l,
      modelMatrix: c
    } = e;
    let a = Ew;
    if (l && (a = c ? new Mi(c).transformAsVector(l, []) : l), this.isGeospatial) {
      const g = this.projectPosition([t, i, 0]);
      this.center = new Tt(a).scale(this.distanceScales.unitsPerMeter).add(g);
    } else
      this.center = this.projectPosition(a);
  }
  _initMatrices(e) {
    const {
      viewMatrix: t = YF,
      projectionMatrix: i = null,
      orthographic: r = !1,
      fovyRadians: l,
      fovy: c = 75,
      near: a = 0.1,
      far: g = 1e3,
      padding: y = null,
      focalDistance: A = 1
    } = e;
    this.viewMatrixUncentered = t, this.viewMatrix = new Mi().multiplyRight(t).translate(new Tt(this.center).negate()), this.projectionMatrix = i || KF({
      width: this.width,
      height: this.height,
      orthographic: r,
      fovyRadians: l || c * XF,
      focalDistance: A,
      padding: y,
      near: a,
      far: g
    });
    const C = dp();
    $h(C, C, this.projectionMatrix), $h(C, C, this.viewMatrix), this.viewProjectionMatrix = C, this.viewMatrixInverse = Yy([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = HF(this.viewMatrixInverse);
    const I = dp(), S = dp();
    _b(I, I, [this.width / 2, -this.height / 2, 1]), Bm(I, I, [1, -1, 0]), $h(S, I, this.viewProjectionMatrix), this.pixelProjectionMatrix = S, this.pixelUnprojectionMatrix = Yy(dp(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || zi.warn("Pixel project matrix not invertible")();
  }
}
H(mf, "displayName", "Viewport");
class Kh extends mf {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      latitude: t = 0,
      longitude: i = 0,
      zoom: r = 0,
      pitch: l = 0,
      bearing: c = 0,
      nearZMultiplier: a = 0.1,
      farZMultiplier: g = 1.01,
      nearZ: y,
      farZ: A,
      orthographic: C = !1,
      projectionMatrix: I,
      repeat: S = !1,
      worldOffset: F = 0,
      position: U,
      padding: V,
      legacyMeterSizes: W = !1
    } = e;
    let {
      width: X,
      height: de,
      altitude: ie = 1.5
    } = e;
    const fe = Math.pow(2, r);
    X = X || 1, de = de || 1;
    let Ae, Te = null;
    if (I)
      ie = I[5] / 2, Ae = Fm(ie);
    else {
      e.fovy ? (Ae = e.fovy, ie = kE(Ae)) : Ae = Fm(ie);
      let Ge;
      if (V) {
        const {
          top: ke = 0,
          bottom: pe = 0
        } = V;
        Ge = [0, Pu((ke + de - pe) / 2, 0, de) - de / 2];
      }
      Te = CF({
        width: X,
        height: de,
        scale: fe,
        center: U && [0, 0, U[2] * am(t)],
        offset: Ge,
        pitch: l,
        fovy: Ae,
        nearZMultiplier: a,
        farZMultiplier: g
      }), Number.isFinite(y) && (Te.near = y), Number.isFinite(A) && (Te.far = A);
    }
    let me = SF({
      height: de,
      pitch: l,
      bearing: c,
      scale: fe,
      altitude: ie
    });
    F && (me = new Mi().translate([512 * F, 0, 0]).multiplyLeft(me)), super({
      ...e,
      width: X,
      height: de,
      viewMatrix: me,
      longitude: i,
      latitude: t,
      zoom: r,
      ...Te,
      fovy: Ae,
      focalDistance: ie
    }), H(this, "longitude", void 0), H(this, "latitude", void 0), H(this, "pitch", void 0), H(this, "bearing", void 0), H(this, "altitude", void 0), H(this, "fovy", void 0), H(this, "orthographic", void 0), H(this, "_subViewports", void 0), H(this, "_pseudoMeters", void 0), this.latitude = t, this.longitude = i, this.zoom = r, this.pitch = l, this.bearing = c, this.altitude = ie, this.fovy = Ae, this.orthographic = C, this._subViewports = S ? [] : null, this._pseudoMeters = W, Object.freeze(this);
  }
  get subViewports() {
    if (this._subViewports && !this._subViewports.length) {
      const e = this.getBounds(), t = Math.floor((e[0] + 180) / 360), i = Math.ceil((e[2] - 180) / 360);
      for (let r = t; r <= i; r++) {
        const l = r ? new Kh({
          ...this,
          worldOffset: r
        }) : this;
        this._subViewports.push(l);
      }
    }
    return this._subViewports;
  }
  projectPosition(e) {
    if (this._pseudoMeters)
      return super.projectPosition(e);
    const [t, i] = this.projectFlat(e), r = (e[2] || 0) * am(e[1]);
    return [t, i, r];
  }
  unprojectPosition(e) {
    if (this._pseudoMeters)
      return super.unprojectPosition(e);
    const [t, i] = this.unprojectFlat(e), r = (e[2] || 0) / am(i);
    return [t, i, r];
  }
  addMetersToLngLat(e, t) {
    return NE(e, t);
  }
  panByPosition(e, t) {
    const i = Tb(t, this.pixelUnprojectionMatrix), r = this.projectFlat(e), l = ow([], r, KO([], i)), c = ow([], this.center, l), [a, g] = this.unprojectFlat(c);
    return {
      longitude: a,
      latitude: g
    };
  }
  getBounds() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = MF(this, e.z || 0);
    return [Math.min(t[0][0], t[1][0], t[2][0], t[3][0]), Math.min(t[0][1], t[1][1], t[2][1], t[3][1]), Math.max(t[0][0], t[1][0], t[2][0], t[3][0]), Math.max(t[0][1], t[1][1], t[2][1], t[3][1])];
  }
  fitBounds(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      width: i,
      height: r
    } = this, {
      longitude: l,
      latitude: c,
      zoom: a
    } = PF({
      width: i,
      height: r,
      bounds: e,
      ...t
    });
    return new Kh({
      width: i,
      height: r,
      longitude: l,
      latitude: c,
      zoom: a
    });
  }
}
H(Kh, "displayName", "WebMercatorViewport");
const Sw = [0, 0, 0];
function N0(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const i = e.projectPosition(n);
  if (t && e instanceof Kh) {
    const [r, l, c = 0] = n, a = e.getDistanceScales([r, l]);
    i[2] = c * a.unitsPerMeter[2];
  }
  return i;
}
function QF(n) {
  const {
    viewport: e,
    modelMatrix: t,
    coordinateOrigin: i
  } = n;
  let {
    coordinateSystem: r,
    fromCoordinateSystem: l,
    fromCoordinateOrigin: c
  } = n;
  return r === Bi.DEFAULT && (r = e.isGeospatial ? Bi.LNGLAT : Bi.CARTESIAN), l === void 0 && (l = r), c === void 0 && (c = i), {
    viewport: e,
    coordinateSystem: r,
    coordinateOrigin: i,
    modelMatrix: t,
    fromCoordinateSystem: l,
    fromCoordinateOrigin: c
  };
}
function UE(n, e) {
  let {
    viewport: t,
    modelMatrix: i,
    coordinateSystem: r,
    coordinateOrigin: l,
    offsetMode: c
  } = e, [a, g, y = 0] = n;
  switch (i && ([a, g, y] = Wp([], [a, g, y, 1], i)), r) {
    case Bi.LNGLAT:
      return N0([a, g, y], t, c);
    case Bi.LNGLAT_OFFSETS:
      return N0([a + l[0], g + l[1], y + (l[2] || 0)], t, c);
    case Bi.METER_OFFSETS:
      return N0(NE(l, [a, g, y]), t, c);
    case Bi.CARTESIAN:
    default:
      return t.isGeospatial ? [a + l[0], g + l[1], y + l[2]] : t.projectPosition([a, g, y]);
  }
}
function eN(n, e) {
  const {
    viewport: t,
    coordinateSystem: i,
    coordinateOrigin: r,
    modelMatrix: l,
    fromCoordinateSystem: c,
    fromCoordinateOrigin: a
  } = QF(e), {
    autoOffset: g = !0
  } = e, {
    geospatialOrigin: y = Sw,
    shaderCoordinateOrigin: A = Sw,
    offsetMode: C = !1
  } = g ? DE(t, i, r) : {}, I = UE(n, {
    viewport: t,
    modelMatrix: l,
    coordinateSystem: c,
    coordinateOrigin: a,
    offsetMode: C
  });
  if (C) {
    const S = t.projectPosition(y || A);
    u6(I, I, S);
  }
  return I;
}
const Cw = {
  blendFunc: [1, 0, 32771, 0],
  blendEquation: 32774
};
class jE extends xb {
  constructor() {
    super(...arguments), H(this, "pickZ", void 0), H(this, "_colorEncoderState", null);
  }
  render(e) {
    return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
  }
  _drawPickingBuffer(e) {
    let {
      layers: t,
      layerFilter: i,
      views: r,
      viewports: l,
      onViewportActive: c,
      pickingFBO: a,
      deviceRect: {
        x: g,
        y,
        width: A,
        height: C
      },
      cullRect: I,
      effects: S,
      pass: F = "picking",
      pickZ: U,
      moduleParameters: V
    } = e;
    const W = this.gl;
    this.pickZ = U;
    const X = this._resetColorEncoder(U), de = yc(W, {
      scissorTest: !0,
      scissor: [g, y, A, C],
      clearColor: [0, 0, 0, 0],
      depthMask: !0,
      depthTest: !0,
      depthRange: [0, 1],
      colorMask: [!0, !0, !0, !0],
      ...Cw,
      blend: !U
    }, () => super.render({
      target: a,
      layers: t,
      layerFilter: i,
      views: r,
      viewports: l,
      onViewportActive: c,
      cullRect: I,
      effects: S == null ? void 0 : S.filter((fe) => fe.useInPicking),
      pass: F,
      isPicking: !0,
      moduleParameters: V
    }));
    return this._colorEncoderState = null, {
      decodePickingColor: X && nN.bind(null, X),
      stats: de
    };
  }
  shouldDrawLayer(e) {
    const {
      pickable: t,
      operation: i
    } = e.props;
    return t && i.includes("draw") || i.includes("terrain") || i.includes("mask");
  }
  getModuleParameters() {
    return {
      pickingActive: 1,
      pickingAttribute: this.pickZ,
      lightSources: {}
    };
  }
  getLayerParameters(e, t, i) {
    const r = {
      ...e.props.parameters
    }, {
      pickable: l,
      operation: c
    } = e.props;
    return this._colorEncoderState ? l && c.includes("draw") && (Object.assign(r, Cw), r.blend = !0, r.blendColor = tN(this._colorEncoderState, e, i)) : r.blend = !1, c.includes("terrain") && (r.blend = !1), r;
  }
  _resetColorEncoder(e) {
    return this._colorEncoderState = e ? null : {
      byLayer: /* @__PURE__ */ new Map(),
      byAlpha: []
    }, this._colorEncoderState;
  }
}
function tN(n, e, t) {
  const {
    byLayer: i,
    byAlpha: r
  } = n;
  let l, c = i.get(e);
  return c ? (c.viewports.push(t), l = c.a) : (l = i.size + 1, l <= 255 ? (c = {
    a: l,
    layer: e,
    viewports: [t]
  }, i.set(e, c), r[l] = c) : (zi.warn("Too many pickable layers, only picking the first 255")(), l = 0)), [0, 0, 0, l / 255];
}
function nN(n, e) {
  const t = n.byAlpha[e[3]];
  return t && {
    pickedLayer: t.layer,
    pickedViewports: t.viewports,
    pickedObjectIndex: t.layer.decodePickingColor(e)
  };
}
const kd = {
  NO_STATE: "Awaiting state",
  MATCHED: "Matched. State transferred from previous layer",
  INITIALIZED: "Initialized",
  AWAITING_GC: "Discarded. Awaiting garbage collection",
  AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
  FINALIZED: "Finalized! Awaiting garbage collection"
}, Nm = Symbol.for("component"), fh = Symbol.for("propTypes"), k0 = Symbol.for("deprecatedProps"), Xd = Symbol.for("asyncPropDefaults"), Qh = Symbol.for("asyncPropOriginal"), uh = Symbol.for("asyncPropResolved");
function n_(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : () => !0;
  return Array.isArray(n) ? GE(n, e, []) : e(n) ? [n] : [];
}
function GE(n, e, t) {
  let i = -1;
  for (; ++i < n.length; ) {
    const r = n[i];
    Array.isArray(r) ? GE(r, e, t) : e(r) && t.push(r);
  }
  return t;
}
function iN(n) {
  let {
    target: e,
    source: t,
    start: i = 0,
    count: r = 1
  } = n;
  const l = t.length, c = r * l;
  let a = 0;
  for (let g = i; a < l; a++)
    e[g++] = t[a];
  for (; a < c; )
    a < c - a ? (e.copyWithin(i + a, i, i + a), a *= 2) : (e.copyWithin(i + a, i, i + c - a), a = c);
  return e;
}
class rN {
  constructor(e, t, i) {
    H(this, "id", void 0), H(this, "context", void 0), H(this, "isLoaded", void 0), H(this, "persistent", void 0), H(this, "_loadCount", 0), H(this, "_subscribers", /* @__PURE__ */ new Set()), H(this, "_data", void 0), H(this, "_loader", void 0), H(this, "_error", void 0), H(this, "_content", void 0), this.id = e, this.context = i, this.setData(t);
  }
  subscribe(e) {
    this._subscribers.add(e);
  }
  unsubscribe(e) {
    this._subscribers.delete(e);
  }
  inUse() {
    return this._subscribers.size > 0;
  }
  delete() {
  }
  getData() {
    return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
  }
  setData(e, t) {
    if (e === this._data && !t)
      return;
    this._data = e;
    const i = ++this._loadCount;
    let r = e;
    typeof e == "string" && (r = gh(e)), r instanceof Promise ? (this.isLoaded = !1, this._loader = r.then((l) => {
      this._loadCount === i && (this.isLoaded = !0, this._error = void 0, this._content = l);
    }).catch((l) => {
      this._loadCount === i && (this.isLoaded = !0, this._error = l || !0);
    })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
    for (const l of this._subscribers)
      l.onChange(this.getData());
  }
}
class sN {
  constructor(e) {
    let {
      gl: t,
      protocol: i
    } = e;
    H(this, "protocol", void 0), H(this, "_context", void 0), H(this, "_resources", void 0), H(this, "_consumers", void 0), H(this, "_pruneRequest", void 0), this.protocol = i || "resource://", this._context = {
      gl: t,
      resourceManager: this
    }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
  }
  contains(e) {
    return e.startsWith(this.protocol) ? !0 : e in this._resources;
  }
  add(e) {
    let {
      resourceId: t,
      data: i,
      forceUpdate: r = !1,
      persistent: l = !0
    } = e, c = this._resources[t];
    c ? c.setData(i, r) : (c = new rN(t, i, this._context), this._resources[t] = c), c.persistent = l;
  }
  remove(e) {
    const t = this._resources[e];
    t && (t.delete(), delete this._resources[e]);
  }
  unsubscribe(e) {
    let {
      consumerId: t
    } = e;
    const i = this._consumers[t];
    if (i) {
      for (const r in i) {
        const l = i[r], c = this._resources[l.resourceId];
        c && c.unsubscribe(l);
      }
      delete this._consumers[t], this.prune();
    }
  }
  subscribe(e) {
    let {
      resourceId: t,
      onChange: i,
      consumerId: r,
      requestId: l = "default"
    } = e;
    const {
      _resources: c,
      protocol: a
    } = this;
    t.startsWith(a) && (t = t.replace(a, ""), c[t] || this.add({
      resourceId: t,
      data: null,
      persistent: !1
    }));
    const g = c[t];
    if (this._track(r, l, g, i), g)
      return g.getData();
  }
  prune() {
    this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
  }
  finalize() {
    for (const e in this._resources)
      this._resources[e].delete();
  }
  _track(e, t, i, r) {
    const l = this._consumers, c = l[e] = l[e] || {}, a = c[t] || {}, g = a.resourceId && this._resources[a.resourceId];
    g && (g.unsubscribe(a), this.prune()), i && (c[t] = a, a.onChange = r, a.resourceId = i.id, i.subscribe(a));
  }
  _prune() {
    this._pruneRequest = null;
    for (const e of Object.keys(this._resources)) {
      const t = this._resources[e];
      !t.persistent && !t.inUse() && (t.delete(), delete this._resources[e]);
    }
  }
}
const oN = `
vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`, Sb = {
  name: "project32",
  dependencies: [wb],
  vs: oN
}, Cb = {
  inject: {
    "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
    "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
    "fs:#decl": `
uniform bool picking_uAttribute;
  `,
    "fs:DECKGL_FILTER_COLOR": {
      order: 99,
      injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
    }
  },
  ..._D
}, aN = [wb], lN = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
function cN(n) {
  const e = Zp.getDefaultProgramManager(n);
  for (const t of aN)
    e.addDefaultModule(t);
  for (const t of lN)
    e.addShaderHook(t);
  return e;
}
const uN = "layerManager.setLayers", hN = "layerManager.activateViewport";
class dN {
  constructor(e) {
    let {
      deck: t,
      stats: i,
      viewport: r,
      timeline: l
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    H(this, "layers", void 0), H(this, "context", void 0), H(this, "resourceManager", void 0), H(this, "_lastRenderedLayers", []), H(this, "_needsRedraw", !1), H(this, "_needsUpdate", !1), H(this, "_nextLayers", null), H(this, "_debug", !1), H(this, "activateViewport", (c) => {
      Vo(hN, this, c), c && (this.context.viewport = c);
    }), this.layers = [], this.resourceManager = new sN({
      gl: e,
      protocol: "deck://"
    }), this.context = {
      mousePosition: null,
      userData: {},
      layerManager: this,
      gl: e,
      deck: t,
      programManager: e && cN(e),
      stats: i || new Up({
        id: "deck.gl"
      }),
      viewport: r || new mf({
        id: "DEFAULT-INITIAL-VIEWPORT"
      }),
      timeline: l || new IE(),
      resourceManager: this.resourceManager,
      onError: void 0
    }, Object.seal(this);
  }
  finalize() {
    this.resourceManager.finalize();
    for (const e of this.layers)
      this._finalizeLayer(e);
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    }, t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    for (const i of this.layers) {
      const r = i.getNeedsRedraw(e);
      t = t || r;
    }
    return t;
  }
  needsUpdate() {
    return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._needsUpdate;
  }
  setNeedsRedraw(e) {
    this._needsRedraw = this._needsRedraw || e;
  }
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e;
  }
  getLayers() {
    let {
      layerIds: e
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return e ? this.layers.filter((t) => e.find((i) => t.id.indexOf(i) === 0)) : this.layers;
  }
  setProps(e) {
    "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
  }
  setLayers(e, t) {
    Vo(uN, this, t, e), this._lastRenderedLayers = e;
    const i = n_(e, Boolean);
    for (const r of i)
      r.context = this.context;
    this._updateLayers(this.layers, i);
  }
  updateLayers() {
    const e = this.needsUpdate();
    e && (this.setNeedsRedraw("updating layers: ".concat(e)), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
  }
  _handleError(e, t, i) {
    i.raiseError(t, "".concat(e, " of ").concat(i));
  }
  _updateLayers(e, t) {
    const i = {};
    for (const c of e)
      i[c.id] ? zi.warn("Multiple old layers with same id ".concat(c.id))() : i[c.id] = c;
    const r = [];
    this._updateSublayersRecursively(t, i, r), this._finalizeOldLayers(i);
    let l = !1;
    for (const c of r)
      if (c.hasUniformTransition()) {
        l = "Uniform transition in ".concat(c);
        break;
      }
    this._needsUpdate = l, this.layers = r;
  }
  _updateSublayersRecursively(e, t, i) {
    for (const r of e) {
      r.context = this.context;
      const l = t[r.id];
      l === null && zi.warn("Multiple new layers with same id ".concat(r.id))(), t[r.id] = null;
      let c = null;
      try {
        this._debug && l !== r && r.validateProps(), l ? (this._transferLayerState(l, r), this._updateLayer(r)) : this._initializeLayer(r), i.push(r), c = r.isComposite ? r.getSubLayers() : null;
      } catch (a) {
        this._handleError("matching", a, r);
      }
      c && this._updateSublayersRecursively(c, t, i);
    }
  }
  _finalizeOldLayers(e) {
    for (const t in e) {
      const i = e[t];
      i && this._finalizeLayer(i);
    }
  }
  _initializeLayer(e) {
    try {
      e._initialize(), e.lifecycle = kd.INITIALIZED;
    } catch (t) {
      this._handleError("initialization", t, e);
    }
  }
  _transferLayerState(e, t) {
    t._transferState(e), t.lifecycle = kd.MATCHED, t !== e && (e.lifecycle = kd.AWAITING_GC);
  }
  _updateLayer(e) {
    try {
      e._update();
    } catch (t) {
      this._handleError("update", t, e);
    }
  }
  _finalizeLayer(e) {
    this._needsRedraw = this._needsRedraw || "finalized ".concat(e), e.lifecycle = kd.AWAITING_FINALIZATION;
    try {
      e._finalize(), e.lifecycle = kd.FINALIZED;
    } catch (t) {
      this._handleError("finalization", t, e);
    }
  }
}
function Kc(n, e, t) {
  if (n === e)
    return !0;
  if (!t || !n || !e)
    return !1;
  if (Array.isArray(n)) {
    if (!Array.isArray(e) || n.length !== e.length)
      return !1;
    for (let i = 0; i < n.length; i++)
      if (!Kc(n[i], e[i], t - 1))
        return !1;
    return !0;
  }
  if (Array.isArray(e))
    return !1;
  if (typeof n == "object" && typeof e == "object") {
    const i = Object.keys(n), r = Object.keys(e);
    if (i.length !== r.length)
      return !1;
    for (const l of i)
      if (!e.hasOwnProperty(l) || !Kc(n[l], e[l], t - 1))
        return !1;
    return !0;
  }
  return !1;
}
class fN {
  constructor(e) {
    H(this, "width", void 0), H(this, "height", void 0), H(this, "views", void 0), H(this, "viewState", void 0), H(this, "controllers", void 0), H(this, "timeline", void 0), H(this, "_viewports", void 0), H(this, "_viewportMap", void 0), H(this, "_isUpdating", void 0), H(this, "_needsRedraw", void 0), H(this, "_needsUpdate", void 0), H(this, "_eventManager", void 0), H(this, "_eventCallbacks", void 0), this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
      onViewStateChange: e.onViewStateChange,
      onInteractionStateChange: e.onInteractionStateChange
    }, Object.seal(this), this.setProps(e);
  }
  finalize() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.finalize();
    }
    this.controllers = {};
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  setNeedsUpdate(e) {
    this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
  }
  updateViewStates() {
    for (const e in this.controllers) {
      const t = this.controllers[e];
      t && t.updateTransition();
    }
  }
  getViewports(e) {
    return e ? this._viewports.filter((t) => t.containsPixel(e)) : this._viewports;
  }
  getViews() {
    const e = {};
    return this.views.forEach((t) => {
      e[t.id] = t;
    }), e;
  }
  getView(e) {
    return this.views.find((t) => t.id === e);
  }
  getViewState(e) {
    const t = typeof e == "string" ? this.getView(e) : e, i = t && this.viewState[t.getViewStateId()] || this.viewState;
    return t ? t.filterViewState(i) : i;
  }
  getViewport(e) {
    return this._viewportMap[e];
  }
  unproject(e, t) {
    const i = this.getViewports(), r = {
      x: e[0],
      y: e[1]
    };
    for (let l = i.length - 1; l >= 0; --l) {
      const c = i[l];
      if (c.containsPixel(r)) {
        const a = e.slice();
        return a[0] -= c.x, a[1] -= c.y, c.unproject(a, t);
      }
    }
    return null;
  }
  setProps(e) {
    e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
  }
  _update() {
    this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
  }
  _setSize(e, t) {
    (e !== this.width || t !== this.height) && (this.width = e, this.height = t, this.setNeedsUpdate("Size changed"));
  }
  _setViews(e) {
    e = n_(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
  }
  _setViewState(e) {
    e ? (!Kc(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : zi.warn("missing `viewState` or `initialViewState`")();
  }
  _onViewStateChange(e, t) {
    this._eventCallbacks.onViewStateChange && this._eventCallbacks.onViewStateChange({
      ...t,
      viewId: e
    });
  }
  _createController(e, t) {
    const i = t.type;
    return new i({
      timeline: this.timeline,
      eventManager: this._eventManager,
      onViewStateChange: this._onViewStateChange.bind(this, t.id),
      onStateChange: this._eventCallbacks.onInteractionStateChange,
      makeViewport: (l) => {
        var c;
        return (c = this.getView(e.id)) === null || c === void 0 ? void 0 : c.makeViewport({
          viewState: l,
          width: this.width,
          height: this.height
        });
      }
    });
  }
  _updateController(e, t, i, r) {
    const l = e.controller;
    if (l && i) {
      const c = {
        ...t,
        ...l,
        id: e.id,
        x: i.x,
        y: i.y,
        width: i.width,
        height: i.height
      };
      return (!r || r.constructor !== l.type) && (r = this._createController(e, c)), r && r.setProps(c), r;
    }
    return null;
  }
  _rebuildViewports() {
    const {
      views: e
    } = this, t = this.controllers;
    this._viewports = [], this.controllers = {};
    let i = !1;
    for (let r = e.length; r--; ) {
      const l = e[r], c = this.getViewState(l), a = l.makeViewport({
        viewState: c,
        width: this.width,
        height: this.height
      });
      let g = t[l.id];
      const y = !!l.controller;
      y && !g && (i = !0), (i || !y) && g && (g.finalize(), g = null), this.controllers[l.id] = this._updateController(l, c, a, g), a && this._viewports.unshift(a);
    }
    for (const r in t) {
      const l = t[r];
      l && !this.controllers[r] && l.finalize();
    }
    this._buildViewportMap();
  }
  _buildViewportMap() {
    this._viewportMap = {}, this._viewports.forEach((e) => {
      e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
    });
  }
  _diffViews(e, t) {
    return e.length !== t.length ? !0 : e.some((i, r) => !e[r].equals(t[r]));
  }
}
const pN = /([0-9]+\.?[0-9]*)(%|px)/;
function th(n) {
  switch (typeof n) {
    case "number":
      return {
        position: n,
        relative: !1
      };
    case "string":
      const e = pN.exec(n);
      if (e && e.length >= 3) {
        const t = e[2] === "%", i = parseFloat(e[1]);
        return {
          position: t ? i / 100 : i,
          relative: t
        };
      }
    default:
      throw new Error("Could not parse position string ".concat(n));
  }
}
function nh(n, e) {
  return n.relative ? Math.round(n.position * e) : n.position;
}
function wo(n, e) {
  if (!n)
    throw new Error(e || "deck.gl: assertion failed.");
}
class gN {
  constructor(e) {
    H(this, "id", void 0), H(this, "viewportInstance", void 0), H(this, "_x", void 0), H(this, "_y", void 0), H(this, "_width", void 0), H(this, "_height", void 0), H(this, "_padding", void 0), H(this, "props", void 0);
    const {
      id: t,
      x: i = 0,
      y: r = 0,
      width: l = "100%",
      height: c = "100%",
      padding: a = null,
      viewportInstance: g
    } = e || {};
    wo(!g || g instanceof mf), this.viewportInstance = g, this.id = t || this.constructor.displayName || "view", this.props = {
      ...e,
      id: this.id
    }, this._x = th(i), this._y = th(r), this._width = th(l), this._height = th(c), this._padding = a && {
      left: th(a.left || 0),
      right: th(a.right || 0),
      top: th(a.top || 0),
      bottom: th(a.bottom || 0)
    }, this.equals = this.equals.bind(this), Object.seal(this);
  }
  equals(e) {
    return this === e ? !0 : this.viewportInstance ? e.viewportInstance ? this.viewportInstance.equals(e.viewportInstance) : !1 : this.ViewportType === e.ViewportType && Kc(this.props, e.props, 2);
  }
  makeViewport(e) {
    let {
      width: t,
      height: i,
      viewState: r
    } = e;
    if (this.viewportInstance)
      return this.viewportInstance;
    r = this.filterViewState(r);
    const l = this.getDimensions({
      width: t,
      height: i
    });
    return !l.height || !l.width ? null : new this.ViewportType({
      ...r,
      ...this.props,
      ...l
    });
  }
  getViewStateId() {
    const {
      viewState: e
    } = this.props;
    return typeof e == "string" ? e : (e == null ? void 0 : e.id) || this.id;
  }
  filterViewState(e) {
    if (this.props.viewState && typeof this.props.viewState == "object") {
      if (!this.props.viewState.id)
        return this.props.viewState;
      const t = {
        ...e
      };
      for (const i in this.props.viewState)
        i !== "id" && (t[i] = this.props.viewState[i]);
      return t;
    }
    return e;
  }
  getDimensions(e) {
    let {
      width: t,
      height: i
    } = e;
    const r = {
      x: nh(this._x, t),
      y: nh(this._y, i),
      width: nh(this._width, t),
      height: nh(this._height, i)
    };
    return this._padding && (r.padding = {
      left: nh(this._padding.left, t),
      top: nh(this._padding.top, i),
      right: nh(this._padding.right, t),
      bottom: nh(this._padding.bottom, i)
    }), r;
  }
  get controller() {
    const e = this.props.controller;
    return e ? e === !0 ? {
      type: this.ControllerType
    } : typeof e == "function" ? {
      type: e
    } : {
      type: this.ControllerType,
      ...e
    } : null;
  }
}
class Xp {
  constructor(e) {
    H(this, "_inProgress", void 0), H(this, "_handle", void 0), H(this, "_timeline", void 0), H(this, "time", void 0), H(this, "settings", void 0), this._inProgress = !1, this._handle = null, this._timeline = e, this.time = 0, this.settings = {
      duration: 0
    };
  }
  get inProgress() {
    return this._inProgress;
  }
  start(e) {
    var t, i;
    this.cancel(), this.settings = e, this._inProgress = !0, (t = (i = this.settings).onStart) === null || t === void 0 || t.call(i, this);
  }
  end() {
    if (this._inProgress) {
      var e, t;
      this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, (e = (t = this.settings).onEnd) === null || e === void 0 || e.call(t, this);
    }
  }
  cancel() {
    if (this._inProgress) {
      var e, t;
      (e = (t = this.settings).onInterrupt) === null || e === void 0 || e.call(t, this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1;
    }
  }
  update() {
    var e, t;
    if (!this._inProgress)
      return !1;
    if (this._handle === null) {
      const {
        _timeline: i,
        settings: r
      } = this;
      this._handle = i.addChannel({
        delay: i.getTime(),
        duration: r.duration
      });
    }
    return this.time = this._timeline.getTime(this._handle), this._onUpdate(), (e = (t = this.settings).onUpdate) === null || e === void 0 || e.call(t, this), this._timeline.isFinished(this._handle) && this.end(), !0;
  }
  _onUpdate() {
  }
}
const Pw = () => {
}, t1 = {
  BREAK: 1,
  SNAP_TO_END: 2,
  IGNORE: 3
}, mN = (n) => n, _N = t1.BREAK;
class yN {
  constructor(e) {
    H(this, "getControllerState", void 0), H(this, "props", void 0), H(this, "propsInTransition", void 0), H(this, "transition", void 0), H(this, "onViewStateChange", void 0), H(this, "onStateChange", void 0), H(this, "_onTransitionUpdate", (t) => {
      const {
        time: i,
        settings: {
          interpolator: r,
          startProps: l,
          endProps: c,
          duration: a,
          easing: g
        }
      } = t, y = g(i / a), A = r.interpolateProps(l, c, y);
      this.propsInTransition = this.getControllerState({
        ...this.props,
        ...A
      }).getViewportProps(), this.onViewStateChange({
        viewState: this.propsInTransition,
        oldViewState: this.props
      });
    }), this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new Xp(e.timeline), this.onViewStateChange = e.onViewStateChange || Pw, this.onStateChange = e.onStateChange || Pw;
  }
  finalize() {
    this.transition.cancel();
  }
  getViewportInTransition() {
    return this.propsInTransition;
  }
  processViewStateChange(e) {
    let t = !1;
    const i = this.props;
    if (this.props = e, !i || this._shouldIgnoreViewportChange(i, e))
      return !1;
    if (this._isTransitionEnabled(e)) {
      let r = i;
      if (this.transition.inProgress) {
        const {
          interruption: l,
          endProps: c
        } = this.transition.settings;
        r = {
          ...i,
          ...l === t1.SNAP_TO_END ? c : this.propsInTransition || i
        };
      }
      this._triggerTransition(r, e), t = !0;
    } else
      this.transition.cancel();
    return t;
  }
  updateTransition() {
    this.transition.update();
  }
  _isTransitionEnabled(e) {
    const {
      transitionDuration: t,
      transitionInterpolator: i
    } = e;
    return (t > 0 || t === "auto") && !!i;
  }
  _isUpdateDueToCurrentTransition(e) {
    return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1;
  }
  _shouldIgnoreViewportChange(e, t) {
    return this.transition.inProgress ? this.transition.settings.interruption === t1.IGNORE || this._isUpdateDueToCurrentTransition(t) : this._isTransitionEnabled(t) ? t.transitionInterpolator.arePropsEqual(e, t) : !0;
  }
  _triggerTransition(e, t) {
    const i = this.getControllerState(e), r = this.getControllerState(t).shortestPathFrom(i), l = t.transitionInterpolator, c = l.getDuration ? l.getDuration(e, t) : t.transitionDuration;
    if (c === 0)
      return;
    const a = l.initializeProps(e, r);
    this.propsInTransition = {};
    const g = {
      duration: c,
      easing: t.transitionEasing || mN,
      interpolator: l,
      interruption: t.transitionInterruption || _N,
      startProps: a.start,
      endProps: a.end,
      onStart: t.onTransitionStart,
      onUpdate: this._onTransitionUpdate,
      onInterrupt: this._onTransitionEnd(t.onTransitionInterrupt),
      onEnd: this._onTransitionEnd(t.onTransitionEnd)
    };
    this.transition.start(g), this.onStateChange({
      inTransition: !0
    }), this.updateTransition();
  }
  _onTransitionEnd(e) {
    return (t) => {
      this.propsInTransition = null, this.onStateChange({
        inTransition: !1,
        isZooming: !1,
        isPanning: !1,
        isRotating: !1
      }), e == null || e(t);
    };
  }
}
class bN {
  constructor(e) {
    H(this, "_propsToCompare", void 0), H(this, "_propsToExtract", void 0), H(this, "_requiredProps", void 0);
    const {
      compare: t,
      extract: i,
      required: r
    } = e;
    this._propsToCompare = t, this._propsToExtract = i || t, this._requiredProps = r;
  }
  arePropsEqual(e, t) {
    for (const i of this._propsToCompare)
      if (!(i in e) || !(i in t) || !bc(e[i], t[i]))
        return !1;
    return !0;
  }
  initializeProps(e, t) {
    const i = {}, r = {};
    for (const l of this._propsToExtract)
      (l in e || l in t) && (i[l] = e[l], r[l] = t[l]);
    return this._checkRequiredProps(i), this._checkRequiredProps(r), {
      start: i,
      end: r
    };
  }
  getDuration(e, t) {
    return t.transitionDuration;
  }
  _checkRequiredProps(e) {
    this._requiredProps && this._requiredProps.forEach((t) => {
      const i = e[t];
      wo(Number.isFinite(i) || Array.isArray(i), "".concat(t, " is required for transition"));
    });
  }
}
const vN = ["longitude", "latitude", "zoom", "bearing", "pitch"], xN = ["longitude", "latitude", "zoom"];
class VE extends bN {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = Array.isArray(e) ? e : e.transitionProps, i = Array.isArray(e) ? {} : e;
    i.transitionProps = Array.isArray(t) ? {
      compare: t,
      required: t
    } : t || {
      compare: vN,
      required: xN
    }, super(i.transitionProps), H(this, "opts", void 0), this.opts = i;
  }
  initializeProps(e, t) {
    const i = super.initializeProps(e, t), {
      makeViewport: r,
      around: l
    } = this.opts;
    if (r && l) {
      const c = r(e), a = r(t), g = c.unproject(l);
      i.start.around = l, Object.assign(i.end, {
        around: a.project(g),
        aroundPosition: g,
        width: t.width,
        height: t.height
      });
    }
    return i;
  }
  interpolateProps(e, t, i) {
    const r = {};
    for (const l of this._propsToExtract)
      r[l] = Rm(e[l] || 0, t[l] || 0, i);
    if (t.aroundPosition && this.opts.makeViewport) {
      const l = this.opts.makeViewport({
        ...t,
        ...r
      });
      Object.assign(r, l.panByPosition(t.aroundPosition, Rm(e.around, t.around, i)));
    }
    return r;
  }
}
const ih = {
  transitionDuration: 0
}, wN = 300, Ng = (n) => 1 - (1 - n) * (1 - n), Rd = {
  WHEEL: ["wheel"],
  PAN: ["panstart", "panmove", "panend"],
  PINCH: ["pinchstart", "pinchmove", "pinchend"],
  TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
  DOUBLE_TAP: ["doubletap"],
  KEYBOARD: ["keydown"]
}, Bh = {};
class AN {
  constructor(e) {
    H(this, "props", void 0), H(this, "state", {}), H(this, "transitionManager", void 0), H(this, "eventManager", void 0), H(this, "onViewStateChange", void 0), H(this, "onStateChange", void 0), H(this, "makeViewport", void 0), H(this, "_controllerState", void 0), H(this, "_events", {}), H(this, "_interactionState", {
      isDragging: !1
    }), H(this, "_customEvents", []), H(this, "_eventStartBlocked", null), H(this, "_panMove", !1), H(this, "invertPan", !1), H(this, "dragMode", "rotate"), H(this, "inertia", 0), H(this, "scrollZoom", !0), H(this, "dragPan", !0), H(this, "dragRotate", !0), H(this, "doubleClickZoom", !0), H(this, "touchZoom", !0), H(this, "touchRotate", !1), H(this, "keyboard", !0), this.transitionManager = new yN({
      ...e,
      getControllerState: (t) => new this.ControllerState(t),
      onViewStateChange: this._onTransition.bind(this),
      onStateChange: this._setInteractionState.bind(this)
    }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {
    }), this.onStateChange = e.onStateChange || (() => {
    }), this.makeViewport = e.makeViewport;
  }
  set events(e) {
    this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props);
  }
  finalize() {
    for (const t in this._events)
      if (this._events[t]) {
        var e;
        (e = this.eventManager) === null || e === void 0 || e.off(t, this.handleEvent);
      }
    this.transitionManager.finalize();
  }
  handleEvent(e) {
    this._controllerState = void 0;
    const t = this._eventStartBlocked;
    switch (e.type) {
      case "panstart":
        return t ? !1 : this._onPanStart(e);
      case "panmove":
        return this._onPan(e);
      case "panend":
        return this._onPanEnd(e);
      case "pinchstart":
        return t ? !1 : this._onPinchStart(e);
      case "pinchmove":
        return this._onPinch(e);
      case "pinchend":
        return this._onPinchEnd(e);
      case "tripanstart":
        return t ? !1 : this._onTriplePanStart(e);
      case "tripanmove":
        return this._onTriplePan(e);
      case "tripanend":
        return this._onTriplePanEnd(e);
      case "doubletap":
        return this._onDoubleTap(e);
      case "wheel":
        return this._onWheel(e);
      case "keydown":
        return this._onKeyDown(e);
      default:
        return !1;
    }
  }
  get controllerState() {
    return this._controllerState = this._controllerState || new this.ControllerState({
      makeViewport: this.makeViewport,
      ...this.props,
      ...this.state
    }), this._controllerState;
  }
  getCenter(e) {
    const {
      x: t,
      y: i
    } = this.props, {
      offsetCenter: r
    } = e;
    return [r.x - t, r.y - i];
  }
  isPointInBounds(e, t) {
    const {
      width: i,
      height: r
    } = this.props;
    if (t && t.handled)
      return !1;
    const l = e[0] >= 0 && e[0] <= i && e[1] >= 0 && e[1] <= r;
    return l && t && t.stopPropagation(), l;
  }
  isFunctionKeyPressed(e) {
    const {
      srcEvent: t
    } = e;
    return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
  }
  isDragging() {
    return this._interactionState.isDragging || !1;
  }
  blockEvents(e) {
    const t = setTimeout(() => {
      this._eventStartBlocked === t && (this._eventStartBlocked = null);
    }, e);
    this._eventStartBlocked = t;
  }
  setProps(e) {
    e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
    const {
      inertia: t
    } = e;
    this.inertia = Number.isFinite(t) ? t : t === !0 ? wN : 0;
    const {
      scrollZoom: i = !0,
      dragPan: r = !0,
      dragRotate: l = !0,
      doubleClickZoom: c = !0,
      touchZoom: a = !0,
      touchRotate: g = !1,
      keyboard: y = !0
    } = e, A = !!this.onViewStateChange;
    this.toggleEvents(Rd.WHEEL, A && i), this.toggleEvents(Rd.PAN, A), this.toggleEvents(Rd.PINCH, A && (a || g)), this.toggleEvents(Rd.TRIPLE_PAN, A && g), this.toggleEvents(Rd.DOUBLE_TAP, A && c), this.toggleEvents(Rd.KEYBOARD, A && y), this.scrollZoom = i, this.dragPan = r, this.dragRotate = l, this.doubleClickZoom = c, this.touchZoom = a, this.touchRotate = g, this.keyboard = y;
  }
  updateTransition() {
    this.transitionManager.updateTransition();
  }
  toggleEvents(e, t) {
    this.eventManager && e.forEach((i) => {
      this._events[i] !== t && (this._events[i] = t, t ? this.eventManager.on(i, this.handleEvent) : this.eventManager.off(i, this.handleEvent));
    });
  }
  updateViewport(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = {
      ...e.getViewportProps(),
      ...t
    }, l = this.controllerState !== e;
    if (this.state = e.getState(), this._setInteractionState(i), l) {
      const c = this.controllerState && this.controllerState.getViewportProps();
      this.onViewStateChange && this.onViewStateChange({
        viewState: r,
        interactionState: this._interactionState,
        oldViewState: c
      });
    }
  }
  _onTransition(e) {
    this.onViewStateChange({
      ...e,
      interactionState: this._interactionState
    });
  }
  _setInteractionState(e) {
    Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
  }
  _onPanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    let i = this.isFunctionKeyPressed(e) || e.rightButton || !1;
    (this.invertPan || this.dragMode === "pan") && (i = !i);
    const r = this.controllerState[i ? "panStart" : "rotateStart"]({
      pos: t
    });
    return this._panMove = i, this.updateViewport(r, ih, {
      isDragging: !0
    }), !0;
  }
  _onPan(e) {
    return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1;
  }
  _onPanEnd(e) {
    return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1;
  }
  _onPanMove(e) {
    if (!this.dragPan)
      return !1;
    const t = this.getCenter(e), i = this.controllerState.pan({
      pos: t
    });
    return this.updateViewport(i, ih, {
      isDragging: !0,
      isPanning: !0
    }), !0;
  }
  _onPanMoveEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragPan && t && e.velocity) {
      const i = this.getCenter(e), r = [i[0] + e.velocityX * t / 2, i[1] + e.velocityY * t / 2], l = this.controllerState.pan({
        pos: r
      }).panEnd();
      this.updateViewport(l, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Ng
      }, {
        isDragging: !1,
        isPanning: !0
      });
    } else {
      const i = this.controllerState.panEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isPanning: !1
      });
    }
    return !0;
  }
  _onPanRotate(e) {
    if (!this.dragRotate)
      return !1;
    const t = this.getCenter(e), i = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(i, ih, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onPanRotateEnd(e) {
    const {
      inertia: t
    } = this;
    if (this.dragRotate && t && e.velocity) {
      const i = this.getCenter(e), r = [i[0] + e.velocityX * t / 2, i[1] + e.velocityY * t / 2], l = this.controllerState.rotate({
        pos: r
      }).rotateEnd();
      this.updateViewport(l, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Ng
      }, {
        isDragging: !1,
        isRotating: !0
      });
    } else {
      const i = this.controllerState.rotateEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  _onWheel(e) {
    if (!this.scrollZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    e.srcEvent.preventDefault();
    const {
      speed: i = 0.01,
      smooth: r = !1
    } = this.scrollZoom === !0 ? {} : this.scrollZoom, {
      delta: l
    } = e;
    let c = 2 / (1 + Math.exp(-Math.abs(l * i)));
    l < 0 && c !== 0 && (c = 1 / c);
    const a = this.controllerState.zoom({
      pos: t,
      scale: c
    });
    return this.updateViewport(a, {
      ...this._getTransitionProps({
        around: t
      }),
      transitionDuration: r ? 250 : 1
    }, {
      isZooming: !0,
      isPanning: !0
    }), !0;
  }
  _onTriplePanStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const i = this.controllerState.rotateStart({
      pos: t
    });
    return this.updateViewport(i, ih, {
      isDragging: !0
    }), !0;
  }
  _onTriplePan(e) {
    if (!this.touchRotate || !this.isDragging())
      return !1;
    const t = this.getCenter(e);
    t[0] -= e.deltaX;
    const i = this.controllerState.rotate({
      pos: t
    });
    return this.updateViewport(i, ih, {
      isDragging: !0,
      isRotating: !0
    }), !0;
  }
  _onTriplePanEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this;
    if (this.touchRotate && t && e.velocityY) {
      const i = this.getCenter(e), r = [i[0], i[1] += e.velocityY * t / 2], l = this.controllerState.rotate({
        pos: r
      });
      this.updateViewport(l, {
        ...this._getTransitionProps(),
        transitionDuration: t,
        transitionEasing: Ng
      }, {
        isDragging: !1,
        isRotating: !0
      }), this.blockEvents(t);
    } else {
      const i = this.controllerState.rotateEnd();
      this.updateViewport(i, null, {
        isDragging: !1,
        isRotating: !1
      });
    }
    return !0;
  }
  _onPinchStart(e) {
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const i = this.controllerState.zoomStart({
      pos: t
    }).rotateStart({
      pos: t
    });
    return Bh._startPinchRotation = e.rotation, Bh._lastPinchEvent = e, this.updateViewport(i, ih, {
      isDragging: !0
    }), !0;
  }
  _onPinch(e) {
    if (!this.touchZoom && !this.touchRotate || !this.isDragging())
      return !1;
    let t = this.controllerState;
    if (this.touchZoom) {
      const {
        scale: i
      } = e, r = this.getCenter(e);
      t = t.zoom({
        pos: r,
        scale: i
      });
    }
    if (this.touchRotate) {
      const {
        rotation: i
      } = e;
      t = t.rotate({
        deltaAngleX: Bh._startPinchRotation - i
      });
    }
    return this.updateViewport(t, ih, {
      isDragging: !0,
      isPanning: this.touchZoom,
      isZooming: this.touchZoom,
      isRotating: this.touchRotate
    }), Bh._lastPinchEvent = e, !0;
  }
  _onPinchEnd(e) {
    if (!this.isDragging())
      return !1;
    const {
      inertia: t
    } = this, {
      _lastPinchEvent: i
    } = Bh;
    if (this.touchZoom && t && i && e.scale !== i.scale) {
      const r = this.getCenter(e);
      let l = this.controllerState.rotateEnd();
      const c = Math.log2(e.scale), a = (c - Math.log2(i.scale)) / (e.deltaTime - i.deltaTime), g = Math.pow(2, c + a * t / 2);
      l = l.zoom({
        pos: r,
        scale: g
      }).zoomEnd(), this.updateViewport(l, {
        ...this._getTransitionProps({
          around: r
        }),
        transitionDuration: t,
        transitionEasing: Ng
      }, {
        isDragging: !1,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: !1
      }), this.blockEvents(t);
    } else {
      const r = this.controllerState.zoomEnd().rotateEnd();
      this.updateViewport(r, null, {
        isDragging: !1,
        isPanning: !1,
        isZooming: !1,
        isRotating: !1
      });
    }
    return Bh._startPinchRotation = null, Bh._lastPinchEvent = null, !0;
  }
  _onDoubleTap(e) {
    if (!this.doubleClickZoom)
      return !1;
    const t = this.getCenter(e);
    if (!this.isPointInBounds(t, e))
      return !1;
    const i = this.isFunctionKeyPressed(e), r = this.controllerState.zoom({
      pos: t,
      scale: i ? 0.5 : 2
    });
    return this.updateViewport(r, this._getTransitionProps({
      around: t
    }), {
      isZooming: !0,
      isPanning: !0
    }), this.blockEvents(100), !0;
  }
  _onKeyDown(e) {
    if (!this.keyboard)
      return !1;
    const t = this.isFunctionKeyPressed(e), {
      zoomSpeed: i,
      moveSpeed: r,
      rotateSpeedX: l,
      rotateSpeedY: c
    } = this.keyboard === !0 ? {} : this.keyboard, {
      controllerState: a
    } = this;
    let g;
    const y = {};
    switch (e.srcEvent.code) {
      case "Minus":
        g = t ? a.zoomOut(i).zoomOut(i) : a.zoomOut(i), y.isZooming = !0;
        break;
      case "Equal":
        g = t ? a.zoomIn(i).zoomIn(i) : a.zoomIn(i), y.isZooming = !0;
        break;
      case "ArrowLeft":
        t ? (g = a.rotateLeft(l), y.isRotating = !0) : (g = a.moveLeft(r), y.isPanning = !0);
        break;
      case "ArrowRight":
        t ? (g = a.rotateRight(l), y.isRotating = !0) : (g = a.moveRight(r), y.isPanning = !0);
        break;
      case "ArrowUp":
        t ? (g = a.rotateUp(c), y.isRotating = !0) : (g = a.moveUp(r), y.isPanning = !0);
        break;
      case "ArrowDown":
        t ? (g = a.rotateDown(c), y.isRotating = !0) : (g = a.moveDown(r), y.isPanning = !0);
        break;
      default:
        return !1;
    }
    return this.updateViewport(g, this._getTransitionProps(), y), !0;
  }
  _getTransitionProps(e) {
    const {
      transition: t
    } = this;
    return !t || !t.transitionInterpolator ? ih : e ? {
      ...t,
      transitionInterpolator: new VE({
        ...e,
        ...t.transitionInterpolator.opts,
        makeViewport: this.controllerState.makeViewport
      })
    } : t;
  }
}
class TN {
  constructor(e, t) {
    H(this, "_viewportProps", void 0), H(this, "_state", void 0), this._viewportProps = this.applyConstraints(e), this._state = t;
  }
  getViewportProps() {
    return this._viewportProps;
  }
  getState() {
    return this._state;
  }
}
const Iw = 5, EN = 1.2;
class SN extends TN {
  constructor(e) {
    const {
      width: t,
      height: i,
      latitude: r,
      longitude: l,
      zoom: c,
      bearing: a = 0,
      pitch: g = 0,
      altitude: y = 1.5,
      position: A = [0, 0, 0],
      maxZoom: C = 20,
      minZoom: I = 0,
      maxPitch: S = 60,
      minPitch: F = 0,
      startPanLngLat: U,
      startZoomLngLat: V,
      startRotatePos: W,
      startBearing: X,
      startPitch: de,
      startZoom: ie,
      normalize: fe = !0
    } = e;
    wo(Number.isFinite(l)), wo(Number.isFinite(r)), wo(Number.isFinite(c)), super({
      width: t,
      height: i,
      latitude: r,
      longitude: l,
      zoom: c,
      bearing: a,
      pitch: g,
      altitude: y,
      maxZoom: C,
      minZoom: I,
      maxPitch: S,
      minPitch: F,
      normalize: fe,
      position: A
    }, {
      startPanLngLat: U,
      startZoomLngLat: V,
      startRotatePos: W,
      startBearing: X,
      startPitch: de,
      startZoom: ie
    }), H(this, "makeViewport", void 0), this.makeViewport = e.makeViewport;
  }
  panStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startPanLngLat: this._unproject(t)
    });
  }
  pan(e) {
    let {
      pos: t,
      startPos: i
    } = e;
    const r = this.getState().startPanLngLat || this._unproject(i);
    if (!r)
      return this;
    const c = this.makeViewport(this.getViewportProps()).panByPosition(r, t);
    return this._getUpdatedState(c);
  }
  panEnd() {
    return this._getUpdatedState({
      startPanLngLat: null
    });
  }
  rotateStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startRotatePos: t,
      startBearing: this.getViewportProps().bearing,
      startPitch: this.getViewportProps().pitch
    });
  }
  rotate(e) {
    let {
      pos: t,
      deltaAngleX: i = 0,
      deltaAngleY: r = 0
    } = e;
    const {
      startRotatePos: l,
      startBearing: c,
      startPitch: a
    } = this.getState();
    if (!l || c === void 0 || a === void 0)
      return this;
    let g;
    return t ? g = this._getNewRotation(t, l, a, c) : g = {
      bearing: c + i,
      pitch: a + r
    }, this._getUpdatedState(g);
  }
  rotateEnd() {
    return this._getUpdatedState({
      startBearing: null,
      startPitch: null
    });
  }
  zoomStart(e) {
    let {
      pos: t
    } = e;
    return this._getUpdatedState({
      startZoomLngLat: this._unproject(t),
      startZoom: this.getViewportProps().zoom
    });
  }
  zoom(e) {
    let {
      pos: t,
      startPos: i,
      scale: r
    } = e, {
      startZoom: l,
      startZoomLngLat: c
    } = this.getState();
    if (c || (l = this.getViewportProps().zoom, c = this._unproject(i) || this._unproject(t)), !c)
      return this;
    const {
      maxZoom: a,
      minZoom: g
    } = this.getViewportProps();
    let y = l + Math.log2(r);
    y = Pu(y, g, a);
    const A = this.makeViewport({
      ...this.getViewportProps(),
      zoom: y
    });
    return this._getUpdatedState({
      zoom: y,
      ...A.panByPosition(c, t)
    });
  }
  zoomEnd() {
    return this._getUpdatedState({
      startZoomLngLat: null,
      startZoom: null
    });
  }
  zoomIn() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
    return this._zoomFromCenter(e);
  }
  zoomOut() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 2;
    return this._zoomFromCenter(1 / e);
  }
  moveLeft() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([e, 0]);
  }
  moveRight() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([-e, 0]);
  }
  moveUp() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([0, e]);
  }
  moveDown() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 100;
    return this._panFromCenter([0, -e]);
  }
  rotateLeft() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing - e
    });
  }
  rotateRight() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 15;
    return this._getUpdatedState({
      bearing: this.getViewportProps().bearing + e
    });
  }
  rotateUp() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch + e
    });
  }
  rotateDown() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
    return this._getUpdatedState({
      pitch: this.getViewportProps().pitch - e
    });
  }
  shortestPathFrom(e) {
    const t = e.getViewportProps(), i = {
      ...this.getViewportProps()
    }, {
      bearing: r,
      longitude: l
    } = i;
    return Math.abs(r - t.bearing) > 180 && (i.bearing = r < 0 ? r + 360 : r - 360), Math.abs(l - t.longitude) > 180 && (i.longitude = l < 0 ? l + 360 : l - 360), i;
  }
  applyConstraints(e) {
    const {
      maxZoom: t,
      minZoom: i,
      zoom: r
    } = e;
    e.zoom = Pu(r, i, t);
    const {
      maxPitch: l,
      minPitch: c,
      pitch: a
    } = e;
    e.pitch = Pu(a, c, l);
    const {
      normalize: g = !0
    } = e;
    return g && Object.assign(e, LF(e)), e;
  }
  _zoomFromCenter(e) {
    const {
      width: t,
      height: i
    } = this.getViewportProps();
    return this.zoom({
      pos: [t / 2, i / 2],
      scale: e
    });
  }
  _panFromCenter(e) {
    const {
      width: t,
      height: i
    } = this.getViewportProps();
    return this.pan({
      startPos: [t / 2, i / 2],
      pos: [t / 2 + e[0], i / 2 + e[1]]
    });
  }
  _getUpdatedState(e) {
    return new this.constructor({
      makeViewport: this.makeViewport,
      ...this.getViewportProps(),
      ...this.getState(),
      ...e
    });
  }
  _unproject(e) {
    const t = this.makeViewport(this.getViewportProps());
    return e && t.unproject(e);
  }
  _getNewRotation(e, t, i, r) {
    const l = e[0] - t[0], c = e[1] - t[1], a = e[1], g = t[1], {
      width: y,
      height: A
    } = this.getViewportProps(), C = l / y;
    let I = 0;
    c > 0 ? Math.abs(A - g) > Iw && (I = c / (g - A) * EN) : c < 0 && g > Iw && (I = 1 - a / g), I = Pu(I, -1, 1);
    const {
      minPitch: S,
      maxPitch: F
    } = this.getViewportProps(), U = r + 180 * C;
    let V = i;
    return I > 0 ? V = i + I * (F - i) : I < 0 && (V = i - I * (S - i)), {
      pitch: V,
      bearing: U
    };
  }
}
class CN extends AN {
  constructor() {
    super(...arguments), H(this, "ControllerState", SN), H(this, "transition", {
      transitionDuration: 300,
      transitionInterpolator: new VE({
        transitionProps: {
          compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
          required: ["longitude", "latitude", "zoom"]
        }
      })
    }), H(this, "dragMode", "pan");
  }
  setProps(e) {
    e.position = e.position || [0, 0, 0];
    const t = this.props;
    super.setProps(e), (!t || t.height !== e.height) && this.updateViewport(new this.ControllerState({
      makeViewport: this.makeViewport,
      ...e,
      ...this.state
    }));
  }
}
class Pb extends gN {
  get ViewportType() {
    return Kh;
  }
  get ControllerType() {
    return CN;
  }
}
H(Pb, "displayName", "MapView");
const PN = new Eb();
function IN(n, e) {
  var t, i;
  const r = (t = n.order) !== null && t !== void 0 ? t : 1 / 0, l = (i = e.order) !== null && i !== void 0 ? i : 1 / 0;
  return r - l;
}
class MN {
  constructor() {
    H(this, "effects", void 0), H(this, "_resolvedEffects", []), H(this, "_defaultEffects", []), H(this, "_needsRedraw", void 0), this.effects = [], this._needsRedraw = "Initial render", this._setEffects([]);
  }
  addDefaultEffect(e) {
    const t = this._defaultEffects;
    if (!t.find((i) => i.id === e.id)) {
      const i = t.findIndex((r) => IN(r, e) > 0);
      i < 0 ? t.push(e) : t.splice(i, 0, e), this._setEffects(this.effects);
    }
  }
  setProps(e) {
    "effects" in e && (Kc(e.effects, this.effects, 1) || this._setEffects(e.effects));
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  getEffects() {
    return this._resolvedEffects;
  }
  _setEffects(e) {
    const t = {};
    for (const r of this.effects)
      t[r.id] = r;
    const i = [];
    for (const r of e) {
      const l = t[r.id];
      l && l !== r ? l.setProps ? (l.setProps(r.props), i.push(l)) : (l.cleanup(), i.push(r)) : i.push(r), delete t[r.id];
    }
    for (const r in t)
      t[r].cleanup();
    this.effects = i, this._resolvedEffects = i.concat(this._defaultEffects), e.some((r) => r instanceof Eb) || this._resolvedEffects.push(PN), this._needsRedraw = "effects changed";
  }
  finalize() {
    for (const e of this._resolvedEffects)
      e.cleanup();
    this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
  }
}
class LN extends xb {
  shouldDrawLayer(e) {
    const {
      operation: t
    } = e.props;
    return t.includes("draw") || t.includes("terrain");
  }
}
const RN = "deckRenderer.renderLayers";
class BN {
  constructor(e) {
    H(this, "gl", void 0), H(this, "layerFilter", void 0), H(this, "drawPickingColors", void 0), H(this, "drawLayersPass", void 0), H(this, "pickLayersPass", void 0), H(this, "renderCount", void 0), H(this, "_needsRedraw", void 0), H(this, "renderBuffers", void 0), H(this, "lastPostProcessEffect", void 0), this.gl = e, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new LN(e), this.pickLayersPass = new jE(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
  }
  setProps(e) {
    this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
  }
  renderLayers(e) {
    if (!e.viewports.length)
      return;
    const t = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, i = {
      layerFilter: this.layerFilter,
      isPicking: this.drawPickingColors,
      ...e,
      target: e.target || Vs.getDefaultFramebuffer(this.gl)
    };
    i.effects && this._preRender(i.effects, i);
    const r = this.lastPostProcessEffect ? this.renderBuffers[0] : i.target, l = t.render({
      ...i,
      target: r
    });
    i.effects && this._postRender(i.effects, i), this.renderCount++, Vo(RN, this, l, e);
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this._needsRedraw;
    return e.clearRedrawFlags && (this._needsRedraw = !1), t;
  }
  finalize() {
    const {
      renderBuffers: e
    } = this;
    for (const t of e)
      t.delete();
    e.length = 0;
  }
  _preRender(e, t) {
    this.lastPostProcessEffect = null, t.preRenderStats = t.preRenderStats || {};
    for (const i of e)
      t.preRenderStats[i.id] = i.preRender(this.gl, t), i.postRender && (this.lastPostProcessEffect = i.id);
    this.lastPostProcessEffect && this._resizeRenderBuffers();
  }
  _resizeRenderBuffers() {
    const {
      renderBuffers: e
    } = this;
    e.length === 0 && e.push(new Vs(this.gl), new Vs(this.gl));
    for (const t of e)
      t.resize();
  }
  _postRender(e, t) {
    const {
      renderBuffers: i
    } = this, r = {
      ...t,
      inputBuffer: i[0],
      swapBuffer: i[1],
      target: null
    };
    for (const l of e)
      if (l.postRender) {
        if (l.id === this.lastPostProcessEffect) {
          r.target = t.target, l.postRender(this.gl, r);
          break;
        }
        const c = l.postRender(this.gl, r);
        r.inputBuffer = c, r.swapBuffer = c === i[0] ? i[1] : i[0];
      }
  }
}
const ON = {
  pickedColor: null,
  pickedObjectIndex: -1
};
function DN(n) {
  let {
    pickedColors: e,
    decodePickingColor: t,
    deviceX: i,
    deviceY: r,
    deviceRadius: l,
    deviceRect: c
  } = n;
  const {
    x: a,
    y: g,
    width: y,
    height: A
  } = c;
  let C = l * l, I = -1, S = 0;
  for (let F = 0; F < A; F++) {
    const U = F + g - r, V = U * U;
    if (V > C)
      S += 4 * y;
    else
      for (let W = 0; W < y; W++) {
        if (e[S + 3] - 1 >= 0) {
          const de = W + a - i, ie = de * de + V;
          ie <= C && (C = ie, I = S);
        }
        S += 4;
      }
  }
  if (I >= 0) {
    const F = e.slice(I, I + 4), U = t(F);
    if (U) {
      const V = Math.floor(I / 4 / y), W = I / 4 - V * y;
      return {
        ...U,
        pickedColor: F,
        pickedX: a + W,
        pickedY: g + V
      };
    }
    zi.error("Picked non-existent layer. Is picking buffer corrupt?")();
  }
  return ON;
}
function FN(n) {
  let {
    pickedColors: e,
    decodePickingColor: t
  } = n;
  const i = /* @__PURE__ */ new Map();
  if (e) {
    for (let r = 0; r < e.length; r += 4)
      if (e[r + 3] - 1 >= 0) {
        const c = e.slice(r, r + 4), a = c.join(",");
        if (!i.has(a)) {
          const g = t(c);
          g ? i.set(a, {
            ...g,
            color: c
          }) : zi.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
  }
  return Array.from(i.values());
}
function qE(n) {
  let {
    pickInfo: e,
    viewports: t,
    pixelRatio: i,
    x: r,
    y: l,
    z: c
  } = n, a = t[0];
  t.length > 1 && (a = kN((e == null ? void 0 : e.pickedViewports) || t, {
    x: r,
    y: l
  }));
  let g;
  if (a) {
    const y = [r - a.x, l - a.y];
    c !== void 0 && (y[2] = c), g = a.unproject(y);
  }
  return {
    color: null,
    layer: null,
    viewport: a,
    index: -1,
    picked: !1,
    x: r,
    y: l,
    pixel: [r, l],
    coordinate: g,
    devicePixel: e && "pickedX" in e ? [e.pickedX, e.pickedY] : void 0,
    pixelRatio: i
  };
}
function NN(n) {
  const {
    pickInfo: e,
    lastPickedInfo: t,
    mode: i,
    layers: r
  } = n, {
    pickedColor: l,
    pickedLayer: c,
    pickedObjectIndex: a
  } = e, g = c ? [c] : [];
  if (i === "hover") {
    const C = t.index, I = t.layerId, S = c ? c.props.id : null;
    if (S !== I || a !== C) {
      if (S !== I) {
        const F = r.find((U) => U.props.id === I);
        F && g.unshift(F);
      }
      t.layerId = S, t.index = a, t.info = null;
    }
  }
  const y = qE(n), A = /* @__PURE__ */ new Map();
  return A.set(null, y), g.forEach((C) => {
    let I = {
      ...y
    };
    C === c && (I.color = l, I.index = a, I.picked = !0), I = HE({
      layer: C,
      info: I,
      mode: i
    });
    const S = I.layer;
    C === c && i === "hover" && (t.info = I), A.set(S.id, I), i === "hover" && S.updateAutoHighlight(I);
  }), A;
}
function HE(n) {
  let {
    layer: e,
    info: t,
    mode: i
  } = n;
  for (; e && t; ) {
    const r = t.layer || null;
    t.sourceLayer = r, t.layer = e, t = e.getPickingInfo({
      info: t,
      mode: i,
      sourceLayer: r
    }), e = e.parent;
  }
  return t;
}
function kN(n, e) {
  for (let t = n.length - 1; t >= 0; t--) {
    const i = n[t];
    if (i.containsPixel(e))
      return i;
  }
  return n[0];
}
class zN {
  constructor(e) {
    H(this, "gl", void 0), H(this, "pickingFBO", void 0), H(this, "depthFBO", void 0), H(this, "pickLayersPass", void 0), H(this, "layerFilter", void 0), H(this, "lastPickedInfo", void 0), H(this, "_pickable", !0), this.gl = e, this.pickLayersPass = new jE(e), this.lastPickedInfo = {
      index: -1,
      layerId: null,
      info: null
    };
  }
  setProps(e) {
    "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
  }
  finalize() {
    this.pickingFBO && this.pickingFBO.delete(), this.depthFBO && (this.depthFBO.color.delete(), this.depthFBO.delete());
  }
  pickObject(e) {
    return this._pickClosestObject(e);
  }
  pickObjects(e) {
    return this._pickVisibleObjects(e);
  }
  getLastPickedObject(e) {
    let {
      x: t,
      y: i,
      layers: r,
      viewports: l
    } = e, c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.lastPickedInfo.info;
    const a = c && c.layer && c.layer.id, g = c && c.viewport && c.viewport.id, y = a ? r.find((S) => S.id === a) : null, A = g && l.find((S) => S.id === g) || l[0], C = A && A.unproject([t - A.x, i - A.y]);
    return {
      ...c,
      ...{
        x: t,
        y: i,
        viewport: A,
        coordinate: C,
        layer: y
      }
    };
  }
  _resizeBuffer() {
    var e, t;
    const {
      gl: i
    } = this;
    if (!this.pickingFBO && (this.pickingFBO = new Vs(i), Vs.isSupported(i, {
      colorBufferFloat: !0
    }))) {
      const r = new Vs(i);
      r.attach({
        36064: new rl(i, {
          format: Si(i) ? 34836 : 6408,
          type: 5126
        })
      }), this.depthFBO = r;
    }
    (e = this.pickingFBO) === null || e === void 0 || e.resize({
      width: i.canvas.width,
      height: i.canvas.height
    }), (t = this.depthFBO) === null || t === void 0 || t.resize({
      width: i.canvas.width,
      height: i.canvas.height
    });
  }
  _getPickable(e) {
    if (this._pickable === !1)
      return null;
    const t = e.filter((i) => this.pickLayersPass.shouldDrawLayer(i) && !i.isComposite);
    return t.length ? t : null;
  }
  _pickClosestObject(e) {
    let {
      layers: t,
      views: i,
      viewports: r,
      x: l,
      y: c,
      radius: a = 0,
      depth: g = 1,
      mode: y = "query",
      unproject3D: A,
      onViewportActive: C,
      effects: I
    } = e;
    const S = this._getPickable(t), F = sf(this.gl);
    if (!S)
      return {
        result: [],
        emptyInfo: qE({
          viewports: r,
          x: l,
          y: c,
          pixelRatio: F
        })
      };
    this._resizeBuffer();
    const U = w0(this.gl, [l, c], !0), V = [U.x + Math.floor(U.width / 2), U.y + Math.floor(U.height / 2)], W = Math.round(a * F), {
      width: X,
      height: de
    } = this.pickingFBO, ie = this._getPickingRect({
      deviceX: V[0],
      deviceY: V[1],
      deviceRadius: W,
      deviceWidth: X,
      deviceHeight: de
    }), fe = {
      x: l - a,
      y: c - a,
      width: a * 2 + 1,
      height: a * 2 + 1
    };
    let Ae;
    const Te = [], me = /* @__PURE__ */ new Set();
    for (let Ge = 0; Ge < g; Ge++) {
      let ke;
      if (ie) {
        const _e = this._drawAndSample({
          layers: S,
          views: i,
          viewports: r,
          onViewportActive: C,
          deviceRect: ie,
          cullRect: fe,
          effects: I,
          pass: "picking:".concat(y)
        });
        ke = DN({
          ..._e,
          deviceX: V[0],
          deviceY: V[1],
          deviceRadius: W,
          deviceRect: ie
        });
      } else
        ke = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
      let pe;
      if (ke.pickedLayer && A && this.depthFBO) {
        const {
          pickedColors: _e
        } = this._drawAndSample({
          layers: [ke.pickedLayer],
          views: i,
          viewports: r,
          onViewportActive: C,
          deviceRect: {
            x: ke.pickedX,
            y: ke.pickedY,
            width: 1,
            height: 1
          },
          cullRect: fe,
          effects: I,
          pass: "picking:".concat(y, ":z")
        }, !0);
        _e[3] && (pe = _e[0]);
      }
      ke.pickedLayer && Ge + 1 < g && (me.add(ke.pickedLayer), ke.pickedLayer.disablePickingIndex(ke.pickedObjectIndex)), Ae = NN({
        pickInfo: ke,
        lastPickedInfo: this.lastPickedInfo,
        mode: y,
        layers: S,
        viewports: r,
        x: l,
        y: c,
        z: pe,
        pixelRatio: F
      });
      for (const _e of Ae.values())
        _e.layer && Te.push(_e);
      if (!ke.pickedColor)
        break;
    }
    for (const Ge of me)
      Ge.restorePickingColors();
    return {
      result: Te,
      emptyInfo: Ae.get(null)
    };
  }
  _pickVisibleObjects(e) {
    let {
      layers: t,
      views: i,
      viewports: r,
      x: l,
      y: c,
      width: a = 1,
      height: g = 1,
      mode: y = "query",
      maxObjects: A = null,
      onViewportActive: C,
      effects: I
    } = e;
    const S = this._getPickable(t);
    if (!S)
      return [];
    this._resizeBuffer();
    const F = sf(this.gl), U = w0(this.gl, [l, c], !0), V = U.x, W = U.y + U.height, X = w0(this.gl, [l + a, c + g], !0), de = X.x + X.width, ie = X.y, fe = {
      x: V,
      y: ie,
      width: de - V,
      height: W - ie
    }, Ae = this._drawAndSample({
      layers: S,
      views: i,
      viewports: r,
      onViewportActive: C,
      deviceRect: fe,
      cullRect: {
        x: l,
        y: c,
        width: a,
        height: g
      },
      effects: I,
      pass: "picking:".concat(y)
    }), Te = FN(Ae), me = /* @__PURE__ */ new Map(), Ge = Number.isFinite(A);
    for (let pe = 0; pe < Te.length; pe++) {
      var ke;
      if (Ge && A && me.size >= A)
        break;
      const _e = Te[pe];
      let De = {
        color: _e.pickedColor,
        layer: null,
        index: _e.pickedObjectIndex,
        picked: !0,
        x: l,
        y: c,
        pixelRatio: F
      };
      De = HE({
        layer: _e.pickedLayer,
        info: De,
        mode: y
      });
      const Me = (ke = De.object) !== null && ke !== void 0 ? ke : "".concat(De.layer.id, "[").concat(De.index, "]");
      me.has(Me) || me.set(Me, De);
    }
    return Array.from(me.values());
  }
  _drawAndSample(e) {
    let {
      layers: t,
      views: i,
      viewports: r,
      onViewportActive: l,
      deviceRect: c,
      cullRect: a,
      effects: g,
      pass: y
    } = e, A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const C = A ? this.depthFBO : this.pickingFBO, I = {
      layers: t,
      layerFilter: this.layerFilter,
      views: i,
      viewports: r,
      onViewportActive: l,
      pickingFBO: C,
      deviceRect: c,
      cullRect: a,
      effects: g,
      pass: y,
      pickZ: A,
      preRenderStats: {}
    };
    for (const de of g)
      de.useInPicking && (I.preRenderStats[de.id] = de.preRender(this.gl, I));
    const {
      decodePickingColor: S
    } = this.pickLayersPass.render(I), {
      x: F,
      y: U,
      width: V,
      height: W
    } = c, X = new (A ? Float32Array : Uint8Array)(V * W * 4);
    return t_(C, {
      sourceX: F,
      sourceY: U,
      sourceWidth: V,
      sourceHeight: W,
      target: X
    }), {
      pickedColors: X,
      decodePickingColor: S
    };
  }
  _getPickingRect(e) {
    let {
      deviceX: t,
      deviceY: i,
      deviceRadius: r,
      deviceWidth: l,
      deviceHeight: c
    } = e;
    const a = Math.max(0, t - r), g = Math.max(0, i - r), y = Math.min(l, t + r + 1) - a, A = Math.min(c, i + r + 1) - g;
    return y <= 0 || A <= 0 ? null : {
      x: a,
      y: g,
      width: y,
      height: A
    };
  }
}
const UN = {
  zIndex: "1",
  position: "absolute",
  pointerEvents: "none",
  color: "#a0a7b4",
  backgroundColor: "#29323c",
  padding: "10px",
  top: "0",
  left: "0",
  display: "none"
};
class jN {
  constructor(e) {
    H(this, "el", null), H(this, "isVisible", !1);
    const t = e.parentElement;
    t && (this.el = document.createElement("div"), this.el.className = "deck-tooltip", Object.assign(this.el.style, UN), t.appendChild(this.el));
  }
  setTooltip(e, t, i) {
    const r = this.el;
    if (r) {
      if (typeof e == "string")
        r.innerText = e;
      else if (e)
        e.text && (r.innerText = e.text), e.html && (r.innerHTML = e.html), e.className && (r.className = e.className);
      else {
        this.isVisible = !1, r.style.display = "none";
        return;
      }
      this.isVisible = !0, r.style.display = "block", r.style.transform = "translate(".concat(t, "px, ").concat(i, "px)"), e && typeof e == "object" && "style" in e && Object.assign(r.style, e.style);
    }
  }
  remove() {
    this.el && (this.el.remove(), this.el = null);
  }
}
var WE = { exports: {} };
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
(function(n) {
  (function(e, t, i, r) {
    var l = ["", "webkit", "Moz", "MS", "ms", "o"], c = t.createElement("div"), a = "function", g = Math.round, y = Math.abs, A = Date.now;
    function C(ge, we, Ve) {
      return setTimeout(de(ge, Ve), we);
    }
    function I(ge, we, Ve) {
      return Array.isArray(ge) ? (S(ge, Ve[we], Ve), !0) : !1;
    }
    function S(ge, we, Ve) {
      var _t;
      if (ge)
        if (ge.forEach)
          ge.forEach(we, Ve);
        else if (ge.length !== r)
          for (_t = 0; _t < ge.length; )
            we.call(Ve, ge[_t], _t, ge), _t++;
        else
          for (_t in ge)
            ge.hasOwnProperty(_t) && we.call(Ve, ge[_t], _t, ge);
    }
    function F(ge, we, Ve) {
      var _t = "DEPRECATED METHOD: " + we + `
` + Ve + ` AT 
`;
      return function() {
        var Kt = new Error("get-stack-trace"), gn = Kt && Kt.stack ? Kt.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", Rn = e.console && (e.console.warn || e.console.log);
        return Rn && Rn.call(e.console, _t, gn), ge.apply(this, arguments);
      };
    }
    var U;
    typeof Object.assign != "function" ? U = function(we) {
      if (we === r || we === null)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var Ve = Object(we), _t = 1; _t < arguments.length; _t++) {
        var Kt = arguments[_t];
        if (Kt !== r && Kt !== null)
          for (var gn in Kt)
            Kt.hasOwnProperty(gn) && (Ve[gn] = Kt[gn]);
      }
      return Ve;
    } : U = Object.assign;
    var V = F(function(we, Ve, _t) {
      for (var Kt = Object.keys(Ve), gn = 0; gn < Kt.length; )
        (!_t || _t && we[Kt[gn]] === r) && (we[Kt[gn]] = Ve[Kt[gn]]), gn++;
      return we;
    }, "extend", "Use `assign`."), W = F(function(we, Ve) {
      return V(we, Ve, !0);
    }, "merge", "Use `assign`.");
    function X(ge, we, Ve) {
      var _t = we.prototype, Kt;
      Kt = ge.prototype = Object.create(_t), Kt.constructor = ge, Kt._super = _t, Ve && U(Kt, Ve);
    }
    function de(ge, we) {
      return function() {
        return ge.apply(we, arguments);
      };
    }
    function ie(ge, we) {
      return typeof ge == a ? ge.apply(we && we[0] || r, we) : ge;
    }
    function fe(ge, we) {
      return ge === r ? we : ge;
    }
    function Ae(ge, we, Ve) {
      S(ke(we), function(_t) {
        ge.addEventListener(_t, Ve, !1);
      });
    }
    function Te(ge, we, Ve) {
      S(ke(we), function(_t) {
        ge.removeEventListener(_t, Ve, !1);
      });
    }
    function me(ge, we) {
      for (; ge; ) {
        if (ge == we)
          return !0;
        ge = ge.parentNode;
      }
      return !1;
    }
    function Ge(ge, we) {
      return ge.indexOf(we) > -1;
    }
    function ke(ge) {
      return ge.trim().split(/\s+/g);
    }
    function pe(ge, we, Ve) {
      if (ge.indexOf && !Ve)
        return ge.indexOf(we);
      for (var _t = 0; _t < ge.length; ) {
        if (Ve && ge[_t][Ve] == we || !Ve && ge[_t] === we)
          return _t;
        _t++;
      }
      return -1;
    }
    function _e(ge) {
      return Array.prototype.slice.call(ge, 0);
    }
    function De(ge, we, Ve) {
      for (var _t = [], Kt = [], gn = 0; gn < ge.length; ) {
        var Rn = ge[gn][we];
        pe(Kt, Rn) < 0 && _t.push(ge[gn]), Kt[gn] = Rn, gn++;
      }
      return _t = _t.sort(function(Ji, Ki) {
        return Ji[we] > Ki[we];
      }), _t;
    }
    function Me(ge, we) {
      for (var Ve, _t, Kt = we[0].toUpperCase() + we.slice(1), gn = 0; gn < l.length; ) {
        if (Ve = l[gn], _t = Ve ? Ve + Kt : we, _t in ge)
          return _t;
        gn++;
      }
      return r;
    }
    var St = 1;
    function dt() {
      return St++;
    }
    function Pt(ge) {
      var we = ge.ownerDocument || ge;
      return we.defaultView || we.parentWindow || e;
    }
    var gt = /mobile|tablet|ip(ad|hone|od)|android/i, Rt = "ontouchstart" in e, Ft = Me(e, "PointerEvent") !== r, mn = Rt && gt.test(navigator.userAgent), oe = "touch", Re = "pen", ze = "mouse", Xe = "kinect", ot = 25, rt = 1, xt = 2, ht = 4, $t = 8, Wt = 1, on = 2, hn = 4, wn = 8, Bt = 16, Ue = on | hn, On = wn | Bt, Sn = Ue | On, en = ["x", "y"], ln = ["clientX", "clientY"];
    function un(ge, we) {
      var Ve = this;
      this.manager = ge, this.callback = we, this.element = ge.element, this.target = ge.options.inputTarget, this.domHandler = function(_t) {
        ie(ge.options.enable, [ge]) && Ve.handler(_t);
      }, this.init();
    }
    un.prototype = {
      /**
       * should handle the inputEvent data and trigger the callback
       * @virtual
       */
      handler: function() {
      },
      /**
       * bind the events
       */
      init: function() {
        this.evEl && Ae(this.element, this.evEl, this.domHandler), this.evTarget && Ae(this.target, this.evTarget, this.domHandler), this.evWin && Ae(Pt(this.element), this.evWin, this.domHandler);
      },
      /**
       * unbind the events
       */
      destroy: function() {
        this.evEl && Te(this.element, this.evEl, this.domHandler), this.evTarget && Te(this.target, this.evTarget, this.domHandler), this.evWin && Te(Pt(this.element), this.evWin, this.domHandler);
      }
    };
    function _n(ge) {
      var we, Ve = ge.options.inputClass;
      return Ve ? we = Ve : Ft ? we = Ye : mn ? we = An : Rt ? we = In : we = ue, new we(ge, Mn);
    }
    function Mn(ge, we, Ve) {
      var _t = Ve.pointers.length, Kt = Ve.changedPointers.length, gn = we & rt && _t - Kt === 0, Rn = we & (ht | $t) && _t - Kt === 0;
      Ve.isFirst = !!gn, Ve.isFinal = !!Rn, gn && (ge.session = {}), Ve.eventType = we, Wn(ge, Ve), ge.emit("hammer.input", Ve), ge.recognize(Ve), ge.session.prevInput = Ve;
    }
    function Wn(ge, we) {
      var Ve = ge.session, _t = we.pointers, Kt = _t.length;
      Ve.firstInput || (Ve.firstInput = si(we)), Kt > 1 && !Ve.firstMultiple ? Ve.firstMultiple = si(we) : Kt === 1 && (Ve.firstMultiple = !1);
      var gn = Ve.firstInput, Rn = Ve.firstMultiple, hi = Rn ? Rn.center : gn.center, Ji = we.center = fi(_t);
      we.timeStamp = A(), we.deltaTime = we.timeStamp - gn.timeStamp, we.angle = tr(hi, Ji), we.distance = bn(hi, Ji), $n(Ve, we), we.offsetDirection = Jn(we.deltaX, we.deltaY);
      var Ki = Un(we.deltaTime, we.deltaX, we.deltaY);
      we.overallVelocityX = Ki.x, we.overallVelocityY = Ki.y, we.overallVelocity = y(Ki.x) > y(Ki.y) ? Ki.x : Ki.y, we.scale = Rn ? Dr(Rn.pointers, _t) : 1, we.rotation = Rn ? pi(Rn.pointers, _t) : 0, we.maxPointers = Ve.prevInput ? we.pointers.length > Ve.prevInput.maxPointers ? we.pointers.length : Ve.prevInput.maxPointers : we.pointers.length, Yn(Ve, we);
      var qn = ge.element;
      me(we.srcEvent.target, qn) && (qn = we.srcEvent.target), we.target = qn;
    }
    function $n(ge, we) {
      var Ve = we.center, _t = ge.offsetDelta || {}, Kt = ge.prevDelta || {}, gn = ge.prevInput || {};
      (we.eventType === rt || gn.eventType === ht) && (Kt = ge.prevDelta = {
        x: gn.deltaX || 0,
        y: gn.deltaY || 0
      }, _t = ge.offsetDelta = {
        x: Ve.x,
        y: Ve.y
      }), we.deltaX = Kt.x + (Ve.x - _t.x), we.deltaY = Kt.y + (Ve.y - _t.y);
    }
    function Yn(ge, we) {
      var Ve = ge.lastInterval || we, _t = we.timeStamp - Ve.timeStamp, Kt, gn, Rn, hi;
      if (we.eventType != $t && (_t > ot || Ve.velocity === r)) {
        var Ji = we.deltaX - Ve.deltaX, Ki = we.deltaY - Ve.deltaY, qn = Un(_t, Ji, Ki);
        gn = qn.x, Rn = qn.y, Kt = y(qn.x) > y(qn.y) ? qn.x : qn.y, hi = Jn(Ji, Ki), ge.lastInterval = we;
      } else
        Kt = Ve.velocity, gn = Ve.velocityX, Rn = Ve.velocityY, hi = Ve.direction;
      we.velocity = Kt, we.velocityX = gn, we.velocityY = Rn, we.direction = hi;
    }
    function si(ge) {
      for (var we = [], Ve = 0; Ve < ge.pointers.length; )
        we[Ve] = {
          clientX: g(ge.pointers[Ve].clientX),
          clientY: g(ge.pointers[Ve].clientY)
        }, Ve++;
      return {
        timeStamp: A(),
        pointers: we,
        center: fi(we),
        deltaX: ge.deltaX,
        deltaY: ge.deltaY
      };
    }
    function fi(ge) {
      var we = ge.length;
      if (we === 1)
        return {
          x: g(ge[0].clientX),
          y: g(ge[0].clientY)
        };
      for (var Ve = 0, _t = 0, Kt = 0; Kt < we; )
        Ve += ge[Kt].clientX, _t += ge[Kt].clientY, Kt++;
      return {
        x: g(Ve / we),
        y: g(_t / we)
      };
    }
    function Un(ge, we, Ve) {
      return {
        x: we / ge || 0,
        y: Ve / ge || 0
      };
    }
    function Jn(ge, we) {
      return ge === we ? Wt : y(ge) >= y(we) ? ge < 0 ? on : hn : we < 0 ? wn : Bt;
    }
    function bn(ge, we, Ve) {
      Ve || (Ve = en);
      var _t = we[Ve[0]] - ge[Ve[0]], Kt = we[Ve[1]] - ge[Ve[1]];
      return Math.sqrt(_t * _t + Kt * Kt);
    }
    function tr(ge, we, Ve) {
      Ve || (Ve = en);
      var _t = we[Ve[0]] - ge[Ve[0]], Kt = we[Ve[1]] - ge[Ve[1]];
      return Math.atan2(Kt, _t) * 180 / Math.PI;
    }
    function pi(ge, we) {
      return tr(we[1], we[0], ln) + tr(ge[1], ge[0], ln);
    }
    function Dr(ge, we) {
      return bn(we[0], we[1], ln) / bn(ge[0], ge[1], ln);
    }
    var be = {
      mousedown: rt,
      mousemove: xt,
      mouseup: ht
    }, ne = "mousedown", ce = "mousemove mouseup";
    function ue() {
      this.evEl = ne, this.evWin = ce, this.pressed = !1, un.apply(this, arguments);
    }
    X(ue, un, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(we) {
        var Ve = be[we.type];
        Ve & rt && we.button === 0 && (this.pressed = !0), Ve & xt && we.which !== 1 && (Ve = ht), this.pressed && (Ve & ht && (this.pressed = !1), this.callback(this.manager, Ve, {
          pointers: [we],
          changedPointers: [we],
          pointerType: ze,
          srcEvent: we
        }));
      }
    });
    var Oe = {
      pointerdown: rt,
      pointermove: xt,
      pointerup: ht,
      pointercancel: $t,
      pointerout: $t
    }, qe = {
      2: oe,
      3: Re,
      4: ze,
      5: Xe
      // see https://twitter.com/jacobrossi/status/480596438489890816
    }, it = "pointerdown", mt = "pointermove pointerup pointercancel";
    e.MSPointerEvent && !e.PointerEvent && (it = "MSPointerDown", mt = "MSPointerMove MSPointerUp MSPointerCancel");
    function Ye() {
      this.evEl = it, this.evWin = mt, un.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
    }
    X(Ye, un, {
      /**
       * handle mouse events
       * @param {Object} ev
       */
      handler: function(we) {
        var Ve = this.store, _t = !1, Kt = we.type.toLowerCase().replace("ms", ""), gn = Oe[Kt], Rn = qe[we.pointerType] || we.pointerType, hi = Rn == oe, Ji = pe(Ve, we.pointerId, "pointerId");
        gn & rt && (we.button === 0 || hi) ? Ji < 0 && (Ve.push(we), Ji = Ve.length - 1) : gn & (ht | $t) && (_t = !0), !(Ji < 0) && (Ve[Ji] = we, this.callback(this.manager, gn, {
          pointers: Ve,
          changedPointers: [we],
          pointerType: Rn,
          srcEvent: we
        }), _t && Ve.splice(Ji, 1));
      }
    });
    var at = {
      touchstart: rt,
      touchmove: xt,
      touchend: ht,
      touchcancel: $t
    }, pt = "touchstart", lt = "touchstart touchmove touchend touchcancel";
    function Ze() {
      this.evTarget = pt, this.evWin = lt, this.started = !1, un.apply(this, arguments);
    }
    X(Ze, un, {
      handler: function(we) {
        var Ve = at[we.type];
        if (Ve === rt && (this.started = !0), !!this.started) {
          var _t = an.call(this, we, Ve);
          Ve & (ht | $t) && _t[0].length - _t[1].length === 0 && (this.started = !1), this.callback(this.manager, Ve, {
            pointers: _t[0],
            changedPointers: _t[1],
            pointerType: oe,
            srcEvent: we
          });
        }
      }
    });
    function an(ge, we) {
      var Ve = _e(ge.touches), _t = _e(ge.changedTouches);
      return we & (ht | $t) && (Ve = De(Ve.concat(_t), "identifier")), [Ve, _t];
    }
    var Yt = {
      touchstart: rt,
      touchmove: xt,
      touchend: ht,
      touchcancel: $t
    }, Xt = "touchstart touchmove touchend touchcancel";
    function An() {
      this.evTarget = Xt, this.targetIds = {}, un.apply(this, arguments);
    }
    X(An, un, {
      handler: function(we) {
        var Ve = Yt[we.type], _t = It.call(this, we, Ve);
        _t && this.callback(this.manager, Ve, {
          pointers: _t[0],
          changedPointers: _t[1],
          pointerType: oe,
          srcEvent: we
        });
      }
    });
    function It(ge, we) {
      var Ve = _e(ge.touches), _t = this.targetIds;
      if (we & (rt | xt) && Ve.length === 1)
        return _t[Ve[0].identifier] = !0, [Ve, Ve];
      var Kt, gn, Rn = _e(ge.changedTouches), hi = [], Ji = this.target;
      if (gn = Ve.filter(function(Ki) {
        return me(Ki.target, Ji);
      }), we === rt)
        for (Kt = 0; Kt < gn.length; )
          _t[gn[Kt].identifier] = !0, Kt++;
      for (Kt = 0; Kt < Rn.length; )
        _t[Rn[Kt].identifier] && hi.push(Rn[Kt]), we & (ht | $t) && delete _t[Rn[Kt].identifier], Kt++;
      if (hi.length)
        return [
          // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
          De(gn.concat(hi), "identifier"),
          hi
        ];
    }
    var Jt = 2500, cn = 25;
    function In() {
      un.apply(this, arguments);
      var ge = de(this.handler, this);
      this.touch = new An(this.manager, ge), this.mouse = new ue(this.manager, ge), this.primaryTouch = null, this.lastTouches = [];
    }
    X(In, un, {
      /**
       * handle mouse and touch events
       * @param {Hammer} manager
       * @param {String} inputEvent
       * @param {Object} inputData
       */
      handler: function(we, Ve, _t) {
        var Kt = _t.pointerType == oe, gn = _t.pointerType == ze;
        if (!(gn && _t.sourceCapabilities && _t.sourceCapabilities.firesTouchEvents)) {
          if (Kt)
            Zn.call(this, Ve, _t);
          else if (gn && fn.call(this, _t))
            return;
          this.callback(we, Ve, _t);
        }
      },
      /**
       * remove the event listeners
       */
      destroy: function() {
        this.touch.destroy(), this.mouse.destroy();
      }
    });
    function Zn(ge, we) {
      ge & rt ? (this.primaryTouch = we.changedPointers[0].identifier, Ln.call(this, we)) : ge & (ht | $t) && Ln.call(this, we);
    }
    function Ln(ge) {
      var we = ge.changedPointers[0];
      if (we.identifier === this.primaryTouch) {
        var Ve = {
          x: we.clientX,
          y: we.clientY
        };
        this.lastTouches.push(Ve);
        var _t = this.lastTouches, Kt = function() {
          var gn = _t.indexOf(Ve);
          gn > -1 && _t.splice(gn, 1);
        };
        setTimeout(Kt, Jt);
      }
    }
    function fn(ge) {
      for (var we = ge.srcEvent.clientX, Ve = ge.srcEvent.clientY, _t = 0; _t < this.lastTouches.length; _t++) {
        var Kt = this.lastTouches[_t], gn = Math.abs(we - Kt.x), Rn = Math.abs(Ve - Kt.y);
        if (gn <= cn && Rn <= cn)
          return !0;
      }
      return !1;
    }
    var xi = Me(c.style, "touchAction"), Er = xi !== r, Pi = "compute", Ii = "auto", ui = "manipulation", Oi = "none", _i = "pan-x", xs = "pan-y", ws = To();
    function Ao(ge, we) {
      this.manager = ge, this.set(we);
    }
    Ao.prototype = {
      /**
       * set the touchAction value on the element or enable the polyfill
       * @param {String} value
       */
      set: function(ge) {
        ge == Pi && (ge = this.compute()), Er && this.manager.element.style && ws[ge] && (this.manager.element.style[xi] = ge), this.actions = ge.toLowerCase().trim();
      },
      /**
       * just re-set the touchAction value
       */
      update: function() {
        this.set(this.manager.options.touchAction);
      },
      /**
       * compute the value for the touchAction property based on the recognizer's settings
       * @returns {String} value
       */
      compute: function() {
        var ge = [];
        return S(this.manager.recognizers, function(we) {
          ie(we.options.enable, [we]) && (ge = ge.concat(we.getTouchAction()));
        }), qs(ge.join(" "));
      },
      /**
       * this method is called on each input cycle and provides the preventing of the browser behavior
       * @param {Object} input
       */
      preventDefaults: function(ge) {
        var we = ge.srcEvent, Ve = ge.offsetDirection;
        if (this.manager.session.prevented) {
          we.preventDefault();
          return;
        }
        var _t = this.actions, Kt = Ge(_t, Oi) && !ws[Oi], gn = Ge(_t, xs) && !ws[xs], Rn = Ge(_t, _i) && !ws[_i];
        if (Kt) {
          var hi = ge.pointers.length === 1, Ji = ge.distance < 2, Ki = ge.deltaTime < 250;
          if (hi && Ji && Ki)
            return;
        }
        if (!(Rn && gn) && (Kt || gn && Ve & Ue || Rn && Ve & On))
          return this.preventSrc(we);
      },
      /**
       * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
       * @param {Object} srcEvent
       */
      preventSrc: function(ge) {
        this.manager.session.prevented = !0, ge.preventDefault();
      }
    };
    function qs(ge) {
      if (Ge(ge, Oi))
        return Oi;
      var we = Ge(ge, _i), Ve = Ge(ge, xs);
      return we && Ve ? Oi : we || Ve ? we ? _i : xs : Ge(ge, ui) ? ui : Ii;
    }
    function To() {
      if (!Er)
        return !1;
      var ge = {}, we = e.CSS && e.CSS.supports;
      return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(Ve) {
        ge[Ve] = we ? e.CSS.supports("touch-action", Ve) : !0;
      }), ge;
    }
    var Ia = 1, Hr = 2, Hs = 4, Wr = 8, Ws = Wr, $o = 16, Zs = 32;
    function $s(ge) {
      this.options = U({}, this.defaults, ge || {}), this.id = dt(), this.manager = null, this.options.enable = fe(this.options.enable, !0), this.state = Ia, this.simultaneous = {}, this.requireFail = [];
    }
    $s.prototype = {
      /**
       * @virtual
       * @type {Object}
       */
      defaults: {},
      /**
       * set options
       * @param {Object} options
       * @return {Recognizer}
       */
      set: function(ge) {
        return U(this.options, ge), this.manager && this.manager.touchAction.update(), this;
      },
      /**
       * recognize simultaneous with an other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      recognizeWith: function(ge) {
        if (I(ge, "recognizeWith", this))
          return this;
        var we = this.simultaneous;
        return ge = Xs(ge, this), we[ge.id] || (we[ge.id] = ge, ge.recognizeWith(this)), this;
      },
      /**
       * drop the simultaneous link. it doesnt remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRecognizeWith: function(ge) {
        return I(ge, "dropRecognizeWith", this) ? this : (ge = Xs(ge, this), delete this.simultaneous[ge.id], this);
      },
      /**
       * recognizer can only run when an other is failing
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      requireFailure: function(ge) {
        if (I(ge, "requireFailure", this))
          return this;
        var we = this.requireFail;
        return ge = Xs(ge, this), pe(we, ge) === -1 && (we.push(ge), ge.requireFailure(this)), this;
      },
      /**
       * drop the requireFailure link. it does not remove the link on the other recognizer.
       * @param {Recognizer} otherRecognizer
       * @returns {Recognizer} this
       */
      dropRequireFailure: function(ge) {
        if (I(ge, "dropRequireFailure", this))
          return this;
        ge = Xs(ge, this);
        var we = pe(this.requireFail, ge);
        return we > -1 && this.requireFail.splice(we, 1), this;
      },
      /**
       * has require failures boolean
       * @returns {boolean}
       */
      hasRequireFailures: function() {
        return this.requireFail.length > 0;
      },
      /**
       * if the recognizer can recognize simultaneous with an other recognizer
       * @param {Recognizer} otherRecognizer
       * @returns {Boolean}
       */
      canRecognizeWith: function(ge) {
        return !!this.simultaneous[ge.id];
      },
      /**
       * You should use `tryEmit` instead of `emit` directly to check
       * that all the needed recognizers has failed before emitting.
       * @param {Object} input
       */
      emit: function(ge) {
        var we = this, Ve = this.state;
        function _t(Kt) {
          we.manager.emit(Kt, ge);
        }
        Ve < Wr && _t(we.options.event + Il(Ve)), _t(we.options.event), ge.additionalEvent && _t(ge.additionalEvent), Ve >= Wr && _t(we.options.event + Il(Ve));
      },
      /**
       * Check that all the require failure recognizers has failed,
       * if true, it emits a gesture event,
       * otherwise, setup the state to FAILED.
       * @param {Object} input
       */
      tryEmit: function(ge) {
        if (this.canEmit())
          return this.emit(ge);
        this.state = Zs;
      },
      /**
       * can we emit?
       * @returns {boolean}
       */
      canEmit: function() {
        for (var ge = 0; ge < this.requireFail.length; ) {
          if (!(this.requireFail[ge].state & (Zs | Ia)))
            return !1;
          ge++;
        }
        return !0;
      },
      /**
       * update the recognizer
       * @param {Object} inputData
       */
      recognize: function(ge) {
        var we = U({}, ge);
        if (!ie(this.options.enable, [this, we])) {
          this.reset(), this.state = Zs;
          return;
        }
        this.state & (Ws | $o | Zs) && (this.state = Ia), this.state = this.process(we), this.state & (Hr | Hs | Wr | $o) && this.tryEmit(we);
      },
      /**
       * return the state of the recognizer
       * the actual recognizing happens in this method
       * @virtual
       * @param {Object} inputData
       * @returns {Const} STATE
       */
      process: function(ge) {
      },
      // jshint ignore:line
      /**
       * return the preferred touch-action
       * @virtual
       * @returns {Array}
       */
      getTouchAction: function() {
      },
      /**
       * called when the gesture isn't allowed to recognize
       * like when another is being recognized or it is disabled
       * @virtual
       */
      reset: function() {
      }
    };
    function Il(ge) {
      return ge & $o ? "cancel" : ge & Wr ? "end" : ge & Hs ? "move" : ge & Hr ? "start" : "";
    }
    function Xo(ge) {
      return ge == Bt ? "down" : ge == wn ? "up" : ge == on ? "left" : ge == hn ? "right" : "";
    }
    function Xs(ge, we) {
      var Ve = we.manager;
      return Ve ? Ve.get(ge) : ge;
    }
    function Ti() {
      $s.apply(this, arguments);
    }
    X(Ti, $s, {
      /**
       * @namespace
       * @memberof AttrRecognizer
       */
      defaults: {
        /**
         * @type {Number}
         * @default 1
         */
        pointers: 1
      },
      /**
       * Used to check if it the recognizer receives valid input, like input.distance > 10.
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {Boolean} recognized
       */
      attrTest: function(ge) {
        var we = this.options.pointers;
        return we === 0 || ge.pointers.length === we;
      },
      /**
       * Process the input and return the state for the recognizer
       * @memberof AttrRecognizer
       * @param {Object} input
       * @returns {*} State
       */
      process: function(ge) {
        var we = this.state, Ve = ge.eventType, _t = we & (Hr | Hs), Kt = this.attrTest(ge);
        return _t && (Ve & $t || !Kt) ? we | $o : _t || Kt ? Ve & ht ? we | Wr : we & Hr ? we | Hs : Hr : Zs;
      }
    });
    function ha() {
      Ti.apply(this, arguments), this.pX = null, this.pY = null;
    }
    X(ha, Ti, {
      /**
       * @namespace
       * @memberof PanRecognizer
       */
      defaults: {
        event: "pan",
        threshold: 10,
        pointers: 1,
        direction: Sn
      },
      getTouchAction: function() {
        var ge = this.options.direction, we = [];
        return ge & Ue && we.push(xs), ge & On && we.push(_i), we;
      },
      directionTest: function(ge) {
        var we = this.options, Ve = !0, _t = ge.distance, Kt = ge.direction, gn = ge.deltaX, Rn = ge.deltaY;
        return Kt & we.direction || (we.direction & Ue ? (Kt = gn === 0 ? Wt : gn < 0 ? on : hn, Ve = gn != this.pX, _t = Math.abs(ge.deltaX)) : (Kt = Rn === 0 ? Wt : Rn < 0 ? wn : Bt, Ve = Rn != this.pY, _t = Math.abs(ge.deltaY))), ge.direction = Kt, Ve && _t > we.threshold && Kt & we.direction;
      },
      attrTest: function(ge) {
        return Ti.prototype.attrTest.call(this, ge) && (this.state & Hr || !(this.state & Hr) && this.directionTest(ge));
      },
      emit: function(ge) {
        this.pX = ge.deltaX, this.pY = ge.deltaY;
        var we = Xo(ge.direction);
        we && (ge.additionalEvent = this.options.event + we), this._super.emit.call(this, ge);
      }
    });
    function Ys() {
      Ti.apply(this, arguments);
    }
    X(Ys, Ti, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "pinch",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [Oi];
      },
      attrTest: function(ge) {
        return this._super.attrTest.call(this, ge) && (Math.abs(ge.scale - 1) > this.options.threshold || this.state & Hr);
      },
      emit: function(ge) {
        if (ge.scale !== 1) {
          var we = ge.scale < 1 ? "in" : "out";
          ge.additionalEvent = this.options.event + we;
        }
        this._super.emit.call(this, ge);
      }
    });
    function da() {
      $s.apply(this, arguments), this._timer = null, this._input = null;
    }
    X(da, $s, {
      /**
       * @namespace
       * @memberof PressRecognizer
       */
      defaults: {
        event: "press",
        pointers: 1,
        time: 251,
        // minimal time of the pointer to be pressed
        threshold: 9
        // a minimal movement is ok, but keep it low
      },
      getTouchAction: function() {
        return [Ii];
      },
      process: function(ge) {
        var we = this.options, Ve = ge.pointers.length === we.pointers, _t = ge.distance < we.threshold, Kt = ge.deltaTime > we.time;
        if (this._input = ge, !_t || !Ve || ge.eventType & (ht | $t) && !Kt)
          this.reset();
        else if (ge.eventType & rt)
          this.reset(), this._timer = C(function() {
            this.state = Ws, this.tryEmit();
          }, we.time, this);
        else if (ge.eventType & ht)
          return Ws;
        return Zs;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function(ge) {
        this.state === Ws && (ge && ge.eventType & ht ? this.manager.emit(this.options.event + "up", ge) : (this._input.timeStamp = A(), this.manager.emit(this.options.event, this._input)));
      }
    });
    function Eo() {
      Ti.apply(this, arguments);
    }
    X(Eo, Ti, {
      /**
       * @namespace
       * @memberof RotateRecognizer
       */
      defaults: {
        event: "rotate",
        threshold: 0,
        pointers: 2
      },
      getTouchAction: function() {
        return [Oi];
      },
      attrTest: function(ge) {
        return this._super.attrTest.call(this, ge) && (Math.abs(ge.rotation) > this.options.threshold || this.state & Hr);
      }
    });
    function sl() {
      Ti.apply(this, arguments);
    }
    X(sl, Ti, {
      /**
       * @namespace
       * @memberof SwipeRecognizer
       */
      defaults: {
        event: "swipe",
        threshold: 10,
        velocity: 0.3,
        direction: Ue | On,
        pointers: 1
      },
      getTouchAction: function() {
        return ha.prototype.getTouchAction.call(this);
      },
      attrTest: function(ge) {
        var we = this.options.direction, Ve;
        return we & (Ue | On) ? Ve = ge.overallVelocity : we & Ue ? Ve = ge.overallVelocityX : we & On && (Ve = ge.overallVelocityY), this._super.attrTest.call(this, ge) && we & ge.offsetDirection && ge.distance > this.options.threshold && ge.maxPointers == this.options.pointers && y(Ve) > this.options.velocity && ge.eventType & ht;
      },
      emit: function(ge) {
        var we = Xo(ge.offsetDirection);
        we && this.manager.emit(this.options.event + we, ge), this.manager.emit(this.options.event, ge);
      }
    });
    function yr() {
      $s.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0;
    }
    X(yr, $s, {
      /**
       * @namespace
       * @memberof PinchRecognizer
       */
      defaults: {
        event: "tap",
        pointers: 1,
        taps: 1,
        interval: 300,
        // max time between the multi-tap taps
        time: 250,
        // max time of the pointer to be down (like finger on the screen)
        threshold: 9,
        // a minimal movement is ok, but keep it low
        posThreshold: 10
        // a multi-tap can be a bit off the initial position
      },
      getTouchAction: function() {
        return [ui];
      },
      process: function(ge) {
        var we = this.options, Ve = ge.pointers.length === we.pointers, _t = ge.distance < we.threshold, Kt = ge.deltaTime < we.time;
        if (this.reset(), ge.eventType & rt && this.count === 0)
          return this.failTimeout();
        if (_t && Kt && Ve) {
          if (ge.eventType != ht)
            return this.failTimeout();
          var gn = this.pTime ? ge.timeStamp - this.pTime < we.interval : !0, Rn = !this.pCenter || bn(this.pCenter, ge.center) < we.posThreshold;
          this.pTime = ge.timeStamp, this.pCenter = ge.center, !Rn || !gn ? this.count = 1 : this.count += 1, this._input = ge;
          var hi = this.count % we.taps;
          if (hi === 0)
            return this.hasRequireFailures() ? (this._timer = C(function() {
              this.state = Ws, this.tryEmit();
            }, we.interval, this), Hr) : Ws;
        }
        return Zs;
      },
      failTimeout: function() {
        return this._timer = C(function() {
          this.state = Zs;
        }, this.options.interval, this), Zs;
      },
      reset: function() {
        clearTimeout(this._timer);
      },
      emit: function() {
        this.state == Ws && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
      }
    });
    function os(ge, we) {
      return we = we || {}, we.recognizers = fe(we.recognizers, os.defaults.preset), new as(ge, we);
    }
    os.VERSION = "2.0.7", os.defaults = {
      /**
       * set if DOM events are being triggered.
       * But this is slower and unused by simple implementations, so disabled by default.
       * @type {Boolean}
       * @default false
       */
      domEvents: !1,
      /**
       * The value for the touchAction property/fallback.
       * When set to `compute` it will magically set the correct value based on the added recognizers.
       * @type {String}
       * @default compute
       */
      touchAction: Pi,
      /**
       * @type {Boolean}
       * @default true
       */
      enable: !0,
      /**
       * EXPERIMENTAL FEATURE -- can be removed/changed
       * Change the parent input target element.
       * If Null, then it is being set the to main element.
       * @type {Null|EventTarget}
       * @default null
       */
      inputTarget: null,
      /**
       * force an input class
       * @type {Null|Function}
       * @default null
       */
      inputClass: null,
      /**
       * Default recognizer setup when calling `Hammer()`
       * When creating a new Manager these will be skipped.
       * @type {Array}
       */
      preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [Eo, {
          enable: !1
        }],
        [Ys, {
          enable: !1
        }, ["rotate"]],
        [sl, {
          direction: Ue
        }],
        [ha, {
          direction: Ue
        }, ["swipe"]],
        [yr],
        [yr, {
          event: "doubletap",
          taps: 2
        }, ["tap"]],
        [da]
      ],
      /**
       * Some CSS properties can be used to improve the working of Hammer.
       * Add them to this method and they will be set when creating a new Manager.
       * @namespace
       */
      cssProps: {
        /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userSelect: "none",
        /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
        touchSelect: "none",
        /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
        touchCallout: "none",
        /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
        contentZooming: "none",
        /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
        userDrag: "none",
        /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
        tapHighlightColor: "rgba(0,0,0,0)"
      }
    };
    var nr = 1, Xn = 2;
    function as(ge, we) {
      this.options = U({}, os.defaults, we || {}), this.options.inputTarget = this.options.inputTarget || ge, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = ge, this.input = _n(this), this.touchAction = new Ao(this, this.options.touchAction), Qn(this, !0), S(this.options.recognizers, function(Ve) {
        var _t = this.add(new Ve[0](Ve[1]));
        Ve[2] && _t.recognizeWith(Ve[2]), Ve[3] && _t.requireFailure(Ve[3]);
      }, this);
    }
    as.prototype = {
      /**
       * set options
       * @param {Object} options
       * @returns {Manager}
       */
      set: function(ge) {
        return U(this.options, ge), ge.touchAction && this.touchAction.update(), ge.inputTarget && (this.input.destroy(), this.input.target = ge.inputTarget, this.input.init()), this;
      },
      /**
       * stop recognizing for this session.
       * This session will be discarded, when a new [input]start event is fired.
       * When forced, the recognizer cycle is stopped immediately.
       * @param {Boolean} [force]
       */
      stop: function(ge) {
        this.session.stopped = ge ? Xn : nr;
      },
      /**
       * run the recognizers!
       * called by the inputHandler function on every movement of the pointers (touches)
       * it walks through all the recognizers and tries to detect the gesture that is being made
       * @param {Object} inputData
       */
      recognize: function(ge) {
        var we = this.session;
        if (!we.stopped) {
          this.touchAction.preventDefaults(ge);
          var Ve, _t = this.recognizers, Kt = we.curRecognizer;
          (!Kt || Kt && Kt.state & Ws) && (Kt = we.curRecognizer = null);
          for (var gn = 0; gn < _t.length; )
            Ve = _t[gn], we.stopped !== Xn && // 1
            (!Kt || Ve == Kt || // 2
            Ve.canRecognizeWith(Kt)) ? Ve.recognize(ge) : Ve.reset(), !Kt && Ve.state & (Hr | Hs | Wr) && (Kt = we.curRecognizer = Ve), gn++;
        }
      },
      /**
       * get a recognizer by its event name.
       * @param {Recognizer|String} recognizer
       * @returns {Recognizer|Null}
       */
      get: function(ge) {
        if (ge instanceof $s)
          return ge;
        for (var we = this.recognizers, Ve = 0; Ve < we.length; Ve++)
          if (we[Ve].options.event == ge)
            return we[Ve];
        return null;
      },
      /**
       * add a recognizer to the manager
       * existing recognizers with the same event name will be removed
       * @param {Recognizer} recognizer
       * @returns {Recognizer|Manager}
       */
      add: function(ge) {
        if (I(ge, "add", this))
          return this;
        var we = this.get(ge.options.event);
        return we && this.remove(we), this.recognizers.push(ge), ge.manager = this, this.touchAction.update(), ge;
      },
      /**
       * remove a recognizer by name or instance
       * @param {Recognizer|String} recognizer
       * @returns {Manager}
       */
      remove: function(ge) {
        if (I(ge, "remove", this))
          return this;
        if (ge = this.get(ge), ge) {
          var we = this.recognizers, Ve = pe(we, ge);
          Ve !== -1 && (we.splice(Ve, 1), this.touchAction.update());
        }
        return this;
      },
      /**
       * bind event
       * @param {String} events
       * @param {Function} handler
       * @returns {EventEmitter} this
       */
      on: function(ge, we) {
        if (ge !== r && we !== r) {
          var Ve = this.handlers;
          return S(ke(ge), function(_t) {
            Ve[_t] = Ve[_t] || [], Ve[_t].push(we);
          }), this;
        }
      },
      /**
       * unbind event, leave emit blank to remove all handlers
       * @param {String} events
       * @param {Function} [handler]
       * @returns {EventEmitter} this
       */
      off: function(ge, we) {
        if (ge !== r) {
          var Ve = this.handlers;
          return S(ke(ge), function(_t) {
            we ? Ve[_t] && Ve[_t].splice(pe(Ve[_t], we), 1) : delete Ve[_t];
          }), this;
        }
      },
      /**
       * emit event to the listeners
       * @param {String} event
       * @param {Object} data
       */
      emit: function(ge, we) {
        this.options.domEvents && Ma(ge, we);
        var Ve = this.handlers[ge] && this.handlers[ge].slice();
        if (!(!Ve || !Ve.length)) {
          we.type = ge, we.preventDefault = function() {
            we.srcEvent.preventDefault();
          };
          for (var _t = 0; _t < Ve.length; )
            Ve[_t](we), _t++;
        }
      },
      /**
       * destroy the manager and unbinds all events
       * it doesn't unbind dom events, that is the user own responsibility
       */
      destroy: function() {
        this.element && Qn(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
      }
    };
    function Qn(ge, we) {
      var Ve = ge.element;
      if (Ve.style) {
        var _t;
        S(ge.options.cssProps, function(Kt, gn) {
          _t = Me(Ve.style, gn), we ? (ge.oldCssProps[_t] = Ve.style[_t], Ve.style[_t] = Kt) : Ve.style[_t] = ge.oldCssProps[_t] || "";
        }), we || (ge.oldCssProps = {});
      }
    }
    function Ma(ge, we) {
      var Ve = t.createEvent("Event");
      Ve.initEvent(ge, !0, !0), Ve.gesture = we, we.target.dispatchEvent(Ve);
    }
    U(os, {
      INPUT_START: rt,
      INPUT_MOVE: xt,
      INPUT_END: ht,
      INPUT_CANCEL: $t,
      STATE_POSSIBLE: Ia,
      STATE_BEGAN: Hr,
      STATE_CHANGED: Hs,
      STATE_ENDED: Wr,
      STATE_RECOGNIZED: Ws,
      STATE_CANCELLED: $o,
      STATE_FAILED: Zs,
      DIRECTION_NONE: Wt,
      DIRECTION_LEFT: on,
      DIRECTION_RIGHT: hn,
      DIRECTION_UP: wn,
      DIRECTION_DOWN: Bt,
      DIRECTION_HORIZONTAL: Ue,
      DIRECTION_VERTICAL: On,
      DIRECTION_ALL: Sn,
      Manager: as,
      Input: un,
      TouchAction: Ao,
      TouchInput: An,
      MouseInput: ue,
      PointerEventInput: Ye,
      TouchMouseInput: In,
      SingleTouchInput: Ze,
      Recognizer: $s,
      AttrRecognizer: Ti,
      Tap: yr,
      Pan: ha,
      Swipe: sl,
      Pinch: Ys,
      Rotate: Eo,
      Press: da,
      on: Ae,
      off: Te,
      each: S,
      merge: W,
      extend: V,
      assign: U,
      inherit: X,
      bindFn: de,
      prefixed: Me
    });
    var Ec = typeof e < "u" ? e : typeof self < "u" ? self : {};
    Ec.Hammer = os, n.exports ? n.exports = os : e[i] = os;
  })(window, document, "Hammer");
})(WE);
var Yp = WE.exports;
const GN = /* @__PURE__ */ $m(Yp), qc = /* @__PURE__ */ GP({
  __proto__: null,
  default: GN
}, [Yp]), ZE = 1, $E = 2, n1 = 4, VN = {
  mousedown: ZE,
  mousemove: $E,
  mouseup: n1
};
function qN(n, e) {
  for (let t = 0; t < n.length; t++)
    if (e(n[t]))
      return !0;
  return !1;
}
function HN(n) {
  const e = n.prototype.handler;
  n.prototype.handler = function(i) {
    const r = this.store;
    i.button > 0 && i.type === "pointerdown" && (qN(r, (l) => l.pointerId === i.pointerId) || r.push(i)), e.call(this, i);
  };
}
function WN(n) {
  n.prototype.handler = function(t) {
    let i = VN[t.type];
    i & ZE && t.button >= 0 && (this.pressed = !0), i & $E && t.buttons === 0 && (i = n1), this.pressed && (i & n1 && (this.pressed = !1), this.callback(this.manager, i, {
      pointers: [t],
      changedPointers: [t],
      pointerType: "mouse",
      srcEvent: t
    }));
  };
}
HN(Yp.PointerEventInput);
WN(Yp.MouseInput);
const ZN = Yp.Manager;
class i_ {
  constructor(e, t, i) {
    this.element = e, this.callback = t, this.options = {
      enable: !0,
      ...i
    };
  }
}
const $N = qc ? [
  [qc.Pan, {
    event: "tripan",
    pointers: 3,
    threshold: 0,
    enable: !1
  }],
  [qc.Rotate, {
    enable: !1
  }],
  [qc.Pinch, {
    enable: !1
  }],
  [qc.Swipe, {
    enable: !1
  }],
  [qc.Pan, {
    threshold: 0,
    enable: !1
  }],
  [qc.Press, {
    enable: !1
  }],
  [qc.Tap, {
    event: "doubletap",
    taps: 2,
    enable: !1
  }],
  // TODO - rename to 'tap' and 'singletap' in the next major release
  [qc.Tap, {
    event: "anytap",
    enable: !1
  }],
  [qc.Tap, {
    enable: !1
  }]
] : null, Mw = {
  tripan: ["rotate", "pinch", "pan"],
  rotate: ["pinch"],
  pinch: ["pan"],
  pan: ["press", "doubletap", "anytap", "tap"],
  doubletap: ["anytap"],
  anytap: ["tap"]
}, XN = {
  doubletap: ["tap"]
}, YN = {
  pointerdown: "pointerdown",
  pointermove: "pointermove",
  pointerup: "pointerup",
  touchstart: "pointerdown",
  touchmove: "pointermove",
  touchend: "pointerup",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup"
}, Ib = {
  KEY_EVENTS: ["keydown", "keyup"],
  MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
  WHEEL_EVENTS: [
    // Chrome, Safari
    "wheel",
    // IE
    "mousewheel"
  ]
}, JN = {
  tap: "tap",
  anytap: "anytap",
  doubletap: "doubletap",
  press: "press",
  pinch: "pinch",
  pinchin: "pinch",
  pinchout: "pinch",
  pinchstart: "pinch",
  pinchmove: "pinch",
  pinchend: "pinch",
  pinchcancel: "pinch",
  rotate: "rotate",
  rotatestart: "rotate",
  rotatemove: "rotate",
  rotateend: "rotate",
  rotatecancel: "rotate",
  tripan: "tripan",
  tripanstart: "tripan",
  tripanmove: "tripan",
  tripanup: "tripan",
  tripandown: "tripan",
  tripanleft: "tripan",
  tripanright: "tripan",
  tripanend: "tripan",
  tripancancel: "tripan",
  pan: "pan",
  panstart: "pan",
  panmove: "pan",
  panup: "pan",
  pandown: "pan",
  panleft: "pan",
  panright: "pan",
  panend: "pan",
  pancancel: "pan",
  swipe: "swipe",
  swipeleft: "swipe",
  swiperight: "swipe",
  swipeup: "swipe",
  swipedown: "swipe"
}, Lw = {
  click: "tap",
  anyclick: "anytap",
  dblclick: "doubletap",
  mousedown: "pointerdown",
  mousemove: "pointermove",
  mouseup: "pointerup",
  mouseover: "pointerover",
  mouseout: "pointerout",
  mouseleave: "pointerleave"
}, KN = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", Vd = typeof window < "u" ? window : global;
let i1 = !1;
try {
  const n = {
    // This function will be called when the browser
    // attempts to access the passive property.
    get passive() {
      return i1 = !0, !0;
    }
  };
  Vd.addEventListener("test", null, n), Vd.removeEventListener("test", null);
} catch {
  i1 = !1;
}
const QN = KN.indexOf("firefox") !== -1, {
  WHEEL_EVENTS: ek
} = Ib, Rw = "wheel", Bw = 4.000244140625, tk = 40, nk = 0.25;
class ik extends i_ {
  constructor(e, t, i) {
    super(e, t, i), this.handleEvent = (r) => {
      if (!this.options.enable)
        return;
      let l = r.deltaY;
      Vd.WheelEvent && (QN && r.deltaMode === Vd.WheelEvent.DOM_DELTA_PIXEL && (l /= Vd.devicePixelRatio), r.deltaMode === Vd.WheelEvent.DOM_DELTA_LINE && (l *= tk)), l !== 0 && l % Bw === 0 && (l = Math.floor(l / Bw)), r.shiftKey && l && (l = l * nk), this.callback({
        type: Rw,
        center: {
          x: r.clientX,
          y: r.clientY
        },
        delta: -l,
        srcEvent: r,
        pointerType: "mouse",
        target: r.target
      });
    }, this.events = (this.options.events || []).concat(ek), this.events.forEach((r) => e.addEventListener(r, this.handleEvent, i1 ? {
      passive: !1
    } : !1));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === Rw && (this.options.enable = t);
  }
}
const {
  MOUSE_EVENTS: rk
} = Ib, Ow = "pointermove", Dw = "pointerover", Fw = "pointerout", Nw = "pointerenter", kw = "pointerleave";
class sk extends i_ {
  constructor(e, t, i) {
    super(e, t, i), this.handleEvent = (l) => {
      this.handleOverEvent(l), this.handleOutEvent(l), this.handleEnterEvent(l), this.handleLeaveEvent(l), this.handleMoveEvent(l);
    }, this.pressed = !1;
    const {
      enable: r
    } = this.options;
    this.enableMoveEvent = r, this.enableLeaveEvent = r, this.enableEnterEvent = r, this.enableOutEvent = r, this.enableOverEvent = r, this.events = (this.options.events || []).concat(rk), this.events.forEach((l) => e.addEventListener(l, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === Ow && (this.enableMoveEvent = t), e === Dw && (this.enableOverEvent = t), e === Fw && (this.enableOutEvent = t), e === Nw && (this.enableEnterEvent = t), e === kw && (this.enableLeaveEvent = t);
  }
  handleOverEvent(e) {
    this.enableOverEvent && e.type === "mouseover" && this._emit(Dw, e);
  }
  handleOutEvent(e) {
    this.enableOutEvent && e.type === "mouseout" && this._emit(Fw, e);
  }
  handleEnterEvent(e) {
    this.enableEnterEvent && e.type === "mouseenter" && this._emit(Nw, e);
  }
  handleLeaveEvent(e) {
    this.enableLeaveEvent && e.type === "mouseleave" && this._emit(kw, e);
  }
  handleMoveEvent(e) {
    if (this.enableMoveEvent)
      switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = !0);
          break;
        case "mousemove":
          e.buttons === 0 && (this.pressed = !1), this.pressed || this._emit(Ow, e);
          break;
        case "mouseup":
          this.pressed = !1;
          break;
      }
  }
  _emit(e, t) {
    this.callback({
      type: e,
      center: {
        x: t.clientX,
        y: t.clientY
      },
      srcEvent: t,
      pointerType: "mouse",
      target: t.target
    });
  }
}
const {
  KEY_EVENTS: ok
} = Ib, zw = "keydown", Uw = "keyup";
class ak extends i_ {
  constructor(e, t, i) {
    super(e, t, i), this.handleEvent = (r) => {
      const l = r.target || r.srcElement;
      l.tagName === "INPUT" && l.type === "text" || l.tagName === "TEXTAREA" || (this.enableDownEvent && r.type === "keydown" && this.callback({
        type: zw,
        srcEvent: r,
        key: r.key,
        target: r.target
      }), this.enableUpEvent && r.type === "keyup" && this.callback({
        type: Uw,
        srcEvent: r,
        key: r.key,
        target: r.target
      }));
    }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, this.events = (this.options.events || []).concat(ok), e.tabIndex = this.options.tabIndex || 0, e.style.outline = "none", this.events.forEach((r) => e.addEventListener(r, this.handleEvent));
  }
  destroy() {
    this.events.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === zw && (this.enableDownEvent = t), e === Uw && (this.enableUpEvent = t);
  }
}
const jw = "contextmenu";
class lk extends i_ {
  constructor(e, t, i) {
    super(e, t, i), this.handleEvent = (r) => {
      this.options.enable && this.callback({
        type: jw,
        center: {
          x: r.clientX,
          y: r.clientY
        },
        srcEvent: r,
        pointerType: "mouse",
        target: r.target
      });
    }, e.addEventListener("contextmenu", this.handleEvent);
  }
  destroy() {
    this.element.removeEventListener("contextmenu", this.handleEvent);
  }
  /**
   * Enable this input (begin processing events)
   * if the specified event type is among those handled by this input.
   */
  enableEventType(e, t) {
    e === jw && (this.options.enable = t);
  }
}
const Gw = 1, r1 = 2, Vw = 4, ck = {
  pointerdown: Gw,
  pointermove: r1,
  pointerup: Vw,
  mousedown: Gw,
  mousemove: r1,
  mouseup: Vw
}, uk = 0, hk = 1, dk = 2, fk = 1, pk = 2, gk = 4;
function mk(n) {
  const e = ck[n.srcEvent.type];
  if (!e)
    return null;
  const {
    buttons: t,
    button: i
  } = n.srcEvent;
  let r = !1, l = !1, c = !1;
  return e === r1 ? (r = !!(t & fk), l = !!(t & gk), c = !!(t & pk)) : (r = i === uk, l = i === hk, c = i === dk), {
    leftButton: r,
    middleButton: l,
    rightButton: c
  };
}
function _k(n, e) {
  const t = n.center;
  if (!t)
    return null;
  const i = e.getBoundingClientRect(), r = i.width / e.offsetWidth || 1, l = i.height / e.offsetHeight || 1, c = {
    x: (t.x - i.left - e.clientLeft) / r,
    y: (t.y - i.top - e.clientTop) / l
  };
  return {
    center: t,
    offsetCenter: c
  };
}
const z0 = {
  srcElement: "root",
  priority: 0
};
class yk {
  constructor(e) {
    this.handleEvent = (t) => {
      if (this.isEmpty())
        return;
      const i = this._normalizeEvent(t);
      let r = t.srcEvent.target;
      for (; r && r !== i.rootElement; ) {
        if (this._emit(i, r), i.handled)
          return;
        r = r.parentNode;
      }
      this._emit(i, "root");
    }, this.eventManager = e, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = !1;
  }
  // Returns true if there are no non-passive handlers
  isEmpty() {
    return !this._active;
  }
  add(e, t, i) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
    const {
      handlers: c,
      handlersByElement: a
    } = this;
    let g = z0;
    typeof i == "string" || i && i.addEventListener ? g = {
      ...z0,
      srcElement: i
    } : i && (g = {
      ...z0,
      ...i
    });
    let y = a.get(g.srcElement);
    y || (y = [], a.set(g.srcElement, y));
    const A = {
      type: e,
      handler: t,
      srcElement: g.srcElement,
      priority: g.priority
    };
    r && (A.once = !0), l && (A.passive = !0), c.push(A), this._active = this._active || !A.passive;
    let C = y.length - 1;
    for (; C >= 0 && !(y[C].priority >= A.priority); )
      C--;
    y.splice(C + 1, 0, A);
  }
  remove(e, t) {
    const {
      handlers: i,
      handlersByElement: r
    } = this;
    for (let l = i.length - 1; l >= 0; l--) {
      const c = i[l];
      if (c.type === e && c.handler === t) {
        i.splice(l, 1);
        const a = r.get(c.srcElement);
        a.splice(a.indexOf(c), 1), a.length === 0 && r.delete(c.srcElement);
      }
    }
    this._active = i.some((l) => !l.passive);
  }
  /**
   * Invoke handlers on a particular element
   */
  _emit(e, t) {
    const i = this.handlersByElement.get(t);
    if (i) {
      let r = !1;
      const l = () => {
        e.handled = !0;
      }, c = () => {
        e.handled = !0, r = !0;
      }, a = [];
      for (let g = 0; g < i.length; g++) {
        const {
          type: y,
          handler: A,
          once: C
        } = i[g];
        if (A({
          ...e,
          // @ts-ignore
          type: y,
          stopPropagation: l,
          stopImmediatePropagation: c
        }), C && a.push(i[g]), r)
          break;
      }
      for (let g = 0; g < a.length; g++) {
        const {
          type: y,
          handler: A
        } = a[g];
        this.remove(y, A);
      }
    }
  }
  /**
   * Normalizes hammerjs and custom events to have predictable fields.
   */
  _normalizeEvent(e) {
    const t = this.eventManager.getElement();
    return {
      ...e,
      ...mk(e),
      ..._k(e, t),
      preventDefault: () => {
        e.srcEvent.preventDefault();
      },
      stopImmediatePropagation: null,
      stopPropagation: null,
      handled: !1,
      rootElement: t
    };
  }
}
const bk = {
  // event handlers
  events: null,
  // custom recognizers
  recognizers: null,
  recognizerOptions: {},
  // Manager class
  Manager: ZN,
  // allow browser default touch action
  // https://github.com/uber/react-map-gl/issues/506
  touchAction: "none",
  tabIndex: 0
};
class vk {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, t = arguments.length > 1 ? arguments[1] : void 0;
    this._onBasicInput = (r) => {
      const {
        srcEvent: l
      } = r, c = YN[l.type];
      c && this.manager.emit(c, r);
    }, this._onOtherEvent = (r) => {
      this.manager.emit(r.type, r);
    }, this.options = {
      ...bk,
      ...t
    }, this.events = /* @__PURE__ */ new Map(), this.setElement(e);
    const {
      events: i
    } = this.options;
    i && this.on(i);
  }
  getElement() {
    return this.element;
  }
  setElement(e) {
    if (this.element && this.destroy(), this.element = e, !e)
      return;
    const {
      options: t
    } = this, i = t.Manager;
    this.manager = new i(e, {
      touchAction: t.touchAction,
      recognizers: t.recognizers || $N
    }).on("hammer.input", this._onBasicInput), t.recognizers || Object.keys(Mw).forEach((r) => {
      const l = this.manager.get(r);
      l && Mw[r].forEach((c) => {
        l.recognizeWith(c);
      });
    });
    for (const r in t.recognizerOptions) {
      const l = this.manager.get(r);
      if (l) {
        const c = t.recognizerOptions[r];
        delete c.enable, l.set(c);
      }
    }
    this.wheelInput = new ik(e, this._onOtherEvent, {
      enable: !1
    }), this.moveInput = new sk(e, this._onOtherEvent, {
      enable: !1
    }), this.keyInput = new ak(e, this._onOtherEvent, {
      enable: !1,
      tabIndex: t.tabIndex
    }), this.contextmenuInput = new lk(e, this._onOtherEvent, {
      enable: !1
    });
    for (const [r, l] of this.events)
      l.isEmpty() || (this._toggleRecognizer(l.recognizerName, !0), this.manager.on(r, l.handleEvent));
  }
  // Tear down internal event management implementations.
  destroy() {
    this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy(), this.wheelInput = null, this.moveInput = null, this.keyInput = null, this.contextmenuInput = null, this.manager = null, this.element = null);
  }
  /** Register an event handler function to be called on `event` */
  on(e, t, i) {
    this._addEventHandler(e, t, i, !1);
  }
  once(e, t, i) {
    this._addEventHandler(e, t, i, !0);
  }
  watch(e, t, i) {
    this._addEventHandler(e, t, i, !1, !0);
  }
  off(e, t) {
    this._removeEventHandler(e, t);
  }
  /*
   * Enable/disable recognizer for the given event
   */
  _toggleRecognizer(e, t) {
    const {
      manager: i
    } = this;
    if (!i)
      return;
    const r = i.get(e);
    if (r && r.options.enable !== t) {
      r.set({
        enable: t
      });
      const l = XN[e];
      l && !this.options.recognizers && l.forEach((c) => {
        const a = i.get(c);
        t ? (a.requireFailure(e), r.dropRequireFailure(c)) : a.dropRequireFailure(e);
      });
    }
    this.wheelInput.enableEventType(e, t), this.moveInput.enableEventType(e, t), this.keyInput.enableEventType(e, t), this.contextmenuInput.enableEventType(e, t);
  }
  /**
   * Process the event registration for a single event + handler.
   */
  _addEventHandler(e, t, i, r, l) {
    if (typeof e != "string") {
      i = t;
      for (const A in e)
        this._addEventHandler(A, e[A], i, r, l);
      return;
    }
    const {
      manager: c,
      events: a
    } = this, g = Lw[e] || e;
    let y = a.get(g);
    y || (y = new yk(this), a.set(g, y), y.recognizerName = JN[g] || g, c && c.on(g, y.handleEvent)), y.add(e, t, i, r, l), y.isEmpty() || this._toggleRecognizer(y.recognizerName, !0);
  }
  /**
   * Process the event deregistration for a single event + handler.
   */
  _removeEventHandler(e, t) {
    if (typeof e != "string") {
      for (const c in e)
        this._removeEventHandler(c, e[c]);
      return;
    }
    const {
      events: i
    } = this, r = Lw[e] || e, l = i.get(r);
    if (l && (l.remove(e, t), l.isEmpty())) {
      const {
        recognizerName: c
      } = l;
      let a = !1;
      for (const g of i.values())
        if (g.recognizerName === c && !g.isEmpty()) {
          a = !0;
          break;
        }
      a || this._toggleRecognizer(c, !1);
    }
  }
}
function Oh() {
}
const xk = (n) => {
  let {
    isDragging: e
  } = n;
  return e ? "grabbing" : "grab";
}, XE = {
  id: "",
  width: "100%",
  height: "100%",
  style: null,
  viewState: null,
  initialViewState: null,
  pickingRadius: 0,
  layerFilter: null,
  glOptions: {},
  parameters: {},
  parent: null,
  gl: null,
  canvas: null,
  layers: [],
  effects: [],
  views: null,
  controller: null,
  useDevicePixels: !0,
  touchAction: "none",
  eventRecognizerOptions: {},
  _framebuffer: null,
  _animate: !1,
  _pickable: !0,
  _typedArrayManagerProps: {},
  _customRender: null,
  onWebGLInitialized: Oh,
  onResize: Oh,
  onViewStateChange: Oh,
  onInteractionStateChange: Oh,
  onBeforeRender: Oh,
  onAfterRender: Oh,
  onLoad: Oh,
  onError: (n) => zi.error(n.message, n.cause)(),
  onHover: null,
  onClick: null,
  onDragStart: null,
  onDrag: null,
  onDragEnd: null,
  _onMetrics: null,
  getCursor: xk,
  getTooltip: null,
  debug: !1,
  drawPickingColors: !1
};
class Mb {
  constructor(e) {
    H(this, "props", void 0), H(this, "width", 0), H(this, "height", 0), H(this, "userData", {}), H(this, "canvas", null), H(this, "viewManager", null), H(this, "layerManager", null), H(this, "effectManager", null), H(this, "deckRenderer", null), H(this, "deckPicker", null), H(this, "eventManager", null), H(this, "tooltip", null), H(this, "metrics", void 0), H(this, "animationLoop", void 0), H(this, "stats", void 0), H(this, "viewState", void 0), H(this, "cursorState", void 0), H(this, "_needsRedraw", void 0), H(this, "_pickRequest", void 0), H(this, "_lastPointerDownInfo", null), H(this, "_metricsCounter", void 0), H(this, "_onPointerMove", (t) => {
      const {
        _pickRequest: i
      } = this;
      if (t.type === "pointerleave")
        i.x = -1, i.y = -1, i.radius = 0;
      else {
        if (t.leftButton || t.rightButton)
          return;
        {
          const r = t.offsetCenter;
          if (!r)
            return;
          i.x = r.x, i.y = r.y, i.radius = this.props.pickingRadius;
        }
      }
      this.layerManager && (this.layerManager.context.mousePosition = {
        x: i.x,
        y: i.y
      }), i.event = t;
    }), H(this, "_onEvent", (t) => {
      const i = wx[t.type], r = t.offsetCenter;
      if (!i || !r || !this.layerManager)
        return;
      const l = this.layerManager.getLayers(), c = this.deckPicker.getLastPickedObject({
        x: r.x,
        y: r.y,
        layers: l,
        viewports: this.getViewports(r)
      }, this._lastPointerDownInfo), {
        layer: a
      } = c, g = a && (a[i.handler] || a.props[i.handler]), y = this.props[i.handler];
      let A = !1;
      g && (A = g.call(a, c, t)), !A && y && y(c, t);
    }), H(this, "_onPointerDown", (t) => {
      const i = t.offsetCenter, r = this._pick("pickObject", "pickObject Time", {
        x: i.x,
        y: i.y,
        radius: this.props.pickingRadius
      });
      this._lastPointerDownInfo = r.result[0] || r.emptyInfo;
    }), this.props = {
      ...XE,
      ...e
    }, e = this.props, this._needsRedraw = "Initial render", this._pickRequest = {
      mode: "hover",
      x: -1,
      y: -1,
      radius: 0,
      event: null
    }, this.cursorState = {
      isHovering: !1,
      isDragging: !1
    }, e.viewState && e.initialViewState && zi.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), xT() === "IE" && zi.warn("IE 11 is not supported")(), this.viewState = e.initialViewState, e.gl || typeof document < "u" && (this.canvas = this._createCanvas(e)), this.animationLoop = this._createAnimationLoop(e), this.stats = new Up({
      id: "deck.gl"
    }), this.metrics = {
      fps: 0,
      setPropsTime: 0,
      updateAttributesTime: 0,
      framesRedrawn: 0,
      pickTime: 0,
      pickCount: 0,
      gpuTime: 0,
      gpuTimePerFrame: 0,
      cpuTime: 0,
      cpuTimePerFrame: 0,
      bufferMemory: 0,
      textureMemory: 0,
      renderbufferMemory: 0,
      gpuMemory: 0
    }, this._metricsCounter = 0, this.setProps(e), e._typedArrayManagerProps && Rp.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
  }
  finalize() {
    var e, t, i, r, l, c, a, g;
    if ((e = this.animationLoop) === null || e === void 0 || e.stop(), this.animationLoop = null, this._lastPointerDownInfo = null, (t = this.layerManager) === null || t === void 0 || t.finalize(), this.layerManager = null, (i = this.viewManager) === null || i === void 0 || i.finalize(), this.viewManager = null, (r = this.effectManager) === null || r === void 0 || r.finalize(), this.effectManager = null, (l = this.deckRenderer) === null || l === void 0 || l.finalize(), this.deckRenderer = null, (c = this.deckPicker) === null || c === void 0 || c.finalize(), this.deckPicker = null, (a = this.eventManager) === null || a === void 0 || a.destroy(), this.eventManager = null, (g = this.tooltip) === null || g === void 0 || g.remove(), this.tooltip = null, !this.props.canvas && !this.props.gl && this.canvas) {
      var y;
      (y = this.canvas.parentElement) === null || y === void 0 || y.removeChild(this.canvas), this.canvas = null;
    }
  }
  setProps(e) {
    this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && zi.removed("onLayerHover", "onHover")(), "onLayerClick" in e && zi.removed("onLayerClick", "onClick")(), e.initialViewState && !Kc(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
    const t = Object.create(this.props);
    Object.assign(t, {
      views: this._getViews(),
      width: this.width,
      height: this.height,
      viewState: this._getViewState()
    }), this.animationLoop.setProps(t), this.layerManager && (this.viewManager.setProps(t), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(t), this.effectManager.setProps(t), this.deckRenderer.setProps(t), this.deckPicker.setProps(t)), this.stats.get("setProps Time").timeEnd();
  }
  needsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    if (!this.layerManager)
      return !1;
    if (this.props._animate)
      return "Deck._animate";
    let t = this._needsRedraw;
    e.clearRedrawFlags && (this._needsRedraw = !1);
    const i = this.viewManager.needsRedraw(e), r = this.layerManager.needsRedraw(e), l = this.effectManager.needsRedraw(e), c = this.deckRenderer.needsRedraw(e);
    return t = t || i || r || l || c, t;
  }
  redraw(e) {
    if (!this.layerManager)
      return;
    let t = this.needsRedraw({
      clearRedrawFlags: !0
    });
    t = e || t, t && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(t) : this._drawLayers(t));
  }
  get isInitialized() {
    return this.viewManager !== null;
  }
  getViews() {
    return wo(this.viewManager), this.viewManager.views;
  }
  getViewports(e) {
    return wo(this.viewManager), this.viewManager.getViewports(e);
  }
  getCanvas() {
    return this.canvas;
  }
  pickObject(e) {
    const t = this._pick("pickObject", "pickObject Time", e).result;
    return t.length ? t[0] : null;
  }
  pickMultipleObjects(e) {
    return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
  }
  pickObjects(e) {
    return this._pick("pickObjects", "pickObjects Time", e);
  }
  _addResources(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    for (const i in e)
      this.layerManager.resourceManager.add({
        resourceId: i,
        data: e[i],
        forceUpdate: t
      });
  }
  _removeResources(e) {
    for (const t of e)
      this.layerManager.resourceManager.remove(t);
  }
  _addDefaultEffect(e) {
    this.effectManager.addDefaultEffect(e);
  }
  _pick(e, t, i) {
    wo(this.deckPicker);
    const {
      stats: r
    } = this;
    r.get("Pick Count").incrementCount(), r.get(t).timeStart();
    const l = this.deckPicker[e]({
      layers: this.layerManager.getLayers(i),
      views: this.viewManager.getViews(),
      viewports: this.getViewports(i),
      onViewportActive: this.layerManager.activateViewport,
      effects: this.effectManager.getEffects(),
      ...i
    });
    return r.get(t).timeEnd(), l;
  }
  _createCanvas(e) {
    let t = e.canvas;
    return typeof t == "string" && (t = document.getElementById(t), wo(t)), t || (t = document.createElement("canvas"), t.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(t)), Object.assign(t.style, e.style), t;
  }
  _setCanvasSize(e) {
    if (!this.canvas)
      return;
    const {
      width: t,
      height: i
    } = e;
    if (t || t === 0) {
      const l = Number.isFinite(t) ? "".concat(t, "px") : t;
      this.canvas.style.width = l;
    }
    if (i || i === 0) {
      var r;
      const l = Number.isFinite(i) ? "".concat(i, "px") : i;
      this.canvas.style.position = ((r = e.style) === null || r === void 0 ? void 0 : r.position) || "absolute", this.canvas.style.height = l;
    }
  }
  _updateCanvasSize() {
    var e, t;
    const {
      canvas: i
    } = this;
    if (!i)
      return;
    const r = (e = i.clientWidth) !== null && e !== void 0 ? e : i.width, l = (t = i.clientHeight) !== null && t !== void 0 ? t : i.height;
    if (r !== this.width || l !== this.height) {
      var c, a;
      this.width = r, this.height = l, (c = this.viewManager) === null || c === void 0 || c.setProps({
        width: r,
        height: l
      }), (a = this.layerManager) === null || a === void 0 || a.activateViewport(this.getViewports()[0]), this.props.onResize({
        width: r,
        height: l
      });
    }
  }
  _createAnimationLoop(e) {
    const {
      width: t,
      height: i,
      gl: r,
      glOptions: l,
      debug: c,
      onError: a,
      onBeforeRender: g,
      onAfterRender: y,
      useDevicePixels: A
    } = e;
    return new X4({
      width: t,
      height: i,
      useDevicePixels: A,
      autoResizeDrawingBuffer: !r,
      autoResizeViewport: !1,
      gl: r,
      onCreateContext: (C) => UT({
        ...l,
        ...C,
        canvas: this.canvas,
        debug: c,
        onContextLost: () => this._onContextLost()
      }),
      onInitialize: (C) => this._setGLContext(C.gl),
      onRender: this._onRenderFrame.bind(this),
      onBeforeRender: g,
      onAfterRender: y,
      onError: a
    });
  }
  _getViewState() {
    return this.props.viewState || this.viewState;
  }
  _getViews() {
    let e = this.props.views || [new Pb({
      id: "default-view"
    })];
    return e = Array.isArray(e) ? e : [e], e.length && this.props.controller && (e[0].props.controller = this.props.controller), e;
  }
  _onContextLost() {
    const {
      onError: e
    } = this.props;
    this.animationLoop && e && e(new Error("WebGL context is lost"));
  }
  _pickAndCallback() {
    const {
      _pickRequest: e
    } = this;
    if (e.event) {
      const {
        result: i,
        emptyInfo: r
      } = this._pick("pickObject", "pickObject Time", e);
      this.cursorState.isHovering = i.length > 0;
      let l = r, c = !1;
      for (const a of i) {
        var t;
        l = a, c = ((t = a.layer) === null || t === void 0 ? void 0 : t.onHover(a, e.event)) || c;
      }
      if (!c && this.props.onHover && this.props.onHover(l, e.event), this.props.getTooltip && this.tooltip) {
        const a = this.props.getTooltip(l);
        this.tooltip.setTooltip(a, l.x, l.y);
      }
      e.event = null;
    }
  }
  _updateCursor() {
    const e = this.props.parent || this.canvas;
    e && (e.style.cursor = this.props.getCursor(this.cursorState));
  }
  _setGLContext(e) {
    if (this.layerManager)
      return;
    this.canvas || (this.canvas = e.canvas, ib(e, {
      enable: !0,
      copyState: !0
    })), this.tooltip = new jN(this.canvas), Bu(e, {
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthTest: !0,
      depthFunc: 515
    }), this.props.onWebGLInitialized(e);
    const t = new IE();
    t.play(), this.animationLoop.attachTimeline(t), this.eventManager = new vk(this.props.parent || e.canvas, {
      touchAction: this.props.touchAction,
      recognizerOptions: this.props.eventRecognizerOptions,
      events: {
        pointerdown: this._onPointerDown,
        pointermove: this._onPointerMove,
        pointerleave: this._onPointerMove
      }
    });
    for (const r in wx)
      this.eventManager.on(r, this._onEvent);
    this.viewManager = new fN({
      timeline: t,
      eventManager: this.eventManager,
      onViewStateChange: this._onViewStateChange.bind(this),
      onInteractionStateChange: this._onInteractionStateChange.bind(this),
      views: this._getViews(),
      viewState: this._getViewState(),
      width: this.width,
      height: this.height
    });
    const i = this.viewManager.getViewports()[0];
    this.layerManager = new dN(e, {
      deck: this,
      stats: this.stats,
      viewport: i,
      timeline: t
    }), this.effectManager = new MN(), this.deckRenderer = new BN(e), this.deckPicker = new zN(e), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
  }
  _drawLayers(e, t) {
    const {
      gl: i
    } = this.layerManager.context;
    Bu(i, this.props.parameters), this.props.onBeforeRender({
      gl: i
    }), this.deckRenderer.renderLayers({
      target: this.props._framebuffer,
      layers: this.layerManager.getLayers(),
      viewports: this.viewManager.getViewports(),
      onViewportActive: this.layerManager.activateViewport,
      views: this.viewManager.getViews(),
      pass: "screen",
      effects: this.effectManager.getEffects(),
      ...t
    }), this.props.onAfterRender({
      gl: i
    });
  }
  _onRenderFrame(e) {
    this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), zi.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.tooltip.isVisible && this.viewManager.needsRedraw() && this.tooltip.setTooltip(null), this.layerManager.updateLayers(), this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
  }
  _onViewStateChange(e) {
    const t = this.props.onViewStateChange(e) || e.viewState;
    this.viewState && (this.viewState = {
      ...this.viewState,
      [e.viewId]: t
    }, this.props.viewState || this.viewManager && this.viewManager.setProps({
      viewState: this.viewState
    }));
  }
  _onInteractionStateChange(e) {
    this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e);
  }
  _getFrameStats() {
    const {
      stats: e
    } = this;
    e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
    const t = this.animationLoop.stats;
    e.get("GPU Time").addTime(t.get("GPU Time").lastTiming), e.get("CPU Time").addTime(t.get("CPU Time").lastTiming);
  }
  _getMetrics() {
    const {
      metrics: e,
      stats: t
    } = this;
    e.fps = t.get("frameRate").getHz(), e.setPropsTime = t.get("setProps Time").time, e.updateAttributesTime = t.get("Update Attributes").time, e.framesRedrawn = t.get("Redraw Count").count, e.pickTime = t.get("pickObject Time").time + t.get("pickMultipleObjects Time").time + t.get("pickObjects Time").time, e.pickCount = t.get("Pick Count").count, e.gpuTime = t.get("GPU Time").time, e.cpuTime = t.get("CPU Time").time, e.gpuTimePerFrame = t.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = t.get("CPU Time").getAverageTime();
    const i = Gh.get("Memory Usage");
    e.bufferMemory = i.get("Buffer Memory").count, e.textureMemory = i.get("Texture Memory").count, e.renderbufferMemory = i.get("Renderbuffer Memory").count, e.gpuMemory = i.get("GPU Memory").count;
  }
}
H(Mb, "defaultProps", XE);
H(Mb, "VERSION", tR);
class U0 {
  constructor(e, t) {
    H(this, "opts", void 0), H(this, "source", void 0), this.opts = t, this.source = e;
  }
  get value() {
    return this.source.value;
  }
  getValue() {
    const e = this.source.getBuffer(), t = this.getAccessor();
    if (e)
      return [e, t];
    const {
      value: i
    } = this.source, {
      size: r
    } = t;
    let l = i;
    if (i && i.length !== r) {
      l = new Float32Array(r);
      const c = t.elementOffset || 0;
      for (let a = 0; a < r; ++a)
        l[a] = i[c + a];
    }
    return l;
  }
  getAccessor() {
    return {
      ...this.source.getAccessor(),
      ...this.opts
    };
  }
}
function wk(n) {
  switch (n) {
    case 5126:
      return Float32Array;
    case 5130:
      return Float64Array;
    case 5123:
    case 33635:
    case 32819:
    case 32820:
      return Uint16Array;
    case 5125:
      return Uint32Array;
    case 5121:
      return Uint8ClampedArray;
    case 5120:
      return Int8Array;
    case 5122:
      return Int16Array;
    case 5124:
      return Int32Array;
    default:
      throw new Error("Unknown GL type");
  }
}
function lm(n) {
  return n.stride || n.size * n.bytesPerElement;
}
function YE(n, e) {
  e.offset && zi.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
  const t = lm(n), i = e.vertexOffset !== void 0 ? e.vertexOffset : n.vertexOffset || 0, r = e.elementOffset || 0, l = i * t + r * n.bytesPerElement + (n.offset || 0);
  return {
    ...e,
    offset: l,
    stride: t
  };
}
function Ak(n, e) {
  const t = YE(n, e);
  return {
    high: t,
    low: {
      ...t,
      offset: t.offset + n.size * 4
    }
  };
}
class Tk {
  constructor(e, t, i) {
    H(this, "gl", void 0), H(this, "id", void 0), H(this, "size", void 0), H(this, "settings", void 0), H(this, "value", void 0), H(this, "doublePrecision", void 0), H(this, "_buffer", void 0), H(this, "state", void 0), this.gl = e, this.id = t.id || "", this.size = t.size || 1;
    const r = t.logicalType || t.type, l = r === 5130;
    let {
      defaultValue: c
    } = t;
    c = Number.isFinite(c) ? [c] : c || new Array(this.size).fill(0);
    let a;
    l ? a = 5126 : !r && t.isIndexed ? a = e && ob(e, Tr.ELEMENT_INDEX_UINT32) ? 5125 : 5123 : a = r || 5126;
    let g = wk(r || a || 5126);
    this.doublePrecision = l, l && t.fp64 === !1 && (g = Float32Array), this.value = null, this.settings = {
      ...t,
      defaultType: g,
      defaultValue: c,
      logicalType: r,
      type: a,
      size: this.size,
      bytesPerElement: g.BYTES_PER_ELEMENT
    }, this.state = {
      ...i,
      externalBuffer: null,
      bufferAccessor: this.settings,
      allocatedValue: null,
      numInstances: 0,
      bounds: null,
      constant: !1
    }, this._buffer = null;
  }
  get isConstant() {
    return this.state.constant;
  }
  get buffer() {
    if (!this._buffer) {
      const {
        isIndexed: e,
        type: t
      } = this.settings;
      this._buffer = new dr(this.gl, {
        id: this.id,
        target: e ? 34963 : 34962,
        accessor: {
          type: t
        }
      });
    }
    return this._buffer;
  }
  get byteOffset() {
    const e = this.getAccessor();
    return e.vertexOffset ? e.vertexOffset * lm(e) : 0;
  }
  get numInstances() {
    return this.state.numInstances;
  }
  set numInstances(e) {
    this.state.numInstances = e;
  }
  delete() {
    this._buffer && (this._buffer.delete(), this._buffer = null), Rp.release(this.state.allocatedValue);
  }
  getShaderAttributes(e, t) {
    if (this.doublePrecision) {
      const i = {}, r = this.value instanceof Float64Array, l = Ak(this.getAccessor(), t || {});
      return i[e] = new U0(this, l.high), i["".concat(e, "64Low")] = r ? new U0(this, l.low) : new Float32Array(this.size), i;
    }
    if (t) {
      const i = YE(this.getAccessor(), t);
      return {
        [e]: new U0(this, i)
      };
    }
    return {
      [e]: this
    };
  }
  getBuffer() {
    return this.state.constant ? null : this.state.externalBuffer || this._buffer;
  }
  getValue() {
    return this.state.constant ? this.value : [this.getBuffer(), this.getAccessor()];
  }
  getAccessor() {
    return this.state.bufferAccessor;
  }
  getBounds() {
    if (this.state.bounds)
      return this.state.bounds;
    let e = null;
    if (this.state.constant && this.value) {
      const t = Array.from(this.value);
      e = [t, t];
    } else {
      const {
        value: t,
        numInstances: i,
        size: r
      } = this, l = i * r;
      if (t && l && t.length >= l) {
        const c = new Array(r).fill(1 / 0), a = new Array(r).fill(-1 / 0);
        for (let g = 0; g < l; )
          for (let y = 0; y < r; y++) {
            const A = t[g++];
            A < c[y] && (c[y] = A), A > a[y] && (a[y] = A);
          }
        e = [c, a];
      }
    }
    return this.state.bounds = e, e;
  }
  setData(e) {
    const {
      state: t
    } = this;
    let i;
    ArrayBuffer.isView(e) ? i = {
      value: e
    } : e instanceof dr ? i = {
      buffer: e
    } : i = e;
    const r = {
      ...this.settings,
      ...i
    };
    if (t.bufferAccessor = r, t.bounds = null, i.constant) {
      let l = i.value;
      if (l = this._normalizeValue(l, [], 0), this.settings.normalized && (l = this.normalizeConstant(l)), !(!t.constant || !this._areValuesEqual(l, this.value)))
        return !1;
      t.externalBuffer = null, t.constant = !0, this.value = l;
    } else if (i.buffer) {
      const l = i.buffer;
      t.externalBuffer = l, t.constant = !1, this.value = i.value || null;
      const c = i.value instanceof Float64Array;
      r.type = i.type || l.accessor.type, r.bytesPerElement = l.accessor.BYTES_PER_ELEMENT * (c ? 2 : 1), r.stride = lm(r);
    } else if (i.value) {
      this._checkExternalBuffer(i);
      let l = i.value;
      t.externalBuffer = null, t.constant = !1, this.value = l, r.bytesPerElement = l.BYTES_PER_ELEMENT, r.stride = lm(r);
      const {
        buffer: c,
        byteOffset: a
      } = this;
      this.doublePrecision && l instanceof Float64Array && (l = F0(l, r));
      const g = l.byteLength + a + r.stride * 2;
      c.byteLength < g && c.reallocate(g), c.setAccessor(null), c.subData({
        data: l,
        offset: a
      }), r.type = i.type || c.accessor.type;
    }
    return !0;
  }
  updateSubBuffer() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.state.bounds = null;
    const t = this.value, {
      startOffset: i = 0,
      endOffset: r
    } = e;
    this.buffer.subData({
      data: this.doublePrecision && t instanceof Float64Array ? F0(t, {
        size: this.size,
        startIndex: i,
        endIndex: r
      }) : t.subarray(i, r),
      offset: i * t.BYTES_PER_ELEMENT + this.byteOffset
    });
  }
  allocate(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const {
      state: i
    } = this, r = i.allocatedValue, l = Rp.allocate(r, e + 1, {
      size: this.size,
      type: this.settings.defaultType,
      copy: t
    });
    this.value = l;
    const {
      buffer: c,
      byteOffset: a
    } = this;
    return c.byteLength < l.byteLength + a && (c.reallocate(l.byteLength + a), t && r && c.subData({
      data: r instanceof Float64Array ? F0(r, this) : r,
      offset: a
    })), i.allocatedValue = l, i.constant = !1, i.externalBuffer = null, i.bufferAccessor = this.settings, !0;
  }
  _checkExternalBuffer(e) {
    const {
      value: t
    } = e;
    if (!ArrayBuffer.isView(t))
      throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
    const i = this.settings.defaultType;
    let r = !1;
    if (this.doublePrecision && (r = t.BYTES_PER_ELEMENT < 4), r)
      throw new Error("Attribute ".concat(this.id, " does not support ").concat(t.constructor.name));
    !(t instanceof i) && this.settings.normalized && !("normalized" in e) && zi.warn("Attribute ".concat(this.id, " is normalized"))();
  }
  normalizeConstant(e) {
    switch (this.settings.type) {
      case 5120:
        return new Float32Array(e).map((t) => (t + 128) / 255 * 2 - 1);
      case 5122:
        return new Float32Array(e).map((t) => (t + 32768) / 65535 * 2 - 1);
      case 5121:
        return new Float32Array(e).map((t) => t / 255);
      case 5123:
        return new Float32Array(e).map((t) => t / 65535);
      default:
        return e;
    }
  }
  _normalizeValue(e, t, i) {
    const {
      defaultValue: r,
      size: l
    } = this.settings;
    if (Number.isFinite(e))
      return t[i] = e, t;
    if (!e) {
      let c = l;
      for (; --c >= 0; )
        t[i + c] = r[c];
      return t;
    }
    switch (l) {
      case 4:
        t[i + 3] = Number.isFinite(e[3]) ? e[3] : r[3];
      case 3:
        t[i + 2] = Number.isFinite(e[2]) ? e[2] : r[2];
      case 2:
        t[i + 1] = Number.isFinite(e[1]) ? e[1] : r[1];
      case 1:
        t[i + 0] = Number.isFinite(e[0]) ? e[0] : r[0];
        break;
      default:
        let c = l;
        for (; --c >= 0; )
          t[i + c] = Number.isFinite(e[c]) ? e[c] : r[c];
    }
    return t;
  }
  _areValuesEqual(e, t) {
    if (!e || !t)
      return !1;
    const {
      size: i
    } = this;
    for (let r = 0; r < i; r++)
      if (e[r] !== t[r])
        return !1;
    return !0;
  }
}
const qw = [], Hw = [];
function JE(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1 / 0, i = qw;
  const r = {
    index: -1,
    data: n,
    target: []
  };
  return n ? typeof n[Symbol.iterator] == "function" ? i = n : n.length > 0 && (Hw.length = n.length, i = Hw) : i = qw, (e > 0 || Number.isFinite(t)) && (i = (Array.isArray(i) ? i : Array.from(i)).slice(e, t), r.index = e - 1), {
    iterable: i,
    objectInfo: r
  };
}
function KE(n) {
  return n && n[Symbol.asyncIterator];
}
function Ek(n, e) {
  const {
    size: t,
    stride: i,
    offset: r,
    startIndices: l,
    nested: c
  } = e, a = n.BYTES_PER_ELEMENT, g = i ? i / a : t, y = r ? r / a : 0, A = Math.floor((n.length - y) / g);
  return (C, I) => {
    let {
      index: S,
      target: F
    } = I;
    if (!l) {
      const X = S * g + y;
      for (let de = 0; de < t; de++)
        F[de] = n[X + de];
      return F;
    }
    const U = l[S], V = l[S + 1] || A;
    let W;
    if (c) {
      W = new Array(V - U);
      for (let X = U; X < V; X++) {
        const de = X * g + y;
        F = new Array(t);
        for (let ie = 0; ie < t; ie++)
          F[ie] = n[de + ie];
        W[X - U] = F;
      }
    } else if (g === t)
      W = n.subarray(U * t + y, V * t + y);
    else {
      W = new n.constructor((V - U) * t);
      let X = 0;
      for (let de = U; de < V; de++) {
        const ie = de * g + y;
        for (let fe = 0; fe < t; fe++)
          W[X++] = n[ie + fe];
      }
    }
    return W;
  };
}
const Sk = [], cm = [[0, 1 / 0]];
function Ck(n, e) {
  if (n === cm || (e[0] < 0 && (e[0] = 0), e[0] >= e[1]))
    return n;
  const t = [], i = n.length;
  let r = 0;
  for (let l = 0; l < i; l++) {
    const c = n[l];
    c[1] < e[0] ? (t.push(c), r = l + 1) : c[0] > e[1] ? t.push(c) : e = [Math.min(c[0], e[0]), Math.max(c[1], e[1])];
  }
  return t.splice(r, 0, e), t;
}
function j0(n) {
  const {
    source: e,
    target: t,
    start: i = 0,
    size: r,
    getData: l
  } = n, c = n.end || t.length, a = e.length, g = c - i;
  if (a > g) {
    t.set(e.subarray(0, g), i);
    return;
  }
  if (t.set(e, i), !l)
    return;
  let y = a;
  for (; y < g; ) {
    const A = l(y, e);
    for (let C = 0; C < r; C++)
      t[i + y] = A[C] || 0, y++;
  }
}
function Pk(n) {
  let {
    source: e,
    target: t,
    size: i,
    getData: r,
    sourceStartIndices: l,
    targetStartIndices: c
  } = n;
  if (!Array.isArray(c))
    return j0({
      source: e,
      target: t,
      size: i,
      getData: r
    }), t;
  let a = 0, g = 0;
  const y = r && ((C, I) => r(C + g, I)), A = Math.min(l.length, c.length);
  for (let C = 1; C < A; C++) {
    const I = l[C] * i, S = c[C] * i;
    j0({
      source: e.subarray(a, I),
      target: t,
      start: g,
      end: S,
      size: i,
      getData: y
    }), a = I, g = S;
  }
  return g < t.length && j0({
    source: [],
    target: t,
    start: g,
    size: i,
    getData: y
  }), t;
}
const Ik = {
  interpolation: {
    duration: 0,
    easing: (n) => n
  },
  spring: {
    stiffness: 0.05,
    damping: 0.5
  }
};
function QE(n, e) {
  if (!n)
    return null;
  Number.isFinite(n) && (n = {
    type: "interpolation",
    duration: n
  });
  const t = n.type || "interpolation";
  return {
    ...Ik[t],
    ...e,
    ...n,
    type: t
  };
}
function eS(n, e) {
  const t = e.getBuffer();
  return t ? [t, {
    divisor: 0,
    size: e.size,
    normalized: e.settings.normalized
  }] : e.value;
}
function tS(n) {
  switch (n) {
    case 1:
      return "float";
    case 2:
      return "vec2";
    case 3:
      return "vec3";
    case 4:
      return "vec4";
    default:
      throw new Error('No defined attribute type for size "'.concat(n, '"'));
  }
}
function nS(n) {
  n.push(n.shift());
}
function Lb(n, e) {
  const {
    doublePrecision: t,
    settings: i,
    value: r,
    size: l
  } = n, c = t && r instanceof Float64Array ? 2 : 1;
  return (i.noAlloc ? r.length : e * l) * c;
}
function iS(n) {
  let {
    buffer: e,
    numInstances: t,
    attribute: i,
    fromLength: r,
    fromStartIndices: l,
    getData: c = (X) => X
  } = n;
  const a = i.doublePrecision && i.value instanceof Float64Array ? 2 : 1, g = i.size * a, y = i.byteOffset, A = i.startIndices, C = l && A, I = Lb(i, t), S = i.isConstant;
  if (!C && r >= I)
    return;
  const F = S ? i.value : i.getBuffer().getData({
    srcByteOffset: y
  });
  if (i.settings.normalized && !S) {
    const X = c;
    c = (de, ie) => i.normalizeConstant(X(de, ie));
  }
  const U = S ? (X, de) => c(F, de) : (X, de) => c(F.subarray(X, X + g), de), V = e.getData({
    length: r
  }), W = new Float32Array(I);
  Pk({
    source: V,
    target: W,
    sourceStartIndices: l,
    targetStartIndices: A,
    size: g,
    getData: U
  }), e.byteLength < W.byteLength + y && e.reallocate(W.byteLength + y), e.subData({
    data: W,
    offset: y
  });
}
class Rb extends Tk {
  constructor(e, t) {
    super(e, t, {
      startIndices: null,
      lastExternalBuffer: null,
      binaryValue: null,
      binaryAccessor: null,
      needsUpdate: !0,
      needsRedraw: !1,
      updateRanges: cm
    }), H(this, "constant", !1), this.settings.update = t.update || (t.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
  }
  get startIndices() {
    return this.state.startIndices;
  }
  set startIndices(e) {
    this.state.startIndices = e;
  }
  needsUpdate() {
    return this.state.needsUpdate;
  }
  needsRedraw() {
    let {
      clearChangedFlags: e = !1
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = this.state.needsRedraw;
    return this.state.needsRedraw = t && !e, t;
  }
  getUpdateTriggers() {
    const {
      accessor: e
    } = this.settings;
    return [this.id].concat(typeof e != "function" && e || []);
  }
  supportsTransition() {
    return !!this.settings.transition;
  }
  getTransitionSetting(e) {
    if (!e || !this.supportsTransition())
      return null;
    const {
      accessor: t
    } = this.settings, i = this.settings.transition, r = Array.isArray(t) ? e[t.find((l) => e[l])] : e[t];
    return QE(r, i);
  }
  setNeedsUpdate() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id, t = arguments.length > 1 ? arguments[1] : void 0;
    if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), t) {
      const {
        startRow: i = 0,
        endRow: r = 1 / 0
      } = t;
      this.state.updateRanges = Ck(this.state.updateRanges, [i, r]);
    } else
      this.state.updateRanges = cm;
  }
  clearNeedsUpdate() {
    this.state.needsUpdate = !1, this.state.updateRanges = Sk;
  }
  setNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.id;
    this.state.needsRedraw = this.state.needsRedraw || e;
  }
  allocate(e) {
    const {
      state: t,
      settings: i
    } = this;
    return i.noAlloc ? !1 : i.update ? (super.allocate(e, t.updateRanges !== cm), !0) : !1;
  }
  updateBuffer(e) {
    let {
      numInstances: t,
      data: i,
      props: r,
      context: l
    } = e;
    if (!this.needsUpdate())
      return !1;
    const {
      state: {
        updateRanges: c
      },
      settings: {
        update: a,
        noAlloc: g
      }
    } = this;
    let y = !0;
    if (a) {
      for (const [A, C] of c)
        a.call(l, this, {
          data: i,
          startRow: A,
          endRow: C,
          props: r,
          numInstances: t
        });
      if (this.value) if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset)
        this.setData({
          value: this.value,
          constant: this.constant
        }), this.constant = !1;
      else
        for (const [A, C] of c) {
          const I = Number.isFinite(A) ? this.getVertexOffset(A) : 0, S = Number.isFinite(C) ? this.getVertexOffset(C) : g || !Number.isFinite(t) ? this.value.length : t * this.size;
          super.updateSubBuffer({
            startOffset: I,
            endOffset: S
          });
        }
      this._checkAttributeArray();
    } else
      y = !1;
    return this.clearNeedsUpdate(), this.setNeedsRedraw(), y;
  }
  setConstantValue(e) {
    return e === void 0 || typeof e == "function" ? !1 : (this.setData({
      constant: !0,
      value: e
    }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0);
  }
  setExternalBuffer(e) {
    const {
      state: t
    } = this;
    return e ? (this.clearNeedsUpdate(), t.lastExternalBuffer === e || (t.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (t.lastExternalBuffer = null, !1);
  }
  setBinaryValue(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    const {
      state: i,
      settings: r
    } = this;
    if (!e)
      return i.binaryValue = null, i.binaryAccessor = null, !1;
    if (r.noAlloc)
      return !1;
    if (i.binaryValue === e)
      return this.clearNeedsUpdate(), !0;
    if (i.binaryValue = e, this.setNeedsRedraw(), r.transform || t !== this.startIndices) {
      ArrayBuffer.isView(e) && (e = {
        value: e
      });
      const c = e;
      wo(ArrayBuffer.isView(c.value), "invalid ".concat(r.accessor));
      const a = !!c.size && c.size !== this.size;
      return i.binaryAccessor = Ek(c.value, {
        size: c.size || this.size,
        stride: c.stride,
        offset: c.offset,
        startIndices: t,
        nested: a
      }), !1;
    }
    return this.clearNeedsUpdate(), this.setData(e), !0;
  }
  getVertexOffset(e) {
    const {
      startIndices: t
    } = this;
    return (t ? e < t.length ? t[e] : this.numInstances : e) * this.size;
  }
  getShaderAttributes() {
    const e = this.settings.shaderAttributes || {
      [this.id]: null
    }, t = {};
    for (const i in e)
      Object.assign(t, super.getShaderAttributes(i, e[i]));
    return t;
  }
  _autoUpdater(e, t) {
    let {
      data: i,
      startRow: r,
      endRow: l,
      props: c,
      numInstances: a
    } = t;
    if (e.constant)
      return;
    const {
      settings: g,
      state: y,
      value: A,
      size: C,
      startIndices: I
    } = e, {
      accessor: S,
      transform: F
    } = g, U = y.binaryAccessor || (typeof S == "function" ? S : c[S]);
    wo(typeof U == "function", 'accessor "'.concat(S, '" is not a function'));
    let V = e.getVertexOffset(r);
    const {
      iterable: W,
      objectInfo: X
    } = JE(i, r, l);
    for (const de of W) {
      X.index++;
      let ie = U(de, X);
      if (F && (ie = F.call(this, ie)), I) {
        const fe = (X.index < I.length - 1 ? I[X.index + 1] : a) - I[X.index];
        if (ie && Array.isArray(ie[0])) {
          let Ae = V;
          for (const Te of ie)
            e._normalizeValue(Te, A, Ae), Ae += C;
        } else ie && ie.length > C ? A.set(ie, V) : (e._normalizeValue(ie, X.target, 0), iN({
          target: A,
          source: X.target,
          start: V,
          count: fe
        }));
        V += fe * C;
      } else
        e._normalizeValue(ie, A, V), V += C;
    }
  }
  _validateAttributeUpdaters() {
    const {
      settings: e
    } = this;
    if (!(e.noAlloc || typeof e.update == "function"))
      throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
  }
  _checkAttributeArray() {
    const {
      value: e
    } = this, t = Math.min(4, this.size);
    if (e && e.length >= t) {
      let i = !0;
      switch (t) {
        case 4:
          i = i && Number.isFinite(e[3]);
        case 3:
          i = i && Number.isFinite(e[2]);
        case 2:
          i = i && Number.isFinite(e[1]);
        case 1:
          i = i && Number.isFinite(e[0]);
          break;
        default:
          i = !1;
      }
      if (!i)
        throw new Error("Illegal attribute generated for ".concat(this.id));
    }
  }
}
class Mk {
  constructor(e) {
    let {
      gl: t,
      attribute: i,
      timeline: r
    } = e;
    H(this, "gl", void 0), H(this, "type", "interpolation"), H(this, "attributeInTransition", void 0), H(this, "settings", void 0), H(this, "attribute", void 0), H(this, "transition", void 0), H(this, "currentStartIndices", void 0), H(this, "currentLength", void 0), H(this, "transform", void 0), H(this, "buffers", void 0), this.gl = t, this.transition = new Xp(r), this.attribute = i, this.attributeInTransition = new Rb(t, i.settings), this.currentStartIndices = i.startIndices, this.currentLength = 0, this.transform = Rk(t, i);
    const l = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new dr(t, l), new dr(t, l)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, t) {
    if (e.duration <= 0) {
      this.transition.cancel();
      return;
    }
    this.settings = e;
    const {
      gl: i,
      buffers: r,
      attribute: l
    } = this;
    nS(r);
    const c = {
      numInstances: t,
      attribute: l,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: e.enter
    };
    for (const a of r)
      iS({
        buffer: a,
        ...c
      });
    this.currentStartIndices = l.startIndices, this.currentLength = Lb(l, t), this.attributeInTransition.setData({
      buffer: r[1],
      value: l.value
    }), this.transition.start(e), this.transform.update({
      elementCount: Math.floor(this.currentLength / l.size),
      sourceBuffers: {
        aFrom: r[0],
        aTo: eS(i, l)
      },
      feedbackBuffers: {
        vCurrent: r[1]
      }
    });
  }
  update() {
    const e = this.transition.update();
    if (e) {
      const {
        duration: t,
        easing: i
      } = this.settings, {
        time: r
      } = this.transition;
      let l = r / t;
      i && (l = i(l)), this.transform.run({
        uniforms: {
          time: l
        }
      });
    }
    return e;
  }
  cancel() {
    this.transition.cancel(), this.transform.delete();
    for (const e of this.buffers)
      e.delete();
    this.buffers.length = 0;
  }
}
const Lk = `
#define SHADER_NAME interpolation-transition-vertex-shader

uniform float time;
attribute ATTRIBUTE_TYPE aFrom;
attribute ATTRIBUTE_TYPE aTo;
varying ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, time);
  gl_Position = vec4(0.0);
}
`;
function Rk(n, e) {
  const t = tS(e.size);
  return new vb(n, {
    vs: Lk,
    defines: {
      ATTRIBUTE_TYPE: t
    },
    varyings: ["vCurrent"]
  });
}
class Bk {
  constructor(e) {
    let {
      gl: t,
      attribute: i,
      timeline: r
    } = e;
    H(this, "gl", void 0), H(this, "type", "spring"), H(this, "attributeInTransition", void 0), H(this, "settings", void 0), H(this, "attribute", void 0), H(this, "transition", void 0), H(this, "currentStartIndices", void 0), H(this, "currentLength", void 0), H(this, "texture", void 0), H(this, "framebuffer", void 0), H(this, "transform", void 0), H(this, "buffers", void 0), this.gl = t, this.type = "spring", this.transition = new Xp(r), this.attribute = i, this.attributeInTransition = new Rb(t, {
      ...i.settings,
      normalized: !1
    }), this.currentStartIndices = i.startIndices, this.currentLength = 0, this.texture = Dk(t), this.framebuffer = Fk(t, this.texture), this.transform = Ok(t, i, this.framebuffer);
    const l = {
      byteLength: 0,
      usage: 35050
    };
    this.buffers = [new dr(t, l), new dr(t, l), new dr(t, l)];
  }
  get inProgress() {
    return this.transition.inProgress;
  }
  start(e, t) {
    const {
      gl: i,
      buffers: r,
      attribute: l
    } = this, c = {
      numInstances: t,
      attribute: l,
      fromLength: this.currentLength,
      fromStartIndices: this.currentStartIndices,
      getData: e.enter
    };
    for (const a of r)
      iS({
        buffer: a,
        ...c
      });
    this.settings = e, this.currentStartIndices = l.startIndices, this.currentLength = Lb(l, t), this.attributeInTransition.setData({
      buffer: r[1],
      value: l.value
    }), this.transition.start({
      ...e,
      duration: 1 / 0
    }), this.transform.update({
      elementCount: Math.floor(this.currentLength / l.size),
      sourceBuffers: {
        aTo: eS(i, l)
      }
    });
  }
  update() {
    const {
      buffers: e,
      transform: t,
      framebuffer: i,
      transition: r
    } = this;
    if (!r.update())
      return !1;
    const c = this.settings;
    return t.update({
      sourceBuffers: {
        aPrev: e[0],
        aCur: e[1]
      },
      feedbackBuffers: {
        vNext: e[2]
      }
    }), t.run({
      framebuffer: i,
      discard: !1,
      clearRenderTarget: !0,
      uniforms: {
        stiffness: c.stiffness,
        damping: c.damping
      },
      parameters: {
        depthTest: !1,
        blend: !0,
        viewport: [0, 0, 1, 1],
        blendFunc: [1, 1],
        blendEquation: [32776, 32776]
      }
    }), nS(e), this.attributeInTransition.setData({
      buffer: e[1],
      value: this.attribute.value
    }), t_(i)[0] > 0 || r.end(), !0;
  }
  cancel() {
    this.transition.cancel(), this.transform.delete();
    for (const e of this.buffers)
      e.delete();
    this.buffers.length = 0, this.texture.delete(), this.framebuffer.delete();
  }
}
function Ok(n, e, t) {
  const i = tS(e.size);
  return new vb(n, {
    framebuffer: t,
    vs: `
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

uniform float stiffness;
uniform float damping;
attribute ATTRIBUTE_TYPE aPrev;
attribute ATTRIBUTE_TYPE aCur;
attribute ATTRIBUTE_TYPE aTo;
varying ATTRIBUTE_TYPE vNext;
varying float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE spring = delta * stiffness;
  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;
  return spring + damper + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`,
    fs: `
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

varying float vIsTransitioningFlag;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  gl_FragColor = vec4(1.0);
}`,
    defines: {
      ATTRIBUTE_TYPE: i
    },
    varyings: ["vNext"]
  });
}
function Dk(n) {
  return new rl(n, {
    data: new Uint8Array(4),
    format: 6408,
    type: 5121,
    border: 0,
    mipmaps: !1,
    dataFormat: 6408,
    width: 1,
    height: 1
  });
}
function Fk(n, e) {
  return new Vs(n, {
    id: "spring-transition-is-transitioning-framebuffer",
    width: 1,
    height: 1,
    attachments: {
      36064: e
    }
  });
}
const Nk = {
  interpolation: Mk,
  spring: Bk
};
class kk {
  constructor(e, t) {
    let {
      id: i,
      timeline: r
    } = t;
    H(this, "id", void 0), H(this, "isSupported", void 0), H(this, "gl", void 0), H(this, "timeline", void 0), H(this, "transitions", void 0), H(this, "needsRedraw", void 0), H(this, "numInstances", void 0), this.id = i, this.gl = e, this.timeline = r, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1, this.isSupported = vb.isSupported(e);
  }
  finalize() {
    for (const e in this.transitions)
      this._removeTransition(e);
  }
  update(e) {
    let {
      attributes: t,
      transitions: i,
      numInstances: r
    } = e;
    this.numInstances = r || 1;
    for (const l in t) {
      const c = t[l], a = c.getTransitionSetting(i);
      a && this._updateAttribute(l, c, a);
    }
    for (const l in this.transitions) {
      const c = t[l];
      (!c || !c.getTransitionSetting(i)) && this._removeTransition(l);
    }
  }
  hasAttribute(e) {
    const t = this.transitions[e];
    return t && t.inProgress;
  }
  getAttributes() {
    const e = {};
    for (const t in this.transitions) {
      const i = this.transitions[t];
      i.inProgress && (e[t] = i.attributeInTransition);
    }
    return e;
  }
  run() {
    if (!this.isSupported || this.numInstances === 0)
      return !1;
    for (const t in this.transitions)
      this.transitions[t].update() && (this.needsRedraw = !0);
    const e = this.needsRedraw;
    return this.needsRedraw = !1, e;
  }
  _removeTransition(e) {
    this.transitions[e].cancel(), delete this.transitions[e];
  }
  _updateAttribute(e, t, i) {
    const r = this.transitions[e];
    let l = !r || r.type !== i.type;
    if (l) {
      if (!this.isSupported) {
        zi.warn("WebGL2 not supported by this browser. Transition for ".concat(e, " is disabled."))();
        return;
      }
      r && this._removeTransition(e);
      const c = Nk[i.type];
      c ? this.transitions[e] = new c({
        attribute: t,
        timeline: this.timeline,
        gl: this.gl
      }) : (zi.error("unsupported transition type '".concat(i.type, "'"))(), l = !1);
    }
    (l || t.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(i, this.numInstances));
  }
}
const Ww = "attributeManager.invalidate", zk = "attributeManager.updateStart", Uk = "attributeManager.updateEnd", jk = "attribute.updateStart", Gk = "attribute.allocate", Vk = "attribute.updateEnd";
class qk {
  constructor(e) {
    let {
      id: t = "attribute-manager",
      stats: i,
      timeline: r
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    H(this, "id", void 0), H(this, "gl", void 0), H(this, "attributes", void 0), H(this, "updateTriggers", void 0), H(this, "needsRedraw", void 0), H(this, "userData", void 0), H(this, "stats", void 0), H(this, "attributeTransitionManager", void 0), H(this, "mergeBoundsMemoized", $p($F)), this.id = t, this.gl = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = i, this.attributeTransitionManager = new kk(e, {
      id: "".concat(t, "-transitions"),
      timeline: r
    }), Object.seal(this);
  }
  finalize() {
    for (const e in this.attributes)
      this.attributes[e].delete();
    this.attributeTransitionManager.finalize();
  }
  getNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    const t = this.needsRedraw;
    return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, t && this.id;
  }
  setNeedsRedraw() {
    this.needsRedraw = !0;
  }
  add(e) {
    this._add(e);
  }
  addInstanced(e) {
    this._add(e, {
      instanced: 1
    });
  }
  remove(e) {
    for (const t of e)
      this.attributes[t] !== void 0 && (this.attributes[t].delete(), delete this.attributes[t]);
  }
  invalidate(e, t) {
    const i = this._invalidateTrigger(e, t);
    Vo(Ww, this, e, i);
  }
  invalidateAll(e) {
    for (const t in this.attributes)
      this.attributes[t].setNeedsUpdate(t, e);
    Vo(Ww, this, "all");
  }
  update(e) {
    let {
      data: t,
      numInstances: i,
      startIndices: r = null,
      transitions: l,
      props: c = {},
      buffers: a = {},
      context: g = {}
    } = e, y = !1;
    Vo(zk, this), this.stats && this.stats.get("Update Attributes").timeStart();
    for (const A in this.attributes) {
      const C = this.attributes[A], I = C.settings.accessor;
      C.startIndices = r, C.numInstances = i, c[A] && zi.removed("props.".concat(A), "data.attributes.".concat(A))(), C.setExternalBuffer(a[A]) || C.setBinaryValue(typeof I == "string" ? a[I] : void 0, t.startIndices) || typeof I == "string" && !a[I] && C.setConstantValue(c[I]) || C.needsUpdate() && (y = !0, this._updateAttribute({
        attribute: C,
        numInstances: i,
        data: t,
        props: c,
        context: g
      })), this.needsRedraw = this.needsRedraw || C.needsRedraw();
    }
    y && Vo(Uk, this, i), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
      attributes: this.attributes,
      numInstances: i,
      transitions: l
    });
  }
  updateTransition() {
    const {
      attributeTransitionManager: e
    } = this, t = e.run();
    return this.needsRedraw = this.needsRedraw || t, t;
  }
  getAttributes() {
    return this.attributes;
  }
  getBounds(e) {
    const t = e.map((i) => {
      var r;
      return (r = this.attributes[i]) === null || r === void 0 ? void 0 : r.getBounds();
    });
    return this.mergeBoundsMemoized(t);
  }
  getChangedAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearChangedFlags: !1
    };
    const {
      attributes: t,
      attributeTransitionManager: i
    } = this, r = {
      ...i.getAttributes()
    };
    for (const l in t) {
      const c = t[l];
      c.needsRedraw(e) && !i.hasAttribute(l) && (r[l] = c);
    }
    return r;
  }
  getShaderAttributes(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    e || (e = this.getAttributes());
    const i = {};
    for (const r in e)
      t[r] || Object.assign(i, e[r].getShaderAttributes());
    return i;
  }
  _add(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (const i in e) {
      const r = e[i];
      this.attributes[i] = this._createAttribute(i, r, t);
    }
    this._mapUpdateTriggersToAttributes();
  }
  _createAttribute(e, t, i) {
    const r = {
      ...t,
      id: e,
      size: t.isIndexed && 1 || t.size || 1,
      divisor: i.instanced ? 1 : t.divisor || 0
    };
    return new Rb(this.gl, r);
  }
  _mapUpdateTriggersToAttributes() {
    const e = {};
    for (const t in this.attributes)
      this.attributes[t].getUpdateTriggers().forEach((r) => {
        e[r] || (e[r] = []), e[r].push(t);
      });
    this.updateTriggers = e;
  }
  _invalidateTrigger(e, t) {
    const {
      attributes: i,
      updateTriggers: r
    } = this, l = r[e];
    return l && l.forEach((c) => {
      const a = i[c];
      a && a.setNeedsUpdate(a.id, t);
    }), l;
  }
  _updateAttribute(e) {
    const {
      attribute: t,
      numInstances: i
    } = e;
    if (Vo(jk, t), t.constant) {
      t.setConstantValue(t.value);
      return;
    }
    t.allocate(i) && Vo(Gk, t, i), t.updateBuffer(e) && (this.needsRedraw = !0, Vo(Vk, t, i));
  }
}
class Hk extends Xp {
  get value() {
    return this._value;
  }
  _onUpdate() {
    const {
      time: e,
      settings: {
        fromValue: t,
        toValue: i,
        duration: r,
        easing: l
      }
    } = this, c = l(e / r);
    this._value = Rm(t, i, c);
  }
}
const Zw = 1e-5;
function $w(n, e, t, i, r) {
  const l = e - n, a = (t - e) * r, g = -l * i;
  return a + g + l + e;
}
function Wk(n, e, t, i, r) {
  if (Array.isArray(t)) {
    const l = [];
    for (let c = 0; c < t.length; c++)
      l[c] = $w(n[c], e[c], t[c], i, r);
    return l;
  }
  return $w(n, e, t, i, r);
}
function Xw(n, e) {
  if (Array.isArray(n)) {
    let t = 0;
    for (let i = 0; i < n.length; i++) {
      const r = n[i] - e[i];
      t += r * r;
    }
    return Math.sqrt(t);
  }
  return Math.abs(n - e);
}
class Zk extends Xp {
  get value() {
    return this._currValue;
  }
  _onUpdate() {
    const {
      fromValue: e,
      toValue: t,
      damping: i,
      stiffness: r
    } = this.settings, {
      _prevValue: l = e,
      _currValue: c = e
    } = this;
    let a = Wk(l, c, t, i, r);
    const g = Xw(a, t), y = Xw(a, c);
    g < Zw && y < Zw && (a = t, this.end()), this._prevValue = c, this._currValue = a;
  }
}
const $k = {
  interpolation: Hk,
  spring: Zk
};
class Xk {
  constructor(e) {
    this.transitions = /* @__PURE__ */ new Map(), this.timeline = e;
  }
  get active() {
    return this.transitions.size > 0;
  }
  add(e, t, i, r) {
    const {
      transitions: l
    } = this;
    if (l.has(e)) {
      const g = l.get(e), {
        value: y = g.settings.fromValue
      } = g;
      t = y, this.remove(e);
    }
    if (r = QE(r), !r)
      return;
    const c = $k[r.type];
    if (!c) {
      zi.error("unsupported transition type '".concat(r.type, "'"))();
      return;
    }
    const a = new c(this.timeline);
    a.start({
      ...r,
      fromValue: t,
      toValue: i
    }), l.set(e, a);
  }
  remove(e) {
    const {
      transitions: t
    } = this;
    t.has(e) && (t.get(e).cancel(), t.delete(e));
  }
  update() {
    const e = {};
    for (const [t, i] of this.transitions)
      i.update(), e[t] = i.value, i.inProgress || this.remove(t);
    return e;
  }
  clear() {
    for (const e of this.transitions.keys())
      this.remove(e);
  }
}
function Yk(n) {
  const e = n[fh];
  for (const t in e) {
    const i = e[t], {
      validate: r
    } = i;
    if (r && !r(n[t], i))
      throw new Error("Invalid prop ".concat(t, ": ").concat(n[t]));
  }
}
function Jk(n, e) {
  const t = rS({
    newProps: n,
    oldProps: e,
    propTypes: n[fh],
    ignoreProps: {
      data: null,
      updateTriggers: null,
      extensions: null,
      transitions: null
    }
  }), i = Qk(n, e);
  let r = !1;
  return i || (r = e8(n, e)), {
    dataChanged: i,
    propsChanged: t,
    updateTriggersChanged: r,
    extensionsChanged: t8(n, e),
    transitionsChanged: Kk(n, e)
  };
}
function Kk(n, e) {
  if (!n.transitions)
    return !1;
  const t = {}, i = n[fh];
  let r = !1;
  for (const l in n.transitions) {
    const c = i[l], a = c && c.type;
    (a === "number" || a === "color" || a === "array") && s1(n[l], e[l], c) && (t[l] = !0, r = !0);
  }
  return r ? t : !1;
}
function rS(n) {
  let {
    newProps: e,
    oldProps: t,
    ignoreProps: i = {},
    propTypes: r = {},
    triggerName: l = "props"
  } = n;
  if (t === e)
    return !1;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return "".concat(l, " changed shallowly");
  for (const c of Object.keys(e))
    if (!(c in i)) {
      if (!(c in t))
        return "".concat(l, ".").concat(c, " added");
      const a = s1(e[c], t[c], r[c]);
      if (a)
        return "".concat(l, ".").concat(c, " ").concat(a);
    }
  for (const c of Object.keys(t))
    if (!(c in i)) {
      if (!(c in e))
        return "".concat(l, ".").concat(c, " dropped");
      if (!Object.hasOwnProperty.call(e, c)) {
        const a = s1(e[c], t[c], r[c]);
        if (a)
          return "".concat(l, ".").concat(c, " ").concat(a);
      }
    }
  return !1;
}
function s1(n, e, t) {
  let i = t && t.equal;
  return i && !i(n, e, t) || !i && (i = n && e && n.equals, i && !i.call(n, e)) ? "changed deeply" : !i && e !== n ? "changed shallowly" : null;
}
function Qk(n, e) {
  if (e === null)
    return "oldProps is null, initial diff";
  let t = !1;
  const {
    dataComparator: i,
    _dataDiff: r
  } = n;
  return i ? i(n.data, e.data) || (t = "Data comparator detected a change") : n.data !== e.data && (t = "A new data container was supplied"), t && r && (t = r(n.data, e.data) || t), t;
}
function e8(n, e) {
  if (e === null)
    return {
      all: !0
    };
  if ("all" in n.updateTriggers && Yw(n, e, "all"))
    return {
      all: !0
    };
  const t = {};
  let i = !1;
  for (const r in n.updateTriggers)
    r !== "all" && Yw(n, e, r) && (t[r] = !0, i = !0);
  return i ? t : !1;
}
function t8(n, e) {
  if (e === null)
    return !0;
  const t = e.extensions, {
    extensions: i
  } = n;
  if (i === t)
    return !1;
  if (!t || !i || i.length !== t.length)
    return !0;
  for (let r = 0; r < i.length; r++)
    if (!i[r].equals(t[r]))
      return !0;
  return !1;
}
function Yw(n, e, t) {
  let i = n.updateTriggers[t];
  i = i ?? {};
  let r = e.updateTriggers[t];
  return r = r ?? {}, rS({
    oldProps: r,
    newProps: i,
    triggerName: t
  });
}
const n8 = "count(): argument not an object", i8 = "count(): argument not a container";
function r8(n) {
  if (!o8(n))
    throw new Error(n8);
  if (typeof n.count == "function")
    return n.count();
  if (Number.isFinite(n.size))
    return n.size;
  if (Number.isFinite(n.length))
    return n.length;
  if (s8(n))
    return Object.keys(n).length;
  throw new Error(i8);
}
function s8(n) {
  return n !== null && typeof n == "object" && n.constructor === Object;
}
function o8(n) {
  return n !== null && typeof n == "object";
}
function a8(n, e) {
  if (!e)
    return n;
  const t = {
    ...n,
    ...e
  };
  if ("defines" in e && (t.defines = {
    ...n.defines,
    ...e.defines
  }), "modules" in e && (t.modules = (n.modules || []).concat(e.modules), e.modules.some((i) => i.name === "project64"))) {
    const i = t.modules.findIndex((r) => r.name === "project32");
    i >= 0 && t.modules.splice(i, 1);
  }
  if ("inject" in e)
    if (!n.inject)
      t.inject = e.inject;
    else {
      const i = {
        ...n.inject
      };
      for (const r in e.inject)
        i[r] = (i[r] || "") + e.inject[r];
      t.inject = i;
    }
  return t;
}
const l8 = {
  10241: 9987,
  10240: 9729,
  10242: 33071,
  10243: 33071
}, o1 = {};
function c8(n, e, t, i) {
  if (t instanceof rl)
    return t;
  t.constructor && t.constructor.name !== "Object" && (t = {
    data: t
  });
  let r = null;
  t.compressed && (r = {
    10241: t.data.length > 1 ? 9985 : 9729
  });
  const l = new rl(e, {
    ...t,
    parameters: {
      ...l8,
      ...r,
      ...i
    }
  });
  return o1[l.id] = n, l;
}
function u8(n, e) {
  !e || !(e instanceof rl) || o1[e.id] === n && (e.delete(), delete o1[e.id]);
}
const h8 = {
  boolean: {
    validate(n, e) {
      return !0;
    },
    equal(n, e, t) {
      return !!n == !!e;
    }
  },
  number: {
    validate(n, e) {
      return Number.isFinite(n) && (!("max" in e) || n <= e.max) && (!("min" in e) || n >= e.min);
    }
  },
  color: {
    validate(n, e) {
      return e.optional && !n || a1(n) && (n.length === 3 || n.length === 4);
    },
    equal(n, e, t) {
      return Kc(n, e, 1);
    }
  },
  accessor: {
    validate(n, e) {
      const t = km(n);
      return t === "function" || t === km(e.value);
    },
    equal(n, e, t) {
      return typeof e == "function" ? !0 : Kc(n, e, 1);
    }
  },
  array: {
    validate(n, e) {
      return e.optional && !n || a1(n);
    },
    equal(n, e, t) {
      const {
        compare: i
      } = t, r = Number.isInteger(i) ? i : i ? 1 : 0;
      return i ? Kc(n, e, r) : n === e;
    }
  },
  object: {
    equal(n, e, t) {
      if (t.ignore)
        return !0;
      const {
        compare: i
      } = t, r = Number.isInteger(i) ? i : i ? 1 : 0;
      return i ? Kc(n, e, r) : n === e;
    }
  },
  function: {
    validate(n, e) {
      return e.optional && !n || typeof n == "function";
    },
    equal(n, e, t) {
      return !t.compare && t.ignore !== !1 || n === e;
    }
  },
  data: {
    transform: (n, e, t) => {
      const {
        dataTransform: i
      } = t.props;
      return i && n ? i(n) : n;
    }
  },
  image: {
    transform: (n, e, t) => {
      const i = t.context;
      return !i || !i.gl ? null : c8(t.id, i.gl, n, {
        ...e.parameters,
        ...t.props.textureParameters
      });
    },
    release: (n, e, t) => {
      u8(t.id, n);
    }
  }
};
function d8(n) {
  const e = {}, t = {}, i = {};
  for (const [r, l] of Object.entries(n)) {
    const c = l == null ? void 0 : l.deprecatedFor;
    if (c)
      i[r] = Array.isArray(c) ? c : [c];
    else {
      const a = f8(r, l);
      e[r] = a, t[r] = a.value;
    }
  }
  return {
    propTypes: e,
    defaultProps: t,
    deprecatedProps: i
  };
}
function f8(n, e) {
  switch (km(e)) {
    case "object":
      return Qf(n, e);
    case "array":
      return Qf(n, {
        type: "array",
        value: e,
        compare: !1
      });
    case "boolean":
      return Qf(n, {
        type: "boolean",
        value: e
      });
    case "number":
      return Qf(n, {
        type: "number",
        value: e
      });
    case "function":
      return Qf(n, {
        type: "function",
        value: e,
        compare: !0
      });
    default:
      return {
        name: n,
        type: "unknown",
        value: e
      };
  }
}
function Qf(n, e) {
  return "type" in e ? {
    name: n,
    ...h8[e.type],
    ...e
  } : "value" in e ? {
    name: n,
    type: km(e.value),
    ...e
  } : {
    name: n,
    type: "object",
    value: e
  };
}
function a1(n) {
  return Array.isArray(n) || ArrayBuffer.isView(n);
}
function km(n) {
  return a1(n) ? "array" : n === null ? "null" : typeof n;
}
function p8(n, e) {
  let t;
  for (let l = e.length - 1; l >= 0; l--) {
    const c = e[l];
    "extensions" in c && (t = c.extensions);
  }
  const i = l1(n.constructor, t), r = Object.create(i);
  r[Nm] = n, r[Qh] = {}, r[uh] = {};
  for (let l = 0; l < e.length; ++l) {
    const c = e[l];
    for (const a in c)
      r[a] = c[a];
  }
  return Object.freeze(r), r;
}
const g8 = "_mergedDefaultProps";
function l1(n, e) {
  let t = g8;
  if (e)
    for (const r of e) {
      const l = r.constructor;
      l && (t += ":".concat(l.extensionName || l.name));
    }
  const i = sS(n, t);
  return i || (n[t] = m8(n, e || []));
}
function m8(n, e) {
  if (!n.prototype)
    return null;
  const i = Object.getPrototypeOf(n), r = l1(i), l = sS(n, "defaultProps") || {}, c = d8(l), a = Object.assign(/* @__PURE__ */ Object.create(null), r, c.defaultProps), g = Object.assign(/* @__PURE__ */ Object.create(null), r == null ? void 0 : r[fh], c.propTypes), y = Object.assign(/* @__PURE__ */ Object.create(null), r == null ? void 0 : r[k0], c.deprecatedProps);
  for (const A of e) {
    const C = l1(A.constructor);
    C && (Object.assign(a, C), Object.assign(g, C[fh]), Object.assign(y, C[k0]));
  }
  return _8(a, n), b8(a, g), y8(a, y), a[fh] = g, a[k0] = y, e.length === 0 && !Bb(n, "_propTypes") && (n._propTypes = g), a;
}
function _8(n, e) {
  const t = x8(e);
  Object.defineProperties(n, {
    id: {
      writable: !0,
      value: t
    }
  });
}
function y8(n, e) {
  for (const t in e)
    Object.defineProperty(n, t, {
      enumerable: !1,
      set(i) {
        const r = "".concat(this.id, ": ").concat(t);
        for (const l of e[t])
          Bb(this, l) || (this[l] = i);
        zi.deprecated(r, e[t].join("/"))();
      }
    });
}
function b8(n, e) {
  const t = {}, i = {};
  for (const r in e) {
    const l = e[r], {
      name: c,
      value: a
    } = l;
    l.async && (t[c] = a, i[c] = v8(c));
  }
  n[Xd] = t, n[Qh] = {}, Object.defineProperties(n, i);
}
function v8(n) {
  return {
    enumerable: !0,
    set(e) {
      typeof e == "string" || e instanceof Promise || KE(e) ? this[Qh][n] = e : this[uh][n] = e;
    },
    get() {
      if (this[uh]) {
        if (n in this[uh])
          return this[uh][n] || this[Xd][n];
        if (n in this[Qh]) {
          const e = this[Nm] && this[Nm].internalState;
          if (e && e.hasAsyncProp(n))
            return e.getAsyncProp(n) || this[Xd][n];
        }
      }
      return this[Xd][n];
    }
  };
}
function Bb(n, e) {
  return Object.prototype.hasOwnProperty.call(n, e);
}
function sS(n, e) {
  return Bb(n, e) && n[e];
}
function x8(n) {
  const e = n.componentName;
  return e || zi.warn("".concat(n.name, ".componentName not specified"))(), e || n.name;
}
let w8 = 0;
class Ob {
  constructor() {
    H(this, "id", void 0), H(this, "props", void 0), H(this, "count", void 0);
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    this.props = p8(this, t), this.id = this.props.id, this.count = w8++;
  }
  clone(e) {
    const {
      props: t
    } = this, i = {};
    for (const r in t[Xd])
      r in t[uh] ? i[r] = t[uh][r] : r in t[Qh] && (i[r] = t[Qh][r]);
    return new this.constructor({
      ...t,
      ...i,
      ...e
    });
  }
}
H(Ob, "componentName", "Component");
H(Ob, "defaultProps", {});
const A8 = Object.freeze({});
class T8 {
  constructor(e) {
    H(this, "component", void 0), H(this, "onAsyncPropUpdated", void 0), H(this, "asyncProps", void 0), H(this, "oldProps", void 0), H(this, "oldAsyncProps", void 0), this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
    }, this.oldProps = null, this.oldAsyncProps = null;
  }
  finalize() {
    for (const e in this.asyncProps) {
      const t = this.asyncProps[e];
      t && t.type && t.type.release && t.type.release(t.resolvedValue, t.type, this.component);
    }
    this.asyncProps = {}, this.component = null, this.resetOldProps();
  }
  getOldProps() {
    return this.oldAsyncProps || this.oldProps || A8;
  }
  resetOldProps() {
    this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
  }
  hasAsyncProp(e) {
    return e in this.asyncProps;
  }
  getAsyncProp(e) {
    const t = this.asyncProps[e];
    return t && t.resolvedValue;
  }
  isAsyncPropLoading(e) {
    if (e) {
      const t = this.asyncProps[e];
      return !!(t && t.pendingLoadCount > 0 && t.pendingLoadCount !== t.resolvedLoadCount);
    }
    for (const t in this.asyncProps)
      if (this.isAsyncPropLoading(t))
        return !0;
    return !1;
  }
  reloadAsyncProp(e, t) {
    this._watchPromise(e, Promise.resolve(t));
  }
  setAsyncProps(e) {
    this.component = e[Nm] || this.component;
    const t = e[uh] || {}, i = e[Qh] || e, r = e[Xd] || {};
    for (const l in t) {
      const c = t[l];
      this._createAsyncPropData(l, r[l]), this._updateAsyncProp(l, c), t[l] = this.getAsyncProp(l);
    }
    for (const l in i) {
      const c = i[l];
      this._createAsyncPropData(l, r[l]), this._updateAsyncProp(l, c);
    }
  }
  _fetch(e, t) {
    return null;
  }
  _onResolve(e, t) {
  }
  _onError(e, t) {
  }
  _updateAsyncProp(e, t) {
    if (this._didAsyncInputValueChange(e, t)) {
      if (typeof t == "string" && (t = this._fetch(e, t)), t instanceof Promise) {
        this._watchPromise(e, t);
        return;
      }
      if (KE(t)) {
        this._resolveAsyncIterable(e, t);
        return;
      }
      this._setPropValue(e, t);
    }
  }
  _freezeAsyncOldProps() {
    if (!this.oldAsyncProps && this.oldProps) {
      this.oldAsyncProps = Object.create(this.oldProps);
      for (const e in this.asyncProps)
        Object.defineProperty(this.oldAsyncProps, e, {
          enumerable: !0,
          value: this.oldProps[e]
        });
    }
  }
  _didAsyncInputValueChange(e, t) {
    const i = this.asyncProps[e];
    return t === i.resolvedValue || t === i.lastValue ? !1 : (i.lastValue = t, !0);
  }
  _setPropValue(e, t) {
    this._freezeAsyncOldProps();
    const i = this.asyncProps[e];
    i && (t = this._postProcessValue(i, t), i.resolvedValue = t, i.pendingLoadCount++, i.resolvedLoadCount = i.pendingLoadCount);
  }
  _setAsyncPropValue(e, t, i) {
    const r = this.asyncProps[e];
    r && i >= r.resolvedLoadCount && t !== void 0 && (this._freezeAsyncOldProps(), r.resolvedValue = t, r.resolvedLoadCount = i, this.onAsyncPropUpdated(e, t));
  }
  _watchPromise(e, t) {
    const i = this.asyncProps[e];
    if (i) {
      i.pendingLoadCount++;
      const r = i.pendingLoadCount;
      t.then((l) => {
        this.component && (l = this._postProcessValue(i, l), this._setAsyncPropValue(e, l, r), this._onResolve(e, l));
      }).catch((l) => {
        this._onError(e, l);
      });
    }
  }
  async _resolveAsyncIterable(e, t) {
    if (e !== "data") {
      this._setPropValue(e, t);
      return;
    }
    const i = this.asyncProps[e];
    if (!i)
      return;
    i.pendingLoadCount++;
    const r = i.pendingLoadCount;
    let l = [], c = 0;
    for await (const a of t) {
      if (!this.component)
        return;
      const {
        dataTransform: g
      } = this.component.props;
      g ? l = g(a, l) : l = l.concat(a), Object.defineProperty(l, "__diff", {
        enumerable: !1,
        value: [{
          startRow: c,
          endRow: l.length
        }]
      }), c = l.length, this._setAsyncPropValue(e, l, r);
    }
    this._onResolve(e, l);
  }
  _postProcessValue(e, t) {
    const i = e.type;
    return i && this.component && (i.release && i.release(e.resolvedValue, i, this.component), i.transform) ? i.transform(t, i, this.component) : t;
  }
  _createAsyncPropData(e, t) {
    if (!this.asyncProps[e]) {
      const r = this.component && this.component.props[fh];
      this.asyncProps[e] = {
        type: r && r[e],
        lastValue: null,
        resolvedValue: t,
        pendingLoadCount: 0,
        resolvedLoadCount: 0
      };
    }
  }
}
class E8 extends T8 {
  constructor(e) {
    let {
      attributeManager: t,
      layer: i
    } = e;
    super(i), H(this, "attributeManager", void 0), H(this, "needsRedraw", void 0), H(this, "needsUpdate", void 0), H(this, "subLayers", void 0), H(this, "usesPickingColorCache", void 0), H(this, "hasPickingBuffer", void 0), H(this, "changeFlags", void 0), H(this, "viewport", void 0), H(this, "uniformTransitions", void 0), H(this, "propsInTransition", void 0), this.attributeManager = t, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
  }
  get layer() {
    return this.component;
  }
  _fetch(e, t) {
    const i = this.layer, r = i == null ? void 0 : i.props.fetch;
    return r ? r(t, {
      propName: e,
      layer: i
    }) : super._fetch(e, t);
  }
  _onResolve(e, t) {
    const i = this.layer;
    if (i) {
      const r = i.props.onDataLoad;
      e === "data" && r && r(t, {
        propName: e,
        layer: i
      });
    }
  }
  _onError(e, t) {
    const i = this.layer;
    i && i.raiseError(t, "loading ".concat(e, " of ").concat(this.layer));
  }
}
const S8 = "layer.changeFlag", C8 = "layer.initialize", P8 = "layer.update", I8 = "layer.finalize", M8 = "layer.matched", Jw = 2 ** 24 - 1, L8 = Object.freeze([]), R8 = $p((n) => {
  let {
    oldViewport: e,
    viewport: t
  } = n;
  return e.equals(t);
});
let Hc = new Uint8ClampedArray(0);
const B8 = {
  data: {
    type: "data",
    value: L8,
    async: !0
  },
  dataComparator: {
    type: "function",
    value: null,
    optional: !0
  },
  _dataDiff: {
    type: "function",
    value: (n) => n && n.__diff,
    optional: !0
  },
  dataTransform: {
    type: "function",
    value: null,
    optional: !0
  },
  onDataLoad: {
    type: "function",
    value: null,
    optional: !0
  },
  onError: {
    type: "function",
    value: null,
    optional: !0
  },
  fetch: {
    type: "function",
    value: (n, e) => {
      let {
        propName: t,
        layer: i,
        loaders: r,
        loadOptions: l,
        signal: c
      } = e;
      const {
        resourceManager: a
      } = i.context;
      if (l = l || i.getLoadOptions(), r = r || i.props.loaders, c) {
        var g;
        l = {
          ...l,
          fetch: {
            ...(g = l) === null || g === void 0 ? void 0 : g.fetch,
            signal: c
          }
        };
      }
      let y = a.contains(n);
      return !y && !l && (a.add({
        resourceId: n,
        data: gh(n, r),
        persistent: !1
      }), y = !0), y ? a.subscribe({
        resourceId: n,
        onChange: (A) => {
          var C;
          return (C = i.internalState) === null || C === void 0 ? void 0 : C.reloadAsyncProp(t, A);
        },
        consumerId: i.id,
        requestId: t
      }) : gh(n, r, l);
    }
  },
  updateTriggers: {},
  visible: !0,
  pickable: !1,
  opacity: {
    type: "number",
    min: 0,
    max: 1,
    value: 1
  },
  operation: "draw",
  onHover: {
    type: "function",
    value: null,
    optional: !0
  },
  onClick: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragStart: {
    type: "function",
    value: null,
    optional: !0
  },
  onDrag: {
    type: "function",
    value: null,
    optional: !0
  },
  onDragEnd: {
    type: "function",
    value: null,
    optional: !0
  },
  coordinateSystem: Bi.DEFAULT,
  coordinateOrigin: {
    type: "array",
    value: [0, 0, 0],
    compare: !0
  },
  modelMatrix: {
    type: "array",
    value: null,
    compare: !0,
    optional: !0
  },
  wrapLongitude: !1,
  positionFormat: "XYZ",
  colorFormat: "RGBA",
  parameters: {
    type: "object",
    value: {},
    optional: !0,
    compare: 2
  },
  loadOptions: {
    type: "object",
    value: null,
    optional: !0,
    ignore: !0
  },
  transitions: null,
  extensions: [],
  loaders: {
    type: "array",
    value: [],
    optional: !0,
    ignore: !0
  },
  getPolygonOffset: {
    type: "function",
    value: (n) => {
      let {
        layerIndex: e
      } = n;
      return [0, -e * 100];
    }
  },
  highlightedObjectIndex: null,
  autoHighlight: !1,
  highlightColor: {
    type: "accessor",
    value: [0, 0, 128, 128]
  }
};
class _f extends Ob {
  constructor() {
    super(...arguments), H(this, "internalState", null), H(this, "lifecycle", kd.NO_STATE), H(this, "context", void 0), H(this, "state", void 0), H(this, "parent", null);
  }
  static get componentName() {
    return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
  }
  get root() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  toString() {
    const e = this.constructor.layerName || this.constructor.name;
    return "".concat(e, "({id: '").concat(this.props.id, "'})");
  }
  project(e) {
    wo(this.internalState);
    const t = this.internalState.viewport || this.context.viewport, i = UE(e, {
      viewport: t,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem
    }), [r, l, c] = zE(i, t.pixelProjectionMatrix);
    return e.length === 2 ? [r, l] : [r, l, c];
  }
  unproject(e) {
    return wo(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
  }
  projectPosition(e, t) {
    wo(this.internalState);
    const i = this.internalState.viewport || this.context.viewport;
    return eN(e, {
      viewport: i,
      modelMatrix: this.props.modelMatrix,
      coordinateOrigin: this.props.coordinateOrigin,
      coordinateSystem: this.props.coordinateSystem,
      ...t
    });
  }
  get isComposite() {
    return !1;
  }
  setState(e) {
    this.setChangeFlags({
      stateChanged: !0
    }), Object.assign(this.state, e), this.setNeedsRedraw();
  }
  setNeedsRedraw() {
    this.internalState && (this.internalState.needsRedraw = !0);
  }
  setNeedsUpdate() {
    this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
  }
  get isLoaded() {
    return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
  }
  get wrapLongitude() {
    return this.props.wrapLongitude;
  }
  isPickable() {
    return this.props.pickable && this.props.visible;
  }
  getModels() {
    return this.state && (this.state.models || this.state.model && [this.state.model]) || [];
  }
  setModuleParameters(e) {
    for (const t of this.getModels())
      t.updateModuleSettings(e);
  }
  getAttributeManager() {
    return this.internalState && this.internalState.attributeManager;
  }
  getCurrentLayer() {
    return this.internalState && this.internalState.layer;
  }
  getLoadOptions() {
    return this.props.loadOptions;
  }
  use64bitPositions() {
    const {
      coordinateSystem: e
    } = this.props;
    return e === Bi.DEFAULT || e === Bi.LNGLAT || e === Bi.CARTESIAN;
  }
  onHover(e, t) {
    return this.props.onHover && this.props.onHover(e, t) || !1;
  }
  onClick(e, t) {
    return this.props.onClick && this.props.onClick(e, t) || !1;
  }
  nullPickingColor() {
    return [0, 0, 0];
  }
  encodePickingColor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return t[0] = e + 1 & 255, t[1] = e + 1 >> 8 & 255, t[2] = e + 1 >> 8 >> 8 & 255, t;
  }
  decodePickingColor(e) {
    wo(e instanceof Uint8Array);
    const [t, i, r] = e;
    return t + i * 256 + r * 65536 - 1;
  }
  getNumInstances() {
    return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : r8(this.props.data);
  }
  getStartIndices() {
    return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
  }
  getBounds() {
    var e;
    return (e = this.getAttributeManager()) === null || e === void 0 ? void 0 : e.getBounds(["positions", "instancePositions"]);
  }
  getShaders(e) {
    for (const t of this.props.extensions)
      e = a8(e, t.getShaders.call(this, t));
    return e;
  }
  shouldUpdateState(e) {
    return e.changeFlags.propsOrDataChanged;
  }
  updateState(e) {
    const t = this.getAttributeManager(), {
      dataChanged: i
    } = e.changeFlags;
    if (i && t)
      if (Array.isArray(i))
        for (const r of i)
          t.invalidateAll(r);
      else
        t.invalidateAll();
    if (t) {
      const {
        props: r
      } = e, l = this.internalState.hasPickingBuffer, c = Number.isInteger(r.highlightedObjectIndex) || r.pickable || r.extensions.some((a) => a.getNeedsPickingBuffer.call(this, a));
      if (l !== c) {
        this.internalState.hasPickingBuffer = c;
        const {
          pickingColors: a,
          instancePickingColors: g
        } = t.attributes, y = a || g;
        y && (c && y.constant && (y.constant = !1, t.invalidate(y.id)), !y.value && !c && (y.constant = !0, y.value = [0, 0, 0]));
      }
    }
  }
  finalizeState(e) {
    for (const i of this.getModels())
      i.delete();
    const t = this.getAttributeManager();
    t && t.finalize(), this.context && this.context.resourceManager.unsubscribe({
      consumerId: this.id
    }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
  }
  draw(e) {
    for (const t of this.getModels())
      t.draw(e);
  }
  getPickingInfo(e) {
    let {
      info: t,
      mode: i,
      sourceLayer: r
    } = e;
    const {
      index: l
    } = t;
    return l >= 0 && Array.isArray(this.props.data) && (t.object = this.props.data[l]), t;
  }
  raiseError(e, t) {
    var i, r;
    if (t && (e = new Error("".concat(t, ": ").concat(e.message), {
      cause: e
    })), !((i = (r = this.props).onError) !== null && i !== void 0 && i.call(r, e))) {
      var l, c;
      (l = this.context) === null || l === void 0 || (c = l.onError) === null || c === void 0 || c.call(l, e, this);
    }
  }
  getNeedsRedraw() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
      clearRedrawFlags: !1
    };
    return this._getNeedsRedraw(e);
  }
  needsUpdate() {
    return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
  }
  hasUniformTransition() {
    var e;
    return ((e = this.internalState) === null || e === void 0 ? void 0 : e.uniformTransitions.active) || !1;
  }
  activateViewport(e) {
    if (!this.internalState)
      return;
    const t = this.internalState.viewport;
    this.internalState.viewport = e, (!t || !R8({
      oldViewport: t,
      viewport: e
    })) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
  }
  invalidateAttribute() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "all";
    const t = this.getAttributeManager();
    t && (e === "all" ? t.invalidateAll() : t.invalidate(e));
  }
  updateAttributes(e) {
    for (const t of this.getModels())
      this._setModelAttributes(t, e);
  }
  _updateAttributes() {
    const e = this.getAttributeManager();
    if (!e)
      return;
    const t = this.props, i = this.getNumInstances(), r = this.getStartIndices();
    e.update({
      data: t.data,
      numInstances: i,
      startIndices: r,
      props: t,
      transitions: t.transitions,
      buffers: t.data.attributes,
      context: this
    });
    const l = e.getChangedAttributes({
      clearChangedFlags: !0
    });
    this.updateAttributes(l);
  }
  _updateAttributeTransition() {
    const e = this.getAttributeManager();
    e && e.updateTransition();
  }
  _updateUniformTransition() {
    const {
      uniformTransitions: e
    } = this.internalState;
    if (e.active) {
      const t = e.update(), i = Object.create(this.props);
      for (const r in t)
        Object.defineProperty(i, r, {
          value: t[r]
        });
      return i;
    }
    return this.props;
  }
  calculateInstancePickingColors(e, t) {
    let {
      numInstances: i
    } = t;
    if (e.constant)
      return;
    const r = Math.floor(Hc.length / 3);
    if (this.internalState.usesPickingColorCache = !0, r < i) {
      i > Jw && zi.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), Hc = Rp.allocate(Hc, i, {
        size: 3,
        copy: !0,
        maxCount: Math.max(i, Jw)
      });
      const l = Math.floor(Hc.length / 3), c = [];
      for (let a = r; a < l; a++)
        this.encodePickingColor(a, c), Hc[a * 3 + 0] = c[0], Hc[a * 3 + 1] = c[1], Hc[a * 3 + 2] = c[2];
    }
    e.value = Hc.subarray(0, i * 3);
  }
  _setModelAttributes(e, t) {
    const i = this.getAttributeManager(), r = e.userData.excludeAttributes || {}, l = i.getShaderAttributes(t, r);
    e.setAttributes(l);
  }
  disablePickingIndex(e) {
    const t = this.props.data;
    if (!("attributes" in t)) {
      this._disablePickingIndex(e);
      return;
    }
    const {
      pickingColors: i,
      instancePickingColors: r
    } = this.getAttributeManager().attributes, l = i || r, c = l && t.attributes && t.attributes[l.id];
    if (c && c.value) {
      const a = c.value, g = this.encodePickingColor(e);
      for (let y = 0; y < t.length; y++) {
        const A = l.getVertexOffset(y);
        a[A] === g[0] && a[A + 1] === g[1] && a[A + 2] === g[2] && this._disablePickingIndex(y);
      }
    } else
      this._disablePickingIndex(e);
  }
  _disablePickingIndex(e) {
    const {
      pickingColors: t,
      instancePickingColors: i
    } = this.getAttributeManager().attributes, r = t || i;
    if (!r)
      return;
    const l = r.getVertexOffset(e), c = r.getVertexOffset(e + 1);
    r.buffer.subData({
      data: new Uint8Array(c - l),
      offset: l
    });
  }
  restorePickingColors() {
    const {
      pickingColors: e,
      instancePickingColors: t
    } = this.getAttributeManager().attributes, i = e || t;
    i && (this.internalState.usesPickingColorCache && i.value.buffer !== Hc.buffer && (i.value = Hc.subarray(0, i.value.length)), i.updateSubBuffer({
      startOffset: 0
    }));
  }
  _initialize() {
    wo(!this.internalState), wo(Number.isFinite(this.props.coordinateSystem)), Vo(C8, this);
    const e = this._getAttributeManager();
    e && e.addInstanced({
      instancePickingColors: {
        type: 5121,
        size: 3,
        noAlloc: !0,
        update: this.calculateInstancePickingColors
      }
    }), this.internalState = new E8({
      attributeManager: e,
      layer: this
    }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
      get: () => (zi.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
    }), this.internalState.uniformTransitions = new Xk(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
    for (const t of this.props.extensions)
      t.initializeState.call(this, this.context, t);
    this.setChangeFlags({
      dataChanged: "init",
      propsChanged: "init",
      viewportChanged: !0,
      extensionsChanged: !0
    }), this._update();
  }
  _transferState(e) {
    Vo(M8, this, this === e);
    const {
      state: t,
      internalState: i
    } = e;
    this !== e && (this.internalState = i, this.state = t, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
  }
  _update() {
    const e = this.needsUpdate();
    if (Vo(P8, this, e), !e)
      return;
    const t = this.props, i = this.context, r = this.internalState, l = i.viewport, c = this._updateUniformTransition();
    r.propsInTransition = c, i.viewport = r.viewport || l, this.props = c;
    try {
      const a = this._getUpdateParams(), g = this.getModels();
      if (i.gl)
        this.updateState(a);
      else
        try {
          this.updateState(a);
        } catch {
        }
      for (const A of this.props.extensions)
        A.updateState.call(this, a, A);
      const y = this.getModels()[0] !== g[0];
      this._postUpdate(a, y);
    } finally {
      i.viewport = l, this.props = t, this._clearChangeFlags(), r.needsUpdate = !1, r.resetOldProps();
    }
  }
  _finalize() {
    Vo(I8, this), this.finalizeState(this.context);
    for (const e of this.props.extensions)
      e.finalizeState.call(this, this.context, e);
  }
  _drawLayer(e) {
    let {
      moduleParameters: t = null,
      uniforms: i = {},
      parameters: r = {}
    } = e;
    this._updateAttributeTransition();
    const l = this.props, c = this.context;
    this.props = this.internalState.propsInTransition || l;
    const a = this.props.opacity;
    i.opacity = Math.pow(a, 1 / 2.2);
    try {
      t && this.setModuleParameters(t);
      const {
        getPolygonOffset: g
      } = this.props, y = g && g(i) || [0, 0];
      Bu(c.gl, {
        polygonOffset: y
      }), yc(c.gl, r, () => {
        const A = {
          moduleParameters: t,
          uniforms: i,
          parameters: r,
          context: c
        };
        for (const C of this.props.extensions)
          C.draw.call(this, A, C);
        this.draw(A);
      });
    } finally {
      this.props = l;
    }
  }
  getChangeFlags() {
    var e;
    return (e = this.internalState) === null || e === void 0 ? void 0 : e.changeFlags;
  }
  setChangeFlags(e) {
    if (!this.internalState)
      return;
    const {
      changeFlags: t
    } = this.internalState;
    for (const r in e)
      if (e[r]) {
        let l = !1;
        switch (r) {
          case "dataChanged":
            const c = e[r], a = t[r];
            c && Array.isArray(a) && (t.dataChanged = Array.isArray(c) ? a.concat(c) : c, l = !0);
          default:
            t[r] || (t[r] = e[r], l = !0);
        }
        l && Vo(S8, this, r, e);
      }
    const i = !!(t.dataChanged || t.updateTriggersChanged || t.propsChanged || t.extensionsChanged);
    t.propsOrDataChanged = i, t.somethingChanged = i || t.viewportChanged || t.stateChanged;
  }
  _clearChangeFlags() {
    this.internalState.changeFlags = {
      dataChanged: !1,
      propsChanged: !1,
      updateTriggersChanged: !1,
      viewportChanged: !1,
      stateChanged: !1,
      extensionsChanged: !1,
      propsOrDataChanged: !1,
      somethingChanged: !1
    };
  }
  _diffProps(e, t) {
    const i = Jk(e, t);
    if (i.updateTriggersChanged)
      for (const l in i.updateTriggersChanged)
        i.updateTriggersChanged[l] && this.invalidateAttribute(l);
    if (i.transitionsChanged)
      for (const l in i.transitionsChanged) {
        var r;
        this.internalState.uniformTransitions.add(l, t[l], e[l], (r = e.transitions) === null || r === void 0 ? void 0 : r[l]);
      }
    return this.setChangeFlags(i);
  }
  validateProps() {
    Yk(this.props);
  }
  updateAutoHighlight(e) {
    this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
  }
  _updateAutoHighlight(e) {
    const t = {
      pickingSelectedColor: e.picked ? e.color : null
    }, {
      highlightColor: i
    } = this.props;
    e.picked && typeof i == "function" && (t.pickingHighlightColor = i(e)), this.setModuleParameters(t), this.setNeedsRedraw();
  }
  _getAttributeManager() {
    const e = this.context;
    return new qk(e.gl, {
      id: this.props.id,
      stats: e.stats,
      timeline: e.timeline
    });
  }
  _postUpdate(e, t) {
    const {
      props: i,
      oldProps: r
    } = e;
    this.setNeedsRedraw(), this._updateAttributes();
    const {
      model: l
    } = this.state;
    l == null || l.setInstanceCount(this.getNumInstances());
    const {
      autoHighlight: c,
      highlightedObjectIndex: a,
      highlightColor: g
    } = i;
    if (t || r.autoHighlight !== c || r.highlightedObjectIndex !== a || r.highlightColor !== g) {
      const y = {};
      c || (y.pickingSelectedColor = null), Array.isArray(g) && (y.pickingHighlightColor = g), (t || a !== r.highlightedObjectIndex) && (y.pickingSelectedColor = Number.isFinite(a) && a >= 0 ? this.encodePickingColor(a) : null), this.setModuleParameters(y);
    }
  }
  _getUpdateParams() {
    return {
      props: this.props,
      oldProps: this.internalState.getOldProps(),
      context: this.context,
      changeFlags: this.internalState.changeFlags
    };
  }
  _getNeedsRedraw(e) {
    if (!this.internalState)
      return !1;
    let t = !1;
    t = t || this.internalState.needsRedraw && this.id;
    const i = this.getAttributeManager(), r = i ? i.getNeedsRedraw(e) : !1;
    if (t = t || r, t)
      for (const l of this.props.extensions)
        l.onNeedsRedraw.call(this, l);
    return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, t;
  }
  _onAsyncPropUpdated() {
    this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
  }
}
H(_f, "defaultProps", B8);
H(_f, "layerName", "Layer");
const O8 = "compositeLayer.renderLayers";
class oS extends _f {
  get isComposite() {
    return !0;
  }
  get isLoaded() {
    return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
  }
  getSubLayers() {
    return this.internalState && this.internalState.subLayers || [];
  }
  initializeState(e) {
  }
  setState(e) {
    super.setState(e), this.setNeedsUpdate();
  }
  getPickingInfo(e) {
    let {
      info: t
    } = e;
    const {
      object: i
    } = t;
    return i && i.__source && i.__source.parent && i.__source.parent.id === this.id && (t.object = i.__source.object, t.index = i.__source.index), t;
  }
  filterSubLayer(e) {
    return !0;
  }
  shouldRenderSubLayer(e, t) {
    return t && t.length;
  }
  getSubLayerClass(e, t) {
    const {
      _subLayerProps: i
    } = this.props;
    return i && i[e] && i[e].type || t;
  }
  getSubLayerRow(e, t, i) {
    return e.__source = {
      parent: this,
      object: t,
      index: i
    }, e;
  }
  getSubLayerAccessor(e) {
    if (typeof e == "function") {
      const t = {
        index: -1,
        data: this.props.data,
        target: []
      };
      return (i, r) => i && i.__source ? (t.index = i.__source.index, e(i.__source.object, t)) : e(i, r);
    }
    return e;
  }
  getSubLayerProps() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var t;
    const {
      opacity: i,
      pickable: r,
      visible: l,
      parameters: c,
      getPolygonOffset: a,
      highlightedObjectIndex: g,
      autoHighlight: y,
      highlightColor: A,
      coordinateSystem: C,
      coordinateOrigin: I,
      wrapLongitude: S,
      positionFormat: F,
      modelMatrix: U,
      extensions: V,
      fetch: W,
      operation: X,
      _subLayerProps: de
    } = this.props, ie = {
      id: "",
      updateTriggers: {},
      opacity: i,
      pickable: r,
      visible: l,
      parameters: c,
      getPolygonOffset: a,
      highlightedObjectIndex: g,
      autoHighlight: y,
      highlightColor: A,
      coordinateSystem: C,
      coordinateOrigin: I,
      wrapLongitude: S,
      positionFormat: F,
      modelMatrix: U,
      extensions: V,
      fetch: W,
      operation: X
    }, fe = de && e.id && de[e.id], Ae = fe && fe.updateTriggers, Te = e.id || "sublayer";
    if (fe) {
      const me = this.props[fh], Ge = e.type ? e.type._propTypes : {};
      for (const ke in fe) {
        const pe = Ge[ke] || me[ke];
        pe && pe.type === "accessor" && (fe[ke] = this.getSubLayerAccessor(fe[ke]));
      }
    }
    Object.assign(ie, e, fe), ie.id = "".concat(this.props.id, "-").concat(Te), ie.updateTriggers = {
      all: (t = this.props.updateTriggers) === null || t === void 0 ? void 0 : t.all,
      ...e.updateTriggers,
      ...Ae
    };
    for (const me of V) {
      const Ge = me.getSubLayerProps.call(this, me);
      Ge && Object.assign(ie, Ge, {
        updateTriggers: Object.assign(ie.updateTriggers, Ge.updateTriggers)
      });
    }
    return ie;
  }
  _updateAutoHighlight(e) {
    for (const t of this.getSubLayers())
      t.updateAutoHighlight(e);
  }
  _getAttributeManager() {
    return null;
  }
  _postUpdate(e, t) {
    let i = this.internalState.subLayers;
    const r = !i || this.needsUpdate();
    if (r) {
      const l = this.renderLayers();
      i = n_(l, Boolean), this.internalState.subLayers = i;
    }
    Vo(O8, this, r, i);
    for (const l of i)
      l.parent = this;
  }
}
H(oS, "layerName", "CompositeLayer");
const G0 = 512, D8 = Math.PI / 180;
function F8(n) {
  let {
    map: e,
    gl: t,
    deck: i
  } = n;
  if (e.__deck)
    return e.__deck;
  const r = i == null ? void 0 : i.props._customRender, l = i == null ? void 0 : i.props.onLoad, c = k8({
    ...i == null ? void 0 : i.props,
    _customRender: () => {
      e.triggerRepaint(), r == null || r("");
    }
  });
  let a;
  return (!i || i.props.gl === t) && (Object.assign(c, {
    gl: t,
    width: null,
    height: null,
    touchAction: "unset",
    viewState: Db(e)
  }), i != null && i.isInitialized ? Kw(i, e) : c.onLoad = () => {
    l == null || l(), Kw(a, e);
  }), i ? (a = i, i.setProps(c), i.userData.isExternal = !0) : (a = new Mb(c), e.on("remove", () => {
    N8(e);
  })), a.userData.mapboxLayers = /* @__PURE__ */ new Set(), e.__deck = a, e.on("render", () => {
    a.isInitialized && q8(a, e);
  }), a;
}
function Kw(n, e) {
  const t = () => {
    n.isInitialized ? H8(n, e) : e.off("move", t);
  };
  e.on("move", t);
}
function N8(n) {
  var e;
  (e = n.__deck) === null || e === void 0 || e.finalize(), n.__deck = null;
}
function k8(n) {
  return {
    ...n,
    parameters: {
      depthMask: !0,
      depthTest: !0,
      blend: !0,
      blendFunc: [770, 771, 1, 771],
      polygonOffsetFill: !0,
      depthFunc: 515,
      blendEquation: 32774,
      ...n.parameters
    },
    views: n.views || [new Pb({
      id: "mapbox"
    })]
  };
}
function z8(n, e) {
  n.userData.mapboxLayers.add(e), Fb(n);
}
function U8(n, e) {
  n.userData.mapboxLayers.delete(e), Fb(n);
}
function j8(n, e) {
  Fb(n);
}
function G8(n, e, t) {
  let {
    currentViewport: i
  } = n.userData, r = !1;
  i || (i = aS(n, e, !0), n.userData.currentViewport = i, r = !0), n.isInitialized && n._drawLayers("mapbox-repaint", {
    viewports: [i],
    layerFilter: (l) => {
      let {
        layer: c
      } = l;
      return t.id === c.id || c.props.operation.includes("terrain");
    },
    clearStack: r,
    clearCanvas: !1
  });
}
function Db(n) {
  var e;
  const {
    lng: t,
    lat: i
  } = n.getCenter(), r = {
    longitude: (t + 540) % 360 - 180,
    latitude: i,
    zoom: n.getZoom(),
    bearing: n.getBearing(),
    pitch: n.getPitch(),
    padding: n.getPadding(),
    repeat: n.getRenderWorldCopies()
  };
  return (e = n.getTerrain) !== null && e !== void 0 && e.call(n) && V8(n, r), r;
}
function V8(n, e) {
  if (n.getFreeCameraOptions) {
    const {
      position: t
    } = n.getFreeCameraOptions();
    if (!t || t.z === void 0)
      return;
    const i = n.transform.height, {
      longitude: r,
      latitude: l,
      pitch: c
    } = e, a = t.x * G0, g = (1 - t.y) * G0, y = t.z * G0, A = Lp([r, l]), C = a - A[0], I = g - A[1], S = Math.sqrt(C * C + I * I), F = c * D8, U = 1.5 * i, V = F < 1e-3 ? U * Math.cos(F) / y : U * Math.sin(F) / S;
    e.zoom = Math.log2(V);
    const W = U * Math.cos(F) / V, X = y - W;
    e.position = [0, 0, X / am(l)];
  } else typeof n.transform.elevation == "number" && (e.position = [0, 0, n.transform.elevation]);
}
function aS(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  return new Kh({
    id: "mapbox",
    x: 0,
    y: 0,
    width: n.width,
    height: n.height,
    ...Db(e),
    nearZMultiplier: t ? 0.02 : 0.1,
    nearZ: e.transform._nearZ / e.transform.height,
    farZ: e.transform._farZ / e.transform.height
  });
}
function q8(n, e) {
  const {
    mapboxLayers: t,
    isExternal: i
  } = n.userData;
  if (i) {
    const r = Array.from(t, (A) => A.id), c = n_(n.props.layers, Boolean).some((A) => A && !r.includes(A.id));
    let a = n.getViewports();
    const g = a.findIndex((A) => A.id === "mapbox"), y = a.length > 1 || g < 0;
    (c || y) && (g >= 0 && (a = a.slice(), a[g] = aS(n, e, !1)), n._drawLayers("mapbox-repaint", {
      viewports: a,
      layerFilter: (A) => (!n.props.layerFilter || n.props.layerFilter(A)) && (A.viewport.id !== "mapbox" || !r.includes(A.layer.id)),
      clearCanvas: !1
    }));
  }
  n.userData.currentViewport = null;
}
function H8(n, e) {
  n.setProps({
    viewState: Db(e)
  }), n.needsRedraw({
    clearRedrawFlags: !0
  });
}
function Fb(n) {
  if (n.userData.isExternal)
    return;
  const e = [];
  n.userData.mapboxLayers.forEach((t) => {
    const i = t.props.type, r = new i(t.props);
    e.push(r);
  }), n.setProps({
    layers: e
  });
}
class W8 {
  constructor(e) {
    if (H(this, "id", void 0), H(this, "type", void 0), H(this, "renderingMode", void 0), H(this, "map", void 0), H(this, "deck", void 0), H(this, "props", void 0), !e.id)
      throw new Error("Layer must have an unique id");
    this.id = e.id, this.type = "custom", this.renderingMode = e.renderingMode || "3d", this.map = null, this.deck = null, this.props = e;
  }
  onAdd(e, t) {
    this.map = e, this.deck = F8({
      map: e,
      gl: t,
      deck: this.props.deck
    }), z8(this.deck, this);
  }
  onRemove() {
    this.deck && U8(this.deck, this);
  }
  setProps(e) {
    Object.assign(this.props, e, {
      id: this.id
    }), this.deck && j8(this.deck);
  }
  render() {
    G8(this.deck, this.map, this);
  }
}
const Z8 = `#define SHADER_NAME point-cloud-layer-vertex-shader

attribute vec3 positions;
attribute vec3 instanceNormals;
attribute vec4 instanceColors;
attribute vec3 instancePositions;
attribute vec3 instancePositions64Low;
attribute vec3 instancePickingColors;

uniform float opacity;
uniform float radiusPixels;
uniform int sizeUnits;

varying vec4 vColor;
varying vec2 unitPosition;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.normal = project_normal(instanceNormals);
  unitPosition = positions.xy;
  geometry.uv = unitPosition;
  geometry.pickingColor = instancePickingColors;
  vec3 offset = vec3(positions.xy * project_size_to_pixel(radiusPixels, sizeUnits), 0.0);
  DECKGL_FILTER_SIZE(offset, geometry);

  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.), geometry.position);
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
  gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, geometry.position.xyz, geometry.normal);
  vColor = vec4(lightColor, instanceColors.a * opacity);
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, $8 = `#define SHADER_NAME point-cloud-layer-fragment-shader

precision highp float;

varying vec4 vColor;
varying vec2 unitPosition;

void main(void) {
  geometry.uv = unitPosition;

  float distToCenter = length(unitPosition);

  if (distToCenter > 1.0) {
    discard;
  }

  gl_FragColor = vColor;
  DECKGL_FILTER_COLOR(gl_FragColor, geometry);
}
`, lS = [0, 0, 0, 255], cS = [0, 0, 1], X8 = {
  sizeUnits: "pixels",
  pointSize: {
    type: "number",
    min: 0,
    value: 10
  },
  getPosition: {
    type: "accessor",
    value: (n) => n.position
  },
  getNormal: {
    type: "accessor",
    value: cS
  },
  getColor: {
    type: "accessor",
    value: lS
  },
  material: !0,
  radiusPixels: {
    deprecatedFor: "pointSize"
  }
};
function Y8(n) {
  const {
    header: e,
    attributes: t
  } = n;
  !e || !t || (n.length = e.vertexCount, t.POSITION && (t.instancePositions = t.POSITION), t.NORMAL && (t.instanceNormals = t.NORMAL), t.COLOR_0 && (t.instanceColors = t.COLOR_0));
}
class Nb extends _f {
  getShaders() {
    return super.getShaders({
      vs: Z8,
      fs: $8,
      modules: [Sb, vD, Cb]
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        transition: !0,
        accessor: "getPosition"
      },
      instanceNormals: {
        size: 3,
        transition: !0,
        accessor: "getNormal",
        defaultValue: cS
      },
      instanceColors: {
        size: this.props.colorFormat.length,
        type: 5121,
        normalized: !0,
        transition: !0,
        accessor: "getColor",
        defaultValue: lS
      }
    });
  }
  updateState(e) {
    const {
      changeFlags: t,
      props: i
    } = e;
    if (super.updateState(e), t.extensionsChanged) {
      var r;
      const {
        gl: l
      } = this.context;
      (r = this.state.model) === null || r === void 0 || r.delete(), this.state.model = this._getModel(l), this.getAttributeManager().invalidateAll();
    }
    t.dataChanged && Y8(i.data);
  }
  draw(e) {
    let {
      uniforms: t
    } = e;
    const {
      pointSize: i,
      sizeUnits: r
    } = this.props;
    this.state.model.setUniforms(t).setUniforms({
      sizeUnits: jy[r],
      radiusPixels: i
    }).draw();
  }
  _getModel(e) {
    const t = [];
    for (let i = 0; i < 3; i++) {
      const r = i / 3 * Math.PI * 2;
      t.push(Math.cos(r) * 2, Math.sin(r) * 2, 0);
    }
    return new cf(e, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: new xp({
        drawMode: 4,
        attributes: {
          positions: new Float32Array(t)
        }
      }),
      isInstanced: !0
    });
  }
}
H(Nb, "layerName", "PointCloudLayer");
H(Nb, "defaultProps", X8);
const Qa = {
  OUTSIDE: -1,
  INTERSECTING: 0,
  INSIDE: 1
};
new Tt();
new Tt();
const ep = new Tt(), Qw = new Tt();
class Jp {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    H(this, "center", void 0), H(this, "radius", void 0), this.radius = -0, this.center = new Tt(), this.fromCenterRadius(e, t);
  }
  fromCenterRadius(e, t) {
    return this.center.from(e), this.radius = t, this;
  }
  fromCornerPoints(e, t) {
    return t = ep.from(t), this.center = new Tt().from(e).add(t).scale(0.5), this.radius = this.center.distance(t), this;
  }
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.radius === e.radius;
  }
  clone() {
    return new Jp(this.center, this.radius);
  }
  union(e) {
    const t = this.center, i = this.radius, r = e.center, l = e.radius, c = ep.copy(r).subtract(t), a = c.magnitude();
    if (i >= a + l)
      return this.clone();
    if (l >= a + i)
      return e.clone();
    const g = (i + a + l) * 0.5;
    return Qw.copy(c).scale((-i + g) / a).add(t), this.center.copy(Qw), this.radius = g, this;
  }
  expand(e) {
    const i = ep.from(e).subtract(this.center).magnitude();
    return i > this.radius && (this.radius = i), this;
  }
  transform(e) {
    this.center.transform(e);
    const t = C6(ep, e);
    return this.radius = Math.max(t[0], Math.max(t[1], t[2])) * this.radius, this;
  }
  distanceSquaredTo(e) {
    const t = this.distanceTo(e);
    return t * t;
  }
  distanceTo(e) {
    const i = ep.from(e).subtract(this.center);
    return Math.max(0, i.len() - this.radius);
  }
  intersectPlane(e) {
    const t = this.center, i = this.radius, l = e.normal.dot(t) + e.distance;
    return l < -i ? Qa.OUTSIDE : l < i ? Qa.INTERSECTING : Qa.INSIDE;
  }
}
const J8 = new Tt(), K8 = new Tt(), kg = new Tt(), zg = new Tt(), Ug = new Tt(), Q8 = new Tt(), ez = new Tt(), wu = {
  COLUMN0ROW0: 0,
  COLUMN0ROW1: 1,
  COLUMN0ROW2: 2,
  COLUMN1ROW0: 3,
  COLUMN1ROW1: 4,
  COLUMN1ROW2: 5,
  COLUMN2ROW0: 6,
  COLUMN2ROW1: 7,
  COLUMN2ROW2: 8
};
class Kp {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 0], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0, 0, 0, 0, 0, 0, 0];
    H(this, "center", void 0), H(this, "halfAxes", void 0), this.center = new Tt().from(e), this.halfAxes = new ss(t);
  }
  get halfSize() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), i = this.halfAxes.getColumn(2);
    return [new Tt(e).len(), new Tt(t).len(), new Tt(i).len()];
  }
  get quaternion() {
    const e = this.halfAxes.getColumn(0), t = this.halfAxes.getColumn(1), i = this.halfAxes.getColumn(2), r = new Tt(e).normalize(), l = new Tt(t).normalize(), c = new Tt(i).normalize();
    return new Ip().fromMatrix3(new ss([...r, ...l, ...c]));
  }
  fromCenterHalfSizeQuaternion(e, t, i) {
    const r = new Ip(i), l = new ss().fromQuaternion(r);
    return l[0] = l[0] * t[0], l[1] = l[1] * t[0], l[2] = l[2] * t[0], l[3] = l[3] * t[1], l[4] = l[4] * t[1], l[5] = l[5] * t[1], l[6] = l[6] * t[2], l[7] = l[7] * t[2], l[8] = l[8] * t[2], this.center = new Tt().from(e), this.halfAxes = l, this;
  }
  clone() {
    return new Kp(this.center, this.halfAxes);
  }
  equals(e) {
    return this === e || !!e && this.center.equals(e.center) && this.halfAxes.equals(e.halfAxes);
  }
  getBoundingSphere() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Jp();
    const t = this.halfAxes, i = t.getColumn(0, kg), r = t.getColumn(1, zg), l = t.getColumn(2, Ug), c = J8.copy(i).add(r).add(l);
    return e.center.copy(this.center), e.radius = c.magnitude(), e;
  }
  intersectPlane(e) {
    const t = this.center, i = e.normal, r = this.halfAxes, l = i.x, c = i.y, a = i.z, g = Math.abs(l * r[wu.COLUMN0ROW0] + c * r[wu.COLUMN0ROW1] + a * r[wu.COLUMN0ROW2]) + Math.abs(l * r[wu.COLUMN1ROW0] + c * r[wu.COLUMN1ROW1] + a * r[wu.COLUMN1ROW2]) + Math.abs(l * r[wu.COLUMN2ROW0] + c * r[wu.COLUMN2ROW1] + a * r[wu.COLUMN2ROW2]), y = i.dot(t) + e.distance;
    return y <= -g ? Qa.OUTSIDE : y >= g ? Qa.INSIDE : Qa.INTERSECTING;
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceSquaredTo(e));
  }
  distanceSquaredTo(e) {
    const t = K8.from(e).subtract(this.center), i = this.halfAxes, r = i.getColumn(0, kg), l = i.getColumn(1, zg), c = i.getColumn(2, Ug), a = r.magnitude(), g = l.magnitude(), y = c.magnitude();
    r.normalize(), l.normalize(), c.normalize();
    let A = 0, C;
    return C = Math.abs(t.dot(r)) - a, C > 0 && (A += C * C), C = Math.abs(t.dot(l)) - g, C > 0 && (A += C * C), C = Math.abs(t.dot(c)) - y, C > 0 && (A += C * C), A;
  }
  computePlaneDistances(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [-0, -0], r = Number.POSITIVE_INFINITY, l = Number.NEGATIVE_INFINITY;
    const c = this.center, a = this.halfAxes, g = a.getColumn(0, kg), y = a.getColumn(1, zg), A = a.getColumn(2, Ug), C = Q8.copy(g).add(y).add(A).add(c), I = ez.copy(C).subtract(e);
    let S = t.dot(I);
    return r = Math.min(S, r), l = Math.max(S, l), C.copy(c).add(g).add(y).subtract(A), I.copy(C).subtract(e), S = t.dot(I), r = Math.min(S, r), l = Math.max(S, l), C.copy(c).add(g).subtract(y).add(A), I.copy(C).subtract(e), S = t.dot(I), r = Math.min(S, r), l = Math.max(S, l), C.copy(c).add(g).subtract(y).subtract(A), I.copy(C).subtract(e), S = t.dot(I), r = Math.min(S, r), l = Math.max(S, l), c.copy(C).subtract(g).add(y).add(A), I.copy(C).subtract(e), S = t.dot(I), r = Math.min(S, r), l = Math.max(S, l), c.copy(C).subtract(g).add(y).subtract(A), I.copy(C).subtract(e), S = t.dot(I), r = Math.min(S, r), l = Math.max(S, l), c.copy(C).subtract(g).subtract(y).add(A), I.copy(C).subtract(e), S = t.dot(I), r = Math.min(S, r), l = Math.max(S, l), c.copy(C).subtract(g).subtract(y).subtract(A), I.copy(C).subtract(e), S = t.dot(I), r = Math.min(S, r), l = Math.max(S, l), i[0] = r, i[1] = l, i;
  }
  transform(e) {
    this.center.transformAsPoint(e);
    const t = this.halfAxes.getColumn(0, kg);
    t.transformAsPoint(e);
    const i = this.halfAxes.getColumn(1, zg);
    i.transformAsPoint(e);
    const r = this.halfAxes.getColumn(2, Ug);
    return r.transformAsPoint(e), this.halfAxes = new ss([...t, ...i, ...r]), this;
  }
  getTransform() {
    throw new Error("not implemented");
  }
}
const eA = new Tt(), tA = new Tt();
class pc {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [0, 0, 1], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    H(this, "normal", void 0), H(this, "distance", void 0), this.normal = new Tt(), this.distance = -0, this.fromNormalDistance(e, t);
  }
  fromNormalDistance(e, t) {
    return gc(Number.isFinite(t)), this.normal.from(e).normalize(), this.distance = t, this;
  }
  fromPointNormal(e, t) {
    e = eA.from(e), this.normal.from(t).normalize();
    const i = -this.normal.dot(e);
    return this.distance = i, this;
  }
  fromCoefficients(e, t, i, r) {
    return this.normal.set(e, t, i), gc(bc(this.normal.len(), 1)), this.distance = r, this;
  }
  clone() {
    return new pc(this.normal, this.distance);
  }
  equals(e) {
    return bc(this.distance, e.distance) && bc(this.normal, e.normal);
  }
  getPointDistance(e) {
    return this.normal.dot(e) + this.distance;
  }
  transform(e) {
    const t = tA.copy(this.normal).transformAsVector(e).normalize(), i = this.normal.scale(-this.distance).transform(e);
    return this.fromPointNormal(i, t);
  }
  projectPointOntoPlane(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    e = eA.from(e);
    const i = this.getPointDistance(e), r = tA.copy(this.normal).scale(i);
    return e.subtract(r).to(t);
  }
}
const nA = [new Tt([1, 0, 0]), new Tt([0, 1, 0]), new Tt([0, 0, 1])], iA = new Tt(), tz = new Tt();
new pc(new Tt(1, 0, 0), 0);
class El {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    H(this, "planes", void 0), this.planes = e;
  }
  fromBoundingSphere(e) {
    this.planes.length = 2 * nA.length;
    const t = e.center, i = e.radius;
    let r = 0;
    for (const l of nA) {
      let c = this.planes[r], a = this.planes[r + 1];
      c || (c = this.planes[r] = new pc()), a || (a = this.planes[r + 1] = new pc());
      const g = iA.copy(l).scale(-i).add(t);
      -l.dot(g), c.fromPointNormal(g, l);
      const y = iA.copy(l).scale(i).add(t), A = tz.copy(l).negate();
      -A.dot(y), a.fromPointNormal(y, A), r += 2;
    }
    return this;
  }
  computeVisibility(e) {
    let t = Qa.INSIDE;
    for (const i of this.planes)
      switch (e.intersectPlane(i)) {
        case Qa.OUTSIDE:
          return Qa.OUTSIDE;
        case Qa.INTERSECTING:
          t = Qa.INTERSECTING;
          break;
      }
    return t;
  }
  computeVisibilityWithPlaneMask(e, t) {
    if (gc(Number.isFinite(t), "parentPlaneMask is required."), t === El.MASK_OUTSIDE || t === El.MASK_INSIDE)
      return t;
    let i = El.MASK_INSIDE;
    const r = this.planes;
    for (let l = 0; l < this.planes.length; ++l) {
      const c = l < 31 ? 1 << l : 0;
      if (l < 31 && !(t & c))
        continue;
      const a = r[l], g = e.intersectPlane(a);
      if (g === Qa.OUTSIDE)
        return El.MASK_OUTSIDE;
      g === Qa.INTERSECTING && (i |= c);
    }
    return i;
  }
}
H(El, "MASK_OUTSIDE", 4294967295);
H(El, "MASK_INSIDE", 0);
H(El, "MASK_INDETERMINATE", 2147483647);
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
new Tt();
const Zc = new ss(), nz = new ss(), iz = new ss(), jg = new ss(), rA = new ss();
function rz(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = Mp.EPSILON20, i = 10;
  let r = 0, l = 0;
  const c = nz, a = iz;
  c.identity(), a.copy(n);
  const g = t * sz(a);
  for (; l < i && oz(a) > g; )
    az(a, jg), rA.copy(jg).transpose(), a.multiplyRight(jg), a.multiplyLeft(rA), c.multiplyRight(jg), ++r > 2 && (++l, r = 0);
  return e.unitary = c.toTarget(e.unitary), e.diagonal = a.toTarget(e.diagonal), e;
}
function sz(n) {
  let e = 0;
  for (let t = 0; t < 9; ++t) {
    const i = n[t];
    e += i * i;
  }
  return Math.sqrt(e);
}
const c1 = [1, 0, 0], u1 = [2, 2, 1];
function oz(n) {
  let e = 0;
  for (let t = 0; t < 3; ++t) {
    const i = n[Zc.getElementIndex(u1[t], c1[t])];
    e += 2 * i * i;
  }
  return Math.sqrt(e);
}
function az(n, e) {
  const t = Mp.EPSILON15;
  let i = 0, r = 1;
  for (let y = 0; y < 3; ++y) {
    const A = Math.abs(n[Zc.getElementIndex(u1[y], c1[y])]);
    A > i && (r = y, i = A);
  }
  const l = c1[r], c = u1[r];
  let a = 1, g = 0;
  if (Math.abs(n[Zc.getElementIndex(c, l)]) > t) {
    const y = n[Zc.getElementIndex(c, c)], A = n[Zc.getElementIndex(l, l)], C = n[Zc.getElementIndex(c, l)], I = (y - A) / 2 / C;
    let S;
    I < 0 ? S = -1 / (-I + Math.sqrt(1 + I * I)) : S = 1 / (I + Math.sqrt(1 + I * I)), a = 1 / Math.sqrt(1 + S * S), g = S * a;
  }
  return ss.IDENTITY.to(e), e[Zc.getElementIndex(l, l)] = e[Zc.getElementIndex(c, c)] = a, e[Zc.getElementIndex(c, l)] = g, e[Zc.getElementIndex(l, c)] = -g, e;
}
const rh = new Tt(), lz = new Tt(), cz = new Tt(), uz = new Tt(), hz = new Tt(), dz = new ss(), fz = {
  diagonal: new ss(),
  unitary: new ss()
};
function pz(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Kp();
  if (!n || n.length === 0)
    return e.halfAxes = new ss([0, 0, 0, 0, 0, 0, 0, 0, 0]), e.center = new Tt(), e;
  const t = n.length, i = new Tt(0, 0, 0);
  for (const Ge of n)
    i.add(Ge);
  const r = 1 / t;
  i.multiplyByScalar(r);
  let l = 0, c = 0, a = 0, g = 0, y = 0, A = 0;
  for (const Ge of n) {
    const ke = rh.copy(Ge).subtract(i);
    l += ke.x * ke.x, c += ke.x * ke.y, a += ke.x * ke.z, g += ke.y * ke.y, y += ke.y * ke.z, A += ke.z * ke.z;
  }
  l *= r, c *= r, a *= r, g *= r, y *= r, A *= r;
  const C = dz;
  C[0] = l, C[1] = c, C[2] = a, C[3] = c, C[4] = g, C[5] = y, C[6] = a, C[7] = y, C[8] = A;
  const {
    unitary: I
  } = rz(C, fz), S = e.halfAxes.copy(I);
  let F = S.getColumn(0, cz), U = S.getColumn(1, uz), V = S.getColumn(2, hz), W = -Number.MAX_VALUE, X = -Number.MAX_VALUE, de = -Number.MAX_VALUE, ie = Number.MAX_VALUE, fe = Number.MAX_VALUE, Ae = Number.MAX_VALUE;
  for (const Ge of n)
    rh.copy(Ge), W = Math.max(rh.dot(F), W), X = Math.max(rh.dot(U), X), de = Math.max(rh.dot(V), de), ie = Math.min(rh.dot(F), ie), fe = Math.min(rh.dot(U), fe), Ae = Math.min(rh.dot(V), Ae);
  F = F.multiplyByScalar(0.5 * (ie + W)), U = U.multiplyByScalar(0.5 * (fe + X)), V = V.multiplyByScalar(0.5 * (Ae + de)), e.center.copy(F).add(U).add(V);
  const Te = lz.set(W - ie, X - fe, de - Ae).multiplyByScalar(0.5), me = new ss([Te[0], 0, 0, 0, Te[1], 0, 0, 0, Te[2]]);
  return e.halfAxes.multiplyRight(me), e;
}
const V0 = Math.PI / 180, Gg = new Float32Array(16), sA = new Float32Array(12);
function oA(n, e, t) {
  const i = e[0] * V0, r = e[1] * V0, l = e[2] * V0, c = Math.sin(l), a = Math.sin(i), g = Math.sin(r), y = Math.cos(l), A = Math.cos(i), C = Math.cos(r), I = t[0], S = t[1], F = t[2];
  n[0] = I * C * A, n[1] = I * g * A, n[2] = I * -a, n[3] = S * (-g * y + C * a * c), n[4] = S * (C * y + g * a * c), n[5] = S * A * c, n[6] = F * (g * c + C * a * y), n[7] = F * (-C * c + g * a * y), n[8] = F * A * y;
}
function aA(n) {
  return n[0] = n[0], n[1] = n[1], n[2] = n[2], n[3] = n[4], n[4] = n[5], n[5] = n[6], n[6] = n[8], n[7] = n[9], n[8] = n[10], n[9] = n[12], n[10] = n[13], n[11] = n[14], n.subarray(0, 12);
}
const uS = {
  size: 12,
  accessor: ["getOrientation", "getScale", "getTranslation", "getTransformMatrix"],
  shaderAttributes: {
    instanceModelMatrix__LOCATION_0: {
      size: 3,
      elementOffset: 0
    },
    instanceModelMatrix__LOCATION_1: {
      size: 3,
      elementOffset: 3
    },
    instanceModelMatrix__LOCATION_2: {
      size: 3,
      elementOffset: 6
    },
    instanceTranslation: {
      size: 3,
      elementOffset: 9
    }
  },
  update(n, e) {
    let {
      startRow: t,
      endRow: i
    } = e;
    const {
      data: r,
      getOrientation: l,
      getScale: c,
      getTranslation: a,
      getTransformMatrix: g
    } = this.props, y = Array.isArray(g), A = y && g.length === 16, C = Array.isArray(c), I = Array.isArray(l), S = Array.isArray(a), F = A || !y && !!g(r[0]);
    F ? n.constant = A : n.constant = I && C && S;
    const U = n.value;
    if (n.constant) {
      let V;
      F ? (Gg.set(g), V = aA(Gg)) : (V = sA, oA(V, l, c), V.set(a, 9)), n.value = new Float32Array(V);
    } else {
      let V = t * n.size;
      const {
        iterable: W,
        objectInfo: X
      } = JE(r, t, i);
      for (const de of W) {
        X.index++;
        let ie;
        if (F)
          Gg.set(A ? g : g(de, X)), ie = aA(Gg);
        else {
          ie = sA;
          const fe = I ? l : l(de, X), Ae = C ? c : c(de, X);
          oA(ie, fe, Ae), ie.set(S ? a : a(de, X), 9);
        }
        U[V++] = ie[0], U[V++] = ie[1], U[V++] = ie[2], U[V++] = ie[3], U[V++] = ie[4], U[V++] = ie[5], U[V++] = ie[6], U[V++] = ie[7], U[V++] = ie[8], U[V++] = ie[9], U[V++] = ie[10], U[V++] = ie[11];
      }
    }
  }
};
function hS(n, e) {
  return e === Bi.CARTESIAN || e === Bi.METER_OFFSETS || e === Bi.DEFAULT && !n.isGeospatial;
}
const gz = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

void main(void) {
  geometry.worldPosition = instancePositions;
  geometry.uv = texCoords;
  geometry.pickingColor = instancePickingColors;

  vTexCoord = texCoords;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * sizeScale + instanceTranslation;

  if (composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    normals_commonspace = project_normal(instanceModelMatrix * normals);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
    geometry.position = position_commonspace;
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
    geometry.position = position_commonspace;
    normals_commonspace = project_normal(instanceModelMatrix * normals);
  }

  geometry.normal = normals_commonspace;
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, mz = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {
#ifdef DERIVATIVES_AVAILABLE
    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  DECKGL_FILTER_COLOR(color, geometry);

  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);
}
`;
function dS(n) {
  let e = 1 / 0, t = 1 / 0, i = 1 / 0, r = -1 / 0, l = -1 / 0, c = -1 / 0;
  const a = n.POSITION ? n.POSITION.value : [], g = a && a.length;
  for (let y = 0; y < g; y += 3) {
    const A = a[y], C = a[y + 1], I = a[y + 2];
    e = A < e ? A : e, t = C < t ? C : t, i = I < i ? I : i, r = A > r ? A : r, l = C > l ? C : l, c = I > c ? I : c;
  }
  return [[e, t, i], [r, l, c]];
}
function _z(n, e) {
  if (!n)
    throw new Error("loader assertion failed.");
}
class qd {
  constructor(e, t) {
    H(this, "fields", void 0), H(this, "metadata", void 0), _z(Array.isArray(e)), yz(e), this.fields = e, this.metadata = t || /* @__PURE__ */ new Map();
  }
  compareTo(e) {
    if (this.metadata !== e.metadata || this.fields.length !== e.fields.length)
      return !1;
    for (let t = 0; t < this.fields.length; ++t)
      if (!this.fields[t].compareTo(e.fields[t]))
        return !1;
    return !0;
  }
  select() {
    const e = /* @__PURE__ */ Object.create(null);
    for (var t = arguments.length, i = new Array(t), r = 0; r < t; r++)
      i[r] = arguments[r];
    for (const c of i)
      e[c] = !0;
    const l = this.fields.filter((c) => e[c.name]);
    return new qd(l, this.metadata);
  }
  selectAt() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    const r = t.map((l) => this.fields[l]).filter(Boolean);
    return new qd(r, this.metadata);
  }
  assign(e) {
    let t, i = this.metadata;
    if (e instanceof qd) {
      const c = e;
      t = c.fields, i = lA(lA(/* @__PURE__ */ new Map(), this.metadata), c.metadata);
    } else
      t = e;
    const r = /* @__PURE__ */ Object.create(null);
    for (const c of this.fields)
      r[c.name] = c;
    for (const c of t)
      r[c.name] = c;
    const l = Object.values(r);
    return new qd(l, i);
  }
}
function yz(n) {
  const e = {};
  for (const t of n)
    e[t.name] && console.warn("Schema: duplicated field name", t.name, t), e[t.name] = !0;
}
function lA(n, e) {
  return new Map([...n || /* @__PURE__ */ new Map(), ...e || /* @__PURE__ */ new Map()]);
}
class zm {
  constructor(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : /* @__PURE__ */ new Map();
    H(this, "name", void 0), H(this, "type", void 0), H(this, "nullable", void 0), H(this, "metadata", void 0), this.name = e, this.type = t, this.nullable = i, this.metadata = r;
  }
  get typeId() {
    return this.type && this.type.typeId;
  }
  clone() {
    return new zm(this.name, this.type, this.nullable, this.metadata);
  }
  compareTo(e) {
    return this.name === e.name && this.type === e.type && this.nullable === e.nullable && this.metadata === e.metadata;
  }
  toString() {
    return "".concat(this.type).concat(this.nullable ? ", nullable" : "").concat(this.metadata ? ", metadata: ".concat(this.metadata) : "");
  }
}
let is = function(n) {
  return n[n.NONE = 0] = "NONE", n[n.Null = 1] = "Null", n[n.Int = 2] = "Int", n[n.Float = 3] = "Float", n[n.Binary = 4] = "Binary", n[n.Utf8 = 5] = "Utf8", n[n.Bool = 6] = "Bool", n[n.Decimal = 7] = "Decimal", n[n.Date = 8] = "Date", n[n.Time = 9] = "Time", n[n.Timestamp = 10] = "Timestamp", n[n.Interval = 11] = "Interval", n[n.List = 12] = "List", n[n.Struct = 13] = "Struct", n[n.Union = 14] = "Union", n[n.FixedSizeBinary = 15] = "FixedSizeBinary", n[n.FixedSizeList = 16] = "FixedSizeList", n[n.Map = 17] = "Map", n[n.Dictionary = -1] = "Dictionary", n[n.Int8 = -2] = "Int8", n[n.Int16 = -3] = "Int16", n[n.Int32 = -4] = "Int32", n[n.Int64 = -5] = "Int64", n[n.Uint8 = -6] = "Uint8", n[n.Uint16 = -7] = "Uint16", n[n.Uint32 = -8] = "Uint32", n[n.Uint64 = -9] = "Uint64", n[n.Float16 = -10] = "Float16", n[n.Float32 = -11] = "Float32", n[n.Float64 = -12] = "Float64", n[n.DateDay = -13] = "DateDay", n[n.DateMillisecond = -14] = "DateMillisecond", n[n.TimestampSecond = -15] = "TimestampSecond", n[n.TimestampMillisecond = -16] = "TimestampMillisecond", n[n.TimestampMicrosecond = -17] = "TimestampMicrosecond", n[n.TimestampNanosecond = -18] = "TimestampNanosecond", n[n.TimeSecond = -19] = "TimeSecond", n[n.TimeMillisecond = -20] = "TimeMillisecond", n[n.TimeMicrosecond = -21] = "TimeMicrosecond", n[n.TimeNanosecond = -22] = "TimeNanosecond", n[n.DenseUnion = -23] = "DenseUnion", n[n.SparseUnion = -24] = "SparseUnion", n[n.IntervalDayTime = -25] = "IntervalDayTime", n[n.IntervalYearMonth = -26] = "IntervalYearMonth", n;
}({}), fS, pS, gS;
class kb {
  static isNull(e) {
    return e && e.typeId === is.Null;
  }
  static isInt(e) {
    return e && e.typeId === is.Int;
  }
  static isFloat(e) {
    return e && e.typeId === is.Float;
  }
  static isBinary(e) {
    return e && e.typeId === is.Binary;
  }
  static isUtf8(e) {
    return e && e.typeId === is.Utf8;
  }
  static isBool(e) {
    return e && e.typeId === is.Bool;
  }
  static isDecimal(e) {
    return e && e.typeId === is.Decimal;
  }
  static isDate(e) {
    return e && e.typeId === is.Date;
  }
  static isTime(e) {
    return e && e.typeId === is.Time;
  }
  static isTimestamp(e) {
    return e && e.typeId === is.Timestamp;
  }
  static isInterval(e) {
    return e && e.typeId === is.Interval;
  }
  static isList(e) {
    return e && e.typeId === is.List;
  }
  static isStruct(e) {
    return e && e.typeId === is.Struct;
  }
  static isUnion(e) {
    return e && e.typeId === is.Union;
  }
  static isFixedSizeBinary(e) {
    return e && e.typeId === is.FixedSizeBinary;
  }
  static isFixedSizeList(e) {
    return e && e.typeId === is.FixedSizeList;
  }
  static isMap(e) {
    return e && e.typeId === is.Map;
  }
  static isDictionary(e) {
    return e && e.typeId === is.Dictionary;
  }
  get typeId() {
    return is.NONE;
  }
  compareTo(e) {
    return this === e;
  }
}
fS = Symbol.toStringTag;
class yf extends kb {
  constructor(e, t) {
    super(), H(this, "isSigned", void 0), H(this, "bitWidth", void 0), this.isSigned = e, this.bitWidth = t;
  }
  get typeId() {
    return is.Int;
  }
  get [fS]() {
    return "Int";
  }
  toString() {
    return "".concat(this.isSigned ? "I" : "Ui", "nt").concat(this.bitWidth);
  }
}
class bz extends yf {
  constructor() {
    super(!0, 8);
  }
}
class vz extends yf {
  constructor() {
    super(!0, 16);
  }
}
class xz extends yf {
  constructor() {
    super(!0, 32);
  }
}
class wz extends yf {
  constructor() {
    super(!1, 8);
  }
}
class Az extends yf {
  constructor() {
    super(!1, 16);
  }
}
class Tz extends yf {
  constructor() {
    super(!1, 32);
  }
}
const mS = {
  HALF: 16,
  SINGLE: 32,
  DOUBLE: 64
};
pS = Symbol.toStringTag;
class _S extends kb {
  constructor(e) {
    super(), H(this, "precision", void 0), this.precision = e;
  }
  get typeId() {
    return is.Float;
  }
  get [pS]() {
    return "Float";
  }
  toString() {
    return "Float".concat(this.precision);
  }
}
class Ez extends _S {
  constructor() {
    super(mS.SINGLE);
  }
}
class Sz extends _S {
  constructor() {
    super(mS.DOUBLE);
  }
}
gS = Symbol.toStringTag;
class Cz extends kb {
  constructor(e, t) {
    super(), H(this, "listSize", void 0), H(this, "children", void 0), this.listSize = e, this.children = [t];
  }
  get typeId() {
    return is.FixedSizeList;
  }
  get valueType() {
    return this.children[0].type;
  }
  get valueField() {
    return this.children[0];
  }
  get [gS]() {
    return "FixedSizeList";
  }
  toString() {
    return "FixedSizeList[".concat(this.listSize, "]<").concat(this.valueType, ">");
  }
}
function Pz(n) {
  switch (n.constructor) {
    case Int8Array:
      return new bz();
    case Uint8Array:
      return new wz();
    case Int16Array:
      return new vz();
    case Uint16Array:
      return new Az();
    case Int32Array:
      return new xz();
    case Uint32Array:
      return new Tz();
    case Float32Array:
      return new Ez();
    case Float64Array:
      return new Sz();
    default:
      throw new Error("array type not supported");
  }
}
function Iz(n, e, t) {
  const i = Pz(e.value), r = t || Mz(e);
  return new zm(n, new Cz(e.size, new zm("value", i)), !1, r);
}
function Mz(n) {
  const e = /* @__PURE__ */ new Map();
  return "byteOffset" in n && e.set("byteOffset", n.byteOffset.toString(10)), "byteStride" in n && e.set("byteStride", n.byteStride.toString(10)), "normalized" in n && e.set("normalized", n.normalized.toString()), e;
}
function cA(n, e) {
  (n.COLOR_0 || n.colors) && e || (n.colors = {
    constant: !0,
    value: new Float32Array([1, 1, 1])
  }), zi.assert(n.positions || n.POSITION, 'no "postions" or "POSITION" attribute in mesh');
}
function uA(n, e) {
  if (n.attributes)
    return cA(n.attributes, e), n instanceof xp ? n : new xp(n);
  if (n.positions || n.POSITION)
    return cA(n, e), new xp({
      attributes: n
    });
  throw Error("Invalid mesh");
}
const Lz = [0, 0, 0, 255], Rz = {
  mesh: {
    type: "object",
    value: null,
    async: !0
  },
  texture: {
    type: "image",
    value: null,
    async: !0
  },
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  _useMeshColors: {
    type: "boolean",
    value: !1
  },
  _instanced: !0,
  wireframe: !1,
  material: !0,
  getPosition: {
    type: "accessor",
    value: (n) => n.position
  },
  getColor: {
    type: "accessor",
    value: Lz
  },
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  textureParameters: {
    type: "object",
    ignore: !0
  }
};
class zb extends _f {
  constructor() {
    super(...arguments), H(this, "state", void 0);
  }
  getShaders() {
    const e = !Si(this.context.gl), t = {};
    return ob(this.context.gl, Tr.GLSL_DERIVATIVES) && (t.DERIVATIVES_AVAILABLE = 1), super.getShaders({
      vs: gz,
      fs: mz,
      modules: [Sb, xD, Cb],
      transpileToGLSL100: e,
      defines: t
    });
  }
  getBounds() {
    var e;
    if (this.props._instanced)
      return super.getBounds();
    let t = this.state.positionBounds;
    if (t)
      return t;
    const {
      mesh: i
    } = this.props;
    if (!i)
      return null;
    if (t = (e = i.header) === null || e === void 0 ? void 0 : e.boundingBox, !t) {
      const {
        attributes: r
      } = uA(i, this.props._useMeshColors);
      r.POSITION = r.POSITION || r.positions, t = dS(r);
    }
    return this.state.positionBounds = t, t;
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        transition: !0,
        type: 5130,
        fp64: this.use64bitPositions(),
        size: 3,
        accessor: "getPosition"
      },
      instanceColors: {
        type: 5121,
        transition: !0,
        size: this.props.colorFormat.length,
        normalized: !0,
        accessor: "getColor",
        defaultValue: [0, 0, 0, 255]
      },
      instanceModelMatrix: uS
    }), this.setState({
      emptyTexture: new rl(this.context.gl, {
        data: new Uint8Array(4),
        width: 1,
        height: 1
      })
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: i,
      changeFlags: r
    } = e;
    if (t.mesh !== i.mesh || r.extensionsChanged) {
      var l;
      if (this.state.positionBounds = null, (l = this.state.model) === null || l === void 0 || l.delete(), t.mesh) {
        this.state.model = this.getModel(t.mesh);
        const c = t.mesh.attributes || t.mesh;
        this.setState({
          hasNormals: !!(c.NORMAL || c.normals)
        });
      }
      this.getAttributeManager().invalidateAll();
    }
    t.texture !== i.texture && this.setTexture(t.texture), this.state.model && this.state.model.setDrawMode(this.props.wireframe ? 3 : 4);
  }
  finalizeState(e) {
    super.finalizeState(e), this.state.emptyTexture.delete();
  }
  draw(e) {
    let {
      uniforms: t
    } = e;
    if (!this.state.model)
      return;
    const {
      viewport: i
    } = this.context, {
      sizeScale: r,
      coordinateSystem: l,
      _instanced: c
    } = this.props;
    this.state.model.setUniforms(t).setUniforms({
      sizeScale: r,
      composeModelMatrix: !c || hS(i, l),
      flatShading: !this.state.hasNormals
    }).draw();
  }
  get isLoaded() {
    var e;
    return ((e = this.state) === null || e === void 0 ? void 0 : e.model) && super.isLoaded;
  }
  getModel(e) {
    const t = new cf(this.context.gl, {
      ...this.getShaders(),
      id: this.props.id,
      geometry: uA(e, this.props._useMeshColors),
      isInstanced: !0
    }), {
      texture: i
    } = this.props, {
      emptyTexture: r
    } = this.state;
    return t.setUniforms({
      sampler: i || r,
      hasTexture: !!i
    }), t;
  }
  setTexture(e) {
    const {
      emptyTexture: t,
      model: i
    } = this.state;
    i && i.setUniforms({
      sampler: e || t,
      hasTexture: !!e
    });
  }
}
H(zb, "defaultProps", Rz);
H(zb, "layerName", "SimpleMeshLayer");
class Yd {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      id: t
    } = e;
    this.id = t || Ou(this.constructor.name), this.display = !0, this.position = new Tt(), this.rotation = new Tt(), this.scale = new Tt(1, 1, 1), this.matrix = new Mi(), this.userData = {}, this.props = {}, this._setScenegraphNodeProps(e);
  }
  delete() {
  }
  setProps(e) {
    return this._setScenegraphNodeProps(e), this;
  }
  toString() {
    return "{type: ScenegraphNode, id: ".concat(this.id, ")}");
  }
  getBounds() {
    return null;
  }
  setPosition(e) {
    return En(e.length === 3, "setPosition requires vector argument"), this.position = e, this;
  }
  setRotation(e) {
    return En(e.length === 3, "setRotation requires vector argument"), this.rotation = e, this;
  }
  setScale(e) {
    return En(e.length === 3, "setScale requires vector argument"), this.scale = e, this;
  }
  setMatrix(e) {
    (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? this.matrix.copy(e) : this.matrix = e;
  }
  setMatrixComponents(e) {
    let {
      position: t,
      rotation: i,
      scale: r,
      update: l = !0
    } = e;
    return t && this.setPosition(t), i && this.setRotation(i), r && this.setScale(r), l && this.updateMatrix(), this;
  }
  updateMatrix() {
    const e = this.position, t = this.rotation, i = this.scale;
    return this.matrix.identity(), this.matrix.translate(e), this.matrix.rotateXYZ(t), this.matrix.scale(i), this;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      position: t,
      rotation: i,
      scale: r
    } = e;
    return t && this.setPosition(t), i && this.setRotation(i), r && this.setScale(r), this.updateMatrix(), this;
  }
  getCoordinateUniforms(e, t) {
    En(e), t = t || this.matrix;
    const i = new Mi(e).multiplyRight(t), r = i.invert(), l = r.transpose();
    return {
      viewMatrix: e,
      modelMatrix: t,
      objectMatrix: t,
      worldMatrix: i,
      worldInverseMatrix: r,
      worldInverseTransposeMatrix: l
    };
  }
  _setScenegraphNodeProps(e) {
    "display" in e && (this.display = e.display), "position" in e && this.setPosition(e.position), "rotation" in e && this.setRotation(e.rotation), "scale" in e && this.setScale(e.scale), "matrix" in e && this.setMatrix(e.matrix), Object.assign(this.props, e);
  }
}
class wp extends Yd {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e = Array.isArray(e) ? {
      children: e
    } : e;
    const {
      children: t = []
    } = e;
    Fn.assert(t.every((i) => i instanceof Yd), "every child must an instance of ScenegraphNode"), super(e), this.children = t;
  }
  add() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    for (const r of t)
      Array.isArray(r) ? this.add(...r) : this.children.push(r);
    return this;
  }
  remove(e) {
    const t = this.children, i = t.indexOf(e);
    return i > -1 && t.splice(i, 1), this;
  }
  removeAll() {
    return this.children = [], this;
  }
  delete() {
    this.children.forEach((e) => e.delete()), this.removeAll(), super.delete();
  }
  getBounds() {
    const e = [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
    return this.traverse((t, i) => {
      let {
        worldMatrix: r
      } = i;
      const l = t.getBounds();
      if (!l)
        return;
      const [c, a] = l, g = new Tt(c).add(a).divide([2, 2, 2]);
      r.transformAsPoint(g, g);
      const y = new Tt(a).subtract(c).divide([2, 2, 2]);
      r.transformAsVector(y, y);
      for (let A = 0; A < 8; A++) {
        const C = new Tt(A & 1 ? -1 : 1, A & 2 ? -1 : 1, A & 4 ? -1 : 1).multiply(y).add(g);
        for (let I = 0; I < 3; I++)
          e[0][I] = Math.min(e[0][I], C[I]), e[1][I] = Math.max(e[1][I], C[I]);
      }
    }), Number.isFinite(e[0][0]) ? e : null;
  }
  traverse(e) {
    let {
      worldMatrix: t = new Mi()
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = new Mi(t).multiplyRight(this.matrix);
    for (const r of this.children)
      r instanceof wp ? r.traverse(e, {
        worldMatrix: i
      }) : e(r, {
        worldMatrix: i
      });
  }
}
const Bz = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, Oz = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function hA(n) {
  if (!n._animation) {
    const e = Oz[n.componentType], t = Bz[n.type], i = t * n.count, {
      buffer: r,
      byteOffset: l
    } = n.bufferView.data, c = new e(r, l + (n.byteOffset || 0), i);
    if (t === 1)
      n._animation = Array.from(c);
    else {
      const a = [];
      for (let g = 0; g < c.length; g += t)
        a.push(Array.from(c.slice(g, g + t)));
      n._animation = a;
    }
  }
  return n._animation;
}
const Dz = new Mi();
function Fz(n, e) {
  if (e.matrix.identity(), n.translation && e.matrix.translate(n.translation), n.rotation) {
    const t = Dz.fromQuaternion(n.rotation);
    e.matrix.multiplyRight(t);
  }
  n.scale && e.matrix.scale(n.scale);
}
const q0 = new Ip();
function Nz(n, e, t, i, r) {
  if (e === "rotation") {
    q0.slerp({
      start: t,
      target: i,
      ratio: r
    });
    for (let l = 0; l < q0.length; l++)
      n[e][l] = q0[l];
  } else
    for (let l = 0; l < t.length; l++)
      n[e][l] = r * i[l] + (1 - r) * t[l];
}
function kz(n, e, t) {
  let {
    p0: i,
    outTangent0: r,
    inTangent1: l,
    p1: c,
    tDiff: a,
    ratio: g
  } = t;
  for (let y = 0; y < n[e].length; y++) {
    const A = r[y] * a, C = l[y] * a;
    n[e][y] = (2 * Math.pow(g, 3) - 3 * Math.pow(g, 2) + 1) * i[y] + (Math.pow(g, 3) - 2 * Math.pow(g, 2) + g) * A + (-2 * Math.pow(g, 3) + 3 * Math.pow(g, 2)) * c[y] + (Math.pow(g, 3) - Math.pow(g, 2)) * C;
  }
}
function zz(n, e, t) {
  for (let i = 0; i < t.length; i++)
    n[e][i] = t[i];
}
function Uz(n, e, t, i) {
  let {
    input: r,
    interpolation: l,
    output: c
  } = e;
  const a = r[r.length - 1], g = n % a, y = r.findIndex((S) => S >= g), A = Math.max(0, y - 1);
  if (!Array.isArray(t[i]))
    switch (i) {
      case "translation":
        t[i] = [0, 0, 0];
        break;
      case "rotation":
        t[i] = [0, 0, 0, 1];
        break;
      case "scale":
        t[i] = [1, 1, 1];
        break;
      default:
        Fn.warn("Bad animation path ".concat(i))();
    }
  En(t[i].length === c[A].length);
  const C = r[A], I = r[y];
  switch (l) {
    case "STEP":
      zz(t, i, c[A]);
      break;
    case "LINEAR":
      if (I > C) {
        const S = (g - C) / (I - C);
        Nz(t, i, c[A], c[y], S);
      }
      break;
    case "CUBICSPLINE":
      if (I > C) {
        const S = (g - C) / (I - C), F = I - C, U = c[3 * A + 1], V = c[3 * A + 2], W = c[3 * y + 0], X = c[3 * y + 1];
        kz(t, i, {
          p0: U,
          outTangent0: V,
          inTangent1: W,
          p1: X,
          tDiff: F,
          ratio: S
        });
      }
      break;
    default:
      Fn.warn("Interpolation ".concat(l, " not supported"))();
      break;
  }
}
class jz {
  constructor(e) {
    this.startTime = 0, this.playing = !0, this.speed = 1, this.channels = [], Object.assign(this, e);
  }
  animate(e) {
    if (!this.playing)
      return;
    const i = (e / 1e3 - this.startTime) * this.speed;
    this.channels.forEach((r) => {
      let {
        sampler: l,
        target: c,
        path: a
      } = r;
      Uz(i, l, c, a), Fz(c, c._node);
    });
  }
}
class Gz {
  constructor(e) {
    this.animations = e.animations.map((t, i) => {
      const r = t.name || "Animation-".concat(i), l = t.samplers.map((a) => {
        let {
          input: g,
          interpolation: y = "LINEAR",
          output: A
        } = a;
        return {
          input: hA(e.accessors[g]),
          interpolation: y,
          output: hA(e.accessors[A])
        };
      }), c = t.channels.map((a) => {
        let {
          sampler: g,
          target: y
        } = a;
        return {
          sampler: l[g],
          target: e.nodes[y.node],
          path: y.path
        };
      });
      return new jz({
        name: r,
        channels: c
      });
    });
  }
  animate(e) {
    this.setTime(e);
  }
  setTime(e) {
    this.animations.forEach((t) => t.animate(e));
  }
  getAnimations() {
    return this.animations;
  }
}
class Vz extends Yd {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(t), this.onBeforeRender = null, this.AfterRender = null, e instanceof cf ? (this.model = e, this._setModelNodeProps(t)) : this.model = new cf(e, t), this.bounds = null, this.managedResources = t.managedResources || [];
  }
  setProps(e) {
    return super.setProps(e), this._setModelNodeProps(e), this;
  }
  getBounds() {
    return this.bounds;
  }
  delete() {
    this.model && (this.model.delete(), this.model = null), this.managedResources.forEach((e) => e.delete()), this.managedResources = [];
  }
  draw() {
    return this.model.draw(...arguments);
  }
  setUniforms() {
    return this.model.setUniforms(...arguments), this;
  }
  setAttributes() {
    return this.model.setAttributes(...arguments), this;
  }
  updateModuleSettings() {
    return this.model.updateModuleSettings(...arguments), this;
  }
  _setModelNodeProps(e) {
    this.model.setProps(e);
  }
}
class yS {
  constructor(e, t) {
    let {
      attributes: i,
      material: r,
      pbrDebug: l,
      imageBasedLightingEnvironment: c,
      lights: a,
      useTangents: g
    } = t;
    this.gl = e, this.defines = {
      MANUAL_SRGB: 1,
      SRGB_FAST_APPROXIMATION: 1
    }, ob(e, Tr.GLSL_TEXTURE_LOD) && (this.defines.USE_TEX_LOD = 1), this.uniforms = {
      u_Camera: [0, 0, 0],
      u_MetallicRoughnessValues: [1, 1]
    }, this.parameters = {}, this.generatedTextures = [], c && (this.uniforms.u_DiffuseEnvSampler = c.getDiffuseEnvSampler(), this.uniforms.u_SpecularEnvSampler = c.getSpecularEnvSampler(), this.uniforms.u_brdfLUT = c.getBrdfTexture(), this.uniforms.u_ScaleIBLAmbient = [1, 1]), l && (this.uniforms.u_ScaleDiffBaseMR = [0, 0, 0, 0], this.uniforms.u_ScaleFGDSpec = [0, 0, 0, 0]), this.defineIfPresent(i.NORMAL, "HAS_NORMALS"), this.defineIfPresent(i.TANGENT && g, "HAS_TANGENTS"), this.defineIfPresent(i.TEXCOORD_0, "HAS_UV"), this.defineIfPresent(c, "USE_IBL"), this.defineIfPresent(a, "USE_LIGHTS"), this.defineIfPresent(l, "PBR_DEBUG"), r && this.parseMaterial(r);
  }
  defineIfPresent(e, t) {
    e && (this.defines[t] = 1);
  }
  parseTexture(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
    const r = e.texture && e.texture.sampler && e.texture.sampler.parameters || {}, l = e.texture.source.image;
    let c, a = {};
    l.compressed ? (c = l, a = {
      [this.gl.TEXTURE_MIN_FILTER]: l.data.length > 1 ? this.gl.LINEAR_MIPMAP_NEAREST : this.gl.LINEAR
    }) : c = {
      data: l
    };
    const g = new rl(this.gl, {
      id: e.name || e.id,
      parameters: {
        ...r,
        ...a
      },
      pixelStore: {
        [this.gl.UNPACK_FLIP_Y_WEBGL]: !1
      },
      ...c
    });
    this.uniforms[t] = g, this.defineIfPresent(i, i), this.generatedTextures.push(g);
  }
  parsePbrMetallicRoughness(e) {
    e.baseColorTexture && this.parseTexture(e.baseColorTexture, "u_BaseColorSampler", "HAS_BASECOLORMAP"), this.uniforms.u_BaseColorFactor = e.baseColorFactor || [1, 1, 1, 1], e.metallicRoughnessTexture && this.parseTexture(e.metallicRoughnessTexture, "u_MetallicRoughnessSampler", "HAS_METALROUGHNESSMAP");
    const {
      metallicFactor: t = 1,
      roughnessFactor: i = 1
    } = e;
    this.uniforms.u_MetallicRoughnessValues = [t, i];
  }
  parseMaterial(e) {
    if (this.uniforms.pbr_uUnlit = !!e.unlit, e.pbrMetallicRoughness && this.parsePbrMetallicRoughness(e.pbrMetallicRoughness), e.normalTexture) {
      this.parseTexture(e.normalTexture, "u_NormalSampler", "HAS_NORMALMAP");
      const {
        scale: t = 1
      } = e.normalTexture;
      this.uniforms.u_NormalScale = t;
    }
    if (e.occlusionTexture) {
      this.parseTexture(e.occlusionTexture, "u_OcclusionSampler", "HAS_OCCLUSIONMAP");
      const {
        strength: t = 1
      } = e.occlusionTexture;
      this.uniforms.u_OcclusionStrength = t;
    }
    if (e.emissiveTexture && (this.parseTexture(e.emissiveTexture, "u_EmissiveSampler", "HAS_EMISSIVEMAP"), this.uniforms.u_EmissiveFactor = e.emissiveFactor || [0, 0, 0]), e.alphaMode === "MASK") {
      const {
        alphaCutoff: t = 0.5
      } = e;
      this.defines.ALPHA_CUTOFF = 1, this.uniforms.u_AlphaCutoff = t;
    } else e.alphaMode === "BLEND" && (Fn.warn("BLEND alphaMode might not work well because it requires mesh sorting")(), Object.assign(this.parameters, {
      blend: !0,
      blendEquation: this.gl.FUNC_ADD,
      blendFunc: [this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA, this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA]
    }));
  }
  delete() {
    this.generatedTextures.forEach((e) => e.delete());
  }
}
const qz = `
#if (__VERSION__ < 300)
  #define _attr attribute
#else
  #define _attr in
#endif

  _attr vec4 POSITION;

  #ifdef HAS_NORMALS
    _attr vec4 NORMAL;
  #endif

  #ifdef HAS_TANGENTS
    _attr vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    _attr vec2 TEXCOORD_0;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = NORMAL;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = TEXCOORD_0;
    #endif

    pbr_setPositionNormalTangentUV(POSITION, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * POSITION;
  }
`, Hz = `
#if (__VERSION__ < 300)
  #define fragmentColor gl_FragColor
#else
  out vec4 fragmentColor;
#endif

  void main(void) {
    fragmentColor = pbr_filterColor(vec4(0));
  }
`;
function dA(n, e) {
  return Si(n) ? `#version 300 es
`.concat(e) : e;
}
function Wz(n, e) {
  const {
    id: t,
    drawMode: i,
    vertexCount: r,
    attributes: l,
    modelOptions: c
  } = e, a = new yS(n, e);
  Fn.info(4, "createGLTFModel defines: ", a.defines)();
  const g = [];
  g.push(...a.generatedTextures), g.push(...Object.values(l).map((A) => A.buffer));
  const y = new Vz(n, {
    id: t,
    drawMode: i,
    vertexCount: r,
    modules: [bb],
    parameters: a.parameters,
    vs: dA(n, qz),
    fs: dA(n, Hz),
    managedResources: g,
    ...c,
    defines: {
      ...a.defines,
      ...c.defines
    }
  });
  return y.setProps({
    attributes: l
  }), y.setUniforms(a.uniforms), y;
}
const Zz = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, $z = {
  modelOptions: {},
  pbrDebug: !1,
  imageBasedLightingEnvironment: null,
  lights: !0,
  useTangents: !1
};
class Xz {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.gl = e, this.options = Object.assign({}, $z, t);
  }
  instantiate(e) {
    return this.gltf = e, (e.scenes || []).map((i) => this.createScene(i));
  }
  createAnimator() {
    return Array.isArray(this.gltf.animations) ? new Gz(this.gltf) : null;
  }
  createScene(e) {
    const i = (e.nodes || []).map((l) => this.createNode(l));
    return new wp({
      id: e.name || e.id,
      children: i
    });
  }
  createNode(e) {
    if (!e._node) {
      const i = (e.children || []).map((l) => this.createNode(l));
      e.mesh && i.push(this.createMesh(e.mesh));
      const r = new wp({
        id: e.name || e.id,
        children: i
      });
      if (e.matrix)
        r.setMatrix(e.matrix);
      else {
        if (r.matrix.identity(), e.translation && r.matrix.translate(e.translation), e.rotation) {
          const l = new Mi().fromQuaternion(e.rotation);
          r.matrix.multiplyRight(l);
        }
        e.scale && r.matrix.scale(e.scale);
      }
      e._node = r;
    }
    return e._node;
  }
  createMesh(e) {
    if (!e._mesh) {
      const i = (e.primitives || []).map((l, c) => this.createPrimitive(l, c, e)), r = new wp({
        id: e.name || e.id,
        children: i
      });
      e._mesh = r;
    }
    return e._mesh;
  }
  getVertexCount(e) {
    Fn.warn("getVertexCount() not found")();
  }
  createPrimitive(e, t, i) {
    const r = Wz(this.gl, Object.assign({
      id: e.name || "".concat(i.name || i.id, "-primitive-").concat(t),
      drawMode: e.mode || 4,
      vertexCount: e.indices ? e.indices.count : this.getVertexCount(e.attributes),
      attributes: this.createAttributes(e.attributes, e.indices),
      material: e.material
    }, this.options));
    return r.bounds = [e.attributes.POSITION.min, e.attributes.POSITION.max], r;
  }
  createAttributes(e, t) {
    const i = {};
    return Object.keys(e).forEach((r) => {
      i[r] = this.createAccessor(e[r], this.createBuffer(e[r], this.gl.ARRAY_BUFFER));
    }), t && (i.indices = this.createAccessor(t, this.createBuffer(t, this.gl.ELEMENT_ARRAY_BUFFER))), Fn.info(4, "glTF Attributes", {
      attributes: e,
      indices: t,
      generated: i
    })(), i;
  }
  createBuffer(e, t) {
    e.bufferView || (e.bufferView = {});
    const {
      bufferView: i
    } = e;
    return i.lumaBuffers || (i.lumaBuffers = {}), i.lumaBuffers[t] || (i.lumaBuffers[t] = new dr(this.gl, {
      id: "from-".concat(i.id),
      data: i.data || e.value,
      target: t
    })), i.lumaBuffers[t];
  }
  createAccessor(e, t) {
    return new Ta({
      buffer: t,
      offset: e.byteOffset || 0,
      stride: e.bufferView.byteStride || 0,
      type: e.componentType,
      size: Zz[e.type]
    });
  }
  createSampler(e) {
    return e;
  }
  needsPOT() {
    return !1;
  }
}
function Yz(n, e, t) {
  const i = new Xz(n, t), r = i.instantiate(e), l = i.createAnimator();
  return {
    scenes: r,
    animator: l
  };
}
const Jz = "3.4.15", Kz = "3.4.15", bS = "3.4.15", Qz = "https://unpkg.com/@loaders.gl/textures@".concat(bS, "/dist/libs/basis_encoder.wasm"), e7 = "https://unpkg.com/@loaders.gl/textures@".concat(bS, "/dist/libs/basis_encoder.js");
let H0;
async function fA(n) {
  const e = n.modules || {};
  return e.basis ? e.basis : (H0 = H0 || t7(n), await H0);
}
async function t7(n) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await Zh("basis_transcoder.js", "textures", n), await Zh("basis_transcoder.wasm", "textures", n)]), e = e || globalThis.BASIS, await n7(e, t);
}
function n7(n, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((i) => {
    n(t).then((r) => {
      const {
        BasisFile: l,
        initializeBasis: c
      } = r;
      c(), i({
        BasisFile: l
      });
    });
  });
}
let W0;
async function pA(n) {
  const e = n.modules || {};
  return e.basisEncoder ? e.basisEncoder : (W0 = W0 || i7(n), await W0);
}
async function i7(n) {
  let e = null, t = null;
  return [e, t] = await Promise.all([await Zh(e7, "textures", n), await Zh(Qz, "textures", n)]), e = e || globalThis.BASIS, await r7(e, t);
}
function r7(n, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((i) => {
    n(t).then((r) => {
      const {
        BasisFile: l,
        KTX2File: c,
        initializeBasis: a,
        BasisEncoder: g
      } = r;
      a(), i({
        BasisFile: l,
        KTX2File: c,
        BasisEncoder: g
      });
    });
  });
}
const Bd = {
  COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
  COMPRESSED_R11_EAC: 37488,
  COMPRESSED_SIGNED_R11_EAC: 37489,
  COMPRESSED_RG11_EAC: 37490,
  COMPRESSED_SIGNED_RG11_EAC: 37491,
  COMPRESSED_RGB8_ETC2: 37492,
  COMPRESSED_RGBA8_ETC2_EAC: 37493,
  COMPRESSED_SRGB8_ETC2: 37494,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 37495,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37496,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 37497,
  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
  COMPRESSED_RGB_ETC1_WEBGL: 36196,
  COMPRESSED_RGB_ATC_WEBGL: 35986,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 35987,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 34798,
  COMPRESSED_RGBA_ASTC_4X4_KHR: 37808,
  COMPRESSED_RGBA_ASTC_5X4_KHR: 37809,
  COMPRESSED_RGBA_ASTC_5X5_KHR: 37810,
  COMPRESSED_RGBA_ASTC_6X5_KHR: 37811,
  COMPRESSED_RGBA_ASTC_6X6_KHR: 37812,
  COMPRESSED_RGBA_ASTC_8X5_KHR: 37813,
  COMPRESSED_RGBA_ASTC_8X6_KHR: 37814,
  COMPRESSED_RGBA_ASTC_8X8_KHR: 37815,
  COMPRESSED_RGBA_ASTC_10X5_KHR: 37816,
  COMPRESSED_RGBA_ASTC_10X6_KHR: 37817,
  COMPRESSED_RGBA_ASTC_10X8_KHR: 37818,
  COMPRESSED_RGBA_ASTC_10X10_KHR: 37819,
  COMPRESSED_RGBA_ASTC_12X10_KHR: 37820,
  COMPRESSED_RGBA_ASTC_12X12_KHR: 37821,
  COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR: 37840,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR: 37841,
  COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR: 37842,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR: 37843,
  COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR: 37844,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR: 37845,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR: 37846,
  COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR: 37847,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR: 37848,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR: 37849,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR: 37850,
  COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR: 37851,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR: 37852,
  COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR: 37853,
  COMPRESSED_RED_RGTC1_EXT: 36283,
  COMPRESSED_SIGNED_RED_RGTC1_EXT: 36284,
  COMPRESSED_RED_GREEN_RGTC2_EXT: 36285,
  COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT: 36286,
  COMPRESSED_SRGB_S3TC_DXT1_EXT: 35916,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: 35917,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: 35918,
  COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: 35919
}, s7 = ["", "WEBKIT_", "MOZ_"], gA = {
  WEBGL_compressed_texture_s3tc: "dxt",
  WEBGL_compressed_texture_s3tc_srgb: "dxt-srgb",
  WEBGL_compressed_texture_etc1: "etc1",
  WEBGL_compressed_texture_etc: "etc2",
  WEBGL_compressed_texture_pvrtc: "pvrtc",
  WEBGL_compressed_texture_atc: "atc",
  WEBGL_compressed_texture_astc: "astc",
  EXT_texture_compression_rgtc: "rgtc"
};
let Vg = null;
function o7(n) {
  if (!Vg) {
    n = n || a7() || void 0, Vg = /* @__PURE__ */ new Set();
    for (const e of s7)
      for (const t in gA)
        if (n && n.getExtension("".concat(e).concat(t))) {
          const i = gA[t];
          Vg.add(i);
        }
  }
  return Vg;
}
function a7() {
  try {
    return document.createElement("canvas").getContext("webgl");
  } catch {
    return null;
  }
}
var mA, _A, yA, bA, vA, xA, wA, AA;
(function(n) {
  n[n.NONE = 0] = "NONE", n[n.BASISLZ = 1] = "BASISLZ", n[n.ZSTD = 2] = "ZSTD", n[n.ZLIB = 3] = "ZLIB";
})(mA || (mA = {})), function(n) {
  n[n.BASICFORMAT = 0] = "BASICFORMAT";
}(_A || (_A = {})), function(n) {
  n[n.UNSPECIFIED = 0] = "UNSPECIFIED", n[n.ETC1S = 163] = "ETC1S", n[n.UASTC = 166] = "UASTC";
}(yA || (yA = {})), function(n) {
  n[n.UNSPECIFIED = 0] = "UNSPECIFIED", n[n.SRGB = 1] = "SRGB";
}(bA || (bA = {})), function(n) {
  n[n.UNSPECIFIED = 0] = "UNSPECIFIED", n[n.LINEAR = 1] = "LINEAR", n[n.SRGB = 2] = "SRGB", n[n.ITU = 3] = "ITU", n[n.NTSC = 4] = "NTSC", n[n.SLOG = 5] = "SLOG", n[n.SLOG2 = 6] = "SLOG2";
}(vA || (vA = {})), function(n) {
  n[n.ALPHA_STRAIGHT = 0] = "ALPHA_STRAIGHT", n[n.ALPHA_PREMULTIPLIED = 1] = "ALPHA_PREMULTIPLIED";
}(xA || (xA = {})), function(n) {
  n[n.RGB = 0] = "RGB", n[n.RRR = 3] = "RRR", n[n.GGG = 4] = "GGG", n[n.AAA = 15] = "AAA";
}(wA || (wA = {})), function(n) {
  n[n.RGB = 0] = "RGB", n[n.RGBA = 3] = "RGBA", n[n.RRR = 4] = "RRR", n[n.RRRG = 5] = "RRRG";
}(AA || (AA = {}));
const Ya = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function l7(n) {
  const e = new Uint8Array(n);
  return !(e.byteLength < Ya.length || e[0] !== Ya[0] || e[1] !== Ya[1] || e[2] !== Ya[2] || e[3] !== Ya[3] || e[4] !== Ya[4] || e[5] !== Ya[5] || e[6] !== Ya[6] || e[7] !== Ya[7] || e[8] !== Ya[8] || e[9] !== Ya[9] || e[10] !== Ya[10] || e[11] !== Ya[11]);
}
const c7 = {
  etc1: {
    basisFormat: 0,
    compressed: !0,
    format: Bd.COMPRESSED_RGB_ETC1_WEBGL
  },
  etc2: {
    basisFormat: 1,
    compressed: !0
  },
  bc1: {
    basisFormat: 2,
    compressed: !0,
    format: Bd.COMPRESSED_RGB_S3TC_DXT1_EXT
  },
  bc3: {
    basisFormat: 3,
    compressed: !0,
    format: Bd.COMPRESSED_RGBA_S3TC_DXT5_EXT
  },
  bc4: {
    basisFormat: 4,
    compressed: !0
  },
  bc5: {
    basisFormat: 5,
    compressed: !0
  },
  "bc7-m6-opaque-only": {
    basisFormat: 6,
    compressed: !0
  },
  "bc7-m5": {
    basisFormat: 7,
    compressed: !0
  },
  "pvrtc1-4-rgb": {
    basisFormat: 8,
    compressed: !0,
    format: Bd.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
  },
  "pvrtc1-4-rgba": {
    basisFormat: 9,
    compressed: !0,
    format: Bd.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
  },
  "astc-4x4": {
    basisFormat: 10,
    compressed: !0,
    format: Bd.COMPRESSED_RGBA_ASTC_4X4_KHR
  },
  "atc-rgb": {
    basisFormat: 11,
    compressed: !0
  },
  "atc-rgba-interpolated-alpha": {
    basisFormat: 12,
    compressed: !0
  },
  rgba32: {
    basisFormat: 13,
    compressed: !1
  },
  rgb565: {
    basisFormat: 14,
    compressed: !1
  },
  bgr565: {
    basisFormat: 15,
    compressed: !1
  },
  rgba4444: {
    basisFormat: 16,
    compressed: !1
  }
};
async function u7(n, e) {
  if (e.basis.containerFormat === "auto") {
    if (l7(n)) {
      const i = await pA(e);
      return TA(i.KTX2File, n, e);
    }
    const {
      BasisFile: t
    } = await fA(e);
    return Z0(t, n, e);
  }
  switch (e.basis.module) {
    case "encoder":
      const t = await pA(e);
      switch (e.basis.containerFormat) {
        case "ktx2":
          return TA(t.KTX2File, n, e);
        case "basis":
        default:
          return Z0(t.BasisFile, n, e);
      }
    case "transcoder":
    default:
      const {
        BasisFile: i
      } = await fA(e);
      return Z0(i, n, e);
  }
}
function Z0(n, e, t) {
  const i = new n(new Uint8Array(e));
  try {
    if (!i.startTranscoding())
      throw new Error("Failed to start basis transcoding");
    const r = i.getNumImages(), l = [];
    for (let c = 0; c < r; c++) {
      const a = i.getNumLevels(c), g = [];
      for (let y = 0; y < a; y++)
        g.push(h7(i, c, y, t));
      l.push(g);
    }
    return l;
  } finally {
    i.close(), i.delete();
  }
}
function h7(n, e, t, i) {
  const r = n.getImageWidth(e, t), l = n.getImageHeight(e, t), c = n.getHasAlpha(), {
    compressed: a,
    format: g,
    basisFormat: y
  } = vS(i, c), A = n.getImageTranscodedSizeInBytes(e, t, y), C = new Uint8Array(A);
  if (!n.transcodeImage(C, e, t, y, 0, 0))
    throw new Error("failed to start Basis transcoding");
  return {
    width: r,
    height: l,
    data: C,
    compressed: a,
    format: g,
    hasAlpha: c
  };
}
function TA(n, e, t) {
  const i = new n(new Uint8Array(e));
  try {
    if (!i.startTranscoding())
      throw new Error("failed to start KTX2 transcoding");
    const r = i.getLevels(), l = [];
    for (let c = 0; c < r; c++) {
      l.push(d7(i, c, t));
      break;
    }
    return [l];
  } finally {
    i.close(), i.delete();
  }
}
function d7(n, e, t) {
  const {
    alphaFlag: i,
    height: r,
    width: l
  } = n.getImageLevelInfo(e, 0, 0), {
    compressed: c,
    format: a,
    basisFormat: g
  } = vS(t, i), y = n.getImageTranscodedSizeInBytes(e, 0, 0, g), A = new Uint8Array(y);
  if (!n.transcodeImage(A, e, 0, 0, g, 0, -1, -1))
    throw new Error("Failed to transcode KTX2 image");
  return {
    width: l,
    height: r,
    data: A,
    compressed: c,
    levelSize: y,
    hasAlpha: i,
    format: a
  };
}
function vS(n, e) {
  let t = n && n.basis && n.basis.format;
  return t === "auto" && (t = xS()), typeof t == "object" && (t = e ? t.alpha : t.noAlpha), t = t.toLowerCase(), c7[t];
}
function xS() {
  const n = o7();
  return n.has("astc") ? "astc-4x4" : n.has("dxt") ? {
    alpha: "bc3",
    noAlpha: "bc1"
  } : n.has("pvrtc") ? {
    alpha: "pvrtc1-4-rgba",
    noAlpha: "pvrtc1-4-rgb"
  } : n.has("etc1") ? "etc1" : n.has("etc2") ? "etc2" : "rgb565";
}
const f7 = {
  name: "Basis",
  id: Mu ? "basis" : "basis-nodejs",
  module: "textures",
  version: Kz,
  worker: !0,
  extensions: ["basis", "ktx2"],
  mimeTypes: ["application/octet-stream", "image/ktx2"],
  tests: ["sB"],
  binary: !0,
  options: {
    basis: {
      format: "auto",
      libraryPath: "libs/",
      containerFormat: "auto",
      module: "transcoder"
    }
  }
}, p7 = {
  ...f7,
  parse: u7
};
function el(n, e) {
  if (!n)
    throw new Error(e || "assert failed: gltf");
}
function wS(n, e) {
  if (n.startsWith("data:") || n.startsWith("http:") || n.startsWith("https:"))
    return n;
  const i = e.baseUri || e.uri;
  if (!i)
    throw new Error("'baseUri' must be provided to resolve relative url ".concat(n));
  return i.substr(0, i.lastIndexOf("/") + 1) + n;
}
function g7(n, e, t) {
  const i = n.bufferViews[t];
  el(i);
  const r = i.buffer, l = e[r];
  el(l);
  const c = (i.byteOffset || 0) + l.byteOffset;
  return new Uint8Array(l.arrayBuffer, c, i.byteLength);
}
const EA = ["SCALAR", "VEC2", "VEC3", "VEC4"], m7 = [[Int8Array, 5120], [Uint8Array, 5121], [Int16Array, 5122], [Uint16Array, 5123], [Uint32Array, 5125], [Float32Array, 5126], [Float64Array, 5130]], _7 = new Map(m7), y7 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, b7 = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, v7 = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
function AS(n) {
  return EA[n - 1] || EA[0];
}
function TS(n) {
  const e = _7.get(n.constructor);
  if (!e)
    throw new Error("Illegal typed array");
  return e;
}
function Ub(n, e) {
  const t = v7[n.componentType], i = y7[n.type], r = b7[n.componentType], l = n.count * i, c = n.count * i * r;
  return el(c >= 0 && c <= e.byteLength), {
    ArrayType: t,
    length: l,
    byteLength: c
  };
}
function ES(n) {
  let {
    images: e,
    bufferViews: t
  } = n;
  e = e || [], t = t || [];
  const i = e.map((c) => c.bufferView);
  t = t.filter((c) => !i.includes(c));
  const r = t.reduce((c, a) => c + a.byteLength, 0), l = e.reduce((c, a) => {
    const {
      width: g,
      height: y
    } = a.image;
    return c + g * y;
  }, 0);
  return r + Math.ceil(4 * l * 1.33);
}
const x7 = {
  asset: {
    version: "2.0",
    generator: "loaders.gl"
  },
  buffers: []
};
class Ca {
  constructor(e) {
    H(this, "gltf", void 0), H(this, "sourceBuffers", void 0), H(this, "byteLength", void 0), this.gltf = e || {
      json: {
        ...x7
      },
      buffers: []
    }, this.sourceBuffers = [], this.byteLength = 0, this.gltf.buffers && this.gltf.buffers[0] && (this.byteLength = this.gltf.buffers[0].byteLength, this.sourceBuffers = [this.gltf.buffers[0]]);
  }
  get json() {
    return this.gltf.json;
  }
  getApplicationData(e) {
    return this.json[e];
  }
  getExtraData(e) {
    return (this.json.extras || {})[e];
  }
  getExtension(e) {
    const t = this.getUsedExtensions().find((r) => r === e), i = this.json.extensions || {};
    return t ? i[e] || !0 : null;
  }
  getRequiredExtension(e) {
    return this.getRequiredExtensions().find((i) => i === e) ? this.getExtension(e) : null;
  }
  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }
  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }
  getRemovedExtensions() {
    return this.json.extensionsRemoved || [];
  }
  getObjectExtension(e, t) {
    return (e.extensions || {})[t];
  }
  getScene(e) {
    return this.getObject("scenes", e);
  }
  getNode(e) {
    return this.getObject("nodes", e);
  }
  getSkin(e) {
    return this.getObject("skins", e);
  }
  getMesh(e) {
    return this.getObject("meshes", e);
  }
  getMaterial(e) {
    return this.getObject("materials", e);
  }
  getAccessor(e) {
    return this.getObject("accessors", e);
  }
  getTexture(e) {
    return this.getObject("textures", e);
  }
  getSampler(e) {
    return this.getObject("samplers", e);
  }
  getImage(e) {
    return this.getObject("images", e);
  }
  getBufferView(e) {
    return this.getObject("bufferViews", e);
  }
  getBuffer(e) {
    return this.getObject("buffers", e);
  }
  getObject(e, t) {
    if (typeof t == "object")
      return t;
    const i = this.json[e] && this.json[e][t];
    if (!i)
      throw new Error("glTF file error: Could not find ".concat(e, "[").concat(t, "]"));
    return i;
  }
  getTypedArrayForBufferView(e) {
    e = this.getBufferView(e);
    const t = e.buffer, i = this.gltf.buffers[t];
    el(i);
    const r = (e.byteOffset || 0) + i.byteOffset;
    return new Uint8Array(i.arrayBuffer, r, e.byteLength);
  }
  getTypedArrayForAccessor(e) {
    e = this.getAccessor(e);
    const t = this.getBufferView(e.bufferView), r = this.getBuffer(t.buffer).data, {
      ArrayType: l,
      length: c
    } = Ub(e, t), a = t.byteOffset + e.byteOffset;
    return new l(r, a, c);
  }
  getTypedArrayForImageData(e) {
    e = this.getAccessor(e);
    const t = this.getBufferView(e.bufferView), r = this.getBuffer(t.buffer).data, l = t.byteOffset || 0;
    return new Uint8Array(r, l, t.byteLength);
  }
  addApplicationData(e, t) {
    return this.json[e] = t, this;
  }
  addExtraData(e, t) {
    return this.json.extras = this.json.extras || {}, this.json.extras[e] = t, this;
  }
  addObjectExtension(e, t, i) {
    return e.extensions = e.extensions || {}, e.extensions[t] = i, this.registerUsedExtension(t), this;
  }
  setObjectExtension(e, t, i) {
    const r = e.extensions || {};
    r[t] = i;
  }
  removeObjectExtension(e, t) {
    const i = e.extensions || {}, r = i[t];
    return delete i[t], r;
  }
  addExtension(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return el(t), this.json.extensions = this.json.extensions || {}, this.json.extensions[e] = t, this.registerUsedExtension(e), t;
  }
  addRequiredExtension(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return el(t), this.addExtension(e, t), this.registerRequiredExtension(e), t;
  }
  registerUsedExtension(e) {
    this.json.extensionsUsed = this.json.extensionsUsed || [], this.json.extensionsUsed.find((t) => t === e) || this.json.extensionsUsed.push(e);
  }
  registerRequiredExtension(e) {
    this.registerUsedExtension(e), this.json.extensionsRequired = this.json.extensionsRequired || [], this.json.extensionsRequired.find((t) => t === e) || this.json.extensionsRequired.push(e);
  }
  removeExtension(e) {
    if (!this.getExtension(e))
      return;
    this.json.extensionsRequired && this._removeStringFromArray(this.json.extensionsRequired, e), this.json.extensionsUsed && this._removeStringFromArray(this.json.extensionsUsed, e), this.json.extensions && delete this.json.extensions[e], Array.isArray(this.json.extensionsRemoved) || (this.json.extensionsRemoved = []);
    const t = this.json.extensionsRemoved;
    t.includes(e) || t.push(e);
  }
  setDefaultScene(e) {
    this.json.scene = e;
  }
  addScene(e) {
    const {
      nodeIndices: t
    } = e;
    return this.json.scenes = this.json.scenes || [], this.json.scenes.push({
      nodes: t
    }), this.json.scenes.length - 1;
  }
  addNode(e) {
    const {
      meshIndex: t,
      matrix: i
    } = e;
    this.json.nodes = this.json.nodes || [];
    const r = {
      mesh: t
    };
    return i && (r.matrix = i), this.json.nodes.push(r), this.json.nodes.length - 1;
  }
  addMesh(e) {
    const {
      attributes: t,
      indices: i,
      material: r,
      mode: l = 4
    } = e, a = {
      primitives: [{
        attributes: this._addAttributes(t),
        mode: l
      }]
    };
    if (i) {
      const g = this._addIndices(i);
      a.primitives[0].indices = g;
    }
    return Number.isFinite(r) && (a.primitives[0].material = r), this.json.meshes = this.json.meshes || [], this.json.meshes.push(a), this.json.meshes.length - 1;
  }
  addPointCloud(e) {
    const i = {
      primitives: [{
        attributes: this._addAttributes(e),
        mode: 0
      }]
    };
    return this.json.meshes = this.json.meshes || [], this.json.meshes.push(i), this.json.meshes.length - 1;
  }
  addImage(e, t) {
    const i = eb(e), r = t || (i == null ? void 0 : i.mimeType), c = {
      bufferView: this.addBufferView(e),
      mimeType: r
    };
    return this.json.images = this.json.images || [], this.json.images.push(c), this.json.images.length - 1;
  }
  addBufferView(e) {
    const t = e.byteLength;
    el(Number.isFinite(t)), this.sourceBuffers = this.sourceBuffers || [], this.sourceBuffers.push(e);
    const i = {
      buffer: 0,
      byteOffset: this.byteLength,
      byteLength: t
    };
    return this.byteLength += zp(t, 4), this.json.bufferViews = this.json.bufferViews || [], this.json.bufferViews.push(i), this.json.bufferViews.length - 1;
  }
  addAccessor(e, t) {
    const i = {
      bufferView: e,
      type: AS(t.size),
      componentType: t.componentType,
      count: t.count,
      max: t.max,
      min: t.min
    };
    return this.json.accessors = this.json.accessors || [], this.json.accessors.push(i), this.json.accessors.length - 1;
  }
  addBinaryBuffer(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      size: 3
    };
    const i = this.addBufferView(e);
    let r = {
      min: t.min,
      max: t.max
    };
    (!r.min || !r.max) && (r = this._getAccessorMinMax(e, t.size));
    const l = {
      size: t.size,
      componentType: TS(e),
      count: Math.round(e.length / t.size),
      min: r.min,
      max: r.max
    };
    return this.addAccessor(i, Object.assign(l, t));
  }
  addTexture(e) {
    const {
      imageIndex: t
    } = e, i = {
      source: t
    };
    return this.json.textures = this.json.textures || [], this.json.textures.push(i), this.json.textures.length - 1;
  }
  addMaterial(e) {
    return this.json.materials = this.json.materials || [], this.json.materials.push(e), this.json.materials.length - 1;
  }
  createBinaryChunk() {
    var e, t;
    this.gltf.buffers = [];
    const i = this.byteLength, r = new ArrayBuffer(i), l = new Uint8Array(r);
    let c = 0;
    for (const a of this.sourceBuffers || [])
      c = WI(a, l, c);
    (e = this.json) !== null && e !== void 0 && (t = e.buffers) !== null && t !== void 0 && t[0] ? this.json.buffers[0].byteLength = i : this.json.buffers = [{
      byteLength: i
    }], this.gltf.binary = r, this.sourceBuffers = [r];
  }
  _removeStringFromArray(e, t) {
    let i = !0;
    for (; i; ) {
      const r = e.indexOf(t);
      r > -1 ? e.splice(r, 1) : i = !1;
    }
  }
  _addAttributes() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = {};
    for (const i in e) {
      const r = e[i], l = this._getGltfAttributeName(i), c = this.addBinaryBuffer(r.value, r);
      t[l] = c;
    }
    return t;
  }
  _addIndices(e) {
    return this.addBinaryBuffer(e, {
      size: 1
    });
  }
  _getGltfAttributeName(e) {
    switch (e.toLowerCase()) {
      case "position":
      case "positions":
      case "vertices":
        return "POSITION";
      case "normal":
      case "normals":
        return "NORMAL";
      case "color":
      case "colors":
        return "COLOR_0";
      case "texcoord":
      case "texcoords":
        return "TEXCOORD_0";
      default:
        return e;
    }
  }
  _getAccessorMinMax(e, t) {
    const i = {
      min: null,
      max: null
    };
    if (e.length < t)
      return i;
    i.min = [], i.max = [];
    const r = e.subarray(0, t);
    for (const l of r)
      i.min.push(l), i.max.push(l);
    for (let l = t; l < e.length; l += t)
      for (let c = 0; c < t; c++)
        i.min[0 + c] = Math.min(i.min[0 + c], e[l + c]), i.max[0 + c] = Math.max(i.max[0 + c], e[l + c]);
    return i;
  }
}
const w7 = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB", A7 = "B9h9z9tFBBBF8dL9gBB9gLaaaaaFa9gEaaaB9gGaaB9gFaFaEQSBBFBFFGEGEGIILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBNn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBcI9z9iqlBMc/j9JSIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMkRIbaG97FaK978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAnDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAnDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAnDeBJAeCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPD8dBhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBAeCx+YUUBJDBBBHnAnDQBBBBBBBBBBBBBBBBAPD8dFhUg/8/4/w/goB9+h84k7HeCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAnDeBJAeCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBRnCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBHiCFD9tAiAPD9OD9hD9RHiDQBTFtGmEYIPLdKeOnH8ZAIAQJDBIBHpCFD9tApAPD9OD9hD9RHpAIASJDBIBHyCFD9tAyAPD9OD9hD9RHyDQBTFtGmEYIPLdKeOnH8cDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAnD9uHnDyBjGBAEAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnA8ZA8cDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNiV8ZcpMyS8cQ8df8eb8fHdApAyDQNiV8ZcpMyS8cQ8df8eb8fHiDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJHIAnAdAiDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHnDyBjGBAIAGJHIAnAPAPDQILKOILKOILKOILKOD9uHnDyBjGBAIAGJHIAnAPAPDQNVcMNVcMNVcMNVcMD9uHnDyBjGBAIAGJHIAnAPAPDQSQfbSQfbSQfbSQfbD9uHnDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/xLGEaK978jUUUUBCAlHE8kUUUUBGXGXAGCI9HQBGXAFC98ZHI9FQBABRGCBRLEXAGAGDBBBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMBBAGCTJRGALCIJHLAI9JQBMMAIAF9PQFAEAFCEZHLCGWHGqCBCTAGl/8MBAEABAICGWJHIAG/8cBBGXAL9FQBAEAEDBIBHKCiD+rFCiD+sFD/6FHOAKCND+rFCiD+sFD/6FAOD/gFAKCTD+rFCiD+sFD/6FHND/gFD/kFD/lFHVCBDtD+2FHcAOCUUUU94DtHMD9OD9RD/kFHO9DBB/+hDYAOAOD/mFAVAVD/mFANAcANAMD9OD9RD/kFHOAOD/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHcD/kFCgFDtD9OAKCUUU94DtD9OD9QAOAND/mFAcD/kFCND+rFCU/+EDtD9OD9QAVAND/mFAcD/kFCTD+rFCUU/8ODtD9OD9QDMIBMAIAEAG/8cBBSFMABAFC98ZHGT+HUUUBAGAF9PQBAEAFCEZHICEWHLJCBCAALl/8MBAEABAGCEWJHGAL/8cBBAEAIT+HUUUBAGAEAL/8cBBMAECAJ8kUUUUBM+yEGGaO97GXAF9FQBCBRGEXABCTJHEAEDBBBHICBDtHLCUU98D8cFCUU98D8cEHKD9OABDBBBHOAIDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAOAIDQBFGENVcMTtmYi8ZpyHICTD+sFD/6FHND/gFAICTD+rFCTD+sFD/6FHVD/gFD/kFD/lFHI9DB/+g6DYAVAIALD+2FHLAVCUUUU94DtHcD9OD9RD/kFHVAVD/mFAIAID/mFANALANAcD9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHND/mF9DBBX9LDYHLD/kFCTD+rFAVAND/mFALD/kFCggEDtD9OD9QHVAIAND/mFALD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHIDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAOAKD9OAVAIDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM94FEa8jUUUUBCAlHE8kUUUUBABAFC98ZHIT+JUUUBGXAIAF9PQBAEAFCEZHLCEWHFJCBCAAFl/8MBAEABAICEWJHBAF/8cBBAEALT+JUUUBABAEAF/8cBBMAECAJ8kUUUUBM/hEIGaF97FaL978jUUUUBCTlRGGXAF9FQBCBREEXAGABDBBBHIABCTJHLDBBBHKDQILKOSQfbPden8c8d8e8fHOCTD+sFHNCID+rFDMIBAB9DBBU8/DY9D/zI818/DYANCEDtD9QD/6FD/nFHNAIAKDQBFGENVcMTtmYi8ZpyHICTD+rFCTD+sFD/6FD/mFHKAKD/mFANAICTD+sFD/6FD/mFHVAVD/mFANAOCTD+rFCTD+sFD/6FD/mFHOAOD/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHND/mF9DBBX9LDYHID/kFCggEDtHcD9OAVAND/mFAID/kFCTD+rFD9QHVAOAND/mFAID/kFCTD+rFAKAND/mFAID/kFAcD9OD9QHNDQBFTtGEmYILPdKOenHID8dBAGDBIBDyB+t+J83EBABCNJAID8dFAGDBIBDyF+t+J83EBALAVANDQNVi8ZcMpySQ8c8dfb8e8fHND8dBAGDBIBDyG+t+J83EBABCiJAND8dFAGDBIBDyE+t+J83EBABCAJRBAECIJHEAF9JQBMMM/3FGEaF978jUUUUBCoBlREGXAGCGrAF9sHIC98ZHL9FQBCBRGABRFEXAFAFDBBBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBAFCTJRFAGCIJHGAL9JQBMMGXALAI9PQBAEAICEZHGCGWHFqCBCoBAFl/8MBAEABALCGWJHLAF/8cBBGXAG9FQBAEAEDBIBHKCND+rFCND+sFD/6FAKCiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMIBMALAEAF/8cBBMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB", T7 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]), E7 = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]), S7 = {
  0: "",
  1: "meshopt_decodeFilterOct",
  2: "meshopt_decodeFilterQuat",
  3: "meshopt_decodeFilterExp",
  NONE: "",
  OCTAHEDRAL: "meshopt_decodeFilterOct",
  QUATERNION: "meshopt_decodeFilterQuat",
  EXPONENTIAL: "meshopt_decodeFilterExp"
}, C7 = {
  0: "meshopt_decodeVertexBuffer",
  1: "meshopt_decodeIndexBuffer",
  2: "meshopt_decodeIndexSequence",
  ATTRIBUTES: "meshopt_decodeVertexBuffer",
  TRIANGLES: "meshopt_decodeIndexBuffer",
  INDICES: "meshopt_decodeIndexSequence"
};
async function P7(n, e, t, i, r) {
  let l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "NONE";
  const c = await I7();
  R7(c, c.exports[C7[r]], n, e, t, i, c.exports[S7[l || "NONE"]]);
}
let $0;
async function I7() {
  return $0 || ($0 = M7()), $0;
}
async function M7() {
  let n = w7;
  WebAssembly.validate(T7) && (n = A7, console.log("Warning: meshopt_decoder is using experimental SIMD support"));
  const e = await WebAssembly.instantiate(L7(n), {});
  return await e.instance.exports.__wasm_call_ctors(), e.instance;
}
function L7(n) {
  const e = new Uint8Array(n.length);
  for (let i = 0; i < n.length; ++i) {
    const r = n.charCodeAt(i);
    e[i] = r > 96 ? r - 71 : r > 64 ? r - 65 : r > 47 ? r + 4 : r > 46 ? 63 : 62;
  }
  let t = 0;
  for (let i = 0; i < n.length; ++i)
    e[t++] = e[i] < 60 ? E7[e[i]] : (e[i] - 60) * 64 + e[++i];
  return e.buffer.slice(0, t);
}
function R7(n, e, t, i, r, l, c) {
  const a = n.exports.sbrk, g = i + 3 & -4, y = a(g * r), A = a(l.length), C = new Uint8Array(n.exports.memory.buffer);
  C.set(l, A);
  const I = e(y, i, r, A, l.length);
  if (I === 0 && c && c(y, g, r), t.set(C.subarray(y, y + i * r)), a(y - a(0)), I !== 0)
    throw new Error("Malformed buffer data: ".concat(I));
}
const jb = "EXT_meshopt_compression", B7 = jb;
async function O7(n, e) {
  var t;
  const i = new Ca(n);
  if (!(e != null && (t = e.gltf) !== null && t !== void 0 && t.decompressMeshes))
    return;
  const r = [];
  for (const l of n.json.bufferViews || [])
    r.push(D7(i, l));
  await Promise.all(r), i.removeExtension(jb);
}
async function D7(n, e) {
  const t = n.getObjectExtension(e, jb);
  if (t) {
    const {
      byteOffset: i = 0,
      byteLength: r = 0,
      byteStride: l,
      count: c,
      mode: a,
      filter: g = "NONE",
      buffer: y
    } = t, A = n.gltf.buffers[y], C = new Uint8Array(A.arrayBuffer, A.byteOffset + i, r), I = new Uint8Array(n.gltf.buffers[e.buffer].arrayBuffer, e.byteOffset, e.byteLength);
    return await P7(I, c, l, C, a, g), I;
  }
  return null;
}
const F7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: O7,
  name: B7
}, Symbol.toStringTag, { value: "Module" })), zd = "EXT_texture_webp", N7 = zd;
function k7(n, e) {
  const t = new Ca(n);
  if (!qL("image/webp")) {
    if (t.getRequiredExtensions().includes(zd))
      throw new Error("gltf: Required extension ".concat(zd, " not supported by browser"));
    return;
  }
  const {
    json: i
  } = t;
  for (const r of i.textures || []) {
    const l = t.getObjectExtension(r, zd);
    l && (r.source = l.source), t.removeObjectExtension(r, zd);
  }
  t.removeExtension(zd);
}
const z7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: N7,
  preprocess: k7
}, Symbol.toStringTag, { value: "Module" })), um = "KHR_texture_basisu", U7 = um;
function j7(n, e) {
  const t = new Ca(n), {
    json: i
  } = t;
  for (const r of i.textures || []) {
    const l = t.getObjectExtension(r, um);
    l && (r.source = l.source), t.removeObjectExtension(r, um);
  }
  t.removeExtension(um);
}
const G7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  name: U7,
  preprocess: j7
}, Symbol.toStringTag, { value: "Module" })), V7 = "3.4.15", q7 = {
  draco: {
    decoderType: typeof WebAssembly == "object" ? "wasm" : "js",
    libraryPath: "libs/",
    extraAttributes: {},
    attributeNameEntry: void 0
  }
}, H7 = {
  name: "Draco",
  id: Mu ? "draco" : "draco-nodejs",
  module: "draco",
  shapes: ["mesh"],
  version: V7,
  worker: !0,
  extensions: ["drc"],
  mimeTypes: ["application/octet-stream"],
  binary: !0,
  tests: ["DRACO"],
  options: q7
};
function W7(n, e, t) {
  const i = SS(e.metadata), r = [], l = Z7(e.attributes);
  for (const c in n) {
    const a = n[c], g = SA(c, a, l[c]);
    r.push(g);
  }
  if (t) {
    const c = SA("indices", t);
    r.push(c);
  }
  return new qd(r, i);
}
function Z7(n) {
  const e = {};
  for (const t in n) {
    const i = n[t];
    e[i.name || "undefined"] = i;
  }
  return e;
}
function SA(n, e, t) {
  const i = t ? SS(t.metadata) : void 0;
  return Iz(n, e, i);
}
function SS(n) {
  const e = /* @__PURE__ */ new Map();
  for (const t in n)
    e.set("".concat(t, ".string"), JSON.stringify(n[t]));
  return e;
}
const CA = {
  POSITION: "POSITION",
  NORMAL: "NORMAL",
  COLOR: "COLOR_0",
  TEX_COORD: "TEXCOORD_0"
}, $7 = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  9: Float32Array
}, X7 = 4;
class Y7 {
  constructor(e) {
    H(this, "draco", void 0), H(this, "decoder", void 0), H(this, "metadataQuerier", void 0), this.draco = e, this.decoder = new this.draco.Decoder(), this.metadataQuerier = new this.draco.MetadataQuerier();
  }
  destroy() {
    this.draco.destroy(this.decoder), this.draco.destroy(this.metadataQuerier);
  }
  parseSync(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const i = new this.draco.DecoderBuffer();
    i.Init(new Int8Array(e), e.byteLength), this._disableAttributeTransforms(t);
    const r = this.decoder.GetEncodedGeometryType(i), l = r === this.draco.TRIANGULAR_MESH ? new this.draco.Mesh() : new this.draco.PointCloud();
    try {
      let c;
      switch (r) {
        case this.draco.TRIANGULAR_MESH:
          c = this.decoder.DecodeBufferToMesh(i, l);
          break;
        case this.draco.POINT_CLOUD:
          c = this.decoder.DecodeBufferToPointCloud(i, l);
          break;
        default:
          throw new Error("DRACO: Unknown geometry type.");
      }
      if (!c.ok() || !l.ptr) {
        const I = "DRACO decompression failed: ".concat(c.error_msg());
        throw new Error(I);
      }
      const a = this._getDracoLoaderData(l, r, t), g = this._getMeshData(l, a, t), y = dS(g.attributes), A = W7(g.attributes, a, g.indices);
      return {
        loader: "draco",
        loaderData: a,
        header: {
          vertexCount: l.num_points(),
          boundingBox: y
        },
        ...g,
        schema: A
      };
    } finally {
      this.draco.destroy(i), l && this.draco.destroy(l);
    }
  }
  _getDracoLoaderData(e, t, i) {
    const r = this._getTopLevelMetadata(e), l = this._getDracoAttributes(e, i);
    return {
      geometry_type: t,
      num_attributes: e.num_attributes(),
      num_points: e.num_points(),
      num_faces: e instanceof this.draco.Mesh ? e.num_faces() : 0,
      metadata: r,
      attributes: l
    };
  }
  _getDracoAttributes(e, t) {
    const i = {};
    for (let r = 0; r < e.num_attributes(); r++) {
      const l = this.decoder.GetAttribute(e, r), c = this._getAttributeMetadata(e, r);
      i[l.unique_id()] = {
        unique_id: l.unique_id(),
        attribute_type: l.attribute_type(),
        data_type: l.data_type(),
        num_components: l.num_components(),
        byte_offset: l.byte_offset(),
        byte_stride: l.byte_stride(),
        normalized: l.normalized(),
        attribute_index: r,
        metadata: c
      };
      const a = this._getQuantizationTransform(l, t);
      a && (i[l.unique_id()].quantization_transform = a);
      const g = this._getOctahedronTransform(l, t);
      g && (i[l.unique_id()].octahedron_transform = g);
    }
    return i;
  }
  _getMeshData(e, t, i) {
    const r = this._getMeshAttributes(t, e, i);
    if (!r.POSITION)
      throw new Error("DRACO: No position attribute found.");
    if (e instanceof this.draco.Mesh)
      switch (i.topology) {
        case "triangle-strip":
          return {
            topology: "triangle-strip",
            mode: 4,
            attributes: r,
            indices: {
              value: this._getTriangleStripIndices(e),
              size: 1
            }
          };
        case "triangle-list":
        default:
          return {
            topology: "triangle-list",
            mode: 5,
            attributes: r,
            indices: {
              value: this._getTriangleListIndices(e),
              size: 1
            }
          };
      }
    return {
      topology: "point-list",
      mode: 0,
      attributes: r
    };
  }
  _getMeshAttributes(e, t, i) {
    const r = {};
    for (const l of Object.values(e.attributes)) {
      const c = this._deduceAttributeName(l, i);
      l.name = c;
      const {
        value: a,
        size: g
      } = this._getAttributeValues(t, l);
      r[c] = {
        value: a,
        size: g,
        byteOffset: l.byte_offset,
        byteStride: l.byte_stride,
        normalized: l.normalized
      };
    }
    return r;
  }
  _getTriangleListIndices(e) {
    const i = e.num_faces() * 3, r = i * X7, l = this.draco._malloc(r);
    try {
      return this.decoder.GetTrianglesUInt32Array(e, r, l), new Uint32Array(this.draco.HEAPF32.buffer, l, i).slice();
    } finally {
      this.draco._free(l);
    }
  }
  _getTriangleStripIndices(e) {
    const t = new this.draco.DracoInt32Array();
    try {
      return this.decoder.GetTriangleStripsFromMesh(e, t), Q7(t);
    } finally {
      this.draco.destroy(t);
    }
  }
  _getAttributeValues(e, t) {
    const i = $7[t.data_type], r = t.num_components, c = e.num_points() * r, a = c * i.BYTES_PER_ELEMENT, g = J7(this.draco, i);
    let y;
    const A = this.draco._malloc(a);
    try {
      const C = this.decoder.GetAttribute(e, t.attribute_index);
      this.decoder.GetAttributeDataArrayForAllPoints(e, C, g, a, A), y = new i(this.draco.HEAPF32.buffer, A, c).slice();
    } finally {
      this.draco._free(A);
    }
    return {
      value: y,
      size: r
    };
  }
  _deduceAttributeName(e, t) {
    const i = e.unique_id;
    for (const [c, a] of Object.entries(t.extraAttributes || {}))
      if (a === i)
        return c;
    const r = e.attribute_type;
    for (const c in CA)
      if (this.draco[c] === r)
        return CA[c];
    const l = t.attributeNameEntry || "name";
    return e.metadata[l] ? e.metadata[l].string : "CUSTOM_ATTRIBUTE_".concat(i);
  }
  _getTopLevelMetadata(e) {
    const t = this.decoder.GetMetadata(e);
    return this._getDracoMetadata(t);
  }
  _getAttributeMetadata(e, t) {
    const i = this.decoder.GetAttributeMetadata(e, t);
    return this._getDracoMetadata(i);
  }
  _getDracoMetadata(e) {
    if (!e || !e.ptr)
      return {};
    const t = {}, i = this.metadataQuerier.NumEntries(e);
    for (let r = 0; r < i; r++) {
      const l = this.metadataQuerier.GetEntryName(e, r);
      t[l] = this._getDracoMetadataField(e, l);
    }
    return t;
  }
  _getDracoMetadataField(e, t) {
    const i = new this.draco.DracoInt32Array();
    try {
      this.metadataQuerier.GetIntEntryArray(e, t, i);
      const r = K7(i);
      return {
        int: this.metadataQuerier.GetIntEntry(e, t),
        string: this.metadataQuerier.GetStringEntry(e, t),
        double: this.metadataQuerier.GetDoubleEntry(e, t),
        intArray: r
      };
    } finally {
      this.draco.destroy(i);
    }
  }
  _disableAttributeTransforms(e) {
    const {
      quantizedAttributes: t = [],
      octahedronAttributes: i = []
    } = e, r = [...t, ...i];
    for (const l of r)
      this.decoder.SkipAttributeTransform(this.draco[l]);
  }
  _getQuantizationTransform(e, t) {
    const {
      quantizedAttributes: i = []
    } = t, r = e.attribute_type();
    if (i.map((c) => this.decoder[c]).includes(r)) {
      const c = new this.draco.AttributeQuantizationTransform();
      try {
        if (c.InitFromAttribute(e))
          return {
            quantization_bits: c.quantization_bits(),
            range: c.range(),
            min_values: new Float32Array([1, 2, 3]).map((a) => c.min_value(a))
          };
      } finally {
        this.draco.destroy(c);
      }
    }
    return null;
  }
  _getOctahedronTransform(e, t) {
    const {
      octahedronAttributes: i = []
    } = t, r = e.attribute_type();
    if (i.map((c) => this.decoder[c]).includes(r)) {
      const c = new this.draco.AttributeQuantizationTransform();
      try {
        if (c.InitFromAttribute(e))
          return {
            quantization_bits: c.quantization_bits()
          };
      } finally {
        this.draco.destroy(c);
      }
    }
    return null;
  }
}
function J7(n, e) {
  switch (e) {
    case Float32Array:
      return n.DT_FLOAT32;
    case Int8Array:
      return n.DT_INT8;
    case Int16Array:
      return n.DT_INT16;
    case Int32Array:
      return n.DT_INT32;
    case Uint8Array:
      return n.DT_UINT8;
    case Uint16Array:
      return n.DT_UINT16;
    case Uint32Array:
      return n.DT_UINT32;
    default:
      return n.DT_INVALID;
  }
}
function K7(n) {
  const e = n.size(), t = new Int32Array(e);
  for (let i = 0; i < e; i++)
    t[i] = n.GetValue(i);
  return t;
}
function Q7(n) {
  const e = n.size(), t = new Int32Array(e);
  for (let i = 0; i < e; i++)
    t[i] = n.GetValue(i);
  return t;
}
const eU = "1.5.5", Gb = "https://www.gstatic.com/draco/versioned/decoders/".concat(eU), tU = "".concat(Gb, "/draco_decoder.js"), nU = "".concat(Gb, "/draco_wasm_wrapper.js"), iU = "".concat(Gb, "/draco_decoder.wasm");
let tp;
async function rU(n) {
  const e = n.modules || {};
  return e.draco3d ? tp = tp || e.draco3d.createDecoderModule({}).then((t) => ({
    draco: t
  })) : tp = tp || sU(n), await tp;
}
async function sU(n) {
  let e, t;
  switch (n.draco && n.draco.decoderType) {
    case "js":
      e = await Zh(tU, "draco", n);
      break;
    case "wasm":
    default:
      [e, t] = await Promise.all([await Zh(nU, "draco", n), await Zh(iU, "draco", n)]);
  }
  return e = e || globalThis.DracoDecoderModule, await oU(e, t);
}
function oU(n, e) {
  const t = {};
  return e && (t.wasmBinary = e), new Promise((i) => {
    n({
      ...t,
      onModuleLoaded: (r) => i({
        draco: r
      })
    });
  });
}
const CS = {
  ...H7,
  parse: aU
};
async function aU(n, e) {
  const {
    draco: t
  } = await rU(e), i = new Y7(t);
  try {
    return i.parseSync(n, e == null ? void 0 : e.draco);
  } finally {
    i.destroy();
  }
}
function lU(n) {
  const e = {};
  for (const t in n) {
    const i = n[t];
    if (t !== "indices") {
      const r = PS(i);
      e[t] = r;
    }
  }
  return e;
}
function PS(n) {
  const {
    buffer: e,
    size: t,
    count: i
  } = cU(n);
  return {
    value: e,
    size: t,
    byteOffset: 0,
    count: i,
    type: AS(t),
    componentType: TS(e)
  };
}
function cU(n) {
  let e = n, t = 1, i = 0;
  return n && n.value && (e = n.value, t = n.size || 1), e && (ArrayBuffer.isView(e) || (e = uU(e, Float32Array)), i = e.length / t), {
    buffer: e,
    size: t,
    count: i
  };
}
function uU(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return n ? Array.isArray(n) ? new e(n) : t && !(n instanceof e) ? new e(n) : n : null;
}
const ed = "KHR_draco_mesh_compression", hU = ed;
function dU(n, e, t) {
  const i = new Ca(n);
  for (const r of IS(i))
    i.getObjectExtension(r, ed);
}
async function fU(n, e, t) {
  var i;
  if (!(e != null && (i = e.gltf) !== null && i !== void 0 && i.decompressMeshes))
    return;
  const r = new Ca(n), l = [];
  for (const c of IS(r))
    r.getObjectExtension(c, ed) && l.push(gU(r, c, e, t));
  await Promise.all(l), r.removeExtension(ed);
}
function pU(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const t = new Ca(n);
  for (const i of t.json.meshes || [])
    mU(i, e), t.addRequiredExtension(ed);
}
async function gU(n, e, t, i) {
  const r = n.getObjectExtension(e, ed);
  if (!r)
    return;
  const l = n.getTypedArrayForBufferView(r.bufferView), c = W1(l.buffer, l.byteOffset), {
    parse: a
  } = i, g = {
    ...t
  };
  delete g["3d-tiles"];
  const y = await a(c, CS, g, i), A = lU(y.attributes);
  for (const [C, I] of Object.entries(A))
    if (C in e.attributes) {
      const S = e.attributes[C], F = n.getAccessor(S);
      F != null && F.min && F !== null && F !== void 0 && F.max && (I.min = F.min, I.max = F.max);
    }
  e.attributes = A, y.indices && (e.indices = PS(y.indices)), _U(e);
}
function mU(n, e) {
  var t;
  let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 4, r = arguments.length > 3 ? arguments[3] : void 0, l = arguments.length > 4 ? arguments[4] : void 0;
  if (!r.DracoWriter)
    throw new Error("options.gltf.DracoWriter not provided");
  const c = r.DracoWriter.encodeSync({
    attributes: n
  }), a = l == null || (t = l.parseSync) === null || t === void 0 ? void 0 : t.call(l, {
    attributes: n
  }), g = r._addFauxAttributes(a.attributes), y = r.addBufferView(c);
  return {
    primitives: [{
      attributes: g,
      mode: i,
      extensions: {
        [ed]: {
          bufferView: y,
          attributes: g
        }
      }
    }]
  };
}
function _U(n) {
  if (!n.attributes && Object.keys(n.attributes).length > 0)
    throw new Error("glTF: Empty primitive detected: Draco decompression failure?");
}
function* IS(n) {
  for (const e of n.json.meshes || [])
    for (const t of e.primitives)
      yield t;
}
const yU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: fU,
  encode: pU,
  name: hU,
  preprocess: dU
}, Symbol.toStringTag, { value: "Module" })), bU = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, vU = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, Vb = "KHR_texture_transform", xU = Vb, qg = new Tt(), wU = new ss(), AU = new ss();
async function TU(n, e) {
  if (!new Ca(n).getExtension(Vb))
    return;
  const r = n.json.materials || [];
  for (let l = 0; l < r.length; l++)
    EU(l, n);
}
function EU(n, e) {
  var t, i, r;
  const l = [], c = (t = e.json.materials) === null || t === void 0 ? void 0 : t[n], a = c == null || (i = c.pbrMetallicRoughness) === null || i === void 0 ? void 0 : i.baseColorTexture;
  a && np(e, n, a, l);
  const g = c == null ? void 0 : c.emissiveTexture;
  g && np(e, n, g, l);
  const y = c == null ? void 0 : c.normalTexture;
  y && np(e, n, y, l);
  const A = c == null ? void 0 : c.occlusionTexture;
  A && np(e, n, A, l);
  const C = c == null || (r = c.pbrMetallicRoughness) === null || r === void 0 ? void 0 : r.metallicRoughnessTexture;
  C && np(e, n, C, l);
}
function np(n, e, t, i) {
  const r = SU(t, i);
  if (!r)
    return;
  const l = n.json.meshes || [];
  for (const c of l)
    for (const a of c.primitives) {
      const g = a.material;
      Number.isFinite(g) && e === g && CU(n, a, r);
    }
}
function SU(n, e) {
  var t;
  const i = (t = n.extensions) === null || t === void 0 ? void 0 : t[Vb], {
    texCoord: r = 0
  } = n, {
    texCoord: l = r
  } = i;
  if (!(e.findIndex((a) => {
    let [g, y] = a;
    return g === r && y === l;
  }) !== -1)) {
    const a = MU(i);
    return r !== l && (n.texCoord = l), e.push([r, l]), {
      originalTexCoord: r,
      texCoord: l,
      matrix: a
    };
  }
  return null;
}
function CU(n, e, t) {
  const {
    originalTexCoord: i,
    texCoord: r,
    matrix: l
  } = t, c = e.attributes["TEXCOORD_".concat(i)];
  if (Number.isFinite(c)) {
    var a;
    const y = (a = n.json.accessors) === null || a === void 0 ? void 0 : a[c];
    if (y && y.bufferView) {
      var g;
      const A = (g = n.json.bufferViews) === null || g === void 0 ? void 0 : g[y.bufferView];
      if (A) {
        const {
          arrayBuffer: C,
          byteOffset: I
        } = n.buffers[A.buffer], S = (I || 0) + (y.byteOffset || 0) + (A.byteOffset || 0), {
          ArrayType: F,
          length: U
        } = Ub(y, A), V = vU[y.componentType], W = bU[y.type], X = A.byteStride || V * W, de = new Float32Array(U);
        for (let ie = 0; ie < y.count; ie++) {
          const fe = new F(C, S + ie * X, 2);
          qg.set(fe[0], fe[1], 1), qg.transformByMatrix3(l), de.set([qg[0], qg[1]], ie * W);
        }
        i === r ? PU(y, A, n.buffers, de) : IU(r, y, e, n, de);
      }
    }
  }
}
function PU(n, e, t, i) {
  n.componentType = 5126, t.push({
    arrayBuffer: i.buffer,
    byteOffset: 0,
    byteLength: i.buffer.byteLength
  }), e.buffer = t.length - 1, e.byteLength = i.buffer.byteLength, e.byteOffset = 0, delete e.byteStride;
}
function IU(n, e, t, i, r) {
  i.buffers.push({
    arrayBuffer: r.buffer,
    byteOffset: 0,
    byteLength: r.buffer.byteLength
  });
  const l = i.json.bufferViews;
  if (!l)
    return;
  l.push({
    buffer: i.buffers.length - 1,
    byteLength: r.buffer.byteLength,
    byteOffset: 0
  });
  const c = i.json.accessors;
  c && (c.push({
    bufferView: (l == null ? void 0 : l.length) - 1,
    byteOffset: 0,
    componentType: 5126,
    count: e.count,
    type: "VEC2"
  }), t.attributes["TEXCOORD_".concat(n)] = c.length - 1);
}
function MU(n) {
  const {
    offset: e = [0, 0],
    rotation: t = 0,
    scale: i = [1, 1]
  } = n, r = new ss().set(1, 0, 0, 0, 1, 0, e[0], e[1], 1), l = wU.set(Math.cos(t), Math.sin(t), 0, -Math.sin(t), Math.cos(t), 0, 0, 0, 1), c = AU.set(i[0], 0, 0, 0, i[1], 0, 0, 0, 1);
  return r.multiplyRight(l).multiplyRight(c);
}
const LU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: TU,
  name: xU
}, Symbol.toStringTag, { value: "Module" })), Vh = "KHR_lights_punctual", RU = Vh;
async function BU(n) {
  const e = new Ca(n), {
    json: t
  } = e, i = e.getExtension(Vh);
  i && (e.json.lights = i.lights, e.removeExtension(Vh));
  for (const r of t.nodes || []) {
    const l = e.getObjectExtension(r, Vh);
    l && (r.light = l.light), e.removeObjectExtension(r, Vh);
  }
}
async function OU(n) {
  const e = new Ca(n), {
    json: t
  } = e;
  if (t.lights) {
    const i = e.addExtension(Vh);
    el(!i.lights), i.lights = t.lights, delete t.lights;
  }
  if (e.json.lights) {
    for (const i of e.json.lights) {
      const r = i.node;
      e.addObjectExtension(r, Vh, i);
    }
    delete e.json.lights;
  }
}
const DU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: BU,
  encode: OU,
  name: RU
}, Symbol.toStringTag, { value: "Module" })), Bp = "KHR_materials_unlit", FU = Bp;
async function NU(n) {
  const e = new Ca(n), {
    json: t
  } = e;
  for (const i of t.materials || [])
    i.extensions && i.extensions.KHR_materials_unlit && (i.unlit = !0), e.removeObjectExtension(i, Bp);
  e.removeExtension(Bp);
}
function kU(n) {
  const e = new Ca(n), {
    json: t
  } = e;
  if (e.materials)
    for (const i of t.materials || [])
      i.unlit && (delete i.unlit, e.addObjectExtension(i, Bp, {}), e.addExtension(Bp));
}
const zU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: NU,
  encode: kU,
  name: FU
}, Symbol.toStringTag, { value: "Module" })), fp = "KHR_techniques_webgl", UU = fp;
async function jU(n) {
  const e = new Ca(n), {
    json: t
  } = e, i = e.getExtension(fp);
  if (i) {
    const r = VU(i, e);
    for (const l of t.materials || []) {
      const c = e.getObjectExtension(l, fp);
      c && (l.technique = Object.assign({}, c, r[c.technique]), l.technique.values = qU(l.technique, e)), e.removeObjectExtension(l, fp);
    }
    e.removeExtension(fp);
  }
}
async function GU(n, e) {
}
function VU(n, e) {
  const {
    programs: t = [],
    shaders: i = [],
    techniques: r = []
  } = n, l = new TextDecoder();
  return i.forEach((c) => {
    if (Number.isFinite(c.bufferView))
      c.code = l.decode(e.getTypedArrayForBufferView(c.bufferView));
    else
      throw new Error("KHR_techniques_webgl: no shader code");
  }), t.forEach((c) => {
    c.fragmentShader = i[c.fragmentShader], c.vertexShader = i[c.vertexShader];
  }), r.forEach((c) => {
    c.program = t[c.program];
  }), r;
}
function qU(n, e) {
  const t = Object.assign({}, n.values);
  return Object.keys(n.uniforms || {}).forEach((i) => {
    n.uniforms[i].value && !(i in t) && (t[i] = n.uniforms[i].value);
  }), Object.keys(t).forEach((i) => {
    typeof t[i] == "object" && t[i].index !== void 0 && (t[i].texture = e.getTexture(t[i].index));
  }), t;
}
const HU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: jU,
  encode: GU,
  name: UU
}, Symbol.toStringTag, { value: "Module" })), MS = "EXT_feature_metadata", WU = MS;
async function ZU(n) {
  const e = new Ca(n);
  $U(e);
}
function $U(n) {
  var e;
  const t = n.getExtension(MS), i = t == null || (e = t.schema) === null || e === void 0 ? void 0 : e.classes, r = t == null ? void 0 : t.featureTables;
  if ((t == null ? void 0 : t.featureTextures) && console.warn('featureTextures is not yet supported in the "EXT_feature_metadata" extension.'), i && r)
    for (const c in i) {
      const a = i[c], g = JU(r, c);
      g && XU(n, g, a);
    }
}
function XU(n, e, t) {
  for (const r in t.properties) {
    var i;
    const l = t.properties[r], c = e == null || (i = e.properties) === null || i === void 0 ? void 0 : i[r], a = e.count;
    if (c) {
      const g = YU(n, l, a, c);
      c.data = g;
    }
  }
}
function YU(n, e, t, i) {
  const r = i.bufferView;
  let l = n.getTypedArrayForBufferView(r);
  switch (e.type) {
    case "STRING": {
      const c = i.stringOffsetBufferView, a = n.getTypedArrayForBufferView(c);
      l = KU(l, a, t);
      break;
    }
  }
  return l;
}
function JU(n, e) {
  for (const t in n) {
    const i = n[t];
    if (i.class === e)
      return i;
  }
  return null;
}
function KU(n, e, t) {
  const i = [], r = new TextDecoder("utf8");
  let l = 0;
  const c = 4;
  for (let a = 0; a < t; a++) {
    const g = e[(a + 1) * c] - e[a * c], y = n.subarray(l, g + l), A = r.decode(y);
    i.push(A), l += g;
  }
  return i;
}
const QU = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decode: ZU,
  name: WU
}, Symbol.toStringTag, { value: "Module" })), LS = [F7, z7, G7, yU, DU, zU, HU, LU, QU];
function e9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const i = LS.filter((l) => RS(l.name, e));
  for (const l of i) {
    var r;
    (r = l.preprocess) === null || r === void 0 || r.call(l, n, e, t);
  }
}
async function t9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  const i = LS.filter((l) => RS(l.name, e));
  for (const l of i) {
    var r;
    await ((r = l.decode) === null || r === void 0 ? void 0 : r.call(l, n, e, t));
  }
}
function RS(n, e) {
  var t;
  const i = (e == null || (t = e.gltf) === null || t === void 0 ? void 0 : t.excludeExtensions) || {};
  return !(n in i && !i[n]);
}
const X0 = "KHR_binary_glTF";
function n9(n) {
  const e = new Ca(n), {
    json: t
  } = e;
  for (const i of t.images || []) {
    const r = e.getObjectExtension(i, X0);
    r && Object.assign(i, r), e.removeObjectExtension(i, X0);
  }
  t.buffers && t.buffers[0] && delete t.buffers[0].uri, e.removeExtension(X0);
}
const PA = {
  accessors: "accessor",
  animations: "animation",
  buffers: "buffer",
  bufferViews: "bufferView",
  images: "image",
  materials: "material",
  meshes: "mesh",
  nodes: "node",
  samplers: "sampler",
  scenes: "scene",
  skins: "skin",
  textures: "texture"
}, i9 = {
  accessor: "accessors",
  animations: "animation",
  buffer: "buffers",
  bufferView: "bufferViews",
  image: "images",
  material: "materials",
  mesh: "meshes",
  node: "nodes",
  sampler: "samplers",
  scene: "scenes",
  skin: "skins",
  texture: "textures"
};
class r9 {
  constructor() {
    H(this, "idToIndexMap", {
      animations: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      images: {},
      materials: {},
      meshes: {},
      nodes: {},
      samplers: {},
      scenes: {},
      skins: {},
      textures: {}
    }), H(this, "json", void 0);
  }
  normalize(e, t) {
    this.json = e.json;
    const i = e.json;
    switch (i.asset && i.asset.version) {
      case "2.0":
        return;
      case void 0:
      case "1.0":
        break;
      default:
        console.warn("glTF: Unknown version ".concat(i.asset.version));
        return;
    }
    if (!t.normalize)
      throw new Error("glTF v1 is not supported.");
    console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."), this._addAsset(i), this._convertTopLevelObjectsToArrays(i), n9(e), this._convertObjectIdsToArrayIndices(i), this._updateObjects(i), this._updateMaterial(i);
  }
  _addAsset(e) {
    e.asset = e.asset || {}, e.asset.version = "2.0", e.asset.generator = e.asset.generator || "Normalized to glTF 2.0 by loaders.gl";
  }
  _convertTopLevelObjectsToArrays(e) {
    for (const t in PA)
      this._convertTopLevelObjectToArray(e, t);
  }
  _convertTopLevelObjectToArray(e, t) {
    const i = e[t];
    if (!(!i || Array.isArray(i))) {
      e[t] = [];
      for (const r in i) {
        const l = i[r];
        l.id = l.id || r;
        const c = e[t].length;
        e[t].push(l), this.idToIndexMap[t][r] = c;
      }
    }
  }
  _convertObjectIdsToArrayIndices(e) {
    for (const t in PA)
      this._convertIdsToIndices(e, t);
    "scene" in e && (e.scene = this._convertIdToIndex(e.scene, "scene"));
    for (const t of e.textures)
      this._convertTextureIds(t);
    for (const t of e.meshes)
      this._convertMeshIds(t);
    for (const t of e.nodes)
      this._convertNodeIds(t);
    for (const t of e.scenes)
      this._convertSceneIds(t);
  }
  _convertTextureIds(e) {
    e.source && (e.source = this._convertIdToIndex(e.source, "image"));
  }
  _convertMeshIds(e) {
    for (const t of e.primitives) {
      const {
        attributes: i,
        indices: r,
        material: l
      } = t;
      for (const c in i)
        i[c] = this._convertIdToIndex(i[c], "accessor");
      r && (t.indices = this._convertIdToIndex(r, "accessor")), l && (t.material = this._convertIdToIndex(l, "material"));
    }
  }
  _convertNodeIds(e) {
    e.children && (e.children = e.children.map((t) => this._convertIdToIndex(t, "node"))), e.meshes && (e.meshes = e.meshes.map((t) => this._convertIdToIndex(t, "mesh")));
  }
  _convertSceneIds(e) {
    e.nodes && (e.nodes = e.nodes.map((t) => this._convertIdToIndex(t, "node")));
  }
  _convertIdsToIndices(e, t) {
    e[t] || (console.warn("gltf v1: json doesn't contain attribute ".concat(t)), e[t] = []);
    for (const i of e[t])
      for (const r in i) {
        const l = i[r], c = this._convertIdToIndex(l, r);
        i[r] = c;
      }
  }
  _convertIdToIndex(e, t) {
    const i = i9[t];
    if (i in this.idToIndexMap) {
      const r = this.idToIndexMap[i][e];
      if (!Number.isFinite(r))
        throw new Error("gltf v1: failed to resolve ".concat(t, " with id ").concat(e));
      return r;
    }
    return e;
  }
  _updateObjects(e) {
    for (const t of this.json.buffers)
      delete t.type;
  }
  _updateMaterial(e) {
    for (const l of e.materials) {
      var t, i, r;
      l.pbrMetallicRoughness = {
        baseColorFactor: [1, 1, 1, 1],
        metallicFactor: 1,
        roughnessFactor: 1
      };
      const c = ((t = l.values) === null || t === void 0 ? void 0 : t.tex) || ((i = l.values) === null || i === void 0 ? void 0 : i.texture2d_0) || ((r = l.values) === null || r === void 0 ? void 0 : r.diffuseTex), a = e.textures.findIndex((g) => g.id === c);
      a !== -1 && (l.pbrMetallicRoughness.baseColorTexture = {
        index: a
      });
    }
  }
}
function s9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return new r9().normalize(n, e);
}
const o9 = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, a9 = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
}, Al = {
  TEXTURE_MAG_FILTER: 10240,
  TEXTURE_MIN_FILTER: 10241,
  TEXTURE_WRAP_S: 10242,
  TEXTURE_WRAP_T: 10243,
  REPEAT: 10497,
  LINEAR: 9729,
  NEAREST_MIPMAP_LINEAR: 9986
}, l9 = {
  magFilter: Al.TEXTURE_MAG_FILTER,
  minFilter: Al.TEXTURE_MIN_FILTER,
  wrapS: Al.TEXTURE_WRAP_S,
  wrapT: Al.TEXTURE_WRAP_T
}, c9 = {
  [Al.TEXTURE_MAG_FILTER]: Al.LINEAR,
  [Al.TEXTURE_MIN_FILTER]: Al.NEAREST_MIPMAP_LINEAR,
  [Al.TEXTURE_WRAP_S]: Al.REPEAT,
  [Al.TEXTURE_WRAP_T]: Al.REPEAT
};
function u9(n) {
  return a9[n];
}
function h9(n) {
  return o9[n];
}
class d9 {
  constructor() {
    H(this, "baseUri", ""), H(this, "json", {}), H(this, "buffers", []), H(this, "images", []);
  }
  postProcess(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      json: i,
      buffers: r = [],
      images: l = [],
      baseUri: c = ""
    } = e;
    return el(i), this.baseUri = c, this.json = i, this.buffers = r, this.images = l, this._resolveTree(this.json, t), this.json;
  }
  _resolveTree(e) {
    e.bufferViews && (e.bufferViews = e.bufferViews.map((t, i) => this._resolveBufferView(t, i))), e.images && (e.images = e.images.map((t, i) => this._resolveImage(t, i))), e.samplers && (e.samplers = e.samplers.map((t, i) => this._resolveSampler(t, i))), e.textures && (e.textures = e.textures.map((t, i) => this._resolveTexture(t, i))), e.accessors && (e.accessors = e.accessors.map((t, i) => this._resolveAccessor(t, i))), e.materials && (e.materials = e.materials.map((t, i) => this._resolveMaterial(t, i))), e.meshes && (e.meshes = e.meshes.map((t, i) => this._resolveMesh(t, i))), e.nodes && (e.nodes = e.nodes.map((t, i) => this._resolveNode(t, i))), e.skins && (e.skins = e.skins.map((t, i) => this._resolveSkin(t, i))), e.scenes && (e.scenes = e.scenes.map((t, i) => this._resolveScene(t, i))), e.scene !== void 0 && (e.scene = e.scenes[this.json.scene]);
  }
  getScene(e) {
    return this._get("scenes", e);
  }
  getNode(e) {
    return this._get("nodes", e);
  }
  getSkin(e) {
    return this._get("skins", e);
  }
  getMesh(e) {
    return this._get("meshes", e);
  }
  getMaterial(e) {
    return this._get("materials", e);
  }
  getAccessor(e) {
    return this._get("accessors", e);
  }
  getCamera(e) {
    return null;
  }
  getTexture(e) {
    return this._get("textures", e);
  }
  getSampler(e) {
    return this._get("samplers", e);
  }
  getImage(e) {
    return this._get("images", e);
  }
  getBufferView(e) {
    return this._get("bufferViews", e);
  }
  getBuffer(e) {
    return this._get("buffers", e);
  }
  _get(e, t) {
    if (typeof t == "object")
      return t;
    const i = this.json[e] && this.json[e][t];
    return i || console.warn("glTF file error: Could not find ".concat(e, "[").concat(t, "]")), i;
  }
  _resolveScene(e, t) {
    return e.id = e.id || "scene-".concat(t), e.nodes = (e.nodes || []).map((i) => this.getNode(i)), e;
  }
  _resolveNode(e, t) {
    return e.id = e.id || "node-".concat(t), e.children && (e.children = e.children.map((i) => this.getNode(i))), e.mesh !== void 0 ? e.mesh = this.getMesh(e.mesh) : e.meshes !== void 0 && e.meshes.length && (e.mesh = e.meshes.reduce((i, r) => {
      const l = this.getMesh(r);
      return i.id = l.id, i.primitives = i.primitives.concat(l.primitives), i;
    }, {
      primitives: []
    })), e.camera !== void 0 && (e.camera = this.getCamera(e.camera)), e.skin !== void 0 && (e.skin = this.getSkin(e.skin)), e;
  }
  _resolveSkin(e, t) {
    return e.id = e.id || "skin-".concat(t), e.inverseBindMatrices = this.getAccessor(e.inverseBindMatrices), e;
  }
  _resolveMesh(e, t) {
    return e.id = e.id || "mesh-".concat(t), e.primitives && (e.primitives = e.primitives.map((i) => {
      i = {
        ...i
      };
      const r = i.attributes;
      i.attributes = {};
      for (const l in r)
        i.attributes[l] = this.getAccessor(r[l]);
      return i.indices !== void 0 && (i.indices = this.getAccessor(i.indices)), i.material !== void 0 && (i.material = this.getMaterial(i.material)), i;
    })), e;
  }
  _resolveMaterial(e, t) {
    if (e.id = e.id || "material-".concat(t), e.normalTexture && (e.normalTexture = {
      ...e.normalTexture
    }, e.normalTexture.texture = this.getTexture(e.normalTexture.index)), e.occlusionTexture && (e.occlustionTexture = {
      ...e.occlustionTexture
    }, e.occlusionTexture.texture = this.getTexture(e.occlusionTexture.index)), e.emissiveTexture && (e.emmisiveTexture = {
      ...e.emmisiveTexture
    }, e.emissiveTexture.texture = this.getTexture(e.emissiveTexture.index)), e.emissiveFactor || (e.emissiveFactor = e.emmisiveTexture ? [1, 1, 1] : [0, 0, 0]), e.pbrMetallicRoughness) {
      e.pbrMetallicRoughness = {
        ...e.pbrMetallicRoughness
      };
      const i = e.pbrMetallicRoughness;
      i.baseColorTexture && (i.baseColorTexture = {
        ...i.baseColorTexture
      }, i.baseColorTexture.texture = this.getTexture(i.baseColorTexture.index)), i.metallicRoughnessTexture && (i.metallicRoughnessTexture = {
        ...i.metallicRoughnessTexture
      }, i.metallicRoughnessTexture.texture = this.getTexture(i.metallicRoughnessTexture.index));
    }
    return e;
  }
  _resolveAccessor(e, t) {
    if (e.id = e.id || "accessor-".concat(t), e.bufferView !== void 0 && (e.bufferView = this.getBufferView(e.bufferView)), e.bytesPerComponent = u9(e.componentType), e.components = h9(e.type), e.bytesPerElement = e.bytesPerComponent * e.components, e.bufferView) {
      const i = e.bufferView.buffer, {
        ArrayType: r,
        byteLength: l
      } = Ub(e, e.bufferView), c = (e.bufferView.byteOffset || 0) + (e.byteOffset || 0) + i.byteOffset;
      let a = i.arrayBuffer.slice(c, c + l);
      e.bufferView.byteStride && (a = this._getValueFromInterleavedBuffer(i, c, e.bufferView.byteStride, e.bytesPerElement, e.count)), e.value = new r(a);
    }
    return e;
  }
  _getValueFromInterleavedBuffer(e, t, i, r, l) {
    const c = new Uint8Array(l * r);
    for (let a = 0; a < l; a++) {
      const g = t + a * i;
      c.set(new Uint8Array(e.arrayBuffer.slice(g, g + r)), a * r);
    }
    return c.buffer;
  }
  _resolveTexture(e, t) {
    return e.id = e.id || "texture-".concat(t), e.sampler = "sampler" in e ? this.getSampler(e.sampler) : c9, e.source = this.getImage(e.source), e;
  }
  _resolveSampler(e, t) {
    e.id = e.id || "sampler-".concat(t), e.parameters = {};
    for (const i in e) {
      const r = this._enumSamplerParameter(i);
      r !== void 0 && (e.parameters[r] = e[i]);
    }
    return e;
  }
  _enumSamplerParameter(e) {
    return l9[e];
  }
  _resolveImage(e, t) {
    e.id = e.id || "image-".concat(t), e.bufferView !== void 0 && (e.bufferView = this.getBufferView(e.bufferView));
    const i = this.images[t];
    return i && (e.image = i), e;
  }
  _resolveBufferView(e, t) {
    const i = e.buffer, r = {
      id: "bufferView-".concat(t),
      ...e,
      buffer: this.buffers[i]
    }, l = this.buffers[i].arrayBuffer;
    let c = this.buffers[i].byteOffset || 0;
    return "byteOffset" in e && (c += e.byteOffset), r.data = new Uint8Array(l, c, e.byteLength), r;
  }
  _resolveCamera(e, t) {
    return e.id = e.id || "camera-".concat(t), e.perspective, e.orthographic, e;
  }
}
function f9(n, e) {
  return new d9().postProcess(n, e);
}
const IA = 1735152710, qb = 12, Um = 8, p9 = 1313821514, g9 = 5130562, m9 = 0, _9 = 1, y9 = 0, df = !0;
function b9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return "".concat(String.fromCharCode(n.getUint8(e + 0))).concat(String.fromCharCode(n.getUint8(e + 1))).concat(String.fromCharCode(n.getUint8(e + 2))).concat(String.fromCharCode(n.getUint8(e + 3)));
}
function v9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const i = new DataView(n), {
    magic: r = IA
  } = t, l = i.getUint32(e, !1);
  return l === r || l === IA;
}
function x9(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const i = new DataView(e), r = b9(i, t + 0), l = i.getUint32(t + 4, df), c = i.getUint32(t + 8, df);
  switch (Object.assign(n, {
    header: {
      byteOffset: t,
      byteLength: c,
      hasBinChunk: !1
    },
    type: r,
    version: l,
    json: {},
    binChunks: []
  }), t += qb, n.version) {
    case 1:
      return w9(n, i, t);
    case 2:
      return A9(n, i, t, {});
    default:
      throw new Error("Invalid GLB version ".concat(n.version, ". Only supports v1 and v2."));
  }
}
function w9(n, e, t) {
  _r(n.header.byteLength > qb + Um);
  const i = e.getUint32(t + 0, df), r = e.getUint32(t + 4, df);
  return t += Um, _r(r === y9), h1(n, e, t, i), t += i, t += d1(n, e, t, n.header.byteLength), t;
}
function A9(n, e, t, i) {
  return _r(n.header.byteLength > qb + Um), T9(n, e, t, i), t + n.header.byteLength;
}
function T9(n, e, t, i) {
  for (; t + 8 <= n.header.byteLength; ) {
    const r = e.getUint32(t + 0, df), l = e.getUint32(t + 4, df);
    switch (t += Um, l) {
      case p9:
        h1(n, e, t, r);
        break;
      case g9:
        d1(n, e, t, r);
        break;
      case m9:
        i.strict || h1(n, e, t, r);
        break;
      case _9:
        i.strict || d1(n, e, t, r);
        break;
    }
    t += zp(r, 4);
  }
  return t;
}
function h1(n, e, t, i) {
  const r = new Uint8Array(e.buffer, t, i), c = new TextDecoder("utf8").decode(r);
  return n.json = JSON.parse(c), zp(i, 4);
}
function d1(n, e, t, i) {
  return n.header.hasBinChunk = !0, n.binChunks.push({
    byteOffset: t,
    byteLength: i,
    arrayBuffer: e.buffer
  }), zp(i, 4);
}
async function E9(n, e) {
  var t, i, r, l;
  let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, a = arguments.length > 3 ? arguments[3] : void 0, g = arguments.length > 4 ? arguments[4] : void 0;
  S9(n, e, c, a), s9(n, {
    normalize: a == null || (t = a.gltf) === null || t === void 0 ? void 0 : t.normalize
  }), e9(n, a, g);
  const y = [];
  if (a != null && (i = a.gltf) !== null && i !== void 0 && i.loadBuffers && n.json.buffers && await C9(n, a, g), a != null && (r = a.gltf) !== null && r !== void 0 && r.loadImages) {
    const C = P9(n, a, g);
    y.push(C);
  }
  const A = t9(n, a, g);
  return y.push(A), await Promise.all(y), a != null && (l = a.gltf) !== null && l !== void 0 && l.postProcess ? f9(n, a) : n;
}
function S9(n, e, t, i) {
  if (i.uri && (n.baseUri = i.uri), e instanceof ArrayBuffer && !v9(e, t, i) && (e = new TextDecoder().decode(e)), typeof e == "string")
    n.json = VI(e);
  else if (e instanceof ArrayBuffer) {
    const c = {};
    t = x9(c, e, t, i.glb), el(c.type === "glTF", "Invalid GLB magic string ".concat(c.type)), n._glb = c, n.json = c.json;
  } else
    el(!1, "GLTF: must be ArrayBuffer or string");
  const r = n.json.buffers || [];
  if (n.buffers = new Array(r.length).fill(null), n._glb && n._glb.header.hasBinChunk) {
    const {
      binChunks: c
    } = n._glb;
    n.buffers[0] = {
      arrayBuffer: c[0].arrayBuffer,
      byteOffset: c[0].byteOffset,
      byteLength: c[0].byteLength
    };
  }
  const l = n.json.images || [];
  n.images = new Array(l.length).fill({});
}
async function C9(n, e, t) {
  const i = n.json.buffers || [];
  for (let c = 0; c < i.length; ++c) {
    const a = i[c];
    if (a.uri) {
      var r, l;
      const {
        fetch: g
      } = t;
      el(g);
      const y = wS(a.uri, e), A = await (t == null || (r = t.fetch) === null || r === void 0 ? void 0 : r.call(t, y)), C = await (A == null || (l = A.arrayBuffer) === null || l === void 0 ? void 0 : l.call(A));
      n.buffers[c] = {
        arrayBuffer: C,
        byteOffset: 0,
        byteLength: C.byteLength
      }, delete a.uri;
    } else n.buffers[c] === null && (n.buffers[c] = {
      arrayBuffer: new ArrayBuffer(a.byteLength),
      byteOffset: 0,
      byteLength: a.byteLength
    });
  }
}
async function P9(n, e, t) {
  const i = I9(n), r = n.json.images || [], l = [];
  for (const c of i)
    l.push(M9(n, r[c], c, e, t));
  return await Promise.all(l);
}
function I9(n) {
  const e = /* @__PURE__ */ new Set(), t = n.json.textures || [];
  for (const i of t)
    i.source !== void 0 && e.add(i.source);
  return Array.from(e).sort();
}
async function M9(n, e, t, i, r) {
  const {
    fetch: l,
    parse: c
  } = r;
  let a;
  if (e.uri && !e.hasOwnProperty("bufferView")) {
    const y = wS(e.uri, i);
    a = await (await l(y)).arrayBuffer(), e.bufferView = {
      data: a
    };
  }
  if (Number.isFinite(e.bufferView)) {
    const y = g7(n.json, n.buffers, e.bufferView);
    a = W1(y.buffer, y.byteOffset, y.byteLength);
  }
  el(a, "glTF image has no data");
  let g = await c(a, [OT, p7], {
    mimeType: e.mimeType,
    basis: i.basis || {
      format: xS()
    }
  }, r);
  g && g[0] && (g = {
    compressed: !0,
    mipmaps: !1,
    width: g[0].width,
    height: g[0].height,
    data: g[0]
  }), n.images = n.images || [], n.images[t] = g;
}
const Op = {
  name: "glTF",
  id: "gltf",
  module: "gltf",
  version: Jz,
  extensions: ["gltf", "glb"],
  mimeTypes: ["model/gltf+json", "model/gltf-binary"],
  text: !0,
  binary: !0,
  tests: ["glTF"],
  parse: L9,
  options: {
    gltf: {
      normalize: !0,
      loadBuffers: !0,
      loadImages: !0,
      decompressMeshes: !0,
      postProcess: !0
    },
    log: console
  },
  deprecatedOptions: {
    fetchImages: "gltf.loadImages",
    createImages: "gltf.loadImages",
    decompress: "gltf.decompressMeshes",
    postProcess: "gltf.postProcess",
    gltf: {
      decompress: "gltf.decompressMeshes"
    }
  }
};
async function L9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, t = arguments.length > 2 ? arguments[2] : void 0;
  e = {
    ...Op.options,
    ...e
  }, e.gltf = {
    ...Op.options.gltf,
    ...e.gltf
  };
  const {
    byteOffset: i = 0
  } = e;
  return await E9({}, n, i, e, t);
}
async function R9(n) {
  const e = [];
  return n.scenes.forEach((t) => {
    t.traverse((i) => {
      Object.values(i.model.getUniforms()).forEach((r) => {
        r.loaded === !1 && e.push(r);
      });
    });
  }), await B9(() => e.some((t) => !t.loaded));
}
async function B9(n) {
  for (; n(); )
    await new Promise((e) => requestAnimationFrame(e));
}
const O9 = `#version 300 es
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
in vec3 instanceTranslation;
uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform mat4 sceneModelMatrix;
uniform bool composeModelMatrix;
in vec4 POSITION;

#ifdef HAS_UV
  in vec2 TEXCOORD_0;
#endif

#ifdef MODULE_PBR
  #ifdef HAS_NORMALS
    in vec4 NORMAL;
  #endif
#endif
out vec4 vColor;
#ifndef MODULE_PBR
  #ifdef HAS_UV
    out vec2 vTEXCOORD_0;
  #endif
#endif
void main(void) {
  #if defined(HAS_UV) && !defined(MODULE_PBR)
    vTEXCOORD_0 = TEXCOORD_0;
    geometry.uv = vTEXCOORD_0;
  #endif

  geometry.worldPosition = instancePositions;
  geometry.pickingColor = instancePickingColors;

  vec3 normal = vec3(0.0, 0.0, 1.0);
  #ifdef MODULE_PBR
    #ifdef HAS_NORMALS
      normal = instanceModelMatrix * (sceneModelMatrix * vec4(NORMAL.xyz, 0.0)).xyz;
    #endif
  #endif

  float originalSize = project_size_to_pixel(sizeScale);
  float clampedSize = clamp(originalSize, sizeMinPixels, sizeMaxPixels);

  vec3 pos = (instanceModelMatrix * (sceneModelMatrix * POSITION).xyz) * sizeScale * (clampedSize / originalSize) + instanceTranslation;
  if(composeModelMatrix) {
    DECKGL_FILTER_SIZE(pos, geometry);
    geometry.normal = project_normal(normal);
    geometry.worldPosition += pos;
    gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
  }
  else {
    pos = project_size(pos);
    DECKGL_FILTER_SIZE(pos, geometry);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
    geometry.normal = project_normal(normal);
  }
  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = TEXCOORD_0;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  vColor = instanceColors;
  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, D9 = `#version 300 es
uniform float opacity;
in vec4 vColor;

out vec4 fragmentColor;
#ifndef MODULE_PBR
  #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
    in vec2 vTEXCOORD_0;
    uniform sampler2D u_BaseColorSampler;
  #endif
#endif

void main(void) {
  #ifdef MODULE_PBR
    fragmentColor = vColor * pbr_filterColor(vec4(0));
    geometry.uv = pbr_vUV;
  #else
    #if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
      fragmentColor = vColor * texture2D(u_BaseColorSampler, vTEXCOORD_0);
      geometry.uv = vTEXCOORD_0;
    #else
      fragmentColor = vColor;
    #endif
  #endif

  fragmentColor.a *= opacity;
  DECKGL_FILTER_COLOR(fragmentColor, geometry);
}
`, BS = [255, 255, 255, 255], F9 = {
  scenegraph: {
    type: "object",
    value: null,
    async: !0
  },
  getScene: (n) => n && n.scenes ? typeof n.scene == "object" ? n.scene : n.scenes[n.scene || 0] : n,
  getAnimator: (n) => n && n.animator,
  _animations: null,
  sizeScale: {
    type: "number",
    value: 1,
    min: 0
  },
  sizeMinPixels: {
    type: "number",
    min: 0,
    value: 0
  },
  sizeMaxPixels: {
    type: "number",
    min: 0,
    value: Number.MAX_SAFE_INTEGER
  },
  getPosition: {
    type: "accessor",
    value: (n) => n.position
  },
  getColor: {
    type: "accessor",
    value: BS
  },
  _lighting: "flat",
  _imageBasedLightingEnvironment: null,
  getOrientation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getScale: {
    type: "accessor",
    value: [1, 1, 1]
  },
  getTranslation: {
    type: "accessor",
    value: [0, 0, 0]
  },
  getTransformMatrix: {
    type: "accessor",
    value: []
  },
  loaders: [Op]
};
class Hb extends _f {
  constructor() {
    super(...arguments), H(this, "state", void 0);
  }
  getShaders() {
    const e = [Sb, Cb];
    return this.props._lighting === "pbr" && e.push(bb), super.getShaders({
      vs: O9,
      fs: D9,
      modules: e
    });
  }
  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        type: 5130,
        fp64: this.use64bitPositions(),
        accessor: "getPosition",
        transition: !0
      },
      instanceColors: {
        type: 5121,
        size: this.props.colorFormat.length,
        accessor: "getColor",
        normalized: !0,
        defaultValue: BS,
        transition: !0
      },
      instanceModelMatrix: uS
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: i
    } = e;
    t.scenegraph !== i.scenegraph ? this._updateScenegraph() : t._animations !== i._animations && this._applyAnimationsProp(this.state.scenegraph, this.state.animator, t._animations);
  }
  finalizeState(e) {
    super.finalizeState(e), this._deleteScenegraph();
  }
  get isLoaded() {
    var e;
    return ((e = this.state) === null || e === void 0 ? void 0 : e.scenegraph) && super.isLoaded;
  }
  _updateScenegraph() {
    const e = this.props, {
      gl: t
    } = this.context;
    let i = null;
    if (e.scenegraph instanceof Yd)
      i = {
        scenes: [e.scenegraph]
      };
    else if (e.scenegraph && !e.scenegraph.gltf) {
      const a = e.scenegraph, g = Yz(t, a, this._getModelOptions());
      i = {
        gltf: a,
        ...g
      }, R9(g).then(() => this.setNeedsRedraw());
    } else e.scenegraph && (zi.deprecated("ScenegraphLayer.props.scenegraph", "Use GLTFLoader instead of GLTFScenegraphLoader")(), i = e.scenegraph);
    const r = {
      layer: this,
      gl: t
    }, l = e.getScene(i, r), c = e.getAnimator(i, r);
    l instanceof Yd ? (this._deleteScenegraph(), this._applyAllAttributes(l), this._applyAnimationsProp(l, c, e._animations), this.setState({
      scenegraph: l,
      animator: c
    })) : l !== null && zi.warn("invalid scenegraph:", l)();
  }
  _applyAllAttributes(e) {
    if (this.state.attributesAvailable) {
      const t = this.getAttributeManager().getAttributes();
      e.traverse((i) => {
        this._setModelAttributes(i.model, t);
      });
    }
  }
  _applyAnimationsProp(e, t, i) {
    if (!e || !t || !i)
      return;
    const r = t.getAnimations();
    Object.keys(i).sort().forEach((l) => {
      const c = i[l];
      if (l === "*")
        r.forEach((a) => {
          Object.assign(a, c);
        });
      else if (Number.isFinite(Number(l))) {
        const a = Number(l);
        a >= 0 && a < r.length ? Object.assign(r[a], c) : zi.warn("animation ".concat(l, " not found"))();
      } else {
        const a = r.find((g) => {
          let {
            name: y
          } = g;
          return y === l;
        });
        a ? Object.assign(a, c) : zi.warn("animation ".concat(l, " not found"))();
      }
    });
  }
  _deleteScenegraph() {
    const {
      scenegraph: e
    } = this.state;
    e instanceof Yd && e.delete();
  }
  _getModelOptions() {
    const {
      _imageBasedLightingEnvironment: e
    } = this.props;
    let t = null;
    return e && (typeof e == "function" ? t = e({
      gl: this.context.gl,
      layer: this
    }) : t = e), {
      gl: this.context.gl,
      waitForFullLoad: !0,
      imageBasedLightingEnvironment: t,
      modelOptions: {
        isInstanced: !0,
        transpileToGLSL100: !Si(this.context.gl),
        ...this.getShaders()
      },
      useTangents: !1
    };
  }
  updateAttributes(e) {
    this.setState({
      attributesAvailable: !0
    }), this.state.scenegraph && this.state.scenegraph.traverse((t) => {
      this._setModelAttributes(t.model, e);
    });
  }
  draw(e) {
    let {
      moduleParameters: t = null,
      parameters: i = {},
      context: r
    } = e;
    if (!this.state.scenegraph) return;
    this.props._animations && this.state.animator && (this.state.animator.animate(r.timeline.getTime()), this.setNeedsRedraw());
    const {
      viewport: l
    } = this.context, {
      sizeScale: c,
      sizeMinPixels: a,
      sizeMaxPixels: g,
      opacity: y,
      coordinateSystem: A
    } = this.props, C = this.getNumInstances();
    this.state.scenegraph.traverse((I, S) => {
      let {
        worldMatrix: F
      } = S;
      I.model.setInstanceCount(C), I.updateModuleSettings(t), I.draw({
        parameters: i,
        uniforms: {
          sizeScale: c,
          opacity: y,
          sizeMinPixels: a,
          sizeMaxPixels: g,
          composeModelMatrix: hS(l, A),
          sceneModelMatrix: F,
          u_Camera: I.model.getUniforms().project_uCameraPosition
        }
      });
    });
  }
}
H(Hb, "defaultProps", F9);
H(Hb, "layerName", "ScenegraphLayer");
const N9 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
uniform float sizeScale;
uniform bool composeModelMatrix;
uniform bool pickFeatureIds;
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec4 uvRegions;
in vec3 featureIdsPickingColors;
in vec4 instanceColors;
in vec3 instancePickingColors;
in mat3 instanceModelMatrix;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;

vec2 applyUVRegion(vec2 uv) {
  #ifdef HAS_UV_REGIONS
    return fract(uv) * (uvRegions.zw - uvRegions.xy) + uvRegions.xy;
  #else
    return uv;
  #endif
}

void main(void) {
  vec2 uv = applyUVRegion(texCoords);
  geometry.uv = uv;

  if (pickFeatureIds) {
    geometry.pickingColor = featureIdsPickingColors;
  } else {
    geometry.pickingColor = instancePickingColors;
  }

  vTexCoord = uv;
  cameraPosition = project_uCameraPosition;
  vColor = vec4(colors * instanceColors.rgb, instanceColors.a);

  vec3 pos = (instanceModelMatrix * positions) * sizeScale;
  vec3 projectedPosition = project_position(positions);
  position_commonspace = vec4(projectedPosition, 1.0);
  gl_Position = project_common_position_to_clipspace(position_commonspace);

  geometry.position = position_commonspace;
  normals_commonspace = project_normal(instanceModelMatrix * normals);
  geometry.normal = normals_commonspace;

  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);

  #ifdef MODULE_PBR
    pbr_vPosition = geometry.position.xyz;
    #ifdef HAS_NORMALS
      pbr_vNormal = geometry.normal;
    #endif

    #ifdef HAS_UV
      pbr_vUV = uv;
    #else
      pbr_vUV = vec2(0., 0.);
    #endif
    geometry.uv = pbr_vUV;
  #endif

  DECKGL_FILTER_COLOR(vColor, geometry);
}
`, k9 = `#version 300 es
#define SHADER_NAME simple-mesh-layer-fs

precision highp float;

uniform bool hasTexture;
uniform sampler2D sampler;
uniform bool flatShading;
uniform float opacity;

in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;

out vec4 fragColor;

void main(void) {
  
#ifdef MODULE_PBR

  fragColor = vColor * pbr_filterColor(vec4(0));
  geometry.uv = pbr_vUV;
  fragColor.a *= opacity;

#else

  geometry.uv = vTexCoord;

  vec3 normal;
  if (flatShading) {
#ifdef DERIVATIVES_AVAILABLE
    normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif
  } else {
    normal = normals_commonspace;
  }

  vec4 color = hasTexture ? texture(sampler, vTexCoord) : vColor;
  vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
  fragColor = vec4(lightColor, color.a * opacity);

#endif

  DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;
function z9(n) {
  n.COLOR_0 || n.colors || (n.colors = {
    constant: !0,
    value: new Float32Array([1, 1, 1])
  });
}
const U9 = {
  pbrMaterial: {
    type: "object",
    value: null
  },
  featureIds: {
    type: "array",
    value: null,
    optional: !0
  }
};
class Wb extends zb {
  getShaders() {
    const e = super.getShaders();
    return e.modules.push(bb), {
      ...e,
      vs: N9,
      fs: k9
    };
  }
  initializeState() {
    const {
      featureIds: e
    } = this.props;
    super.initializeState();
    const t = this.getAttributeManager();
    e && t.add({
      featureIdsPickingColors: {
        type: 5121,
        size: 3,
        noAlloc: !0,
        update: this.calculateFeatureIdsPickingColors
      }
    });
  }
  updateState(e) {
    super.updateState(e);
    const {
      props: t,
      oldProps: i
    } = e;
    t.pbrMaterial !== i.pbrMaterial && this.updatePbrMaterialUniforms(t.pbrMaterial);
  }
  draw(e) {
    const {
      featureIds: t
    } = this.props;
    this.state.model && (this.state.model.setUniforms({
      u_Camera: this.state.model.getUniforms().project_uCameraPosition,
      pickFeatureIds: !!t
    }), super.draw(e));
  }
  getModel(e) {
    const {
      id: t,
      pbrMaterial: i
    } = this.props, r = this.parseMaterial(i, e);
    this.setState({
      materialParser: r
    });
    const l = this.getShaders();
    return z9(e.attributes), new cf(this.context.gl, {
      ...this.getShaders(),
      id: t,
      geometry: e,
      defines: {
        ...l.defines,
        ...r == null ? void 0 : r.defines,
        HAS_UV_REGIONS: e.attributes.uvRegions
      },
      parameters: r == null ? void 0 : r.parameters,
      isInstanced: !0
    });
  }
  updatePbrMaterialUniforms(e) {
    const {
      model: t
    } = this.state;
    if (t) {
      const {
        mesh: i
      } = this.props, r = this.parseMaterial(e, i);
      this.setState({
        materialParser: r
      }), t.setUniforms(r.uniforms);
    }
  }
  parseMaterial(e, t) {
    var i;
    const r = !!(e.pbrMetallicRoughness && e.pbrMetallicRoughness.baseColorTexture);
    return (i = this.state.materialParser) === null || i === void 0 || i.delete(), new yS(this.context.gl, {
      attributes: {
        NORMAL: t.attributes.normals,
        TEXCOORD_0: t.attributes.texCoords
      },
      material: {
        unlit: r,
        ...e
      },
      pbrDebug: !1,
      imageBasedLightingEnvironment: null,
      lights: !0,
      useTangents: !1
    });
  }
  calculateFeatureIdsPickingColors(e) {
    const t = this.props.featureIds, i = new Uint8ClampedArray(t.length * e.size), r = [];
    for (let l = 0; l < t.length; l++)
      this.encodePickingColor(t[l], r), i[l * 3] = r[0], i[l * 3 + 1] = r[1], i[l * 3 + 2] = r[2];
    e.value = i;
  }
  finalizeState(e) {
    var t;
    super.finalizeState(e), (t = this.state.materialParser) === null || t === void 0 || t.delete(), this.setState({
      materialParser: null
    });
  }
}
H(Wb, "layerName", "MeshLayer");
H(Wb, "defaultProps", U9);
const j9 = 6378137, G9 = 6378137, V9 = 6356752314245179e-9;
function r_(n) {
  return n;
}
new Tt();
function q9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : r_;
  return "longitude" in n ? (e[0] = t(n.longitude), e[1] = t(n.latitude), e[2] = n.height) : "x" in n ? (e[0] = t(n.x), e[1] = t(n.y), e[2] = n.z) : (e[0] = t(n[0]), e[1] = t(n[1]), e[2] = n[2]), e;
}
function H9(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return q9(n, e, Gs._cartographicRadians ? r_ : qO);
}
function W9(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : r_;
  return "longitude" in e ? (e.longitude = t(n[0]), e.latitude = t(n[1]), e.height = n[2]) : "x" in e ? (e.x = t(n[0]), e.y = t(n[1]), e.z = n[2]) : (e[0] = t(n[0]), e[1] = t(n[1]), e[2] = n[2]), e;
}
function Z9(n, e) {
  return W9(n, e, Gs._cartographicRadians ? r_ : HO);
}
const Od = new Tt(), $9 = new Tt(), X9 = new Tt();
function Y9(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
  const {
    oneOverRadii: i,
    oneOverRadiiSquared: r,
    centerToleranceSquared: l
  } = e;
  Od.from(n);
  const c = Od.x, a = Od.y, g = Od.z, y = i.x, A = i.y, C = i.z, I = c * c * y * y, S = a * a * A * A, F = g * g * C * C, U = I + S + F, V = Math.sqrt(1 / U);
  if (!Number.isFinite(V))
    return;
  const W = $9;
  if (W.copy(n).scale(V), U < l)
    return W.to(t);
  const X = r.x, de = r.y, ie = r.z, fe = X9;
  fe.set(W.x * X * 2, W.y * de * 2, W.z * ie * 2);
  let Ae = (1 - V) * Od.len() / (0.5 * fe.len()), Te = 0, me, Ge, ke, pe;
  do {
    Ae -= Te, me = 1 / (1 + Ae * X), Ge = 1 / (1 + Ae * de), ke = 1 / (1 + Ae * ie);
    const _e = me * me, De = Ge * Ge, Me = ke * ke, St = _e * me, dt = De * Ge, Pt = Me * ke;
    pe = I * _e + S * De + F * Me - 1;
    const Rt = -2 * (I * St * X + S * dt * de + F * Pt * ie);
    Te = pe / Rt;
  } while (Math.abs(pe) > Mp.EPSILON12);
  return Od.scale([me, Ge, ke]).to(t);
}
const MA = 1e-14, J9 = new Tt(), LA = {
  up: {
    south: "east",
    north: "west",
    west: "south",
    east: "north"
  },
  down: {
    south: "west",
    north: "east",
    west: "north",
    east: "south"
  },
  south: {
    up: "west",
    down: "east",
    west: "down",
    east: "up"
  },
  north: {
    up: "east",
    down: "west",
    west: "up",
    east: "down"
  },
  west: {
    up: "north",
    down: "south",
    north: "down",
    south: "up"
  },
  east: {
    up: "south",
    down: "north",
    north: "up",
    south: "down"
  }
}, Y0 = {
  north: [-1, 0, 0],
  east: [0, 1, 0],
  up: [0, 0, 1],
  south: [1, 0, 0],
  west: [0, -1, 0],
  down: [0, 0, -1]
}, ip = {
  east: new Tt(),
  north: new Tt(),
  up: new Tt(),
  west: new Tt(),
  south: new Tt(),
  down: new Tt()
}, K9 = new Tt(), Q9 = new Tt(), ej = new Tt();
function RA(n, e, t, i, r, l) {
  const c = LA[e] && LA[e][t];
  gc(c && (!i || i === c));
  let a, g, y;
  const A = J9.copy(r);
  if (bc(A.x, 0, MA) && bc(A.y, 0, MA)) {
    const I = Math.sign(A.z);
    a = K9.fromArray(Y0[e]), e !== "east" && e !== "west" && a.scale(I), g = Q9.fromArray(Y0[t]), t !== "east" && t !== "west" && g.scale(I), y = ej.fromArray(Y0[i]), i !== "east" && i !== "west" && y.scale(I);
  } else {
    const {
      up: I,
      east: S,
      north: F
    } = ip;
    S.set(-A.y, A.x, 0).normalize(), n.geodeticSurfaceNormal(A, I), F.copy(I).cross(S);
    const {
      down: U,
      west: V,
      south: W
    } = ip;
    U.copy(I).scale(-1), V.copy(S).scale(-1), W.copy(F).scale(-1), a = ip[e], g = ip[t], y = ip[i];
  }
  return l[0] = a.x, l[1] = a.y, l[2] = a.z, l[3] = 0, l[4] = g.x, l[5] = g.y, l[6] = g.z, l[7] = 0, l[8] = y.x, l[9] = y.y, l[10] = y.z, l[11] = 0, l[12] = A.x, l[13] = A.y, l[14] = A.z, l[15] = 1, l;
}
const Hg = new Tt(), BA = new Tt(), tj = new Tt(), ac = new Tt(), nj = new Tt(), Wg = new Tt();
class qr {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    H(this, "radii", void 0), H(this, "radiiSquared", void 0), H(this, "radiiToTheFourth", void 0), H(this, "oneOverRadii", void 0), H(this, "oneOverRadiiSquared", void 0), H(this, "minimumRadius", void 0), H(this, "maximumRadius", void 0), H(this, "centerToleranceSquared", Mp.EPSILON1), H(this, "squaredXOverSquaredZ", void 0), gc(e >= 0), gc(t >= 0), gc(i >= 0), this.radii = new Tt(e, t, i), this.radiiSquared = new Tt(e * e, t * t, i * i), this.radiiToTheFourth = new Tt(e * e * e * e, t * t * t * t, i * i * i * i), this.oneOverRadii = new Tt(e === 0 ? 0 : 1 / e, t === 0 ? 0 : 1 / t, i === 0 ? 0 : 1 / i), this.oneOverRadiiSquared = new Tt(e === 0 ? 0 : 1 / (e * e), t === 0 ? 0 : 1 / (t * t), i === 0 ? 0 : 1 / (i * i)), this.minimumRadius = Math.min(e, t, i), this.maximumRadius = Math.max(e, t, i), this.radiiSquared.z !== 0 && (this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z), Object.freeze(this);
  }
  equals(e) {
    return this === e || !!(e && this.radii.equals(e.radii));
  }
  toString() {
    return this.radii.toString();
  }
  cartographicToCartesian(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const i = BA, r = tj, [, , l] = e;
    this.geodeticSurfaceNormalCartographic(e, i), r.copy(this.radiiSquared).scale(i);
    const c = Math.sqrt(i.dot(r));
    return r.scale(1 / c), i.scale(l), r.add(i), r.to(t);
  }
  cartesianToCartographic(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    Wg.from(e);
    const i = this.scaleToGeodeticSurface(Wg, ac);
    if (!i)
      return;
    const r = this.geodeticSurfaceNormal(i, BA), l = nj;
    l.copy(Wg).subtract(i);
    const c = Math.atan2(r.y, r.x), a = Math.asin(r.z), g = Math.sign(pb(l, Wg)) * mE(l);
    return Z9([c, a, g], t);
  }
  eastNorthUpToFixedFrame(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Mi();
    return RA(this, "east", "north", "up", e, t);
  }
  localFrameToFixedFrame(e, t, i, r) {
    let l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : new Mi();
    return RA(this, e, t, i, r, l);
  }
  geocentricSurfaceNormal(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return Hg.from(e).normalize().to(t);
  }
  geodeticSurfaceNormalCartographic(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    const i = H9(e), r = i[0], l = i[1], c = Math.cos(l);
    return Hg.set(c * Math.cos(r), c * Math.sin(r), Math.sin(l)).normalize(), Hg.to(t);
  }
  geodeticSurfaceNormal(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return Hg.from(e).scale(this.oneOverRadiiSquared).normalize().to(t);
  }
  scaleToGeodeticSurface(e, t) {
    return Y9(e, this, t);
  }
  scaleToGeocentricSurface(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    ac.from(e);
    const i = ac.x, r = ac.y, l = ac.z, c = this.oneOverRadiiSquared, a = 1 / Math.sqrt(i * i * c.x + r * r * c.y + l * l * c.z);
    return ac.multiplyScalar(a).to(t);
  }
  transformPositionToScaledSpace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return ac.from(e).scale(this.oneOverRadii).to(t);
  }
  transformPositionFromScaledSpace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
    return ac.from(e).scale(this.radii).to(t);
  }
  getSurfaceNormalIntersectionWithZAxis(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [0, 0, 0];
    gc(bc(this.radii.x, this.radii.y, Mp.EPSILON15)), gc(this.radii.z > 0), ac.from(e);
    const r = ac.z * (1 - this.squaredXOverSquaredZ);
    if (!(Math.abs(r) >= this.radii.z - t))
      return ac.set(0, 0, r).to(i);
  }
}
H(qr, "WGS84", new qr(j9, G9, V9));
class ij {
  constructor(e, t, i) {
    H(this, "item", void 0), H(this, "previous", void 0), H(this, "next", void 0), this.item = e, this.previous = t, this.next = i;
  }
}
class rj {
  constructor() {
    H(this, "head", null), H(this, "tail", null), H(this, "_length", 0);
  }
  get length() {
    return this._length;
  }
  add(e) {
    const t = new ij(e, this.tail, null);
    return this.tail ? (this.tail.next = t, this.tail = t) : (this.head = t, this.tail = t), ++this._length, t;
  }
  remove(e) {
    e && (e.previous && e.next ? (e.previous.next = e.next, e.next.previous = e.previous) : e.previous ? (e.previous.next = null, this.tail = e.previous) : e.next ? (e.next.previous = null, this.head = e.next) : (this.head = null, this.tail = null), e.next = null, e.previous = null, --this._length);
  }
  splice(e, t) {
    e !== t && (this.remove(t), this._insert(e, t));
  }
  _insert(e, t) {
    const i = e.next;
    e.next = t, this.tail === e ? this.tail = t : i.previous = t, t.next = i, t.previous = e, ++this._length;
  }
}
class sj {
  constructor() {
    H(this, "_list", void 0), H(this, "_sentinel", void 0), H(this, "_trimTiles", void 0), this._list = new rj(), this._sentinel = this._list.add("sentinel"), this._trimTiles = !1;
  }
  reset() {
    this._list.splice(this._list.tail, this._sentinel);
  }
  touch(e) {
    const t = e._cacheNode;
    t && this._list.splice(this._sentinel, t);
  }
  add(e, t, i) {
    t._cacheNode || (t._cacheNode = this._list.add(t), i && i(e, t));
  }
  unloadTile(e, t, i) {
    const r = t._cacheNode;
    r && (this._list.remove(r), t._cacheNode = null, i && i(e, t));
  }
  unloadTiles(e, t) {
    const i = this._trimTiles;
    this._trimTiles = !1;
    const r = this._list, l = e.maximumMemoryUsage * 1024 * 1024, c = this._sentinel;
    let a = r.head;
    for (; a !== c && (e.gpuMemoryUsageInBytes > l || i); ) {
      const g = a.item;
      a = a.next, this.unloadTile(e, g, t);
    }
  }
  trim() {
    this._trimTiles = !0;
  }
}
function oj(n, e) {
  _r(n), _r(e);
  const {
    rtcCenter: t,
    gltfUpAxis: i
  } = e, {
    computedTransform: r,
    boundingVolume: {
      center: l
    }
  } = n;
  let c = new Mi(r);
  switch (t && c.translate(t), i) {
    case "Z":
      break;
    case "Y":
      const C = new Mi().rotateX(Math.PI / 2);
      c = c.multiplyRight(C);
      break;
    case "X":
      const I = new Mi().rotateY(-Math.PI / 2);
      c = c.multiplyRight(I);
      break;
  }
  e.isQuantized && c.translate(e.quantizedVolumeOffset).scale(e.quantizedVolumeScale);
  const a = new Tt(l);
  e.cartesianModelMatrix = c, e.cartesianOrigin = a;
  const g = qr.WGS84.cartesianToCartographic(a, new Tt()), A = qr.WGS84.eastNorthUpToFixedFrame(a).invert();
  e.cartographicModelMatrix = A.multiplyRight(c), e.cartographicOrigin = g, e.coordinateSystem || (e.modelMatrix = e.cartographicModelMatrix);
}
const OA = new Tt(), J0 = new Tt(), f1 = new El([new pc(), new pc(), new pc(), new pc(), new pc(), new pc()]);
function aj(n, e) {
  const {
    cameraDirection: t,
    cameraUp: i,
    height: r
  } = n, {
    metersPerUnit: l
  } = n.distanceScales, c = hm(n, n.center), a = qr.WGS84.eastNorthUpToFixedFrame(c), g = n.unprojectPosition(n.cameraPosition), y = qr.WGS84.cartographicToCartesian(g, new Tt()), A = new Tt(a.transformAsVector(new Tt(t).scale(l))).normalize(), C = new Tt(a.transformAsVector(new Tt(i).scale(l))).normalize();
  cj(n);
  const I = n.constructor, {
    longitude: S,
    latitude: F,
    width: U,
    bearing: V,
    zoom: W
  } = n, X = new I({
    longitude: S,
    latitude: F,
    height: r,
    width: U,
    bearing: V,
    zoom: W,
    pitch: 0
  });
  return {
    camera: {
      position: y,
      direction: A,
      up: C
    },
    viewport: n,
    topDownViewport: X,
    height: r,
    cullingVolume: f1,
    frameNumber: e,
    sseDenominator: 1.15
  };
}
function lj(n, e, t) {
  if (t === 0 || n.length <= t)
    return [n, []];
  const i = [], {
    longitude: r,
    latitude: l
  } = e.viewport;
  for (const [y, A] of n.entries()) {
    const [C, I] = A.header.mbs, S = Math.abs(r - C), F = Math.abs(l - I), U = Math.sqrt(F * F + S * S);
    i.push([y, U]);
  }
  const c = i.sort((y, A) => y[1] - A[1]), a = [];
  for (let y = 0; y < t; y++)
    a.push(n[c[y][0]]);
  const g = [];
  for (let y = t; y < c.length; y++)
    g.push(n[c[y][0]]);
  return [a, g];
}
function cj(n) {
  const e = n.getFrustumPlanes(), t = DA(e.near, n.cameraPosition), i = hm(n, t), r = hm(n, n.cameraPosition, J0);
  let l = 0;
  f1.planes[l++].fromPointNormal(i, OA.copy(i).subtract(r));
  for (const c in e) {
    if (c === "near")
      continue;
    const a = e[c], g = DA(a, t, J0), y = hm(n, g, J0);
    f1.planes[l++].fromPointNormal(y, OA.copy(i).subtract(y));
  }
}
function DA(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Tt();
  const i = n.normal.dot(e);
  return t.copy(n.normal).scale(n.distance - i).add(e), t;
}
function hm(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : new Tt();
  const i = n.unprojectPosition(e);
  return qr.WGS84.cartographicToCartesian(i, t);
}
const uj = 6378137, hj = 6378137, p1 = 6356752314245179e-9, FA = new Tt();
function dj(n, e) {
  if (n instanceof Kp) {
    const {
      halfAxes: t
    } = n, i = pj(t);
    return Math.log2(p1 / (i + e[2]));
  } else if (n instanceof Jp) {
    const {
      radius: t
    } = n;
    return Math.log2(p1 / (t + e[2]));
  } else if (n.width && n.height) {
    const {
      width: t,
      height: i
    } = n, r = Math.log2(uj / t), l = Math.log2(hj / i);
    return (r + l) / 2;
  }
  return 1;
}
function OS(n, e, t) {
  const i = qr.WGS84.cartographicToCartesian([n.xmax, n.ymax, n.zmax], new Tt()), r = Math.sqrt(Math.pow(i[0] - t[0], 2) + Math.pow(i[1] - t[1], 2) + Math.pow(i[2] - t[2], 2));
  return Math.log2(p1 / (r + e[2]));
}
function fj(n, e, t) {
  const [i, r, l, c] = n;
  return OS({
    xmin: i,
    xmax: l,
    ymin: r,
    ymax: c,
    zmin: 0,
    zmax: 0
  }, e, t);
}
function pj(n) {
  n.getColumn(0, FA);
  const e = n.getColumn(1), t = n.getColumn(2);
  return FA.add(e).add(t).len();
}
const Ja = {
  UNLOADED: 0,
  LOADING: 1,
  PROCESSING: 2,
  READY: 3,
  EXPIRED: 4,
  FAILED: 5
}, Lu = {
  ADD: 1,
  REPLACE: 2
}, Jd = {
  EMPTY: "empty",
  SCENEGRAPH: "scenegraph",
  POINTCLOUD: "pointcloud",
  MESH: "mesh"
}, wl = {
  I3S: "I3S",
  TILES3D: "TILES3D"
}, s_ = {
  GEOMETRIC_ERROR: "geometricError",
  MAX_SCREEN_THRESHOLD: "maxScreenThreshold"
}, gj = {
  NOT_COMPUTED: -1,
  USE_OPTIMIZATION: 1,
  SKIP_OPTIMIZATION: 0
};
function DS(n) {
  return n != null;
}
const qo = new Tt(), dm = new Tt(), mj = new Tt(), _j = new Tt();
function K0(n, e, t) {
  if (_r(n, "3D Tile: boundingVolume must be defined"), n.box)
    return bj(n.box, e, t);
  if (n.region) {
    const [i, r, l, c, a, g] = n.region, y = qr.WGS84.cartographicToCartesian([Cu(i), Cu(c), a], mj), A = qr.WGS84.cartographicToCartesian([Cu(l), Cu(r), g], _j), C = new Tt().addVectors(y, A).multiplyScalar(0.5), I = new Tt().subVectors(y, A).len() / 2;
    return NA([C[0], C[1], C[2], I], new Mi());
  }
  if (n.sphere)
    return NA(n.sphere, e, t);
  throw new Error("3D Tile: boundingVolume must contain a sphere, region, or box");
}
function yj(n, e) {
  if (n.box)
    return vj(e);
  if (n.region) {
    const [t, i, r, l, c, a] = n.region;
    return [[Cu(t), Cu(i), c], [Cu(r), Cu(l), a]];
  }
  if (n.sphere)
    return xj(e);
  throw new Error("Unkown boundingVolume type");
}
function bj(n, e, t) {
  const i = new Tt(n[0], n[1], n[2]);
  e.transform(i, i);
  let r = [];
  if (n.length === 10) {
    const y = n.slice(3, 6), A = new Ip();
    A.fromArray(n, 6);
    const C = new Tt([1, 0, 0]), I = new Tt([0, 1, 0]), S = new Tt([0, 0, 1]);
    C.transformByQuaternion(A), C.scale(y[0]), I.transformByQuaternion(A), I.scale(y[1]), S.transformByQuaternion(A), S.scale(y[2]), r = [...C.toArray(), ...I.toArray(), ...S.toArray()];
  } else
    r = [...n.slice(3, 6), ...n.slice(6, 9), ...n.slice(9, 12)];
  const l = e.transformAsVector(r.slice(0, 3)), c = e.transformAsVector(r.slice(3, 6)), a = e.transformAsVector(r.slice(6, 9)), g = new ss([l[0], l[1], l[2], c[0], c[1], c[2], a[0], a[1], a[2]]);
  return DS(t) ? (t.center = i, t.halfAxes = g, t) : new Kp(i, g);
}
function NA(n, e, t) {
  const i = new Tt(n[0], n[1], n[2]);
  e.transform(i, i);
  const r = e.getScale(dm), l = Math.max(Math.max(r[0], r[1]), r[2]), c = n[3] * l;
  return DS(t) ? (t.center = i, t.radius = c, t) : new Jp(i, c);
}
function vj(n) {
  const e = FS(), {
    halfAxes: t
  } = n, i = new Tt(t.getColumn(0)), r = new Tt(t.getColumn(1)), l = new Tt(t.getColumn(2));
  for (let c = 0; c < 2; c++) {
    for (let a = 0; a < 2; a++) {
      for (let g = 0; g < 2; g++)
        qo.copy(n.center), qo.add(i), qo.add(r), qo.add(l), NS(e, qo), l.negate();
      r.negate();
    }
    i.negate();
  }
  return e;
}
function xj(n) {
  const e = FS(), {
    center: t,
    radius: i
  } = n, r = qr.WGS84.scaleToGeodeticSurface(t, qo);
  let l;
  r ? l = qr.WGS84.geodeticSurfaceNormal(r) : l = new Tt(0, 0, 1);
  let c = new Tt(l[2], -l[1], 0);
  c.len() > 0 ? c.normalize() : c = new Tt(0, 1, 0);
  const a = c.clone().cross(l);
  for (const g of [c, a, l]) {
    dm.copy(g).scale(i);
    for (let y = 0; y < 2; y++)
      qo.copy(t), qo.add(dm), NS(e, qo), dm.negate();
  }
  return e;
}
function FS() {
  return [[1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]];
}
function NS(n, e) {
  qr.WGS84.cartesianToCartographic(e, qo), n[0][0] = Math.min(n[0][0], qo[0]), n[0][1] = Math.min(n[0][1], qo[1]), n[0][2] = Math.min(n[0][2], qo[2]), n[1][0] = Math.max(n[1][0], qo[0]), n[1][1] = Math.max(n[1][1], qo[1]), n[1][2] = Math.max(n[1][2], qo[2]);
}
new Tt();
new Tt();
new Mi();
new Tt();
new Tt();
new Tt();
function wj(n, e) {
  const t = n * e;
  return 1 - Math.exp(-(t * t));
}
function Aj(n, e) {
  if (n.dynamicScreenSpaceError && n.dynamicScreenSpaceErrorComputedDensity) {
    const t = n.dynamicScreenSpaceErrorComputedDensity, i = n.dynamicScreenSpaceErrorFactor;
    return wj(e, t) * i;
  }
  return 0;
}
function Tj(n, e, t) {
  const i = n.tileset, r = n.parent && n.parent.lodMetricValue || n.lodMetricValue, l = t ? r : n.lodMetricValue;
  if (l === 0)
    return 0;
  const c = Math.max(n._distanceToCamera, 1e-7), {
    height: a,
    sseDenominator: g
  } = e, {
    viewDistanceScale: y
  } = i.options;
  let A = l * a * (y || 1) / (c * g);
  return A -= Aj(i, c), A;
}
const Q0 = new Tt(), kA = new Tt(), sh = new Tt(), zA = new Tt(), Ej = new Tt(), ey = new Mi(), UA = new Mi();
function Sj(n, e) {
  if (n.lodMetricValue === 0 || isNaN(n.lodMetricValue))
    return "DIG";
  const t = 2 * kS(n, e);
  return t < 2 ? "OUT" : !n.header.children || t <= n.lodMetricValue ? "DRAW" : n.header.children ? "DIG" : "OUT";
}
function kS(n, e) {
  const {
    topDownViewport: t
  } = e, i = n.header.mbs[1], r = n.header.mbs[0], l = n.header.mbs[2], c = n.header.mbs[3], a = [...n.boundingVolume.center], g = t.unprojectPosition(t.cameraPosition);
  qr.WGS84.cartographicToCartesian(g, Q0), kA.copy(Q0).subtract(a).normalize(), qr.WGS84.eastNorthUpToFixedFrame(a, ey), UA.copy(ey).invert(), sh.copy(Q0).transform(UA);
  const y = Math.sqrt(sh[0] * sh[0] + sh[1] * sh[1]), A = y * y / sh[2];
  zA.copy([sh[0], sh[1], A]);
  const I = zA.transform(ey).subtract(a).normalize(), F = kA.cross(I).normalize().scale(c).add(a), U = qr.WGS84.cartesianToCartographic(F), V = t.project([r, i, l]), W = t.project(U);
  return Ej.copy(V).subtract(W).magnitude();
}
function Cj(n) {
  return {
    assetGltfUpAxis: n.asset && n.asset.gltfUpAxis || "Y"
  };
}
class jA {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    H(this, "_map", /* @__PURE__ */ new Map()), H(this, "_array", void 0), H(this, "_length", void 0), this._array = new Array(e), this._length = e;
  }
  get length() {
    return this._length;
  }
  set length(e) {
    this._length = e, e > this._array.length && (this._array.length = e);
  }
  get values() {
    return this._array;
  }
  get(e) {
    return _r(e < this._array.length), this._array[e];
  }
  set(e, t) {
    _r(e >= 0), e >= this.length && (this.length = e + 1), this._map.has(this._array[e]) && this._map.delete(this._array[e]), this._array[e] = t, this._map.set(t, e);
  }
  delete(e) {
    const t = this._map.get(e);
    t >= 0 && (this._array.splice(t, 1), this._map.delete(e), this.length--);
  }
  peek() {
    return this._array[this._length - 1];
  }
  push(e) {
    if (!this._map.has(e)) {
      const t = this.length++;
      this._array[t] = e, this._map.set(e, t);
    }
  }
  pop() {
    const e = this._array[--this.length];
    return this._map.delete(e), e;
  }
  reserve(e) {
    _r(e >= 0), e > this._array.length && (this._array.length = e);
  }
  resize(e) {
    _r(e >= 0), this.length = e;
  }
  trim(e) {
    e == null && (e = this.length), this._array.length = e;
  }
  reset() {
    this._array = [], this._map = /* @__PURE__ */ new Map(), this._length = 0;
  }
  find(e) {
    return this._map.has(e);
  }
}
const Pj = {
  loadSiblings: !1,
  skipLevelOfDetail: !1,
  maximumScreenSpaceError: 2,
  updateTransforms: !0,
  onTraversalEnd: () => {
  },
  viewportTraversersMap: {},
  basePath: ""
};
class o_ {
  traversalFinished(e) {
    return !0;
  }
  constructor(e) {
    H(this, "options", void 0), H(this, "root", null), H(this, "selectedTiles", {}), H(this, "requestedTiles", {}), H(this, "emptyTiles", {}), H(this, "lastUpdate", (/* @__PURE__ */ new Date()).getTime()), H(this, "updateDebounceTime", 1e3), H(this, "_traversalStack", new jA()), H(this, "_emptyTraversalStack", new jA()), H(this, "_frameNumber", null), this.options = {
      ...Pj,
      ...e
    };
  }
  traverse(e, t, i) {
    this.root = e, this.options = {
      ...this.options,
      ...i
    }, this.reset(), this.updateTile(e, t), this._frameNumber = t.frameNumber, this.executeTraversal(e, t);
  }
  reset() {
    this.requestedTiles = {}, this.selectedTiles = {}, this.emptyTiles = {}, this._traversalStack.reset(), this._emptyTraversalStack.reset();
  }
  executeTraversal(e, t) {
    const i = this._traversalStack;
    for (e._selectionDepth = 1, i.push(e); i.length > 0; ) {
      const l = i.pop();
      let c = !1;
      this.canTraverse(l, t) && (this.updateChildTiles(l, t), c = this.updateAndPushChildren(l, t, i, l.hasRenderContent ? l._selectionDepth + 1 : l._selectionDepth));
      const a = l.parent, g = !!(!a || a._shouldRefine), y = !c;
      l.hasRenderContent ? l.refine === Lu.ADD ? (this.loadTile(l, t), this.selectTile(l, t)) : l.refine === Lu.REPLACE && (this.loadTile(l, t), y && this.selectTile(l, t)) : (this.emptyTiles[l.id] = l, this.loadTile(l, t), y && this.selectTile(l, t)), this.touchTile(l, t), l._shouldRefine = c && g;
    }
    const r = (/* @__PURE__ */ new Date()).getTime();
    (this.traversalFinished(t) || r - this.lastUpdate > this.updateDebounceTime) && (this.lastUpdate = r, this.options.onTraversalEnd(t));
  }
  updateChildTiles(e, t) {
    const i = e.children;
    for (const r of i)
      this.updateTile(r, t);
  }
  updateAndPushChildren(e, t, i, r) {
    const {
      loadSiblings: l,
      skipLevelOfDetail: c
    } = this.options, a = e.children;
    a.sort(this.compareDistanceToCamera.bind(this));
    const g = e.refine === Lu.REPLACE && e.hasRenderContent && !c;
    let y = !1, A = !0;
    for (const C of a)
      if (C._selectionDepth = r, C.isVisibleAndInRequestVolume ? (i.find(C) && i.delete(C), i.push(C), y = !0) : (g || l) && (this.loadTile(C, t), this.touchTile(C, t)), g) {
        let I;
        if (C._inRequestVolume ? C.hasRenderContent ? I = C.contentAvailable : I = this.executeEmptyTraversal(C, t) : I = !1, A = A && I, !A)
          return !1;
      }
    return y || (A = !1), A;
  }
  updateTile(e, t) {
    this.updateTileVisibility(e, t);
  }
  selectTile(e, t) {
    this.shouldSelectTile(e) && (e._selectedFrame = t.frameNumber, this.selectedTiles[e.id] = e);
  }
  loadTile(e, t) {
    this.shouldLoadTile(e) && (e._requestedFrame = t.frameNumber, e._priority = e._getPriority(), this.requestedTiles[e.id] = e);
  }
  touchTile(e, t) {
    e.tileset._cache.touch(e), e._touchedFrame = t.frameNumber;
  }
  canTraverse(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
    return e.hasChildren ? e.hasTilesetContent ? !e.contentExpired : !r && !e.isVisibleAndInRequestVolume ? !1 : this.shouldRefine(e, t, i) : !1;
  }
  shouldLoadTile(e) {
    return e.hasUnloadedContent || e.contentExpired;
  }
  shouldSelectTile(e) {
    return e.contentAvailable && !this.options.skipLevelOfDetail;
  }
  shouldRefine(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, r = e._screenSpaceError;
    return i && (r = e.getScreenSpaceError(t, !0)), r > this.options.maximumScreenSpaceError;
  }
  updateTileVisibility(e, t) {
    const i = [];
    if (this.options.viewportTraversersMap)
      for (const r in this.options.viewportTraversersMap)
        this.options.viewportTraversersMap[r] === t.viewport.id && i.push(r);
    else
      i.push(t.viewport.id);
    e.updateVisibility(t, i);
  }
  compareDistanceToCamera(e, t) {
    return e._distanceToCamera - t._distanceToCamera;
  }
  anyChildrenVisible(e, t) {
    let i = !1;
    for (const r of e.children)
      r.updateVisibility(t), i = i || r.isVisibleAndInRequestVolume;
    return i;
  }
  executeEmptyTraversal(e, t) {
    let i = !0;
    const r = this._emptyTraversalStack;
    for (r.push(e); r.length > 0 && i; ) {
      const l = r.pop();
      if (this.updateTile(l, t), l.isVisibleAndInRequestVolume || this.loadTile(l, t), this.touchTile(l, t), !l.hasRenderContent && this.canTraverse(l, t, !1, !0)) {
        const a = l.children;
        for (const g of a)
          r.find(g) && r.delete(g), r.push(g);
      } else !l.contentAvailable && !l.hasEmptyContent && (i = !1);
    }
    return i;
  }
}
const GA = new Tt();
function Ij(n) {
  return n != null;
}
class g1 {
  constructor(e, t, i) {
    let r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
    H(this, "tileset", void 0), H(this, "header", void 0), H(this, "id", void 0), H(this, "url", void 0), H(this, "parent", void 0), H(this, "refine", void 0), H(this, "type", void 0), H(this, "contentUrl", void 0), H(this, "lodMetricType", "geometricError"), H(this, "lodMetricValue", 0), H(this, "boundingVolume", null), H(this, "content", null), H(this, "contentState", Ja.UNLOADED), H(this, "gpuMemoryUsageInBytes", 0), H(this, "children", []), H(this, "depth", 0), H(this, "viewportIds", []), H(this, "transform", new Mi()), H(this, "extensions", null), H(this, "implicitTiling", null), H(this, "userData", {}), H(this, "computedTransform", void 0), H(this, "hasEmptyContent", !1), H(this, "hasTilesetContent", !1), H(this, "traverser", new o_({})), H(this, "_cacheNode", null), H(this, "_frameNumber", null), H(this, "_expireDate", null), H(this, "_expiredContent", null), H(this, "_boundingBox", void 0), H(this, "_distanceToCamera", 0), H(this, "_screenSpaceError", 0), H(this, "_visibilityPlaneMask", void 0), H(this, "_visible", void 0), H(this, "_contentBoundingVolume", void 0), H(this, "_viewerRequestVolume", void 0), H(this, "_initialTransform", new Mi()), H(this, "_priority", 0), H(this, "_selectedFrame", 0), H(this, "_requestedFrame", 0), H(this, "_selectionDepth", 0), H(this, "_touchedFrame", 0), H(this, "_centerZDepth", 0), H(this, "_shouldRefine", !1), H(this, "_stackLength", 0), H(this, "_visitedFrame", 0), H(this, "_inRequestVolume", !1), H(this, "_lodJudge", null), this.header = t, this.tileset = e, this.id = r || t.id, this.url = t.url, this.parent = i, this.refine = this._getRefine(t.refine), this.type = t.type, this.contentUrl = t.contentUrl, this._initializeLodMetric(t), this._initializeTransforms(t), this._initializeBoundingVolumes(t), this._initializeContent(t), this._initializeRenderingState(t), Object.seal(this);
  }
  destroy() {
    this.header = null;
  }
  isDestroyed() {
    return this.header === null;
  }
  get selected() {
    return this._selectedFrame === this.tileset._frameNumber;
  }
  get isVisible() {
    return this._visible;
  }
  get isVisibleAndInRequestVolume() {
    return this._visible && this._inRequestVolume;
  }
  get hasRenderContent() {
    return !this.hasEmptyContent && !this.hasTilesetContent;
  }
  get hasChildren() {
    return this.children.length > 0 || this.header.children && this.header.children.length > 0;
  }
  get contentReady() {
    return this.contentState === Ja.READY || this.hasEmptyContent;
  }
  get contentAvailable() {
    return !!(this.contentReady && this.hasRenderContent || this._expiredContent && !this.contentFailed);
  }
  get hasUnloadedContent() {
    return this.hasRenderContent && this.contentUnloaded;
  }
  get contentUnloaded() {
    return this.contentState === Ja.UNLOADED;
  }
  get contentExpired() {
    return this.contentState === Ja.EXPIRED;
  }
  get contentFailed() {
    return this.contentState === Ja.FAILED;
  }
  get distanceToCamera() {
    return this._distanceToCamera;
  }
  get screenSpaceError() {
    return this._screenSpaceError;
  }
  get boundingBox() {
    return this._boundingBox || (this._boundingBox = yj(this.header.boundingVolume, this.boundingVolume)), this._boundingBox;
  }
  getScreenSpaceError(e, t) {
    switch (this.tileset.type) {
      case wl.I3S:
        return kS(this, e);
      case wl.TILES3D:
        return Tj(this, e, t);
      default:
        throw new Error("Unsupported tileset type");
    }
  }
  unselect() {
    this._selectedFrame = 0;
  }
  _getGpuMemoryUsageInBytes() {
    return this.content.gpuMemoryUsageInBytes || this.content.byteLength || 0;
  }
  _getPriority() {
    const e = this.tileset._traverser, {
      skipLevelOfDetail: t
    } = e.options, i = this.refine === Lu.ADD || t;
    if (i && !this.isVisible && this._visible !== void 0 || this.tileset._frameNumber - this._touchedFrame >= 1 || this.contentState === Ja.UNLOADED)
      return -1;
    const r = this.parent, c = r && (!i || this._screenSpaceError === 0 || r.hasTilesetContent) ? r._screenSpaceError : this._screenSpaceError, a = e.root ? e.root._screenSpaceError : 0;
    return Math.max(a - c, 0);
  }
  async loadContent() {
    if (this.hasEmptyContent)
      return !1;
    if (this.content)
      return !0;
    this.contentExpired && (this._expireDate = null), this.contentState = Ja.LOADING;
    const t = await this.tileset._requestScheduler.scheduleRequest(this.id, this._getPriority.bind(this));
    if (!t)
      return this.contentState = Ja.UNLOADED, !1;
    try {
      const i = this.tileset.getTileUrl(this.contentUrl), r = this.tileset.loader, l = {
        ...this.tileset.loadOptions,
        [r.id]: {
          ...this.tileset.loadOptions[r.id],
          isTileset: this.type === "json",
          ...this._getLoaderSpecificOptions(r.id)
        }
      };
      return this.content = await gh(i, r, l), this.tileset.options.contentLoader && await this.tileset.options.contentLoader(this), this._isTileset() && this.tileset._initializeTileHeaders(this.content, this), this.contentState = Ja.READY, this._onContentLoaded(), !0;
    } catch (i) {
      throw this.contentState = Ja.FAILED, i;
    } finally {
      t.done();
    }
  }
  unloadContent() {
    return this.content && this.content.destroy && this.content.destroy(), this.content = null, this.header.content && this.header.content.destroy && this.header.content.destroy(), this.header.content = null, this.contentState = Ja.UNLOADED, !0;
  }
  updateVisibility(e, t) {
    if (this._frameNumber === e.frameNumber)
      return;
    const i = this.parent, r = i ? i._visibilityPlaneMask : El.MASK_INDETERMINATE;
    if (this.tileset._traverser.options.updateTransforms) {
      const l = i ? i.computedTransform : this.tileset.modelMatrix;
      this._updateTransform(l);
    }
    this._distanceToCamera = this.distanceToTile(e), this._screenSpaceError = this.getScreenSpaceError(e, !1), this._visibilityPlaneMask = this.visibility(e, r), this._visible = this._visibilityPlaneMask !== El.MASK_OUTSIDE, this._inRequestVolume = this.insideViewerRequestVolume(e), this._frameNumber = e.frameNumber, this.viewportIds = t;
  }
  visibility(e, t) {
    const {
      cullingVolume: i
    } = e, {
      boundingVolume: r
    } = this;
    return i.computeVisibilityWithPlaneMask(r, t);
  }
  contentVisibility() {
    return !0;
  }
  distanceToTile(e) {
    const t = this.boundingVolume;
    return Math.sqrt(Math.max(t.distanceSquaredTo(e.camera.position), 0));
  }
  cameraSpaceZDepth(e) {
    let {
      camera: t
    } = e;
    const i = this.boundingVolume;
    return GA.subVectors(i.center, t.position), t.direction.dot(GA);
  }
  insideViewerRequestVolume(e) {
    const t = this._viewerRequestVolume;
    return !t || t.distanceSquaredTo(e.camera.position) <= 0;
  }
  updateExpiration() {
    if (Ij(this._expireDate) && this.contentReady && !this.hasEmptyContent) {
      const e = Date.now();
      Date.lessThan(this._expireDate, e) && (this.contentState = Ja.EXPIRED, this._expiredContent = this.content);
    }
  }
  get extras() {
    return this.header.extras;
  }
  _initializeLodMetric(e) {
    "lodMetricType" in e ? this.lodMetricType = e.lodMetricType : (this.lodMetricType = this.parent && this.parent.lodMetricType || this.tileset.lodMetricType, console.warn("3D Tile: Required prop lodMetricType is undefined. Using parent lodMetricType")), "lodMetricValue" in e ? this.lodMetricValue = e.lodMetricValue : (this.lodMetricValue = this.parent && this.parent.lodMetricValue || this.tileset.lodMetricValue, console.warn("3D Tile: Required prop lodMetricValue is undefined. Using parent lodMetricValue"));
  }
  _initializeTransforms(e) {
    this.transform = e.transform ? new Mi(e.transform) : new Mi();
    const t = this.parent, i = this.tileset, r = t && t.computedTransform ? t.computedTransform.clone() : i.modelMatrix.clone();
    this.computedTransform = new Mi(r).multiplyRight(this.transform);
    const l = t && t._initialTransform ? t._initialTransform.clone() : new Mi();
    this._initialTransform = new Mi(l).multiplyRight(this.transform);
  }
  _initializeBoundingVolumes(e) {
    this._contentBoundingVolume = null, this._viewerRequestVolume = null, this._updateBoundingVolume(e);
  }
  _initializeContent(e) {
    this.content = {
      _tileset: this.tileset,
      _tile: this
    }, this.hasEmptyContent = !0, this.contentState = Ja.UNLOADED, this.hasTilesetContent = !1, e.contentUrl && (this.content = null, this.hasEmptyContent = !1);
  }
  _initializeRenderingState(e) {
    this.depth = e.level || (this.parent ? this.parent.depth + 1 : 0), this._shouldRefine = !1, this._distanceToCamera = 0, this._centerZDepth = 0, this._screenSpaceError = 0, this._visibilityPlaneMask = El.MASK_INDETERMINATE, this._visible = void 0, this._inRequestVolume = !1, this._stackLength = 0, this._selectionDepth = 0, this._frameNumber = 0, this._touchedFrame = 0, this._visitedFrame = 0, this._selectedFrame = 0, this._requestedFrame = 0, this._priority = 0;
  }
  _getRefine(e) {
    return e || this.parent && this.parent.refine || Lu.REPLACE;
  }
  _isTileset() {
    return this.contentUrl.indexOf(".json") !== -1;
  }
  _onContentLoaded() {
    switch (this.content && this.content.type) {
      case "vctr":
      case "geom":
        this.tileset._traverser.disableSkipLevelOfDetail = !0;
        break;
    }
    this._isTileset() ? this.hasTilesetContent = !0 : this.gpuMemoryUsageInBytes = this._getGpuMemoryUsageInBytes();
  }
  _updateBoundingVolume(e) {
    this.boundingVolume = K0(e.boundingVolume, this.computedTransform, this.boundingVolume);
    const t = e.content;
    t && (t.boundingVolume && (this._contentBoundingVolume = K0(t.boundingVolume, this.computedTransform, this._contentBoundingVolume)), e.viewerRequestVolume && (this._viewerRequestVolume = K0(e.viewerRequestVolume, this.computedTransform, this._viewerRequestVolume)));
  }
  _updateTransform() {
    const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : new Mi()).clone().multiplyRight(this.transform);
    t.equals(this.computedTransform) || (this.computedTransform = t, this._updateBoundingVolume(this.header));
  }
  _getLoaderSpecificOptions(e) {
    switch (e) {
      case "i3s":
        return {
          ...this.tileset.options.i3s,
          _tileOptions: {
            attributeUrls: this.header.attributeUrls,
            textureUrl: this.header.textureUrl,
            textureFormat: this.header.textureFormat,
            textureLoaderOptions: this.header.textureLoaderOptions,
            materialDefinition: this.header.materialDefinition,
            isDracoGeometry: this.header.isDracoGeometry,
            mbs: this.header.mbs
          },
          _tilesetOptions: {
            store: this.tileset.tileset.store,
            attributeStorageInfo: this.tileset.tileset.attributeStorageInfo,
            fields: this.tileset.tileset.fields
          },
          isTileHeader: !1
        };
      case "3d-tiles":
      case "cesium-ion":
      default:
        return Cj(this.tileset.tileset);
    }
  }
}
class Mj extends o_ {
  compareDistanceToCamera(e, t) {
    return t._distanceToCamera === 0 && e._distanceToCamera === 0 ? t._centerZDepth - e._centerZDepth : t._distanceToCamera - e._distanceToCamera;
  }
  updateTileVisibility(e, t) {
    if (super.updateTileVisibility(e, t), !e.isVisibleAndInRequestVolume)
      return;
    const i = e.children.length > 0;
    if (e.hasTilesetContent && i) {
      const c = e.children[0];
      this.updateTileVisibility(c, t), e._visible = c._visible;
      return;
    }
    if (this.meetsScreenSpaceErrorEarly(e, t)) {
      e._visible = !1;
      return;
    }
    const r = e.refine === Lu.REPLACE, l = e._optimChildrenWithinParent === gj.USE_OPTIMIZATION;
    if (r && l && i && !this.anyChildrenVisible(e, t)) {
      e._visible = !1;
      return;
    }
  }
  meetsScreenSpaceErrorEarly(e, t) {
    const {
      parent: i
    } = e;
    return !i || i.hasTilesetContent || i.refine !== Lu.ADD ? !1 : !this.shouldRefine(e, t, !0);
  }
}
class Lj {
  constructor() {
    H(this, "frameNumberMap", /* @__PURE__ */ new Map());
  }
  register(e, t) {
    const i = this.frameNumberMap.get(e) || /* @__PURE__ */ new Map(), r = i.get(t) || 0;
    i.set(t, r + 1), this.frameNumberMap.set(e, i);
  }
  deregister(e, t) {
    const i = this.frameNumberMap.get(e);
    if (!i)
      return;
    const r = i.get(t) || 1;
    i.set(t, r - 1);
  }
  isZero(e, t) {
    var i;
    return (((i = this.frameNumberMap.get(e)) === null || i === void 0 ? void 0 : i.get(t)) || 0) === 0;
  }
}
const ty = {
  REQUESTED: "REQUESTED",
  COMPLETED: "COMPLETED",
  ERROR: "ERROR"
};
class Rj {
  constructor() {
    H(this, "_statusMap", void 0), H(this, "pendingTilesRegister", new Lj()), this._statusMap = {};
  }
  add(e, t, i, r) {
    if (!this._statusMap[t]) {
      const {
        frameNumber: l,
        viewport: {
          id: c
        }
      } = r;
      this._statusMap[t] = {
        request: e,
        callback: i,
        key: t,
        frameState: r,
        status: ty.REQUESTED
      }, this.pendingTilesRegister.register(c, l), e().then((a) => {
        this._statusMap[t].status = ty.COMPLETED;
        const {
          frameNumber: g,
          viewport: {
            id: y
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(y, g), this._statusMap[t].callback(a, r);
      }).catch((a) => {
        this._statusMap[t].status = ty.ERROR;
        const {
          frameNumber: g,
          viewport: {
            id: y
          }
        } = this._statusMap[t].frameState;
        this.pendingTilesRegister.deregister(y, g), i(a);
      });
    }
  }
  update(e, t) {
    if (this._statusMap[e]) {
      const {
        frameNumber: i,
        viewport: {
          id: r
        }
      } = this._statusMap[e].frameState;
      this.pendingTilesRegister.deregister(r, i);
      const {
        frameNumber: l,
        viewport: {
          id: c
        }
      } = t;
      this.pendingTilesRegister.register(c, l), this._statusMap[e].frameState = t;
    }
  }
  find(e) {
    return this._statusMap[e];
  }
  hasPendingTiles(e, t) {
    return !this.pendingTilesRegister.isZero(e, t);
  }
}
class Bj extends o_ {
  constructor(e) {
    super(e), H(this, "_tileManager", void 0), this._tileManager = new Rj();
  }
  traversalFinished(e) {
    return !this._tileManager.hasPendingTiles(e.viewport.id, this._frameNumber || 0);
  }
  shouldRefine(e, t) {
    return e._lodJudge = Sj(e, t), e._lodJudge === "DIG";
  }
  updateChildTiles(e, t) {
    const i = e.header.children || [], r = e.children, l = e.tileset;
    for (const c of i) {
      const a = "".concat(c.id, "-").concat(t.viewport.id), g = r && r.find((y) => y.id === a);
      if (g)
        g && this.updateTile(g, t);
      else {
        let y = () => this._loadTile(c.id, l);
        this._tileManager.find(a) ? this._tileManager.update(a, t) : (l.tileset.nodePages && (y = () => l.tileset.nodePagesTile.formTileFromNodePages(c.id)), this._tileManager.add(y, a, (C) => this._onTileLoad(C, e, a), t));
      }
    }
    return !1;
  }
  async _loadTile(e, t) {
    const {
      loader: i
    } = t, r = t.getTileUrl("".concat(t.url, "/nodes/").concat(e)), l = {
      ...t.loadOptions,
      i3s: {
        ...t.loadOptions.i3s,
        isTileHeader: !0
      }
    };
    return await gh(r, i, l);
  }
  _onTileLoad(e, t, i) {
    const r = new g1(t.tileset, e, t, i);
    t.children.push(r);
    const l = this._tileManager.find(r.id).frameState;
    this.updateTile(r, l), this._frameNumber === l.frameNumber && (this.traversalFinished(l) || (/* @__PURE__ */ new Date()).getTime() - this.lastUpdate > this.updateDebounceTime) && this.executeTraversal(r, l);
  }
}
const Oj = {
  description: "",
  ellipsoid: qr.WGS84,
  modelMatrix: new Mi(),
  throttleRequests: !0,
  maxRequests: 64,
  maximumMemoryUsage: 32,
  maximumTilesSelected: 0,
  debounceTime: 0,
  onTileLoad: () => {
  },
  onTileUnload: () => {
  },
  onTileError: () => {
  },
  onTraversalComplete: (n) => n,
  contentLoader: void 0,
  viewDistanceScale: 1,
  maximumScreenSpaceError: 8,
  loadTiles: !0,
  updateTransforms: !0,
  viewportTraversersMap: null,
  loadOptions: {
    fetch: {}
  },
  attributions: [],
  basePath: "",
  i3s: {}
}, Zg = "Tiles In Tileset(s)", ny = "Tiles In Memory", VA = "Tiles In View", qA = "Tiles To Render", HA = "Tiles Loaded", iy = "Tiles Loading", WA = "Tiles Unloaded", ZA = "Failed Tile Loads", $A = "Points/Vertices", ry = "Tile Memory Use";
class Dj {
  constructor(e, t) {
    H(this, "options", void 0), H(this, "loadOptions", void 0), H(this, "type", void 0), H(this, "tileset", void 0), H(this, "loader", void 0), H(this, "url", void 0), H(this, "basePath", void 0), H(this, "modelMatrix", void 0), H(this, "ellipsoid", void 0), H(this, "lodMetricType", void 0), H(this, "lodMetricValue", void 0), H(this, "refine", void 0), H(this, "root", null), H(this, "roots", {}), H(this, "asset", {}), H(this, "description", ""), H(this, "properties", void 0), H(this, "extras", null), H(this, "attributions", {}), H(this, "credits", {}), H(this, "stats", void 0), H(this, "contentFormats", {
      draco: !1,
      meshopt: !1,
      dds: !1,
      ktx2: !1
    }), H(this, "cartographicCenter", null), H(this, "cartesianCenter", null), H(this, "zoom", 1), H(this, "boundingVolume", null), H(this, "dynamicScreenSpaceErrorComputedDensity", 0), H(this, "maximumMemoryUsage", 32), H(this, "gpuMemoryUsageInBytes", 0), H(this, "_frameNumber", 0), H(this, "_queryParams", {}), H(this, "_extensionsUsed", []), H(this, "_tiles", {}), H(this, "_pendingCount", 0), H(this, "selectedTiles", []), H(this, "traverseCounter", 0), H(this, "geometricError", 0), H(this, "lastUpdatedVieports", null), H(this, "_requestedTiles", []), H(this, "_emptyTiles", []), H(this, "frameStateData", {}), H(this, "_traverser", void 0), H(this, "_cache", new sj()), H(this, "_requestScheduler", void 0), H(this, "updatePromise", null), H(this, "tilesetInitializationPromise", void 0), this.options = {
      ...Oj,
      ...t
    }, this.tileset = e, this.loader = e.loader, this.type = e.type, this.url = e.url, this.basePath = e.basePath || Z1(this.url), this.modelMatrix = this.options.modelMatrix, this.ellipsoid = this.options.ellipsoid, this.lodMetricType = e.lodMetricType, this.lodMetricValue = e.lodMetricValue, this.refine = e.root.refine, this.loadOptions = this.options.loadOptions || {}, this._traverser = this._initializeTraverser(), this._requestScheduler = new eM({
      throttleRequests: this.options.throttleRequests,
      maxRequests: this.options.maxRequests
    }), this.stats = new Up({
      id: this.url
    }), this._initializeStats(), this.tilesetInitializationPromise = this._initializeTileSet(e);
  }
  destroy() {
    this._destroy();
  }
  isLoaded() {
    return this._pendingCount === 0 && this._frameNumber !== 0 && this._requestedTiles.length === 0;
  }
  get tiles() {
    return Object.values(this._tiles);
  }
  get frameNumber() {
    return this._frameNumber;
  }
  get queryParams() {
    return new URLSearchParams(this._queryParams).toString();
  }
  setProps(e) {
    this.options = {
      ...this.options,
      ...e
    };
  }
  setOptions(e) {
    this.options = {
      ...this.options,
      ...e
    };
  }
  getTileUrl(e) {
    return e.startsWith("data:") ? e : "".concat(e).concat(e.includes("?") ? "&" : "?").concat(this.queryParams);
  }
  hasExtension(e) {
    return this._extensionsUsed.indexOf(e) > -1;
  }
  update() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    this.tilesetInitializationPromise.then(() => {
      !e && this.lastUpdatedVieports ? e = this.lastUpdatedVieports : this.lastUpdatedVieports = e, e && this.doUpdate(e);
    });
  }
  async selectTiles() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    return await this.tilesetInitializationPromise, e && (this.lastUpdatedVieports = e), this.updatePromise || (this.updatePromise = new Promise((t) => {
      setTimeout(() => {
        this.lastUpdatedVieports && this.doUpdate(this.lastUpdatedVieports), t(this._frameNumber), this.updatePromise = null;
      }, this.options.debounceTime);
    })), this.updatePromise;
  }
  doUpdate(e) {
    if ("loadTiles" in this.options && !this.options.loadTiles || this.traverseCounter > 0)
      return;
    const t = e instanceof Array ? e : [e];
    this._cache.reset(), this._frameNumber++, this.traverseCounter = t.length;
    const i = [];
    for (const r of t) {
      const l = r.id;
      this._needTraverse(l) ? i.push(l) : this.traverseCounter--;
    }
    for (const r of t) {
      const l = r.id;
      if (this.roots[l] || (this.roots[l] = this._initializeTileHeaders(this.tileset, null)), !i.includes(l))
        continue;
      const c = aj(r, this._frameNumber);
      this._traverser.traverse(this.roots[l], c, this.options);
    }
  }
  _needTraverse(e) {
    let t = e;
    return this.options.viewportTraversersMap && (t = this.options.viewportTraversersMap[e]), t === e;
  }
  _onTraversalEnd(e) {
    const t = e.viewport.id;
    this.frameStateData[t] || (this.frameStateData[t] = {
      selectedTiles: [],
      _requestedTiles: [],
      _emptyTiles: []
    });
    const i = this.frameStateData[t], r = Object.values(this._traverser.selectedTiles), [l, c] = lj(r, e, this.options.maximumTilesSelected);
    i.selectedTiles = l;
    for (const a of c)
      a.unselect();
    i._requestedTiles = Object.values(this._traverser.requestedTiles), i._emptyTiles = Object.values(this._traverser.emptyTiles), this.traverseCounter--, !(this.traverseCounter > 0) && this._updateTiles();
  }
  _updateTiles() {
    this.selectedTiles = [], this._requestedTiles = [], this._emptyTiles = [];
    for (const e in this.frameStateData) {
      const t = this.frameStateData[e];
      this.selectedTiles = this.selectedTiles.concat(t.selectedTiles), this._requestedTiles = this._requestedTiles.concat(t._requestedTiles), this._emptyTiles = this._emptyTiles.concat(t._emptyTiles);
    }
    this.selectedTiles = this.options.onTraversalComplete(this.selectedTiles);
    for (const e of this.selectedTiles)
      this._tiles[e.id] = e;
    this._loadTiles(), this._unloadTiles(), this._updateStats();
  }
  _tilesChanged(e, t) {
    if (e.length !== t.length)
      return !0;
    const i = new Set(e.map((c) => c.id)), r = new Set(t.map((c) => c.id));
    let l = e.filter((c) => !r.has(c.id)).length > 0;
    return l = l || t.filter((c) => !i.has(c.id)).length > 0, l;
  }
  _loadTiles() {
    for (const e of this._requestedTiles)
      e.contentUnloaded && this._loadTile(e);
  }
  _unloadTiles() {
    this._cache.unloadTiles(this, (e, t) => e._unloadTile(t));
  }
  _updateStats() {
    let e = 0, t = 0;
    for (const i of this.selectedTiles)
      i.contentAvailable && i.content && (e++, i.content.pointCount ? t += i.content.pointCount : t += i.content.vertexCount);
    this.stats.get(VA).count = this.selectedTiles.length, this.stats.get(qA).count = e, this.stats.get($A).count = t;
  }
  async _initializeTileSet(e) {
    this.type === wl.I3S && (this.calculateViewPropsI3S(), e.root = await e.root), this.root = this._initializeTileHeaders(e, null), this.type === wl.TILES3D && (this._initializeTiles3DTileset(e), this.calculateViewPropsTiles3D()), this.type === wl.I3S && this._initializeI3STileset();
  }
  calculateViewPropsI3S() {
    var e;
    const t = this.tileset.fullExtent;
    if (t) {
      const {
        xmin: r,
        xmax: l,
        ymin: c,
        ymax: a,
        zmin: g,
        zmax: y
      } = t;
      this.cartographicCenter = new Tt(r + (l - r) / 2, c + (a - c) / 2, g + (y - g) / 2), this.cartesianCenter = qr.WGS84.cartographicToCartesian(this.cartographicCenter, new Tt()), this.zoom = OS(t, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    const i = (e = this.tileset.store) === null || e === void 0 ? void 0 : e.extent;
    if (i) {
      const [r, l, c, a] = i;
      this.cartographicCenter = new Tt(r + (c - r) / 2, l + (a - l) / 2, 0), this.cartesianCenter = qr.WGS84.cartographicToCartesian(this.cartographicCenter, new Tt()), this.zoom = fj(i, this.cartographicCenter, this.cartesianCenter);
      return;
    }
    console.warn("Extent is not defined in the tileset header"), this.cartographicCenter = new Tt(), this.zoom = 1;
  }
  calculateViewPropsTiles3D() {
    const e = this.root, {
      center: t
    } = e.boundingVolume;
    if (!t) {
      console.warn("center was not pre-calculated for the root tile"), this.cartographicCenter = new Tt(), this.zoom = 1;
      return;
    }
    t[0] !== 0 || t[1] !== 0 || t[2] !== 0 ? this.cartographicCenter = qr.WGS84.cartesianToCartographic(t, new Tt()) : this.cartographicCenter = new Tt(0, 0, -qr.WGS84.radii[0]), this.cartesianCenter = t, this.zoom = dj(e.boundingVolume, this.cartographicCenter);
  }
  _initializeStats() {
    this.stats.get(Zg), this.stats.get(iy), this.stats.get(ny), this.stats.get(VA), this.stats.get(qA), this.stats.get(HA), this.stats.get(WA), this.stats.get(ZA), this.stats.get($A), this.stats.get(ry, "memory");
  }
  _initializeTileHeaders(e, t) {
    const i = new g1(this, e.root, t);
    if (t && (t.children.push(i), i.depth = t.depth + 1), this.type === wl.TILES3D) {
      const l = [];
      for (l.push(i); l.length > 0; ) {
        const c = l.pop();
        this.stats.get(Zg).incrementCount();
        const a = c.header.children || [];
        for (const g of a) {
          var r;
          const y = new g1(this, g, c);
          if ((r = y.contentUrl) !== null && r !== void 0 && r.includes("?session=")) {
            const C = new URL(y.contentUrl).searchParams.get("session");
            C && (this._queryParams.session = C);
          }
          c.children.push(y), y.depth = c.depth + 1, l.push(y);
        }
      }
    }
    return i;
  }
  _initializeTraverser() {
    let e;
    switch (this.type) {
      case wl.TILES3D:
        e = Mj;
        break;
      case wl.I3S:
        e = Bj;
        break;
      default:
        e = o_;
    }
    return new e({
      basePath: this.basePath,
      onTraversalEnd: this._onTraversalEnd.bind(this)
    });
  }
  _destroyTileHeaders(e) {
    this._destroySubtree(e);
  }
  async _loadTile(e) {
    let t;
    try {
      this._onStartTileLoading(), t = await e.loadContent();
    } catch (i) {
      this._onTileLoadError(e, i instanceof Error ? i : new Error("load failed"));
    } finally {
      this._onEndTileLoading(), this._onTileLoad(e, t);
    }
  }
  _onTileLoadError(e, t) {
    this.stats.get(ZA).incrementCount();
    const i = t.message || t.toString(), r = e.url;
    console.error("A 3D tile failed to load: ".concat(e.url, " ").concat(i)), this.options.onTileError(e, i, r);
  }
  _onTileLoad(e, t) {
    if (t) {
      if (this.type === wl.I3S) {
        var i, r;
        const l = ((i = this.tileset) === null || i === void 0 || (r = i.nodePagesTile) === null || r === void 0 ? void 0 : r.nodesInNodePages) || 0;
        this.stats.get(Zg).reset(), this.stats.get(Zg).addCount(l);
      }
      e && e.content && oj(e, e.content), this.updateContentTypes(e), this._addTileToCache(e), this.options.onTileLoad(e);
    }
  }
  updateContentTypes(e) {
    if (this.type === wl.I3S)
      switch (e.header.isDracoGeometry && (this.contentFormats.draco = !0), e.header.textureFormat) {
        case "dds":
          this.contentFormats.dds = !0;
          break;
        case "ktx2":
          this.contentFormats.ktx2 = !0;
          break;
      }
    else if (this.type === wl.TILES3D) {
      var t;
      const {
        extensionsRemoved: i = []
      } = ((t = e.content) === null || t === void 0 ? void 0 : t.gltf) || {};
      i.includes("KHR_draco_mesh_compression") && (this.contentFormats.draco = !0), i.includes("EXT_meshopt_compression") && (this.contentFormats.meshopt = !0), i.includes("KHR_texture_basisu") && (this.contentFormats.ktx2 = !0);
    }
  }
  _onStartTileLoading() {
    this._pendingCount++, this.stats.get(iy).incrementCount();
  }
  _onEndTileLoading() {
    this._pendingCount--, this.stats.get(iy).decrementCount();
  }
  _addTileToCache(e) {
    this._cache.add(this, e, (t) => t._updateCacheStats(e));
  }
  _updateCacheStats(e) {
    this.stats.get(HA).incrementCount(), this.stats.get(ny).incrementCount(), this.gpuMemoryUsageInBytes += e.gpuMemoryUsageInBytes || 0, this.stats.get(ry).count = this.gpuMemoryUsageInBytes;
  }
  _unloadTile(e) {
    this.gpuMemoryUsageInBytes -= e.gpuMemoryUsageInBytes || 0, this.stats.get(ny).decrementCount(), this.stats.get(WA).incrementCount(), this.stats.get(ry).count = this.gpuMemoryUsageInBytes, this.options.onTileUnload(e), e.unloadContent();
  }
  _destroy() {
    const e = [];
    for (this.root && e.push(this.root); e.length > 0; ) {
      const t = e.pop();
      for (const i of t.children)
        e.push(i);
      this._destroyTile(t);
    }
    this.root = null;
  }
  _destroySubtree(e) {
    const t = e, i = [];
    for (i.push(t); i.length > 0; ) {
      e = i.pop();
      for (const r of e.children)
        i.push(r);
      e !== t && this._destroyTile(e);
    }
    t.children = [];
  }
  _destroyTile(e) {
    this._cache.unloadTile(this, e), this._unloadTile(e), e.destroy();
  }
  _initializeTiles3DTileset(e) {
    if (e.queryString) {
      const t = new URLSearchParams(e.queryString), i = Object.fromEntries(t.entries());
      this._queryParams = {
        ...this._queryParams,
        ...i
      };
    }
    if (this.asset = e.asset, !this.asset)
      throw new Error("Tileset must have an asset property.");
    if (this.asset.version !== "0.0" && this.asset.version !== "1.0")
      throw new Error("The tileset must be 3D Tiles version 0.0 or 1.0.");
    "tilesetVersion" in this.asset && (this._queryParams.v = this.asset.tilesetVersion), this.credits = {
      attributions: this.options.attributions || []
    }, this.description = this.options.description || "", this.properties = e.properties, this.geometricError = e.geometricError, this._extensionsUsed = e.extensionsUsed || [], this.extras = e.extras;
  }
  _initializeI3STileset() {
    this.loadOptions.i3s && "token" in this.loadOptions.i3s && (this._queryParams.token = this.loadOptions.i3s.token);
  }
}
const zS = "3.4.15", rp = {
  COMPOSITE: "cmpt",
  POINT_CLOUD: "pnts",
  BATCHED_3D_MODEL: "b3dm",
  INSTANCED_3D_MODEL: "i3dm",
  GEOMETRY: "geom",
  VECTOR: "vect",
  GLTF: "glTF"
};
function US(n, e, t) {
  _r(n instanceof ArrayBuffer);
  const i = new TextDecoder("utf8"), r = new Uint8Array(n, e, t);
  return i.decode(r);
}
function Fj(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const t = new DataView(n);
  return "".concat(String.fromCharCode(t.getUint8(e + 0))).concat(String.fromCharCode(t.getUint8(e + 1))).concat(String.fromCharCode(t.getUint8(e + 2))).concat(String.fromCharCode(t.getUint8(e + 3)));
}
const Nj = {
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6
}, Ls = {
  BYTE: 5120,
  UNSIGNED_BYTE: 5121,
  SHORT: 5122,
  UNSIGNED_SHORT: 5123,
  INT: 5124,
  UNSIGNED_INT: 5125,
  FLOAT: 5126,
  DOUBLE: 5130
}, Hi = {
  ...Nj,
  ...Ls
}, sy = {
  [Ls.DOUBLE]: Float64Array,
  [Ls.FLOAT]: Float32Array,
  [Ls.UNSIGNED_SHORT]: Uint16Array,
  [Ls.UNSIGNED_INT]: Uint32Array,
  [Ls.UNSIGNED_BYTE]: Uint8Array,
  [Ls.BYTE]: Int8Array,
  [Ls.SHORT]: Int16Array,
  [Ls.INT]: Int32Array
}, kj = {
  DOUBLE: Ls.DOUBLE,
  FLOAT: Ls.FLOAT,
  UNSIGNED_SHORT: Ls.UNSIGNED_SHORT,
  UNSIGNED_INT: Ls.UNSIGNED_INT,
  UNSIGNED_BYTE: Ls.UNSIGNED_BYTE,
  BYTE: Ls.BYTE,
  SHORT: Ls.SHORT,
  INT: Ls.INT
}, oy = "Failed to convert GL type";
class Qc {
  static fromTypedArray(e) {
    e = ArrayBuffer.isView(e) ? e.constructor : e;
    for (const t in sy)
      if (sy[t] === e)
        return t;
    throw new Error(oy);
  }
  static fromName(e) {
    const t = kj[e];
    if (!t)
      throw new Error(oy);
    return t;
  }
  static getArrayType(e) {
    switch (e) {
      case Ls.UNSIGNED_SHORT_5_6_5:
      case Ls.UNSIGNED_SHORT_4_4_4_4:
      case Ls.UNSIGNED_SHORT_5_5_5_1:
        return Uint16Array;
      default:
        const t = sy[e];
        if (!t)
          throw new Error(oy);
        return t;
    }
  }
  static getByteSize(e) {
    return Qc.getArrayType(e).BYTES_PER_ELEMENT;
  }
  static validate(e) {
    return !!Qc.getArrayType(e);
  }
  static createTypedArray(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, r = arguments.length > 3 ? arguments[3] : void 0;
    r === void 0 && (r = (t.byteLength - i) / Qc.getByteSize(e));
    const l = Qc.getArrayType(e);
    return new l(t, i, r);
  }
}
function zj(n, e) {
  if (!n)
    throw new Error("math.gl assertion failed. ".concat(e));
}
function Uj(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
  const t = n >> 11 & 31, i = n >> 5 & 63, r = n & 31;
  return e[0] = t << 3, e[1] = i << 2, e[2] = r << 3, e;
}
new fb();
new Tt();
new fb();
new fb();
function XA(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 255;
  return Pu(n, 0, e) / e * 2 - 1;
}
function YA(n) {
  return n < 0 ? -1 : 1;
}
function jj(n, e, t, i) {
  if (zj(i), n < 0 || n > t || e < 0 || e > t)
    throw new Error("x and y must be unsigned normalized integers between 0 and ".concat(t));
  if (i.x = XA(n, t), i.y = XA(e, t), i.z = 1 - (Math.abs(i.x) + Math.abs(i.y)), i.z < 0) {
    const r = i.x;
    i.x = (1 - Math.abs(i.y)) * YA(r), i.y = (1 - Math.abs(r)) * YA(i.y);
  }
  return i.normalize();
}
function Gj(n, e, t) {
  return jj(n, e, 255, t);
}
class Zb {
  constructor(e, t) {
    H(this, "json", void 0), H(this, "buffer", void 0), H(this, "featuresLength", 0), H(this, "_cachedTypedArrays", {}), this.json = e, this.buffer = t;
  }
  getExtension(e) {
    return this.json.extensions && this.json.extensions[e];
  }
  hasProperty(e) {
    return !!this.json[e];
  }
  getGlobalProperty(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Hi.UNSIGNED_INT, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const r = this.json[e];
    return r && Number.isFinite(r.byteOffset) ? this._getTypedArrayFromBinary(e, t, i, 1, r.byteOffset) : r;
  }
  getPropertyArray(e, t, i) {
    const r = this.json[e];
    return r && Number.isFinite(r.byteOffset) ? ("componentType" in r && (t = Qc.fromName(r.componentType)), this._getTypedArrayFromBinary(e, t, i, this.featuresLength, r.byteOffset)) : this._getTypedArrayFromArray(e, t, r);
  }
  getProperty(e, t, i, r, l) {
    const c = this.json[e];
    if (!c)
      return c;
    const a = this.getPropertyArray(e, t, i);
    if (i === 1)
      return a[r];
    for (let g = 0; g < i; ++g)
      l[g] = a[i * r + g];
    return l;
  }
  _getTypedArrayFromBinary(e, t, i, r, l) {
    const c = this._cachedTypedArrays;
    let a = c[e];
    return a || (a = Qc.createTypedArray(t, this.buffer.buffer, this.buffer.byteOffset + l, r * i), c[e] = a), a;
  }
  _getTypedArrayFromArray(e, t, i) {
    const r = this._cachedTypedArrays;
    let l = r[e];
    return l || (l = Qc.createTypedArray(t, i), r[e] = l), l;
  }
}
const Vj = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
}, qj = {
  SCALAR: (n, e) => n[e],
  VEC2: (n, e) => [n[2 * e + 0], n[2 * e + 1]],
  VEC3: (n, e) => [n[3 * e + 0], n[3 * e + 1], n[3 * e + 2]],
  VEC4: (n, e) => [n[4 * e + 0], n[4 * e + 1], n[4 * e + 2], n[4 * e + 3]],
  MAT2: (n, e) => [n[4 * e + 0], n[4 * e + 1], n[4 * e + 2], n[4 * e + 3]],
  MAT3: (n, e) => [n[9 * e + 0], n[9 * e + 1], n[9 * e + 2], n[9 * e + 3], n[9 * e + 4], n[9 * e + 5], n[9 * e + 6], n[9 * e + 7], n[9 * e + 8]],
  MAT4: (n, e) => [n[16 * e + 0], n[16 * e + 1], n[16 * e + 2], n[16 * e + 3], n[16 * e + 4], n[16 * e + 5], n[16 * e + 6], n[16 * e + 7], n[16 * e + 8], n[16 * e + 9], n[16 * e + 10], n[16 * e + 11], n[16 * e + 12], n[16 * e + 13], n[16 * e + 14], n[16 * e + 15]]
}, Hj = {
  SCALAR: (n, e, t) => {
    e[t] = n;
  },
  VEC2: (n, e, t) => {
    e[2 * t + 0] = n[0], e[2 * t + 1] = n[1];
  },
  VEC3: (n, e, t) => {
    e[3 * t + 0] = n[0], e[3 * t + 1] = n[1], e[3 * t + 2] = n[2];
  },
  VEC4: (n, e, t) => {
    e[4 * t + 0] = n[0], e[4 * t + 1] = n[1], e[4 * t + 2] = n[2], e[4 * t + 3] = n[3];
  },
  MAT2: (n, e, t) => {
    e[4 * t + 0] = n[0], e[4 * t + 1] = n[1], e[4 * t + 2] = n[2], e[4 * t + 3] = n[3];
  },
  MAT3: (n, e, t) => {
    e[9 * t + 0] = n[0], e[9 * t + 1] = n[1], e[9 * t + 2] = n[2], e[9 * t + 3] = n[3], e[9 * t + 4] = n[4], e[9 * t + 5] = n[5], e[9 * t + 6] = n[6], e[9 * t + 7] = n[7], e[9 * t + 8] = n[8], e[9 * t + 9] = n[9];
  },
  MAT4: (n, e, t) => {
    e[16 * t + 0] = n[0], e[16 * t + 1] = n[1], e[16 * t + 2] = n[2], e[16 * t + 3] = n[3], e[16 * t + 4] = n[4], e[16 * t + 5] = n[5], e[16 * t + 6] = n[6], e[16 * t + 7] = n[7], e[16 * t + 8] = n[8], e[16 * t + 9] = n[9], e[16 * t + 10] = n[10], e[16 * t + 11] = n[11], e[16 * t + 12] = n[12], e[16 * t + 13] = n[13], e[16 * t + 14] = n[14], e[16 * t + 15] = n[15];
  }
};
function Wj(n, e, t, i) {
  const {
    componentType: r
  } = n;
  _r(n.componentType);
  const l = typeof r == "string" ? Qc.fromName(r) : r, c = Vj[n.type], a = qj[n.type], g = Hj[n.type];
  return t += n.byteOffset, {
    values: Qc.createTypedArray(l, e, t, c * i),
    type: l,
    size: c,
    unpacker: a,
    packer: g
  };
}
const Yc = (n) => n !== void 0;
function Zj(n, e, t) {
  if (!e)
    return null;
  let i = n.getExtension("3DTILES_batch_table_hierarchy");
  const r = e.HIERARCHY;
  return r && (console.warn("3D Tile Parser: HIERARCHY is deprecated. Use 3DTILES_batch_table_hierarchy."), e.extensions = e.extensions || {}, e.extensions["3DTILES_batch_table_hierarchy"] = r, i = r), i ? $j(i, t) : null;
}
function $j(n, e) {
  let t, i, r;
  const l = n.instancesLength, c = n.classes;
  let a = n.classIds, g = n.parentCounts, y = n.parentIds, A = l;
  Yc(a.byteOffset) && (a.componentType = defaultValue(a.componentType, GL.UNSIGNED_SHORT), a.type = AttributeType.SCALAR, r = getBinaryAccessor(a), a = r.createArrayBufferView(e.buffer, e.byteOffset + a.byteOffset, l));
  let C;
  if (Yc(g))
    for (Yc(g.byteOffset) && (g.componentType = defaultValue(g.componentType, GL.UNSIGNED_SHORT), g.type = AttributeType.SCALAR, r = getBinaryAccessor(g), g = r.createArrayBufferView(e.buffer, e.byteOffset + g.byteOffset, l)), C = new Uint16Array(l), A = 0, t = 0; t < l; ++t)
      C[t] = A, A += g[t];
  Yc(y) && Yc(y.byteOffset) && (y.componentType = defaultValue(y.componentType, GL.UNSIGNED_SHORT), y.type = AttributeType.SCALAR, r = getBinaryAccessor(y), y = r.createArrayBufferView(e.buffer, e.byteOffset + y.byteOffset, A));
  const I = c.length;
  for (t = 0; t < I; ++t) {
    const V = c[t].length, W = c[t].instances, X = getBinaryProperties(V, W, e);
    c[t].instances = combine(X, W);
  }
  const S = new Array(I).fill(0), F = new Uint16Array(l);
  for (t = 0; t < l; ++t)
    i = a[t], F[t] = S[i], ++S[i];
  const U = {
    classes: c,
    classIds: a,
    classIndexes: F,
    parentCounts: g,
    parentIndexes: C,
    parentIds: y
  };
  return Jj(U), U;
}
function sp(n, e, t) {
  if (!n)
    return;
  const i = n.parentCounts;
  return n.parentIds ? t(n, e) : i > 0 ? Xj(n, e, t) : Yj(n, e, t);
}
function Xj(n, e, t) {
  const i = n.classIds, r = n.parentCounts, l = n.parentIds, c = n.parentIndexes, a = i.length, g = scratchVisited;
  g.length = Math.max(g.length, a);
  const y = ++marker, A = scratchStack;
  for (A.length = 0, A.push(e); A.length > 0; ) {
    if (e = A.pop(), g[e] === y)
      continue;
    g[e] = y;
    const C = t(n, e);
    if (Yc(C))
      return C;
    const I = r[e], S = c[e];
    for (let F = 0; F < I; ++F) {
      const U = l[S + F];
      U !== e && A.push(U);
    }
  }
  return null;
}
function Yj(n, e, t) {
  let i = !0;
  for (; i; ) {
    const r = t(n, e);
    if (Yc(r))
      return r;
    const l = n.parentIds[e];
    i = l !== e, e = l;
  }
  throw new Error("traverseHierarchySingleParent");
}
function Jj(n) {
  const t = n.classIds.length;
  for (let i = 0; i < t; ++i)
    jS(n, i, stack);
}
function jS(n, e, t) {
  const i = n.parentCounts, r = n.parentIds, l = n.parentIndexes, a = n.classIds.length;
  if (!Yc(r))
    return;
  assert(e < a, "Parent index ".concat(e, " exceeds the total number of instances: ").concat(a)), assert(t.indexOf(e) === -1, "Circular dependency detected in the batch table hierarchy."), t.push(e);
  const g = Yc(i) ? i[e] : 1, y = Yc(i) ? l[e] : e;
  for (let A = 0; A < g; ++A) {
    const C = r[y + A];
    C !== e && jS(n, C, t);
  }
  t.pop(e);
}
function wa(n) {
  return n != null;
}
const $g = (n, e) => n, Kj = {
  HIERARCHY: !0,
  extensions: !0,
  extras: !0
};
class GS {
  constructor(e, t, i) {
    var r;
    let l = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    H(this, "json", void 0), H(this, "binary", void 0), H(this, "featureCount", void 0), H(this, "_extensions", void 0), H(this, "_properties", void 0), H(this, "_binaryProperties", void 0), H(this, "_hierarchy", void 0), _r(i >= 0), this.json = e || {}, this.binary = t, this.featureCount = i, this._extensions = ((r = this.json) === null || r === void 0 ? void 0 : r.extensions) || {}, this._properties = {};
    for (const c in this.json)
      Kj[c] || (this._properties[c] = this.json[c]);
    this._binaryProperties = this._initializeBinaryProperties(), l["3DTILES_batch_table_hierarchy"] && (this._hierarchy = Zj(this, this.json, this.binary));
  }
  getExtension(e) {
    return this.json && this.json.extensions && this.json.extensions[e];
  }
  memorySizeInBytes() {
    return 0;
  }
  isClass(e, t) {
    if (this._checkBatchId(e), _r(typeof t == "string", t), this._hierarchy) {
      const i = sp(this._hierarchy, e, (r, l) => {
        const c = r.classIds[l];
        return r.classes[c].name === t;
      });
      return wa(i);
    }
    return !1;
  }
  isExactClass(e, t) {
    return _r(typeof t == "string", t), this.getExactClassName(e) === t;
  }
  getExactClassName(e) {
    if (this._checkBatchId(e), this._hierarchy) {
      const t = this._hierarchy.classIds[e];
      return this._hierarchy.classes[t].name;
    }
  }
  hasProperty(e, t) {
    return this._checkBatchId(e), _r(typeof t == "string", t), wa(this._properties[t]) || this._hasPropertyInHierarchy(e, t);
  }
  getPropertyNames(e, t) {
    this._checkBatchId(e), t = wa(t) ? t : [], t.length = 0;
    const i = Object.keys(this._properties);
    return t.push(...i), this._hierarchy && this._getPropertyNamesInHierarchy(e, t), t;
  }
  getProperty(e, t) {
    if (this._checkBatchId(e), _r(typeof t == "string", t), this._binaryProperties) {
      const r = this._binaryProperties[t];
      if (wa(r))
        return this._getBinaryProperty(r, e);
    }
    const i = this._properties[t];
    if (wa(i))
      return $g(i[e]);
    if (this._hierarchy) {
      const r = this._getHierarchyProperty(e, t);
      if (wa(r))
        return r;
    }
  }
  setProperty(e, t, i) {
    const r = this.featureCount;
    if (this._checkBatchId(e), _r(typeof t == "string", t), this._binaryProperties) {
      const c = this._binaryProperties[t];
      if (c) {
        this._setBinaryProperty(c, e, i);
        return;
      }
    }
    if (this._hierarchy && this._setHierarchyProperty(this, e, t, i))
      return;
    let l = this._properties[t];
    wa(l) || (this._properties[t] = new Array(r), l = this._properties[t]), l[e] = $g(i);
  }
  _checkBatchId(e) {
    if (!(e >= 0 && e < this.featureCount))
      throw new Error("batchId not in range [0, featureCount - 1].");
  }
  _getBinaryProperty(e, t) {
    return e.unpack(e.typedArray, t);
  }
  _setBinaryProperty(e, t, i) {
    e.pack(i, e.typedArray, t);
  }
  _initializeBinaryProperties() {
    let e = null;
    for (const t in this._properties) {
      const i = this._properties[t], r = this._initializeBinaryProperty(t, i);
      r && (e = e || {}, e[t] = r);
    }
    return e;
  }
  _initializeBinaryProperty(e, t) {
    if ("byteOffset" in t) {
      const i = t;
      _r(this.binary, "Property ".concat(e, " requires a batch table binary.")), _r(i.type, "Property ".concat(e, " requires a type."));
      const r = Wj(i, this.binary.buffer, this.binary.byteOffset | 0, this.featureCount);
      return {
        typedArray: r.values,
        componentCount: r.size,
        unpack: r.unpacker,
        pack: r.packer
      };
    }
    return null;
  }
  _hasPropertyInHierarchy(e, t) {
    if (!this._hierarchy)
      return !1;
    const i = sp(this._hierarchy, e, (r, l) => {
      const c = r.classIds[l], a = r.classes[c].instances;
      return wa(a[t]);
    });
    return wa(i);
  }
  _getPropertyNamesInHierarchy(e, t) {
    sp(this._hierarchy, e, (i, r) => {
      const l = i.classIds[r], c = i.classes[l].instances;
      for (const a in c)
        c.hasOwnProperty(a) && t.indexOf(a) === -1 && t.push(a);
    });
  }
  _getHierarchyProperty(e, t) {
    return sp(this._hierarchy, e, (i, r) => {
      const l = i.classIds[r], c = i.classes[l], a = i.classIndexes[r], g = c.instances[t];
      return wa(g) ? wa(g.typedArray) ? this._getBinaryProperty(g, a) : $g(g[a]) : null;
    });
  }
  _setHierarchyProperty(e, t, i, r) {
    const l = sp(this._hierarchy, t, (c, a) => {
      const g = c.classIds[a], y = c.classes[g], A = c.classIndexes[a], C = y.instances[i];
      return wa(C) ? (_r(a === t, 'Inherited property "'.concat(i, '" is read-only.')), wa(C.typedArray) ? this._setBinaryProperty(C, A, r) : C[A] = $g(r), !0) : !1;
    });
    return wa(l);
  }
}
const ay = 4;
function a_(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  const i = new DataView(e);
  if (n.magic = i.getUint32(t, !0), t += ay, n.version = i.getUint32(t, !0), t += ay, n.byteLength = i.getUint32(t, !0), t += ay, n.version !== 1)
    throw new Error("3D Tile Version ".concat(n.version, " not supported"));
  return t;
}
const Dd = 4, JA = "b3dm tile in legacy format.";
function $b(n, e, t) {
  const i = new DataView(e);
  let r;
  n.header = n.header || {};
  let l = i.getUint32(t, !0);
  t += Dd;
  let c = i.getUint32(t, !0);
  t += Dd;
  let a = i.getUint32(t, !0);
  t += Dd;
  let g = i.getUint32(t, !0);
  return t += Dd, a >= 570425344 ? (t -= Dd * 2, r = l, a = c, g = 0, l = 0, c = 0, console.warn(JA)) : g >= 570425344 && (t -= Dd, r = a, a = l, g = c, l = 0, c = 0, console.warn(JA)), n.header.featureTableJsonByteLength = l, n.header.featureTableBinaryByteLength = c, n.header.batchTableJsonByteLength = a, n.header.batchTableBinaryByteLength = g, n.header.batchLength = r, t;
}
function Xb(n, e, t, i) {
  return t = Qj(n, e, t), t = eG(n, e, t), t;
}
function Qj(n, e, t, i) {
  const {
    featureTableJsonByteLength: r,
    featureTableBinaryByteLength: l,
    batchLength: c
  } = n.header;
  if (n.featureTableJson = {
    BATCH_LENGTH: c || 0
  }, r > 0) {
    const a = US(e, t, r);
    n.featureTableJson = JSON.parse(a);
  }
  return t += r, n.featureTableBinary = new Uint8Array(e, t, l), t += l, t;
}
function eG(n, e, t, i) {
  const {
    batchTableJsonByteLength: r,
    batchTableBinaryByteLength: l
  } = n.header;
  if (r > 0) {
    const c = US(e, t, r);
    n.batchTableJson = JSON.parse(c), t += r, l > 0 && (n.batchTableBinary = new Uint8Array(e, t, l), n.batchTableBinary = new Uint8Array(n.batchTableBinary), t += l);
  }
  return t;
}
function VS(n, e, t) {
  if (!e && (!n || !n.batchIds || !t))
    return null;
  const {
    batchIds: i,
    isRGB565: r,
    pointCount: l
  } = n;
  if (i && t) {
    const c = new Uint8ClampedArray(l * 3);
    for (let a = 0; a < l; a++) {
      const g = i[a], A = t.getProperty(g, "dimensions").map((C) => C * 255);
      c[a * 3] = A[0], c[a * 3 + 1] = A[1], c[a * 3 + 2] = A[2];
    }
    return {
      type: Hi.UNSIGNED_BYTE,
      value: c,
      size: 3,
      normalized: !0
    };
  }
  if (r) {
    const c = new Uint8ClampedArray(l * 3);
    for (let a = 0; a < l; a++) {
      const g = Uj(e[a]);
      c[a * 3] = g[0], c[a * 3 + 1] = g[1], c[a * 3 + 2] = g[2];
    }
    return {
      type: Hi.UNSIGNED_BYTE,
      value: c,
      size: 3,
      normalized: !0
    };
  }
  return e && e.length === l * 3 ? {
    type: Hi.UNSIGNED_BYTE,
    value: e,
    size: 3,
    normalized: !0
  } : {
    type: Hi.UNSIGNED_BYTE,
    value: e,
    size: 4,
    normalized: !0
  };
}
const KA = new Tt();
function tG(n, e) {
  if (!e)
    return null;
  if (n.isOctEncoded16P) {
    const t = new Float32Array(n.pointsLength * 3);
    for (let i = 0; i < n.pointsLength; i++)
      Gj(e[i * 2], e[i * 2 + 1], KA), KA.toArray(t, i * 3);
    return {
      type: Hi.FLOAT,
      size: 2,
      value: t
    };
  }
  return {
    type: Hi.FLOAT,
    size: 2,
    value: e
  };
}
function nG(n, e, t) {
  return n.isQuantized ? t["3d-tiles"] && t["3d-tiles"].decodeQuantizedPositions ? (n.isQuantized = !1, iG(n, e)) : {
    type: Hi.UNSIGNED_SHORT,
    value: e,
    size: 3,
    normalized: !0
  } : e;
}
function iG(n, e) {
  const t = new Tt(), i = new Float32Array(n.pointCount * 3);
  for (let r = 0; r < n.pointCount; r++)
    t.set(e[r * 3], e[r * 3 + 1], e[r * 3 + 2]).scale(1 / n.quantizedRange).multiply(n.quantizedVolumeScale).add(n.quantizedVolumeOffset).toArray(i, r * 3);
  return i;
}
async function rG(n, e, t, i, r) {
  t = a_(n, e, t), t = $b(n, e, t), t = Xb(n, e, t), sG(n);
  const {
    featureTable: l,
    batchTable: c
  } = oG(n);
  return await hG(n, l, c, i, r), aG(n, l, i), lG(n, l, c), cG(n, l), t;
}
function sG(n) {
  n.attributes = {
    positions: null,
    colors: null,
    normals: null,
    batchIds: null
  }, n.isQuantized = !1, n.isTranslucent = !1, n.isRGB565 = !1, n.isOctEncoded16P = !1;
}
function oG(n) {
  const e = new Zb(n.featureTableJson, n.featureTableBinary), t = e.getGlobalProperty("POINTS_LENGTH");
  if (!Number.isFinite(t))
    throw new Error("POINTS_LENGTH must be defined");
  e.featuresLength = t, n.featuresLength = t, n.pointsLength = t, n.pointCount = t, n.rtcCenter = e.getGlobalProperty("RTC_CENTER", Hi.FLOAT, 3);
  const i = uG(n, e);
  return {
    featureTable: e,
    batchTable: i
  };
}
function aG(n, e, t) {
  if (!n.attributes.positions) {
    if (e.hasProperty("POSITION"))
      n.attributes.positions = e.getPropertyArray("POSITION", Hi.FLOAT, 3);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      const i = e.getPropertyArray("POSITION_QUANTIZED", Hi.UNSIGNED_SHORT, 3);
      if (n.isQuantized = !0, n.quantizedRange = 65535, n.quantizedVolumeScale = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", Hi.FLOAT, 3), !n.quantizedVolumeScale)
        throw new Error("QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      if (n.quantizedVolumeOffset = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", Hi.FLOAT, 3), !n.quantizedVolumeOffset)
        throw new Error("QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      n.attributes.positions = nG(n, i, t);
    }
  }
  if (!n.attributes.positions)
    throw new Error("Either POSITION or POSITION_QUANTIZED must be defined.");
}
function lG(n, e, t) {
  if (!n.attributes.colors) {
    let i = null;
    e.hasProperty("RGBA") ? (i = e.getPropertyArray("RGBA", Hi.UNSIGNED_BYTE, 4), n.isTranslucent = !0) : e.hasProperty("RGB") ? i = e.getPropertyArray("RGB", Hi.UNSIGNED_BYTE, 3) : e.hasProperty("RGB565") && (i = e.getPropertyArray("RGB565", Hi.UNSIGNED_SHORT, 1), n.isRGB565 = !0), n.attributes.colors = VS(n, i, t);
  }
  e.hasProperty("CONSTANT_RGBA") && (n.constantRGBA = e.getGlobalProperty("CONSTANT_RGBA", Hi.UNSIGNED_BYTE, 4));
}
function cG(n, e) {
  if (!n.attributes.normals) {
    let t = null;
    e.hasProperty("NORMAL") ? t = e.getPropertyArray("NORMAL", Hi.FLOAT, 3) : e.hasProperty("NORMAL_OCT16P") && (t = e.getPropertyArray("NORMAL_OCT16P", Hi.UNSIGNED_BYTE, 2), n.isOctEncoded16P = !0), n.attributes.normals = tG(n, t);
  }
}
function uG(n, e) {
  let t = null;
  if (!n.batchIds && e.hasProperty("BATCH_ID") && (n.batchIds = e.getPropertyArray("BATCH_ID", Hi.UNSIGNED_SHORT, 1), n.batchIds)) {
    const i = e.getGlobalProperty("BATCH_LENGTH");
    if (!i)
      throw new Error("Global property: BATCH_LENGTH must be defined when BATCH_ID is defined.");
    const {
      batchTableJson: r,
      batchTableBinary: l
    } = n;
    t = new GS(r, l, i);
  }
  return t;
}
async function hG(n, e, t, i, r) {
  let l, c, a;
  const g = n.batchTableJson && n.batchTableJson.extensions && n.batchTableJson.extensions["3DTILES_draco_point_compression"];
  g && (a = g.properties);
  const y = e.getExtension("3DTILES_draco_point_compression");
  if (y) {
    c = y.properties;
    const C = y.byteOffset, I = y.byteLength;
    if (!c || !Number.isFinite(C) || !I)
      throw new Error("Draco properties, byteOffset, and byteLength must be defined");
    l = n.featureTableBinary.slice(C, C + I), n.hasPositions = Number.isFinite(c.POSITION), n.hasColors = Number.isFinite(c.RGB) || Number.isFinite(c.RGBA), n.hasNormals = Number.isFinite(c.NORMAL), n.hasBatchIds = Number.isFinite(c.BATCH_ID), n.isTranslucent = Number.isFinite(c.RGBA);
  }
  if (!l)
    return !0;
  const A = {
    buffer: l,
    properties: {
      ...c,
      ...a
    },
    featureTableProperties: c,
    batchTableProperties: a,
    dequantizeInShader: !1
  };
  return await dG(n, A, i, r);
}
async function dG(n, e, t, i) {
  const {
    parse: r
  } = i, l = {
    ...t,
    draco: {
      ...t.draco,
      extraAttributes: e.batchTableProperties || {}
    }
  };
  delete l["3d-tiles"];
  const c = await r(e.buffer, CS, l), a = c.attributes.POSITION && c.attributes.POSITION.value, g = c.attributes.COLOR_0 && c.attributes.COLOR_0.value, y = c.attributes.NORMAL && c.attributes.NORMAL.value, A = c.attributes.BATCH_ID && c.attributes.BATCH_ID.value, C = a && c.attributes.POSITION.value.quantization, I = y && c.attributes.NORMAL.value.quantization;
  if (C) {
    const F = c.POSITION.data.quantization, U = F.range;
    n.quantizedVolumeScale = new Tt(U, U, U), n.quantizedVolumeOffset = new Tt(F.minValues), n.quantizedRange = (1 << F.quantizationBits) - 1, n.isQuantizedDraco = !0;
  }
  I && (n.octEncodedRange = (1 << c.NORMAL.data.quantization.quantizationBits) - 1, n.isOctEncodedDraco = !0);
  const S = {};
  if (e.batchTableProperties)
    for (const F of Object.keys(e.batchTableProperties))
      c.attributes[F] && c.attributes[F].value && (S[F.toLowerCase()] = c.attributes[F].value);
  n.attributes = {
    positions: a,
    colors: VS(n, g, void 0),
    normals: y,
    batchIds: A,
    ...S
  };
}
const m1 = {
  URI: 0,
  EMBEDDED: 1
};
function qS(n, e, t, i) {
  n.rotateYtoZ = !0;
  const r = n.byteOffset + n.byteLength - t;
  if (r === 0)
    throw new Error("glTF byte length must be greater than 0.");
  return n.gltfUpAxis = i["3d-tiles"] && i["3d-tiles"].assetGltfUpAxis ? i["3d-tiles"].assetGltfUpAxis : "Y", n.gltfArrayBuffer = W1(e, t, r), n.gltfByteOffset = 0, n.gltfByteLength = r, t % 4 === 0 || console.warn("".concat(n.type, ": embedded glb is not aligned to a 4-byte boundary.")), n.byteOffset + n.byteLength;
}
async function HS(n, e, t, i) {
  const r = t["3d-tiles"] || {};
  if (fG(n, e), r.loadGLTF) {
    const {
      parse: l,
      fetch: c
    } = i;
    n.gltfUrl && (n.gltfArrayBuffer = await c(n.gltfUrl, t), n.gltfByteOffset = 0), n.gltfArrayBuffer && (n.gltf = await l(n.gltfArrayBuffer, Op, t, i), n.gpuMemoryUsageInBytes = ES(n.gltf), delete n.gltfArrayBuffer, delete n.gltfByteOffset, delete n.gltfByteLength);
  }
}
function fG(n, e, t) {
  switch (e) {
    case m1.URI:
      const i = new Uint8Array(n.gltfArrayBuffer, n.gltfByteOffset), l = new TextDecoder().decode(i);
      n.gltfUrl = l.replace(/[\s\0]+$/, ""), delete n.gltfArrayBuffer, delete n.gltfByteOffset, delete n.gltfByteLength;
      break;
    case m1.EMBEDDED:
      break;
    default:
      throw new Error("b3dm: Illegal glTF format field");
  }
}
async function pG(n, e, t, i, r) {
  var l;
  t = gG(n, e, t, i), await HS(n, m1.EMBEDDED, i, r);
  const c = n == null || (l = n.gltf) === null || l === void 0 ? void 0 : l.extensions;
  return c && c.CESIUM_RTC && (n.rtcCenter = c.CESIUM_RTC.center), t;
}
function gG(n, e, t, i, r) {
  t = a_(n, e, t), t = $b(n, e, t), t = Xb(n, e, t), t = qS(n, e, t, i);
  const l = new Zb(n.featureTableJson, n.featureTableBinary);
  return n.rtcCenter = l.getGlobalProperty("RTC_CENTER", Hi.FLOAT, 3), t;
}
async function mG(n, e, t, i, r) {
  return t = _G(n, e, t, i), await HS(n, n.gltfFormat, i, r), t;
}
function _G(n, e, t, i, r) {
  if (t = a_(n, e, t), n.version !== 1)
    throw new Error("Instanced 3D Model version ".concat(n.version, " is not supported"));
  t = $b(n, e, t);
  const l = new DataView(e);
  if (n.gltfFormat = l.getUint32(t, !0), t += 4, t = Xb(n, e, t), t = qS(n, e, t, i), n.featureTableJsonByteLength === 0)
    throw new Error("i3dm parser: featureTableJsonByteLength is zero.");
  const c = new Zb(n.featureTableJson, n.featureTableBinary), a = c.getGlobalProperty("INSTANCES_LENGTH");
  if (c.featuresLength = a, !Number.isFinite(a))
    throw new Error("i3dm parser: INSTANCES_LENGTH must be defined");
  n.eastNorthUp = c.getGlobalProperty("EAST_NORTH_UP"), n.rtcCenter = c.getGlobalProperty("RTC_CENTER", Hi.FLOAT, 3);
  const g = new GS(n.batchTableJson, n.batchTableBinary, a);
  return yG(n, c, g, a), t;
}
function yG(n, e, t, i) {
  const l = {
    instances: new Array(i),
    batchTable: n._batchTable,
    cull: !1,
    url: void 0,
    gltf: void 0,
    basePath: void 0,
    incrementallyLoadTextures: !1,
    forwardAxis: [1, 0, 0]
  }.instances, c = new Tt();
  new Tt(), new Tt(), new Tt();
  const a = new ss(), g = new Ip(), y = new Tt(), A = {}, C = new Mi(), I = [], S = [], F = new Tt(), U = new Tt();
  for (let V = 0; V < i; V++) {
    let W;
    if (e.hasProperty("POSITION"))
      W = e.getProperty("POSITION", Hi.FLOAT, 3, V, c);
    else if (e.hasProperty("POSITION_QUANTIZED")) {
      W = e.getProperty("POSITION_QUANTIZED", Hi.UNSIGNED_SHORT, 3, V, c);
      const Te = e.getGlobalProperty("QUANTIZED_VOLUME_OFFSET", Hi.FLOAT, 3, F);
      if (!Te)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_OFFSET must be defined for quantized positions.");
      const me = e.getGlobalProperty("QUANTIZED_VOLUME_SCALE", Hi.FLOAT, 3, U);
      if (!me)
        throw new Error("i3dm parser: QUANTIZED_VOLUME_SCALE must be defined for quantized positions.");
      const Ge = 65535;
      for (let ke = 0; ke < 3; ke++)
        W[ke] = W[ke] / Ge * me[ke] + Te[ke];
    }
    if (!W)
      throw new Error("i3dm: POSITION or POSITION_QUANTIZED must be defined for each instance.");
    if (c.copy(W), A.translation = c, n.normalUp = e.getProperty("NORMAL_UP", Hi.FLOAT, 3, V, I), n.normalRight = e.getProperty("NORMAL_RIGHT", Hi.FLOAT, 3, V, S), n.normalUp) {
      if (!n.normalRight)
        throw new Error("i3dm: Custom orientation requires both NORMAL_UP and NORMAL_RIGHT.");
      n.hasCustomOrientation = !0;
    } else {
      if (n.octNormalUp = e.getProperty("NORMAL_UP_OCT32P", Hi.UNSIGNED_SHORT, 2, I), n.octNormalRight = e.getProperty("NORMAL_RIGHT_OCT32P", Hi.UNSIGNED_SHORT, 2, S), n.octNormalUp)
        throw n.octNormalRight ? new Error("i3dm: oct-encoded orientation not implemented") : new Error("i3dm: oct-encoded orientation requires NORMAL_UP_OCT32P and NORMAL_RIGHT_OCT32P");
      n.eastNorthUp ? (qr.WGS84.eastNorthUpToFixedFrame(c, C), C.getRotationMatrix3(a)) : a.identity();
    }
    g.fromMatrix3(a), A.rotation = g, y.set(1, 1, 1);
    const X = e.getProperty("SCALE", Hi.FLOAT, 1, V);
    Number.isFinite(X) && y.multiplyByScalar(X);
    const de = e.getProperty("SCALE_NON_UNIFORM", Hi.FLOAT, 3, V, I);
    de && y.scale(de), A.scale = y;
    let ie = e.getProperty("BATCH_ID", Hi.UNSIGNED_SHORT, 1, V);
    ie === void 0 && (ie = V);
    const fe = new Mi().fromQuaternion(A.rotation);
    C.identity(), C.translate(A.translation), C.multiplyRight(fe), C.scale(A.scale);
    const Ae = C.clone();
    l[V] = {
      modelMatrix: Ae,
      batchId: ie
    };
  }
  n.instances = l;
}
async function bG(n, e, t, i, r, l) {
  t = a_(n, e, t);
  const c = new DataView(e);
  for (n.tilesLength = c.getUint32(t, !0), t += 4, n.tiles = []; n.tiles.length < n.tilesLength && n.byteLength - t > 12; ) {
    const a = {};
    n.tiles.push(a), t = await l(e, t, i, r, a);
  }
  return t;
}
async function vG(n, e, t, i) {
  n.rotateYtoZ = !0, n.gltfUpAxis = t["3d-tiles"] && t["3d-tiles"].assetGltfUpAxis ? t["3d-tiles"].assetGltfUpAxis : "Y";
  const {
    parse: r
  } = i;
  n.gltf = await r(e, Op, t, i), n.gpuMemoryUsageInBytes = ES(n.gltf);
}
async function WS(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = arguments.length > 2 ? arguments[2] : void 0, i = arguments.length > 3 ? arguments[3] : void 0, r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  switch (r.byteOffset = e, r.type = Fj(n, e), r.type) {
    case rp.COMPOSITE:
      return await bG(r, n, e, t, i, WS);
    case rp.BATCHED_3D_MODEL:
      return await pG(r, n, e, t, i);
    case rp.GLTF:
      return await vG(r, n, t, i);
    case rp.INSTANCED_3D_MODEL:
      return await mG(r, n, e, t, i);
    case rp.POINT_CLOUD:
      return await rG(r, n, e, t, i);
    default:
      throw new Error("3DTileLoader: unknown type ".concat(r.type));
  }
}
const xG = 1952609651, wG = 1;
async function AG(n, e, t) {
  if (new Uint32Array(n.slice(0, 4))[0] !== xG)
    throw new Error("Wrong subtree file magic number");
  if (new Uint32Array(n.slice(4, 8))[0] !== wG)
    throw new Error("Wrong subtree file verson, must be 1");
  const l = QA(n.slice(8, 16)), c = new Uint8Array(n, 24, l), g = new TextDecoder("utf8").decode(c), y = JSON.parse(g), A = QA(n.slice(16, 24));
  let C = new ArrayBuffer(0);
  return A && (C = n.slice(24 + l)), "bufferView" in y.tileAvailability && (y.tileAvailability.explicitBitstream = await ly(y, "tileAvailability", C, t)), "bufferView" in y.contentAvailability && (y.contentAvailability.explicitBitstream = await ly(y, "contentAvailability", C, t)), "bufferView" in y.childSubtreeAvailability && (y.childSubtreeAvailability.explicitBitstream = await ly(y, "childSubtreeAvailability", C, t)), y;
}
function TG(n, e) {
  if (e.startsWith("http")) {
    const l = new URL(n, e);
    return decodeURI(l.toString());
  }
  const i = "http://".concat(e), r = new URL(n, i);
  return "/".concat(r.host).concat(r.pathname);
}
async function ly(n, e, t, i) {
  const r = n[e].bufferView, l = n.bufferViews[r], c = n.buffers[l.buffer];
  if (!(i != null && i.url) || !i.fetch)
    throw new Error("Url is not provided");
  if (!i.fetch)
    throw new Error("fetch is not provided");
  if (c.uri) {
    const a = TG(c.uri, i == null ? void 0 : i.url), y = await (await i.fetch(a)).arrayBuffer();
    return new Uint8Array(y, l.byteOffset, l.byteLength);
  }
  return new Uint8Array(t, l.byteOffset, l.byteLength);
}
function QA(n) {
  const e = new DataView(n), t = e.getUint32(0, !0), i = e.getUint32(4, !0);
  return t + 2 ** 32 * i;
}
const ZS = {
  id: "3d-tiles-subtree",
  name: "3D Tiles Subtree",
  module: "3d-tiles",
  version: zS,
  extensions: ["subtree"],
  mimeTypes: ["application/octet-stream"],
  tests: ["subtree"],
  parse: AG,
  options: {}
};
/**
 * @license
 * Copyright 2009 The Closure Library Authors
 * Copyright 2020 Daniel Wirtz / The long.js Authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */
var Sl = null;
try {
  Sl = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
} catch {
}
function ar(n, e, t) {
  this.low = n | 0, this.high = e | 0, this.unsigned = !!t;
}
ar.prototype.__isLong__;
Object.defineProperty(ar.prototype, "__isLong__", {
  value: !0
});
function Zo(n) {
  return (n && n.__isLong__) === !0;
}
function e5(n) {
  var e = Math.clz32(n & -n);
  return n ? 31 - e : e;
}
ar.isLong = Zo;
var t5 = {}, n5 = {};
function sd(n, e) {
  var t, i, r;
  return e ? (n >>>= 0, (r = 0 <= n && n < 256) && (i = n5[n], i) ? i : (t = $i(n, 0, !0), r && (n5[n] = t), t)) : (n |= 0, (r = -128 <= n && n < 128) && (i = t5[n], i) ? i : (t = $i(n, n < 0 ? -1 : 0, !1), r && (t5[n] = t), t));
}
ar.fromInt = sd;
function Cl(n, e) {
  if (isNaN(n)) return e ? Iu : _c;
  if (e) {
    if (n < 0) return Iu;
    if (n >= $S) return JS;
  } else {
    if (n <= -r5) return Ea;
    if (n + 1 >= r5) return YS;
  }
  return n < 0 ? Cl(-n, e).neg() : $i(n % ff | 0, n / ff | 0, e);
}
ar.fromNumber = Cl;
function $i(n, e, t) {
  return new ar(n, e, t);
}
ar.fromBits = $i;
var jm = Math.pow;
function Yb(n, e, t) {
  if (n.length === 0) throw Error("empty string");
  if (typeof e == "number" ? (t = e, e = !1) : e = !!e, n === "NaN" || n === "Infinity" || n === "+Infinity" || n === "-Infinity") return e ? Iu : _c;
  if (t = t || 10, t < 2 || 36 < t) throw RangeError("radix");
  var i;
  if ((i = n.indexOf("-")) > 0) throw Error("interior hyphen");
  if (i === 0)
    return Yb(n.substring(1), e, t).neg();
  for (var r = Cl(jm(t, 8)), l = _c, c = 0; c < n.length; c += 8) {
    var a = Math.min(8, n.length - c), g = parseInt(n.substring(c, c + a), t);
    if (a < 8) {
      var y = Cl(jm(t, a));
      l = l.mul(y).add(Cl(g));
    } else
      l = l.mul(r), l = l.add(Cl(g));
  }
  return l.unsigned = e, l;
}
ar.fromString = Yb;
function xc(n, e) {
  return typeof n == "number" ? Cl(n, e) : typeof n == "string" ? Yb(n, e) : $i(n.low, n.high, typeof e == "boolean" ? e : n.unsigned);
}
ar.fromValue = xc;
var i5 = 65536, EG = 1 << 24, ff = i5 * i5, $S = ff * ff, r5 = $S / 2, s5 = sd(EG), _c = sd(0);
ar.ZERO = _c;
var Iu = sd(0, !0);
ar.UZERO = Iu;
var Hd = sd(1);
ar.ONE = Hd;
var XS = sd(1, !0);
ar.UONE = XS;
var _1 = sd(-1);
ar.NEG_ONE = _1;
var YS = $i(-1, 2147483647, !1);
ar.MAX_VALUE = YS;
var JS = $i(-1, -1, !0);
ar.MAX_UNSIGNED_VALUE = JS;
var Ea = $i(0, -2147483648, !1);
ar.MIN_VALUE = Ea;
var pn = ar.prototype;
pn.toInt = function() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
pn.toNumber = function() {
  return this.unsigned ? (this.high >>> 0) * ff + (this.low >>> 0) : this.high * ff + (this.low >>> 0);
};
pn.toString = function(e) {
  if (e = e || 10, e < 2 || 36 < e) throw RangeError("radix");
  if (this.isZero()) return "0";
  if (this.isNegative())
    if (this.eq(Ea)) {
      var t = Cl(e), i = this.div(t), r = i.mul(t).sub(this);
      return i.toString(e) + r.toInt().toString(e);
    } else return "-" + this.neg().toString(e);
  for (var l = Cl(jm(e, 6), this.unsigned), c = this, a = ""; ; ) {
    var g = c.div(l), y = c.sub(g.mul(l)).toInt() >>> 0, A = y.toString(e);
    if (c = g, c.isZero()) return A + a;
    for (; A.length < 6; ) A = "0" + A;
    a = "" + A + a;
  }
};
pn.getHighBits = function() {
  return this.high;
};
pn.getHighBitsUnsigned = function() {
  return this.high >>> 0;
};
pn.getLowBits = function() {
  return this.low;
};
pn.getLowBitsUnsigned = function() {
  return this.low >>> 0;
};
pn.getNumBitsAbs = function() {
  if (this.isNegative())
    return this.eq(Ea) ? 64 : this.neg().getNumBitsAbs();
  for (var e = this.high != 0 ? this.high : this.low, t = 31; t > 0 && !(e & 1 << t); t--) ;
  return this.high != 0 ? t + 33 : t + 1;
};
pn.isZero = function() {
  return this.high === 0 && this.low === 0;
};
pn.eqz = pn.isZero;
pn.isNegative = function() {
  return !this.unsigned && this.high < 0;
};
pn.isPositive = function() {
  return this.unsigned || this.high >= 0;
};
pn.isOdd = function() {
  return (this.low & 1) === 1;
};
pn.isEven = function() {
  return (this.low & 1) === 0;
};
pn.equals = function(e) {
  return Zo(e) || (e = xc(e)), this.unsigned !== e.unsigned && this.high >>> 31 === 1 && e.high >>> 31 === 1 ? !1 : this.high === e.high && this.low === e.low;
};
pn.eq = pn.equals;
pn.notEquals = function(e) {
  return !this.eq(
    /* validates */
    e
  );
};
pn.neq = pn.notEquals;
pn.ne = pn.notEquals;
pn.lessThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) < 0;
};
pn.lt = pn.lessThan;
pn.lessThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) <= 0;
};
pn.lte = pn.lessThanOrEqual;
pn.le = pn.lessThanOrEqual;
pn.greaterThan = function(e) {
  return this.comp(
    /* validates */
    e
  ) > 0;
};
pn.gt = pn.greaterThan;
pn.greaterThanOrEqual = function(e) {
  return this.comp(
    /* validates */
    e
  ) >= 0;
};
pn.gte = pn.greaterThanOrEqual;
pn.ge = pn.greaterThanOrEqual;
pn.compare = function(e) {
  if (Zo(e) || (e = xc(e)), this.eq(e)) return 0;
  var t = this.isNegative(), i = e.isNegative();
  return t && !i ? -1 : !t && i ? 1 : this.unsigned ? e.high >>> 0 > this.high >>> 0 || e.high === this.high && e.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(e).isNegative() ? -1 : 1;
};
pn.comp = pn.compare;
pn.negate = function() {
  return !this.unsigned && this.eq(Ea) ? Ea : this.not().add(Hd);
};
pn.neg = pn.negate;
pn.add = function(e) {
  Zo(e) || (e = xc(e));
  var t = this.high >>> 16, i = this.high & 65535, r = this.low >>> 16, l = this.low & 65535, c = e.high >>> 16, a = e.high & 65535, g = e.low >>> 16, y = e.low & 65535, A = 0, C = 0, I = 0, S = 0;
  return S += l + y, I += S >>> 16, S &= 65535, I += r + g, C += I >>> 16, I &= 65535, C += i + a, A += C >>> 16, C &= 65535, A += t + c, A &= 65535, $i(I << 16 | S, A << 16 | C, this.unsigned);
};
pn.subtract = function(e) {
  return Zo(e) || (e = xc(e)), this.add(e.neg());
};
pn.sub = pn.subtract;
pn.multiply = function(e) {
  if (this.isZero()) return this;
  if (Zo(e) || (e = xc(e)), Sl) {
    var t = Sl.mul(this.low, this.high, e.low, e.high);
    return $i(t, Sl.get_high(), this.unsigned);
  }
  if (e.isZero()) return this.unsigned ? Iu : _c;
  if (this.eq(Ea)) return e.isOdd() ? Ea : _c;
  if (e.eq(Ea)) return this.isOdd() ? Ea : _c;
  if (this.isNegative())
    return e.isNegative() ? this.neg().mul(e.neg()) : this.neg().mul(e).neg();
  if (e.isNegative()) return this.mul(e.neg()).neg();
  if (this.lt(s5) && e.lt(s5)) return Cl(this.toNumber() * e.toNumber(), this.unsigned);
  var i = this.high >>> 16, r = this.high & 65535, l = this.low >>> 16, c = this.low & 65535, a = e.high >>> 16, g = e.high & 65535, y = e.low >>> 16, A = e.low & 65535, C = 0, I = 0, S = 0, F = 0;
  return F += c * A, S += F >>> 16, F &= 65535, S += l * A, I += S >>> 16, S &= 65535, S += c * y, I += S >>> 16, S &= 65535, I += r * A, C += I >>> 16, I &= 65535, I += l * y, C += I >>> 16, I &= 65535, I += c * g, C += I >>> 16, I &= 65535, C += i * A + r * y + l * g + c * a, C &= 65535, $i(S << 16 | F, C << 16 | I, this.unsigned);
};
pn.mul = pn.multiply;
pn.divide = function(e) {
  if (Zo(e) || (e = xc(e)), e.isZero()) throw Error("division by zero");
  if (Sl) {
    if (!this.unsigned && this.high === -2147483648 && e.low === -1 && e.high === -1)
      return this;
    var t = (this.unsigned ? Sl.div_u : Sl.div_s)(this.low, this.high, e.low, e.high);
    return $i(t, Sl.get_high(), this.unsigned);
  }
  if (this.isZero()) return this.unsigned ? Iu : _c;
  var i, r, l;
  if (this.unsigned) {
    if (e.unsigned || (e = e.toUnsigned()), e.gt(this)) return Iu;
    if (e.gt(this.shru(1)))
      return XS;
    l = Iu;
  } else {
    if (this.eq(Ea)) {
      if (e.eq(Hd) || e.eq(_1)) return Ea;
      if (e.eq(Ea)) return Hd;
      var c = this.shr(1);
      return i = c.div(e).shl(1), i.eq(_c) ? e.isNegative() ? Hd : _1 : (r = this.sub(e.mul(i)), l = i.add(r.div(e)), l);
    } else if (e.eq(Ea)) return this.unsigned ? Iu : _c;
    if (this.isNegative())
      return e.isNegative() ? this.neg().div(e.neg()) : this.neg().div(e).neg();
    if (e.isNegative()) return this.div(e.neg()).neg();
    l = _c;
  }
  for (r = this; r.gte(e); ) {
    i = Math.max(1, Math.floor(r.toNumber() / e.toNumber()));
    for (var a = Math.ceil(Math.log(i) / Math.LN2), g = a <= 48 ? 1 : jm(2, a - 48), y = Cl(i), A = y.mul(e); A.isNegative() || A.gt(r); )
      i -= g, y = Cl(i, this.unsigned), A = y.mul(e);
    y.isZero() && (y = Hd), l = l.add(y), r = r.sub(A);
  }
  return l;
};
pn.div = pn.divide;
pn.modulo = function(e) {
  if (Zo(e) || (e = xc(e)), Sl) {
    var t = (this.unsigned ? Sl.rem_u : Sl.rem_s)(this.low, this.high, e.low, e.high);
    return $i(t, Sl.get_high(), this.unsigned);
  }
  return this.sub(this.div(e).mul(e));
};
pn.mod = pn.modulo;
pn.rem = pn.modulo;
pn.not = function() {
  return $i(~this.low, ~this.high, this.unsigned);
};
pn.countLeadingZeros = function() {
  return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
};
pn.clz = pn.countLeadingZeros;
pn.countTrailingZeros = function() {
  return this.low ? e5(this.low) : e5(this.high) + 32;
};
pn.ctz = pn.countTrailingZeros;
pn.and = function(e) {
  return Zo(e) || (e = xc(e)), $i(this.low & e.low, this.high & e.high, this.unsigned);
};
pn.or = function(e) {
  return Zo(e) || (e = xc(e)), $i(this.low | e.low, this.high | e.high, this.unsigned);
};
pn.xor = function(e) {
  return Zo(e) || (e = xc(e)), $i(this.low ^ e.low, this.high ^ e.high, this.unsigned);
};
pn.shiftLeft = function(e) {
  return Zo(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? $i(this.low << e, this.high << e | this.low >>> 32 - e, this.unsigned) : $i(0, this.low << e - 32, this.unsigned);
};
pn.shl = pn.shiftLeft;
pn.shiftRight = function(e) {
  return Zo(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? $i(this.low >>> e | this.high << 32 - e, this.high >> e, this.unsigned) : $i(this.high >> e - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
pn.shr = pn.shiftRight;
pn.shiftRightUnsigned = function(e) {
  return Zo(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e < 32 ? $i(this.low >>> e | this.high << 32 - e, this.high >>> e, this.unsigned) : e === 32 ? $i(this.high, 0, this.unsigned) : $i(this.high >>> e - 32, 0, this.unsigned);
};
pn.shru = pn.shiftRightUnsigned;
pn.shr_u = pn.shiftRightUnsigned;
pn.rotateLeft = function(e) {
  var t;
  return Zo(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? $i(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, $i(this.low << e | this.high >>> t, this.high << e | this.low >>> t, this.unsigned)) : (e -= 32, t = 32 - e, $i(this.high << e | this.low >>> t, this.low << e | this.high >>> t, this.unsigned));
};
pn.rotl = pn.rotateLeft;
pn.rotateRight = function(e) {
  var t;
  return Zo(e) && (e = e.toInt()), (e &= 63) === 0 ? this : e === 32 ? $i(this.high, this.low, this.unsigned) : e < 32 ? (t = 32 - e, $i(this.high << t | this.low >>> e, this.low << t | this.high >>> e, this.unsigned)) : (e -= 32, t = 32 - e, $i(this.low << t | this.high >>> e, this.high << t | this.low >>> e, this.unsigned));
};
pn.rotr = pn.rotateRight;
pn.toSigned = function() {
  return this.unsigned ? $i(this.low, this.high, !1) : this;
};
pn.toUnsigned = function() {
  return this.unsigned ? this : $i(this.low, this.high, !0);
};
pn.toBytes = function(e) {
  return e ? this.toBytesLE() : this.toBytesBE();
};
pn.toBytesLE = function() {
  var e = this.high, t = this.low;
  return [t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24, e & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24];
};
pn.toBytesBE = function() {
  var e = this.high, t = this.low;
  return [e >>> 24, e >>> 16 & 255, e >>> 8 & 255, e & 255, t >>> 24, t >>> 16 & 255, t >>> 8 & 255, t & 255];
};
ar.fromBytes = function(e, t, i) {
  return i ? ar.fromBytesLE(e, t) : ar.fromBytesBE(e, t);
};
ar.fromBytesLE = function(e, t) {
  return new ar(e[0] | e[1] << 8 | e[2] << 16 | e[3] << 24, e[4] | e[5] << 8 | e[6] << 16 | e[7] << 24, t);
};
ar.fromBytesBE = function(e, t) {
  return new ar(e[4] << 24 | e[5] << 16 | e[6] << 8 | e[7], e[0] << 24 | e[1] << 16 | e[2] << 8 | e[3], t);
};
const SG = 16;
function KS(n) {
  n === "X" && (n = "");
  const e = n.padEnd(SG, "0");
  return ar.fromString(e, !0, 16);
}
function CG(n) {
  if (n.isZero())
    return "X";
  let e = n.countTrailingZeros();
  const t = e % 4;
  e = (e - t) / 4;
  const i = e;
  e *= 4;
  const l = n.shiftRightUnsigned(e).toString(16).replace(/0+$/, "");
  return Array(17 - i - l.length).join("0") + l;
}
function PG(n, e) {
  const t = IG(n).shiftRightUnsigned(2);
  return n.add(ar.fromNumber(2 * e + 1 - 4).multiply(t));
}
function IG(n) {
  return n.and(n.not().add(1));
}
const MG = 3, LG = 30, RG = 2 * LG + 1, o5 = 180 / Math.PI;
function BG(n) {
  if (n.length === 0)
    throw new Error("Invalid Hilbert quad key ".concat(n));
  const e = n.split("/"), t = parseInt(e[0], 10), i = e[1], r = i.length;
  let l = 0;
  const c = [0, 0];
  for (let a = r - 1; a >= 0; a--) {
    l = r - a;
    const g = i[a];
    let y = 0, A = 0;
    g === "1" ? A = 1 : g === "2" ? (y = 1, A = 1) : g === "3" && (y = 1);
    const C = Math.pow(2, l - 1);
    DG(C, c, y, A), c[0] += C * y, c[1] += C * A;
  }
  if (t % 2 === 1) {
    const a = c[0];
    c[0] = c[1], c[1] = a;
  }
  return {
    face: t,
    ij: c,
    level: l
  };
}
function OG(n) {
  if (n.isZero())
    return "";
  let e = n.toString(2);
  for (; e.length < MG + RG; )
    e = "0" + e;
  const t = e.lastIndexOf("1"), i = e.substring(0, 3), r = e.substring(3, t), l = r.length / 2, c = ar.fromString(i, !0, 2).toString(10);
  let a = "";
  if (l !== 0)
    for (a = ar.fromString(r, !0, 2).toString(4); a.length < l; )
      a = "0" + a;
  return "".concat(c, "/").concat(a);
}
function QS(n, e, t) {
  const i = 1 << e;
  return [(n[0] + t[0]) / i, (n[1] + t[1]) / i];
}
function a5(n) {
  return n >= 0.5 ? 1 / 3 * (4 * n * n - 1) : 1 / 3 * (1 - 4 * (1 - n) * (1 - n));
}
function e3(n) {
  return [a5(n[0]), a5(n[1])];
}
function t3(n, e) {
  let [t, i] = e;
  switch (n) {
    case 0:
      return [1, t, i];
    case 1:
      return [-t, 1, i];
    case 2:
      return [-t, -i, 1];
    case 3:
      return [-1, -i, -t];
    case 4:
      return [i, -1, -t];
    case 5:
      return [i, t, -1];
    default:
      throw new Error("Invalid face");
  }
}
function n3(n) {
  let [e, t, i] = n;
  const r = Math.atan2(i, Math.sqrt(e * e + t * t));
  return [Math.atan2(t, e) * o5, r * o5];
}
function DG(n, e, t, i) {
  if (i === 0) {
    t === 1 && (e[0] = n - 1 - e[0], e[1] = n - 1 - e[1]);
    const r = e[0];
    e[0] = e[1], e[1] = r;
  }
}
function FG(n) {
  const e = QS(n.ij, n.level, [0.5, 0.5]), t = e3(e), i = t3(n.face, t);
  return n3(i);
}
const NG = 100;
function l5(n) {
  const {
    face: e,
    ij: t,
    level: i
  } = n, r = [[0, 0], [0, 1], [1, 1], [1, 0], [0, 0]], l = Math.max(1, Math.ceil(NG * Math.pow(2, -i))), c = new Float64Array(4 * l * 2 + 2);
  let a = 0, g = 0;
  for (let y = 0; y < 4; y++) {
    const A = r[y].slice(0), C = r[y + 1], I = (C[0] - A[0]) / l, S = (C[1] - A[1]) / l;
    for (let F = 0; F < l; F++) {
      A[0] += I, A[1] += S;
      const U = QS(t, i, A), V = e3(U), W = t3(e, V), X = n3(W);
      Math.abs(X[1]) > 89.999 && (X[0] = g);
      const de = X[0] - g;
      X[0] += de > 180 ? -360 : de < -180 ? 360 : 0, c[a++] = X[0], c[a++] = X[1], g = X[0];
    }
  }
  return c[a++] = c[0], c[a++] = c[1], c;
}
function Jb(n) {
  const e = kG(n);
  return BG(e);
}
function kG(n) {
  if (n.indexOf("/") > 0)
    return n;
  const e = KS(n);
  return OG(e);
}
function zG(n) {
  const e = Jb(n);
  return FG(e);
}
function UG(n) {
  let e;
  if (n.face === 2 || n.face === 5) {
    let t = null, i = 0;
    for (let r = 0; r < 4; r++) {
      const l = "".concat(n.face, "/").concat(r), c = Jb(l), a = l5(c);
      (typeof t > "u" || t === null) && (t = new Float64Array(4 * a.length)), t.set(a, i), i += a.length;
    }
    e = c5(t);
  } else {
    const t = l5(n);
    e = c5(t);
  }
  return e;
}
function c5(n) {
  if (n.length % 2 !== 0)
    throw new Error("Invalid corners");
  const e = [], t = [];
  for (let i = 0; i < n.length; i += 2)
    e.push(n[i]), t.push(n[i + 1]);
  return e.sort((i, r) => i - r), t.sort((i, r) => i - r), {
    west: e[0],
    east: e[e.length - 1],
    north: t[t.length - 1],
    south: t[0]
  };
}
function jG(n, e) {
  const t = (e == null ? void 0 : e.minimumHeight) || 0, i = (e == null ? void 0 : e.maximumHeight) || 0, r = Jb(n), l = UG(r), c = l.west, a = l.south, g = l.east, y = l.north, A = [];
  return A.push(new Tt(c, y, t)), A.push(new Tt(g, y, t)), A.push(new Tt(g, a, t)), A.push(new Tt(c, a, t)), A.push(new Tt(c, y, i)), A.push(new Tt(g, y, i)), A.push(new Tt(g, a, i)), A.push(new Tt(c, a, i)), A;
}
function i3(n) {
  const e = n.token, t = {
    minimumHeight: n.minimumHeight,
    maximumHeight: n.maximumHeight
  }, i = jG(e, t), r = zG(e), l = r[0], c = r[1], a = qr.WGS84.cartographicToCartesian([l, c, t.maximumHeight]), g = new Tt(a[0], a[1], a[2]);
  i.push(g);
  const y = pz(i);
  return [...y.center, ...y.halfAxes];
}
const GG = 4, VG = 8, qG = {
  QUADTREE: GG,
  OCTREE: VG
};
function HG(n, e, t) {
  if (n != null && n.box) {
    const i = KS(n.s2VolumeInfo.token), r = PG(i, e), l = CG(r), c = {
      ...n.s2VolumeInfo
    };
    switch (c.token = l, t) {
      case "OCTREE":
        const y = n.s2VolumeInfo, A = y.maximumHeight - y.minimumHeight, C = A / 2, I = y.minimumHeight + A / 2;
        y.minimumHeight = I - C, y.maximumHeight = I + C;
        break;
    }
    return {
      box: i3(c),
      s2VolumeInfo: c
    };
  }
}
async function r3(n) {
  const {
    options: e,
    parentData: t = {
      mortonIndex: 0,
      x: 0,
      y: 0,
      z: 0
    },
    childIndex: i = 0,
    globalData: r = {
      level: 0,
      mortonIndex: 0,
      x: 0,
      y: 0,
      z: 0
    },
    s2VolumeBox: l
  } = n;
  let {
    subtree: c,
    level: a = 0
  } = n;
  const {
    subdivisionScheme: g,
    subtreeLevels: y,
    maximumLevel: A,
    contentUrlTemplate: C,
    subtreesUriTemplate: I,
    basePath: S
  } = e, F = {
    children: [],
    lodMetricValue: 0,
    contentUrl: ""
  }, U = qG[g], V = i & 1, W = i >> 1 & 1, X = i >> 2 & 1, de = (U ** a - 1) / (U - 1);
  let ie = Dh(t.mortonIndex, i), fe = de + ie, Ae = Dh(t.x, V), Te = Dh(t.y, W), me = Dh(t.z, X), Ge = !1;
  a + 1 > y && (Ge = cy(c.childSubtreeAvailability, ie));
  const ke = Dh(r.x, Ae), pe = Dh(r.y, Te), _e = Dh(r.z, me), De = a + r.level;
  if (Ge) {
    const gt = "".concat(S, "/").concat(I), Rt = y1(gt, De, ke, pe, _e);
    c = await gh(Rt, ZS), r.mortonIndex = ie, r.x = Ae, r.y = Te, r.z = me, r.level = a, ie = 0, fe = 0, Ae = 0, Te = 0, me = 0, a = 0;
  }
  if (!cy(c.tileAvailability, fe) || a > A)
    return F;
  cy(c.contentAvailability, fe) && (F.contentUrl = y1(C, De, ke, pe, _e));
  const dt = a + 1, Pt = {
    mortonIndex: ie,
    x: Ae,
    y: Te,
    z: me
  };
  for (let gt = 0; gt < U; gt++) {
    const Rt = HG(l, gt, g), Ft = await r3({
      subtree: c,
      options: e,
      parentData: Pt,
      childIndex: gt,
      level: dt,
      globalData: r,
      s2VolumeBox: Rt
    });
    if (Ft.contentUrl || Ft.children.length) {
      const mn = De + 1, Re = WG(Ft, mn, {
        childTileX: Ae,
        childTileY: Te,
        childTileZ: me
      }, e, l);
      F.children.push(Re);
    }
  }
  return F;
}
function cy(n, e) {
  return "constant" in n ? !!n.constant : n.explicitBitstream ? XG(e, n.explicitBitstream) : !1;
}
function WG(n, e, t, i, r) {
  const {
    basePath: l,
    refine: c,
    getRefine: a,
    lodMetricType: g,
    getTileType: y,
    rootLodMetricValue: A,
    rootBoundingVolume: C
  } = i, I = n.contentUrl && n.contentUrl.replace("".concat(l, "/"), ""), S = A / 2 ** e, F = r != null && r.box ? {
    box: r.box
  } : C, U = ZG(e, F, t);
  return {
    children: n.children,
    contentUrl: n.contentUrl,
    content: {
      uri: I
    },
    id: n.contentUrl,
    refine: a(c),
    type: y(n),
    lodMetricType: g,
    lodMetricValue: S,
    geometricError: S,
    transform: n.transform,
    boundingVolume: U
  };
}
function ZG(n, e, t) {
  if (e.region) {
    const {
      childTileX: i,
      childTileY: r,
      childTileZ: l
    } = t, [c, a, g, y, A, C] = e.region, I = 2 ** n, S = (g - c) / I, F = (y - a) / I, U = (C - A) / I, [V, W] = [c + S * i, c + S * (i + 1)], [X, de] = [a + F * r, a + F * (r + 1)], [ie, fe] = [A + U * l, A + U * (l + 1)];
    return {
      region: [V, X, W, de, ie, fe]
    };
  }
  if (e.box)
    return e;
  throw new Error("Unsupported bounding volume type ".concat(e));
}
function Dh(n, e) {
  return parseInt(n.toString(2) + e.toString(2), 2);
}
function y1(n, e, t, i, r) {
  const l = $G({
    level: e,
    x: t,
    y: i,
    z: r
  });
  return n.replace(/{level}|{x}|{y}|{z}/gi, (c) => l[c]);
}
function $G(n) {
  const e = {};
  for (const t in n)
    e["{".concat(t, "}")] = n[t];
  return e;
}
function XG(n, e) {
  const t = Math.floor(n / 8), i = n % 8;
  return (e[t] >> i & 1) === 1;
}
function Kb(n) {
  if (!n.contentUrl)
    return Jd.EMPTY;
  const t = n.contentUrl.split("?")[0].split(".").pop();
  switch (t) {
    case "pnts":
      return Jd.POINTCLOUD;
    case "i3dm":
    case "b3dm":
    case "glb":
    case "gltf":
      return Jd.SCENEGRAPH;
    default:
      return t;
  }
}
function Qb(n) {
  switch (n) {
    case "REPLACE":
    case "replace":
      return Lu.REPLACE;
    case "ADD":
    case "add":
      return Lu.ADD;
    default:
      return n;
  }
}
function b1(n, e) {
  if (/^[a-z][0-9a-z+.-]*:/i.test(e)) {
    const i = new URL(n, "".concat(e, "/"));
    return decodeURI(i.toString());
  } else if (n.startsWith("/"))
    return n;
  return "".concat(e, "/").concat(n);
}
function u5(n, e) {
  if (!n)
    return null;
  if (n.content) {
    const t = n.content.uri || n.content.url;
    n.contentUrl = b1(t, e.basePath);
  }
  return n.id = n.contentUrl, n.lodMetricType = s_.GEOMETRIC_ERROR, n.lodMetricValue = n.geometricError, n.transformMatrix = n.transform, n.type = Kb(n), n.refine = Qb(n.refine), n;
}
async function YG(n, e) {
  const t = n.basePath;
  let i;
  const r = d5(n == null ? void 0 : n.root);
  r && n.root ? i = await h5(n.root, n, r, e) : i = u5(n.root, n);
  const l = [];
  for (l.push(i); l.length > 0; ) {
    const a = (l.pop() || {}).children || [];
    for (let g of a) {
      const y = d5(g);
      y ? g = await h5(g, n, y, e) : u5(g, {
        basePath: t
      }), l.push(g);
    }
  }
  return i;
}
async function h5(n, e, t, i) {
  var r, l;
  const c = e.basePath, {
    subdivisionScheme: a,
    maximumLevel: g,
    subtreeLevels: y,
    subtrees: {
      uri: A
    }
  } = t, C = y1(A, 0, 0, 0, 0), I = b1(C, c), S = await gh(I, ZS, i), F = b1(n.content.uri, c), U = e == null || (r = e.root) === null || r === void 0 ? void 0 : r.refine, V = n.geometricError, W = (l = n.boundingVolume.extensions) === null || l === void 0 ? void 0 : l["3DTILES_bounding_volume_S2"];
  if (W) {
    const fe = {
      box: i3(W),
      s2VolumeInfo: W
    };
    n.boundingVolume = fe;
  }
  const X = n.boundingVolume, de = {
    contentUrlTemplate: F,
    subtreesUriTemplate: A,
    subdivisionScheme: a,
    subtreeLevels: y,
    maximumLevel: g,
    refine: U,
    basePath: c,
    lodMetricType: s_.GEOMETRIC_ERROR,
    rootLodMetricValue: V,
    rootBoundingVolume: X,
    getTileType: Kb,
    getRefine: Qb
  };
  return await JG(n, S, de);
}
async function JG(n, e, t) {
  if (!n)
    return null;
  n.lodMetricType = s_.GEOMETRIC_ERROR, n.lodMetricValue = n.geometricError, n.transformMatrix = n.transform;
  const {
    children: i,
    contentUrl: r
  } = await r3({
    subtree: e,
    options: t,
    s2VolumeBox: n
  });
  return r && (n.contentUrl = r, n.content = {
    uri: r.replace("".concat(t.basePath, "/"), "")
  }), n.refine = Qb(n.refine), n.type = Kb(n), n.children = i, n.id = n.contentUrl, n;
}
function d5(n) {
  var e;
  return (n == null || (e = n.extensions) === null || e === void 0 ? void 0 : e["3DTILES_implicit_tiling"]) || (n == null ? void 0 : n.implicitTiling);
}
const ev = {
  id: "3d-tiles",
  name: "3D Tiles",
  module: "3d-tiles",
  version: zS,
  extensions: ["cmpt", "pnts", "b3dm", "i3dm"],
  mimeTypes: ["application/octet-stream"],
  tests: ["cmpt", "pnts", "b3dm", "i3dm"],
  parse: tV,
  options: {
    "3d-tiles": {
      loadGLTF: !0,
      decodeQuantizedPositions: !1,
      isTileset: "auto",
      assetGltfUpAxis: null
    }
  }
};
function KG(n) {
  return Z1(n.url);
}
async function QG(n, e, t) {
  const i = {
    content: {
      featureIds: null
    }
  };
  return await WS(n, 0, e, t, i.content), i.content;
}
async function eV(n, e, t) {
  var i;
  const r = JSON.parse(new TextDecoder().decode(n));
  return r.loader = e.loader || ev, r.url = t.url, r.queryString = t.queryString, r.basePath = KG(r), r.root = await YG(r, e), r.type = wl.TILES3D, r.lodMetricType = s_.GEOMETRIC_ERROR, r.lodMetricValue = ((i = r.root) === null || i === void 0 ? void 0 : i.lodMetricValue) || 0, r;
}
async function tV(n, e, t) {
  const i = e["3d-tiles"] || {};
  let r;
  return i.isTileset === "auto" ? r = t.url && t.url.indexOf(".json") !== -1 : r = i.isTileset, r ? n = await eV(n, e, t) : n = await QG(n, e, t), n;
}
const f5 = [0], nV = {
  getPointColor: {
    type: "accessor",
    value: [0, 0, 0, 255]
  },
  pointSize: 1,
  data: "",
  loader: ev,
  onTilesetLoad: {
    type: "function",
    value: (n) => {
    }
  },
  onTileLoad: {
    type: "function",
    value: (n) => {
    }
  },
  onTileUnload: {
    type: "function",
    value: (n) => {
    }
  },
  onTileError: {
    type: "function",
    value: (n, e, t) => {
    }
  },
  _getMeshColor: {
    type: "function",
    value: (n) => [255, 255, 255]
  }
};
class tv extends oS {
  constructor() {
    super(...arguments), H(this, "state", void 0);
  }
  initializeState() {
    "onTileLoadFail" in this.props && zi.removed("onTileLoadFail", "onTileError")(), this.state = {
      layerMap: {},
      tileset3d: null,
      activeViewports: {},
      lastUpdatedViewports: null
    };
  }
  get isLoaded() {
    var e, t;
    return !!(!((e = this.state) === null || e === void 0 || (t = e.tileset3d) === null || t === void 0) && t.isLoaded() && super.isLoaded);
  }
  shouldUpdateState(e) {
    let {
      changeFlags: t
    } = e;
    return t.somethingChanged;
  }
  updateState(e) {
    let {
      props: t,
      oldProps: i,
      changeFlags: r
    } = e;
    if (t.data && t.data !== i.data && this._loadTileset(t.data), r.viewportChanged) {
      const {
        activeViewports: l
      } = this.state;
      Object.keys(l).length && (this._updateTileset(l), this.state.lastUpdatedViewports = l, this.state.activeViewports = {});
    }
    if (r.propsChanged) {
      const {
        layerMap: l
      } = this.state;
      for (const c in l)
        l[c].needsUpdate = !0;
    }
  }
  activateViewport(e) {
    const {
      activeViewports: t,
      lastUpdatedViewports: i
    } = this.state;
    this.internalState.viewport = e, t[e.id] = e;
    const r = i == null ? void 0 : i[e.id];
    (!r || !e.equals(r)) && (this.setChangeFlags({
      viewportChanged: !0
    }), this.setNeedsUpdate());
  }
  getPickingInfo(e) {
    let {
      info: t,
      sourceLayer: i
    } = e;
    const r = i && i.props.tile;
    return t.picked && (t.object = r), t.sourceTile = r, t;
  }
  filterSubLayer(e) {
    let {
      layer: t,
      viewport: i
    } = e;
    const {
      tile: r
    } = t.props, {
      id: l
    } = i;
    return r.selected && r.viewportIds.includes(l);
  }
  _updateAutoHighlight(e) {
    const t = e.sourceTile, i = this.state.layerMap[t == null ? void 0 : t.id];
    i && i.layer && i.layer.updateAutoHighlight(e);
  }
  async _loadTileset(e) {
    const {
      loadOptions: t = {}
    } = this.props;
    let i = this.props.loader || this.props.loaders;
    Array.isArray(i) && (i = i[0]);
    const r = {
      loadOptions: {
        ...t
      }
    };
    let l = e;
    if (i.preload) {
      const g = await i.preload(e, t);
      g.url && (l = g.url), g.headers && (r.loadOptions.fetch = {
        ...r.loadOptions.fetch,
        headers: g.headers
      }), Object.assign(r, g);
    }
    const c = await gh(l, i, r.loadOptions), a = new Dj(c, {
      onTileLoad: this._onTileLoad.bind(this),
      onTileUnload: this._onTileUnload.bind(this),
      onTileError: this.props.onTileError,
      ...r
    });
    this.setState({
      tileset3d: a,
      layerMap: {}
    }), this._updateTileset(this.state.activeViewports), this.props.onTilesetLoad(a);
  }
  _onTileLoad(e) {
    const {
      lastUpdatedViewports: t
    } = this.state;
    this.props.onTileLoad(e), this._updateTileset(t), this.setNeedsUpdate();
  }
  _onTileUnload(e) {
    delete this.state.layerMap[e.id], this.props.onTileUnload(e);
  }
  _updateTileset(e) {
    if (!e)
      return;
    const {
      tileset3d: t
    } = this.state, {
      timeline: i
    } = this.context, r = Object.keys(e).length;
    !i || !r || !t || t.selectTiles(Object.values(e)).then((l) => {
      this.state.frameNumber !== l && this.setState({
        frameNumber: l
      });
    });
  }
  _getSubLayer(e, t) {
    if (!e.content)
      return null;
    switch (e.type) {
      case Jd.POINTCLOUD:
        return this._makePointCloudLayer(e, t);
      case Jd.SCENEGRAPH:
        return this._make3DModelLayer(e);
      case Jd.MESH:
        return this._makeSimpleMeshLayer(e, t);
      default:
        throw new Error("Tile3DLayer: Failed to render layer of type ".concat(e.content.type));
    }
  }
  _makePointCloudLayer(e, t) {
    const {
      attributes: i,
      pointCount: r,
      constantRGBA: l,
      cartographicOrigin: c,
      modelMatrix: a
    } = e.content, {
      positions: g,
      normals: y,
      colors: A
    } = i;
    if (!g)
      return null;
    const C = t && t.props.data || {
      header: {
        vertexCount: r
      },
      attributes: {
        POSITION: g,
        NORMAL: y,
        COLOR_0: A
      }
    }, {
      pointSize: I,
      getPointColor: S
    } = this.props, F = this.getSubLayerClass("pointcloud", Nb);
    return new F({
      pointSize: I
    }, this.getSubLayerProps({
      id: "pointcloud"
    }), {
      id: "".concat(this.id, "-pointcloud-").concat(e.id),
      tile: e,
      data: C,
      coordinateSystem: Bi.METER_OFFSETS,
      coordinateOrigin: c,
      modelMatrix: a,
      getColor: l || S,
      _offset: 0
    });
  }
  _make3DModelLayer(e) {
    const {
      gltf: t,
      instances: i,
      cartographicOrigin: r,
      modelMatrix: l
    } = e.content, c = this.getSubLayerClass("scenegraph", Hb);
    return new c({
      _lighting: "pbr"
    }, this.getSubLayerProps({
      id: "scenegraph"
    }), {
      id: "".concat(this.id, "-scenegraph-").concat(e.id),
      tile: e,
      data: i || f5,
      scenegraph: t,
      coordinateSystem: Bi.METER_OFFSETS,
      coordinateOrigin: r,
      modelMatrix: l,
      getTransformMatrix: (a) => a.modelMatrix,
      getPosition: [0, 0, 0],
      _offset: 0
    });
  }
  _makeSimpleMeshLayer(e, t) {
    const i = e.content, {
      attributes: r,
      indices: l,
      modelMatrix: c,
      cartographicOrigin: a,
      coordinateSystem: g = Bi.METER_OFFSETS,
      material: y,
      featureIds: A
    } = i, {
      _getMeshColor: C
    } = this.props, I = t && t.props.mesh || new xp({
      drawMode: 4,
      attributes: iV(r),
      indices: l
    }), S = this.getSubLayerClass("mesh", Wb);
    return new S(this.getSubLayerProps({
      id: "mesh"
    }), {
      id: "".concat(this.id, "-mesh-").concat(e.id),
      tile: e,
      mesh: I,
      data: f5,
      getColor: C(e),
      pbrMaterial: y,
      modelMatrix: c,
      coordinateOrigin: a,
      coordinateSystem: g,
      featureIds: A,
      _offset: 0
    });
  }
  renderLayers() {
    const {
      tileset3d: e,
      layerMap: t
    } = this.state;
    return e ? e.tiles.map((i) => {
      const r = t[i.id] = t[i.id] || {
        tile: i
      };
      let {
        layer: l
      } = r;
      return i.selected && (l ? r.needsUpdate && (l = this._getSubLayer(i, l), r.needsUpdate = !1) : l = this._getSubLayer(i)), r.layer = l, l;
    }).filter(Boolean) : null;
  }
}
H(tv, "defaultProps", nV);
H(tv, "layerName", "Tile3DLayer");
function iV(n) {
  const e = {};
  return e.positions = {
    ...n.positions,
    value: new Float32Array(n.positions.value)
  }, n.normals && (e.normals = n.normals), n.texCoords && (e.texCoords = n.texCoords), n.colors && (e.colors = n.colors), n.uvRegions && (e.uvRegions = n.uvRegions), e;
}
var rV = Object.defineProperty, sV = (n, e, t) => e in n ? rV(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, qi = (n, e, t) => sV(n, typeof e != "symbol" ? e + "" : e, t);
class oV {
  constructor(e) {
    qi(this, "map"), qi(this, "width"), qi(this, "height"), qi(this, "svgCanvas"), qi(this, "xLine"), qi(this, "yLine"), qi(this, "color", "#535353"), this.map = e, this.mapResize = this.mapResize.bind(this);
  }
  create() {
    this.updateValues(), this.map !== void 0 ? (this.map.on("resize", this.mapResize), this.createCanvas(this.map.getCanvasContainer())) : console.error("map object is null");
  }
  updateValues() {
    var e, t;
    this.width = (e = this.map) == null ? void 0 : e.getCanvas().clientWidth, this.height = (t = this.map) == null ? void 0 : t.getCanvas().clientHeight;
  }
  mapResize() {
    this.updateValues(), this.updateCanvas();
  }
  updateCanvas() {
    if (this.svgCanvas !== void 0 && this.yLine !== void 0 && this.xLine !== void 0 && this.width !== void 0 && this.height !== void 0) {
      this.svgCanvas.setAttribute("width", `${this.width}px`), this.svgCanvas.setAttribute("height", `${this.height}px`);
      const e = this.width / 2, t = this.height / 2;
      this.yLine.setAttribute("x1", `${e}px`), this.yLine.setAttribute("y1", "0px"), this.yLine.setAttribute("x2", `${e}px`), this.yLine.setAttribute("y2", `${this.height}px`), this.xLine.setAttribute("x1", "0px"), this.xLine.setAttribute("y1", `${t}px`), this.xLine.setAttribute("x2", `${this.width}px`), this.xLine.setAttribute("y2", `${t}px`);
    } else console.error("element value is null");
  }
  createCanvas(e) {
    if (this.width !== void 0 && this.height !== void 0) {
      const t = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      t.style.position = "relative", t.setAttribute("width", `${this.width}px`), t.setAttribute("height", `${this.height}px`);
      const i = this.width / 2, r = this.height / 2;
      this.yLine = t.appendChild(this.createLine(i, 0, i, this.height, this.color, "2px")), this.xLine = t.appendChild(this.createLine(0, r, this.width, r, this.color, "2px")), e == null || e.appendChild(t), this.svgCanvas = t;
    }
  }
  createLine(e, t, i, r, l, c) {
    const a = document.createElementNS("http://www.w3.org/2000/svg", "line");
    return a.setAttribute("x1", e), a.setAttribute("y1", t), a.setAttribute("x2", i), a.setAttribute("y2", r), a.setAttribute("stroke-dasharray", "5,5"), a.setAttribute("stroke", l), a.setAttribute("stroke-width", c), a;
  }
  destroy() {
    this.xLine !== void 0 && (this.xLine.remove(), this.xLine = void 0), this.yLine !== void 0 && (this.yLine.remove(), this.yLine = void 0), this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map.off("resize", this.mapResize), this.map = void 0);
  }
}
const v1 = { 72: 72, 96: 96, 200: 200, 300: 300, 400: 400 }, Eu = { JPEG: "jpg", PNG: "png", PDF: "pdf", SVG: "svg" }, pp = { Landscape: "landscape", Portrait: "portrait" }, qh = {
  // A0, A1, B0, B1 are not working well.
  // A0: [1189, 841],
  // A1: [841, 594],
  LETTER: [279, 216],
  // 8.5x11 - works
  //TABLOID: [432,279] // 11x17 - not working currently prints to 11.68x8.27 in landscape
  A2: [594, 420],
  A3: [420, 297],
  A4: [297, 210],
  A5: [210, 148],
  A6: [148, 105],
  // B0: [1414, 1000],
  // B1: [1000, 707],
  B2: [707, 500],
  B3: [500, 353],
  B4: [353, 250],
  B5: [250, 176],
  B6: [176, 125]
}, pf = {
  // don't use inch unit. because page size setting is using mm unit.
  in: "in",
  mm: "mm"
};
class aV {
  constructor(e) {
    qi(this, "map"), qi(this, "width"), qi(this, "height"), qi(this, "unit"), qi(this, "svgCanvas"), qi(this, "svgPath");
    var t, i, r;
    if (this.map = e, this.map === void 0) return;
    this.mapResize = this.mapResize.bind(this), this.map.on("resize", this.mapResize);
    const l = (t = this.map) == null ? void 0 : t.getCanvas().clientWidth, c = (i = this.map) == null ? void 0 : i.getCanvas().clientHeight, a = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    a.style.position = "absolute", a.style.top = "0px", a.style.left = "0px", a.setAttribute("width", `${l}px`), a.setAttribute("height", `${c}px`);
    const g = document.createElementNS("http://www.w3.org/2000/svg", "path");
    g.setAttribute("style", "fill:#888888;stroke-width:0"), g.setAttribute("fill-opacity", "0.5"), a.append(g), (r = this.map) == null || r.getCanvasContainer().appendChild(a), this.svgCanvas = a, this.svgPath = g;
  }
  mapResize() {
    this.generateCutOut();
  }
  updateArea(e, t) {
    this.width = e, this.height = t, this.unit = pf.mm, this.generateCutOut();
  }
  generateCutOut() {
    var e, t;
    if (this.map === void 0 || this.svgCanvas === void 0 || this.svgPath === void 0) return;
    const i = this.toPixels(this.width), r = this.toPixels(this.height), l = (e = this.map) == null ? void 0 : e.getCanvas().clientWidth, c = (t = this.map) == null ? void 0 : t.getCanvas().clientHeight, a = l / 2 - i / 2, g = a + i, y = c / 2 - r / 2, A = y + r;
    this.svgCanvas.setAttribute("width", `${l}px`), this.svgCanvas.setAttribute("height", `${c}px`), this.svgPath.setAttribute("d", `M 0 0 L ${l} 0 L ${l} ${c} L 0 ${c} M ${a} ${y} L ${a} ${A} L ${g} ${A} L ${g} ${y}`);
  }
  destroy() {
    this.svgCanvas !== void 0 && (this.svgCanvas.remove(), this.svgCanvas = void 0), this.map !== void 0 && (this.map = void 0);
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 96;
    return this.unit === pf.mm && (t /= 25.4), t * e;
  }
}
const s3 = { PageSize: "Page Size", PageOrientation: "Page Orientation", Format: "Format", DPI: "DPI", Generate: "Generate", LanguageName: "English", LanguageCode: "en" }, lV = { PageSize: "Taille de page", PageOrientation: "Orientation de la page", Format: "Format", DPI: "DPI", Generate: "Générer", LanguageName: "Français", LanguageCode: "fr" }, cV = { PageSize: "Sivukoko", PageOrientation: "Sivun suunta", Format: "Muoto", DPI: "DPI", Generate: "Generoi", LanguageName: "Suomalainen", LanguageCode: "fi" }, uV = { PageSize: "Papierformat", PageOrientation: "Papierausrichtung", Format: "Dateiformat", DPI: "Druckauflösung", Generate: "Erstellen", LanguageName: "Deutsch", LanguageCode: "de" }, hV = { PageSize: "Sidstorlek", PageOrientation: "Sidorientering", Format: "Format", DPI: "DPI", Generate: "Generera", LanguageName: "Svenska", LanguageCode: "sv" }, dV = { PageSize: "Tamaño de página", PageOrientation: "Orientación de página", Format: "Formato", DPI: "DPI", Generate: "Generar", LanguageName: "Española", LanguageCode: "es" }, fV = { PageSize: "Mida", PageOrientation: "Orientació", Format: "Format", DPI: "DPI", Generate: "Genera", LanguageName: "Catalan", LanguageCode: "ca" }, pV = { PageSize: "Kích thước trang", PageOrientation: "Loại trang", Format: "Định dạng", DPI: "Mật độ điểm ảnh (DPI)", Generate: "Tạo", LanguageName: "Tiếng Việt", LanguageCode: "vi" }, gV = { PageSize: "Розмір сторінки", PageOrientation: "Орієнтація сторінки", Format: "Формат", DPI: "DPI", Generate: "Згенерувати", LanguageName: "українська", LanguageCode: "uk" }, mV = { PageSize: "页面大小", PageOrientation: "页面方向", Format: "格式", DPI: "像素", Generate: "导出", LanguageName: "简体字", LanguageCode: "zhHans" }, _V = { PageSize: "頁面大小", PageOrientation: "頁面方向", Format: "格式", DPI: "像素", Generate: "導出", LanguageName: "繁体字", LanguageCode: "zhHant" }, yV = { PageSize: "ページサイズ", PageOrientation: "ページ方向", Format: "フォーマット", DPI: "DPI（解像度）", Generate: "出力", LanguageName: "日本語", LanguageCode: "ja" }, bV = { PageSize: "Tamanho da página", PageOrientation: "Orientação da página", Format: "Formato", DPI: "DPI", Generate: "Gerar", LanguageName: "Português", LanguageCode: "pt" }, vV = [s3, lV, cV, uV, hV, dV, fV, pV, gV, mV, _V, yV, bV], xV = (n) => vV.find((e) => e.LanguageCode === n) ?? s3;
function or(n) {
  "@babel/helpers - typeof";
  return or = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, or(n);
}
var Ho = Uint8Array, tl = Uint16Array, nv = Int32Array, l_ = new Ho([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), c_ = new Ho([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), x1 = new Ho([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), o3 = function(n, e) {
  for (var t = new tl(31), i = 0; i < 31; ++i) t[i] = e += 1 << n[i - 1];
  for (var r = new nv(t[30]), i = 1; i < 30; ++i) for (var l = t[i]; l < t[i + 1]; ++l) r[l] = l - t[i] << 5 | i;
  return { b: t, r };
}, a3 = o3(l_, 2), l3 = a3.b, w1 = a3.r;
l3[28] = 258, w1[258] = 28;
var c3 = o3(c_, 0), wV = c3.b, p5 = c3.r, A1 = new tl(32768);
for (var Or = 0; Or < 32768; ++Or) {
  var oh = (Or & 43690) >> 1 | (Or & 21845) << 1;
  oh = (oh & 52428) >> 2 | (oh & 13107) << 2, oh = (oh & 61680) >> 4 | (oh & 3855) << 4, A1[Or] = ((oh & 65280) >> 8 | (oh & 255) << 8) >> 1;
}
var tu = function(n, e, t) {
  for (var i = n.length, r = 0, l = new tl(e); r < i; ++r) n[r] && ++l[n[r] - 1];
  var c = new tl(e);
  for (r = 1; r < e; ++r) c[r] = c[r - 1] + l[r - 1] << 1;
  var a;
  if (t) {
    a = new tl(1 << e);
    var g = 15 - e;
    for (r = 0; r < i; ++r) if (n[r]) for (var y = r << 4 | n[r], A = e - n[r], C = c[n[r] - 1]++ << A, I = C | (1 << A) - 1; C <= I; ++C) a[A1[C] >> g] = y;
  } else for (a = new tl(i), r = 0; r < i; ++r) n[r] && (a[r] = A1[c[n[r] - 1]++] >> 15 - n[r]);
  return a;
}, _h = new Ho(288);
for (var Or = 0; Or < 144; ++Or) _h[Or] = 8;
for (var Or = 144; Or < 256; ++Or) _h[Or] = 9;
for (var Or = 256; Or < 280; ++Or) _h[Or] = 7;
for (var Or = 280; Or < 288; ++Or) _h[Or] = 8;
var Dp = new Ho(32);
for (var Or = 0; Or < 32; ++Or) Dp[Or] = 5;
var AV = /* @__PURE__ */ tu(_h, 9, 0), TV = /* @__PURE__ */ tu(_h, 9, 1), EV = /* @__PURE__ */ tu(Dp, 5, 0), SV = /* @__PURE__ */ tu(Dp, 5, 1), uy = function(n) {
  for (var e = n[0], t = 1; t < n.length; ++t) n[t] > e && (e = n[t]);
  return e;
}, lc = function(n, e, t) {
  var i = e / 8 | 0;
  return (n[i] | n[i + 1] << 8) >> (e & 7) & t;
}, hy = function(n, e) {
  var t = e / 8 | 0;
  return (n[t] | n[t + 1] << 8 | n[t + 2] << 16) >> (e & 7);
}, iv = function(n) {
  return (n + 7) / 8 | 0;
}, u3 = function(n, e, t) {
  return (t == null || t > n.length) && (t = n.length), new Ho(n.subarray(e, t));
}, CV = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], dc = function(n, e, t) {
  var i = new Error(e || CV[n]);
  if (i.code = n, Error.captureStackTrace && Error.captureStackTrace(i, dc), !t) throw i;
  return i;
}, PV = function(n, e, t, i) {
  var r = n.length, l = 0;
  if (!r || e.f && !e.l) return t || new Ho(0);
  var c = !t, a = c || e.i != 2, g = e.i;
  c && (t = new Ho(r * 3));
  var y = function(Wt) {
    var on = t.length;
    if (Wt > on) {
      var hn = new Ho(Math.max(on * 2, Wt));
      hn.set(t), t = hn;
    }
  }, A = e.f || 0, C = e.p || 0, I = e.b || 0, S = e.l, F = e.d, U = e.m, V = e.n, W = r * 8;
  do {
    if (!S) {
      A = lc(n, C, 1);
      var X = lc(n, C + 1, 3);
      if (C += 3, X)
        if (X == 1) S = TV, F = SV, U = 9, V = 5;
        else if (X == 2) {
          var de = lc(n, C, 31) + 257, ie = lc(n, C + 10, 15) + 4, fe = de + lc(n, C + 5, 31) + 1;
          C += 14;
          for (var Ae = new Ho(fe), Te = new Ho(19), me = 0; me < ie; ++me) Te[x1[me]] = lc(n, C + me * 3, 7);
          C += ie * 3;
          for (var Ge = uy(Te), ke = (1 << Ge) - 1, pe = tu(Te, Ge, 1), me = 0; me < fe; ) {
            var _e = pe[lc(n, C, ke)];
            C += _e & 15;
            var De = _e >> 4;
            if (De < 16) Ae[me++] = De;
            else {
              var Me = 0, St = 0;
              for (De == 16 ? (St = 3 + lc(n, C, 3), C += 2, Me = Ae[me - 1]) : De == 17 ? (St = 3 + lc(n, C, 7), C += 3) : De == 18 && (St = 11 + lc(n, C, 127), C += 7); St--; ) Ae[me++] = Me;
            }
          }
          var dt = Ae.subarray(0, de), Pt = Ae.subarray(de);
          U = uy(dt), V = uy(Pt), S = tu(dt, U, 1), F = tu(Pt, V, 1);
        } else dc(1);
      else {
        var De = iv(C) + 4, gt = n[De - 4] | n[De - 3] << 8, Rt = De + gt;
        if (Rt > r) {
          g && dc(0);
          break;
        }
        a && y(I + gt), t.set(n.subarray(De, Rt), I), e.b = I += gt, e.p = C = Rt * 8, e.f = A;
        continue;
      }
      if (C > W) {
        g && dc(0);
        break;
      }
    }
    a && y(I + 131072);
    for (var Ft = (1 << U) - 1, mn = (1 << V) - 1, oe = C; ; oe = C) {
      var Me = S[hy(n, C) & Ft], Re = Me >> 4;
      if (C += Me & 15, C > W) {
        g && dc(0);
        break;
      }
      if (Me || dc(2), Re < 256) t[I++] = Re;
      else if (Re == 256) {
        oe = C, S = null;
        break;
      } else {
        var ze = Re - 254;
        if (Re > 264) {
          var me = Re - 257, Xe = l_[me];
          ze = lc(n, C, (1 << Xe) - 1) + l3[me], C += Xe;
        }
        var ot = F[hy(n, C) & mn], rt = ot >> 4;
        ot || dc(3), C += ot & 15;
        var Pt = wV[rt];
        if (rt > 3) {
          var Xe = c_[rt];
          Pt += hy(n, C) & (1 << Xe) - 1, C += Xe;
        }
        if (C > W) {
          g && dc(0);
          break;
        }
        a && y(I + 131072);
        var xt = I + ze;
        if (I < Pt) {
          var ht = l - Pt, $t = Math.min(Pt, xt);
          for (ht + I < 0 && dc(3); I < $t; ++I) t[I] = i[ht + I];
        }
        for (; I < xt; ++I) t[I] = t[I - Pt];
      }
    }
    e.l = S, e.p = oe, e.b = I, e.f = A, S && (A = 1, e.m = U, e.d = F, e.n = V);
  } while (!A);
  return I != t.length && c ? u3(t, 0, I) : t.subarray(0, I);
}, Au = function(n, e, t) {
  t <<= e & 7;
  var i = e / 8 | 0;
  n[i] |= t, n[i + 1] |= t >> 8;
}, op = function(n, e, t) {
  t <<= e & 7;
  var i = e / 8 | 0;
  n[i] |= t, n[i + 1] |= t >> 8, n[i + 2] |= t >> 16;
}, dy = function(n, e) {
  for (var t = [], i = 0; i < n.length; ++i) n[i] && t.push({ s: i, f: n[i] });
  var r = t.length, l = t.slice();
  if (!r) return { t: d3, l: 0 };
  if (r == 1) {
    var c = new Ho(t[0].s + 1);
    return c[t[0].s] = 1, { t: c, l: 1 };
  }
  t.sort(function(fe, Ae) {
    return fe.f - Ae.f;
  }), t.push({ s: -1, f: 25001 });
  var a = t[0], g = t[1], y = 0, A = 1, C = 2;
  for (t[0] = { s: -1, f: a.f + g.f, l: a, r: g }; A != r - 1; ) a = t[t[y].f < t[C].f ? y++ : C++], g = t[y != A && t[y].f < t[C].f ? y++ : C++], t[A++] = { s: -1, f: a.f + g.f, l: a, r: g };
  for (var I = l[0].s, i = 1; i < r; ++i) l[i].s > I && (I = l[i].s);
  var S = new tl(I + 1), F = T1(t[A - 1], S, 0);
  if (F > e) {
    var i = 0, U = 0, V = F - e, W = 1 << V;
    for (l.sort(function(Ae, Te) {
      return S[Te.s] - S[Ae.s] || Ae.f - Te.f;
    }); i < r; ++i) {
      var X = l[i].s;
      if (S[X] > e) U += W - (1 << F - S[X]), S[X] = e;
      else break;
    }
    for (U >>= V; U > 0; ) {
      var de = l[i].s;
      S[de] < e ? U -= 1 << e - S[de]++ - 1 : ++i;
    }
    for (; i >= 0 && U; --i) {
      var ie = l[i].s;
      S[ie] == e && (--S[ie], ++U);
    }
    F = e;
  }
  return { t: new Ho(S), l: F };
}, T1 = function(n, e, t) {
  return n.s == -1 ? Math.max(T1(n.l, e, t + 1), T1(n.r, e, t + 1)) : e[n.s] = t;
}, g5 = function(n) {
  for (var e = n.length; e && !n[--e]; ) ;
  for (var t = new tl(++e), i = 0, r = n[0], l = 1, c = function(g) {
    t[i++] = g;
  }, a = 1; a <= e; ++a) if (n[a] == r && a != e) ++l;
  else {
    if (!r && l > 2) {
      for (; l > 138; l -= 138) c(32754);
      l > 2 && (c(l > 10 ? l - 11 << 5 | 28690 : l - 3 << 5 | 12305), l = 0);
    } else if (l > 3) {
      for (c(r), --l; l > 6; l -= 6) c(8304);
      l > 2 && (c(l - 3 << 5 | 8208), l = 0);
    }
    for (; l--; ) c(r);
    l = 1, r = n[a];
  }
  return { c: t.subarray(0, i), n: e };
}, ap = function(n, e) {
  for (var t = 0, i = 0; i < e.length; ++i) t += n[i] * e[i];
  return t;
}, h3 = function(n, e, t) {
  var i = t.length, r = iv(e + 2);
  n[r] = i & 255, n[r + 1] = i >> 8, n[r + 2] = n[r] ^ 255, n[r + 3] = n[r + 1] ^ 255;
  for (var l = 0; l < i; ++l) n[r + l + 4] = t[l];
  return (r + 4 + i) * 8;
}, m5 = function(n, e, t, i, r, l, c, a, g, y, A) {
  Au(e, A++, t), ++r[256];
  for (var C = dy(r, 15), I = C.t, S = C.l, F = dy(l, 15), U = F.t, V = F.l, W = g5(I), X = W.c, de = W.n, ie = g5(U), fe = ie.c, Ae = ie.n, Te = new tl(19), me = 0; me < X.length; ++me) ++Te[X[me] & 31];
  for (var me = 0; me < fe.length; ++me) ++Te[fe[me] & 31];
  for (var Ge = dy(Te, 7), ke = Ge.t, pe = Ge.l, _e = 19; _e > 4 && !ke[x1[_e - 1]]; --_e) ;
  var De = y + 5 << 3, Me = ap(r, _h) + ap(l, Dp) + c, St = ap(r, I) + ap(l, U) + c + 14 + 3 * _e + ap(Te, ke) + 2 * Te[16] + 3 * Te[17] + 7 * Te[18];
  if (g >= 0 && De <= Me && De <= St) return h3(e, A, n.subarray(g, g + y));
  var dt, Pt, gt, Rt;
  if (Au(e, A, 1 + (St < Me)), A += 2, St < Me) {
    dt = tu(I, S, 0), Pt = I, gt = tu(U, V, 0), Rt = U;
    var Ft = tu(ke, pe, 0);
    Au(e, A, de - 257), Au(e, A + 5, Ae - 1), Au(e, A + 10, _e - 4), A += 14;
    for (var me = 0; me < _e; ++me) Au(e, A + 3 * me, ke[x1[me]]);
    A += 3 * _e;
    for (var mn = [X, fe], oe = 0; oe < 2; ++oe) for (var Re = mn[oe], me = 0; me < Re.length; ++me) {
      var ze = Re[me] & 31;
      Au(e, A, Ft[ze]), A += ke[ze], ze > 15 && (Au(e, A, Re[me] >> 5 & 127), A += Re[me] >> 12);
    }
  } else dt = AV, Pt = _h, gt = EV, Rt = Dp;
  for (var me = 0; me < a; ++me) {
    var Xe = i[me];
    if (Xe > 255) {
      var ze = Xe >> 18 & 31;
      op(e, A, dt[ze + 257]), A += Pt[ze + 257], ze > 7 && (Au(e, A, Xe >> 23 & 31), A += l_[ze]);
      var ot = Xe & 31;
      op(e, A, gt[ot]), A += Rt[ot], ot > 3 && (op(e, A, Xe >> 5 & 8191), A += c_[ot]);
    } else op(e, A, dt[Xe]), A += Pt[Xe];
  }
  return op(e, A, dt[256]), A + Pt[256];
}, IV = /* @__PURE__ */ new nv([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), d3 = /* @__PURE__ */ new Ho(0), MV = function(n, e, t, i, r, l) {
  var c = l.z || n.length, a = new Ho(i + c + 5 * (1 + Math.ceil(c / 7e3)) + r), g = a.subarray(i, a.length - r), y = l.l, A = (l.r || 0) & 7;
  if (e) {
    A && (g[0] = l.r >> 3);
    for (var C = IV[e - 1], I = C >> 13, S = C & 8191, F = (1 << t) - 1, U = l.p || new tl(32768), V = l.h || new tl(F + 1), W = Math.ceil(t / 3), X = 2 * W, de = function(wn) {
      return (n[wn] ^ n[wn + 1] << W ^ n[wn + 2] << X) & F;
    }, ie = new nv(25e3), fe = new tl(288), Ae = new tl(32), Te = 0, me = 0, Ge = l.i || 0, ke = 0, pe = l.w || 0, _e = 0; Ge + 2 < c; ++Ge) {
      var De = de(Ge), Me = Ge & 32767, St = V[De];
      if (U[Me] = St, V[De] = Me, pe <= Ge) {
        var dt = c - Ge;
        if ((Te > 7e3 || ke > 24576) && (dt > 423 || !y)) {
          A = m5(n, g, 0, ie, fe, Ae, me, ke, _e, Ge - _e, A), ke = Te = me = 0, _e = Ge;
          for (var Pt = 0; Pt < 286; ++Pt) fe[Pt] = 0;
          for (var Pt = 0; Pt < 30; ++Pt) Ae[Pt] = 0;
        }
        var gt = 2, Rt = 0, Ft = S, mn = Me - St & 32767;
        if (dt > 2 && De == de(Ge - mn)) for (var oe = Math.min(I, dt) - 1, Re = Math.min(32767, Ge), ze = Math.min(258, dt); mn <= Re && --Ft && Me != St; ) {
          if (n[Ge + gt] == n[Ge + gt - mn]) {
            for (var Xe = 0; Xe < ze && n[Ge + Xe] == n[Ge + Xe - mn]; ++Xe) ;
            if (Xe > gt) {
              if (gt = Xe, Rt = mn, Xe > oe) break;
              for (var ot = Math.min(mn, Xe - 2), rt = 0, Pt = 0; Pt < ot; ++Pt) {
                var xt = Ge - mn + Pt & 32767, ht = U[xt], $t = xt - ht & 32767;
                $t > rt && (rt = $t, St = xt);
              }
            }
          }
          Me = St, St = U[Me], mn += Me - St & 32767;
        }
        if (Rt) {
          ie[ke++] = 268435456 | w1[gt] << 18 | p5[Rt];
          var Wt = w1[gt] & 31, on = p5[Rt] & 31;
          me += l_[Wt] + c_[on], ++fe[257 + Wt], ++Ae[on], pe = Ge + gt, ++Te;
        } else ie[ke++] = n[Ge], ++fe[n[Ge]];
      }
    }
    for (Ge = Math.max(Ge, pe); Ge < c; ++Ge) ie[ke++] = n[Ge], ++fe[n[Ge]];
    A = m5(n, g, y, ie, fe, Ae, me, ke, _e, Ge - _e, A), y || (l.r = A & 7 | g[A / 8 | 0] << 3, A -= 7, l.h = V, l.p = U, l.i = Ge, l.w = pe);
  } else {
    for (var Ge = l.w || 0; Ge < c + y; Ge += 65535) {
      var hn = Ge + 65535;
      hn >= c && (g[A / 8 | 0] = y, hn = c), A = h3(g, A + 1, n.subarray(Ge, hn));
    }
    l.i = c;
  }
  return u3(a, 0, i + iv(A) + r);
}, f3 = function() {
  var n = 1, e = 0;
  return { p: function(t) {
    for (var i = n, r = e, l = t.length | 0, c = 0; c != l; ) {
      for (var a = Math.min(c + 2655, l); c < a; ++c) r += i += t[c];
      i = (i & 65535) + 15 * (i >> 16), r = (r & 65535) + 15 * (r >> 16);
    }
    n = i, e = r;
  }, d: function() {
    return n %= 65521, e %= 65521, (n & 255) << 24 | (n & 65280) << 8 | (e & 255) << 8 | e >> 8;
  } };
}, LV = function(n, e, t, i, r) {
  if (!r && (r = { l: 1 }, e.dictionary)) {
    var l = e.dictionary.subarray(-32768), c = new Ho(l.length + n.length);
    c.set(l), c.set(n, l.length), n = c, r.w = l.length;
  }
  return MV(n, e.level == null ? 6 : e.level, e.mem == null ? r.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(n.length))) * 1.5) : 20 : 12 + e.mem, t, i, r);
}, p3 = function(n, e, t) {
  for (; t; ++e) n[e] = t, t >>>= 8;
}, RV = function(n, e) {
  var t = e.level, i = t == 0 ? 0 : t < 6 ? 1 : t == 9 ? 3 : 2;
  if (n[0] = 120, n[1] = i << 6 | (e.dictionary && 32), n[1] |= 31 - (n[0] << 8 | n[1]) % 31, e.dictionary) {
    var r = f3();
    r.p(e.dictionary), p3(n, 2, r.d());
  }
}, BV = function(n, e) {
  return ((n[0] & 15) != 8 || n[0] >> 4 > 7 || (n[0] << 8 | n[1]) % 31) && dc(6, "invalid zlib data"), (n[1] >> 5 & 1) == 1 && dc(6, "invalid zlib data: " + (n[1] & 32 ? "need" : "unexpected") + " dictionary"), (n[1] >> 3 & 4) + 2;
};
function E1(n, e) {
  e || (e = {});
  var t = f3();
  t.p(n);
  var i = LV(n, e, e.dictionary ? 6 : 2, 4);
  return RV(i, e), p3(i, i.length - 4, t.d()), i;
}
function OV(n, e) {
  return PV(n.subarray(BV(n), -4), { i: 2 }, e, e);
}
var DV = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), FV = 0;
try {
  DV.decode(d3, { stream: !0 }), FV = 1;
} catch {
}
/** @license
*
* jsPDF - PDF Document creation from JavaScript
* Version 2.5.2 Built on 2024-09-17T13:29:57.859Z
*                      CommitID 00000000
*
* Copyright (c) 2010-2021 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
*               2015-2021 yWorks GmbH, http://www.yworks.com
*               2015-2021 Lukas Holländer <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
*               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
*               2010 Aaron Spike, https://github.com/acspike
*               2012 Willow Systems Corporation, https://github.com/willowsystems
*               2012 Pablo Hess, https://github.com/pablohess
*               2012 Florian Jenett, https://github.com/fjenett
*               2013 Warren Weckesser, https://github.com/warrenweckesser
*               2013 Youssef Beddad, https://github.com/lifof
*               2013 Lee Driscoll, https://github.com/lsdriscoll
*               2013 Stefan Slonevskiy, https://github.com/stefslon
*               2013 Jeremy Morel, https://github.com/jmorel
*               2013 Christoph Hartmann, https://github.com/chris-rock
*               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
*               2014 James Makes, https://github.com/dollaruw
*               2014 Diego Casorran, https://github.com/diegocr
*               2014 Steven Spungin, https://github.com/Flamenco
*               2014 Kenneth Glassey, https://github.com/Gavvers
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*
* Contributor(s):
*    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
*    kim3er, mfo, alnorth, Flamenco
*/
var ni = /* @__PURE__ */ function() {
  return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this;
}();
function fy() {
  ni.console && typeof ni.console.log == "function" && ni.console.log.apply(ni.console, arguments);
}
var mr = { log: fy, warn: function(n) {
  ni.console && (typeof ni.console.warn == "function" ? ni.console.warn.apply(ni.console, arguments) : fy.call(null, arguments));
}, error: function(n) {
  ni.console && (typeof ni.console.error == "function" ? ni.console.error.apply(ni.console, arguments) : fy(n));
} };
function py(n, e, t) {
  var i = new XMLHttpRequest();
  i.open("GET", n), i.responseType = "blob", i.onload = function() {
    kh(i.response, e, t);
  }, i.onerror = function() {
    mr.error("could not download file");
  }, i.send();
}
function _5(n) {
  var e = new XMLHttpRequest();
  e.open("HEAD", n, !1);
  try {
    e.send();
  } catch {
  }
  return e.status >= 200 && e.status <= 299;
}
function Xg(n) {
  try {
    n.dispatchEvent(new MouseEvent("click"));
  } catch {
    var e = document.createEvent("MouseEvents");
    e.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), n.dispatchEvent(e);
  }
}
var Ap, S1, kh = ni.saveAs || ((typeof window > "u" ? "undefined" : or(window)) !== "object" || window !== ni ? function() {
} : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function(n, e, t) {
  var i = ni.URL || ni.webkitURL, r = document.createElement("a");
  e = e || n.name || "download", r.download = e, r.rel = "noopener", typeof n == "string" ? (r.href = n, r.origin !== location.origin ? _5(r.href) ? py(n, e, t) : Xg(r, r.target = "_blank") : Xg(r)) : (r.href = i.createObjectURL(n), setTimeout(function() {
    i.revokeObjectURL(r.href);
  }, 4e4), setTimeout(function() {
    Xg(r);
  }, 0));
} : "msSaveOrOpenBlob" in navigator ? function(n, e, t) {
  if (e = e || n.name || "download", typeof n == "string")
    if (_5(n)) py(n, e, t);
    else {
      var i = document.createElement("a");
      i.href = n, i.target = "_blank", setTimeout(function() {
        Xg(i);
      });
    }
  else navigator.msSaveOrOpenBlob(function(r, l) {
    return l === void 0 ? l = { autoBom: !1 } : or(l) !== "object" && (mr.warn("Deprecated: Expected third argument to be a object"), l = { autoBom: !l }), l.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(r.type) ? new Blob(["\uFEFF", r], { type: r.type }) : r;
  }(n, t), e);
} : function(n, e, t, i) {
  if ((i = i || open("", "_blank")) && (i.document.title = i.document.body.innerText = "downloading..."), typeof n == "string") return py(n, e, t);
  var r = n.type === "application/octet-stream", l = /constructor/i.test(ni.HTMLElement) || ni.safari, c = /CriOS\/[\d]+/.test(navigator.userAgent);
  if ((c || r && l) && (typeof FileReader > "u" ? "undefined" : or(FileReader)) === "object") {
    var a = new FileReader();
    a.onloadend = function() {
      var A = a.result;
      A = c ? A : A.replace(/^data:[^;]*;/, "data:attachment/file;"), i ? i.location.href = A : location = A, i = null;
    }, a.readAsDataURL(n);
  } else {
    var g = ni.URL || ni.webkitURL, y = g.createObjectURL(n);
    i ? i.location = y : location.href = y, i = null, setTimeout(function() {
      g.revokeObjectURL(y);
    }, 4e4);
  }
});
/**
* A class to parse color values
* @author Stoyan Stefanov <sstoo@gmail.com>
* {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
* @license Use it if you like it
*/
function g3(n) {
  var e;
  n = n || "", this.ok = !1, n.charAt(0) == "#" && (n = n.substr(1, 6)), n = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[n = (n = n.replace(/ /g, "")).toLowerCase()] || n;
  for (var t = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(a) {
    return [parseInt(a[1]), parseInt(a[2]), parseInt(a[3])];
  } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(a) {
    return [parseInt(a[1], 16), parseInt(a[2], 16), parseInt(a[3], 16)];
  } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(a) {
    return [parseInt(a[1] + a[1], 16), parseInt(a[2] + a[2], 16), parseInt(a[3] + a[3], 16)];
  } }], i = 0; i < t.length; i++) {
    var r = t[i].re, l = t[i].process, c = r.exec(n);
    c && (e = l(c), this.r = e[0], this.g = e[1], this.b = e[2], this.ok = !0);
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toHex = function() {
    var a = this.r.toString(16), g = this.g.toString(16), y = this.b.toString(16);
    return a.length == 1 && (a = "0" + a), g.length == 1 && (g = "0" + g), y.length == 1 && (y = "0" + y), "#" + a + g + y;
  };
}
/**
* @license
* Joseph Myers does not specify a particular license for his work.
*
* Author: Joseph Myers
* Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
*
* Modified by: Owen Leong
*/
function gy(n, e) {
  var t = n[0], i = n[1], r = n[2], l = n[3];
  t = zo(t, i, r, l, e[0], 7, -680876936), l = zo(l, t, i, r, e[1], 12, -389564586), r = zo(r, l, t, i, e[2], 17, 606105819), i = zo(i, r, l, t, e[3], 22, -1044525330), t = zo(t, i, r, l, e[4], 7, -176418897), l = zo(l, t, i, r, e[5], 12, 1200080426), r = zo(r, l, t, i, e[6], 17, -1473231341), i = zo(i, r, l, t, e[7], 22, -45705983), t = zo(t, i, r, l, e[8], 7, 1770035416), l = zo(l, t, i, r, e[9], 12, -1958414417), r = zo(r, l, t, i, e[10], 17, -42063), i = zo(i, r, l, t, e[11], 22, -1990404162), t = zo(t, i, r, l, e[12], 7, 1804603682), l = zo(l, t, i, r, e[13], 12, -40341101), r = zo(r, l, t, i, e[14], 17, -1502002290), t = Uo(t, i = zo(i, r, l, t, e[15], 22, 1236535329), r, l, e[1], 5, -165796510), l = Uo(l, t, i, r, e[6], 9, -1069501632), r = Uo(r, l, t, i, e[11], 14, 643717713), i = Uo(i, r, l, t, e[0], 20, -373897302), t = Uo(t, i, r, l, e[5], 5, -701558691), l = Uo(l, t, i, r, e[10], 9, 38016083), r = Uo(r, l, t, i, e[15], 14, -660478335), i = Uo(i, r, l, t, e[4], 20, -405537848), t = Uo(t, i, r, l, e[9], 5, 568446438), l = Uo(l, t, i, r, e[14], 9, -1019803690), r = Uo(r, l, t, i, e[3], 14, -187363961), i = Uo(i, r, l, t, e[8], 20, 1163531501), t = Uo(t, i, r, l, e[13], 5, -1444681467), l = Uo(l, t, i, r, e[2], 9, -51403784), r = Uo(r, l, t, i, e[7], 14, 1735328473), t = jo(t, i = Uo(i, r, l, t, e[12], 20, -1926607734), r, l, e[5], 4, -378558), l = jo(l, t, i, r, e[8], 11, -2022574463), r = jo(r, l, t, i, e[11], 16, 1839030562), i = jo(i, r, l, t, e[14], 23, -35309556), t = jo(t, i, r, l, e[1], 4, -1530992060), l = jo(l, t, i, r, e[4], 11, 1272893353), r = jo(r, l, t, i, e[7], 16, -155497632), i = jo(i, r, l, t, e[10], 23, -1094730640), t = jo(t, i, r, l, e[13], 4, 681279174), l = jo(l, t, i, r, e[0], 11, -358537222), r = jo(r, l, t, i, e[3], 16, -722521979), i = jo(i, r, l, t, e[6], 23, 76029189), t = jo(t, i, r, l, e[9], 4, -640364487), l = jo(l, t, i, r, e[12], 11, -421815835), r = jo(r, l, t, i, e[15], 16, 530742520), t = Go(t, i = jo(i, r, l, t, e[2], 23, -995338651), r, l, e[0], 6, -198630844), l = Go(l, t, i, r, e[7], 10, 1126891415), r = Go(r, l, t, i, e[14], 15, -1416354905), i = Go(i, r, l, t, e[5], 21, -57434055), t = Go(t, i, r, l, e[12], 6, 1700485571), l = Go(l, t, i, r, e[3], 10, -1894986606), r = Go(r, l, t, i, e[10], 15, -1051523), i = Go(i, r, l, t, e[1], 21, -2054922799), t = Go(t, i, r, l, e[8], 6, 1873313359), l = Go(l, t, i, r, e[15], 10, -30611744), r = Go(r, l, t, i, e[6], 15, -1560198380), i = Go(i, r, l, t, e[13], 21, 1309151649), t = Go(t, i, r, l, e[4], 6, -145523070), l = Go(l, t, i, r, e[11], 10, -1120210379), r = Go(r, l, t, i, e[2], 15, 718787259), i = Go(i, r, l, t, e[9], 21, -343485551), n[0] = hh(t, n[0]), n[1] = hh(i, n[1]), n[2] = hh(r, n[2]), n[3] = hh(l, n[3]);
}
function u_(n, e, t, i, r, l) {
  return e = hh(hh(e, n), hh(i, l)), hh(e << r | e >>> 32 - r, t);
}
function zo(n, e, t, i, r, l, c) {
  return u_(e & t | ~e & i, n, e, r, l, c);
}
function Uo(n, e, t, i, r, l, c) {
  return u_(e & i | t & ~i, n, e, r, l, c);
}
function jo(n, e, t, i, r, l, c) {
  return u_(e ^ t ^ i, n, e, r, l, c);
}
function Go(n, e, t, i, r, l, c) {
  return u_(t ^ (e | ~i), n, e, r, l, c);
}
function m3(n) {
  var e, t = n.length, i = [1732584193, -271733879, -1732584194, 271733878];
  for (e = 64; e <= n.length; e += 64) gy(i, NV(n.substring(e - 64, e)));
  n = n.substring(e - 64);
  var r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (e = 0; e < n.length; e++) r[e >> 2] |= n.charCodeAt(e) << (e % 4 << 3);
  if (r[e >> 2] |= 128 << (e % 4 << 3), e > 55) for (gy(i, r), e = 0; e < 16; e++) r[e] = 0;
  return r[14] = 8 * t, gy(i, r), i;
}
function NV(n) {
  var e, t = [];
  for (e = 0; e < 64; e += 4) t[e >> 2] = n.charCodeAt(e) + (n.charCodeAt(e + 1) << 8) + (n.charCodeAt(e + 2) << 16) + (n.charCodeAt(e + 3) << 24);
  return t;
}
Ap = ni.atob.bind(ni), S1 = ni.btoa.bind(ni);
var y5 = "0123456789abcdef".split("");
function kV(n) {
  for (var e = "", t = 0; t < 4; t++) e += y5[n >> 8 * t + 4 & 15] + y5[n >> 8 * t & 15];
  return e;
}
function zV(n) {
  return String.fromCharCode((255 & n) >> 0, (65280 & n) >> 8, (16711680 & n) >> 16, (4278190080 & n) >> 24);
}
function C1(n) {
  return m3(n).map(zV).join("");
}
var UV = function(n) {
  for (var e = 0; e < n.length; e++) n[e] = kV(n[e]);
  return n.join("");
}(m3("hello")) != "5d41402abc4b2a76b9719d911017c592";
function hh(n, e) {
  if (UV) {
    var t = (65535 & n) + (65535 & e);
    return (n >> 16) + (e >> 16) + (t >> 16) << 16 | 65535 & t;
  }
  return n + e & 4294967295;
}
/**
* @license
* FPDF is released under a permissive license: there is no usage restriction.
* You may embed it freely in your application (commercial or not), with or
* without modifications.
*
* Reference: http://www.fpdf.org/en/script/script37.php
*/
function P1(n, e) {
  var t, i, r, l;
  if (n !== t) {
    for (var c = (r = n, l = 1 + (256 / n.length >> 0), new Array(l + 1).join(r)), a = [], g = 0; g < 256; g++) a[g] = g;
    var y = 0;
    for (g = 0; g < 256; g++) {
      var A = a[g];
      y = (y + A + c.charCodeAt(g)) % 256, a[g] = a[y], a[y] = A;
    }
    t = n, i = a;
  } else a = i;
  var C = e.length, I = 0, S = 0, F = "";
  for (g = 0; g < C; g++) S = (S + (A = a[I = (I + 1) % 256])) % 256, a[I] = a[S], a[S] = A, c = a[(a[I] + a[S]) % 256], F += String.fromCharCode(e.charCodeAt(g) ^ c);
  return F;
}
/**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
* Author: Owen Leong (@owenl131)
* Date: 15 Oct 2020
* References:
* https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
* https://github.com/foliojs/pdfkit/blob/master/lib/security.js
* http://www.fpdf.org/en/script/script37.php
*/
var b5 = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
function Ud(n, e, t, i) {
  this.v = 1, this.r = 2;
  var r = 192;
  n.forEach(function(a) {
    if (b5.perm !== void 0) throw new Error("Invalid permission: " + a);
    r += b5[a];
  }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz";
  var l = (e + this.padding).substr(0, 32), c = (t + this.padding).substr(0, 32);
  this.O = this.processOwnerPassword(l, c), this.P = -(1 + (255 ^ r)), this.encryptionKey = C1(l + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(i)).substr(0, 5), this.U = P1(this.encryptionKey, this.padding);
}
function jd(n) {
  if (/[^\u0000-\u00ff]/.test(n)) throw new Error("Invalid PDF Name Object: " + n + ", Only accept ASCII characters.");
  for (var e = "", t = n.length, i = 0; i < t; i++) {
    var r = n.charCodeAt(i);
    r < 33 || r === 35 || r === 37 || r === 40 || r === 41 || r === 47 || r === 60 || r === 62 || r === 91 || r === 93 || r === 123 || r === 125 || r > 126 ? e += "#" + ("0" + r.toString(16)).slice(-2) : e += n[i];
  }
  return e;
}
function v5(n) {
  if (or(n) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
  var e = {};
  this.subscribe = function(t, i, r) {
    if (r = r || !1, typeof t != "string" || typeof i != "function" || typeof r != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
    e.hasOwnProperty(t) || (e[t] = {});
    var l = Math.random().toString(35);
    return e[t][l] = [i, !!r], l;
  }, this.unsubscribe = function(t) {
    for (var i in e) if (e[i][t]) return delete e[i][t], Object.keys(e[i]).length === 0 && delete e[i], !0;
    return !1;
  }, this.publish = function(t) {
    if (e.hasOwnProperty(t)) {
      var i = Array.prototype.slice.call(arguments, 1), r = [];
      for (var l in e[t]) {
        var c = e[t][l];
        try {
          c[0].apply(n, i);
        } catch (a) {
          ni.console && mr.error("jsPDF PubSub Error", a.message, a);
        }
        c[1] && r.push(l);
      }
      r.length && r.forEach(this.unsubscribe);
    }
  }, this.getTopics = function() {
    return e;
  };
}
function Gm(n) {
  if (!(this instanceof Gm)) return new Gm(n);
  var e = "opacity,stroke-opacity".split(",");
  for (var t in n) n.hasOwnProperty(t) && e.indexOf(t) >= 0 && (this[t] = n[t]);
  this.id = "", this.objectNumber = -1;
}
function _3(n, e) {
  this.gState = n, this.matrix = e, this.id = "", this.objectNumber = -1;
}
function jh(n, e, t, i, r) {
  if (!(this instanceof jh)) return new jh(n, e, t, i, r);
  this.type = n === "axial" ? 2 : 3, this.coords = e, this.colors = t, _3.call(this, i, r);
}
function Wd(n, e, t, i, r) {
  if (!(this instanceof Wd)) return new Wd(n, e, t, i, r);
  this.boundingBox = n, this.xStep = e, this.yStep = t, this.stream = "", this.cloneIndex = 0, _3.call(this, i, r);
}
function ti(n) {
  var e, t = typeof arguments[0] == "string" ? arguments[0] : "p", i = arguments[1], r = arguments[2], l = arguments[3], c = [], a = 1, g = 16, y = "S", A = null;
  or(n = n || {}) === "object" && (t = n.orientation, i = n.unit || i, r = n.format || r, l = n.compress || n.compressPdf || l, (A = n.encryption || null) !== null && (A.userPassword = A.userPassword || "", A.ownerPassword = A.ownerPassword || "", A.userPermissions = A.userPermissions || []), a = typeof n.userUnit == "number" ? Math.abs(n.userUnit) : 1, n.precision !== void 0 && (e = n.precision), n.floatPrecision !== void 0 && (g = n.floatPrecision), y = n.defaultPathOperation || "S"), c = n.filters || (l === !0 ? ["FlateEncode"] : c), i = i || "mm", t = ("" + (t || "P")).toLowerCase();
  var C = n.putOnlyUsedFonts || !1, I = {}, S = { internal: {}, __private__: {} };
  S.__private__.PubSub = v5;
  var F = "1.3", U = S.__private__.getPdfVersion = function() {
    return F;
  };
  S.__private__.setPdfVersion = function(O) {
    F = O;
  };
  var V = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
  S.__private__.getPageFormats = function() {
    return V;
  };
  var W = S.__private__.getPageFormat = function(O) {
    return V[O];
  };
  r = r || "a4";
  var X = { COMPAT: "compat", ADVANCED: "advanced" }, de = X.COMPAT;
  function ie() {
    this.saveGraphicsState(), Ue(new Xt(bn, 0, 0, -bn, 0, Po() * bn).toString() + " cm"), this.setFontSize(this.getFontSize() / bn), y = "n", de = X.ADVANCED;
  }
  function fe() {
    this.restoreGraphicsState(), y = "S", de = X.COMPAT;
  }
  var Ae = S.__private__.combineFontStyleAndFontWeight = function(O, te) {
    if (O == "bold" && te == "normal" || O == "bold" && te == 400 || O == "normal" && te == "italic" || O == "bold" && te == "italic") throw new Error("Invalid Combination of fontweight and fontstyle");
    return te && (O = te == 400 || te === "normal" ? O === "italic" ? "italic" : "normal" : te != 700 && te !== "bold" || O !== "normal" ? (te == 700 ? "bold" : te) + "" + O : "bold"), O;
  };
  S.advancedAPI = function(O) {
    var te = de === X.COMPAT;
    return te && ie.call(this), typeof O != "function" || (O(this), te && fe.call(this)), this;
  }, S.compatAPI = function(O) {
    var te = de === X.ADVANCED;
    return te && fe.call(this), typeof O != "function" || (O(this), te && ie.call(this)), this;
  }, S.isAdvancedAPI = function() {
    return de === X.ADVANCED;
  };
  var Te, me = function(O) {
    if (de !== X.ADVANCED) throw new Error(O + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
  }, Ge = S.roundToPrecision = S.__private__.roundToPrecision = function(O, te) {
    var Fe = e || te;
    if (isNaN(O) || isNaN(Fe)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
    return O.toFixed(Fe).replace(/0+$/, "");
  };
  Te = S.hpf = S.__private__.hpf = typeof g == "number" ? function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ge(O, g);
  } : g === "smart" ? function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ge(O, O > -1 && O < 1 ? 16 : 5);
  } : function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.hpf");
    return Ge(O, 16);
  };
  var ke = S.f2 = S.__private__.f2 = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.f2");
    return Ge(O, 2);
  }, pe = S.__private__.f3 = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.f3");
    return Ge(O, 3);
  }, _e = S.scale = S.__private__.scale = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.scale");
    return de === X.COMPAT ? O * bn : de === X.ADVANCED ? O : void 0;
  }, De = function(O) {
    return de === X.COMPAT ? Po() - O : de === X.ADVANCED ? O : void 0;
  }, Me = function(O) {
    return _e(De(O));
  };
  S.__private__.setPrecision = S.setPrecision = function(O) {
    typeof parseInt(O, 10) == "number" && (e = parseInt(O, 10));
  };
  var St, dt = "00000000000000000000000000000000", Pt = S.__private__.getFileId = function() {
    return dt;
  }, gt = S.__private__.setFileId = function(O) {
    return dt = O !== void 0 && /^[a-fA-F0-9]{32}$/.test(O) ? O.toUpperCase() : dt.split("").map(function() {
      return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
    }).join(""), A !== null && (qn = new Ud(A.userPermissions, A.userPassword, A.ownerPassword, dt)), dt;
  };
  S.setFileId = function(O) {
    return gt(O), this;
  }, S.getFileId = function() {
    return Pt();
  };
  var Rt = S.__private__.convertDateToPDFDate = function(O) {
    var te = O.getTimezoneOffset(), Fe = te < 0 ? "+" : "-", Ke = Math.floor(Math.abs(te / 60)), yt = Math.abs(te % 60), kt = [Fe, ze(Ke), "'", ze(yt), "'"].join("");
    return ["D:", O.getFullYear(), ze(O.getMonth() + 1), ze(O.getDate()), ze(O.getHours()), ze(O.getMinutes()), ze(O.getSeconds()), kt].join("");
  }, Ft = S.__private__.convertPDFDateToDate = function(O) {
    var te = parseInt(O.substr(2, 4), 10), Fe = parseInt(O.substr(6, 2), 10) - 1, Ke = parseInt(O.substr(8, 2), 10), yt = parseInt(O.substr(10, 2), 10), kt = parseInt(O.substr(12, 2), 10), tn = parseInt(O.substr(14, 2), 10);
    return new Date(te, Fe, Ke, yt, kt, tn, 0);
  }, mn = S.__private__.setCreationDate = function(O) {
    var te;
    if (O === void 0 && (O = /* @__PURE__ */ new Date()), O instanceof Date) te = Rt(O);
    else {
      if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(O)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
      te = O;
    }
    return St = te;
  }, oe = S.__private__.getCreationDate = function(O) {
    var te = St;
    return O === "jsDate" && (te = Ft(St)), te;
  };
  S.setCreationDate = function(O) {
    return mn(O), this;
  }, S.getCreationDate = function(O) {
    return oe(O);
  };
  var Re, ze = S.__private__.padd2 = function(O) {
    return ("0" + parseInt(O)).slice(-2);
  }, Xe = S.__private__.padd2Hex = function(O) {
    return ("00" + (O = O.toString())).substr(O.length);
  }, ot = 0, rt = [], xt = [], ht = 0, $t = [], Wt = [], on = !1, hn = xt, wn = function() {
    ot = 0, ht = 0, xt = [], rt = [], $t = [], fn = In(), xi = In();
  };
  S.__private__.setCustomOutputDestination = function(O) {
    on = !0, hn = O;
  };
  var Bt = function(O) {
    on || (hn = O);
  };
  S.__private__.resetCustomOutputDestination = function() {
    on = !1, hn = xt;
  };
  var Ue = S.__private__.out = function(O) {
    return O = O.toString(), ht += O.length + 1, hn.push(O), hn;
  }, On = S.__private__.write = function(O) {
    return Ue(arguments.length === 1 ? O.toString() : Array.prototype.join.call(arguments, " "));
  }, Sn = S.__private__.getArrayBuffer = function(O) {
    for (var te = O.length, Fe = new ArrayBuffer(te), Ke = new Uint8Array(Fe); te--; ) Ke[te] = O.charCodeAt(te);
    return Fe;
  }, en = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
  S.__private__.getStandardFonts = function() {
    return en;
  };
  var ln = n.fontSize || 16;
  S.__private__.setFontSize = S.setFontSize = function(O) {
    return ln = de === X.ADVANCED ? O / bn : O, this;
  };
  var un, _n = S.__private__.getFontSize = S.getFontSize = function() {
    return de === X.COMPAT ? ln : ln * bn;
  }, Mn = n.R2L || !1;
  S.__private__.setR2L = S.setR2L = function(O) {
    return Mn = O, this;
  }, S.__private__.getR2L = S.getR2L = function() {
    return Mn;
  };
  var Wn, $n = S.__private__.setZoomMode = function(O) {
    var te = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"];
    if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(O)) un = O;
    else if (isNaN(O)) {
      if (te.indexOf(O) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + O + '" is not recognized.');
      un = O;
    } else un = parseInt(O, 10);
  };
  S.__private__.getZoomMode = function() {
    return un;
  };
  var Yn, si = S.__private__.setPageMode = function(O) {
    if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(O) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + O + '" is not recognized.');
    Wn = O;
  };
  S.__private__.getPageMode = function() {
    return Wn;
  };
  var fi = S.__private__.setLayoutMode = function(O) {
    if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(O) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + O + '" is not recognized.');
    Yn = O;
  };
  S.__private__.getLayoutMode = function() {
    return Yn;
  }, S.__private__.setDisplayMode = S.setDisplayMode = function(O, te, Fe) {
    return $n(O), fi(te), si(Fe), this;
  };
  var Un = { title: "", subject: "", author: "", keywords: "", creator: "" };
  S.__private__.getDocumentProperty = function(O) {
    if (Object.keys(Un).indexOf(O) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
    return Un[O];
  }, S.__private__.getDocumentProperties = function() {
    return Un;
  }, S.__private__.setDocumentProperties = S.setProperties = S.setDocumentProperties = function(O) {
    for (var te in Un) Un.hasOwnProperty(te) && O[te] && (Un[te] = O[te]);
    return this;
  }, S.__private__.setDocumentProperty = function(O, te) {
    if (Object.keys(Un).indexOf(O) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
    return Un[O] = te;
  };
  var Jn, bn, tr, pi, Dr, be = {}, ne = {}, ce = [], ue = {}, Oe = {}, qe = {}, it = {}, mt = null, Ye = 0, at = [], pt = new v5(S), lt = n.hotfixes || [], Ze = {}, an = {}, Yt = [], Xt = function O(te, Fe, Ke, yt, kt, tn) {
    if (!(this instanceof O)) return new O(te, Fe, Ke, yt, kt, tn);
    isNaN(te) && (te = 1), isNaN(Fe) && (Fe = 0), isNaN(Ke) && (Ke = 0), isNaN(yt) && (yt = 1), isNaN(kt) && (kt = 0), isNaN(tn) && (tn = 0), this._matrix = [te, Fe, Ke, yt, kt, tn];
  };
  Object.defineProperty(Xt.prototype, "sx", { get: function() {
    return this._matrix[0];
  }, set: function(O) {
    this._matrix[0] = O;
  } }), Object.defineProperty(Xt.prototype, "shy", { get: function() {
    return this._matrix[1];
  }, set: function(O) {
    this._matrix[1] = O;
  } }), Object.defineProperty(Xt.prototype, "shx", { get: function() {
    return this._matrix[2];
  }, set: function(O) {
    this._matrix[2] = O;
  } }), Object.defineProperty(Xt.prototype, "sy", { get: function() {
    return this._matrix[3];
  }, set: function(O) {
    this._matrix[3] = O;
  } }), Object.defineProperty(Xt.prototype, "tx", { get: function() {
    return this._matrix[4];
  }, set: function(O) {
    this._matrix[4] = O;
  } }), Object.defineProperty(Xt.prototype, "ty", { get: function() {
    return this._matrix[5];
  }, set: function(O) {
    this._matrix[5] = O;
  } }), Object.defineProperty(Xt.prototype, "a", { get: function() {
    return this._matrix[0];
  }, set: function(O) {
    this._matrix[0] = O;
  } }), Object.defineProperty(Xt.prototype, "b", { get: function() {
    return this._matrix[1];
  }, set: function(O) {
    this._matrix[1] = O;
  } }), Object.defineProperty(Xt.prototype, "c", { get: function() {
    return this._matrix[2];
  }, set: function(O) {
    this._matrix[2] = O;
  } }), Object.defineProperty(Xt.prototype, "d", { get: function() {
    return this._matrix[3];
  }, set: function(O) {
    this._matrix[3] = O;
  } }), Object.defineProperty(Xt.prototype, "e", { get: function() {
    return this._matrix[4];
  }, set: function(O) {
    this._matrix[4] = O;
  } }), Object.defineProperty(Xt.prototype, "f", { get: function() {
    return this._matrix[5];
  }, set: function(O) {
    this._matrix[5] = O;
  } }), Object.defineProperty(Xt.prototype, "rotation", { get: function() {
    return Math.atan2(this.shx, this.sx);
  } }), Object.defineProperty(Xt.prototype, "scaleX", { get: function() {
    return this.decompose().scale.sx;
  } }), Object.defineProperty(Xt.prototype, "scaleY", { get: function() {
    return this.decompose().scale.sy;
  } }), Object.defineProperty(Xt.prototype, "isIdentity", { get: function() {
    return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0;
  } }), Xt.prototype.join = function(O) {
    return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(Te).join(O);
  }, Xt.prototype.multiply = function(O) {
    var te = O.sx * this.sx + O.shy * this.shx, Fe = O.sx * this.shy + O.shy * this.sy, Ke = O.shx * this.sx + O.sy * this.shx, yt = O.shx * this.shy + O.sy * this.sy, kt = O.tx * this.sx + O.ty * this.shx + this.tx, tn = O.tx * this.shy + O.ty * this.sy + this.ty;
    return new Xt(te, Fe, Ke, yt, kt, tn);
  }, Xt.prototype.decompose = function() {
    var O = this.sx, te = this.shy, Fe = this.shx, Ke = this.sy, yt = this.tx, kt = this.ty, tn = Math.sqrt(O * O + te * te), Tn = (O /= tn) * Fe + (te /= tn) * Ke;
    Fe -= O * Tn, Ke -= te * Tn;
    var kn = Math.sqrt(Fe * Fe + Ke * Ke);
    return Tn /= kn, O * (Ke /= kn) < te * (Fe /= kn) && (O = -O, te = -te, Tn = -Tn, tn = -tn), { scale: new Xt(tn, 0, 0, kn, 0, 0), translate: new Xt(1, 0, 0, 1, yt, kt), rotate: new Xt(O, te, -te, O, 0, 0), skew: new Xt(1, 0, Tn, 1, 0, 0) };
  }, Xt.prototype.toString = function(O) {
    return this.join(" ");
  }, Xt.prototype.inversed = function() {
    var O = this.sx, te = this.shy, Fe = this.shx, Ke = this.sy, yt = this.tx, kt = this.ty, tn = 1 / (O * Ke - te * Fe), Tn = Ke * tn, kn = -te * tn, ii = -Fe * tn, ei = O * tn;
    return new Xt(Tn, kn, ii, ei, -Tn * yt - ii * kt, -kn * yt - ei * kt);
  }, Xt.prototype.applyToPoint = function(O) {
    var te = O.x * this.sx + O.y * this.shx + this.tx, Fe = O.x * this.shy + O.y * this.sy + this.ty;
    return new Co(te, Fe);
  }, Xt.prototype.applyToRectangle = function(O) {
    var te = this.applyToPoint(O), Fe = this.applyToPoint(new Co(O.x + O.w, O.y + O.h));
    return new cs(te.x, te.y, Fe.x - te.x, Fe.y - te.y);
  }, Xt.prototype.clone = function() {
    var O = this.sx, te = this.shy, Fe = this.shx, Ke = this.sy, yt = this.tx, kt = this.ty;
    return new Xt(O, te, Fe, Ke, yt, kt);
  }, S.Matrix = Xt;
  var An = S.matrixMult = function(O, te) {
    return te.multiply(O);
  }, It = new Xt(1, 0, 0, 1, 0, 0);
  S.unitMatrix = S.identityMatrix = It;
  var Jt = function(O, te) {
    if (!Oe[O]) {
      var Fe = (te instanceof jh ? "Sh" : "P") + (Object.keys(ue).length + 1).toString(10);
      te.id = Fe, Oe[O] = Fe, ue[Fe] = te, pt.publish("addPattern", te);
    }
  };
  S.ShadingPattern = jh, S.TilingPattern = Wd, S.addShadingPattern = function(O, te) {
    return me("addShadingPattern()"), Jt(O, te), this;
  }, S.beginTilingPattern = function(O) {
    me("beginTilingPattern()"), Ra(O.boundingBox[0], O.boundingBox[1], O.boundingBox[2] - O.boundingBox[0], O.boundingBox[3] - O.boundingBox[1], O.matrix);
  }, S.endTilingPattern = function(O, te) {
    me("endTilingPattern()"), te.stream = Wt[Re].join(`
`), Jt(O, te), pt.publish("endTilingPattern", te), Yt.pop().restore();
  };
  var cn = S.__private__.newObject = function() {
    var O = In();
    return Zn(O, !0), O;
  }, In = S.__private__.newObjectDeferred = function() {
    return ot++, rt[ot] = function() {
      return ht;
    }, ot;
  }, Zn = function(O, te) {
    return te = typeof te == "boolean" && te, rt[O] = ht, te && Ue(O + " 0 obj"), O;
  }, Ln = S.__private__.newAdditionalObject = function() {
    var O = { objId: In(), content: "" };
    return $t.push(O), O;
  }, fn = In(), xi = In(), Er = S.__private__.decodeColorString = function(O) {
    var te = O.split(" ");
    if (te.length !== 2 || te[1] !== "g" && te[1] !== "G") te.length === 5 && (te[4] === "k" || te[4] === "K") && (te = [(1 - te[0]) * (1 - te[3]), (1 - te[1]) * (1 - te[3]), (1 - te[2]) * (1 - te[3]), "r"]);
    else {
      var Fe = parseFloat(te[0]);
      te = [Fe, Fe, Fe, "r"];
    }
    for (var Ke = "#", yt = 0; yt < 3; yt++) Ke += ("0" + Math.floor(255 * parseFloat(te[yt])).toString(16)).slice(-2);
    return Ke;
  }, Pi = S.__private__.encodeColorString = function(O) {
    var te;
    typeof O == "string" && (O = { ch1: O });
    var Fe = O.ch1, Ke = O.ch2, yt = O.ch3, kt = O.ch4, tn = O.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"];
    if (typeof Fe == "string" && Fe.charAt(0) !== "#") {
      var Tn = new g3(Fe);
      if (Tn.ok) Fe = Tn.toHex();
      else if (!/^\d*\.?\d*$/.test(Fe)) throw new Error('Invalid color "' + Fe + '" passed to jsPDF.encodeColorString.');
    }
    if (typeof Fe == "string" && /^#[0-9A-Fa-f]{3}$/.test(Fe) && (Fe = "#" + Fe[1] + Fe[1] + Fe[2] + Fe[2] + Fe[3] + Fe[3]), typeof Fe == "string" && /^#[0-9A-Fa-f]{6}$/.test(Fe)) {
      var kn = parseInt(Fe.substr(1), 16);
      Fe = kn >> 16 & 255, Ke = kn >> 8 & 255, yt = 255 & kn;
    }
    if (Ke === void 0 || kt === void 0 && Fe === Ke && Ke === yt)
      if (typeof Fe == "string") te = Fe + " " + tn[0];
      else switch (O.precision) {
        case 2:
          te = ke(Fe / 255) + " " + tn[0];
          break;
        case 3:
        default:
          te = pe(Fe / 255) + " " + tn[0];
      }
    else if (kt === void 0 || or(kt) === "object") {
      if (kt && !isNaN(kt.a) && kt.a === 0) return te = ["1.", "1.", "1.", tn[1]].join(" ");
      if (typeof Fe == "string") te = [Fe, Ke, yt, tn[1]].join(" ");
      else switch (O.precision) {
        case 2:
          te = [ke(Fe / 255), ke(Ke / 255), ke(yt / 255), tn[1]].join(" ");
          break;
        default:
        case 3:
          te = [pe(Fe / 255), pe(Ke / 255), pe(yt / 255), tn[1]].join(" ");
      }
    } else if (typeof Fe == "string") te = [Fe, Ke, yt, kt, tn[2]].join(" ");
    else switch (O.precision) {
      case 2:
        te = [ke(Fe), ke(Ke), ke(yt), ke(kt), tn[2]].join(" ");
        break;
      case 3:
      default:
        te = [pe(Fe), pe(Ke), pe(yt), pe(kt), tn[2]].join(" ");
    }
    return te;
  }, Ii = S.__private__.getFilters = function() {
    return c;
  }, ui = S.__private__.putStream = function(O) {
    var te = (O = O || {}).data || "", Fe = O.filters || Ii(), Ke = O.alreadyAppliedFilters || [], yt = O.addLength1 || !1, kt = te.length, tn = O.objectId, Tn = function(hs) {
      return hs;
    };
    if (A !== null && tn === void 0) throw new Error("ObjectId must be passed to putStream for file encryption");
    A !== null && (Tn = qn.encryptor(tn, 0));
    var kn = {};
    Fe === !0 && (Fe = ["FlateEncode"]);
    var ii = O.additionalKeyValues || [], ei = (kn = ti.API.processDataByFilters !== void 0 ? ti.API.processDataByFilters(te, Fe) : { data: te, reverseChain: [] }).reverseChain + (Array.isArray(Ke) ? Ke.join(" ") : Ke.toString());
    if (kn.data.length !== 0 && (ii.push({ key: "Length", value: kn.data.length }), yt === !0 && ii.push({ key: "Length1", value: kt })), ei.length != 0) if (ei.split("/").length - 1 == 1) ii.push({ key: "Filter", value: ei });
    else {
      ii.push({ key: "Filter", value: "[" + ei + "]" });
      for (var wi = 0; wi < ii.length; wi += 1) if (ii[wi].key === "DecodeParms") {
        for (var ir = [], Wi = 0; Wi < kn.reverseChain.split("/").length - 1; Wi += 1) ir.push("null");
        ir.push(ii[wi].value), ii[wi].value = "[" + ir.join(" ") + "]";
      }
    }
    Ue("<<");
    for (var Sr = 0; Sr < ii.length; Sr++) Ue("/" + ii[Sr].key + " " + ii[Sr].value);
    Ue(">>"), kn.data.length !== 0 && (Ue("stream"), Ue(Tn(kn.data)), Ue("endstream"));
  }, Oi = S.__private__.putPage = function(O) {
    var te = O.number, Fe = O.data, Ke = O.objId, yt = O.contentsObjId;
    Zn(Ke, !0), Ue("<</Type /Page"), Ue("/Parent " + O.rootDictionaryObjId + " 0 R"), Ue("/Resources " + O.resourceDictionaryObjId + " 0 R"), Ue("/MediaBox [" + parseFloat(Te(O.mediaBox.bottomLeftX)) + " " + parseFloat(Te(O.mediaBox.bottomLeftY)) + " " + Te(O.mediaBox.topRightX) + " " + Te(O.mediaBox.topRightY) + "]"), O.cropBox !== null && Ue("/CropBox [" + Te(O.cropBox.bottomLeftX) + " " + Te(O.cropBox.bottomLeftY) + " " + Te(O.cropBox.topRightX) + " " + Te(O.cropBox.topRightY) + "]"), O.bleedBox !== null && Ue("/BleedBox [" + Te(O.bleedBox.bottomLeftX) + " " + Te(O.bleedBox.bottomLeftY) + " " + Te(O.bleedBox.topRightX) + " " + Te(O.bleedBox.topRightY) + "]"), O.trimBox !== null && Ue("/TrimBox [" + Te(O.trimBox.bottomLeftX) + " " + Te(O.trimBox.bottomLeftY) + " " + Te(O.trimBox.topRightX) + " " + Te(O.trimBox.topRightY) + "]"), O.artBox !== null && Ue("/ArtBox [" + Te(O.artBox.bottomLeftX) + " " + Te(O.artBox.bottomLeftY) + " " + Te(O.artBox.topRightX) + " " + Te(O.artBox.topRightY) + "]"), typeof O.userUnit == "number" && O.userUnit !== 1 && Ue("/UserUnit " + O.userUnit), pt.publish("putPage", { objId: Ke, pageContext: at[te], pageNumber: te, page: Fe }), Ue("/Contents " + yt + " 0 R"), Ue(">>"), Ue("endobj");
    var kt = Fe.join(`
`);
    return de === X.ADVANCED && (kt += `
Q`), Zn(yt, !0), ui({ data: kt, filters: Ii(), objectId: yt }), Ue("endobj"), Ke;
  }, _i = S.__private__.putPages = function() {
    var O, te, Fe = [];
    for (O = 1; O <= Ye; O++) at[O].objId = In(), at[O].contentsObjId = In();
    for (O = 1; O <= Ye; O++) Fe.push(Oi({ number: O, data: Wt[O], objId: at[O].objId, contentsObjId: at[O].contentsObjId, mediaBox: at[O].mediaBox, cropBox: at[O].cropBox, bleedBox: at[O].bleedBox, trimBox: at[O].trimBox, artBox: at[O].artBox, userUnit: at[O].userUnit, rootDictionaryObjId: fn, resourceDictionaryObjId: xi }));
    Zn(fn, !0), Ue("<</Type /Pages");
    var Ke = "/Kids [";
    for (te = 0; te < Ye; te++) Ke += Fe[te] + " 0 R ";
    Ue(Ke + "]"), Ue("/Count " + Ye), Ue(">>"), Ue("endobj"), pt.publish("postPutPages");
  }, xs = function(O) {
    pt.publish("putFont", { font: O, out: Ue, newObject: cn, putStream: ui }), O.isAlreadyPutted !== !0 && (O.objectNumber = cn(), Ue("<<"), Ue("/Type /Font"), Ue("/BaseFont /" + jd(O.postScriptName)), Ue("/Subtype /Type1"), typeof O.encoding == "string" && Ue("/Encoding /" + O.encoding), Ue("/FirstChar 32"), Ue("/LastChar 255"), Ue(">>"), Ue("endobj"));
  }, ws = function() {
    for (var O in be) be.hasOwnProperty(O) && (C === !1 || C === !0 && I.hasOwnProperty(O)) && xs(be[O]);
  }, Ao = function(O) {
    O.objectNumber = cn();
    var te = [];
    te.push({ key: "Type", value: "/XObject" }), te.push({ key: "Subtype", value: "/Form" }), te.push({ key: "BBox", value: "[" + [Te(O.x), Te(O.y), Te(O.x + O.width), Te(O.y + O.height)].join(" ") + "]" }), te.push({ key: "Matrix", value: "[" + O.matrix.toString() + "]" });
    var Fe = O.pages[1].join(`
`);
    ui({ data: Fe, additionalKeyValues: te, objectId: O.objectNumber }), Ue("endobj");
  }, qs = function() {
    for (var O in Ze) Ze.hasOwnProperty(O) && Ao(Ze[O]);
  }, To = function(O, te) {
    var Fe, Ke = [], yt = 1 / (te - 1);
    for (Fe = 0; Fe < 1; Fe += yt) Ke.push(Fe);
    if (Ke.push(1), O[0].offset != 0) {
      var kt = { offset: 0, color: O[0].color };
      O.unshift(kt);
    }
    if (O[O.length - 1].offset != 1) {
      var tn = { offset: 1, color: O[O.length - 1].color };
      O.push(tn);
    }
    for (var Tn = "", kn = 0, ii = 0; ii < Ke.length; ii++) {
      for (Fe = Ke[ii]; Fe > O[kn + 1].offset; ) kn++;
      var ei = O[kn].offset, wi = (Fe - ei) / (O[kn + 1].offset - ei), ir = O[kn].color, Wi = O[kn + 1].color;
      Tn += Xe(Math.round((1 - wi) * ir[0] + wi * Wi[0]).toString(16)) + Xe(Math.round((1 - wi) * ir[1] + wi * Wi[1]).toString(16)) + Xe(Math.round((1 - wi) * ir[2] + wi * Wi[2]).toString(16));
    }
    return Tn.trim();
  }, Ia = function(O, te) {
    te || (te = 21);
    var Fe = cn(), Ke = To(O.colors, te), yt = [];
    yt.push({ key: "FunctionType", value: "0" }), yt.push({ key: "Domain", value: "[0.0 1.0]" }), yt.push({ key: "Size", value: "[" + te + "]" }), yt.push({ key: "BitsPerSample", value: "8" }), yt.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), yt.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ui({ data: Ke, additionalKeyValues: yt, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: Fe }), Ue("endobj"), O.objectNumber = cn(), Ue("<< /ShadingType " + O.type), Ue("/ColorSpace /DeviceRGB");
    var kt = "/Coords [" + Te(parseFloat(O.coords[0])) + " " + Te(parseFloat(O.coords[1])) + " ";
    O.type === 2 ? kt += Te(parseFloat(O.coords[2])) + " " + Te(parseFloat(O.coords[3])) : kt += Te(parseFloat(O.coords[2])) + " " + Te(parseFloat(O.coords[3])) + " " + Te(parseFloat(O.coords[4])) + " " + Te(parseFloat(O.coords[5])), Ue(kt += "]"), O.matrix && Ue("/Matrix [" + O.matrix.toString() + "]"), Ue("/Function " + Fe + " 0 R"), Ue("/Extend [true true]"), Ue(">>"), Ue("endobj");
  }, Hr = function(O, te) {
    var Fe = In(), Ke = cn();
    te.push({ resourcesOid: Fe, objectOid: Ke }), O.objectNumber = Ke;
    var yt = [];
    yt.push({ key: "Type", value: "/Pattern" }), yt.push({ key: "PatternType", value: "1" }), yt.push({ key: "PaintType", value: "1" }), yt.push({ key: "TilingType", value: "1" }), yt.push({ key: "BBox", value: "[" + O.boundingBox.map(Te).join(" ") + "]" }), yt.push({ key: "XStep", value: Te(O.xStep) }), yt.push({ key: "YStep", value: Te(O.yStep) }), yt.push({ key: "Resources", value: Fe + " 0 R" }), O.matrix && yt.push({ key: "Matrix", value: "[" + O.matrix.toString() + "]" }), ui({ data: O.stream, additionalKeyValues: yt, objectId: O.objectNumber }), Ue("endobj");
  }, Hs = function(O) {
    var te;
    for (te in ue) ue.hasOwnProperty(te) && (ue[te] instanceof jh ? Ia(ue[te]) : ue[te] instanceof Wd && Hr(ue[te], O));
  }, Wr = function(O) {
    for (var te in O.objectNumber = cn(), Ue("<<"), O) switch (te) {
      case "opacity":
        Ue("/ca " + ke(O[te]));
        break;
      case "stroke-opacity":
        Ue("/CA " + ke(O[te]));
    }
    Ue(">>"), Ue("endobj");
  }, Ws = function() {
    var O;
    for (O in qe) qe.hasOwnProperty(O) && Wr(qe[O]);
  }, $o = function() {
    for (var O in Ue("/XObject <<"), Ze) Ze.hasOwnProperty(O) && Ze[O].objectNumber >= 0 && Ue("/" + O + " " + Ze[O].objectNumber + " 0 R");
    pt.publish("putXobjectDict"), Ue(">>");
  }, Zs = function() {
    qn.oid = cn(), Ue("<<"), Ue("/Filter /Standard"), Ue("/V " + qn.v), Ue("/R " + qn.r), Ue("/U <" + qn.toHexString(qn.U) + ">"), Ue("/O <" + qn.toHexString(qn.O) + ">"), Ue("/P " + qn.P), Ue(">>"), Ue("endobj");
  }, $s = function() {
    for (var O in Ue("/Font <<"), be) be.hasOwnProperty(O) && (C === !1 || C === !0 && I.hasOwnProperty(O)) && Ue("/" + O + " " + be[O].objectNumber + " 0 R");
    Ue(">>");
  }, Il = function() {
    if (Object.keys(ue).length > 0) {
      for (var O in Ue("/Shading <<"), ue) ue.hasOwnProperty(O) && ue[O] instanceof jh && ue[O].objectNumber >= 0 && Ue("/" + O + " " + ue[O].objectNumber + " 0 R");
      pt.publish("putShadingPatternDict"), Ue(">>");
    }
  }, Xo = function(O) {
    if (Object.keys(ue).length > 0) {
      for (var te in Ue("/Pattern <<"), ue) ue.hasOwnProperty(te) && ue[te] instanceof S.TilingPattern && ue[te].objectNumber >= 0 && ue[te].objectNumber < O && Ue("/" + te + " " + ue[te].objectNumber + " 0 R");
      pt.publish("putTilingPatternDict"), Ue(">>");
    }
  }, Xs = function() {
    if (Object.keys(qe).length > 0) {
      var O;
      for (O in Ue("/ExtGState <<"), qe) qe.hasOwnProperty(O) && qe[O].objectNumber >= 0 && Ue("/" + O + " " + qe[O].objectNumber + " 0 R");
      pt.publish("putGStateDict"), Ue(">>");
    }
  }, Ti = function(O) {
    Zn(O.resourcesOid, !0), Ue("<<"), Ue("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), $s(), Il(), Xo(O.objectOid), Xs(), $o(), Ue(">>"), Ue("endobj");
  }, ha = function() {
    var O = [];
    ws(), Ws(), qs(), Hs(O), pt.publish("putResources"), O.forEach(Ti), Ti({ resourcesOid: xi, objectOid: Number.MAX_SAFE_INTEGER }), pt.publish("postPutResources");
  }, Ys = function() {
    pt.publish("putAdditionalObjects");
    for (var O = 0; O < $t.length; O++) {
      var te = $t[O];
      Zn(te.objId, !0), Ue(te.content), Ue("endobj");
    }
    pt.publish("postPutAdditionalObjects");
  }, da = function(O) {
    ne[O.fontName] = ne[O.fontName] || {}, ne[O.fontName][O.fontStyle] = O.id;
  }, Eo = function(O, te, Fe, Ke, yt) {
    var kt = { id: "F" + (Object.keys(be).length + 1).toString(10), postScriptName: O, fontName: te, fontStyle: Fe, encoding: Ke, isStandardFont: yt || !1, metadata: {} };
    return pt.publish("addFont", { font: kt, instance: this }), be[kt.id] = kt, da(kt), kt.id;
  }, sl = function(O) {
    for (var te = 0, Fe = en.length; te < Fe; te++) {
      var Ke = Eo.call(this, O[te][0], O[te][1], O[te][2], en[te][3], !0);
      C === !1 && (I[Ke] = !0);
      var yt = O[te][0].split("-");
      da({ id: Ke, fontName: yt[0], fontStyle: yt[1] || "" });
    }
    pt.publish("addFonts", { fonts: be, dictionary: ne });
  }, yr = function(O) {
    return O.foo = function() {
      try {
        return O.apply(this, arguments);
      } catch (Ke) {
        var te = Ke.stack || "";
        ~te.indexOf(" at ") && (te = te.split(" at ")[1]);
        var Fe = "Error in function " + te.split(`
`)[0].split("<")[0] + ": " + Ke.message;
        if (!ni.console) throw new Error(Fe);
        ni.console.error(Fe, Ke), ni.alert && alert(Fe);
      }
    }, O.foo.bar = O, O.foo;
  }, os = function(O, te) {
    var Fe, Ke, yt, kt, tn, Tn, kn, ii, ei;
    if (yt = (te = te || {}).sourceEncoding || "Unicode", tn = te.outputEncoding, (te.autoencode || tn) && be[Jn].metadata && be[Jn].metadata[yt] && be[Jn].metadata[yt].encoding && (kt = be[Jn].metadata[yt].encoding, !tn && be[Jn].encoding && (tn = be[Jn].encoding), !tn && kt.codePages && (tn = kt.codePages[0]), typeof tn == "string" && (tn = kt[tn]), tn)) {
      for (kn = !1, Tn = [], Fe = 0, Ke = O.length; Fe < Ke; Fe++) (ii = tn[O.charCodeAt(Fe)]) ? Tn.push(String.fromCharCode(ii)) : Tn.push(O[Fe]), Tn[Fe].charCodeAt(0) >> 8 && (kn = !0);
      O = Tn.join("");
    }
    for (Fe = O.length; kn === void 0 && Fe !== 0; ) O.charCodeAt(Fe - 1) >> 8 && (kn = !0), Fe--;
    if (!kn) return O;
    for (Tn = te.noBOM ? [] : [254, 255], Fe = 0, Ke = O.length; Fe < Ke; Fe++) {
      if ((ei = (ii = O.charCodeAt(Fe)) >> 8) >> 8) throw new Error("Character at position " + Fe + " of string '" + O + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
      Tn.push(ei), Tn.push(ii - (ei << 8));
    }
    return String.fromCharCode.apply(void 0, Tn);
  }, nr = S.__private__.pdfEscape = S.pdfEscape = function(O, te) {
    return os(O, te).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, Xn = S.__private__.beginPage = function(O) {
    Wt[++Ye] = [], at[Ye] = { objId: 0, contentsObjId: 0, userUnit: Number(a), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(O[0]), topRightY: Number(O[1]) } }, Ma(Ye), Bt(Wt[Re]);
  }, as = function(O, te) {
    var Fe, Ke, yt;
    switch (t = te || t, typeof O == "string" && (Fe = W(O.toLowerCase()), Array.isArray(Fe) && (Ke = Fe[0], yt = Fe[1])), Array.isArray(O) && (Ke = O[0] * bn, yt = O[1] * bn), isNaN(Ke) && (Ke = r[0], yt = r[1]), (Ke > 14400 || yt > 14400) && (mr.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), Ke = Math.min(14400, Ke), yt = Math.min(14400, yt)), r = [Ke, yt], t.substr(0, 1)) {
      case "l":
        yt > Ke && (r = [yt, Ke]);
        break;
      case "p":
        Ke > yt && (r = [yt, Ke]);
    }
    Xn(r), Sc(Ko), Ue(ji), Fl !== 0 && Ue(Fl + " J"), ou !== 0 && Ue(ou + " j"), pt.publish("addPage", { pageNumber: Ye });
  }, Qn = function(O) {
    O > 0 && O <= Ye && (Wt.splice(O, 1), at.splice(O, 1), Ye--, Re > Ye && (Re = Ye), this.setPage(Re));
  }, Ma = function(O) {
    O > 0 && O <= Ye && (Re = O);
  }, Ec = S.__private__.getNumberOfPages = S.getNumberOfPages = function() {
    return Wt.length - 1;
  }, ge = function(O, te, Fe) {
    var Ke, yt = void 0;
    return Fe = Fe || {}, O = O !== void 0 ? O : be[Jn].fontName, te = te !== void 0 ? te : be[Jn].fontStyle, Ke = O.toLowerCase(), ne[Ke] !== void 0 && ne[Ke][te] !== void 0 ? yt = ne[Ke][te] : ne[O] !== void 0 && ne[O][te] !== void 0 ? yt = ne[O][te] : Fe.disableWarning === !1 && mr.warn("Unable to look up font label for font '" + O + "', '" + te + "'. Refer to getFontList() for available fonts."), yt || Fe.noFallback || (yt = ne.times[te]) == null && (yt = ne.times.normal), yt;
  }, we = S.__private__.putInfo = function() {
    var O = cn(), te = function(Ke) {
      return Ke;
    };
    for (var Fe in A !== null && (te = qn.encryptor(O, 0)), Ue("<<"), Ue("/Producer (" + nr(te("jsPDF " + ti.version)) + ")"), Un) Un.hasOwnProperty(Fe) && Un[Fe] && Ue("/" + Fe.substr(0, 1).toUpperCase() + Fe.substr(1) + " (" + nr(te(Un[Fe])) + ")");
    Ue("/CreationDate (" + nr(te(St)) + ")"), Ue(">>"), Ue("endobj");
  }, Ve = S.__private__.putCatalog = function(O) {
    var te = (O = O || {}).rootDictionaryObjId || fn;
    switch (cn(), Ue("<<"), Ue("/Type /Catalog"), Ue("/Pages " + te + " 0 R"), un || (un = "fullwidth"), un) {
      case "fullwidth":
        Ue("/OpenAction [3 0 R /FitH null]");
        break;
      case "fullheight":
        Ue("/OpenAction [3 0 R /FitV null]");
        break;
      case "fullpage":
        Ue("/OpenAction [3 0 R /Fit]");
        break;
      case "original":
        Ue("/OpenAction [3 0 R /XYZ null null 1]");
        break;
      default:
        var Fe = "" + un;
        Fe.substr(Fe.length - 1) === "%" && (un = parseInt(un) / 100), typeof un == "number" && Ue("/OpenAction [3 0 R /XYZ null null " + ke(un) + "]");
    }
    switch (Yn || (Yn = "continuous"), Yn) {
      case "continuous":
        Ue("/PageLayout /OneColumn");
        break;
      case "single":
        Ue("/PageLayout /SinglePage");
        break;
      case "two":
      case "twoleft":
        Ue("/PageLayout /TwoColumnLeft");
        break;
      case "tworight":
        Ue("/PageLayout /TwoColumnRight");
    }
    Wn && Ue("/PageMode /" + Wn), pt.publish("putCatalog"), Ue(">>"), Ue("endobj");
  }, _t = S.__private__.putTrailer = function() {
    Ue("trailer"), Ue("<<"), Ue("/Size " + (ot + 1)), Ue("/Root " + ot + " 0 R"), Ue("/Info " + (ot - 1) + " 0 R"), A !== null && Ue("/Encrypt " + qn.oid + " 0 R"), Ue("/ID [ <" + dt + "> <" + dt + "> ]"), Ue(">>");
  }, Kt = S.__private__.putHeader = function() {
    Ue("%PDF-" + F), Ue("%ºß¬à");
  }, gn = S.__private__.putXRef = function() {
    var O = "0000000000";
    Ue("xref"), Ue("0 " + (ot + 1)), Ue("0000000000 65535 f ");
    for (var te = 1; te <= ot; te++) typeof rt[te] == "function" ? Ue((O + rt[te]()).slice(-10) + " 00000 n ") : rt[te] !== void 0 ? Ue((O + rt[te]).slice(-10) + " 00000 n ") : Ue("0000000000 00000 n ");
  }, Rn = S.__private__.buildDocument = function() {
    wn(), Bt(xt), pt.publish("buildDocument"), Kt(), _i(), Ys(), ha(), A !== null && Zs(), we(), Ve();
    var O = ht;
    return gn(), _t(), Ue("startxref"), Ue("" + O), Ue("%%EOF"), Bt(Wt[Re]), xt.join(`
`);
  }, hi = S.__private__.getBlob = function(O) {
    return new Blob([Sn(O)], { type: "application/pdf" });
  }, Ji = S.output = S.__private__.output = yr(function(O, te) {
    switch (typeof (te = te || {}) == "string" ? te = { filename: te } : te.filename = te.filename || "generated.pdf", O) {
      case void 0:
        return Rn();
      case "save":
        S.save(te.filename);
        break;
      case "arraybuffer":
        return Sn(Rn());
      case "blob":
        return hi(Rn());
      case "bloburi":
      case "bloburl":
        if (ni.URL !== void 0 && typeof ni.URL.createObjectURL == "function") return ni.URL && ni.URL.createObjectURL(hi(Rn())) || void 0;
        mr.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
        break;
      case "datauristring":
      case "dataurlstring":
        var Fe = "", Ke = Rn();
        try {
          Fe = S1(Ke);
        } catch {
          Fe = S1(unescape(encodeURIComponent(Ke)));
        }
        return "data:application/pdf;filename=" + te.filename + ";base64," + Fe;
      case "pdfobjectnewwindow":
        if (Object.prototype.toString.call(ni) === "[object Window]") {
          var yt = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", kt = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
          te.pdfObjectUrl && (yt = te.pdfObjectUrl, kt = "");
          var tn = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + yt + '"' + kt + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(te) + ");<\/script></body></html>", Tn = ni.open();
          return Tn !== null && Tn.document.write(tn), Tn;
        }
        throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
      case "pdfjsnewwindow":
        if (Object.prototype.toString.call(ni) === "[object Window]") {
          var kn = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (te.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + te.filename + '" width="500px" height="400px" /></body></html>', ii = ni.open();
          if (ii !== null) {
            ii.document.write(kn);
            var ei = this;
            ii.document.documentElement.querySelector("#pdfViewer").onload = function() {
              ii.document.title = te.filename, ii.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(ei.output("bloburl"));
            };
          }
          return ii;
        }
        throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
      case "dataurlnewwindow":
        if (Object.prototype.toString.call(ni) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment.");
        var wi = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", te) + '"></iframe></body></html>', ir = ni.open();
        if (ir !== null && (ir.document.write(wi), ir.document.title = te.filename), ir || typeof safari > "u") return ir;
        break;
      case "datauri":
      case "dataurl":
        return ni.document.location.href = this.output("datauristring", te);
      default:
        return null;
    }
  }), Ki = function(O) {
    return Array.isArray(lt) === !0 && lt.indexOf(O) > -1;
  };
  switch (i) {
    case "pt":
      bn = 1;
      break;
    case "mm":
      bn = 72 / 25.4;
      break;
    case "cm":
      bn = 72 / 2.54;
      break;
    case "in":
      bn = 72;
      break;
    case "px":
      bn = Ki("px_scaling") == 1 ? 0.75 : 96 / 72;
      break;
    case "pc":
    case "em":
      bn = 12;
      break;
    case "ex":
      bn = 6;
      break;
    default:
      if (typeof i != "number") throw new Error("Invalid unit: " + i);
      bn = i;
  }
  var qn = null;
  mn(), gt();
  var Ml = function(O) {
    return A !== null ? qn.encryptor(O, 0) : function(te) {
      return te;
    };
  }, ho = S.__private__.getPageInfo = S.getPageInfo = function(O) {
    if (isNaN(O) || O % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
    return { objId: at[O].objId, pageNumber: O, pageContext: at[O] };
  }, Vn = S.__private__.getPageInfoByObjId = function(O) {
    if (isNaN(O) || O % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
    for (var te in at) if (at[te].objId === O) break;
    return ho(te);
  }, Js = S.__private__.getCurrentPageInfo = S.getCurrentPageInfo = function() {
    return { objId: at[Re].objId, pageNumber: Re, pageContext: at[Re] };
  };
  S.addPage = function() {
    return as.apply(this, arguments), this;
  }, S.setPage = function() {
    return Ma.apply(this, arguments), Bt.call(this, Wt[Re]), this;
  }, S.insertPage = function(O) {
    return this.addPage(), this.movePage(Re, O), this;
  }, S.movePage = function(O, te) {
    var Fe, Ke;
    if (O > te) {
      Fe = Wt[O], Ke = at[O];
      for (var yt = O; yt > te; yt--) Wt[yt] = Wt[yt - 1], at[yt] = at[yt - 1];
      Wt[te] = Fe, at[te] = Ke, this.setPage(te);
    } else if (O < te) {
      Fe = Wt[O], Ke = at[O];
      for (var kt = O; kt < te; kt++) Wt[kt] = Wt[kt + 1], at[kt] = at[kt + 1];
      Wt[te] = Fe, at[te] = Ke, this.setPage(te);
    }
    return this;
  }, S.deletePage = function() {
    return Qn.apply(this, arguments), this;
  }, S.__private__.text = S.text = function(O, te, Fe, Ke, yt) {
    var kt, tn, Tn, kn, ii, ei, wi, ir, Wi, Sr = (Ke = Ke || {}).scope || this;
    if (typeof O == "number" && typeof te == "number" && (typeof Fe == "string" || Array.isArray(Fe))) {
      var hs = Fe;
      Fe = te, te = O, O = hs;
    }
    if (arguments[3] instanceof Xt ? (me("The transform parameter of text() with a Matrix value"), Wi = yt) : (Tn = arguments[4], kn = arguments[5], or(wi = arguments[3]) === "object" && wi !== null || (typeof Tn == "string" && (kn = Tn, Tn = null), typeof wi == "string" && (kn = wi, wi = null), typeof wi == "number" && (Tn = wi, wi = null), Ke = { flags: wi, angle: Tn, align: kn })), isNaN(te) || isNaN(Fe) || O == null) throw new Error("Invalid arguments passed to jsPDF.text");
    if (O.length === 0) return Sr;
    var br = "", po = !1, Bs = typeof Ke.lineHeightFactor == "number" ? Ke.lineHeightFactor : Jo, pa = Sr.internal.scaleFactor;
    function zu(Di) {
      return Di = Di.split("	").join(Array(Ke.TabLen || 9).join(" ")), nr(Di, wi);
    }
    function Ul(Di) {
      for (var Zi, Cr = Di.concat(), Nr = [], za = Cr.length; za--; ) typeof (Zi = Cr.shift()) == "string" ? Nr.push(Zi) : Array.isArray(Di) && (Zi.length === 1 || Zi[1] === void 0 && Zi[2] === void 0) ? Nr.push(Zi[0]) : Nr.push([Zi[0], Zi[1], Zi[2]]);
      return Nr;
    }
    function jl(Di, Zi) {
      var Cr;
      if (typeof Di == "string") Cr = Zi(Di)[0];
      else if (Array.isArray(Di)) {
        for (var Nr, za, fl = Di.concat(), Ua = [], $l = fl.length; $l--; ) typeof (Nr = fl.shift()) == "string" ? Ua.push(Zi(Nr)[0]) : Array.isArray(Nr) && typeof Nr[0] == "string" && (za = Zi(Nr[0], Nr[1], Nr[2]), Ua.push([za[0], za[1], za[2]]));
        Cr = Ua;
      }
      return Cr;
    }
    var Gl = !1, Vl = !0;
    if (typeof O == "string") Gl = !0;
    else if (Array.isArray(O)) {
      var ql = O.concat();
      tn = [];
      for (var ga, rr = ql.length; rr--; ) (typeof (ga = ql.shift()) != "string" || Array.isArray(ga) && typeof ga[0] != "string") && (Vl = !1);
      Gl = Vl;
    }
    if (Gl === !1) throw new Error('Type of text must be string or Array. "' + O + '" is not recognized.');
    typeof O == "string" && (O = O.match(/[\r?\n]/) ? O.split(/\r\n|\r|\n/g) : [O]);
    var al = ln / Sr.internal.scaleFactor, ll = al * (Bs - 1);
    switch (Ke.baseline) {
      case "bottom":
        Fe -= ll;
        break;
      case "top":
        Fe += al - ll;
        break;
      case "hanging":
        Fe += al - 2 * ll;
        break;
      case "middle":
        Fe += al / 2 - ll;
    }
    if ((ei = Ke.maxWidth || 0) > 0 && (typeof O == "string" ? O = Sr.splitTextToSize(O, ei) : Object.prototype.toString.call(O) === "[object Array]" && (O = O.reduce(function(Di, Zi) {
      return Di.concat(Sr.splitTextToSize(Zi, ei));
    }, []))), kt = { text: O, x: te, y: Fe, options: Ke, mutex: { pdfEscape: nr, activeFontKey: Jn, fonts: be, activeFontSize: ln } }, pt.publish("preProcessText", kt), O = kt.text, Tn = (Ke = kt.options).angle, !(Wi instanceof Xt) && Tn && typeof Tn == "number") {
      Tn *= Math.PI / 180, Ke.rotationDirection === 0 && (Tn = -Tn), de === X.ADVANCED && (Tn = -Tn);
      var Oa = Math.cos(Tn), Mc = Math.sin(Tn);
      Wi = new Xt(Oa, Mc, -Mc, Oa, 0, 0);
    } else Tn && Tn instanceof Xt && (Wi = Tn);
    de !== X.ADVANCED || Wi || (Wi = It), (ii = Ke.charSpace || Pc) !== void 0 && (br += Te(_e(ii)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (ir = Ke.horizontalScale) !== void 0 && (br += Te(100 * ir) + ` Tz
`), Ke.lang;
    var As = -1, Da = Ke.renderingMode !== void 0 ? Ke.renderingMode : Ke.stroke, Hl = Sr.internal.getCurrentPageInfo().pageContext;
    switch (Da) {
      case 0:
      case !1:
      case "fill":
        As = 0;
        break;
      case 1:
      case !0:
      case "stroke":
        As = 1;
        break;
      case 2:
      case "fillThenStroke":
        As = 2;
        break;
      case 3:
      case "invisible":
        As = 3;
        break;
      case 4:
      case "fillAndAddForClipping":
        As = 4;
        break;
      case 5:
      case "strokeAndAddPathForClipping":
        As = 5;
        break;
      case 6:
      case "fillThenStrokeAndAddToPathForClipping":
        As = 6;
        break;
      case 7:
      case "addToPathForClipping":
        As = 7;
    }
    var Ei = Hl.usedRenderingMode !== void 0 ? Hl.usedRenderingMode : -1;
    As !== -1 ? br += As + ` Tr
` : Ei !== -1 && (br += `0 Tr
`), As !== -1 && (Hl.usedRenderingMode = As), kn = Ke.align || "left";
    var Io, Lc = ln * Bs, Uu = Sr.internal.pageSize.getWidth(), lu = be[Jn];
    ii = Ke.charSpace || Pc, ei = Ke.maxWidth || 0, wi = Object.assign({ autoencode: !0, noBOM: !0 }, Ke.flags);
    var cl = [], ul = function(Di) {
      return Sr.getStringUnitWidth(Di, { font: lu, charSpace: ii, fontSize: ln, doKerning: !1 }) * ln / pa;
    };
    if (Object.prototype.toString.call(O) === "[object Array]") {
      var ds;
      tn = Ul(O), kn !== "left" && (Io = tn.map(ul));
      var $r, Qo = 0;
      if (kn === "right") {
        te -= Io[0], O = [], rr = tn.length;
        for (var ea = 0; ea < rr; ea++) ea === 0 ? ($r = yi(te), ds = Ks(Fe)) : ($r = _e(Qo - Io[ea]), ds = -Lc), O.push([tn[ea], $r, ds]), Qo = Io[ea];
      } else if (kn === "center") {
        te -= Io[0] / 2, O = [], rr = tn.length;
        for (var Os = 0; Os < rr; Os++) Os === 0 ? ($r = yi(te), ds = Ks(Fe)) : ($r = _e((Qo - Io[Os]) / 2), ds = -Lc), O.push([tn[Os], $r, ds]), Qo = Io[Os];
      } else if (kn === "left") {
        O = [], rr = tn.length;
        for (var ta = 0; ta < rr; ta++) O.push(tn[ta]);
      } else if (kn === "justify" && lu.encoding === "Identity-H") {
        O = [], rr = tn.length, ei = ei !== 0 ? ei : Uu;
        for (var Fr = 0, vr = 0; vr < rr; vr++) if (ds = vr === 0 ? Ks(Fe) : -Lc, $r = vr === 0 ? yi(te) : Fr, vr < rr - 1) {
          var Rc = _e((ei - Io[vr]) / (tn[vr].split(" ").length - 1)), fs = tn[vr].split(" ");
          O.push([fs[0] + " ", $r, ds]), Fr = 0;
          for (var Xr = 1; Xr < fs.length; Xr++) {
            var Fa = (ul(fs[Xr - 1] + " " + fs[Xr]) - ul(fs[Xr])) * pa + Rc;
            Xr == fs.length - 1 ? O.push([fs[Xr], Fa, 0]) : O.push([fs[Xr] + " ", Fa, 0]), Fr -= Fa;
          }
        } else O.push([tn[vr], $r, ds]);
        O.push(["", Fr, 0]);
      } else {
        if (kn !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
        for (O = [], rr = tn.length, ei = ei !== 0 ? ei : Uu, vr = 0; vr < rr; vr++) ds = vr === 0 ? Ks(Fe) : -Lc, $r = vr === 0 ? yi(te) : 0, vr < rr - 1 ? cl.push(Te(_e((ei - Io[vr]) / (tn[vr].split(" ").length - 1)))) : cl.push(0), O.push([tn[vr], $r, ds]);
      }
    }
    var Wl = typeof Ke.R2L == "boolean" ? Ke.R2L : Mn;
    Wl === !0 && (O = jl(O, function(Di, Zi, Cr) {
      return [Di.split("").reverse().join(""), Zi, Cr];
    })), kt = { text: O, x: te, y: Fe, options: Ke, mutex: { pdfEscape: nr, activeFontKey: Jn, fonts: be, activeFontSize: ln } }, pt.publish("postProcessText", kt), O = kt.text, po = kt.mutex.isHex || !1;
    var Na = be[Jn].encoding;
    Na !== "WinAnsiEncoding" && Na !== "StandardEncoding" || (O = jl(O, function(Di, Zi, Cr) {
      return [zu(Di), Zi, Cr];
    })), tn = Ul(O), O = [];
    for (var ma, hl, go, Mo = 0, Zl = 1, ka = Array.isArray(tn[0]) ? Zl : Mo, oi = "", dl = function(Di, Zi, Cr) {
      var Nr = "";
      return Cr instanceof Xt ? (Cr = typeof Ke.angle == "number" ? An(Cr, new Xt(1, 0, 0, 1, Di, Zi)) : An(new Xt(1, 0, 0, 1, Di, Zi), Cr), de === X.ADVANCED && (Cr = An(new Xt(1, 0, 0, -1, 0, 0), Cr)), Nr = Cr.join(" ") + ` Tm
`) : Nr = Te(Di) + " " + Te(Zi) + ` Td
`, Nr;
    }, Lo = 0; Lo < tn.length; Lo++) {
      switch (oi = "", ka) {
        case Zl:
          go = (po ? "<" : "(") + tn[Lo][0] + (po ? ">" : ")"), ma = parseFloat(tn[Lo][1]), hl = parseFloat(tn[Lo][2]);
          break;
        case Mo:
          go = (po ? "<" : "(") + tn[Lo] + (po ? ">" : ")"), ma = yi(te), hl = Ks(Fe);
      }
      cl !== void 0 && cl[Lo] !== void 0 && (oi = cl[Lo] + ` Tw
`), Lo === 0 ? O.push(oi + dl(ma, hl, Wi) + go) : ka === Mo ? O.push(oi + go) : ka === Zl && O.push(oi + dl(ma, hl, Wi) + go);
    }
    O = ka === Mo ? O.join(` Tj
T* `) : O.join(` Tj
`), O += ` Tj
`;
    var mo = `BT
/`;
    return mo += Jn + " " + ln + ` Tf
`, mo += Te(ln * Bs) + ` TL
`, mo += eo + `
`, mo += br, mo += O, Ue(mo += "ET"), I[Jn] = !0, Sr;
  };
  var ru = S.__private__.clip = S.clip = function(O) {
    return Ue(O === "evenodd" ? "W*" : "W"), this;
  };
  S.clipEvenOdd = function() {
    return ru("evenodd");
  }, S.__private__.discardPath = S.discardPath = function() {
    return Ue("n"), this;
  };
  var Zr = S.__private__.isValidStyle = function(O) {
    var te = !1;
    return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(O) !== -1 && (te = !0), te;
  };
  S.__private__.setDefaultPathOperation = S.setDefaultPathOperation = function(O) {
    return Zr(O) && (y = O), this;
  };
  var Ll = S.__private__.getStyle = S.getStyle = function(O) {
    var te = y;
    switch (O) {
      case "D":
      case "S":
        te = "S";
        break;
      case "F":
        te = "f";
        break;
      case "FD":
      case "DF":
        te = "B";
        break;
      case "f":
      case "f*":
      case "B":
      case "B*":
        te = O;
    }
    return te;
  }, Ui = S.close = function() {
    return Ue("h"), this;
  };
  S.stroke = function() {
    return Ue("S"), this;
  }, S.fill = function(O) {
    return Yo("f", O), this;
  }, S.fillEvenOdd = function(O) {
    return Yo("f*", O), this;
  }, S.fillStroke = function(O) {
    return Yo("B", O), this;
  }, S.fillStrokeEvenOdd = function(O) {
    return Yo("B*", O), this;
  };
  var Yo = function(O, te) {
    or(te) === "object" ? Rl(te, O) : Ue(O);
  }, li = function(O) {
    O === null || de === X.ADVANCED && O === void 0 || (O = Ll(O), Ue(O));
  };
  function Kn(O, te, Fe, Ke, yt) {
    var kt = new Wd(te || this.boundingBox, Fe || this.xStep, Ke || this.yStep, this.gState, yt || this.matrix);
    kt.stream = this.stream;
    var tn = O + "$$" + this.cloneIndex++ + "$$";
    return Jt(tn, kt), kt;
  }
  var Rl = function(O, te) {
    var Fe = Oe[O.key], Ke = ue[Fe];
    if (Ke instanceof jh) Ue("q"), Ue(gi(te)), Ke.gState && S.setGState(Ke.gState), Ue(O.matrix.toString() + " cm"), Ue("/" + Fe + " sh"), Ue("Q");
    else if (Ke instanceof Wd) {
      var yt = new Xt(1, 0, 0, -1, 0, Po());
      O.matrix && (yt = yt.multiply(O.matrix || It), Fe = Kn.call(Ke, O.key, O.boundingBox, O.xStep, O.yStep, yt).id), Ue("q"), Ue("/Pattern cs"), Ue("/" + Fe + " scn"), Ke.gState && S.setGState(Ke.gState), Ue(te), Ue("Q");
    }
  }, gi = function(O) {
    switch (O) {
      case "f":
      case "F":
        return "W n";
      case "f*":
        return "W* n";
      case "B":
        return "W S";
      case "B*":
        return "W* S";
      case "S":
        return "W S";
      case "n":
        return "W n";
    }
  }, fa = S.moveTo = function(O, te) {
    return Ue(Te(_e(O)) + " " + Te(Me(te)) + " m"), this;
  }, ls = S.lineTo = function(O, te) {
    return Ue(Te(_e(O)) + " " + Te(Me(te)) + " l"), this;
  }, So = S.curveTo = function(O, te, Fe, Ke, yt, kt) {
    return Ue([Te(_e(O)), Te(Me(te)), Te(_e(Fe)), Te(Me(Ke)), Te(_e(yt)), Te(Me(kt)), "c"].join(" ")), this;
  };
  S.__private__.line = S.line = function(O, te, Fe, Ke, yt) {
    if (isNaN(O) || isNaN(te) || isNaN(Fe) || isNaN(Ke) || !Zr(yt)) throw new Error("Invalid arguments passed to jsPDF.line");
    return de === X.COMPAT ? this.lines([[Fe - O, Ke - te]], O, te, [1, 1], yt || "S") : this.lines([[Fe - O, Ke - te]], O, te, [1, 1]).stroke();
  }, S.__private__.lines = S.lines = function(O, te, Fe, Ke, yt, kt) {
    var tn, Tn, kn, ii, ei, wi, ir, Wi, Sr, hs, br, po;
    if (typeof O == "number" && (po = Fe, Fe = te, te = O, O = po), Ke = Ke || [1, 1], kt = kt || !1, isNaN(te) || isNaN(Fe) || !Array.isArray(O) || !Array.isArray(Ke) || !Zr(yt) || typeof kt != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines");
    for (fa(te, Fe), tn = Ke[0], Tn = Ke[1], ii = O.length, hs = te, br = Fe, kn = 0; kn < ii; kn++) (ei = O[kn]).length === 2 ? (hs = ei[0] * tn + hs, br = ei[1] * Tn + br, ls(hs, br)) : (wi = ei[0] * tn + hs, ir = ei[1] * Tn + br, Wi = ei[2] * tn + hs, Sr = ei[3] * Tn + br, hs = ei[4] * tn + hs, br = ei[5] * Tn + br, So(wi, ir, Wi, Sr, hs, br));
    return kt && Ui(), li(yt), this;
  }, S.path = function(O) {
    for (var te = 0; te < O.length; te++) {
      var Fe = O[te], Ke = Fe.c;
      switch (Fe.op) {
        case "m":
          fa(Ke[0], Ke[1]);
          break;
        case "l":
          ls(Ke[0], Ke[1]);
          break;
        case "c":
          So.apply(this, Ke);
          break;
        case "h":
          Ui();
      }
    }
    return this;
  }, S.__private__.rect = S.rect = function(O, te, Fe, Ke, yt) {
    if (isNaN(O) || isNaN(te) || isNaN(Fe) || isNaN(Ke) || !Zr(yt)) throw new Error("Invalid arguments passed to jsPDF.rect");
    return de === X.COMPAT && (Ke = -Ke), Ue([Te(_e(O)), Te(Me(te)), Te(_e(Fe)), Te(_e(Ke)), "re"].join(" ")), li(yt), this;
  }, S.__private__.triangle = S.triangle = function(O, te, Fe, Ke, yt, kt, tn) {
    if (isNaN(O) || isNaN(te) || isNaN(Fe) || isNaN(Ke) || isNaN(yt) || isNaN(kt) || !Zr(tn)) throw new Error("Invalid arguments passed to jsPDF.triangle");
    return this.lines([[Fe - O, Ke - te], [yt - Fe, kt - Ke], [O - yt, te - kt]], O, te, [1, 1], tn, !0), this;
  }, S.__private__.roundedRect = S.roundedRect = function(O, te, Fe, Ke, yt, kt, tn) {
    if (isNaN(O) || isNaN(te) || isNaN(Fe) || isNaN(Ke) || isNaN(yt) || isNaN(kt) || !Zr(tn)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
    var Tn = 4 / 3 * (Math.SQRT2 - 1);
    return yt = Math.min(yt, 0.5 * Fe), kt = Math.min(kt, 0.5 * Ke), this.lines([[Fe - 2 * yt, 0], [yt * Tn, 0, yt, kt - kt * Tn, yt, kt], [0, Ke - 2 * kt], [0, kt * Tn, -yt * Tn, kt, -yt, kt], [2 * yt - Fe, 0], [-yt * Tn, 0, -yt, -kt * Tn, -yt, -kt], [0, 2 * kt - Ke], [0, -kt * Tn, yt * Tn, -kt, yt, -kt]], O + yt, te, [1, 1], tn, !0), this;
  }, S.__private__.ellipse = S.ellipse = function(O, te, Fe, Ke, yt) {
    if (isNaN(O) || isNaN(te) || isNaN(Fe) || isNaN(Ke) || !Zr(yt)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
    var kt = 4 / 3 * (Math.SQRT2 - 1) * Fe, tn = 4 / 3 * (Math.SQRT2 - 1) * Ke;
    return fa(O + Fe, te), So(O + Fe, te - tn, O + kt, te - Ke, O, te - Ke), So(O - kt, te - Ke, O - Fe, te - tn, O - Fe, te), So(O - Fe, te + tn, O - kt, te + Ke, O, te + Ke), So(O + kt, te + Ke, O + Fe, te + tn, O + Fe, te), li(yt), this;
  }, S.__private__.circle = S.circle = function(O, te, Fe, Ke) {
    if (isNaN(O) || isNaN(te) || isNaN(Fe) || !Zr(Ke)) throw new Error("Invalid arguments passed to jsPDF.circle");
    return this.ellipse(O, te, Fe, Fe, Ke);
  }, S.setFont = function(O, te, Fe) {
    return Fe && (te = Ae(te, Fe)), Jn = ge(O, te, { disableWarning: !1 }), this;
  };
  var Bl = S.__private__.getFont = S.getFont = function() {
    return be[ge.apply(S, arguments)];
  };
  S.__private__.getFontList = S.getFontList = function() {
    var O, te, Fe = {};
    for (O in ne) if (ne.hasOwnProperty(O)) for (te in Fe[O] = [], ne[O]) ne[O].hasOwnProperty(te) && Fe[O].push(te);
    return Fe;
  }, S.addFont = function(O, te, Fe, Ke, yt) {
    var kt = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
    return arguments[3] && kt.indexOf(arguments[3]) !== -1 ? yt = arguments[3] : arguments[3] && kt.indexOf(arguments[3]) == -1 && (Fe = Ae(Fe, Ke)), yt = yt || "Identity-H", Eo.call(this, O, te, Fe, yt);
  };
  var Jo, Ko = n.lineWidth || 0.200025, Ol = S.__private__.getLineWidth = S.getLineWidth = function() {
    return Ko;
  }, Sc = S.__private__.setLineWidth = S.setLineWidth = function(O) {
    return Ko = O, Ue(Te(_e(O)) + " w"), this;
  };
  S.__private__.setLineDash = ti.API.setLineDash = ti.API.setLineDashPattern = function(O, te) {
    if (O = O || [], te = te || 0, isNaN(te) || !Array.isArray(O)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
    return O = O.map(function(Fe) {
      return Te(_e(Fe));
    }).join(" "), te = Te(_e(te)), Ue("[" + O + "] " + te + " d"), this;
  };
  var Cc = S.__private__.getLineHeight = S.getLineHeight = function() {
    return ln * Jo;
  };
  S.__private__.getLineHeight = S.getLineHeight = function() {
    return ln * Jo;
  };
  var su = S.__private__.setLineHeightFactor = S.setLineHeightFactor = function(O) {
    return typeof (O = O || 1.15) == "number" && (Jo = O), this;
  }, ol = S.__private__.getLineHeightFactor = S.getLineHeightFactor = function() {
    return Jo;
  };
  su(n.lineHeight);
  var yi = S.__private__.getHorizontalCoordinate = function(O) {
    return _e(O);
  }, Ks = S.__private__.getVerticalCoordinate = function(O) {
    return de === X.ADVANCED ? O : at[Re].mediaBox.topRightY - at[Re].mediaBox.bottomLeftY - _e(O);
  }, fo = S.__private__.getHorizontalCoordinateString = S.getHorizontalCoordinateString = function(O) {
    return Te(yi(O));
  }, Qs = S.__private__.getVerticalCoordinateString = S.getVerticalCoordinateString = function(O) {
    return Te(Ks(O));
  }, ji = n.strokeColor || "0 G";
  S.__private__.getStrokeColor = S.getDrawColor = function() {
    return Er(ji);
  }, S.__private__.setStrokeColor = S.setDrawColor = function(O, te, Fe, Ke) {
    return ji = Pi({ ch1: O, ch2: te, ch3: Fe, ch4: Ke, pdfColorType: "draw", precision: 2 }), Ue(ji), this;
  };
  var Dl = n.fillColor || "0 g";
  S.__private__.getFillColor = S.getFillColor = function() {
    return Er(Dl);
  }, S.__private__.setFillColor = S.setFillColor = function(O, te, Fe, Ke) {
    return Dl = Pi({ ch1: O, ch2: te, ch3: Fe, ch4: Ke, pdfColorType: "fill", precision: 2 }), Ue(Dl), this;
  };
  var eo = n.textColor || "0 g", ku = S.__private__.getTextColor = S.getTextColor = function() {
    return Er(eo);
  };
  S.__private__.setTextColor = S.setTextColor = function(O, te, Fe, Ke) {
    return eo = Pi({ ch1: O, ch2: te, ch3: Fe, ch4: Ke, pdfColorType: "text", precision: 3 }), this;
  };
  var Pc = n.charSpace, Ic = S.__private__.getCharSpace = S.getCharSpace = function() {
    return parseFloat(Pc || 0);
  };
  S.__private__.setCharSpace = S.setCharSpace = function(O) {
    if (isNaN(O)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
    return Pc = O, this;
  };
  var Fl = 0;
  S.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, S.__private__.setLineCap = S.setLineCap = function(O) {
    var te = S.CapJoinStyles[O];
    if (te === void 0) throw new Error("Line cap style of '" + O + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return Fl = te, Ue(te + " J"), this;
  };
  var ou = 0;
  S.__private__.setLineJoin = S.setLineJoin = function(O) {
    var te = S.CapJoinStyles[O];
    if (te === void 0) throw new Error("Line join style of '" + O + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
    return ou = te, Ue(te + " j"), this;
  }, S.__private__.setLineMiterLimit = S.__private__.setMiterLimit = S.setLineMiterLimit = S.setMiterLimit = function(O) {
    if (O = O || 0, isNaN(O)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
    return Ue(Te(_e(O)) + " M"), this;
  }, S.GState = Gm, S.setGState = function(O) {
    (O = typeof O == "string" ? qe[it[O]] : Nl(null, O)).equals(mt) || (Ue("/" + O.id + " gs"), mt = O);
  };
  var Nl = function(O, te) {
    if (!O || !it[O]) {
      var Fe = !1;
      for (var Ke in qe) if (qe.hasOwnProperty(Ke) && qe[Ke].equals(te)) {
        Fe = !0;
        break;
      }
      if (Fe) te = qe[Ke];
      else {
        var yt = "GS" + (Object.keys(qe).length + 1).toString(10);
        qe[yt] = te, te.id = yt;
      }
      return O && (it[O] = te.id), pt.publish("addGState", te), te;
    }
  };
  S.addGState = function(O, te) {
    return Nl(O, te), this;
  }, S.saveGraphicsState = function() {
    return Ue("q"), ce.push({ key: Jn, size: ln, color: eo }), this;
  }, S.restoreGraphicsState = function() {
    Ue("Q");
    var O = ce.pop();
    return Jn = O.key, ln = O.size, eo = O.color, mt = null, this;
  }, S.setCurrentTransformationMatrix = function(O) {
    return Ue(O.toString() + " cm"), this;
  }, S.comment = function(O) {
    return Ue("#" + O), this;
  };
  var Co = function(O, te) {
    var Fe = O || 0;
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return Fe;
    }, set: function(kt) {
      isNaN(kt) || (Fe = parseFloat(kt));
    } });
    var Ke = te || 0;
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return Ke;
    }, set: function(kt) {
      isNaN(kt) || (Ke = parseFloat(kt));
    } });
    var yt = "pt";
    return Object.defineProperty(this, "type", { enumerable: !0, get: function() {
      return yt;
    }, set: function(kt) {
      yt = kt.toString();
    } }), this;
  }, cs = function(O, te, Fe, Ke) {
    Co.call(this, O, te), this.type = "rect";
    var yt = Fe || 0;
    Object.defineProperty(this, "w", { enumerable: !0, get: function() {
      return yt;
    }, set: function(tn) {
      isNaN(tn) || (yt = parseFloat(tn));
    } });
    var kt = Ke || 0;
    return Object.defineProperty(this, "h", { enumerable: !0, get: function() {
      return kt;
    }, set: function(tn) {
      isNaN(tn) || (kt = parseFloat(tn));
    } }), this;
  }, La = function() {
    this.page = Ye, this.currentPage = Re, this.pages = Wt.slice(0), this.pagesContext = at.slice(0), this.x = tr, this.y = pi, this.matrix = Dr, this.width = kl(Re), this.height = Po(Re), this.outputDestination = hn, this.id = "", this.objectNumber = -1;
  };
  La.prototype.restore = function() {
    Ye = this.page, Re = this.currentPage, at = this.pagesContext, Wt = this.pages, tr = this.x, pi = this.y, Dr = this.matrix, zl(Re, this.width), Ba(Re, this.height), hn = this.outputDestination;
  };
  var Ra = function(O, te, Fe, Ke, yt) {
    Yt.push(new La()), Ye = Re = 0, Wt = [], tr = O, pi = te, Dr = yt, Xn([Fe, Ke]);
  }, au = function(O) {
    if (an[O]) Yt.pop().restore();
    else {
      var te = new La(), Fe = "Xo" + (Object.keys(Ze).length + 1).toString(10);
      te.id = Fe, an[O] = Fe, Ze[Fe] = te, pt.publish("addFormObject", te), Yt.pop().restore();
    }
  };
  for (var us in S.beginFormObject = function(O, te, Fe, Ke, yt) {
    return Ra(O, te, Fe, Ke, yt), this;
  }, S.endFormObject = function(O) {
    return au(O), this;
  }, S.doFormObject = function(O, te) {
    var Fe = Ze[an[O]];
    return Ue("q"), Ue(te.toString() + " cm"), Ue("/" + Fe.id + " Do"), Ue("Q"), this;
  }, S.getFormObject = function(O) {
    var te = Ze[an[O]];
    return { x: te.x, y: te.y, width: te.width, height: te.height, matrix: te.matrix };
  }, S.save = function(O, te) {
    return O = O || "generated.pdf", (te = te || {}).returnPromise = te.returnPromise || !1, te.returnPromise === !1 ? (kh(hi(Rn()), O), typeof kh.unload == "function" && ni.setTimeout && setTimeout(kh.unload, 911), this) : new Promise(function(Fe, Ke) {
      try {
        var yt = kh(hi(Rn()), O);
        typeof kh.unload == "function" && ni.setTimeout && setTimeout(kh.unload, 911), Fe(yt);
      } catch (kt) {
        Ke(kt.message);
      }
    });
  }, ti.API) ti.API.hasOwnProperty(us) && (us === "events" && ti.API.events.length ? function(O, te) {
    var Fe, Ke, yt;
    for (yt = te.length - 1; yt !== -1; yt--) Fe = te[yt][0], Ke = te[yt][1], O.subscribe.apply(O, [Fe].concat(typeof Ke == "function" ? [Ke] : Ke));
  }(pt, ti.API.events) : S[us] = ti.API[us]);
  var kl = S.getPageWidth = function(O) {
    return (at[O = O || Re].mediaBox.topRightX - at[O].mediaBox.bottomLeftX) / bn;
  }, zl = S.setPageWidth = function(O, te) {
    at[O].mediaBox.topRightX = te * bn + at[O].mediaBox.bottomLeftX;
  }, Po = S.getPageHeight = function(O) {
    return (at[O = O || Re].mediaBox.topRightY - at[O].mediaBox.bottomLeftY) / bn;
  }, Ba = S.setPageHeight = function(O, te) {
    at[O].mediaBox.topRightY = te * bn + at[O].mediaBox.bottomLeftY;
  };
  return S.internal = { pdfEscape: nr, getStyle: Ll, getFont: Bl, getFontSize: _n, getCharSpace: Ic, getTextColor: ku, getLineHeight: Cc, getLineHeightFactor: ol, getLineWidth: Ol, write: On, getHorizontalCoordinate: yi, getVerticalCoordinate: Ks, getCoordinateString: fo, getVerticalCoordinateString: Qs, collections: {}, newObject: cn, newAdditionalObject: Ln, newObjectDeferred: In, newObjectDeferredBegin: Zn, getFilters: Ii, putStream: ui, events: pt, scaleFactor: bn, pageSize: { getWidth: function() {
    return kl(Re);
  }, setWidth: function(O) {
    zl(Re, O);
  }, getHeight: function() {
    return Po(Re);
  }, setHeight: function(O) {
    Ba(Re, O);
  } }, encryptionOptions: A, encryption: qn, getEncryptor: Ml, output: Ji, getNumberOfPages: Ec, pages: Wt, out: Ue, f2: ke, f3: pe, getPageInfo: ho, getPageInfoByObjId: Vn, getCurrentPageInfo: Js, getPDFVersion: U, Point: Co, Rectangle: cs, Matrix: Xt, hasHotfix: Ki }, Object.defineProperty(S.internal.pageSize, "width", { get: function() {
    return kl(Re);
  }, set: function(O) {
    zl(Re, O);
  }, enumerable: !0, configurable: !0 }), Object.defineProperty(S.internal.pageSize, "height", { get: function() {
    return Po(Re);
  }, set: function(O) {
    Ba(Re, O);
  }, enumerable: !0, configurable: !0 }), sl.call(S, en), Jn = "F1", as(r, t), pt.publish("initialized"), S;
}
Ud.prototype.lsbFirstWord = function(n) {
  return String.fromCharCode(n >> 0 & 255, n >> 8 & 255, n >> 16 & 255, n >> 24 & 255);
}, Ud.prototype.toHexString = function(n) {
  return n.split("").map(function(e) {
    return ("0" + (255 & e.charCodeAt(0)).toString(16)).slice(-2);
  }).join("");
}, Ud.prototype.hexToBytes = function(n) {
  for (var e = [], t = 0; t < n.length; t += 2) e.push(String.fromCharCode(parseInt(n.substr(t, 2), 16)));
  return e.join("");
}, Ud.prototype.processOwnerPassword = function(n, e) {
  return P1(C1(e).substr(0, 5), n);
}, Ud.prototype.encryptor = function(n, e) {
  var t = C1(this.encryptionKey + String.fromCharCode(255 & n, n >> 8 & 255, n >> 16 & 255, 255 & e, e >> 8 & 255)).substr(0, 10);
  return function(i) {
    return P1(t, i);
  };
}, Gm.prototype.equals = function(n) {
  var e, t = "id,objectNumber,equals";
  if (!n || or(n) !== or(this)) return !1;
  var i = 0;
  for (e in this) if (!(t.indexOf(e) >= 0)) {
    if (this.hasOwnProperty(e) && !n.hasOwnProperty(e) || this[e] !== n[e]) return !1;
    i++;
  }
  for (e in n) n.hasOwnProperty(e) && t.indexOf(e) < 0 && i--;
  return i === 0;
}, ti.API = { events: [] }, ti.version = "2.5.2";
var rs = ti.API, rv = 1, od = function(n) {
  return n.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
}, Fd = function(n) {
  return n.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}, di = function(n) {
  return n.toFixed(2);
}, ah = function(n) {
  return n.toFixed(5);
};
rs.__acroform__ = {};
var Pa = function(n, e) {
  n.prototype = Object.create(e.prototype), n.prototype.constructor = n;
}, x5 = function(n) {
  return n * rv;
}, $c = function(n) {
  var e = new b3(), t = Nn.internal.getHeight(n) || 0, i = Nn.internal.getWidth(n) || 0;
  return e.BBox = [0, 0, Number(di(i)), Number(di(t))], e;
}, jV = rs.__acroform__.setBit = function(n, e) {
  if (n = n || 0, e = e || 0, isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
  return n |= 1 << e;
}, GV = rs.__acroform__.clearBit = function(n, e) {
  if (n = n || 0, e = e || 0, isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
  return n &= ~(1 << e);
}, VV = rs.__acroform__.getBit = function(n, e) {
  if (isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
  return n & 1 << e ? 1 : 0;
}, ys = rs.__acroform__.getBitForPdf = function(n, e) {
  if (isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
  return VV(n, e - 1);
}, bs = rs.__acroform__.setBitForPdf = function(n, e) {
  if (isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
  return jV(n, e - 1);
}, vs = rs.__acroform__.clearBitForPdf = function(n, e) {
  if (isNaN(n) || isNaN(e)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
  return GV(n, e - 1);
}, qV = rs.__acroform__.calculateCoordinates = function(n, e) {
  var t = e.internal.getHorizontalCoordinate, i = e.internal.getVerticalCoordinate, r = n[0], l = n[1], c = n[2], a = n[3], g = {};
  return g.lowerLeft_X = t(r) || 0, g.lowerLeft_Y = i(l + a) || 0, g.upperRight_X = t(r + c) || 0, g.upperRight_Y = i(l) || 0, [Number(di(g.lowerLeft_X)), Number(di(g.lowerLeft_Y)), Number(di(g.upperRight_X)), Number(di(g.upperRight_Y))];
}, HV = function(n) {
  if (n.appearanceStreamContent) return n.appearanceStreamContent;
  if (n.V || n.DV) {
    var e = [], t = n._V || n.DV, i = I1(n, t), r = n.scope.internal.getFont(n.fontName, n.fontStyle).id;
    e.push("/Tx BMC"), e.push("q"), e.push("BT"), e.push(n.scope.__private__.encodeColorString(n.color)), e.push("/" + r + " " + di(i.fontSize) + " Tf"), e.push("1 0 0 1 0 0 Tm"), e.push(i.text), e.push("ET"), e.push("Q"), e.push("EMC");
    var l = $c(n);
    return l.scope = n.scope, l.stream = e.join(`
`), l;
  }
}, I1 = function(n, e) {
  var t = n.fontSize === 0 ? n.maxFontSize : n.fontSize, i = { text: "", fontSize: "" }, r = (e = (e = e.substr(0, 1) == "(" ? e.substr(1) : e).substr(e.length - 1) == ")" ? e.substr(0, e.length - 1) : e).split(" ");
  r = n.multiline ? r.map(function(pe) {
    return pe.split(`
`);
  }) : r.map(function(pe) {
    return [pe];
  });
  var l = t, c = Nn.internal.getHeight(n) || 0;
  c = c < 0 ? -c : c;
  var a = Nn.internal.getWidth(n) || 0;
  a = a < 0 ? -a : a;
  var g = function(pe, _e, De) {
    if (pe + 1 < r.length) {
      var Me = _e + " " + r[pe + 1][0];
      return Yg(Me, n, De).width <= a - 4;
    }
    return !1;
  };
  l++;
  e: for (; l > 0; ) {
    e = "", l--;
    var y, A, C = Yg("3", n, l).height, I = n.multiline ? c - l : (c - C) / 2, S = I += 2, F = 0, U = 0, V = 0;
    if (l <= 0) {
      e = `(...) Tj
`, e += "% Width of Text: " + Yg(e, n, l = 12).width + ", FieldWidth:" + a + `
`;
      break;
    }
    for (var W = "", X = 0, de = 0; de < r.length; de++) if (r.hasOwnProperty(de)) {
      var ie = !1;
      if (r[de].length !== 1 && V !== r[de].length - 1) {
        if ((C + 2) * (X + 2) + 2 > c) continue e;
        W += r[de][V], ie = !0, U = de, de--;
      } else {
        W = (W += r[de][V] + " ").substr(W.length - 1) == " " ? W.substr(0, W.length - 1) : W;
        var fe = parseInt(de), Ae = g(fe, W, l), Te = de >= r.length - 1;
        if (Ae && !Te) {
          W += " ", V = 0;
          continue;
        }
        if (Ae || Te) {
          if (Te) U = fe;
          else if (n.multiline && (C + 2) * (X + 2) + 2 > c) continue e;
        } else {
          if (!n.multiline || (C + 2) * (X + 2) + 2 > c) continue e;
          U = fe;
        }
      }
      for (var me = "", Ge = F; Ge <= U; Ge++) {
        var ke = r[Ge];
        if (n.multiline) {
          if (Ge === U) {
            me += ke[V] + " ", V = (V + 1) % ke.length;
            continue;
          }
          if (Ge === F) {
            me += ke[ke.length - 1] + " ";
            continue;
          }
        }
        me += ke[0] + " ";
      }
      switch (me = me.substr(me.length - 1) == " " ? me.substr(0, me.length - 1) : me, A = Yg(me, n, l).width, n.textAlign) {
        case "right":
          y = a - A - 2;
          break;
        case "center":
          y = (a - A) / 2;
          break;
        case "left":
        default:
          y = 2;
      }
      e += di(y) + " " + di(S) + ` Td
`, e += "(" + od(me) + `) Tj
`, e += -di(y) + ` 0 Td
`, S = -(l + 2), A = 0, F = ie ? U : U + 1, X++, W = "";
    }
    break;
  }
  return i.text = e, i.fontSize = l, i;
}, Yg = function(n, e, t) {
  var i = e.scope.internal.getFont(e.fontName, e.fontStyle), r = e.scope.getStringUnitWidth(n, { font: i, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t);
  return { height: e.scope.getStringUnitWidth("3", { font: i, fontSize: parseFloat(t), charSpace: 0 }) * parseFloat(t) * 1.5, width: r };
}, WV = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, ZV = function(n, e) {
  var t = { type: "reference", object: n };
  e.internal.getPageInfo(n.page).pageContext.annotations.find(function(i) {
    return i.type === t.type && i.object === t.object;
  }) === void 0 && e.internal.getPageInfo(n.page).pageContext.annotations.push(t);
}, $V = function(n, e) {
  for (var t in n) if (n.hasOwnProperty(t)) {
    var i = t, r = n[t];
    e.internal.newObjectDeferredBegin(r.objId, !0), or(r) === "object" && typeof r.putStream == "function" && r.putStream(), delete n[i];
  }
}, XV = function(n, e) {
  if (e.scope = n, n.internal !== void 0 && (n.internal.acroformPlugin === void 0 || n.internal.acroformPlugin.isInitialized === !1)) {
    if (wc.FieldNum = 0, n.internal.acroformPlugin = JSON.parse(JSON.stringify(WV)), n.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
    rv = n.internal.scaleFactor, n.internal.acroformPlugin.acroFormDictionaryRoot = new v3(), n.internal.acroformPlugin.acroFormDictionaryRoot.scope = n, n.internal.acroformPlugin.acroFormDictionaryRoot._eventID = n.internal.events.subscribe("postPutResources", function() {
      (function(t) {
        t.internal.events.unsubscribe(t.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t.internal.acroformPlugin.printedOut = !0;
      })(n);
    }), n.internal.events.subscribe("buildDocument", function() {
      (function(t) {
        t.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
        var i = t.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
        for (var r in i) if (i.hasOwnProperty(r)) {
          var l = i[r];
          l.objId = void 0, l.hasAnnotation && ZV(l, t);
        }
      })(n);
    }), n.internal.events.subscribe("putCatalog", function() {
      (function(t) {
        if (t.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing.");
        t.internal.write("/AcroForm " + t.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
      })(n);
    }), n.internal.events.subscribe("postPutPages", function(t) {
      (function(i, r) {
        var l = !i;
        for (var c in i || (r.internal.newObjectDeferredBegin(r.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), r.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), i = i || r.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (i.hasOwnProperty(c)) {
          var a = i[c], g = [], y = a.Rect;
          if (a.Rect && (a.Rect = qV(a.Rect, r)), r.internal.newObjectDeferredBegin(a.objId, !0), a.DA = Nn.createDefaultAppearanceStream(a), or(a) === "object" && typeof a.getKeyValueListForStream == "function" && (g = a.getKeyValueListForStream()), a.Rect = y, a.hasAppearanceStream && !a.appearanceStreamContent) {
            var A = HV(a);
            g.push({ key: "AP", value: "<</N " + A + ">>" }), r.internal.acroformPlugin.xForms.push(A);
          }
          if (a.appearanceStreamContent) {
            var C = "";
            for (var I in a.appearanceStreamContent) if (a.appearanceStreamContent.hasOwnProperty(I)) {
              var S = a.appearanceStreamContent[I];
              if (C += "/" + I + " ", C += "<<", Object.keys(S).length >= 1 || Array.isArray(S)) {
                for (var c in S) if (S.hasOwnProperty(c)) {
                  var F = S[c];
                  typeof F == "function" && (F = F.call(r, a)), C += "/" + c + " " + F + " ", r.internal.acroformPlugin.xForms.indexOf(F) >= 0 || r.internal.acroformPlugin.xForms.push(F);
                }
              } else typeof (F = S) == "function" && (F = F.call(r, a)), C += "/" + c + " " + F, r.internal.acroformPlugin.xForms.indexOf(F) >= 0 || r.internal.acroformPlugin.xForms.push(F);
              C += ">>";
            }
            g.push({ key: "AP", value: `<<
` + C + ">>" });
          }
          r.internal.putStream({ additionalKeyValues: g, objectId: a.objId }), r.internal.out("endobj");
        }
        l && $V(r.internal.acroformPlugin.xForms, r);
      })(t, n);
    }), n.internal.acroformPlugin.isInitialized = !0;
  }
}, y3 = rs.__acroform__.arrayToPdfArray = function(n, e, t) {
  var i = function(c) {
    return c;
  };
  if (Array.isArray(n)) {
    for (var r = "[", l = 0; l < n.length; l++) switch (l !== 0 && (r += " "), or(n[l])) {
      case "boolean":
      case "number":
      case "object":
        r += n[l].toString();
        break;
      case "string":
        n[l].substr(0, 1) !== "/" ? (e !== void 0 && t && (i = t.internal.getEncryptor(e)), r += "(" + od(i(n[l].toString())) + ")") : r += n[l].toString();
    }
    return r += "]";
  }
  throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
}, my = function(n, e, t) {
  var i = function(r) {
    return r;
  };
  return e !== void 0 && t && (i = t.internal.getEncryptor(e)), (n = n || "").toString(), n = "(" + od(i(n)) + ")";
}, eu = function() {
  this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
    if (this._objId === void 0) {
      if (this.scope === void 0) return;
      this._objId = this.scope.internal.newObjectDeferred();
    }
    return this._objId;
  }, set: function(n) {
    this._objId = n;
  } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 });
};
eu.prototype.toString = function() {
  return this.objId + " 0 R";
}, eu.prototype.putStream = function() {
  var n = this.getKeyValueListForStream();
  this.scope.internal.putStream({ data: this.stream, additionalKeyValues: n, objectId: this.objId }), this.scope.internal.out("endobj");
}, eu.prototype.getKeyValueListForStream = function() {
  var n = [], e = Object.getOwnPropertyNames(this).filter(function(l) {
    return l != "content" && l != "appearanceStreamContent" && l != "scope" && l != "objId" && l.substring(0, 1) != "_";
  });
  for (var t in e) if (Object.getOwnPropertyDescriptor(this, e[t]).configurable === !1) {
    var i = e[t], r = this[i];
    r && (Array.isArray(r) ? n.push({ key: i, value: y3(r, this.objId, this.scope) }) : r instanceof eu ? (r.scope = this.scope, n.push({ key: i, value: r.objId + " 0 R" })) : typeof r != "function" && n.push({ key: i, value: r }));
  }
  return n;
};
var b3 = function() {
  eu.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 });
  var n, e = [];
  Object.defineProperty(this, "BBox", { configurable: !1, get: function() {
    return e;
  }, set: function(t) {
    e = t;
  } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function(t) {
    n = t.trim();
  }, get: function() {
    return n || null;
  } });
};
Pa(b3, eu);
var v3 = function() {
  eu.call(this);
  var n, e = [];
  Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function() {
    return e.length > 0 ? e : void 0;
  } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function() {
    return e;
  } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function() {
    if (n) {
      var t = function(i) {
        return i;
      };
      return this.scope && (t = this.scope.internal.getEncryptor(this.objId)), "(" + od(t(n)) + ")";
    }
  }, set: function(t) {
    n = t;
  } });
};
Pa(v3, eu);
var wc = function n() {
  eu.call(this);
  var e = 4;
  Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function() {
    return e;
  }, set: function(W) {
    if (isNaN(W)) throw new Error('Invalid value "' + W + '" for attribute F supplied.');
    e = W;
  } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(e, 3);
  }, set: function(W) {
    W ? this.F = bs(e, 3) : this.F = vs(e, 3);
  } });
  var t = 0;
  Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(W) {
    if (isNaN(W)) throw new Error('Invalid value "' + W + '" for attribute Ff supplied.');
    t = W;
  } });
  var i = [];
  Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function() {
    if (i.length !== 0) return i;
  }, set: function(W) {
    i = W !== void 0 ? W : [];
  } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[0]) ? 0 : i[0];
  }, set: function(W) {
    i[0] = W;
  } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[1]) ? 0 : i[1];
  }, set: function(W) {
    i[1] = W;
  } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[2]) ? 0 : i[2];
  }, set: function(W) {
    i[2] = W;
  } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function() {
    return !i || isNaN(i[3]) ? 0 : i[3];
  }, set: function(W) {
    i[3] = W;
  } });
  var r = "";
  Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function() {
    return r;
  }, set: function(W) {
    switch (W) {
      case "/Btn":
      case "/Tx":
      case "/Ch":
      case "/Sig":
        r = W;
        break;
      default:
        throw new Error('Invalid value "' + W + '" for attribute FT supplied.');
    }
  } });
  var l = null;
  Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function() {
    if (!l || l.length < 1) {
      if (this instanceof Vm) return;
      l = "FieldObject" + n.FieldNum++;
    }
    var W = function(X) {
      return X;
    };
    return this.scope && (W = this.scope.internal.getEncryptor(this.objId)), "(" + od(W(l)) + ")";
  }, set: function(W) {
    l = W.toString();
  } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function() {
    return l;
  }, set: function(W) {
    l = W;
  } });
  var c = "helvetica";
  Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function() {
    return c;
  }, set: function(W) {
    c = W;
  } });
  var a = "normal";
  Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function() {
    return a;
  }, set: function(W) {
    a = W;
  } });
  var g = 0;
  Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function() {
    return g;
  }, set: function(W) {
    g = W;
  } });
  var y = void 0;
  Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function() {
    return y === void 0 ? 50 / rv : y;
  }, set: function(W) {
    y = W;
  } });
  var A = "black";
  Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function() {
    return A;
  }, set: function(W) {
    A = W;
  } });
  var C = "/F1 0 Tf 0 g";
  Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function() {
    if (!(!C || this instanceof Vm || this instanceof Xh)) return my(C, this.objId, this.scope);
  }, set: function(W) {
    W = W.toString(), C = W;
  } });
  var I = null;
  Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function() {
    if (I) return this instanceof lo ? I : my(I, this.objId, this.scope);
  }, set: function(W) {
    W = W.toString(), I = this instanceof lo ? W : W.substr(0, 1) === "(" ? Fd(W.substr(1, W.length - 2)) : Fd(W);
  } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof lo ? Fd(I.substr(1, I.length - 1)) : I;
  }, set: function(W) {
    W = W.toString(), I = this instanceof lo ? "/" + W : W;
  } });
  var S = null;
  Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function() {
    if (S) return S;
  }, set: function(W) {
    this.V = W;
  } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function() {
    if (S) return this instanceof lo ? S : my(S, this.objId, this.scope);
  }, set: function(W) {
    W = W.toString(), S = this instanceof lo ? W : W.substr(0, 1) === "(" ? Fd(W.substr(1, W.length - 2)) : Fd(W);
  } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function() {
    return this instanceof lo ? Fd(S.substr(1, S.length - 1)) : S;
  }, set: function(W) {
    W = W.toString(), S = this instanceof lo ? "/" + W : W;
  } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function() {
    return this.Rect;
  } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Annot" : null;
  } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function() {
    return this.hasAnnotation ? "/Widget" : null;
  } });
  var F, U = !1;
  Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return U;
  }, set: function(W) {
    W = !!W, U = W;
  } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function() {
    if (F) return F;
  }, set: function(W) {
    F = W;
  } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 1);
  }, set: function(W) {
    W ? this.Ff = bs(this.Ff, 1) : this.Ff = vs(this.Ff, 1);
  } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 2);
  }, set: function(W) {
    W ? this.Ff = bs(this.Ff, 2) : this.Ff = vs(this.Ff, 2);
  } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 3);
  }, set: function(W) {
    W ? this.Ff = bs(this.Ff, 3) : this.Ff = vs(this.Ff, 3);
  } });
  var V = null;
  Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function() {
    if (V !== null) return V;
  }, set: function(W) {
    if ([0, 1, 2].indexOf(W) === -1) throw new Error('Invalid value "' + W + '" for attribute Q supplied.');
    V = W;
  } }), Object.defineProperty(this, "textAlign", { get: function() {
    var W;
    switch (V) {
      case 0:
      default:
        W = "left";
        break;
      case 1:
        W = "center";
        break;
      case 2:
        W = "right";
    }
    return W;
  }, configurable: !0, enumerable: !0, set: function(W) {
    switch (W) {
      case "right":
      case 2:
        V = 2;
        break;
      case "center":
      case 1:
        V = 1;
        break;
      case "left":
      case 0:
      default:
        V = 0;
    }
  } });
};
Pa(wc, eu);
var Kd = function() {
  wc.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
  var n = 0;
  Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } });
  var e = [];
  Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function() {
    return y3(e, this.objId, this.scope);
  }, set: function(t) {
    var i, r;
    r = [], typeof (i = t) == "string" && (r = function(l, c, a) {
      a || (a = 1);
      for (var g, y = []; g = c.exec(l); ) y.push(g[a]);
      return y;
    }(i, /\((.*?)\)/g)), e = r;
  } }), this.getOptions = function() {
    return e;
  }, this.setOptions = function(t) {
    e = t, this.sort && e.sort();
  }, this.addOption = function(t) {
    t = (t = t || "").toString(), e.push(t), this.sort && e.sort();
  }, this.removeOption = function(t, i) {
    for (i = i || !1, t = (t = t || "").toString(); e.indexOf(t) !== -1 && (e.splice(e.indexOf(t), 1), i !== !1); ) ;
  }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 18);
  }, set: function(t) {
    t ? this.Ff = bs(this.Ff, 18) : this.Ff = vs(this.Ff, 18);
  } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 19);
  }, set: function(t) {
    this.combo === !0 && (t ? this.Ff = bs(this.Ff, 19) : this.Ff = vs(this.Ff, 19));
  } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 20);
  }, set: function(t) {
    t ? (this.Ff = bs(this.Ff, 20), e.sort()) : this.Ff = vs(this.Ff, 20);
  } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 22);
  }, set: function(t) {
    t ? this.Ff = bs(this.Ff, 22) : this.Ff = vs(this.Ff, 22);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 23);
  }, set: function(t) {
    t ? this.Ff = bs(this.Ff, 23) : this.Ff = vs(this.Ff, 23);
  } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 27);
  }, set: function(t) {
    t ? this.Ff = bs(this.Ff, 27) : this.Ff = vs(this.Ff, 27);
  } }), this.hasAppearanceStream = !1;
};
Pa(Kd, wc);
var Qd = function() {
  Kd.call(this), this.fontName = "helvetica", this.combo = !1;
};
Pa(Qd, Kd);
var ef = function() {
  Qd.call(this), this.combo = !0;
};
Pa(ef, Qd);
var fm = function() {
  ef.call(this), this.edit = !0;
};
Pa(fm, ef);
var lo = function() {
  wc.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 15);
  }, set: function(t) {
    t ? this.Ff = bs(this.Ff, 15) : this.Ff = vs(this.Ff, 15);
  } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 16);
  }, set: function(t) {
    t ? this.Ff = bs(this.Ff, 16) : this.Ff = vs(this.Ff, 16);
  } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 17);
  }, set: function(t) {
    t ? this.Ff = bs(this.Ff, 17) : this.Ff = vs(this.Ff, 17);
  } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 26);
  }, set: function(t) {
    t ? this.Ff = bs(this.Ff, 26) : this.Ff = vs(this.Ff, 26);
  } });
  var n, e = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var t = function(l) {
      return l;
    };
    if (this.scope && (t = this.scope.internal.getEncryptor(this.objId)), Object.keys(e).length !== 0) {
      var i, r = [];
      for (i in r.push("<<"), e) r.push("/" + i + " (" + od(t(e[i])) + ")");
      return r.push(">>"), r.join(`
`);
    }
  }, set: function(t) {
    or(t) === "object" && (e = t);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return e.CA || "";
  }, set: function(t) {
    typeof t == "string" && (e.CA = t);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(t) {
    n = t;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return n.substr(1, n.length - 1);
  }, set: function(t) {
    n = "/" + t;
  } });
};
Pa(lo, wc);
var pm = function() {
  lo.call(this), this.pushButton = !0;
};
Pa(pm, lo);
var tf = function() {
  lo.call(this), this.radio = !0, this.pushButton = !1;
  var n = [];
  Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e !== void 0 ? e : [];
  } });
};
Pa(tf, lo);
var Vm = function() {
  var n, e;
  wc.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function() {
    return n;
  }, set: function(r) {
    n = r;
  } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function() {
    return e;
  }, set: function(r) {
    e = r;
  } });
  var t, i = {};
  Object.defineProperty(this, "MK", { enumerable: !1, configurable: !1, get: function() {
    var r = function(a) {
      return a;
    };
    this.scope && (r = this.scope.internal.getEncryptor(this.objId));
    var l, c = [];
    for (l in c.push("<<"), i) c.push("/" + l + " (" + od(r(i[l])) + ")");
    return c.push(">>"), c.join(`
`);
  }, set: function(r) {
    or(r) === "object" && (i = r);
  } }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function() {
    return i.CA || "";
  }, set: function(r) {
    typeof r == "string" && (i.CA = r);
  } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function() {
    return t;
  }, set: function(r) {
    t = r;
  } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function() {
    return t.substr(1, t.length - 1);
  }, set: function(r) {
    t = "/" + r;
  } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = Nn.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
};
Pa(Vm, wc), tf.prototype.setAppearance = function(n) {
  if (!("createAppearanceStream" in n) || !("getCA" in n)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
  for (var e in this.Kids) if (this.Kids.hasOwnProperty(e)) {
    var t = this.Kids[e];
    t.appearanceStreamContent = n.createAppearanceStream(t.optionName), t.caption = n.getCA();
  }
}, tf.prototype.createOption = function(n) {
  var e = new Vm();
  return e.Parent = this, e.optionName = n, this.Kids.push(e), YV.call(this.scope, e), e;
};
var gm = function() {
  lo.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = Nn.CheckBox.createAppearanceStream();
};
Pa(gm, lo);
var Xh = function() {
  wc.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 13);
  }, set: function(e) {
    e ? this.Ff = bs(this.Ff, 13) : this.Ff = vs(this.Ff, 13);
  } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 21);
  }, set: function(e) {
    e ? this.Ff = bs(this.Ff, 21) : this.Ff = vs(this.Ff, 21);
  } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 23);
  }, set: function(e) {
    e ? this.Ff = bs(this.Ff, 23) : this.Ff = vs(this.Ff, 23);
  } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 24);
  }, set: function(e) {
    e ? this.Ff = bs(this.Ff, 24) : this.Ff = vs(this.Ff, 24);
  } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 25);
  }, set: function(e) {
    e ? this.Ff = bs(this.Ff, 25) : this.Ff = vs(this.Ff, 25);
  } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 26);
  }, set: function(e) {
    e ? this.Ff = bs(this.Ff, 26) : this.Ff = vs(this.Ff, 26);
  } });
  var n = null;
  Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function() {
    return n;
  }, set: function(e) {
    n = e;
  } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function() {
    return n;
  }, set: function(e) {
    Number.isInteger(e) && (n = e);
  } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function() {
    return this.V || this.DV;
  } });
};
Pa(Xh, wc);
var mm = function() {
  Xh.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function() {
    return !!ys(this.Ff, 14);
  }, set: function(n) {
    n ? this.Ff = bs(this.Ff, 14) : this.Ff = vs(this.Ff, 14);
  } }), this.password = !0;
};
Pa(mm, Xh);
var Nn = { CheckBox: { createAppearanceStream: function() {
  return { N: { On: Nn.CheckBox.YesNormal }, D: { On: Nn.CheckBox.YesPushDown, Off: Nn.CheckBox.OffPushDown } };
}, YesPushDown: function(n) {
  var e = $c(n);
  e.scope = n.scope;
  var t = [], i = n.scope.internal.getFont(n.fontName, n.fontStyle).id, r = n.scope.__private__.encodeColorString(n.color), l = I1(n, n.caption);
  return t.push("0.749023 g"), t.push("0 0 " + di(Nn.internal.getWidth(n)) + " " + di(Nn.internal.getHeight(n)) + " re"), t.push("f"), t.push("BMC"), t.push("q"), t.push("0 0 1 rg"), t.push("/" + i + " " + di(l.fontSize) + " Tf " + r), t.push("BT"), t.push(l.text), t.push("ET"), t.push("Q"), t.push("EMC"), e.stream = t.join(`
`), e;
}, YesNormal: function(n) {
  var e = $c(n);
  e.scope = n.scope;
  var t = n.scope.internal.getFont(n.fontName, n.fontStyle).id, i = n.scope.__private__.encodeColorString(n.color), r = [], l = Nn.internal.getHeight(n), c = Nn.internal.getWidth(n), a = I1(n, n.caption);
  return r.push("1 g"), r.push("0 0 " + di(c) + " " + di(l) + " re"), r.push("f"), r.push("q"), r.push("0 0 1 rg"), r.push("0 0 " + di(c - 1) + " " + di(l - 1) + " re"), r.push("W"), r.push("n"), r.push("0 g"), r.push("BT"), r.push("/" + t + " " + di(a.fontSize) + " Tf " + i), r.push(a.text), r.push("ET"), r.push("Q"), e.stream = r.join(`
`), e;
}, OffPushDown: function(n) {
  var e = $c(n);
  e.scope = n.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + di(Nn.internal.getWidth(n)) + " " + di(Nn.internal.getHeight(n)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} }, RadioButton: { Circle: { createAppearanceStream: function(n) {
  var e = { D: { Off: Nn.RadioButton.Circle.OffPushDown }, N: {} };
  return e.N[n] = Nn.RadioButton.Circle.YesNormal, e.D[n] = Nn.RadioButton.Circle.YesPushDown, e;
}, getCA: function() {
  return "l";
}, YesNormal: function(n) {
  var e = $c(n);
  e.scope = n.scope;
  var t = [], i = Nn.internal.getWidth(n) <= Nn.internal.getHeight(n) ? Nn.internal.getWidth(n) / 4 : Nn.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Nn.internal.Bezier_C, l = Number((i * r).toFixed(5));
  return t.push("q"), t.push("1 0 0 1 " + ah(Nn.internal.getWidth(n) / 2) + " " + ah(Nn.internal.getHeight(n) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + l + " " + l + " " + i + " 0 " + i + " c"), t.push("-" + l + " " + i + " -" + i + " " + l + " -" + i + " 0 c"), t.push("-" + i + " -" + l + " -" + l + " -" + i + " 0 -" + i + " c"), t.push(l + " -" + i + " " + i + " -" + l + " " + i + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(n) {
  var e = $c(n);
  e.scope = n.scope;
  var t = [], i = Nn.internal.getWidth(n) <= Nn.internal.getHeight(n) ? Nn.internal.getWidth(n) / 4 : Nn.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), l = Number((r * Nn.internal.Bezier_C).toFixed(5)), c = Number((i * Nn.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + ah(Nn.internal.getWidth(n) / 2) + " " + ah(Nn.internal.getHeight(n) / 2) + " cm"), t.push(r + " 0 m"), t.push(r + " " + l + " " + l + " " + r + " 0 " + r + " c"), t.push("-" + l + " " + r + " -" + r + " " + l + " -" + r + " 0 c"), t.push("-" + r + " -" + l + " -" + l + " -" + r + " 0 -" + r + " c"), t.push(l + " -" + r + " " + r + " -" + l + " " + r + " 0 c"), t.push("f"), t.push("Q"), t.push("0 g"), t.push("q"), t.push("1 0 0 1 " + ah(Nn.internal.getWidth(n) / 2) + " " + ah(Nn.internal.getHeight(n) / 2) + " cm"), t.push(i + " 0 m"), t.push(i + " " + c + " " + c + " " + i + " 0 " + i + " c"), t.push("-" + c + " " + i + " -" + i + " " + c + " -" + i + " 0 c"), t.push("-" + i + " -" + c + " -" + c + " -" + i + " 0 -" + i + " c"), t.push(c + " -" + i + " " + i + " -" + c + " " + i + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
}, OffPushDown: function(n) {
  var e = $c(n);
  e.scope = n.scope;
  var t = [], i = Nn.internal.getWidth(n) <= Nn.internal.getHeight(n) ? Nn.internal.getWidth(n) / 4 : Nn.internal.getHeight(n) / 4;
  i = Number((0.9 * i).toFixed(5));
  var r = Number((2 * i).toFixed(5)), l = Number((r * Nn.internal.Bezier_C).toFixed(5));
  return t.push("0.749023 g"), t.push("q"), t.push("1 0 0 1 " + ah(Nn.internal.getWidth(n) / 2) + " " + ah(Nn.internal.getHeight(n) / 2) + " cm"), t.push(r + " 0 m"), t.push(r + " " + l + " " + l + " " + r + " 0 " + r + " c"), t.push("-" + l + " " + r + " -" + r + " " + l + " -" + r + " 0 c"), t.push("-" + r + " -" + l + " -" + l + " -" + r + " 0 -" + r + " c"), t.push(l + " -" + r + " " + r + " -" + l + " " + r + " 0 c"), t.push("f"), t.push("Q"), e.stream = t.join(`
`), e;
} }, Cross: { createAppearanceStream: function(n) {
  var e = { D: { Off: Nn.RadioButton.Cross.OffPushDown }, N: {} };
  return e.N[n] = Nn.RadioButton.Cross.YesNormal, e.D[n] = Nn.RadioButton.Cross.YesPushDown, e;
}, getCA: function() {
  return "8";
}, YesNormal: function(n) {
  var e = $c(n);
  e.scope = n.scope;
  var t = [], i = Nn.internal.calculateCross(n);
  return t.push("q"), t.push("1 1 " + di(Nn.internal.getWidth(n) - 2) + " " + di(Nn.internal.getHeight(n) - 2) + " re"), t.push("W"), t.push("n"), t.push(di(i.x1.x) + " " + di(i.x1.y) + " m"), t.push(di(i.x2.x) + " " + di(i.x2.y) + " l"), t.push(di(i.x4.x) + " " + di(i.x4.y) + " m"), t.push(di(i.x3.x) + " " + di(i.x3.y) + " l"), t.push("s"), t.push("Q"), e.stream = t.join(`
`), e;
}, YesPushDown: function(n) {
  var e = $c(n);
  e.scope = n.scope;
  var t = Nn.internal.calculateCross(n), i = [];
  return i.push("0.749023 g"), i.push("0 0 " + di(Nn.internal.getWidth(n)) + " " + di(Nn.internal.getHeight(n)) + " re"), i.push("f"), i.push("q"), i.push("1 1 " + di(Nn.internal.getWidth(n) - 2) + " " + di(Nn.internal.getHeight(n) - 2) + " re"), i.push("W"), i.push("n"), i.push(di(t.x1.x) + " " + di(t.x1.y) + " m"), i.push(di(t.x2.x) + " " + di(t.x2.y) + " l"), i.push(di(t.x4.x) + " " + di(t.x4.y) + " m"), i.push(di(t.x3.x) + " " + di(t.x3.y) + " l"), i.push("s"), i.push("Q"), e.stream = i.join(`
`), e;
}, OffPushDown: function(n) {
  var e = $c(n);
  e.scope = n.scope;
  var t = [];
  return t.push("0.749023 g"), t.push("0 0 " + di(Nn.internal.getWidth(n)) + " " + di(Nn.internal.getHeight(n)) + " re"), t.push("f"), e.stream = t.join(`
`), e;
} } }, createDefaultAppearanceStream: function(n) {
  var e = n.scope.internal.getFont(n.fontName, n.fontStyle).id, t = n.scope.__private__.encodeColorString(n.color);
  return "/" + e + " " + n.fontSize + " Tf " + t;
} };
Nn.internal = { Bezier_C: 0.551915024494, calculateCross: function(n) {
  var e = Nn.internal.getWidth(n), t = Nn.internal.getHeight(n), i = Math.min(e, t);
  return { x1: { x: (e - i) / 2, y: (t - i) / 2 + i }, x2: { x: (e - i) / 2 + i, y: (t - i) / 2 }, x3: { x: (e - i) / 2, y: (t - i) / 2 }, x4: { x: (e - i) / 2 + i, y: (t - i) / 2 + i } };
} }, Nn.internal.getWidth = function(n) {
  var e = 0;
  return or(n) === "object" && (e = x5(n.Rect[2])), e;
}, Nn.internal.getHeight = function(n) {
  var e = 0;
  return or(n) === "object" && (e = x5(n.Rect[3])), e;
};
var YV = rs.addField = function(n) {
  if (XV(this, n), !(n instanceof wc)) throw new Error("Invalid argument passed to jsPDF.addField.");
  var e;
  return (e = n).scope.internal.acroformPlugin.printedOut && (e.scope.internal.acroformPlugin.printedOut = !1, e.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e), n.page = n.scope.internal.getCurrentPageInfo().pageNumber, this;
};
rs.AcroFormChoiceField = Kd, rs.AcroFormListBox = Qd, rs.AcroFormComboBox = ef, rs.AcroFormEditBox = fm, rs.AcroFormButton = lo, rs.AcroFormPushButton = pm, rs.AcroFormRadioButton = tf, rs.AcroFormCheckBox = gm, rs.AcroFormTextField = Xh, rs.AcroFormPasswordField = mm, rs.AcroFormAppearance = Nn, rs.AcroForm = { ChoiceField: Kd, ListBox: Qd, ComboBox: ef, EditBox: fm, Button: lo, PushButton: pm, RadioButton: tf, CheckBox: gm, TextField: Xh, PasswordField: mm, Appearance: Nn }, ti.AcroForm = { ChoiceField: Kd, ListBox: Qd, ComboBox: ef, EditBox: fm, Button: lo, PushButton: pm, RadioButton: tf, CheckBox: gm, TextField: Xh, PasswordField: mm, Appearance: Nn };
function x3(n) {
  return n.reduce(function(e, t, i) {
    return e[t] = i, e;
  }, {});
}
(function(n) {
  n.__addimage__ = {};
  var e = "UNKNOWN", t = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, i = n.__addimage__.getImageFileTypeByImageData = function(pe, _e) {
    var De, Me, St, dt, Pt, gt = e;
    if ((_e = _e || e) === "RGBA" || pe.data !== void 0 && pe.data instanceof Uint8ClampedArray && "height" in pe && "width" in pe) return "RGBA";
    if (Ae(pe)) for (Pt in t) for (St = t[Pt], De = 0; De < St.length; De += 1) {
      for (dt = !0, Me = 0; Me < St[De].length; Me += 1) if (St[De][Me] !== void 0 && St[De][Me] !== pe[Me]) {
        dt = !1;
        break;
      }
      if (dt === !0) {
        gt = Pt;
        break;
      }
    }
    else for (Pt in t) for (St = t[Pt], De = 0; De < St.length; De += 1) {
      for (dt = !0, Me = 0; Me < St[De].length; Me += 1) if (St[De][Me] !== void 0 && St[De][Me] !== pe.charCodeAt(Me)) {
        dt = !1;
        break;
      }
      if (dt === !0) {
        gt = Pt;
        break;
      }
    }
    return gt === e && _e !== e && (gt = _e), gt;
  }, r = function pe(_e) {
    for (var De = this.internal.write, Me = this.internal.putStream, St = (0, this.internal.getFilters)(); St.indexOf("FlateEncode") !== -1; ) St.splice(St.indexOf("FlateEncode"), 1);
    _e.objectId = this.internal.newObject();
    var dt = [];
    if (dt.push({ key: "Type", value: "/XObject" }), dt.push({ key: "Subtype", value: "/Image" }), dt.push({ key: "Width", value: _e.width }), dt.push({ key: "Height", value: _e.height }), _e.colorSpace === V.INDEXED ? dt.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (_e.palette.length / 3 - 1) + " " + ("sMask" in _e && _e.sMask !== void 0 ? _e.objectId + 2 : _e.objectId + 1) + " 0 R]" }) : (dt.push({ key: "ColorSpace", value: "/" + _e.colorSpace }), _e.colorSpace === V.DEVICE_CMYK && dt.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), dt.push({ key: "BitsPerComponent", value: _e.bitsPerComponent }), "decodeParameters" in _e && _e.decodeParameters !== void 0 && dt.push({ key: "DecodeParms", value: "<<" + _e.decodeParameters + ">>" }), "transparency" in _e && Array.isArray(_e.transparency)) {
      for (var Pt = "", gt = 0, Rt = _e.transparency.length; gt < Rt; gt++) Pt += _e.transparency[gt] + " " + _e.transparency[gt] + " ";
      dt.push({ key: "Mask", value: "[" + Pt + "]" });
    }
    _e.sMask !== void 0 && dt.push({ key: "SMask", value: _e.objectId + 1 + " 0 R" });
    var Ft = _e.filter !== void 0 ? ["/" + _e.filter] : void 0;
    if (Me({ data: _e.data, additionalKeyValues: dt, alreadyAppliedFilters: Ft, objectId: _e.objectId }), De("endobj"), "sMask" in _e && _e.sMask !== void 0) {
      var mn = "/Predictor " + _e.predictor + " /Colors 1 /BitsPerComponent " + _e.bitsPerComponent + " /Columns " + _e.width, oe = { width: _e.width, height: _e.height, colorSpace: "DeviceGray", bitsPerComponent: _e.bitsPerComponent, decodeParameters: mn, data: _e.sMask };
      "filter" in _e && (oe.filter = _e.filter), pe.call(this, oe);
    }
    if (_e.colorSpace === V.INDEXED) {
      var Re = this.internal.newObject();
      Me({ data: me(new Uint8Array(_e.palette)), objectId: Re }), De("endobj");
    }
  }, l = function() {
    var pe = this.internal.collections.addImage_images;
    for (var _e in pe) r.call(this, pe[_e]);
  }, c = function() {
    var pe, _e = this.internal.collections.addImage_images, De = this.internal.write;
    for (var Me in _e) De("/I" + (pe = _e[Me]).index, pe.objectId, "0", "R");
  }, a = function() {
    this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", l), this.internal.events.subscribe("putXobjectDict", c));
  }, g = function() {
    var pe = this.internal.collections.addImage_images;
    return a.call(this), pe;
  }, y = function() {
    return Object.keys(this.internal.collections.addImage_images).length;
  }, A = function(pe) {
    return typeof n["process" + pe.toUpperCase()] == "function";
  }, C = function(pe) {
    return or(pe) === "object" && pe.nodeType === 1;
  }, I = function(pe, _e) {
    if (pe.nodeName === "IMG" && pe.hasAttribute("src")) {
      var De = "" + pe.getAttribute("src");
      if (De.indexOf("data:image/") === 0) return Ap(unescape(De).split("base64,").pop());
      var Me = n.loadFile(De, !0);
      if (Me !== void 0) return Me;
    }
    if (pe.nodeName === "CANVAS") {
      if (pe.width === 0 || pe.height === 0) throw new Error("Given canvas must have data. Canvas width: " + pe.width + ", height: " + pe.height);
      var St;
      switch (_e) {
        case "PNG":
          St = "image/png";
          break;
        case "WEBP":
          St = "image/webp";
          break;
        case "JPEG":
        case "JPG":
        default:
          St = "image/jpeg";
      }
      return Ap(pe.toDataURL(St, 1).split("base64,").pop());
    }
  }, S = function(pe) {
    var _e = this.internal.collections.addImage_images;
    if (_e) {
      for (var De in _e) if (pe === _e[De].alias) return _e[De];
    }
  }, F = function(pe, _e, De) {
    return pe || _e || (pe = -96, _e = -96), pe < 0 && (pe = -1 * De.width * 72 / pe / this.internal.scaleFactor), _e < 0 && (_e = -1 * De.height * 72 / _e / this.internal.scaleFactor), pe === 0 && (pe = _e * De.width / De.height), _e === 0 && (_e = pe * De.height / De.width), [pe, _e];
  }, U = function(pe, _e, De, Me, St, dt) {
    var Pt = F.call(this, De, Me, St), gt = this.internal.getCoordinateString, Rt = this.internal.getVerticalCoordinateString, Ft = g.call(this);
    if (De = Pt[0], Me = Pt[1], Ft[St.index] = St, dt) {
      dt *= Math.PI / 180;
      var mn = Math.cos(dt), oe = Math.sin(dt), Re = function(Xe) {
        return Xe.toFixed(4);
      }, ze = [Re(mn), Re(oe), Re(-1 * oe), Re(mn), 0, 0, "cm"];
    }
    this.internal.write("q"), dt ? (this.internal.write([1, "0", "0", 1, gt(pe), Rt(_e + Me), "cm"].join(" ")), this.internal.write(ze.join(" ")), this.internal.write([gt(De), "0", "0", gt(Me), "0", "0", "cm"].join(" "))) : this.internal.write([gt(De), "0", "0", gt(Me), gt(pe), Rt(_e + Me), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + St.index + " Do"), this.internal.write("Q");
  }, V = n.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
  n.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
  var W = n.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, X = n.__addimage__.sHashCode = function(pe) {
    var _e, De, Me = 0;
    if (typeof pe == "string") for (De = pe.length, _e = 0; _e < De; _e++) Me = (Me << 5) - Me + pe.charCodeAt(_e), Me |= 0;
    else if (Ae(pe)) for (De = pe.byteLength / 2, _e = 0; _e < De; _e++) Me = (Me << 5) - Me + pe[_e], Me |= 0;
    return Me;
  }, de = n.__addimage__.validateStringAsBase64 = function(pe) {
    (pe = pe || "").toString().trim();
    var _e = !0;
    return pe.length === 0 && (_e = !1), pe.length % 4 != 0 && (_e = !1), /^[A-Za-z0-9+/]+$/.test(pe.substr(0, pe.length - 2)) === !1 && (_e = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(pe.substr(-2)) === !1 && (_e = !1), _e;
  }, ie = n.__addimage__.extractImageFromDataUrl = function(pe) {
    var _e = (pe = pe || "").split("base64,"), De = null;
    if (_e.length === 2) {
      var Me = /^data:(\w*\/\w*);*(charset=(?!charset=)[\w=-]*)*;*$/.exec(_e[0]);
      Array.isArray(Me) && (De = { mimeType: Me[1], charset: Me[2], data: _e[1] });
    }
    return De;
  }, fe = n.__addimage__.supportsArrayBuffer = function() {
    return typeof ArrayBuffer < "u" && typeof Uint8Array < "u";
  };
  n.__addimage__.isArrayBuffer = function(pe) {
    return fe() && pe instanceof ArrayBuffer;
  };
  var Ae = n.__addimage__.isArrayBufferView = function(pe) {
    return fe() && typeof Uint32Array < "u" && (pe instanceof Int8Array || pe instanceof Uint8Array || typeof Uint8ClampedArray < "u" && pe instanceof Uint8ClampedArray || pe instanceof Int16Array || pe instanceof Uint16Array || pe instanceof Int32Array || pe instanceof Uint32Array || pe instanceof Float32Array || pe instanceof Float64Array);
  }, Te = n.__addimage__.binaryStringToUint8Array = function(pe) {
    for (var _e = pe.length, De = new Uint8Array(_e), Me = 0; Me < _e; Me++) De[Me] = pe.charCodeAt(Me);
    return De;
  }, me = n.__addimage__.arrayBufferToBinaryString = function(pe) {
    for (var _e = "", De = Ae(pe) ? pe : new Uint8Array(pe), Me = 0; Me < De.length; Me += 8192) _e += String.fromCharCode.apply(null, De.subarray(Me, Me + 8192));
    return _e;
  };
  n.addImage = function() {
    var pe, _e, De, Me, St, dt, Pt, gt, Rt;
    if (typeof arguments[1] == "number" ? (_e = e, De = arguments[1], Me = arguments[2], St = arguments[3], dt = arguments[4], Pt = arguments[5], gt = arguments[6], Rt = arguments[7]) : (_e = arguments[1], De = arguments[2], Me = arguments[3], St = arguments[4], dt = arguments[5], Pt = arguments[6], gt = arguments[7], Rt = arguments[8]), or(pe = arguments[0]) === "object" && !C(pe) && "imageData" in pe) {
      var Ft = pe;
      pe = Ft.imageData, _e = Ft.format || _e || e, De = Ft.x || De || 0, Me = Ft.y || Me || 0, St = Ft.w || Ft.width || St, dt = Ft.h || Ft.height || dt, Pt = Ft.alias || Pt, gt = Ft.compression || gt, Rt = Ft.rotation || Ft.angle || Rt;
    }
    var mn = this.internal.getFilters();
    if (gt === void 0 && mn.indexOf("FlateEncode") !== -1 && (gt = "SLOW"), isNaN(De) || isNaN(Me)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
    a.call(this);
    var oe = Ge.call(this, pe, _e, Pt, gt);
    return U.call(this, De, Me, St, dt, oe, Rt), this;
  };
  var Ge = function(pe, _e, De, Me) {
    var St, dt, Pt;
    if (typeof pe == "string" && i(pe) === e) {
      pe = unescape(pe);
      var gt = ke(pe, !1);
      (gt !== "" || (gt = n.loadFile(pe, !0)) !== void 0) && (pe = gt);
    }
    if (C(pe) && (pe = I(pe, _e)), _e = i(pe, _e), !A(_e)) throw new Error("addImage does not support files of type '" + _e + "', please ensure that a plugin for '" + _e + "' support is added.");
    if (((Pt = De) == null || Pt.length === 0) && (De = function(Rt) {
      return typeof Rt == "string" || Ae(Rt) ? X(Rt) : Ae(Rt.data) ? X(Rt.data) : null;
    }(pe)), (St = S.call(this, De)) || (fe() && (pe instanceof Uint8Array || _e === "RGBA" || (dt = pe, pe = Te(pe))), St = this["process" + _e.toUpperCase()](pe, y.call(this), De, function(Rt) {
      return Rt && typeof Rt == "string" && (Rt = Rt.toUpperCase()), Rt in n.image_compression ? Rt : W.NONE;
    }(Me), dt)), !St) throw new Error("An unknown error occurred whilst processing the image.");
    return St;
  }, ke = n.__addimage__.convertBase64ToBinaryString = function(pe, _e) {
    var De;
    _e = typeof _e != "boolean" || _e;
    var Me, St = "";
    if (typeof pe == "string") {
      Me = (De = ie(pe)) !== null ? De.data : pe;
      try {
        St = Ap(Me);
      } catch (dt) {
        if (_e) throw de(Me) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + dt.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
      }
    }
    return St;
  };
  n.getImageProperties = function(pe) {
    var _e, De, Me = "";
    if (C(pe) && (pe = I(pe)), typeof pe == "string" && i(pe) === e && ((Me = ke(pe, !1)) === "" && (Me = n.loadFile(pe) || ""), pe = Me), De = i(pe), !A(De)) throw new Error("addImage does not support files of type '" + De + "', please ensure that a plugin for '" + De + "' support is added.");
    if (!fe() || pe instanceof Uint8Array || (pe = Te(pe)), !(_e = this["process" + De.toUpperCase()](pe))) throw new Error("An unknown error occurred whilst processing the image");
    return _e.fileType = De, _e;
  };
})(ti.API), /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function(t) {
    if (t !== void 0 && t != "") return !0;
  };
  ti.API.events.push(["addPage", function(t) {
    this.internal.getPageInfo(t.pageNumber).pageContext.annotations = [];
  }]), n.events.push(["putPage", function(t) {
    for (var i, r, l, c = this.internal.getCoordinateString, a = this.internal.getVerticalCoordinateString, g = this.internal.getPageInfoByObjId(t.objId), y = t.pageContext.annotations, A = !1, C = 0; C < y.length && !A; C++) switch ((i = y[C]).type) {
      case "link":
        (e(i.options.url) || e(i.options.pageNumber)) && (A = !0);
        break;
      case "reference":
      case "text":
      case "freetext":
        A = !0;
    }
    if (A != 0) {
      this.internal.write("/Annots [");
      for (var I = 0; I < y.length; I++) {
        i = y[I];
        var S = this.internal.pdfEscape, F = this.internal.getEncryptor(t.objId);
        switch (i.type) {
          case "reference":
            this.internal.write(" " + i.object.objId + " 0 R ");
            break;
          case "text":
            var U = this.internal.newAdditionalObject(), V = this.internal.newAdditionalObject(), W = this.internal.getEncryptor(U.objId), X = i.title || "Note";
            l = "<</Type /Annot /Subtype /Text " + (r = "/Rect [" + c(i.bounds.x) + " " + a(i.bounds.y + i.bounds.h) + " " + c(i.bounds.x + i.bounds.w) + " " + a(i.bounds.y) + "] ") + "/Contents (" + S(W(i.contents)) + ")", l += " /Popup " + V.objId + " 0 R", l += " /P " + g.objId + " 0 R", l += " /T (" + S(W(X)) + ") >>", U.content = l;
            var de = U.objId + " 0 R";
            l = "<</Type /Annot /Subtype /Popup " + (r = "/Rect [" + c(i.bounds.x + 30) + " " + a(i.bounds.y + i.bounds.h) + " " + c(i.bounds.x + i.bounds.w + 30) + " " + a(i.bounds.y) + "] ") + " /Parent " + de, i.open && (l += " /Open true"), l += " >>", V.content = l, this.internal.write(U.objId, "0 R", V.objId, "0 R");
            break;
          case "freetext":
            r = "/Rect [" + c(i.bounds.x) + " " + a(i.bounds.y) + " " + c(i.bounds.x + i.bounds.w) + " " + a(i.bounds.y + i.bounds.h) + "] ";
            var ie = i.color || "#000000";
            l = "<</Type /Annot /Subtype /FreeText " + r + "/Contents (" + S(F(i.contents)) + ")", l += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + ie + ")", l += " /Border [0 0 0]", l += " >>", this.internal.write(l);
            break;
          case "link":
            if (i.options.name) {
              var fe = this.annotations._nameMap[i.options.name];
              i.options.pageNumber = fe.page, i.options.top = fe.y;
            } else i.options.top || (i.options.top = 0);
            if (r = "/Rect [" + i.finalBounds.x + " " + i.finalBounds.y + " " + i.finalBounds.w + " " + i.finalBounds.h + "] ", l = "", i.options.url) l = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /A <</S /URI /URI (" + S(F(i.options.url)) + ") >>";
            else if (i.options.pageNumber) switch (l = "<</Type /Annot /Subtype /Link " + r + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(i.options.pageNumber).objId + " 0 R", i.options.magFactor = i.options.magFactor || "XYZ", i.options.magFactor) {
              case "Fit":
                l += " /Fit]";
                break;
              case "FitH":
                l += " /FitH " + i.options.top + "]";
                break;
              case "FitV":
                i.options.left = i.options.left || 0, l += " /FitV " + i.options.left + "]";
                break;
              case "XYZ":
              default:
                var Ae = a(i.options.top);
                i.options.left = i.options.left || 0, i.options.zoom === void 0 && (i.options.zoom = 0), l += " /XYZ " + i.options.left + " " + Ae + " " + i.options.zoom + "]";
            }
            l != "" && (l += " >>", this.internal.write(l));
        }
      }
      this.internal.write("]");
    }
  }]), n.createAnnotation = function(t) {
    var i = this.internal.getCurrentPageInfo();
    switch (t.type) {
      case "link":
        this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
        break;
      case "text":
      case "freetext":
        i.pageContext.annotations.push(t);
    }
  }, n.link = function(t, i, r, l, c) {
    var a = this.internal.getCurrentPageInfo(), g = this.internal.getCoordinateString, y = this.internal.getVerticalCoordinateString;
    a.pageContext.annotations.push({ finalBounds: { x: g(t), y: y(i), w: g(t + r), h: y(i + l) }, options: c, type: "link" });
  }, n.textWithLink = function(t, i, r, l) {
    var c, a, g = this.getTextWidth(t), y = this.internal.getLineHeight() / this.internal.scaleFactor;
    if (l.maxWidth !== void 0) {
      a = l.maxWidth;
      var A = this.splitTextToSize(t, a).length;
      c = Math.ceil(y * A);
    } else a = g, c = y;
    return this.text(t, i, r, l), r += 0.2 * y, l.align === "center" && (i -= g / 2), l.align === "right" && (i -= g), this.link(i, r - y, a, c, l), g;
  }, n.getTextWidth = function(t) {
    var i = this.internal.getFontSize();
    return this.getStringUnitWidth(t) * i / this.internal.scaleFactor;
  };
}(ti.API), /**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, t = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, i = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, r = [1570, 1571, 1573, 1575];
  n.__arabicParser__ = {};
  var l = n.__arabicParser__.isInArabicSubstitutionA = function(U) {
    return e[U.charCodeAt(0)] !== void 0;
  }, c = n.__arabicParser__.isArabicLetter = function(U) {
    return typeof U == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(U);
  }, a = n.__arabicParser__.isArabicEndLetter = function(U) {
    return c(U) && l(U) && e[U.charCodeAt(0)].length <= 2;
  }, g = n.__arabicParser__.isArabicAlfLetter = function(U) {
    return c(U) && r.indexOf(U.charCodeAt(0)) >= 0;
  };
  n.__arabicParser__.arabicLetterHasIsolatedForm = function(U) {
    return c(U) && l(U) && e[U.charCodeAt(0)].length >= 1;
  };
  var y = n.__arabicParser__.arabicLetterHasFinalForm = function(U) {
    return c(U) && l(U) && e[U.charCodeAt(0)].length >= 2;
  };
  n.__arabicParser__.arabicLetterHasInitialForm = function(U) {
    return c(U) && l(U) && e[U.charCodeAt(0)].length >= 3;
  };
  var A = n.__arabicParser__.arabicLetterHasMedialForm = function(U) {
    return c(U) && l(U) && e[U.charCodeAt(0)].length == 4;
  }, C = n.__arabicParser__.resolveLigatures = function(U) {
    var V = 0, W = t, X = "", de = 0;
    for (V = 0; V < U.length; V += 1) W[U.charCodeAt(V)] !== void 0 ? (de++, typeof (W = W[U.charCodeAt(V)]) == "number" && (X += String.fromCharCode(W), W = t, de = 0), V === U.length - 1 && (W = t, X += U.charAt(V - (de - 1)), V -= de - 1, de = 0)) : (W = t, X += U.charAt(V - de), V -= de, de = 0);
    return X;
  };
  n.__arabicParser__.isArabicDiacritic = function(U) {
    return U !== void 0 && i[U.charCodeAt(0)] !== void 0;
  };
  var I = n.__arabicParser__.getCorrectForm = function(U, V, W) {
    return c(U) ? l(U) === !1 ? -1 : !y(U) || !c(V) && !c(W) || !c(W) && a(V) || a(U) && !c(V) || a(U) && g(V) || a(U) && a(V) ? 0 : A(U) && c(V) && !a(V) && c(W) && y(W) ? 3 : a(U) || !c(W) ? 1 : 2 : -1;
  }, S = function(U) {
    var V = 0, W = 0, X = 0, de = "", ie = "", fe = "", Ae = (U = U || "").split("\\s+"), Te = [];
    for (V = 0; V < Ae.length; V += 1) {
      for (Te.push(""), W = 0; W < Ae[V].length; W += 1) de = Ae[V][W], ie = Ae[V][W - 1], fe = Ae[V][W + 1], c(de) ? (X = I(de, ie, fe), Te[V] += X !== -1 ? String.fromCharCode(e[de.charCodeAt(0)][X]) : de) : Te[V] += de;
      Te[V] = C(Te[V]);
    }
    return Te.join(" ");
  }, F = n.__arabicParser__.processArabic = n.processArabic = function() {
    var U, V = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, W = [];
    if (Array.isArray(V)) {
      var X = 0;
      for (W = [], X = 0; X < V.length; X += 1) Array.isArray(V[X]) ? W.push([S(V[X][0]), V[X][1], V[X][2]]) : W.push([S(V[X])]);
      U = W;
    } else U = S(V);
    return typeof arguments[0] == "string" ? U : (arguments[0].text = U, arguments[0]);
  };
  n.events.push(["preProcessText", F]);
}(ti.API), ti.API.autoPrint = function(n) {
  var e;
  switch ((n = n || {}).variant = n.variant || "non-conform", n.variant) {
    case "javascript":
      this.addJS("print({});");
      break;
    case "non-conform":
    default:
      this.internal.events.subscribe("postPutResources", function() {
        e = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
      }), this.internal.events.subscribe("putCatalog", function() {
        this.internal.out("/OpenAction " + e + " 0 R");
      });
  }
  return this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function() {
    var t = void 0;
    Object.defineProperty(this, "pdf", { get: function() {
      return t;
    }, set: function(a) {
      t = a;
    } });
    var i = 150;
    Object.defineProperty(this, "width", { get: function() {
      return i;
    }, set: function(a) {
      i = isNaN(a) || Number.isInteger(a) === !1 || a < 0 ? 150 : a, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = i + 1);
    } });
    var r = 300;
    Object.defineProperty(this, "height", { get: function() {
      return r;
    }, set: function(a) {
      r = isNaN(a) || Number.isInteger(a) === !1 || a < 0 ? 300 : a, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = r + 1);
    } });
    var l = [];
    Object.defineProperty(this, "childNodes", { get: function() {
      return l;
    }, set: function(a) {
      l = a;
    } });
    var c = {};
    Object.defineProperty(this, "style", { get: function() {
      return c;
    }, set: function(a) {
      c = a;
    } }), Object.defineProperty(this, "parentNode", {});
  };
  e.prototype.getContext = function(t, i) {
    var r;
    if ((t = t || "2d") !== "2d") return null;
    for (r in i) this.pdf.context2d.hasOwnProperty(r) && (this.pdf.context2d[r] = i[r]);
    return this.pdf.context2d._canvas = this, this.pdf.context2d;
  }, e.prototype.toDataURL = function() {
    throw new Error("toDataURL is not implemented.");
  }, n.events.push(["initialized", function() {
    this.canvas = new e(), this.canvas.pdf = this;
  }]);
}(ti.API), function(n) {
  var e = { left: 0, top: 0, bottom: 0, right: 0 }, t = !1, i = function() {
    this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, e), this.internal.__cell__.margins.width = this.getPageWidth(), r.call(this));
  }, r = function() {
    this.internal.__cell__.lastCell = new l(), this.internal.__cell__.pages = 1;
  }, l = function() {
    var g = arguments[0];
    Object.defineProperty(this, "x", { enumerable: !0, get: function() {
      return g;
    }, set: function(U) {
      g = U;
    } });
    var y = arguments[1];
    Object.defineProperty(this, "y", { enumerable: !0, get: function() {
      return y;
    }, set: function(U) {
      y = U;
    } });
    var A = arguments[2];
    Object.defineProperty(this, "width", { enumerable: !0, get: function() {
      return A;
    }, set: function(U) {
      A = U;
    } });
    var C = arguments[3];
    Object.defineProperty(this, "height", { enumerable: !0, get: function() {
      return C;
    }, set: function(U) {
      C = U;
    } });
    var I = arguments[4];
    Object.defineProperty(this, "text", { enumerable: !0, get: function() {
      return I;
    }, set: function(U) {
      I = U;
    } });
    var S = arguments[5];
    Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function() {
      return S;
    }, set: function(U) {
      S = U;
    } });
    var F = arguments[6];
    return Object.defineProperty(this, "align", { enumerable: !0, get: function() {
      return F;
    }, set: function(U) {
      F = U;
    } }), this;
  };
  l.prototype.clone = function() {
    return new l(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
  }, l.prototype.toArray = function() {
    return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
  }, n.setHeaderFunction = function(g) {
    return i.call(this), this.internal.__cell__.headerFunction = typeof g == "function" ? g : void 0, this;
  }, n.getTextDimensions = function(g, y) {
    i.call(this);
    var A = (y = y || {}).fontSize || this.getFontSize(), C = y.font || this.getFont(), I = y.scaleFactor || this.internal.scaleFactor, S = 0, F = 0, U = 0, V = this;
    if (!Array.isArray(g) && typeof g != "string") {
      if (typeof g != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
      g = String(g);
    }
    var W = y.maxWidth;
    W > 0 ? typeof g == "string" ? g = this.splitTextToSize(g, W) : Object.prototype.toString.call(g) === "[object Array]" && (g = g.reduce(function(de, ie) {
      return de.concat(V.splitTextToSize(ie, W));
    }, [])) : g = Array.isArray(g) ? g : [g];
    for (var X = 0; X < g.length; X++) S < (U = this.getStringUnitWidth(g[X], { font: C }) * A) && (S = U);
    return S !== 0 && (F = g.length), { w: S /= I, h: Math.max((F * A * this.getLineHeightFactor() - A * (this.getLineHeightFactor() - 1)) / I, 0) };
  }, n.cellAddPage = function() {
    i.call(this), this.addPage();
    var g = this.internal.__cell__.margins || e;
    return this.internal.__cell__.lastCell = new l(g.left, g.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
  };
  var c = n.cell = function() {
    var g;
    g = arguments[0] instanceof l ? arguments[0] : new l(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), i.call(this);
    var y = this.internal.__cell__.lastCell, A = this.internal.__cell__.padding, C = this.internal.__cell__.margins || e, I = this.internal.__cell__.tableHeaderRow, S = this.internal.__cell__.printHeaders;
    return y.lineNumber !== void 0 && (y.lineNumber === g.lineNumber ? (g.x = (y.x || 0) + (y.width || 0), g.y = y.y || 0) : y.y + y.height + g.height + C.bottom > this.getPageHeight() ? (this.cellAddPage(), g.y = C.top, S && I && (this.printHeaderRow(g.lineNumber, !0), g.y += I[0].height)) : g.y = y.y + y.height || g.y), g.text[0] !== void 0 && (this.rect(g.x, g.y, g.width, g.height, t === !0 ? "FD" : void 0), g.align === "right" ? this.text(g.text, g.x + g.width - A, g.y + A, { align: "right", baseline: "top" }) : g.align === "center" ? this.text(g.text, g.x + g.width / 2, g.y + A, { align: "center", baseline: "top", maxWidth: g.width - A - A }) : this.text(g.text, g.x + A, g.y + A, { align: "left", baseline: "top", maxWidth: g.width - A - A })), this.internal.__cell__.lastCell = g, this;
  };
  n.table = function(g, y, A, C, I) {
    if (i.call(this), !A) throw new Error("No data for PDF table.");
    var S, F, U, V, W = [], X = [], de = [], ie = {}, fe = {}, Ae = [], Te = [], me = (I = I || {}).autoSize || !1, Ge = I.printHeaders !== !1, ke = I.css && I.css["font-size"] !== void 0 ? 16 * I.css["font-size"] : I.fontSize || 12, pe = I.margins || Object.assign({ width: this.getPageWidth() }, e), _e = typeof I.padding == "number" ? I.padding : 3, De = I.headerBackgroundColor || "#c8c8c8", Me = I.headerTextColor || "#000";
    if (r.call(this), this.internal.__cell__.printHeaders = Ge, this.internal.__cell__.margins = pe, this.internal.__cell__.table_font_size = ke, this.internal.__cell__.padding = _e, this.internal.__cell__.headerBackgroundColor = De, this.internal.__cell__.headerTextColor = Me, this.setFontSize(ke), C == null) X = W = Object.keys(A[0]), de = W.map(function() {
      return "left";
    });
    else if (Array.isArray(C) && or(C[0]) === "object") for (W = C.map(function(Ft) {
      return Ft.name;
    }), X = C.map(function(Ft) {
      return Ft.prompt || Ft.name || "";
    }), de = C.map(function(Ft) {
      return Ft.align || "left";
    }), S = 0; S < C.length; S += 1) fe[C[S].name] = C[S].width * (19.049976 / 25.4);
    else Array.isArray(C) && typeof C[0] == "string" && (X = W = C, de = W.map(function() {
      return "left";
    }));
    if (me || Array.isArray(C) && typeof C[0] == "string") for (S = 0; S < W.length; S += 1) {
      for (ie[V = W[S]] = A.map(function(Ft) {
        return Ft[V];
      }), this.setFont(void 0, "bold"), Ae.push(this.getTextDimensions(X[S], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), F = ie[V], this.setFont(void 0, "normal"), U = 0; U < F.length; U += 1) Ae.push(this.getTextDimensions(F[U], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
      fe[V] = Math.max.apply(null, Ae) + _e + _e, Ae = [];
    }
    if (Ge) {
      var St = {};
      for (S = 0; S < W.length; S += 1) St[W[S]] = {}, St[W[S]].text = X[S], St[W[S]].align = de[S];
      var dt = a.call(this, St, fe);
      Te = W.map(function(Ft) {
        return new l(g, y, fe[Ft], dt, St[Ft].text, void 0, St[Ft].align);
      }), this.setTableHeaderRow(Te), this.printHeaderRow(1, !1);
    }
    var Pt = C.reduce(function(Ft, mn) {
      return Ft[mn.name] = mn.align, Ft;
    }, {});
    for (S = 0; S < A.length; S += 1) {
      "rowStart" in I && I.rowStart instanceof Function && I.rowStart({ row: S, data: A[S] }, this);
      var gt = a.call(this, A[S], fe);
      for (U = 0; U < W.length; U += 1) {
        var Rt = A[S][W[U]];
        "cellStart" in I && I.cellStart instanceof Function && I.cellStart({ row: S, col: U, data: Rt }, this), c.call(this, new l(g, y, fe[W[U]], gt, Rt, S + 2, Pt[W[U]]));
      }
    }
    return this.internal.__cell__.table_x = g, this.internal.__cell__.table_y = y, this;
  };
  var a = function(g, y) {
    var A = this.internal.__cell__.padding, C = this.internal.__cell__.table_font_size, I = this.internal.scaleFactor;
    return Object.keys(g).map(function(S) {
      var F = g[S];
      return this.splitTextToSize(F.hasOwnProperty("text") ? F.text : F, y[S] - A - A);
    }, this).map(function(S) {
      return this.getLineHeightFactor() * S.length * C / I + A + A;
    }, this).reduce(function(S, F) {
      return Math.max(S, F);
    }, 0);
  };
  n.setTableHeaderRow = function(g) {
    i.call(this), this.internal.__cell__.tableHeaderRow = g;
  }, n.printHeaderRow = function(g, y) {
    if (i.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
    var A;
    if (t = !0, typeof this.internal.__cell__.headerFunction == "function") {
      var C = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
      this.internal.__cell__.lastCell = new l(C[0], C[1], C[2], C[3], void 0, -1);
    }
    this.setFont(void 0, "bold");
    for (var I = [], S = 0; S < this.internal.__cell__.tableHeaderRow.length; S += 1) {
      A = this.internal.__cell__.tableHeaderRow[S].clone(), y && (A.y = this.internal.__cell__.margins.top || 0, I.push(A)), A.lineNumber = g;
      var F = this.getTextColor();
      this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), c.call(this, A), this.setTextColor(F);
    }
    I.length > 0 && this.setTableHeaderRow(I), this.setFont(void 0, "normal"), t = !1;
  };
}(ti.API);
var w3 = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, A3 = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], M1 = x3(A3), T3 = [100, 200, 300, 400, 500, 600, 700, 800, 900], JV = x3(T3);
function L1(n) {
  var e = n.family.replace(/"|'/g, "").toLowerCase(), t = function(l) {
    return w3[l = l || "normal"] ? l : "normal";
  }(n.style), i = function(l) {
    if (!l) return 400;
    if (typeof l == "number") return l >= 100 && l <= 900 && l % 100 == 0 ? l : 400;
    if (/^\d00$/.test(l)) return parseInt(l);
    switch (l) {
      case "bold":
        return 700;
      case "normal":
      default:
        return 400;
    }
  }(n.weight), r = function(l) {
    return typeof M1[l = l || "normal"] == "number" ? l : "normal";
  }(n.stretch);
  return { family: e, style: t, weight: i, stretch: r, src: n.src || [], ref: n.ref || { name: e, style: [r, t, i].join(" ") } };
}
function w5(n, e, t, i) {
  var r;
  for (r = t; r >= 0 && r < e.length; r += i) if (n[e[r]]) return n[e[r]];
  for (r = t; r >= 0 && r < e.length; r -= i) if (n[e[r]]) return n[e[r]];
}
var KV = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, A5 = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
function T5(n) {
  return [n.stretch, n.style, n.weight, n.family].join(" ");
}
function QV(n, e, t) {
  for (var i = (t = t || {}).defaultFontFamily || "times", r = Object.assign({}, KV, t.genericFontFamilies || {}), l = null, c = null, a = 0; a < e.length; ++a) if (r[(l = L1(e[a])).family] && (l.family = r[l.family]), n.hasOwnProperty(l.family)) {
    c = n[l.family];
    break;
  }
  if (!(c = c || n[i])) throw new Error("Could not find a font-family for the rule '" + T5(l) + "' and default family '" + i + "'.");
  if (c = function(g, y) {
    if (y[g]) return y[g];
    var A = M1[g], C = A <= M1.normal ? -1 : 1, I = w5(y, A3, A, C);
    if (!I) throw new Error("Could not find a matching font-stretch value for " + g);
    return I;
  }(l.stretch, c), c = function(g, y) {
    if (y[g]) return y[g];
    for (var A = w3[g], C = 0; C < A.length; ++C) if (y[A[C]]) return y[A[C]];
    throw new Error("Could not find a matching font-style for " + g);
  }(l.style, c), !(c = function(g, y) {
    if (y[g]) return y[g];
    if (g === 400 && y[500]) return y[500];
    if (g === 500 && y[400]) return y[400];
    var A = JV[g], C = w5(y, T3, A, g < 400 ? -1 : 1);
    if (!C) throw new Error("Could not find a matching font-weight for value " + g);
    return C;
  }(l.weight, c))) throw new Error("Failed to resolve a font for the rule '" + T5(l) + "'.");
  return c;
}
function E5(n) {
  return n.trimLeft();
}
function eq(n, e) {
  for (var t = 0; t < n.length; ) {
    if (n.charAt(t) === e) return [n.substring(0, t), n.substring(t + 1)];
    t += 1;
  }
  return null;
}
function tq(n) {
  var e = n.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
  return e === null ? null : [e[0], n.substring(e[0].length)];
}
var Jg, S5, C5, P5 = ["times"];
(function(n) {
  var e, t, i, r, l, c, a, g, y, A = function(oe) {
    return oe = oe || {}, this.isStrokeTransparent = oe.isStrokeTransparent || !1, this.strokeOpacity = oe.strokeOpacity || 1, this.strokeStyle = oe.strokeStyle || "#000000", this.fillStyle = oe.fillStyle || "#000000", this.isFillTransparent = oe.isFillTransparent || !1, this.fillOpacity = oe.fillOpacity || 1, this.font = oe.font || "10px sans-serif", this.textBaseline = oe.textBaseline || "alphabetic", this.textAlign = oe.textAlign || "left", this.lineWidth = oe.lineWidth || 1, this.lineJoin = oe.lineJoin || "miter", this.lineCap = oe.lineCap || "butt", this.path = oe.path || [], this.transform = oe.transform !== void 0 ? oe.transform.clone() : new g(), this.globalCompositeOperation = oe.globalCompositeOperation || "normal", this.globalAlpha = oe.globalAlpha || 1, this.clip_path = oe.clip_path || [], this.currentPoint = oe.currentPoint || new c(), this.miterLimit = oe.miterLimit || 10, this.lastPoint = oe.lastPoint || new c(), this.lineDashOffset = oe.lineDashOffset || 0, this.lineDash = oe.lineDash || [], this.margin = oe.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = oe.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof oe.ignoreClearRect != "boolean" || oe.ignoreClearRect, this;
  };
  n.events.push(["initialized", function() {
    this.context2d = new C(this), e = this.internal.f2, t = this.internal.getCoordinateString, i = this.internal.getVerticalCoordinateString, r = this.internal.getHorizontalCoordinate, l = this.internal.getVerticalCoordinate, c = this.internal.Point, a = this.internal.Rectangle, g = this.internal.Matrix, y = new A();
  }]);
  var C = function(oe) {
    Object.defineProperty(this, "canvas", { get: function() {
      return { parentNode: !1, style: !1 };
    } });
    var Re = oe;
    Object.defineProperty(this, "pdf", { get: function() {
      return Re;
    } });
    var ze = !1;
    Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
      return ze;
    }, set: function(Bt) {
      ze = !!Bt;
    } });
    var Xe = !1;
    Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
      return Xe;
    }, set: function(Bt) {
      Xe = !!Bt;
    } });
    var ot = 0;
    Object.defineProperty(this, "posX", { get: function() {
      return ot;
    }, set: function(Bt) {
      isNaN(Bt) || (ot = Bt);
    } });
    var rt = 0;
    Object.defineProperty(this, "posY", { get: function() {
      return rt;
    }, set: function(Bt) {
      isNaN(Bt) || (rt = Bt);
    } }), Object.defineProperty(this, "margin", { get: function() {
      return y.margin;
    }, set: function(Bt) {
      var Ue;
      typeof Bt == "number" ? Ue = [Bt, Bt, Bt, Bt] : ((Ue = new Array(4))[0] = Bt[0], Ue[1] = Bt.length >= 2 ? Bt[1] : Ue[0], Ue[2] = Bt.length >= 3 ? Bt[2] : Ue[0], Ue[3] = Bt.length >= 4 ? Bt[3] : Ue[1]), y.margin = Ue;
    } });
    var xt = !1;
    Object.defineProperty(this, "autoPaging", { get: function() {
      return xt;
    }, set: function(Bt) {
      xt = Bt;
    } });
    var ht = 0;
    Object.defineProperty(this, "lastBreak", { get: function() {
      return ht;
    }, set: function(Bt) {
      ht = Bt;
    } });
    var $t = [];
    Object.defineProperty(this, "pageBreaks", { get: function() {
      return $t;
    }, set: function(Bt) {
      $t = Bt;
    } }), Object.defineProperty(this, "ctx", { get: function() {
      return y;
    }, set: function(Bt) {
      Bt instanceof A && (y = Bt);
    } }), Object.defineProperty(this, "path", { get: function() {
      return y.path;
    }, set: function(Bt) {
      y.path = Bt;
    } });
    var Wt = [];
    Object.defineProperty(this, "ctxStack", { get: function() {
      return Wt;
    }, set: function(Bt) {
      Wt = Bt;
    } }), Object.defineProperty(this, "fillStyle", { get: function() {
      return this.ctx.fillStyle;
    }, set: function(Bt) {
      var Ue;
      Ue = I(Bt), this.ctx.fillStyle = Ue.style, this.ctx.isFillTransparent = Ue.a === 0, this.ctx.fillOpacity = Ue.a, this.pdf.setFillColor(Ue.r, Ue.g, Ue.b, { a: Ue.a }), this.pdf.setTextColor(Ue.r, Ue.g, Ue.b, { a: Ue.a });
    } }), Object.defineProperty(this, "strokeStyle", { get: function() {
      return this.ctx.strokeStyle;
    }, set: function(Bt) {
      var Ue = I(Bt);
      this.ctx.strokeStyle = Ue.style, this.ctx.isStrokeTransparent = Ue.a === 0, this.ctx.strokeOpacity = Ue.a, Ue.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (Ue.a, this.pdf.setDrawColor(Ue.r, Ue.g, Ue.b));
    } }), Object.defineProperty(this, "lineCap", { get: function() {
      return this.ctx.lineCap;
    }, set: function(Bt) {
      ["butt", "round", "square"].indexOf(Bt) !== -1 && (this.ctx.lineCap = Bt, this.pdf.setLineCap(Bt));
    } }), Object.defineProperty(this, "lineWidth", { get: function() {
      return this.ctx.lineWidth;
    }, set: function(Bt) {
      isNaN(Bt) || (this.ctx.lineWidth = Bt, this.pdf.setLineWidth(Bt));
    } }), Object.defineProperty(this, "lineJoin", { get: function() {
      return this.ctx.lineJoin;
    }, set: function(Bt) {
      ["bevel", "round", "miter"].indexOf(Bt) !== -1 && (this.ctx.lineJoin = Bt, this.pdf.setLineJoin(Bt));
    } }), Object.defineProperty(this, "miterLimit", { get: function() {
      return this.ctx.miterLimit;
    }, set: function(Bt) {
      isNaN(Bt) || (this.ctx.miterLimit = Bt, this.pdf.setMiterLimit(Bt));
    } }), Object.defineProperty(this, "textBaseline", { get: function() {
      return this.ctx.textBaseline;
    }, set: function(Bt) {
      this.ctx.textBaseline = Bt;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      return this.ctx.textAlign;
    }, set: function(Bt) {
      ["right", "end", "center", "left", "start"].indexOf(Bt) !== -1 && (this.ctx.textAlign = Bt);
    } });
    var on = null;
    function hn(Bt, Ue) {
      if (on === null) {
        var On = function(Sn) {
          var en = [];
          return Object.keys(Sn).forEach(function(ln) {
            Sn[ln].forEach(function(un) {
              var _n = null;
              switch (un) {
                case "bold":
                  _n = { family: ln, weight: "bold" };
                  break;
                case "italic":
                  _n = { family: ln, style: "italic" };
                  break;
                case "bolditalic":
                  _n = { family: ln, weight: "bold", style: "italic" };
                  break;
                case "":
                case "normal":
                  _n = { family: ln };
              }
              _n !== null && (_n.ref = { name: ln, style: un }, en.push(_n));
            });
          }), en;
        }(Bt.getFontList());
        on = function(Sn) {
          for (var en = {}, ln = 0; ln < Sn.length; ++ln) {
            var un = L1(Sn[ln]), _n = un.family, Mn = un.stretch, Wn = un.style, $n = un.weight;
            en[_n] = en[_n] || {}, en[_n][Mn] = en[_n][Mn] || {}, en[_n][Mn][Wn] = en[_n][Mn][Wn] || {}, en[_n][Mn][Wn][$n] = un;
          }
          return en;
        }(On.concat(Ue));
      }
      return on;
    }
    var wn = null;
    Object.defineProperty(this, "fontFaces", { get: function() {
      return wn;
    }, set: function(Bt) {
      on = null, wn = Bt;
    } }), Object.defineProperty(this, "font", { get: function() {
      return this.ctx.font;
    }, set: function(Bt) {
      var Ue;
      if (this.ctx.font = Bt, (Ue = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(Bt)) !== null) {
        var On = Ue[1], Sn = (Ue[2], Ue[3]), en = Ue[4], ln = (Ue[5], Ue[6]), un = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(en)[2];
        en = Math.floor(un === "px" ? parseFloat(en) * this.pdf.internal.scaleFactor : un === "em" ? parseFloat(en) * this.pdf.getFontSize() : parseFloat(en) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(en);
        var _n = function(Un) {
          var Jn, bn, tr = [], pi = Un.trim();
          if (pi === "") return P5;
          if (pi in A5) return [A5[pi]];
          for (; pi !== ""; ) {
            switch (bn = null, Jn = (pi = E5(pi)).charAt(0)) {
              case '"':
              case "'":
                bn = eq(pi.substring(1), Jn);
                break;
              default:
                bn = tq(pi);
            }
            if (bn === null || (tr.push(bn[0]), (pi = E5(bn[1])) !== "" && pi.charAt(0) !== ",")) return P5;
            pi = pi.replace(/^,/, "");
          }
          return tr;
        }(ln);
        if (this.fontFaces) {
          var Mn = QV(hn(this.pdf, this.fontFaces), _n.map(function(Un) {
            return { family: Un, stretch: "normal", weight: Sn, style: On };
          }));
          this.pdf.setFont(Mn.ref.name, Mn.ref.style);
        } else {
          var Wn = "";
          (Sn === "bold" || parseInt(Sn, 10) >= 700 || On === "bold") && (Wn = "bold"), On === "italic" && (Wn += "italic"), Wn.length === 0 && (Wn = "normal");
          for (var $n = "", Yn = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, si = 0; si < _n.length; si++) {
            if (this.pdf.internal.getFont(_n[si], Wn, { noFallback: !0, disableWarning: !0 }) !== void 0) {
              $n = _n[si];
              break;
            }
            if (Wn === "bolditalic" && this.pdf.internal.getFont(_n[si], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) $n = _n[si], Wn = "bold";
            else if (this.pdf.internal.getFont(_n[si], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) {
              $n = _n[si], Wn = "normal";
              break;
            }
          }
          if ($n === "") {
            for (var fi = 0; fi < _n.length; fi++) if (Yn[_n[fi]]) {
              $n = Yn[_n[fi]];
              break;
            }
          }
          $n = $n === "" ? "Times" : $n, this.pdf.setFont($n, Wn);
        }
      }
    } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
      return this.ctx.globalCompositeOperation;
    }, set: function(Bt) {
      this.ctx.globalCompositeOperation = Bt;
    } }), Object.defineProperty(this, "globalAlpha", { get: function() {
      return this.ctx.globalAlpha;
    }, set: function(Bt) {
      this.ctx.globalAlpha = Bt;
    } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
      return this.ctx.lineDashOffset;
    }, set: function(Bt) {
      this.ctx.lineDashOffset = Bt, mn.call(this);
    } }), Object.defineProperty(this, "lineDash", { get: function() {
      return this.ctx.lineDash;
    }, set: function(Bt) {
      this.ctx.lineDash = Bt, mn.call(this);
    } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
      return this.ctx.ignoreClearRect;
    }, set: function(Bt) {
      this.ctx.ignoreClearRect = !!Bt;
    } });
  };
  C.prototype.setLineDash = function(oe) {
    this.lineDash = oe;
  }, C.prototype.getLineDash = function() {
    return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
  }, C.prototype.fill = function() {
    ie.call(this, "fill", !1);
  }, C.prototype.stroke = function() {
    ie.call(this, "stroke", !1);
  }, C.prototype.beginPath = function() {
    this.path = [{ type: "begin" }];
  }, C.prototype.moveTo = function(oe, Re) {
    if (isNaN(oe) || isNaN(Re)) throw mr.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
    var ze = this.ctx.transform.applyToPoint(new c(oe, Re));
    this.path.push({ type: "mt", x: ze.x, y: ze.y }), this.ctx.lastPoint = new c(oe, Re);
  }, C.prototype.closePath = function() {
    var oe = new c(0, 0), Re = 0;
    for (Re = this.path.length - 1; Re !== -1; Re--) if (this.path[Re].type === "begin" && or(this.path[Re + 1]) === "object" && typeof this.path[Re + 1].x == "number") {
      oe = new c(this.path[Re + 1].x, this.path[Re + 1].y);
      break;
    }
    this.path.push({ type: "close" }), this.ctx.lastPoint = new c(oe.x, oe.y);
  }, C.prototype.lineTo = function(oe, Re) {
    if (isNaN(oe) || isNaN(Re)) throw mr.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
    var ze = this.ctx.transform.applyToPoint(new c(oe, Re));
    this.path.push({ type: "lt", x: ze.x, y: ze.y }), this.ctx.lastPoint = new c(ze.x, ze.y);
  }, C.prototype.clip = function() {
    this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), ie.call(this, null, !0);
  }, C.prototype.quadraticCurveTo = function(oe, Re, ze, Xe) {
    if (isNaN(ze) || isNaN(Xe) || isNaN(oe) || isNaN(Re)) throw mr.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
    var ot = this.ctx.transform.applyToPoint(new c(ze, Xe)), rt = this.ctx.transform.applyToPoint(new c(oe, Re));
    this.path.push({ type: "qct", x1: rt.x, y1: rt.y, x: ot.x, y: ot.y }), this.ctx.lastPoint = new c(ot.x, ot.y);
  }, C.prototype.bezierCurveTo = function(oe, Re, ze, Xe, ot, rt) {
    if (isNaN(ot) || isNaN(rt) || isNaN(oe) || isNaN(Re) || isNaN(ze) || isNaN(Xe)) throw mr.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
    var xt = this.ctx.transform.applyToPoint(new c(ot, rt)), ht = this.ctx.transform.applyToPoint(new c(oe, Re)), $t = this.ctx.transform.applyToPoint(new c(ze, Xe));
    this.path.push({ type: "bct", x1: ht.x, y1: ht.y, x2: $t.x, y2: $t.y, x: xt.x, y: xt.y }), this.ctx.lastPoint = new c(xt.x, xt.y);
  }, C.prototype.arc = function(oe, Re, ze, Xe, ot, rt) {
    if (isNaN(oe) || isNaN(Re) || isNaN(ze) || isNaN(Xe) || isNaN(ot)) throw mr.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
    if (rt = !!rt, !this.ctx.transform.isIdentity) {
      var xt = this.ctx.transform.applyToPoint(new c(oe, Re));
      oe = xt.x, Re = xt.y;
      var ht = this.ctx.transform.applyToPoint(new c(0, ze)), $t = this.ctx.transform.applyToPoint(new c(0, 0));
      ze = Math.sqrt(Math.pow(ht.x - $t.x, 2) + Math.pow(ht.y - $t.y, 2));
    }
    Math.abs(ot - Xe) >= 2 * Math.PI && (Xe = 0, ot = 2 * Math.PI), this.path.push({ type: "arc", x: oe, y: Re, radius: ze, startAngle: Xe, endAngle: ot, counterclockwise: rt });
  }, C.prototype.arcTo = function(oe, Re, ze, Xe, ot) {
    throw new Error("arcTo not implemented.");
  }, C.prototype.rect = function(oe, Re, ze, Xe) {
    if (isNaN(oe) || isNaN(Re) || isNaN(ze) || isNaN(Xe)) throw mr.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
    this.moveTo(oe, Re), this.lineTo(oe + ze, Re), this.lineTo(oe + ze, Re + Xe), this.lineTo(oe, Re + Xe), this.lineTo(oe, Re), this.lineTo(oe + ze, Re), this.lineTo(oe, Re);
  }, C.prototype.fillRect = function(oe, Re, ze, Xe) {
    if (isNaN(oe) || isNaN(Re) || isNaN(ze) || isNaN(Xe)) throw mr.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
    if (!S.call(this)) {
      var ot = {};
      this.lineCap !== "butt" && (ot.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (ot.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(oe, Re, ze, Xe), this.fill(), ot.hasOwnProperty("lineCap") && (this.lineCap = ot.lineCap), ot.hasOwnProperty("lineJoin") && (this.lineJoin = ot.lineJoin);
    }
  }, C.prototype.strokeRect = function(oe, Re, ze, Xe) {
    if (isNaN(oe) || isNaN(Re) || isNaN(ze) || isNaN(Xe)) throw mr.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
    F.call(this) || (this.beginPath(), this.rect(oe, Re, ze, Xe), this.stroke());
  }, C.prototype.clearRect = function(oe, Re, ze, Xe) {
    if (isNaN(oe) || isNaN(Re) || isNaN(ze) || isNaN(Xe)) throw mr.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
    this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(oe, Re, ze, Xe));
  }, C.prototype.save = function(oe) {
    oe = typeof oe != "boolean" || oe;
    for (var Re = this.pdf.internal.getCurrentPageInfo().pageNumber, ze = 0; ze < this.pdf.internal.getNumberOfPages(); ze++) this.pdf.setPage(ze + 1), this.pdf.internal.out("q");
    if (this.pdf.setPage(Re), oe) {
      this.ctx.fontSize = this.pdf.internal.getFontSize();
      var Xe = new A(this.ctx);
      this.ctxStack.push(this.ctx), this.ctx = Xe;
    }
  }, C.prototype.restore = function(oe) {
    oe = typeof oe != "boolean" || oe;
    for (var Re = this.pdf.internal.getCurrentPageInfo().pageNumber, ze = 0; ze < this.pdf.internal.getNumberOfPages(); ze++) this.pdf.setPage(ze + 1), this.pdf.internal.out("Q");
    this.pdf.setPage(Re), oe && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
  }, C.prototype.toDataURL = function() {
    throw new Error("toDataUrl not implemented.");
  };
  var I = function(oe) {
    var Re, ze, Xe, ot;
    if (oe.isCanvasGradient === !0 && (oe = oe.getColor()), !oe) return { r: 0, g: 0, b: 0, a: 0, style: oe };
    if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(oe)) Re = 0, ze = 0, Xe = 0, ot = 0;
    else {
      var rt = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(oe);
      if (rt !== null) Re = parseInt(rt[1]), ze = parseInt(rt[2]), Xe = parseInt(rt[3]), ot = 1;
      else if ((rt = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(oe)) !== null) Re = parseInt(rt[1]), ze = parseInt(rt[2]), Xe = parseInt(rt[3]), ot = parseFloat(rt[4]);
      else {
        if (ot = 1, typeof oe == "string" && oe.charAt(0) !== "#") {
          var xt = new g3(oe);
          oe = xt.ok ? xt.toHex() : "#000000";
        }
        oe.length === 4 ? (Re = oe.substring(1, 2), Re += Re, ze = oe.substring(2, 3), ze += ze, Xe = oe.substring(3, 4), Xe += Xe) : (Re = oe.substring(1, 3), ze = oe.substring(3, 5), Xe = oe.substring(5, 7)), Re = parseInt(Re, 16), ze = parseInt(ze, 16), Xe = parseInt(Xe, 16);
      }
    }
    return { r: Re, g: ze, b: Xe, a: ot, style: oe };
  }, S = function() {
    return this.ctx.isFillTransparent || this.globalAlpha == 0;
  }, F = function() {
    return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0);
  };
  C.prototype.fillText = function(oe, Re, ze, Xe) {
    if (isNaN(Re) || isNaN(ze) || typeof oe != "string") throw mr.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
    if (Xe = isNaN(Xe) ? void 0 : Xe, !S.call(this)) {
      var ot = gt(this.ctx.transform.rotation), rt = this.ctx.transform.scaleX;
      _e.call(this, { text: oe, x: Re, y: ze, scale: rt, angle: ot, align: this.textAlign, maxWidth: Xe });
    }
  }, C.prototype.strokeText = function(oe, Re, ze, Xe) {
    if (isNaN(Re) || isNaN(ze) || typeof oe != "string") throw mr.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
    if (!F.call(this)) {
      Xe = isNaN(Xe) ? void 0 : Xe;
      var ot = gt(this.ctx.transform.rotation), rt = this.ctx.transform.scaleX;
      _e.call(this, { text: oe, x: Re, y: ze, scale: rt, renderingMode: "stroke", angle: ot, align: this.textAlign, maxWidth: Xe });
    }
  }, C.prototype.measureText = function(oe) {
    if (typeof oe != "string") throw mr.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
    var Re = this.pdf, ze = this.pdf.internal.scaleFactor, Xe = Re.internal.getFontSize(), ot = Re.getStringUnitWidth(oe) * Xe / Re.internal.scaleFactor, rt = function(xt) {
      var ht = (xt = xt || {}).width || 0;
      return Object.defineProperty(this, "width", { get: function() {
        return ht;
      } }), this;
    };
    return new rt({ width: ot *= Math.round(96 * ze / 72 * 1e4) / 1e4 });
  }, C.prototype.scale = function(oe, Re) {
    if (isNaN(oe) || isNaN(Re)) throw mr.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
    var ze = new g(oe, 0, 0, Re, 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(ze);
  }, C.prototype.rotate = function(oe) {
    if (isNaN(oe)) throw mr.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
    var Re = new g(Math.cos(oe), Math.sin(oe), -Math.sin(oe), Math.cos(oe), 0, 0);
    this.ctx.transform = this.ctx.transform.multiply(Re);
  }, C.prototype.translate = function(oe, Re) {
    if (isNaN(oe) || isNaN(Re)) throw mr.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
    var ze = new g(1, 0, 0, 1, oe, Re);
    this.ctx.transform = this.ctx.transform.multiply(ze);
  }, C.prototype.transform = function(oe, Re, ze, Xe, ot, rt) {
    if (isNaN(oe) || isNaN(Re) || isNaN(ze) || isNaN(Xe) || isNaN(ot) || isNaN(rt)) throw mr.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
    var xt = new g(oe, Re, ze, Xe, ot, rt);
    this.ctx.transform = this.ctx.transform.multiply(xt);
  }, C.prototype.setTransform = function(oe, Re, ze, Xe, ot, rt) {
    oe = isNaN(oe) ? 1 : oe, Re = isNaN(Re) ? 0 : Re, ze = isNaN(ze) ? 0 : ze, Xe = isNaN(Xe) ? 1 : Xe, ot = isNaN(ot) ? 0 : ot, rt = isNaN(rt) ? 0 : rt, this.ctx.transform = new g(oe, Re, ze, Xe, ot, rt);
  };
  var U = function() {
    return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
  };
  C.prototype.drawImage = function(oe, Re, ze, Xe, ot, rt, xt, ht, $t) {
    var Wt = this.pdf.getImageProperties(oe), on = 1, hn = 1, wn = 1, Bt = 1;
    Xe !== void 0 && ht !== void 0 && (wn = ht / Xe, Bt = $t / ot, on = Wt.width / Xe * ht / Xe, hn = Wt.height / ot * $t / ot), rt === void 0 && (rt = Re, xt = ze, Re = 0, ze = 0), Xe !== void 0 && ht === void 0 && (ht = Xe, $t = ot), Xe === void 0 && ht === void 0 && (ht = Wt.width, $t = Wt.height);
    for (var Ue, On = this.ctx.transform.decompose(), Sn = gt(On.rotate.shx), en = new g(), ln = (en = (en = (en = en.multiply(On.translate)).multiply(On.skew)).multiply(On.scale)).applyToRectangle(new a(rt - Re * wn, xt - ze * Bt, Xe * on, ot * hn)), un = V.call(this, ln), _n = [], Mn = 0; Mn < un.length; Mn += 1) _n.indexOf(un[Mn]) === -1 && _n.push(un[Mn]);
    if (de(_n), this.autoPaging) for (var Wn = _n[0], $n = _n[_n.length - 1], Yn = Wn; Yn < $n + 1; Yn++) {
      this.pdf.setPage(Yn);
      var si = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], fi = Yn === 1 ? this.posY + this.margin[0] : this.margin[0], Un = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Jn = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], bn = Yn === 1 ? 0 : Un + (Yn - 2) * Jn;
      if (this.ctx.clip_path.length !== 0) {
        var tr = this.path;
        Ue = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = X(Ue, this.posX + this.margin[3], -bn + fi + this.ctx.prevPageLastElemOffset), fe.call(this, "fill", !0), this.path = tr;
      }
      var pi = JSON.parse(JSON.stringify(ln));
      pi = X([pi], this.posX + this.margin[3], -bn + fi + this.ctx.prevPageLastElemOffset)[0];
      var Dr = (Yn > Wn || Yn < $n) && U.call(this);
      Dr && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], si, Jn, null).clip().discardPath()), this.pdf.addImage(oe, "JPEG", pi.x, pi.y, pi.w, pi.h, null, null, Sn), Dr && this.pdf.restoreGraphicsState();
    }
    else this.pdf.addImage(oe, "JPEG", ln.x, ln.y, ln.w, ln.h, null, null, Sn);
  };
  var V = function(oe, Re, ze) {
    var Xe = [];
    Re = Re || this.pdf.internal.pageSize.width, ze = ze || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
    var ot = this.posY + this.ctx.prevPageLastElemOffset;
    switch (oe.type) {
      default:
      case "mt":
      case "lt":
        Xe.push(Math.floor((oe.y + ot) / ze) + 1);
        break;
      case "arc":
        Xe.push(Math.floor((oe.y + ot - oe.radius) / ze) + 1), Xe.push(Math.floor((oe.y + ot + oe.radius) / ze) + 1);
        break;
      case "qct":
        var rt = Rt(this.ctx.lastPoint.x, this.ctx.lastPoint.y, oe.x1, oe.y1, oe.x, oe.y);
        Xe.push(Math.floor((rt.y + ot) / ze) + 1), Xe.push(Math.floor((rt.y + rt.h + ot) / ze) + 1);
        break;
      case "bct":
        var xt = Ft(this.ctx.lastPoint.x, this.ctx.lastPoint.y, oe.x1, oe.y1, oe.x2, oe.y2, oe.x, oe.y);
        Xe.push(Math.floor((xt.y + ot) / ze) + 1), Xe.push(Math.floor((xt.y + xt.h + ot) / ze) + 1);
        break;
      case "rect":
        Xe.push(Math.floor((oe.y + ot) / ze) + 1), Xe.push(Math.floor((oe.y + oe.h + ot) / ze) + 1);
    }
    for (var ht = 0; ht < Xe.length; ht += 1) for (; this.pdf.internal.getNumberOfPages() < Xe[ht]; ) W.call(this);
    return Xe;
  }, W = function() {
    var oe = this.fillStyle, Re = this.strokeStyle, ze = this.font, Xe = this.lineCap, ot = this.lineWidth, rt = this.lineJoin;
    this.pdf.addPage(), this.fillStyle = oe, this.strokeStyle = Re, this.font = ze, this.lineCap = Xe, this.lineWidth = ot, this.lineJoin = rt;
  }, X = function(oe, Re, ze) {
    for (var Xe = 0; Xe < oe.length; Xe++) switch (oe[Xe].type) {
      case "bct":
        oe[Xe].x2 += Re, oe[Xe].y2 += ze;
      case "qct":
        oe[Xe].x1 += Re, oe[Xe].y1 += ze;
      case "mt":
      case "lt":
      case "arc":
      default:
        oe[Xe].x += Re, oe[Xe].y += ze;
    }
    return oe;
  }, de = function(oe) {
    return oe.sort(function(Re, ze) {
      return Re - ze;
    });
  }, ie = function(oe, Re) {
    for (var ze, Xe, ot = this.fillStyle, rt = this.strokeStyle, xt = this.lineCap, ht = this.lineWidth, $t = Math.abs(ht * this.ctx.transform.scaleX), Wt = this.lineJoin, on = JSON.parse(JSON.stringify(this.path)), hn = JSON.parse(JSON.stringify(this.path)), wn = [], Bt = 0; Bt < hn.length; Bt++) if (hn[Bt].x !== void 0) for (var Ue = V.call(this, hn[Bt]), On = 0; On < Ue.length; On += 1) wn.indexOf(Ue[On]) === -1 && wn.push(Ue[On]);
    for (var Sn = 0; Sn < wn.length; Sn++) for (; this.pdf.internal.getNumberOfPages() < wn[Sn]; ) W.call(this);
    if (de(wn), this.autoPaging) for (var en = wn[0], ln = wn[wn.length - 1], un = en; un < ln + 1; un++) {
      this.pdf.setPage(un), this.fillStyle = ot, this.strokeStyle = rt, this.lineCap = xt, this.lineWidth = $t, this.lineJoin = Wt;
      var _n = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Mn = un === 1 ? this.posY + this.margin[0] : this.margin[0], Wn = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], $n = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Yn = un === 1 ? 0 : Wn + (un - 2) * $n;
      if (this.ctx.clip_path.length !== 0) {
        var si = this.path;
        ze = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = X(ze, this.posX + this.margin[3], -Yn + Mn + this.ctx.prevPageLastElemOffset), fe.call(this, oe, !0), this.path = si;
      }
      if (Xe = JSON.parse(JSON.stringify(on)), this.path = X(Xe, this.posX + this.margin[3], -Yn + Mn + this.ctx.prevPageLastElemOffset), Re === !1 || un === 0) {
        var fi = (un > en || un < ln) && U.call(this);
        fi && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _n, $n, null).clip().discardPath()), fe.call(this, oe, Re), fi && this.pdf.restoreGraphicsState();
      }
      this.lineWidth = ht;
    }
    else this.lineWidth = $t, fe.call(this, oe, Re), this.lineWidth = ht;
    this.path = on;
  }, fe = function(oe, Re) {
    if ((oe !== "stroke" || Re || !F.call(this)) && (oe === "stroke" || Re || !S.call(this))) {
      for (var ze, Xe, ot = [], rt = this.path, xt = 0; xt < rt.length; xt++) {
        var ht = rt[xt];
        switch (ht.type) {
          case "begin":
            ot.push({ begin: !0 });
            break;
          case "close":
            ot.push({ close: !0 });
            break;
          case "mt":
            ot.push({ start: ht, deltas: [], abs: [] });
            break;
          case "lt":
            var $t = ot.length;
            if (rt[xt - 1] && !isNaN(rt[xt - 1].x) && (ze = [ht.x - rt[xt - 1].x, ht.y - rt[xt - 1].y], $t > 0)) {
              for (; $t >= 0; $t--) if (ot[$t - 1].close !== !0 && ot[$t - 1].begin !== !0) {
                ot[$t - 1].deltas.push(ze), ot[$t - 1].abs.push(ht);
                break;
              }
            }
            break;
          case "bct":
            ze = [ht.x1 - rt[xt - 1].x, ht.y1 - rt[xt - 1].y, ht.x2 - rt[xt - 1].x, ht.y2 - rt[xt - 1].y, ht.x - rt[xt - 1].x, ht.y - rt[xt - 1].y], ot[ot.length - 1].deltas.push(ze);
            break;
          case "qct":
            var Wt = rt[xt - 1].x + 2 / 3 * (ht.x1 - rt[xt - 1].x), on = rt[xt - 1].y + 2 / 3 * (ht.y1 - rt[xt - 1].y), hn = ht.x + 2 / 3 * (ht.x1 - ht.x), wn = ht.y + 2 / 3 * (ht.y1 - ht.y), Bt = ht.x, Ue = ht.y;
            ze = [Wt - rt[xt - 1].x, on - rt[xt - 1].y, hn - rt[xt - 1].x, wn - rt[xt - 1].y, Bt - rt[xt - 1].x, Ue - rt[xt - 1].y], ot[ot.length - 1].deltas.push(ze);
            break;
          case "arc":
            ot.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(ot[ot.length - 1].abs) && ot[ot.length - 1].abs.push(ht);
        }
      }
      Xe = Re ? null : oe === "stroke" ? "stroke" : "fill";
      for (var On = !1, Sn = 0; Sn < ot.length; Sn++) if (ot[Sn].arc) for (var en = ot[Sn].abs, ln = 0; ln < en.length; ln++) {
        var un = en[ln];
        un.type === "arc" ? me.call(this, un.x, un.y, un.radius, un.startAngle, un.endAngle, un.counterclockwise, void 0, Re, !On) : De.call(this, un.x, un.y), On = !0;
      }
      else if (ot[Sn].close === !0) this.pdf.internal.out("h"), On = !1;
      else if (ot[Sn].begin !== !0) {
        var _n = ot[Sn].start.x, Mn = ot[Sn].start.y;
        Me.call(this, ot[Sn].deltas, _n, Mn), On = !0;
      }
      Xe && Ge.call(this, Xe), Re && ke.call(this);
    }
  }, Ae = function(oe) {
    var Re = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, ze = Re * (this.pdf.internal.getLineHeightFactor() - 1);
    switch (this.ctx.textBaseline) {
      case "bottom":
        return oe - ze;
      case "top":
        return oe + Re - ze;
      case "hanging":
        return oe + Re - 2 * ze;
      case "middle":
        return oe + Re / 2 - ze;
      case "ideographic":
        return oe;
      case "alphabetic":
      default:
        return oe;
    }
  }, Te = function(oe) {
    return oe + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
  };
  C.prototype.createLinearGradient = function() {
    var oe = function() {
    };
    return oe.colorStops = [], oe.addColorStop = function(Re, ze) {
      this.colorStops.push([Re, ze]);
    }, oe.getColor = function() {
      return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1];
    }, oe.isCanvasGradient = !0, oe;
  }, C.prototype.createPattern = function() {
    return this.createLinearGradient();
  }, C.prototype.createRadialGradient = function() {
    return this.createLinearGradient();
  };
  var me = function(oe, Re, ze, Xe, ot, rt, xt, ht, $t) {
    for (var Wt = dt.call(this, ze, Xe, ot, rt), on = 0; on < Wt.length; on++) {
      var hn = Wt[on];
      on === 0 && ($t ? pe.call(this, hn.x1 + oe, hn.y1 + Re) : De.call(this, hn.x1 + oe, hn.y1 + Re)), St.call(this, oe, Re, hn.x2, hn.y2, hn.x3, hn.y3, hn.x4, hn.y4);
    }
    ht ? ke.call(this) : Ge.call(this, xt);
  }, Ge = function(oe) {
    switch (oe) {
      case "stroke":
        this.pdf.internal.out("S");
        break;
      case "fill":
        this.pdf.internal.out("f");
    }
  }, ke = function() {
    this.pdf.clip(), this.pdf.discardPath();
  }, pe = function(oe, Re) {
    this.pdf.internal.out(t(oe) + " " + i(Re) + " m");
  }, _e = function(oe) {
    var Re;
    switch (oe.align) {
      case "right":
      case "end":
        Re = "right";
        break;
      case "center":
        Re = "center";
        break;
      case "left":
      case "start":
      default:
        Re = "left";
    }
    var ze = this.pdf.getTextDimensions(oe.text), Xe = Ae.call(this, oe.y), ot = Te.call(this, Xe) - ze.h, rt = this.ctx.transform.applyToPoint(new c(oe.x, Xe)), xt = this.ctx.transform.decompose(), ht = new g();
    ht = (ht = (ht = ht.multiply(xt.translate)).multiply(xt.skew)).multiply(xt.scale);
    for (var $t, Wt, on, hn = this.ctx.transform.applyToRectangle(new a(oe.x, Xe, ze.w, ze.h)), wn = ht.applyToRectangle(new a(oe.x, ot, ze.w, ze.h)), Bt = V.call(this, wn), Ue = [], On = 0; On < Bt.length; On += 1) Ue.indexOf(Bt[On]) === -1 && Ue.push(Bt[On]);
    if (de(Ue), this.autoPaging) for (var Sn = Ue[0], en = Ue[Ue.length - 1], ln = Sn; ln < en + 1; ln++) {
      this.pdf.setPage(ln);
      var un = ln === 1 ? this.posY + this.margin[0] : this.margin[0], _n = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Mn = this.pdf.internal.pageSize.height - this.margin[2], Wn = Mn - this.margin[0], $n = this.pdf.internal.pageSize.width - this.margin[1], Yn = $n - this.margin[3], si = ln === 1 ? 0 : _n + (ln - 2) * Wn;
      if (this.ctx.clip_path.length !== 0) {
        var fi = this.path;
        $t = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = X($t, this.posX + this.margin[3], -1 * si + un), fe.call(this, "fill", !0), this.path = fi;
      }
      var Un = X([JSON.parse(JSON.stringify(wn))], this.posX + this.margin[3], -si + un + this.ctx.prevPageLastElemOffset)[0];
      oe.scale >= 0.01 && (Wt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Wt * oe.scale), on = this.lineWidth, this.lineWidth = on * oe.scale);
      var Jn = this.autoPaging !== "text";
      if (Jn || Un.y + Un.h <= Mn) {
        if (Jn || Un.y >= un && Un.x <= $n) {
          var bn = Jn ? oe.text : this.pdf.splitTextToSize(oe.text, oe.maxWidth || $n - Un.x)[0], tr = X([JSON.parse(JSON.stringify(hn))], this.posX + this.margin[3], -si + un + this.ctx.prevPageLastElemOffset)[0], pi = Jn && (ln > Sn || ln < en) && U.call(this);
          pi && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Yn, Wn, null).clip().discardPath()), this.pdf.text(bn, tr.x, tr.y, { angle: oe.angle, align: Re, renderingMode: oe.renderingMode }), pi && this.pdf.restoreGraphicsState();
        }
      } else Un.y < Mn && (this.ctx.prevPageLastElemOffset += Mn - Un.y);
      oe.scale >= 0.01 && (this.pdf.setFontSize(Wt), this.lineWidth = on);
    }
    else oe.scale >= 0.01 && (Wt = this.pdf.internal.getFontSize(), this.pdf.setFontSize(Wt * oe.scale), on = this.lineWidth, this.lineWidth = on * oe.scale), this.pdf.text(oe.text, rt.x + this.posX, rt.y + this.posY, { angle: oe.angle, align: Re, renderingMode: oe.renderingMode, maxWidth: oe.maxWidth }), oe.scale >= 0.01 && (this.pdf.setFontSize(Wt), this.lineWidth = on);
  }, De = function(oe, Re, ze, Xe) {
    ze = ze || 0, Xe = Xe || 0, this.pdf.internal.out(t(oe + ze) + " " + i(Re + Xe) + " l");
  }, Me = function(oe, Re, ze) {
    return this.pdf.lines(oe, Re, ze, null, null);
  }, St = function(oe, Re, ze, Xe, ot, rt, xt, ht) {
    this.pdf.internal.out([e(r(ze + oe)), e(l(Xe + Re)), e(r(ot + oe)), e(l(rt + Re)), e(r(xt + oe)), e(l(ht + Re)), "c"].join(" "));
  }, dt = function(oe, Re, ze, Xe) {
    for (var ot = 2 * Math.PI, rt = Math.PI / 2; Re > ze; ) Re -= ot;
    var xt = Math.abs(ze - Re);
    xt < ot && Xe && (xt = ot - xt);
    for (var ht = [], $t = Xe ? -1 : 1, Wt = Re; xt > 1e-5; ) {
      var on = Wt + $t * Math.min(xt, rt);
      ht.push(Pt.call(this, oe, Wt, on)), xt -= Math.abs(on - Wt), Wt = on;
    }
    return ht;
  }, Pt = function(oe, Re, ze) {
    var Xe = (ze - Re) / 2, ot = oe * Math.cos(Xe), rt = oe * Math.sin(Xe), xt = ot, ht = -rt, $t = xt * xt + ht * ht, Wt = $t + xt * ot + ht * rt, on = 4 / 3 * (Math.sqrt(2 * $t * Wt) - Wt) / (xt * rt - ht * ot), hn = xt - on * ht, wn = ht + on * xt, Bt = hn, Ue = -wn, On = Xe + Re, Sn = Math.cos(On), en = Math.sin(On);
    return { x1: oe * Math.cos(Re), y1: oe * Math.sin(Re), x2: hn * Sn - wn * en, y2: hn * en + wn * Sn, x3: Bt * Sn - Ue * en, y3: Bt * en + Ue * Sn, x4: oe * Math.cos(ze), y4: oe * Math.sin(ze) };
  }, gt = function(oe) {
    return 180 * oe / Math.PI;
  }, Rt = function(oe, Re, ze, Xe, ot, rt) {
    var xt = oe + 0.5 * (ze - oe), ht = Re + 0.5 * (Xe - Re), $t = ot + 0.5 * (ze - ot), Wt = rt + 0.5 * (Xe - rt), on = Math.min(oe, ot, xt, $t), hn = Math.max(oe, ot, xt, $t), wn = Math.min(Re, rt, ht, Wt), Bt = Math.max(Re, rt, ht, Wt);
    return new a(on, wn, hn - on, Bt - wn);
  }, Ft = function(oe, Re, ze, Xe, ot, rt, xt, ht) {
    var $t, Wt, on, hn, wn, Bt, Ue, On, Sn, en, ln, un, _n, Mn, Wn = ze - oe, $n = Xe - Re, Yn = ot - ze, si = rt - Xe, fi = xt - ot, Un = ht - rt;
    for (Wt = 0; Wt < 41; Wt++) Sn = (Ue = (on = oe + ($t = Wt / 40) * Wn) + $t * ((wn = ze + $t * Yn) - on)) + $t * (wn + $t * (ot + $t * fi - wn) - Ue), en = (On = (hn = Re + $t * $n) + $t * ((Bt = Xe + $t * si) - hn)) + $t * (Bt + $t * (rt + $t * Un - Bt) - On), Wt == 0 ? (ln = Sn, un = en, _n = Sn, Mn = en) : (ln = Math.min(ln, Sn), un = Math.min(un, en), _n = Math.max(_n, Sn), Mn = Math.max(Mn, en));
    return new a(Math.round(ln), Math.round(un), Math.round(_n - ln), Math.round(Mn - un));
  }, mn = function() {
    if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
      var oe, Re, ze = (oe = this.ctx.lineDash, Re = this.ctx.lineDashOffset, JSON.stringify({ lineDash: oe, lineDashOffset: Re }));
      this.prevLineDash !== ze && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = ze);
    }
  };
})(ti.API), /**
* @license
* jsPDF filters PlugIn
* Copyright (c) 2014 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function(l) {
    var c, a, g, y, A, C, I, S, F, U;
    for (a = [], g = 0, y = (l += c = "\0\0\0\0".slice(l.length % 4 || 4)).length; y > g; g += 4) (A = (l.charCodeAt(g) << 24) + (l.charCodeAt(g + 1) << 16) + (l.charCodeAt(g + 2) << 8) + l.charCodeAt(g + 3)) !== 0 ? (C = (A = ((A = ((A = ((A = (A - (U = A % 85)) / 85) - (F = A % 85)) / 85) - (S = A % 85)) / 85) - (I = A % 85)) / 85) % 85, a.push(C + 33, I + 33, S + 33, F + 33, U + 33)) : a.push(122);
    return function(V, W) {
      for (var X = W; X > 0; X--) V.pop();
    }(a, c.length), String.fromCharCode.apply(String, a) + "~>";
  }, t = function(l) {
    var c, a, g, y, A, C = String, I = "length", S = 255, F = "charCodeAt", U = "slice", V = "replace";
    for (l[U](-2), l = l[U](0, -2)[V](/\s/g, "")[V]("z", "!!!!!"), g = [], y = 0, A = (l += c = "uuuuu"[U](l[I] % 5 || 5))[I]; A > y; y += 5) a = 52200625 * (l[F](y) - 33) + 614125 * (l[F](y + 1) - 33) + 7225 * (l[F](y + 2) - 33) + 85 * (l[F](y + 3) - 33) + (l[F](y + 4) - 33), g.push(S & a >> 24, S & a >> 16, S & a >> 8, S & a);
    return function(W, X) {
      for (var de = X; de > 0; de--) W.pop();
    }(g, c[I]), C.fromCharCode.apply(C, g);
  }, i = function(l) {
    var c = new RegExp(/^([0-9A-Fa-f]{2})+$/);
    if ((l = l.replace(/\s/g, "")).indexOf(">") !== -1 && (l = l.substr(0, l.indexOf(">"))), l.length % 2 && (l += "0"), c.test(l) === !1) return "";
    for (var a = "", g = 0; g < l.length; g += 2) a += String.fromCharCode("0x" + (l[g] + l[g + 1]));
    return a;
  }, r = function(l) {
    for (var c = new Uint8Array(l.length), a = l.length; a--; ) c[a] = l.charCodeAt(a);
    return l = (c = E1(c)).reduce(function(g, y) {
      return g + String.fromCharCode(y);
    }, "");
  };
  n.processDataByFilters = function(l, c) {
    var a = 0, g = l || "", y = [];
    for (typeof (c = c || []) == "string" && (c = [c]), a = 0; a < c.length; a += 1) switch (c[a]) {
      case "ASCII85Decode":
      case "/ASCII85Decode":
        g = t(g), y.push("/ASCII85Encode");
        break;
      case "ASCII85Encode":
      case "/ASCII85Encode":
        g = e(g), y.push("/ASCII85Decode");
        break;
      case "ASCIIHexDecode":
      case "/ASCIIHexDecode":
        g = i(g), y.push("/ASCIIHexEncode");
        break;
      case "ASCIIHexEncode":
      case "/ASCIIHexEncode":
        g = g.split("").map(function(A) {
          return ("0" + A.charCodeAt().toString(16)).slice(-2);
        }).join("") + ">", y.push("/ASCIIHexDecode");
        break;
      case "FlateEncode":
      case "/FlateEncode":
        g = r(g), y.push("/FlateDecode");
        break;
      default:
        throw new Error('The filter: "' + c[a] + '" is not implemented');
    }
    return { data: g, reverseChain: y.reverse().join(" ") };
  };
}(ti.API), /**
* @license
* jsPDF fileloading PlugIn
* Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  n.loadFile = function(e, t, i) {
    return function(r, l, c) {
      l = l !== !1, c = typeof c == "function" ? c : function() {
      };
      var a = void 0;
      try {
        a = function(g, y, A) {
          var C = new XMLHttpRequest(), I = 0, S = function(F) {
            var U = F.length, V = [], W = String.fromCharCode;
            for (I = 0; I < U; I += 1) V.push(W(255 & F.charCodeAt(I)));
            return V.join("");
          };
          if (C.open("GET", g, !y), C.overrideMimeType("text/plain; charset=x-user-defined"), y === !1 && (C.onload = function() {
            C.status === 200 ? A(S(this.responseText)) : A(void 0);
          }), C.send(null), y && C.status === 200) return S(C.responseText);
        }(r, l, c);
      } catch {
      }
      return a;
    }(e, t, i);
  }, n.loadImageFile = n.loadFile;
}(ti.API), function(n) {
  function e() {
    return (ni.html2canvas ? Promise.resolve(ni.html2canvas) : import("./html2canvas.esm-Dr4iCOK6-Bfz6BEVf.mjs")).catch(function(c) {
      return Promise.reject(new Error("Could not load html2canvas: " + c));
    }).then(function(c) {
      return c.default ? c.default : c;
    });
  }
  function t() {
    return (ni.DOMPurify ? Promise.resolve(ni.DOMPurify) : import("./purify.es-CKk_t3XZ-2nNQNeDh.mjs")).catch(function(c) {
      return Promise.reject(new Error("Could not load dompurify: " + c));
    }).then(function(c) {
      return c.default ? c.default : c;
    });
  }
  var i = function(c) {
    var a = or(c);
    return a === "undefined" ? "undefined" : a === "string" || c instanceof String ? "string" : a === "number" || c instanceof Number ? "number" : a === "function" || c instanceof Function ? "function" : c && c.constructor === Array ? "array" : c && c.nodeType === 1 ? "element" : a === "object" ? "object" : "unknown";
  }, r = function(c, a) {
    var g = document.createElement(c);
    for (var y in a.className && (g.className = a.className), a.innerHTML && a.dompurify && (g.innerHTML = a.dompurify.sanitize(a.innerHTML)), a.style) g.style[y] = a.style[y];
    return g;
  }, l = function c(a) {
    var g = Object.assign(c.convert(Promise.resolve()), JSON.parse(JSON.stringify(c.template))), y = c.convert(Promise.resolve(), g);
    return y = (y = y.setProgress(1, c, 1, [c])).set(a);
  };
  (l.prototype = Object.create(Promise.prototype)).constructor = l, l.convert = function(c, a) {
    return c.__proto__ = a || l.prototype, c;
  }, l.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
  } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, l.prototype.from = function(c, a) {
    return this.then(function() {
      switch (a = a || function(g) {
        switch (i(g)) {
          case "string":
            return "string";
          case "element":
            return g.nodeName.toLowerCase() === "canvas" ? "canvas" : "element";
          default:
            return "unknown";
        }
      }(c)) {
        case "string":
          return this.then(t).then(function(g) {
            return this.set({ src: r("div", { innerHTML: c, dompurify: g }) });
          });
        case "element":
          return this.set({ src: c });
        case "canvas":
          return this.set({ canvas: c });
        case "img":
          return this.set({ img: c });
        default:
          return this.error("Unknown source type.");
      }
    });
  }, l.prototype.to = function(c) {
    switch (c) {
      case "container":
        return this.toContainer();
      case "canvas":
        return this.toCanvas();
      case "img":
        return this.toImg();
      case "pdf":
        return this.toPdf();
      default:
        return this.error("Invalid target.");
    }
  }, l.prototype.toContainer = function() {
    return this.thenList([function() {
      return this.prop.src || this.error("Cannot duplicate - no source HTML.");
    }, function() {
      return this.prop.pageSize || this.setPageSize();
    }]).then(function() {
      var c = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, a = function g(y, A) {
        for (var C = y.nodeType === 3 ? document.createTextNode(y.nodeValue) : y.cloneNode(!1), I = y.firstChild; I; I = I.nextSibling) A !== !0 && I.nodeType === 1 && I.nodeName === "SCRIPT" || C.appendChild(g(I, A));
        return y.nodeType === 1 && (y.nodeName === "CANVAS" ? (C.width = y.width, C.height = y.height, C.getContext("2d").drawImage(y, 0, 0)) : y.nodeName !== "TEXTAREA" && y.nodeName !== "SELECT" || (C.value = y.value), C.addEventListener("load", function() {
          C.scrollTop = y.scrollTop, C.scrollLeft = y.scrollLeft;
        }, !0)), C;
      }(this.prop.src, this.opt.html2canvas.javascriptEnabled);
      a.tagName === "BODY" && (c.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = r("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = r("div", { className: "html2pdf__container", style: c }), this.prop.container.appendChild(a), this.prop.container.firstChild.appendChild(r("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
    });
  }, l.prototype.toCanvas = function() {
    var c = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(c).then(e).then(function(a) {
      var g = Object.assign({}, this.opt.html2canvas);
      return delete g.onrendered, a(this.prop.container, g);
    }).then(function(a) {
      (this.opt.html2canvas.onrendered || function() {
      })(a), this.prop.canvas = a, document.body.removeChild(this.prop.overlay);
    });
  }, l.prototype.toContext2d = function() {
    var c = [function() {
      return document.body.contains(this.prop.container) || this.toContainer();
    }];
    return this.thenList(c).then(e).then(function(a) {
      var g = this.opt.jsPDF, y = this.opt.fontFaces, A = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, C = Object.assign({ async: !0, allowTaint: !0, scale: A, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas);
      if (delete C.onrendered, g.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, g.context2d.posX = this.opt.x, g.context2d.posY = this.opt.y, g.context2d.margin = this.opt.margin, g.context2d.fontFaces = y, y) for (var I = 0; I < y.length; ++I) {
        var S = y[I], F = S.src.find(function(U) {
          return U.format === "truetype";
        });
        F && g.addFont(F.url, S.ref.name, S.ref.style);
      }
      return C.windowHeight = C.windowHeight || 0, C.windowHeight = C.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : C.windowHeight, g.context2d.save(!0), a(this.prop.container, C);
    }).then(function(a) {
      this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function() {
      })(a), this.prop.canvas = a, document.body.removeChild(this.prop.overlay);
    });
  }, l.prototype.toImg = function() {
    return this.thenList([function() {
      return this.prop.canvas || this.toCanvas();
    }]).then(function() {
      var c = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
      this.prop.img = document.createElement("img"), this.prop.img.src = c;
    });
  }, l.prototype.toPdf = function() {
    return this.thenList([function() {
      return this.toContext2d();
    }]).then(function() {
      this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
    });
  }, l.prototype.output = function(c, a, g) {
    return (g = g || "pdf").toLowerCase() === "img" || g.toLowerCase() === "image" ? this.outputImg(c, a) : this.outputPdf(c, a);
  }, l.prototype.outputPdf = function(c, a) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      return this.prop.pdf.output(c, a);
    });
  }, l.prototype.outputImg = function(c) {
    return this.thenList([function() {
      return this.prop.img || this.toImg();
    }]).then(function() {
      switch (c) {
        case void 0:
        case "img":
          return this.prop.img;
        case "datauristring":
        case "dataurlstring":
          return this.prop.img.src;
        case "datauri":
        case "dataurl":
          return document.location.href = this.prop.img.src;
        default:
          throw 'Image output type "' + c + '" is not supported.';
      }
    });
  }, l.prototype.save = function(c) {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).set(c ? { filename: c } : null).then(function() {
      this.prop.pdf.save(this.opt.filename);
    });
  }, l.prototype.doCallback = function() {
    return this.thenList([function() {
      return this.prop.pdf || this.toPdf();
    }]).then(function() {
      this.prop.callback(this.prop.pdf);
    });
  }, l.prototype.set = function(c) {
    if (i(c) !== "object") return this;
    var a = Object.keys(c || {}).map(function(g) {
      if (g in l.template.prop) return function() {
        this.prop[g] = c[g];
      };
      switch (g) {
        case "margin":
          return this.setMargin.bind(this, c.margin);
        case "jsPDF":
          return function() {
            return this.opt.jsPDF = c.jsPDF, this.setPageSize();
          };
        case "pageSize":
          return this.setPageSize.bind(this, c.pageSize);
        default:
          return function() {
            this.opt[g] = c[g];
          };
      }
    }, this);
    return this.then(function() {
      return this.thenList(a);
    });
  }, l.prototype.get = function(c, a) {
    return this.then(function() {
      var g = c in l.template.prop ? this.prop[c] : this.opt[c];
      return a ? a(g) : g;
    });
  }, l.prototype.setMargin = function(c) {
    return this.then(function() {
      switch (i(c)) {
        case "number":
          c = [c, c, c, c];
        case "array":
          if (c.length === 2 && (c = [c[0], c[1], c[0], c[1]]), c.length === 4) break;
        default:
          return this.error("Invalid margin array.");
      }
      this.opt.margin = c;
    }).then(this.setPageSize);
  }, l.prototype.setPageSize = function(c) {
    function a(g, y) {
      return Math.floor(g * y / 72 * 96);
    }
    return this.then(function() {
      (c = c || ti.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (c.inner = { width: c.width - this.opt.margin[1] - this.opt.margin[3], height: c.height - this.opt.margin[0] - this.opt.margin[2] }, c.inner.px = { width: a(c.inner.width, c.k), height: a(c.inner.height, c.k) }, c.inner.ratio = c.inner.height / c.inner.width), this.prop.pageSize = c;
    });
  }, l.prototype.setProgress = function(c, a, g, y) {
    return c != null && (this.progress.val = c), a != null && (this.progress.state = a), g != null && (this.progress.n = g), y != null && (this.progress.stack = y), this.progress.ratio = this.progress.val / this.progress.state, this;
  }, l.prototype.updateProgress = function(c, a, g, y) {
    return this.setProgress(c ? this.progress.val + c : null, a || null, g ? this.progress.n + g : null, y ? this.progress.stack.concat(y) : null);
  }, l.prototype.then = function(c, a) {
    var g = this;
    return this.thenCore(c, a, function(y, A) {
      return g.updateProgress(null, null, 1, [y]), Promise.prototype.then.call(this, function(C) {
        return g.updateProgress(null, y), C;
      }).then(y, A).then(function(C) {
        return g.updateProgress(1), C;
      });
    });
  }, l.prototype.thenCore = function(c, a, g) {
    g = g || Promise.prototype.then, c && (c = c.bind(this)), a && (a = a.bind(this));
    var y = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : l.convert(Object.assign({}, this), Promise.prototype), A = g.call(y, c, a);
    return l.convert(A, this.__proto__);
  }, l.prototype.thenExternal = function(c, a) {
    return Promise.prototype.then.call(this, c, a);
  }, l.prototype.thenList = function(c) {
    var a = this;
    return c.forEach(function(g) {
      a = a.thenCore(g);
    }), a;
  }, l.prototype.catch = function(c) {
    c && (c = c.bind(this));
    var a = Promise.prototype.catch.call(this, c);
    return l.convert(a, this);
  }, l.prototype.catchExternal = function(c) {
    return Promise.prototype.catch.call(this, c);
  }, l.prototype.error = function(c) {
    return this.then(function() {
      throw new Error(c);
    });
  }, l.prototype.using = l.prototype.set, l.prototype.saveAs = l.prototype.save, l.prototype.export = l.prototype.output, l.prototype.run = l.prototype.then, ti.getPageSize = function(c, a, g) {
    if (or(c) === "object") {
      var y = c;
      c = y.orientation, a = y.unit || a, g = y.format || g;
    }
    a = a || "mm", g = g || "a4", c = ("" + (c || "P")).toLowerCase();
    var A, C = ("" + g).toLowerCase(), I = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    switch (a) {
      case "pt":
        A = 1;
        break;
      case "mm":
        A = 72 / 25.4;
        break;
      case "cm":
        A = 72 / 2.54;
        break;
      case "in":
        A = 72;
        break;
      case "px":
        A = 0.75;
        break;
      case "pc":
      case "em":
        A = 12;
        break;
      case "ex":
        A = 6;
        break;
      default:
        throw "Invalid unit: " + a;
    }
    var S, F = 0, U = 0;
    if (I.hasOwnProperty(C)) F = I[C][1] / A, U = I[C][0] / A;
    else try {
      F = g[1], U = g[0];
    } catch {
      throw new Error("Invalid format: " + g);
    }
    if (c === "p" || c === "portrait") c = "p", U > F && (S = U, U = F, F = S);
    else {
      if (c !== "l" && c !== "landscape") throw "Invalid orientation: " + c;
      c = "l", F > U && (S = U, U = F, F = S);
    }
    return { width: U, height: F, unit: a, k: A, orientation: c };
  }, n.html = function(c, a) {
    (a = a || {}).callback = a.callback || function() {
    }, a.html2canvas = a.html2canvas || {}, a.html2canvas.canvas = a.html2canvas.canvas || this.canvas, a.jsPDF = a.jsPDF || this, a.fontFaces = a.fontFaces ? a.fontFaces.map(L1) : null;
    var g = new l(a);
    return a.worker ? g : g.from(c).doCallback();
  };
}(ti.API), ti.API.addJS = function(n) {
  return C5 = n, this.internal.events.subscribe("postPutResources", function() {
    Jg = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Jg + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), S5 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + C5 + ")"), this.internal.out(">>"), this.internal.out("endobj");
  }), this.internal.events.subscribe("putCatalog", function() {
    Jg !== void 0 && S5 !== void 0 && this.internal.out("/Names <</JavaScript " + Jg + " 0 R>>");
  }), this;
}, /**
* @license
* Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e;
  n.events.push(["postPutResources", function() {
    var t = this, i = /^(\d+) 0 obj$/;
    if (this.outline.root.children.length > 0) for (var r = t.outline.render().split(/\r\n/), l = 0; l < r.length; l++) {
      var c = r[l], a = i.exec(c);
      if (a != null) {
        var g = a[1];
        t.internal.newObjectDeferredBegin(g, !1);
      }
      t.internal.write(c);
    }
    if (this.outline.createNamedDestinations) {
      var y = this.internal.pages.length, A = [];
      for (l = 0; l < y; l++) {
        var C = t.internal.newObject();
        A.push(C);
        var I = t.internal.getPageInfo(l + 1);
        t.internal.write("<< /D[" + I.objId + " 0 R /XYZ null null null]>> endobj");
      }
      var S = t.internal.newObject();
      for (t.internal.write("<< /Names [ "), l = 0; l < A.length; l++) t.internal.write("(page_" + (l + 1) + ")" + A[l] + " 0 R");
      t.internal.write(" ] >>", "endobj"), e = t.internal.newObject(), t.internal.write("<< /Dests " + S + " 0 R"), t.internal.write(">>", "endobj");
    }
  }]), n.events.push(["putCatalog", function() {
    this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + e + " 0 R"));
  }]), n.events.push(["initialized", function() {
    var t = this;
    t.outline = { createNamedDestinations: !1, root: { children: [] } }, t.outline.add = function(i, r, l) {
      var c = { title: r, options: l, children: [] };
      return i == null && (i = this.root), i.children.push(c), c;
    }, t.outline.render = function() {
      return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
    }, t.outline.genIds_r = function(i) {
      i.id = t.internal.newObjectDeferred();
      for (var r = 0; r < i.children.length; r++) this.genIds_r(i.children[r]);
    }, t.outline.renderRoot = function(i) {
      this.objStart(i), this.line("/Type /Outlines"), i.children.length > 0 && (this.line("/First " + this.makeRef(i.children[0])), this.line("/Last " + this.makeRef(i.children[i.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, i)), this.objEnd();
    }, t.outline.renderItems = function(i) {
      for (var r = this.ctx.pdf.internal.getVerticalCoordinateString, l = 0; l < i.children.length; l++) {
        var c = i.children[l];
        this.objStart(c), this.line("/Title " + this.makeString(c.title)), this.line("/Parent " + this.makeRef(i)), l > 0 && this.line("/Prev " + this.makeRef(i.children[l - 1])), l < i.children.length - 1 && this.line("/Next " + this.makeRef(i.children[l + 1])), c.children.length > 0 && (this.line("/First " + this.makeRef(c.children[0])), this.line("/Last " + this.makeRef(c.children[c.children.length - 1])));
        var a = this.count = this.count_r({ count: 0 }, c);
        if (a > 0 && this.line("/Count " + a), c.options && c.options.pageNumber) {
          var g = t.internal.getPageInfo(c.options.pageNumber);
          this.line("/Dest [" + g.objId + " 0 R /XYZ 0 " + r(0) + " 0]");
        }
        this.objEnd();
      }
      for (var y = 0; y < i.children.length; y++) this.renderItems(i.children[y]);
    }, t.outline.line = function(i) {
      this.ctx.val += i + `\r
`;
    }, t.outline.makeRef = function(i) {
      return i.id + " 0 R";
    }, t.outline.makeString = function(i) {
      return "(" + t.internal.pdfEscape(i) + ")";
    }, t.outline.objStart = function(i) {
      this.ctx.val += `\r
` + i.id + ` 0 obj\r
<<\r
`;
    }, t.outline.objEnd = function() {
      this.ctx.val += `>> \r
endobj\r
`;
    }, t.outline.count_r = function(i, r) {
      for (var l = 0; l < r.children.length; l++) i.count++, this.count_r(i, r.children[l]);
      return i.count;
    };
  }]);
}(ti.API), /**
* @license
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = [192, 193, 194, 195, 196, 197, 198, 199];
  n.processJPEG = function(t, i, r, l, c, a) {
    var g, y = this.decode.DCT_DECODE, A = null;
    if (typeof t == "string" || this.__addimage__.isArrayBuffer(t) || this.__addimage__.isArrayBufferView(t)) {
      switch (t = c || t, t = this.__addimage__.isArrayBuffer(t) ? new Uint8Array(t) : t, (g = function(C) {
        for (var I, S = 256 * C.charCodeAt(4) + C.charCodeAt(5), F = C.length, U = { width: 0, height: 0, numcomponents: 1 }, V = 4; V < F; V += 2) {
          if (V += S, e.indexOf(C.charCodeAt(V + 1)) !== -1) {
            I = 256 * C.charCodeAt(V + 5) + C.charCodeAt(V + 6), U = { width: 256 * C.charCodeAt(V + 7) + C.charCodeAt(V + 8), height: I, numcomponents: C.charCodeAt(V + 9) };
            break;
          }
          S = 256 * C.charCodeAt(V + 2) + C.charCodeAt(V + 3);
        }
        return U;
      }(t = this.__addimage__.isArrayBufferView(t) ? this.__addimage__.arrayBufferToBinaryString(t) : t)).numcomponents) {
        case 1:
          a = this.color_spaces.DEVICE_GRAY;
          break;
        case 4:
          a = this.color_spaces.DEVICE_CMYK;
          break;
        case 3:
          a = this.color_spaces.DEVICE_RGB;
      }
      A = { data: t, width: g.width, height: g.height, colorSpace: a, bitsPerComponent: 8, filter: y, index: i, alias: r };
    }
    return A;
  };
}(ti.API);
var Nd, Kg, I5, M5, L5, nq = function() {
  var n, e, t;
  function i(l) {
    var c, a, g, y, A, C, I, S, F, U, V, W, X, de;
    for (this.data = l, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, C = null; ; ) {
      switch (c = this.readUInt32(), F = (function() {
        var ie, fe;
        for (fe = [], ie = 0; ie < 4; ++ie) fe.push(String.fromCharCode(this.data[this.pos++]));
        return fe;
      }).call(this).join("")) {
        case "IHDR":
          this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
          break;
        case "acTL":
          this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] };
          break;
        case "PLTE":
          this.palette = this.read(c);
          break;
        case "fcTL":
          C && this.animation.frames.push(C), this.pos += 4, C = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, A = this.readUInt16(), y = this.readUInt16() || 100, C.delay = 1e3 * A / y, C.disposeOp = this.data[this.pos++], C.blendOp = this.data[this.pos++], C.data = [];
          break;
        case "IDAT":
        case "fdAT":
          for (F === "fdAT" && (this.pos += 4, c -= 4), l = (C != null ? C.data : void 0) || this.imgData, W = 0; 0 <= c ? W < c : W > c; 0 <= c ? ++W : --W) l.push(this.data[this.pos++]);
          break;
        case "tRNS":
          switch (this.transparency = {}, this.colorType) {
            case 3:
              if (g = this.palette.length / 3, this.transparency.indexed = this.read(c), this.transparency.indexed.length > g) throw new Error("More transparent colors than palette size");
              if ((U = g - this.transparency.indexed.length) > 0) for (X = 0; 0 <= U ? X < U : X > U; 0 <= U ? ++X : --X) this.transparency.indexed.push(255);
              break;
            case 0:
              this.transparency.grayscale = this.read(c)[0];
              break;
            case 2:
              this.transparency.rgb = this.read(c);
          }
          break;
        case "tEXt":
          I = (V = this.read(c)).indexOf(0), S = String.fromCharCode.apply(String, V.slice(0, I)), this.text[S] = String.fromCharCode.apply(String, V.slice(I + 1));
          break;
        case "IEND":
          return C && this.animation.frames.push(C), this.colors = (function() {
            switch (this.colorType) {
              case 0:
              case 3:
              case 4:
                return 1;
              case 2:
              case 6:
                return 3;
            }
          }).call(this), this.hasAlphaChannel = (de = this.colorType) === 4 || de === 6, a = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * a, this.colorSpace = (function() {
            switch (this.colors) {
              case 1:
                return "DeviceGray";
              case 3:
                return "DeviceRGB";
            }
          }).call(this), void (this.imgData = new Uint8Array(this.imgData));
        default:
          this.pos += c;
      }
      if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file");
    }
  }
  i.prototype.read = function(l) {
    var c, a;
    for (a = [], c = 0; 0 <= l ? c < l : c > l; 0 <= l ? ++c : --c) a.push(this.data[this.pos++]);
    return a;
  }, i.prototype.readUInt32 = function() {
    return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.readUInt16 = function() {
    return this.data[this.pos++] << 8 | this.data[this.pos++];
  }, i.prototype.decodePixels = function(l) {
    var c = this.pixelBitlength / 8, a = new Uint8Array(this.width * this.height * c), g = 0, y = this;
    if (l == null && (l = this.imgData), l.length === 0) return new Uint8Array(0);
    function A(C, I, S, F) {
      var U, V, W, X, de, ie, fe, Ae, Te, me, Ge, ke, pe, _e, De, Me, St, dt, Pt, gt, Rt, Ft = Math.ceil((y.width - C) / S), mn = Math.ceil((y.height - I) / F), oe = y.width == Ft && y.height == mn;
      for (_e = c * Ft, ke = oe ? a : new Uint8Array(_e * mn), ie = l.length, pe = 0, V = 0; pe < mn && g < ie; ) {
        switch (l[g++]) {
          case 0:
            for (X = St = 0; St < _e; X = St += 1) ke[V++] = l[g++];
            break;
          case 1:
            for (X = dt = 0; dt < _e; X = dt += 1) U = l[g++], de = X < c ? 0 : ke[V - c], ke[V++] = (U + de) % 256;
            break;
          case 2:
            for (X = Pt = 0; Pt < _e; X = Pt += 1) U = l[g++], W = (X - X % c) / c, De = pe && ke[(pe - 1) * _e + W * c + X % c], ke[V++] = (De + U) % 256;
            break;
          case 3:
            for (X = gt = 0; gt < _e; X = gt += 1) U = l[g++], W = (X - X % c) / c, de = X < c ? 0 : ke[V - c], De = pe && ke[(pe - 1) * _e + W * c + X % c], ke[V++] = (U + Math.floor((de + De) / 2)) % 256;
            break;
          case 4:
            for (X = Rt = 0; Rt < _e; X = Rt += 1) U = l[g++], W = (X - X % c) / c, de = X < c ? 0 : ke[V - c], pe === 0 ? De = Me = 0 : (De = ke[(pe - 1) * _e + W * c + X % c], Me = W && ke[(pe - 1) * _e + (W - 1) * c + X % c]), fe = de + De - Me, Ae = Math.abs(fe - de), me = Math.abs(fe - De), Ge = Math.abs(fe - Me), Te = Ae <= me && Ae <= Ge ? de : me <= Ge ? De : Me, ke[V++] = (U + Te) % 256;
            break;
          default:
            throw new Error("Invalid filter algorithm: " + l[g - 1]);
        }
        if (!oe) {
          var Re = ((I + pe * F) * y.width + C) * c, ze = pe * _e;
          for (X = 0; X < Ft; X += 1) {
            for (var Xe = 0; Xe < c; Xe += 1) a[Re++] = ke[ze++];
            Re += (S - 1) * c;
          }
        }
        pe++;
      }
    }
    return l = OV(l), y.interlaceMethod == 1 ? (A(0, 0, 8, 8), A(4, 0, 8, 8), A(0, 4, 4, 8), A(2, 0, 4, 4), A(0, 2, 2, 4), A(1, 0, 2, 2), A(0, 1, 1, 2)) : A(0, 0, 1, 1), a;
  }, i.prototype.decodePalette = function() {
    var l, c, a, g, y, A, C, I, S;
    for (a = this.palette, A = this.transparency.indexed || [], y = new Uint8Array((A.length || 0) + a.length), g = 0, l = 0, c = C = 0, I = a.length; C < I; c = C += 3) y[g++] = a[c], y[g++] = a[c + 1], y[g++] = a[c + 2], y[g++] = (S = A[l++]) != null ? S : 255;
    return y;
  }, i.prototype.copyToImageData = function(l, c) {
    var a, g, y, A, C, I, S, F, U, V, W;
    if (g = this.colors, U = null, a = this.hasAlphaChannel, this.palette.length && (U = (W = this._decodedPalette) != null ? W : this._decodedPalette = this.decodePalette(), g = 4, a = !0), F = (y = l.data || l).length, C = U || c, A = I = 0, g === 1) for (; A < F; ) S = U ? 4 * c[A / 4] : I, V = C[S++], y[A++] = V, y[A++] = V, y[A++] = V, y[A++] = a ? C[S++] : 255, I = S;
    else for (; A < F; ) S = U ? 4 * c[A / 4] : I, y[A++] = C[S++], y[A++] = C[S++], y[A++] = C[S++], y[A++] = a ? C[S++] : 255, I = S;
  }, i.prototype.decode = function() {
    var l;
    return l = new Uint8Array(this.width * this.height * 4), this.copyToImageData(l, this.decodePixels()), l;
  };
  var r = function() {
    if (Object.prototype.toString.call(ni) === "[object Window]") {
      try {
        e = ni.document.createElement("canvas"), t = e.getContext("2d");
      } catch {
        return !1;
      }
      return !0;
    }
    return !1;
  };
  return r(), n = function(l) {
    var c;
    if (r() === !0) return t.width = l.width, t.height = l.height, t.clearRect(0, 0, l.width, l.height), t.putImageData(l, 0, 0), (c = new Image()).src = e.toDataURL(), c;
    throw new Error("This method requires a Browser with Canvas-capability.");
  }, i.prototype.decodeFrames = function(l) {
    var c, a, g, y, A, C, I, S;
    if (this.animation) {
      for (S = [], a = A = 0, C = (I = this.animation.frames).length; A < C; a = ++A) c = I[a], g = l.createImageData(c.width, c.height), y = this.decodePixels(new Uint8Array(c.data)), this.copyToImageData(g, y), c.imageData = g, S.push(c.image = n(g));
      return S;
    }
  }, i.prototype.renderFrame = function(l, c) {
    var a, g, y;
    return a = (g = this.animation.frames)[c], y = g[c - 1], c === 0 && l.clearRect(0, 0, this.width, this.height), (y != null ? y.disposeOp : void 0) === 1 ? l.clearRect(y.xOffset, y.yOffset, y.width, y.height) : (y != null ? y.disposeOp : void 0) === 2 && l.putImageData(y.imageData, y.xOffset, y.yOffset), a.blendOp === 0 && l.clearRect(a.xOffset, a.yOffset, a.width, a.height), l.drawImage(a.image, a.xOffset, a.yOffset);
  }, i.prototype.animate = function(l) {
    var c, a, g, y, A, C, I = this;
    return a = 0, C = this.animation, y = C.numFrames, g = C.frames, A = C.numPlays, (c = function() {
      var S, F;
      if (S = a++ % y, F = g[S], I.renderFrame(l, S), y > 1 && a / y < A) return I.animation._timeout = setTimeout(c, F.delay);
    })();
  }, i.prototype.stopAnimation = function() {
    var l;
    return clearTimeout((l = this.animation) != null ? l._timeout : void 0);
  }, i.prototype.render = function(l) {
    var c, a;
    return l._png && l._png.stopAnimation(), l._png = this, l.width = this.width, l.height = this.height, c = l.getContext("2d"), this.animation ? (this.decodeFrames(c), this.animate(c)) : (a = c.createImageData(this.width, this.height), this.copyToImageData(a, this.decodePixels()), c.putImageData(a, 0, 0));
  }, i;
}();
/**
* @license
*
* Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
/**
* @license
* (c) Dean McNamee <dean@gmail.com>, 2013.
*
* https://github.com/deanm/omggif
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to
* deal in the Software without restriction, including without limitation the
* rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
* sell copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
* IN THE SOFTWARE.
*
* omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
* including animation and compression.  It does not rely on any specific
* underlying system, so should run in the browser, Node, or Plask.
*/
function iq(n) {
  var e = 0;
  if (n[e++] !== 71 || n[e++] !== 73 || n[e++] !== 70 || n[e++] !== 56 || (n[e++] + 1 & 253) != 56 || n[e++] !== 97) throw new Error("Invalid GIF 87a/89a header.");
  var t = n[e++] | n[e++] << 8, i = n[e++] | n[e++] << 8, r = n[e++], l = r >> 7, c = 1 << (7 & r) + 1;
  n[e++], n[e++];
  var a = null, g = null;
  l && (a = e, g = c, e += 3 * c);
  var y = !0, A = [], C = 0, I = null, S = 0, F = null;
  for (this.width = t, this.height = i; y && e < n.length; ) switch (n[e++]) {
    case 33:
      switch (n[e++]) {
        case 255:
          if (n[e] !== 11 || n[e + 1] == 78 && n[e + 2] == 69 && n[e + 3] == 84 && n[e + 4] == 83 && n[e + 5] == 67 && n[e + 6] == 65 && n[e + 7] == 80 && n[e + 8] == 69 && n[e + 9] == 50 && n[e + 10] == 46 && n[e + 11] == 48 && n[e + 12] == 3 && n[e + 13] == 1 && n[e + 16] == 0) e += 14, F = n[e++] | n[e++] << 8, e++;
          else for (e += 12; ; ) {
            if (!((pe = n[e++]) >= 0)) throw Error("Invalid block size");
            if (pe === 0) break;
            e += pe;
          }
          break;
        case 249:
          if (n[e++] !== 4 || n[e + 4] !== 0) throw new Error("Invalid graphics extension block.");
          var U = n[e++];
          C = n[e++] | n[e++] << 8, I = n[e++], !(1 & U) && (I = null), S = U >> 2 & 7, e++;
          break;
        case 254:
          for (; ; ) {
            if (!((pe = n[e++]) >= 0)) throw Error("Invalid block size");
            if (pe === 0) break;
            e += pe;
          }
          break;
        default:
          throw new Error("Unknown graphic control label: 0x" + n[e - 1].toString(16));
      }
      break;
    case 44:
      var V = n[e++] | n[e++] << 8, W = n[e++] | n[e++] << 8, X = n[e++] | n[e++] << 8, de = n[e++] | n[e++] << 8, ie = n[e++], fe = ie >> 6 & 1, Ae = 1 << (7 & ie) + 1, Te = a, me = g, Ge = !1;
      ie >> 7 && (Ge = !0, Te = e, me = Ae, e += 3 * Ae);
      var ke = e;
      for (e++; ; ) {
        var pe;
        if (!((pe = n[e++]) >= 0)) throw Error("Invalid block size");
        if (pe === 0) break;
        e += pe;
      }
      A.push({ x: V, y: W, width: X, height: de, has_local_palette: Ge, palette_offset: Te, palette_size: me, data_offset: ke, data_length: e - ke, transparent_index: I, interlaced: !!fe, delay: C, disposal: S });
      break;
    case 59:
      y = !1;
      break;
    default:
      throw new Error("Unknown gif block: 0x" + n[e - 1].toString(16));
  }
  this.numFrames = function() {
    return A.length;
  }, this.loopCount = function() {
    return F;
  }, this.frameInfo = function(_e) {
    if (_e < 0 || _e >= A.length) throw new Error("Frame index out of range.");
    return A[_e];
  }, this.decodeAndBlitFrameBGRA = function(_e, De) {
    var Me = this.frameInfo(_e), St = Me.width * Me.height, dt = new Uint8Array(St);
    R5(n, Me.data_offset, dt, St);
    var Pt = Me.palette_offset, gt = Me.transparent_index;
    gt === null && (gt = 256);
    var Rt = Me.width, Ft = t - Rt, mn = Rt, oe = 4 * (Me.y * t + Me.x), Re = 4 * ((Me.y + Me.height) * t + Me.x), ze = oe, Xe = 4 * Ft;
    Me.interlaced === !0 && (Xe += 4 * t * 7);
    for (var ot = 8, rt = 0, xt = dt.length; rt < xt; ++rt) {
      var ht = dt[rt];
      if (mn === 0 && (mn = Rt, (ze += Xe) >= Re && (Xe = 4 * Ft + 4 * t * (ot - 1), ze = oe + (Rt + Ft) * (ot << 1), ot >>= 1)), ht === gt) ze += 4;
      else {
        var $t = n[Pt + 3 * ht], Wt = n[Pt + 3 * ht + 1], on = n[Pt + 3 * ht + 2];
        De[ze++] = on, De[ze++] = Wt, De[ze++] = $t, De[ze++] = 255;
      }
      --mn;
    }
  }, this.decodeAndBlitFrameRGBA = function(_e, De) {
    var Me = this.frameInfo(_e), St = Me.width * Me.height, dt = new Uint8Array(St);
    R5(n, Me.data_offset, dt, St);
    var Pt = Me.palette_offset, gt = Me.transparent_index;
    gt === null && (gt = 256);
    var Rt = Me.width, Ft = t - Rt, mn = Rt, oe = 4 * (Me.y * t + Me.x), Re = 4 * ((Me.y + Me.height) * t + Me.x), ze = oe, Xe = 4 * Ft;
    Me.interlaced === !0 && (Xe += 4 * t * 7);
    for (var ot = 8, rt = 0, xt = dt.length; rt < xt; ++rt) {
      var ht = dt[rt];
      if (mn === 0 && (mn = Rt, (ze += Xe) >= Re && (Xe = 4 * Ft + 4 * t * (ot - 1), ze = oe + (Rt + Ft) * (ot << 1), ot >>= 1)), ht === gt) ze += 4;
      else {
        var $t = n[Pt + 3 * ht], Wt = n[Pt + 3 * ht + 1], on = n[Pt + 3 * ht + 2];
        De[ze++] = $t, De[ze++] = Wt, De[ze++] = on, De[ze++] = 255;
      }
      --mn;
    }
  };
}
function R5(n, e, t, i) {
  for (var r = n[e++], l = 1 << r, c = l + 1, a = c + 1, g = r + 1, y = (1 << g) - 1, A = 0, C = 0, I = 0, S = n[e++], F = new Int32Array(4096), U = null; ; ) {
    for (; A < 16 && S !== 0; ) C |= n[e++] << A, A += 8, S === 1 ? S = n[e++] : --S;
    if (A < g) break;
    var V = C & y;
    if (C >>= g, A -= g, V !== l) {
      if (V === c) break;
      for (var W = V < a ? V : U, X = 0, de = W; de > l; ) de = F[de] >> 8, ++X;
      var ie = de;
      if (I + X + (W !== V ? 1 : 0) > i) return void mr.log("Warning, gif stream longer than expected.");
      t[I++] = ie;
      var fe = I += X;
      for (W !== V && (t[I++] = ie), de = W; X--; ) de = F[de], t[--fe] = 255 & de, de >>= 8;
      U !== null && a < 4096 && (F[a++] = U << 8 | ie, a >= y + 1 && g < 12 && (++g, y = y << 1 | 1)), U = V;
    } else a = c + 1, y = (1 << (g = r + 1)) - 1, U = null;
  }
  return I !== i && mr.log("Warning, gif stream shorter than expected."), t;
}
/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
function _y(n) {
  var e, t, i, r, l, c = Math.floor, a = new Array(64), g = new Array(64), y = new Array(64), A = new Array(64), C = new Array(65535), I = new Array(65535), S = new Array(64), F = new Array(64), U = [], V = 0, W = 7, X = new Array(64), de = new Array(64), ie = new Array(64), fe = new Array(256), Ae = new Array(2048), Te = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], me = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], Ge = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], ke = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], pe = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], _e = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], De = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Me = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], St = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
  function dt(oe, Re) {
    for (var ze = 0, Xe = 0, ot = new Array(), rt = 1; rt <= 16; rt++) {
      for (var xt = 1; xt <= oe[rt]; xt++) ot[Re[Xe]] = [], ot[Re[Xe]][0] = ze, ot[Re[Xe]][1] = rt, Xe++, ze++;
      ze *= 2;
    }
    return ot;
  }
  function Pt(oe) {
    for (var Re = oe[0], ze = oe[1] - 1; ze >= 0; ) Re & 1 << ze && (V |= 1 << W), ze--, --W < 0 && (V == 255 ? (gt(255), gt(0)) : gt(V), W = 7, V = 0);
  }
  function gt(oe) {
    U.push(oe);
  }
  function Rt(oe) {
    gt(oe >> 8 & 255), gt(255 & oe);
  }
  function Ft(oe, Re, ze, Xe, ot) {
    for (var rt, xt = ot[0], ht = ot[240], $t = function(en, ln) {
      var un, _n, Mn, Wn, $n, Yn, si, fi, Un, Jn, bn = 0;
      for (Un = 0; Un < 8; ++Un) {
        un = en[bn], _n = en[bn + 1], Mn = en[bn + 2], Wn = en[bn + 3], $n = en[bn + 4], Yn = en[bn + 5], si = en[bn + 6];
        var tr = un + (fi = en[bn + 7]), pi = un - fi, Dr = _n + si, be = _n - si, ne = Mn + Yn, ce = Mn - Yn, ue = Wn + $n, Oe = Wn - $n, qe = tr + ue, it = tr - ue, mt = Dr + ne, Ye = Dr - ne;
        en[bn] = qe + mt, en[bn + 4] = qe - mt;
        var at = 0.707106781 * (Ye + it);
        en[bn + 2] = it + at, en[bn + 6] = it - at;
        var pt = 0.382683433 * ((qe = Oe + ce) - (Ye = be + pi)), lt = 0.5411961 * qe + pt, Ze = 1.306562965 * Ye + pt, an = 0.707106781 * (mt = ce + be), Yt = pi + an, Xt = pi - an;
        en[bn + 5] = Xt + lt, en[bn + 3] = Xt - lt, en[bn + 1] = Yt + Ze, en[bn + 7] = Yt - Ze, bn += 8;
      }
      for (bn = 0, Un = 0; Un < 8; ++Un) {
        un = en[bn], _n = en[bn + 8], Mn = en[bn + 16], Wn = en[bn + 24], $n = en[bn + 32], Yn = en[bn + 40], si = en[bn + 48];
        var An = un + (fi = en[bn + 56]), It = un - fi, Jt = _n + si, cn = _n - si, In = Mn + Yn, Zn = Mn - Yn, Ln = Wn + $n, fn = Wn - $n, xi = An + Ln, Er = An - Ln, Pi = Jt + In, Ii = Jt - In;
        en[bn] = xi + Pi, en[bn + 32] = xi - Pi;
        var ui = 0.707106781 * (Ii + Er);
        en[bn + 16] = Er + ui, en[bn + 48] = Er - ui;
        var Oi = 0.382683433 * ((xi = fn + Zn) - (Ii = cn + It)), _i = 0.5411961 * xi + Oi, xs = 1.306562965 * Ii + Oi, ws = 0.707106781 * (Pi = Zn + cn), Ao = It + ws, qs = It - ws;
        en[bn + 40] = qs + _i, en[bn + 24] = qs - _i, en[bn + 8] = Ao + xs, en[bn + 56] = Ao - xs, bn++;
      }
      for (Un = 0; Un < 64; ++Un) Jn = en[Un] * ln[Un], S[Un] = Jn > 0 ? Jn + 0.5 | 0 : Jn - 0.5 | 0;
      return S;
    }(oe, Re), Wt = 0; Wt < 64; ++Wt) F[Te[Wt]] = $t[Wt];
    var on = F[0] - ze;
    ze = F[0], on == 0 ? Pt(Xe[0]) : (Pt(Xe[I[rt = 32767 + on]]), Pt(C[rt]));
    for (var hn = 63; hn > 0 && F[hn] == 0; ) hn--;
    if (hn == 0) return Pt(xt), ze;
    for (var wn, Bt = 1; Bt <= hn; ) {
      for (var Ue = Bt; F[Bt] == 0 && Bt <= hn; ) ++Bt;
      var On = Bt - Ue;
      if (On >= 16) {
        wn = On >> 4;
        for (var Sn = 1; Sn <= wn; ++Sn) Pt(ht);
        On &= 15;
      }
      rt = 32767 + F[Bt], Pt(ot[(On << 4) + I[rt]]), Pt(C[rt]), Bt++;
    }
    return hn != 63 && Pt(xt), ze;
  }
  function mn(oe) {
    oe = Math.min(Math.max(oe, 1), 100), l != oe && (function(Re) {
      for (var ze = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], Xe = 0; Xe < 64; Xe++) {
        var ot = c((ze[Xe] * Re + 50) / 100);
        ot = Math.min(Math.max(ot, 1), 255), a[Te[Xe]] = ot;
      }
      for (var rt = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], xt = 0; xt < 64; xt++) {
        var ht = c((rt[xt] * Re + 50) / 100);
        ht = Math.min(Math.max(ht, 1), 255), g[Te[xt]] = ht;
      }
      for (var $t = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Wt = 0, on = 0; on < 8; on++) for (var hn = 0; hn < 8; hn++) y[Wt] = 1 / (a[Te[Wt]] * $t[on] * $t[hn] * 8), A[Wt] = 1 / (g[Te[Wt]] * $t[on] * $t[hn] * 8), Wt++;
    }(oe < 50 ? Math.floor(5e3 / oe) : Math.floor(200 - 2 * oe)), l = oe);
  }
  this.encode = function(oe, Re) {
    Re && mn(Re), U = new Array(), V = 0, W = 7, Rt(65496), Rt(65504), Rt(16), gt(74), gt(70), gt(73), gt(70), gt(0), gt(1), gt(1), gt(0), Rt(1), Rt(1), gt(0), gt(0), function() {
      Rt(65499), Rt(132), gt(0);
      for (var _n = 0; _n < 64; _n++) gt(a[_n]);
      gt(1);
      for (var Mn = 0; Mn < 64; Mn++) gt(g[Mn]);
    }(), function(_n, Mn) {
      Rt(65472), Rt(17), gt(8), Rt(Mn), Rt(_n), gt(3), gt(1), gt(17), gt(0), gt(2), gt(17), gt(1), gt(3), gt(17), gt(1);
    }(oe.width, oe.height), function() {
      Rt(65476), Rt(418), gt(0);
      for (var _n = 0; _n < 16; _n++) gt(me[_n + 1]);
      for (var Mn = 0; Mn <= 11; Mn++) gt(Ge[Mn]);
      gt(16);
      for (var Wn = 0; Wn < 16; Wn++) gt(ke[Wn + 1]);
      for (var $n = 0; $n <= 161; $n++) gt(pe[$n]);
      gt(1);
      for (var Yn = 0; Yn < 16; Yn++) gt(_e[Yn + 1]);
      for (var si = 0; si <= 11; si++) gt(De[si]);
      gt(17);
      for (var fi = 0; fi < 16; fi++) gt(Me[fi + 1]);
      for (var Un = 0; Un <= 161; Un++) gt(St[Un]);
    }(), Rt(65498), Rt(12), gt(3), gt(1), gt(0), gt(2), gt(17), gt(3), gt(17), gt(0), gt(63), gt(0);
    var ze = 0, Xe = 0, ot = 0;
    V = 0, W = 7, this.encode.displayName = "_encode_";
    for (var rt, xt, ht, $t, Wt, on, hn, wn, Bt, Ue = oe.data, On = oe.width, Sn = oe.height, en = 4 * On, ln = 0; ln < Sn; ) {
      for (rt = 0; rt < en; ) {
        for (Wt = en * ln + rt, hn = -1, wn = 0, Bt = 0; Bt < 64; Bt++) on = Wt + (wn = Bt >> 3) * en + (hn = 4 * (7 & Bt)), ln + wn >= Sn && (on -= en * (ln + 1 + wn - Sn)), rt + hn >= en && (on -= rt + hn - en + 4), xt = Ue[on++], ht = Ue[on++], $t = Ue[on++], X[Bt] = (Ae[xt] + Ae[ht + 256 >> 0] + Ae[$t + 512 >> 0] >> 16) - 128, de[Bt] = (Ae[xt + 768 >> 0] + Ae[ht + 1024 >> 0] + Ae[$t + 1280 >> 0] >> 16) - 128, ie[Bt] = (Ae[xt + 1280 >> 0] + Ae[ht + 1536 >> 0] + Ae[$t + 1792 >> 0] >> 16) - 128;
        ze = Ft(X, y, ze, e, i), Xe = Ft(de, A, Xe, t, r), ot = Ft(ie, A, ot, t, r), rt += 32;
      }
      ln += 8;
    }
    if (W >= 0) {
      var un = [];
      un[1] = W + 1, un[0] = (1 << W + 1) - 1, Pt(un);
    }
    return Rt(65497), new Uint8Array(U);
  }, n = n || 50, function() {
    for (var oe = String.fromCharCode, Re = 0; Re < 256; Re++) fe[Re] = oe(Re);
  }(), e = dt(me, Ge), t = dt(_e, De), i = dt(ke, pe), r = dt(Me, St), function() {
    for (var oe = 1, Re = 2, ze = 1; ze <= 15; ze++) {
      for (var Xe = oe; Xe < Re; Xe++) I[32767 + Xe] = ze, C[32767 + Xe] = [], C[32767 + Xe][1] = ze, C[32767 + Xe][0] = Xe;
      for (var ot = -(Re - 1); ot <= -oe; ot++) I[32767 + ot] = ze, C[32767 + ot] = [], C[32767 + ot][1] = ze, C[32767 + ot][0] = Re - 1 + ot;
      oe <<= 1, Re <<= 1;
    }
  }(), function() {
    for (var oe = 0; oe < 256; oe++) Ae[oe] = 19595 * oe, Ae[oe + 256 >> 0] = 38470 * oe, Ae[oe + 512 >> 0] = 7471 * oe + 32768, Ae[oe + 768 >> 0] = -11059 * oe, Ae[oe + 1024 >> 0] = -21709 * oe, Ae[oe + 1280 >> 0] = 32768 * oe + 8421375, Ae[oe + 1536 >> 0] = -27439 * oe, Ae[oe + 1792 >> 0] = -5329 * oe;
  }(), mn(n);
}
/**
* @license
* Copyright (c) 2017 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function cc(n, e) {
  if (this.pos = 0, this.buffer = n, this.datav = new DataView(n.buffer), this.is_with_alpha = !!e, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
  this.parseHeader(), this.parseBGR();
}
function B5(n) {
  function e(me) {
    if (!me) throw Error("assert :P");
  }
  function t(me, Ge, ke) {
    for (var pe = 0; 4 > pe; pe++) if (me[Ge + pe] != ke.charCodeAt(pe)) return !0;
    return !1;
  }
  function i(me, Ge, ke, pe, _e) {
    for (var De = 0; De < _e; De++) me[Ge + De] = ke[pe + De];
  }
  function r(me, Ge, ke, pe) {
    for (var _e = 0; _e < pe; _e++) me[Ge + _e] = ke;
  }
  function l(me) {
    return new Int32Array(me);
  }
  function c(me, Ge) {
    for (var ke = [], pe = 0; pe < me; pe++) ke.push(new Ge());
    return ke;
  }
  function a(me, Ge) {
    var ke = [];
    return function pe(_e, De, Me) {
      for (var St = Me[De], dt = 0; dt < St && (_e.push(Me.length > De + 1 ? [] : new Ge()), !(Me.length < De + 1)); dt++) pe(_e[dt], De + 1, Me);
    }(ke, 0, me), ke;
  }
  var g = function() {
    var me = this;
    function Ge(T, M) {
      for (var k = 1 << M - 1 >>> 0; T & k; ) k >>>= 1;
      return k ? (T & k - 1) + k : T;
    }
    function ke(T, M, k, q, ee) {
      e(!(q % k));
      do
        T[M + (q -= k)] = ee;
      while (0 < q);
    }
    function pe(T, M, k, q, ee) {
      if (e(2328 >= ee), 512 >= ee) var le = l(512);
      else if ((le = l(ee)) == null) return 0;
      return function(he, ye, xe, Le, tt, ut) {
        var At, ct, qt = ye, Ot = 1 << xe, nt = l(16), st = l(16);
        for (e(tt != 0), e(Le != null), e(he != null), e(0 < xe), ct = 0; ct < tt; ++ct) {
          if (15 < Le[ct]) return 0;
          ++nt[Le[ct]];
        }
        if (nt[0] == tt) return 0;
        for (st[1] = 0, At = 1; 15 > At; ++At) {
          if (nt[At] > 1 << At) return 0;
          st[At + 1] = st[At] + nt[At];
        }
        for (ct = 0; ct < tt; ++ct) At = Le[ct], 0 < Le[ct] && (ut[st[At]++] = ct);
        if (st[15] == 1) return (Le = new _e()).g = 0, Le.value = ut[0], ke(he, qt, 1, Ot, Le), Ot;
        var jt, Zt = -1, ft = Ot - 1, Ut = 0, yn = 1, jn = 1, xn = 1 << xe;
        for (ct = 0, At = 1, tt = 2; At <= xe; ++At, tt <<= 1) {
          if (yn += jn <<= 1, 0 > (jn -= nt[At])) return 0;
          for (; 0 < nt[At]; --nt[At]) (Le = new _e()).g = At, Le.value = ut[ct++], ke(he, qt + Ut, tt, xn, Le), Ut = Ge(Ut, At);
        }
        for (At = xe + 1, tt = 2; 15 >= At; ++At, tt <<= 1) {
          if (yn += jn <<= 1, 0 > (jn -= nt[At])) return 0;
          for (; 0 < nt[At]; --nt[At]) {
            if (Le = new _e(), (Ut & ft) != Zt) {
              for (qt += xn, jt = 1 << (Zt = At) - xe; 15 > Zt && !(0 >= (jt -= nt[Zt])); ) ++Zt, jt <<= 1;
              Ot += xn = 1 << (jt = Zt - xe), he[ye + (Zt = Ut & ft)].g = jt + xe, he[ye + Zt].value = qt - ye - Zt;
            }
            Le.g = At - xe, Le.value = ut[ct++], ke(he, qt + (Ut >> xe), tt, xn, Le), Ut = Ge(Ut, At);
          }
        }
        return yn != 2 * st[15] - 1 ? 0 : Ot;
      }(T, M, k, q, ee, le);
    }
    function _e() {
      this.value = this.g = 0;
    }
    function De() {
      this.value = this.g = 0;
    }
    function Me() {
      this.G = c(5, _e), this.H = l(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = c(rr, De);
    }
    function St(T, M, k, q) {
      e(T != null), e(M != null), e(2147483648 > q), T.Ca = 254, T.I = 0, T.b = -8, T.Ka = 0, T.oa = M, T.pa = k, T.Jd = M, T.Yc = k + q, T.Zc = 4 <= q ? k + q - 4 + 1 : k, rt(T);
    }
    function dt(T, M) {
      for (var k = 0; 0 < M--; ) k |= ht(T, 128) << M;
      return k;
    }
    function Pt(T, M) {
      var k = dt(T, M);
      return xt(T) ? -k : k;
    }
    function gt(T, M, k, q) {
      var ee, le = 0;
      for (e(T != null), e(M != null), e(4294967288 > q), T.Sb = q, T.Ra = 0, T.u = 0, T.h = 0, 4 < q && (q = 4), ee = 0; ee < q; ++ee) le += M[k + ee] << 8 * ee;
      T.Ra = le, T.bb = q, T.oa = M, T.pa = k;
    }
    function Rt(T) {
      for (; 8 <= T.u && T.bb < T.Sb; ) T.Ra >>>= 8, T.Ra += T.oa[T.pa + T.bb] << Oa - 8 >>> 0, ++T.bb, T.u -= 8;
      ze(T) && (T.h = 1, T.u = 0);
    }
    function Ft(T, M) {
      if (e(0 <= M), !T.h && M <= ll) {
        var k = Re(T) & al[M];
        return T.u += M, Rt(T), k;
      }
      return T.h = 1, T.u = 0;
    }
    function mn() {
      this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
    }
    function oe() {
      this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
    }
    function Re(T) {
      return T.Ra >>> (T.u & Oa - 1) >>> 0;
    }
    function ze(T) {
      return e(T.bb <= T.Sb), T.h || T.bb == T.Sb && T.u > Oa;
    }
    function Xe(T, M) {
      T.u = M, T.h = ze(T);
    }
    function ot(T) {
      T.u >= Mc && (e(T.u >= Mc), Rt(T));
    }
    function rt(T) {
      e(T != null && T.oa != null), T.pa < T.Zc ? (T.I = (T.oa[T.pa++] | T.I << 8) >>> 0, T.b += 8) : (e(T != null && T.oa != null), T.pa < T.Yc ? (T.b += 8, T.I = T.oa[T.pa++] | T.I << 8) : T.Ka ? T.b = 0 : (T.I <<= 8, T.b += 8, T.Ka = 1));
    }
    function xt(T) {
      return dt(T, 1);
    }
    function ht(T, M) {
      var k = T.Ca;
      0 > T.b && rt(T);
      var q = T.b, ee = k * M >>> 8, le = (T.I >>> q > ee) + 0;
      for (le ? (k -= ee, T.I -= ee + 1 << q >>> 0) : k = ee + 1, q = k, ee = 0; 256 <= q; ) ee += 8, q >>= 8;
      return q = 7 ^ ee + As[q], T.b -= q, T.Ca = (k << q) - 1, le;
    }
    function $t(T, M, k) {
      T[M + 0] = k >> 24 & 255, T[M + 1] = k >> 16 & 255, T[M + 2] = k >> 8 & 255, T[M + 3] = k >> 0 & 255;
    }
    function Wt(T, M) {
      return T[M + 0] << 0 | T[M + 1] << 8;
    }
    function on(T, M) {
      return Wt(T, M) | T[M + 2] << 16;
    }
    function hn(T, M) {
      return Wt(T, M) | Wt(T, M + 2) << 16;
    }
    function wn(T, M) {
      var k = 1 << M;
      return e(T != null), e(0 < M), T.X = l(k), T.X == null ? 0 : (T.Mb = 32 - M, T.Xa = M, 1);
    }
    function Bt(T, M) {
      e(T != null), e(M != null), e(T.Xa == M.Xa), i(M.X, 0, T.X, 0, 1 << M.Xa);
    }
    function Ue() {
      this.X = [], this.Xa = this.Mb = 0;
    }
    function On(T, M, k, q) {
      e(k != null), e(q != null);
      var ee = k[0], le = q[0];
      return ee == 0 && (ee = (T * le + M / 2) / M), le == 0 && (le = (M * ee + T / 2) / T), 0 >= ee || 0 >= le ? 0 : (k[0] = ee, q[0] = le, 1);
    }
    function Sn(T, M) {
      return T + (1 << M) - 1 >>> M;
    }
    function en(T, M) {
      return ((4278255360 & T) + (4278255360 & M) >>> 0 & 4278255360) + ((16711935 & T) + (16711935 & M) >>> 0 & 16711935) >>> 0;
    }
    function ln(T, M) {
      me[M] = function(k, q, ee, le, he, ye, xe) {
        var Le;
        for (Le = 0; Le < he; ++Le) {
          var tt = me[T](ye[xe + Le - 1], ee, le + Le);
          ye[xe + Le] = en(k[q + Le], tt);
        }
      };
    }
    function un() {
      this.ud = this.hd = this.jd = 0;
    }
    function _n(T, M) {
      return ((4278124286 & (T ^ M)) >>> 1) + (T & M) >>> 0;
    }
    function Mn(T) {
      return 0 <= T && 256 > T ? T : 0 > T ? 0 : 255 < T ? 255 : void 0;
    }
    function Wn(T, M) {
      return Mn(T + (T - M + 0.5 >> 1));
    }
    function $n(T, M, k) {
      return Math.abs(M - k) - Math.abs(T - k);
    }
    function Yn(T, M, k, q, ee, le, he) {
      for (q = le[he - 1], k = 0; k < ee; ++k) le[he + k] = q = en(T[M + k], q);
    }
    function si(T, M, k, q, ee) {
      var le;
      for (le = 0; le < k; ++le) {
        var he = T[M + le], ye = he >> 8 & 255, xe = 16711935 & (xe = (xe = 16711935 & he) + ((ye << 16) + ye));
        q[ee + le] = (4278255360 & he) + xe >>> 0;
      }
    }
    function fi(T, M) {
      M.jd = T >> 0 & 255, M.hd = T >> 8 & 255, M.ud = T >> 16 & 255;
    }
    function Un(T, M, k, q, ee, le) {
      var he;
      for (he = 0; he < q; ++he) {
        var ye = M[k + he], xe = ye >>> 8, Le = ye, tt = 255 & (tt = (tt = ye >>> 16) + ((T.jd << 24 >> 24) * (xe << 24 >> 24) >>> 5));
        Le = 255 & (Le = (Le = Le + ((T.hd << 24 >> 24) * (xe << 24 >> 24) >>> 5)) + ((T.ud << 24 >> 24) * (tt << 24 >> 24) >>> 5)), ee[le + he] = (4278255360 & ye) + (tt << 16) + Le;
      }
    }
    function Jn(T, M, k, q, ee) {
      me[M] = function(le, he, ye, xe, Le, tt, ut, At, ct) {
        for (xe = ut; xe < At; ++xe) for (ut = 0; ut < ct; ++ut) Le[tt++] = ee(ye[q(le[he++])]);
      }, me[T] = function(le, he, ye, xe, Le, tt, ut) {
        var At = 8 >> le.b, ct = le.Ea, qt = le.K[0], Ot = le.w;
        if (8 > At) for (le = (1 << le.b) - 1, Ot = (1 << At) - 1; he < ye; ++he) {
          var nt, st = 0;
          for (nt = 0; nt < ct; ++nt) nt & le || (st = q(xe[Le++])), tt[ut++] = ee(qt[st & Ot]), st >>= At;
        }
        else me["VP8LMapColor" + k](xe, Le, qt, Ot, tt, ut, he, ye, ct);
      };
    }
    function bn(T, M, k, q, ee) {
      for (k = M + k; M < k; ) {
        var le = T[M++];
        q[ee++] = le >> 16 & 255, q[ee++] = le >> 8 & 255, q[ee++] = le >> 0 & 255;
      }
    }
    function tr(T, M, k, q, ee) {
      for (k = M + k; M < k; ) {
        var le = T[M++];
        q[ee++] = le >> 16 & 255, q[ee++] = le >> 8 & 255, q[ee++] = le >> 0 & 255, q[ee++] = le >> 24 & 255;
      }
    }
    function pi(T, M, k, q, ee) {
      for (k = M + k; M < k; ) {
        var le = (he = T[M++]) >> 16 & 240 | he >> 12 & 15, he = he >> 0 & 240 | he >> 28 & 15;
        q[ee++] = le, q[ee++] = he;
      }
    }
    function Dr(T, M, k, q, ee) {
      for (k = M + k; M < k; ) {
        var le = (he = T[M++]) >> 16 & 248 | he >> 13 & 7, he = he >> 5 & 224 | he >> 3 & 31;
        q[ee++] = le, q[ee++] = he;
      }
    }
    function be(T, M, k, q, ee) {
      for (k = M + k; M < k; ) {
        var le = T[M++];
        q[ee++] = le >> 0 & 255, q[ee++] = le >> 8 & 255, q[ee++] = le >> 16 & 255;
      }
    }
    function ne(T, M, k, q, ee, le) {
      if (le == 0) for (k = M + k; M < k; ) $t(q, ((le = T[M++])[0] >> 24 | le[1] >> 8 & 65280 | le[2] << 8 & 16711680 | le[3] << 24) >>> 0), ee += 32;
      else i(q, ee, T, M, k);
    }
    function ce(T, M) {
      me[M][0] = me[T + "0"], me[M][1] = me[T + "1"], me[M][2] = me[T + "2"], me[M][3] = me[T + "3"], me[M][4] = me[T + "4"], me[M][5] = me[T + "5"], me[M][6] = me[T + "6"], me[M][7] = me[T + "7"], me[M][8] = me[T + "8"], me[M][9] = me[T + "9"], me[M][10] = me[T + "10"], me[M][11] = me[T + "11"], me[M][12] = me[T + "12"], me[M][13] = me[T + "13"], me[M][14] = me[T + "0"], me[M][15] = me[T + "0"];
    }
    function ue(T) {
      return T == Oc || T == hu || T == Dc || T == Kl;
    }
    function Oe() {
      this.eb = [], this.size = this.A = this.fb = 0;
    }
    function qe() {
      this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
    }
    function it() {
      this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new Oe(), this.f.kb = new qe(), this.sd = null;
    }
    function mt() {
      this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
    }
    function Ye() {
      this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
    }
    function at(T) {
      return alert("todo:WebPSamplerProcessPlane"), T.T;
    }
    function pt(T, M) {
      var k = T.T, q = M.ba.f.RGBA, ee = q.eb, le = q.fb + T.ka * q.A, he = _o[M.ba.S], ye = T.y, xe = T.O, Le = T.f, tt = T.N, ut = T.ea, At = T.W, ct = M.cc, qt = M.dc, Ot = M.Mc, nt = M.Nc, st = T.ka, jt = T.ka + T.T, Zt = T.U, ft = Zt + 1 >> 1;
      for (st == 0 ? he(ye, xe, null, null, Le, tt, ut, At, Le, tt, ut, At, ee, le, null, null, Zt) : (he(M.ec, M.fc, ye, xe, ct, qt, Ot, nt, Le, tt, ut, At, ee, le - q.A, ee, le, Zt), ++k); st + 2 < jt; st += 2) ct = Le, qt = tt, Ot = ut, nt = At, tt += T.Rc, At += T.Rc, le += 2 * q.A, he(ye, (xe += 2 * T.fa) - T.fa, ye, xe, ct, qt, Ot, nt, Le, tt, ut, At, ee, le - q.A, ee, le, Zt);
      return xe += T.fa, T.j + jt < T.o ? (i(M.ec, M.fc, ye, xe, Zt), i(M.cc, M.dc, Le, tt, ft), i(M.Mc, M.Nc, ut, At, ft), k--) : 1 & jt || he(ye, xe, null, null, Le, tt, ut, At, Le, tt, ut, At, ee, le + q.A, null, null, Zt), k;
    }
    function lt(T, M, k) {
      var q = T.F, ee = [T.J];
      if (q != null) {
        var le = T.U, he = M.ba.S, ye = he == cu || he == Dc;
        M = M.ba.f.RGBA;
        var xe = [0], Le = T.ka;
        xe[0] = T.T, T.Kb && (Le == 0 ? --xe[0] : (--Le, ee[0] -= T.width), T.j + T.ka + T.T == T.o && (xe[0] = T.o - T.j - Le));
        var tt = M.eb;
        Le = M.fb + Le * M.A, T = Zi(q, ee[0], T.width, le, xe, tt, Le + (ye ? 0 : 3), M.A), e(k == xe), T && ue(he) && mo(tt, Le, ye, le, xe, M.A);
      }
      return 0;
    }
    function Ze(T) {
      var M = T.ma, k = M.ba.S, q = 11 > k, ee = k == Bc || k == Jl || k == cu || k == ju || k == 12 || ue(k);
      if (M.memory = null, M.Ib = null, M.Jb = null, M.Nd = null, !Vl(M.Oa, T, ee ? 11 : 12)) return 0;
      if (ee && ue(k) && tn(), T.da) alert("todo:use_scaling");
      else {
        if (q) {
          if (M.Ib = at, T.Kb) {
            if (k = T.U + 1 >> 1, M.memory = l(T.U + 2 * k), M.memory == null) return 0;
            M.ec = M.memory, M.fc = 0, M.cc = M.ec, M.dc = M.fc + T.U, M.Mc = M.cc, M.Nc = M.dc + k, M.Ib = pt, tn();
          }
        } else alert("todo:EmitYUV");
        ee && (M.Jb = lt, q && yt());
      }
      if (q && !yl) {
        for (T = 0; 256 > T; ++T) Ga[T] = 89858 * (T - 128) + _l >> Hu, tc[T] = -22014 * (T - 128) + _l, hd[T] = -45773 * (T - 128), vn[T] = 113618 * (T - 128) + _l >> Hu;
        for (T = kc; T < gu; ++T) M = 76283 * (T - 16) + _l >> Hu, dd[T - kc] = Bs(M, 255), mu[T - kc] = Bs(M + 8 >> 4, 15);
        yl = 1;
      }
      return 1;
    }
    function an(T) {
      var M = T.ma, k = T.U, q = T.T;
      return e(!(1 & T.ka)), 0 >= k || 0 >= q ? 0 : (k = M.Ib(T, M), M.Jb != null && M.Jb(T, M, k), M.Dc += k, 1);
    }
    function Yt(T) {
      T.ma.memory = null;
    }
    function Xt(T, M, k, q) {
      return Ft(T, 8) != 47 ? 0 : (M[0] = Ft(T, 14) + 1, k[0] = Ft(T, 14) + 1, q[0] = Ft(T, 1), Ft(T, 3) != 0 ? 0 : !T.h);
    }
    function An(T, M) {
      if (4 > T) return T + 1;
      var k = T - 2 >> 1;
      return (2 + (1 & T) << k) + Ft(M, k) + 1;
    }
    function It(T, M) {
      return 120 < M ? M - 120 : 1 <= (k = ((k = Ro[M - 1]) >> 4) * T + (8 - (15 & k))) ? k : 1;
      var k;
    }
    function Jt(T, M, k) {
      var q = Re(k), ee = T[M += 255 & q].g - 8;
      return 0 < ee && (Xe(k, k.u + 8), q = Re(k), M += T[M].value, M += q & (1 << ee) - 1), Xe(k, k.u + T[M].g), T[M].value;
    }
    function cn(T, M, k) {
      return k.g += T.g, k.value += T.value << M >>> 0, e(8 >= k.g), T.g;
    }
    function In(T, M, k) {
      var q = T.xc;
      return e((M = q == 0 ? 0 : T.vc[T.md * (k >> q) + (M >> q)]) < T.Wb), T.Ya[M];
    }
    function Zn(T, M, k, q) {
      var ee = T.ab, le = T.c * M, he = T.C;
      M = he + M;
      var ye = k, xe = q;
      for (q = T.Ta, k = T.Ua; 0 < ee--; ) {
        var Le = T.gc[ee], tt = he, ut = M, At = ye, ct = xe, qt = (xe = q, ye = k, Le.Ea);
        switch (e(tt < ut), e(ut <= Le.nc), Le.hc) {
          case 2:
            Ei(At, ct, (ut - tt) * qt, xe, ye);
            break;
          case 0:
            var Ot = tt, nt = ut, st = xe, jt = ye, Zt = (xn = Le).Ea;
            Ot == 0 && (Da(At, ct, null, null, 1, st, jt), Yn(At, ct + 1, 0, 0, Zt - 1, st, jt + 1), ct += Zt, jt += Zt, ++Ot);
            for (var ft = 1 << xn.b, Ut = ft - 1, yn = Sn(Zt, xn.b), jn = xn.K, xn = xn.w + (Ot >> xn.b) * yn; Ot < nt; ) {
              var ri = jn, Fi = xn, ai = 1;
              for (Hl(At, ct, st, jt - Zt, 1, st, jt); ai < Zt; ) {
                var Ai = (ai & ~Ut) + ft;
                Ai > Zt && (Ai = Zt), (0, cl[ri[Fi++] >> 8 & 15])(At, ct + +ai, st, jt + ai - Zt, Ai - ai, st, jt + ai), ai = Ai;
              }
              ct += Zt, jt += Zt, ++Ot & Ut || (xn += yn);
            }
            ut != Le.nc && i(xe, ye - qt, xe, ye + (ut - tt - 1) * qt, qt);
            break;
          case 1:
            for (qt = At, nt = ct, Zt = (At = Le.Ea) - (jt = At & ~(st = (ct = 1 << Le.b) - 1)), Ot = Sn(At, Le.b), ft = Le.K, Le = Le.w + (tt >> Le.b) * Ot; tt < ut; ) {
              for (Ut = ft, yn = Le, jn = new un(), xn = nt + jt, ri = nt + At; nt < xn; ) fi(Ut[yn++], jn), ul(jn, qt, nt, ct, xe, ye), nt += ct, ye += ct;
              nt < ri && (fi(Ut[yn++], jn), ul(jn, qt, nt, Zt, xe, ye), nt += Zt, ye += Zt), ++tt & st || (Le += Ot);
            }
            break;
          case 3:
            if (At == xe && ct == ye && 0 < Le.b) {
              for (nt = xe, At = qt = ye + (ut - tt) * qt - (jt = (ut - tt) * Sn(Le.Ea, Le.b)), ct = xe, st = ye, Ot = [], jt = (Zt = jt) - 1; 0 <= jt; --jt) Ot[jt] = ct[st + jt];
              for (jt = Zt - 1; 0 <= jt; --jt) nt[At + jt] = Ot[jt];
              Io(Le, tt, ut, xe, qt, xe, ye);
            } else Io(Le, tt, ut, At, ct, xe, ye);
        }
        ye = q, xe = k;
      }
      xe != k && i(q, k, ye, xe, le);
    }
    function Ln(T, M) {
      var k = T.V, q = T.Ba + T.c * T.C, ee = M - T.C;
      if (e(M <= T.l.o), e(16 >= ee), 0 < ee) {
        var le = T.l, he = T.Ta, ye = T.Ua, xe = le.width;
        if (Zn(T, ee, k, q), ee = ye = [ye], e((k = T.C) < (q = M)), e(le.v < le.va), q > le.o && (q = le.o), k < le.j) {
          var Le = le.j - k;
          k = le.j, ee[0] += Le * xe;
        }
        if (k >= q ? k = 0 : (ee[0] += 4 * le.v, le.ka = k - le.j, le.U = le.va - le.v, le.T = q - k, k = 1), k) {
          if (ye = ye[0], 11 > (k = T.ca).S) {
            var tt = k.f.RGBA, ut = (q = k.S, ee = le.U, le = le.T, Le = tt.eb, tt.A), At = le;
            for (tt = tt.fb + T.Ma * tt.A; 0 < At--; ) {
              var ct = he, qt = ye, Ot = ee, nt = Le, st = tt;
              switch (q) {
                case Yl:
                  ds(ct, qt, Ot, nt, st);
                  break;
                case Bc:
                  $r(ct, qt, Ot, nt, st);
                  break;
                case Oc:
                  $r(ct, qt, Ot, nt, st), mo(nt, st, 0, Ot, 1, 0);
                  break;
                case ad:
                  Os(ct, qt, Ot, nt, st);
                  break;
                case Jl:
                  ne(ct, qt, Ot, nt, st, 1);
                  break;
                case hu:
                  ne(ct, qt, Ot, nt, st, 1), mo(nt, st, 0, Ot, 1, 0);
                  break;
                case cu:
                  ne(ct, qt, Ot, nt, st, 0);
                  break;
                case Dc:
                  ne(ct, qt, Ot, nt, st, 0), mo(nt, st, 1, Ot, 1, 0);
                  break;
                case ju:
                  Qo(ct, qt, Ot, nt, st);
                  break;
                case Kl:
                  Qo(ct, qt, Ot, nt, st), Di(nt, st, Ot, 1, 0);
                  break;
                case uu:
                  ea(ct, qt, Ot, nt, st);
                  break;
                default:
                  e(0);
              }
              ye += xe, tt += ut;
            }
            T.Ma += le;
          } else alert("todo:EmitRescaledRowsYUVA");
          e(T.Ma <= k.height);
        }
      }
      T.C = M, e(T.C <= T.i);
    }
    function fn(T) {
      var M;
      if (0 < T.ua) return 0;
      for (M = 0; M < T.Wb; ++M) {
        var k = T.Ya[M].G, q = T.Ya[M].H;
        if (0 < k[1][q[1] + 0].g || 0 < k[2][q[2] + 0].g || 0 < k[3][q[3] + 0].g) return 0;
      }
      return 1;
    }
    function xi(T, M, k, q, ee, le) {
      if (T.Z != 0) {
        var he = T.qd, ye = T.rd;
        for (e(ja[T.Z] != null); M < k; ++M) ja[T.Z](he, ye, q, ee, q, ee, le), he = q, ye = ee, ee += le;
        T.qd = he, T.rd = ye;
      }
    }
    function Er(T, M) {
      var k = T.l.ma, q = k.Z == 0 || k.Z == 1 ? T.l.j : T.C;
      if (q = T.C < q ? q : T.C, e(M <= T.l.o), M > q) {
        var ee = T.l.width, le = k.ca, he = k.tb + ee * q, ye = T.V, xe = T.Ba + T.c * q, Le = T.gc;
        e(T.ab == 1), e(Le[0].hc == 3), Uu(Le[0], q, M, ye, xe, le, he), xi(k, q, M, le, he, ee);
      }
      T.C = T.Ma = M;
    }
    function Pi(T, M, k, q, ee, le, he) {
      var ye = T.$ / q, xe = T.$ % q, Le = T.m, tt = T.s, ut = k + T.$, At = ut;
      ee = k + q * ee;
      var ct = k + q * le, qt = 280 + tt.ua, Ot = T.Pb ? ye : 16777216, nt = 0 < tt.ua ? tt.Wa : null, st = tt.wc, jt = ut < ct ? In(tt, xe, ye) : null;
      e(T.C < le), e(ct <= ee);
      var Zt = !1;
      e: for (; ; ) {
        for (; Zt || ut < ct; ) {
          var ft = 0;
          if (ye >= Ot) {
            var Ut = ut - k;
            e((Ot = T).Pb), Ot.wd = Ot.m, Ot.xd = Ut, 0 < Ot.s.ua && Bt(Ot.s.Wa, Ot.s.vb), Ot = ye + xh;
          }
          if (xe & st || (jt = In(tt, xe, ye)), e(jt != null), jt.Qb && (M[ut] = jt.qb, Zt = !0), !Zt) if (ot(Le), jt.jc) {
            ft = Le, Ut = M;
            var yn = ut, jn = jt.pd[Re(ft) & rr - 1];
            e(jt.jc), 256 > jn.g ? (Xe(ft, ft.u + jn.g), Ut[yn] = jn.value, ft = 0) : (Xe(ft, ft.u + jn.g - 256), e(256 <= jn.value), ft = jn.value), ft == 0 && (Zt = !0);
          } else ft = Jt(jt.G[0], jt.H[0], Le);
          if (Le.h) break;
          if (Zt || 256 > ft) {
            if (!Zt) if (jt.nd) M[ut] = (jt.qb | ft << 8) >>> 0;
            else {
              if (ot(Le), Zt = Jt(jt.G[1], jt.H[1], Le), ot(Le), Ut = Jt(jt.G[2], jt.H[2], Le), yn = Jt(jt.G[3], jt.H[3], Le), Le.h) break;
              M[ut] = (yn << 24 | Zt << 16 | ft << 8 | Ut) >>> 0;
            }
            if (Zt = !1, ++ut, ++xe >= q && (xe = 0, ++ye, he != null && ye <= le && !(ye % 16) && he(T, ye), nt != null)) for (; At < ut; ) ft = M[At++], nt.X[(506832829 * ft & 4294967295) >>> nt.Mb] = ft;
          } else if (280 > ft) {
            if (ft = An(ft - 256, Le), Ut = Jt(jt.G[4], jt.H[4], Le), ot(Le), Ut = It(q, Ut = An(Ut, Le)), Le.h) break;
            if (ut - k < Ut || ee - ut < ft) break e;
            for (yn = 0; yn < ft; ++yn) M[ut + yn] = M[ut + yn - Ut];
            for (ut += ft, xe += ft; xe >= q; ) xe -= q, ++ye, he != null && ye <= le && !(ye % 16) && he(T, ye);
            if (e(ut <= ee), xe & st && (jt = In(tt, xe, ye)), nt != null) for (; At < ut; ) ft = M[At++], nt.X[(506832829 * ft & 4294967295) >>> nt.Mb] = ft;
          } else {
            if (!(ft < qt)) break e;
            for (Zt = ft - 280, e(nt != null); At < ut; ) ft = M[At++], nt.X[(506832829 * ft & 4294967295) >>> nt.Mb] = ft;
            ft = ut, e(!(Zt >>> (Ut = nt).Xa)), M[ft] = Ut.X[Zt], Zt = !0;
          }
          Zt || e(Le.h == ze(Le));
        }
        if (T.Pb && Le.h && ut < ee) e(T.m.h), T.a = 5, T.m = T.wd, T.$ = T.xd, 0 < T.s.ua && Bt(T.s.vb, T.s.Wa);
        else {
          if (Le.h) break e;
          he != null && he(T, ye > le ? le : ye), T.a = 0, T.$ = ut - k;
        }
        return 1;
      }
      return T.a = 3, 0;
    }
    function Ii(T) {
      e(T != null), T.vc = null, T.yc = null, T.Ya = null;
      var M = T.Wa;
      M != null && (M.X = null), T.vb = null, e(T != null);
    }
    function ui() {
      var T = new au();
      return T == null ? null : (T.a = 0, T.xb = Eh, ce("Predictor", "VP8LPredictors"), ce("Predictor", "VP8LPredictors_C"), ce("PredictorAdd", "VP8LPredictorsAdd"), ce("PredictorAdd", "VP8LPredictorsAdd_C"), Ei = si, ul = Un, ds = bn, $r = tr, Qo = pi, ea = Dr, Os = be, me.VP8LMapColor32b = Lc, me.VP8LMapColor8b = lu, T);
    }
    function Oi(T, M, k, q, ee) {
      var le = 1, he = [T], ye = [M], xe = q.m, Le = q.s, tt = null, ut = 0;
      e: for (; ; ) {
        if (k) for (; le && Ft(xe, 1); ) {
          var At = he, ct = ye, qt = q, Ot = 1, nt = qt.m, st = qt.gc[qt.ab], jt = Ft(nt, 2);
          if (qt.Oc & 1 << jt) le = 0;
          else {
            switch (qt.Oc |= 1 << jt, st.hc = jt, st.Ea = At[0], st.nc = ct[0], st.K = [null], ++qt.ab, e(4 >= qt.ab), jt) {
              case 0:
              case 1:
                st.b = Ft(nt, 3) + 2, Ot = Oi(Sn(st.Ea, st.b), Sn(st.nc, st.b), 0, qt, st.K), st.K = st.K[0];
                break;
              case 3:
                var Zt, ft = Ft(nt, 8) + 1, Ut = 16 < ft ? 0 : 4 < ft ? 1 : 2 < ft ? 2 : 3;
                if (At[0] = Sn(st.Ea, Ut), st.b = Ut, Zt = Ot = Oi(ft, 1, 0, qt, st.K)) {
                  var yn, jn = ft, xn = st, ri = 1 << (8 >> xn.b), Fi = l(ri);
                  if (Fi == null) Zt = 0;
                  else {
                    var ai = xn.K[0], Ai = xn.w;
                    for (Fi[0] = xn.K[0][0], yn = 1; yn < 1 * jn; ++yn) Fi[yn] = en(ai[Ai + yn], Fi[yn - 1]);
                    for (; yn < 4 * ri; ++yn) Fi[yn] = 0;
                    xn.K[0] = null, xn.K[0] = Fi, Zt = 1;
                  }
                }
                Ot = Zt;
                break;
              case 2:
                break;
              default:
                e(0);
            }
            le = Ot;
          }
        }
        if (he = he[0], ye = ye[0], le && Ft(xe, 1) && !(le = 1 <= (ut = Ft(xe, 4)) && 11 >= ut)) {
          q.a = 3;
          break e;
        }
        var Li;
        if (Li = le) t: {
          var Gn, Bn, Pr, Yr = q, lr = he, Ss = ye, Ri = ut, Ir = k, Jr = Yr.m, xr = Yr.s, kr = [null], jr = 1, no = 0, Fs = vh[Ri];
          n: for (; ; ) {
            if (Ir && Ft(Jr, 1)) {
              var cr = Ft(Jr, 3) + 2, na = Sn(lr, cr), va = Sn(Ss, cr), yo = na * va;
              if (!Oi(na, va, 0, Yr, kr)) break n;
              for (kr = kr[0], xr.xc = cr, Gn = 0; Gn < yo; ++Gn) {
                var xa = kr[Gn] >> 8 & 65535;
                kr[Gn] = xa, xa >= jr && (jr = xa + 1);
              }
            }
            if (Jr.h) break n;
            for (Bn = 0; 5 > Bn; ++Bn) {
              var ur = fu[Bn];
              !Bn && 0 < Ri && (ur += 1 << Ri), no < ur && (no = ur);
            }
            var nc = c(jr * Fs, _e), Wu = jr, b = c(Wu, Me);
            if (b == null) var s = null;
            else e(65536 >= Wu), s = b;
            var u = l(no);
            if (s == null || u == null || nc == null) {
              Yr.a = 1;
              break n;
            }
            var p = nc;
            for (Gn = Pr = 0; Gn < jr; ++Gn) {
              var m = s[Gn], x = m.G, E = m.H, L = 0, B = 1, N = 0;
              for (Bn = 0; 5 > Bn; ++Bn) {
                ur = fu[Bn], x[Bn] = p, E[Bn] = Pr, !Bn && 0 < Ri && (ur += 1 << Ri);
                r: {
                  var G, Z = ur, $ = Yr, re = u, ae = p, Pe = Pr, Ce = 0, Ie = $.m, Be = Ft(Ie, 1);
                  if (r(re, 0, 0, Z), Be) {
                    var He = Ft(Ie, 1) + 1, We = Ft(Ie, 1), $e = Ft(Ie, We == 0 ? 1 : 8);
                    re[$e] = 1, He == 2 && (re[$e = Ft(Ie, 8)] = 1);
                    var Je = 1;
                  } else {
                    var Qe = l(19), wt = Ft(Ie, 4) + 4;
                    if (19 < wt) {
                      $.a = 3;
                      var bt = 0;
                      break r;
                    }
                    for (G = 0; G < wt; ++G) Qe[Ql[G]] = Ft(Ie, 3);
                    var Mt = void 0, Nt = void 0, Ct = $, sn = Qe, nn = Z, Gt = re, dn = 0, Hn = Ct.m, bi = 8, Qi = c(128, _e);
                    i: for (; pe(Qi, 0, 7, sn, 19); ) {
                      if (Ft(Hn, 1)) {
                        var Gi = 2 + 2 * Ft(Hn, 3);
                        if ((Mt = 2 + Ft(Hn, Gi)) > nn) break i;
                      } else Mt = nn;
                      for (Nt = 0; Nt < nn && Mt--; ) {
                        ot(Hn);
                        var er = Qi[0 + (127 & Re(Hn))];
                        Xe(Hn, Hn.u + er.g);
                        var Ci = er.value;
                        if (16 > Ci) Gt[Nt++] = Ci, Ci != 0 && (bi = Ci);
                        else {
                          var Ni = Ci == 16, ki = Ci - 16, ps = bh[ki], Mr = Ft(Hn, du[ki]) + ps;
                          if (Nt + Mr > nn) break i;
                          for (var zr = Ni ? bi : 0; 0 < Mr--; ) Gt[Nt++] = zr;
                        }
                      }
                      dn = 1;
                      break i;
                    }
                    dn || (Ct.a = 3), Je = dn;
                  }
                  (Je = Je && !Ie.h) && (Ce = pe(ae, Pe, 8, re, Z)), Je && Ce != 0 ? bt = Ce : ($.a = 3, bt = 0);
                }
                if (bt == 0) break n;
                if (B && sr[Bn] == 1 && (B = p[Pr].g == 0), L += p[Pr].g, Pr += bt, 3 >= Bn) {
                  var Gr, ia = u[0];
                  for (Gr = 1; Gr < ur; ++Gr) u[Gr] > ia && (ia = u[Gr]);
                  N += ia;
                }
              }
              if (m.nd = B, m.Qb = 0, B && (m.qb = (x[3][E[3] + 0].value << 24 | x[1][E[1] + 0].value << 16 | x[2][E[2] + 0].value) >>> 0, L == 0 && 256 > x[0][E[0] + 0].value && (m.Qb = 1, m.qb += x[0][E[0] + 0].value << 8)), m.jc = !m.Qb && 6 > N, m.jc) {
                var bo, Lr = m;
                for (bo = 0; bo < rr; ++bo) {
                  var Cs = bo, Oo = Lr.pd[Cs], bl = Lr.G[0][Lr.H[0] + Cs];
                  256 <= bl.value ? (Oo.g = bl.g + 256, Oo.value = bl.value) : (Oo.g = 0, Oo.value = 0, Cs >>= cn(bl, 8, Oo), Cs >>= cn(Lr.G[1][Lr.H[1] + Cs], 16, Oo), Cs >>= cn(Lr.G[2][Lr.H[2] + Cs], 0, Oo), cn(Lr.G[3][Lr.H[3] + Cs], 24, Oo));
                }
              }
            }
            xr.vc = kr, xr.Wb = jr, xr.Ya = s, xr.yc = nc, Li = 1;
            break t;
          }
          Li = 0;
        }
        if (!(le = Li)) {
          q.a = 3;
          break e;
        }
        if (0 < ut) {
          if (Le.ua = 1 << ut, !wn(Le.Wa, ut)) {
            q.a = 1, le = 0;
            break e;
          }
        } else Le.ua = 0;
        var vl = q, Ns = he, Do = ye, io = vl.s, ks = io.xc;
        if (vl.c = Ns, vl.i = Do, io.md = Sn(Ns, ks), io.wc = ks == 0 ? -1 : (1 << ks) - 1, k) {
          q.xb = cd;
          break e;
        }
        if ((tt = l(he * ye)) == null) {
          q.a = 1, le = 0;
          break e;
        }
        le = (le = Pi(q, tt, 0, he, ye, ye, null)) && !xe.h;
        break e;
      }
      return le ? (ee != null ? ee[0] = tt : (e(tt == null), e(k)), q.$ = 0, k || Ii(Le)) : Ii(Le), le;
    }
    function _i(T, M) {
      var k = T.c * T.i, q = k + M + 16 * M;
      return e(T.c <= M), T.V = l(q), T.V == null ? (T.Ta = null, T.Ua = 0, T.a = 1, 0) : (T.Ta = T.V, T.Ua = T.Ba + k + M, 1);
    }
    function xs(T, M) {
      var k = T.C, q = M - k, ee = T.V, le = T.Ba + T.c * k;
      for (e(M <= T.l.o); 0 < q; ) {
        var he = 16 < q ? 16 : q, ye = T.l.ma, xe = T.l.width, Le = xe * he, tt = ye.ca, ut = ye.tb + xe * k, At = T.Ta, ct = T.Ua;
        Zn(T, he, ee, le), Cr(At, ct, tt, ut, Le), xi(ye, k, k + he, tt, ut, xe), q -= he, ee += he * T.c, k += he;
      }
      e(k == M), T.C = T.Ma = M;
    }
    function ws() {
      this.ub = this.yd = this.td = this.Rb = 0;
    }
    function Ao() {
      this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
    }
    function qs() {
      this.Fb = this.Bb = this.Cb = 0, this.Zb = l(4), this.Lb = l(4);
    }
    function To() {
      this.Yb = function() {
        var T = [];
        return function M(k, q, ee) {
          for (var le = ee[q], he = 0; he < le && (k.push(ee.length > q + 1 ? [] : 0), !(ee.length < q + 1)); he++) M(k[he], q + 1, ee);
        }(T, 0, [3, 11]), T;
      }();
    }
    function Ia() {
      this.jb = l(3), this.Wc = a([4, 8], To), this.Xc = a([4, 17], To);
    }
    function Hr() {
      this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new l(4), this.od = new l(4);
    }
    function Hs() {
      this.ld = this.La = this.dd = this.tc = 0;
    }
    function Wr() {
      this.Na = this.la = 0;
    }
    function Ws() {
      this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
    }
    function $o() {
      this.ad = l(384), this.Za = 0, this.Ob = l(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
    }
    function Zs() {
      this.uc = this.M = this.Nb = 0, this.wa = Array(new Hs()), this.Y = 0, this.ya = Array(new $o()), this.aa = 0, this.l = new Xo();
    }
    function $s() {
      this.y = l(16), this.f = l(8), this.ea = l(8);
    }
    function Il() {
      this.cb = this.a = 0, this.sc = "", this.m = new mn(), this.Od = new ws(), this.Kc = new Ao(), this.ed = new Hr(), this.Qa = new qs(), this.Ic = this.$c = this.Aa = 0, this.D = new Zs(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = c(8, mn), this.ia = 0, this.pb = c(4, Ws), this.Pa = new Ia(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new $s()), this.Hd = 0, this.rb = Array(new Wr()), this.sb = 0, this.wa = Array(new Hs()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new $o()), this.L = this.aa = 0, this.gd = a([4, 2], Hs), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
    }
    function Xo() {
      this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
    }
    function Xs() {
      var T = new Il();
      return T != null && (T.a = 0, T.sc = "OK", T.cb = 0, T.Xb = 0, _a || (_a = da)), T;
    }
    function Ti(T, M, k) {
      return T.a == 0 && (T.a = M, T.sc = k, T.cb = 0), 0;
    }
    function ha(T, M, k) {
      return 3 <= k && T[M + 0] == 157 && T[M + 1] == 1 && T[M + 2] == 42;
    }
    function Ys(T, M) {
      if (T == null) return 0;
      if (T.a = 0, T.sc = "OK", M == null) return Ti(T, 2, "null VP8Io passed to VP8GetHeaders()");
      var k = M.data, q = M.w, ee = M.ha;
      if (4 > ee) return Ti(T, 7, "Truncated header.");
      var le = k[q + 0] | k[q + 1] << 8 | k[q + 2] << 16, he = T.Od;
      if (he.Rb = !(1 & le), he.td = le >> 1 & 7, he.yd = le >> 4 & 1, he.ub = le >> 5, 3 < he.td) return Ti(T, 3, "Incorrect keyframe parameters.");
      if (!he.yd) return Ti(T, 4, "Frame not displayable.");
      q += 3, ee -= 3;
      var ye = T.Kc;
      if (he.Rb) {
        if (7 > ee) return Ti(T, 7, "cannot parse picture header");
        if (!ha(k, q, ee)) return Ti(T, 3, "Bad code word");
        ye.c = 16383 & (k[q + 4] << 8 | k[q + 3]), ye.Td = k[q + 4] >> 6, ye.i = 16383 & (k[q + 6] << 8 | k[q + 5]), ye.Ud = k[q + 6] >> 6, q += 7, ee -= 7, T.za = ye.c + 15 >> 4, T.Ub = ye.i + 15 >> 4, M.width = ye.c, M.height = ye.i, M.Da = 0, M.j = 0, M.v = 0, M.va = M.width, M.o = M.height, M.da = 0, M.ib = M.width, M.hb = M.height, M.U = M.width, M.T = M.height, r((le = T.Pa).jb, 0, 255, le.jb.length), e((le = T.Qa) != null), le.Cb = 0, le.Bb = 0, le.Fb = 1, r(le.Zb, 0, 0, le.Zb.length), r(le.Lb, 0, 0, le.Lb);
      }
      if (he.ub > ee) return Ti(T, 7, "bad partition length");
      St(le = T.m, k, q, he.ub), q += he.ub, ee -= he.ub, he.Rb && (ye.Ld = xt(le), ye.Kd = xt(le)), ye = T.Qa;
      var xe, Le = T.Pa;
      if (e(le != null), e(ye != null), ye.Cb = xt(le), ye.Cb) {
        if (ye.Bb = xt(le), xt(le)) {
          for (ye.Fb = xt(le), xe = 0; 4 > xe; ++xe) ye.Zb[xe] = xt(le) ? Pt(le, 7) : 0;
          for (xe = 0; 4 > xe; ++xe) ye.Lb[xe] = xt(le) ? Pt(le, 6) : 0;
        }
        if (ye.Bb) for (xe = 0; 3 > xe; ++xe) Le.jb[xe] = xt(le) ? dt(le, 8) : 255;
      } else ye.Bb = 0;
      if (le.Ka) return Ti(T, 3, "cannot parse segment header");
      if ((ye = T.ed).zd = xt(le), ye.Tb = dt(le, 6), ye.wb = dt(le, 3), ye.Pc = xt(le), ye.Pc && xt(le)) {
        for (Le = 0; 4 > Le; ++Le) xt(le) && (ye.vd[Le] = Pt(le, 6));
        for (Le = 0; 4 > Le; ++Le) xt(le) && (ye.od[Le] = Pt(le, 6));
      }
      if (T.L = ye.Tb == 0 ? 0 : ye.zd ? 1 : 2, le.Ka) return Ti(T, 3, "cannot parse filter header");
      var tt = ee;
      if (ee = xe = q, q = xe + tt, ye = tt, T.Xb = (1 << dt(T.m, 2)) - 1, tt < 3 * (Le = T.Xb)) k = 7;
      else {
        for (xe += 3 * Le, ye -= 3 * Le, tt = 0; tt < Le; ++tt) {
          var ut = k[ee + 0] | k[ee + 1] << 8 | k[ee + 2] << 16;
          ut > ye && (ut = ye), St(T.Jc[+tt], k, xe, ut), xe += ut, ye -= ut, ee += 3;
        }
        St(T.Jc[+Le], k, xe, ye), k = xe < q ? 0 : 5;
      }
      if (k != 0) return Ti(T, k, "cannot parse partitions");
      for (k = dt(xe = T.m, 7), ee = xt(xe) ? Pt(xe, 4) : 0, q = xt(xe) ? Pt(xe, 4) : 0, ye = xt(xe) ? Pt(xe, 4) : 0, Le = xt(xe) ? Pt(xe, 4) : 0, xe = xt(xe) ? Pt(xe, 4) : 0, tt = T.Qa, ut = 0; 4 > ut; ++ut) {
        if (tt.Cb) {
          var At = tt.Zb[ut];
          tt.Fb || (At += k);
        } else {
          if (0 < ut) {
            T.pb[ut] = T.pb[0];
            continue;
          }
          At = k;
        }
        var ct = T.pb[ut];
        ct.Sc[0] = Gu[Bs(At + ee, 127)], ct.Sc[1] = gl[Bs(At + 0, 127)], ct.Eb[0] = 2 * Gu[Bs(At + q, 127)], ct.Eb[1] = 101581 * gl[Bs(At + ye, 127)] >> 16, 8 > ct.Eb[1] && (ct.Eb[1] = 8), ct.Qc[0] = Gu[Bs(At + Le, 117)], ct.Qc[1] = gl[Bs(At + xe, 127)], ct.lc = At + xe;
      }
      if (!he.Rb) return Ti(T, 4, "Not a key frame.");
      for (xt(le), he = T.Pa, k = 0; 4 > k; ++k) {
        for (ee = 0; 8 > ee; ++ee) for (q = 0; 3 > q; ++q) for (ye = 0; 11 > ye; ++ye) Le = ht(le, ld[k][ee][q][ye]) ? dt(le, 8) : Ah[k][ee][q][ye], he.Wc[k][ee].Yb[q][ye] = Le;
        for (ee = 0; 17 > ee; ++ee) he.Xc[k][ee] = he.Wc[k][ml[ee]];
      }
      return T.kc = xt(le), T.kc && (T.Bd = dt(le, 8)), T.cb = 1;
    }
    function da(T, M, k, q, ee, le, he) {
      var ye = M[ee].Yb[k];
      for (k = 0; 16 > ee; ++ee) {
        if (!ht(T, ye[k + 0])) return ee;
        for (; !ht(T, ye[k + 1]); ) if (ye = M[++ee].Yb[0], k = 0, ee == 16) return 16;
        var xe = M[ee + 1].Yb;
        if (ht(T, ye[k + 2])) {
          var Le = T, tt = 0;
          if (ht(Le, (At = ye)[(ut = k) + 3]))
            if (ht(Le, At[ut + 6])) {
              for (ye = 0, ut = 2 * (tt = ht(Le, At[ut + 8])) + (At = ht(Le, At[ut + 9 + tt])), tt = 0, At = Vu[ut]; At[ye]; ++ye) tt += tt + ht(Le, At[ye]);
              tt += 3 + (8 << ut);
            } else ht(Le, At[ut + 7]) ? (tt = 7 + 2 * ht(Le, 165), tt += ht(Le, 145)) : tt = 5 + ht(Le, 159);
          else tt = ht(Le, At[ut + 4]) ? 3 + ht(Le, At[ut + 5]) : 2;
          ye = xe[2];
        } else tt = 1, ye = xe[1];
        xe = he + pu[ee], 0 > (Le = T).b && rt(Le);
        var ut, At = Le.b, ct = (ut = Le.Ca >> 1) - (Le.I >> At) >> 31;
        --Le.b, Le.Ca += ct, Le.Ca |= 1, Le.I -= (ut + 1 & ct) << At, le[xe] = ((tt ^ ct) - ct) * q[(0 < ee) + 0];
      }
      return 16;
    }
    function Eo(T) {
      var M = T.rb[T.sb - 1];
      M.la = 0, M.Na = 0, r(T.zc, 0, 0, T.zc.length), T.ja = 0;
    }
    function sl(T, M) {
      if (T == null) return 0;
      if (M == null) return Ti(T, 2, "NULL VP8Io parameter in VP8Decode().");
      if (!T.cb && !Ys(T, M)) return 0;
      if (e(T.cb), M.ac == null || M.ac(M)) {
        M.ob && (T.L = 0);
        var k = _u[T.L];
        if (T.L == 2 ? (T.yb = 0, T.zb = 0) : (T.yb = M.v - k >> 4, T.zb = M.j - k >> 4, 0 > T.yb && (T.yb = 0), 0 > T.zb && (T.zb = 0)), T.Va = M.o + 15 + k >> 4, T.Hb = M.va + 15 + k >> 4, T.Hb > T.za && (T.Hb = T.za), T.Va > T.Ub && (T.Va = T.Ub), 0 < T.L) {
          var q = T.ed;
          for (k = 0; 4 > k; ++k) {
            var ee;
            if (T.Qa.Cb) {
              var le = T.Qa.Lb[k];
              T.Qa.Fb || (le += q.Tb);
            } else le = q.Tb;
            for (ee = 0; 1 >= ee; ++ee) {
              var he = T.gd[k][ee], ye = le;
              if (q.Pc && (ye += q.vd[0], ee && (ye += q.od[0])), 0 < (ye = 0 > ye ? 0 : 63 < ye ? 63 : ye)) {
                var xe = ye;
                0 < q.wb && (xe = 4 < q.wb ? xe >> 2 : xe >> 1) > 9 - q.wb && (xe = 9 - q.wb), 1 > xe && (xe = 1), he.dd = xe, he.tc = 2 * ye + xe, he.ld = 40 <= ye ? 2 : 15 <= ye ? 1 : 0;
              } else he.tc = 0;
              he.La = ee;
            }
          }
        }
        k = 0;
      } else Ti(T, 6, "Frame setup failed"), k = T.a;
      if (k = k == 0) {
        if (k) {
          T.$c = 0, 0 < T.Aa || (T.Ic = zc);
          e: {
            k = T.Ic, q = 4 * (xe = T.za);
            var Le = 32 * xe, tt = xe + 1, ut = 0 < T.L ? xe * (0 < T.Aa ? 2 : 1) : 0, At = (T.Aa == 2 ? 2 : 1) * xe;
            if ((he = q + 832 + (ee = 3 * (16 * k + _u[T.L]) / 2 * Le) + (le = T.Fa != null && 0 < T.Fa.length ? T.Kc.c * T.Kc.i : 0)) != he) k = 0;
            else {
              if (he > T.Vb) {
                if (T.Vb = 0, T.Ec = l(he), T.Fc = 0, T.Ec == null) {
                  k = Ti(T, 1, "no memory during frame initialization.");
                  break e;
                }
                T.Vb = he;
              }
              he = T.Ec, ye = T.Fc, T.Ac = he, T.Bc = ye, ye += q, T.Gd = c(Le, $s), T.Hd = 0, T.rb = c(tt + 1, Wr), T.sb = 1, T.wa = ut ? c(ut, Hs) : null, T.Y = 0, T.D.Nb = 0, T.D.wa = T.wa, T.D.Y = T.Y, 0 < T.Aa && (T.D.Y += xe), e(!0), T.oc = he, T.pc = ye, ye += 832, T.ya = c(At, $o), T.aa = 0, T.D.ya = T.ya, T.D.aa = T.aa, T.Aa == 2 && (T.D.aa += xe), T.R = 16 * xe, T.B = 8 * xe, xe = (Le = _u[T.L]) * T.R, Le = Le / 2 * T.B, T.sa = he, T.ta = ye + xe, T.qa = T.sa, T.ra = T.ta + 16 * k * T.R + Le, T.Ha = T.qa, T.Ia = T.ra + 8 * k * T.B + Le, T.$c = 0, ye += ee, T.mb = le ? he : null, T.nb = le ? ye : null, e(ye + le <= T.Fc + T.Vb), Eo(T), r(T.Ac, T.Bc, 0, q), k = 1;
            }
          }
          if (k) {
            if (M.ka = 0, M.y = T.sa, M.O = T.ta, M.f = T.qa, M.N = T.ra, M.ea = T.Ha, M.Vd = T.Ia, M.fa = T.R, M.Rc = T.B, M.F = null, M.J = 0, !$l) {
              for (k = -255; 255 >= k; ++k) Nr[255 + k] = 0 > k ? -k : k;
              for (k = -1020; 1020 >= k; ++k) za[1020 + k] = -128 > k ? -128 : 127 < k ? 127 : k;
              for (k = -112; 112 >= k; ++k) fl[112 + k] = -16 > k ? -16 : 15 < k ? 15 : k;
              for (k = -255; 510 >= k; ++k) Ua[255 + k] = 0 > k ? 0 : 255 < k ? 255 : k;
              $l = 1;
            }
            ta = we, Fr = Qn, Rc = Ma, fs = Ec, Xr = ge, vr = as, Fa = Dl, Wl = eo, Na = Ic, ma = Fl, hl = ku, go = Pc, Mo = ou, Zl = Nl, ka = ol, oi = yi, dl = Ks, Lo = fo, Ts[0] = Zr, Ts[1] = _t, Ts[2] = Js, Ts[3] = ru, Ts[4] = Ll, Ts[5] = Yo, Ts[6] = Ui, Ts[7] = li, Ts[8] = Rl, Ts[9] = Kn, ya[0] = Ki, ya[1] = gn, ya[2] = Rn, ya[3] = hi, ya[4] = qn, ya[5] = Ml, ya[6] = ho, ba[0] = So, ba[1] = Kt, ba[2] = gi, ba[3] = fa, ba[4] = Jo, ba[5] = Bl, ba[6] = Ko, k = 1;
          } else k = 0;
        }
        k && (k = function(ct, qt) {
          for (ct.M = 0; ct.M < ct.Va; ++ct.M) {
            var Ot, nt = ct.Jc[ct.M & ct.Xb], st = ct.m, jt = ct;
            for (Ot = 0; Ot < jt.za; ++Ot) {
              var Zt = st, ft = jt, Ut = ft.Ac, yn = ft.Bc + 4 * Ot, jn = ft.zc, xn = ft.ya[ft.aa + Ot];
              if (ft.Qa.Bb ? xn.$b = ht(Zt, ft.Pa.jb[0]) ? 2 + ht(Zt, ft.Pa.jb[2]) : ht(Zt, ft.Pa.jb[1]) : xn.$b = 0, ft.kc && (xn.Ad = ht(Zt, ft.Bd)), xn.Za = !ht(Zt, 145) + 0, xn.Za) {
                var ri = xn.Ob, Fi = 0;
                for (ft = 0; 4 > ft; ++ft) {
                  var ai, Ai = jn[0 + ft];
                  for (ai = 0; 4 > ai; ++ai) {
                    Ai = Th[Ut[yn + ai]][Ai];
                    for (var Li = wh[ht(Zt, Ai[0])]; 0 < Li; ) Li = wh[2 * Li + ht(Zt, Ai[Li])];
                    Ai = -Li, Ut[yn + ai] = Ai;
                  }
                  i(ri, Fi, Ut, yn, 4), Fi += 4, jn[0 + ft] = Ai;
                }
              } else Ai = ht(Zt, 156) ? ht(Zt, 128) ? 1 : 3 : ht(Zt, 163) ? 2 : 0, xn.Ob[0] = Ai, r(Ut, yn, Ai, 4), r(jn, 0, Ai, 4);
              xn.Dd = ht(Zt, 142) ? ht(Zt, 114) ? ht(Zt, 183) ? 1 : 3 : 2 : 0;
            }
            if (jt.m.Ka) return Ti(ct, 7, "Premature end-of-partition0 encountered.");
            for (; ct.ja < ct.za; ++ct.ja) {
              if (jt = nt, Zt = (st = ct).rb[st.sb - 1], Ut = st.rb[st.sb + st.ja], Ot = st.ya[st.aa + st.ja], yn = st.kc ? Ot.Ad : 0) Zt.la = Ut.la = 0, Ot.Za || (Zt.Na = Ut.Na = 0), Ot.Hc = 0, Ot.Gc = 0, Ot.ia = 0;
              else {
                var Gn, Bn;
                if (Zt = Ut, Ut = jt, yn = st.Pa.Xc, jn = st.ya[st.aa + st.ja], xn = st.pb[jn.$b], ft = jn.ad, ri = 0, Fi = st.rb[st.sb - 1], Ai = ai = 0, r(ft, ri, 0, 384), jn.Za) var Pr = 0, Yr = yn[3];
                else {
                  Li = l(16);
                  var lr = Zt.Na + Fi.Na;
                  if (lr = _a(Ut, yn[1], lr, xn.Eb, 0, Li, 0), Zt.Na = Fi.Na = (0 < lr) + 0, 1 < lr) ta(Li, 0, ft, ri);
                  else {
                    var Ss = Li[0] + 3 >> 3;
                    for (Li = 0; 256 > Li; Li += 16) ft[ri + Li] = Ss;
                  }
                  Pr = 1, Yr = yn[0];
                }
                var Ri = 15 & Zt.la, Ir = 15 & Fi.la;
                for (Li = 0; 4 > Li; ++Li) {
                  var Jr = 1 & Ir;
                  for (Ss = Bn = 0; 4 > Ss; ++Ss) Ri = Ri >> 1 | (Jr = (lr = _a(Ut, Yr, lr = Jr + (1 & Ri), xn.Sc, Pr, ft, ri)) > Pr) << 7, Bn = Bn << 2 | (3 < lr ? 3 : 1 < lr ? 2 : ft[ri + 0] != 0), ri += 16;
                  Ri >>= 4, Ir = Ir >> 1 | Jr << 7, ai = (ai << 8 | Bn) >>> 0;
                }
                for (Yr = Ri, Pr = Ir >> 4, Gn = 0; 4 > Gn; Gn += 2) {
                  for (Bn = 0, Ri = Zt.la >> 4 + Gn, Ir = Fi.la >> 4 + Gn, Li = 0; 2 > Li; ++Li) {
                    for (Jr = 1 & Ir, Ss = 0; 2 > Ss; ++Ss) lr = Jr + (1 & Ri), Ri = Ri >> 1 | (Jr = 0 < (lr = _a(Ut, yn[2], lr, xn.Qc, 0, ft, ri))) << 3, Bn = Bn << 2 | (3 < lr ? 3 : 1 < lr ? 2 : ft[ri + 0] != 0), ri += 16;
                    Ri >>= 2, Ir = Ir >> 1 | Jr << 5;
                  }
                  Ai |= Bn << 4 * Gn, Yr |= Ri << 4 << Gn, Pr |= (240 & Ir) << Gn;
                }
                Zt.la = Yr, Fi.la = Pr, jn.Hc = ai, jn.Gc = Ai, jn.ia = 43690 & Ai ? 0 : xn.ia, yn = !(ai | Ai);
              }
              if (0 < st.L && (st.wa[st.Y + st.ja] = st.gd[Ot.$b][Ot.Za], st.wa[st.Y + st.ja].La |= !yn), jt.Ka) return Ti(ct, 7, "Premature end-of-file encountered.");
            }
            if (Eo(ct), st = qt, jt = 1, Ot = (nt = ct).D, Zt = 0 < nt.L && nt.M >= nt.zb && nt.M <= nt.Va, nt.Aa == 0) e: {
              if (Ot.M = nt.M, Ot.uc = Zt, jl(nt, Ot), jt = 1, Ot = (Bn = nt.D).Nb, Zt = (Ai = _u[nt.L]) * nt.R, Ut = Ai / 2 * nt.B, Li = 16 * Ot * nt.R, Ss = 8 * Ot * nt.B, yn = nt.sa, jn = nt.ta - Zt + Li, xn = nt.qa, ft = nt.ra - Ut + Ss, ri = nt.Ha, Fi = nt.Ia - Ut + Ss, Ir = (Ri = Bn.M) == 0, ai = Ri >= nt.Va - 1, nt.Aa == 2 && jl(nt, Bn), Bn.uc) for (Jr = (lr = nt).D.M, e(lr.D.uc), Bn = lr.yb; Bn < lr.Hb; ++Bn) {
                Pr = Bn, Yr = Jr;
                var xr = (kr = (ur = lr).D).Nb;
                Gn = ur.R;
                var kr = kr.wa[kr.Y + Pr], jr = ur.sa, no = ur.ta + 16 * xr * Gn + 16 * Pr, Fs = kr.dd, cr = kr.tc;
                if (cr != 0) if (e(3 <= cr), ur.L == 1) 0 < Pr && oi(jr, no, Gn, cr + 4), kr.La && Lo(jr, no, Gn, cr), 0 < Yr && ka(jr, no, Gn, cr + 4), kr.La && dl(jr, no, Gn, cr);
                else {
                  var na = ur.B, va = ur.qa, yo = ur.ra + 8 * xr * na + 8 * Pr, xa = ur.Ha, ur = ur.Ia + 8 * xr * na + 8 * Pr;
                  xr = kr.ld, 0 < Pr && (Wl(jr, no, Gn, cr + 4, Fs, xr), ma(va, yo, xa, ur, na, cr + 4, Fs, xr)), kr.La && (go(jr, no, Gn, cr, Fs, xr), Zl(va, yo, xa, ur, na, cr, Fs, xr)), 0 < Yr && (Fa(jr, no, Gn, cr + 4, Fs, xr), Na(va, yo, xa, ur, na, cr + 4, Fs, xr)), kr.La && (hl(jr, no, Gn, cr, Fs, xr), Mo(va, yo, xa, ur, na, cr, Fs, xr));
                }
              }
              if (nt.ia && alert("todo:DitherRow"), st.put != null) {
                if (Bn = 16 * Ri, Ri = 16 * (Ri + 1), Ir ? (st.y = nt.sa, st.O = nt.ta + Li, st.f = nt.qa, st.N = nt.ra + Ss, st.ea = nt.Ha, st.W = nt.Ia + Ss) : (Bn -= Ai, st.y = yn, st.O = jn, st.f = xn, st.N = ft, st.ea = ri, st.W = Fi), ai || (Ri -= Ai), Ri > st.o && (Ri = st.o), st.F = null, st.J = null, nt.Fa != null && 0 < nt.Fa.length && Bn < Ri && (st.J = Ba(nt, st, Bn, Ri - Bn), st.F = nt.mb, st.F == null && st.F.length == 0)) {
                  jt = Ti(nt, 3, "Could not decode alpha data.");
                  break e;
                }
                Bn < st.j && (Ai = st.j - Bn, Bn = st.j, e(!(1 & Ai)), st.O += nt.R * Ai, st.N += nt.B * (Ai >> 1), st.W += nt.B * (Ai >> 1), st.F != null && (st.J += st.width * Ai)), Bn < Ri && (st.O += st.v, st.N += st.v >> 1, st.W += st.v >> 1, st.F != null && (st.J += st.v), st.ka = Bn - st.j, st.U = st.va - st.v, st.T = Ri - Bn, jt = st.put(st));
              }
              Ot + 1 != nt.Ic || ai || (i(nt.sa, nt.ta - Zt, yn, jn + 16 * nt.R, Zt), i(nt.qa, nt.ra - Ut, xn, ft + 8 * nt.B, Ut), i(nt.Ha, nt.Ia - Ut, ri, Fi + 8 * nt.B, Ut));
            }
            if (!jt) return Ti(ct, 6, "Output aborted.");
          }
          return 1;
        }(T, M)), M.bc != null && M.bc(M), k &= 1;
      }
      return k ? (T.cb = 0, k) : 0;
    }
    function yr(T, M, k, q, ee) {
      ee = T[M + k + 32 * q] + (ee >> 3), T[M + k + 32 * q] = -256 & ee ? 0 > ee ? 0 : 255 : ee;
    }
    function os(T, M, k, q, ee, le) {
      yr(T, M, 0, k, q + ee), yr(T, M, 1, k, q + le), yr(T, M, 2, k, q - le), yr(T, M, 3, k, q - ee);
    }
    function nr(T) {
      return (20091 * T >> 16) + T;
    }
    function Xn(T, M, k, q) {
      var ee, le = 0, he = l(16);
      for (ee = 0; 4 > ee; ++ee) {
        var ye = T[M + 0] + T[M + 8], xe = T[M + 0] - T[M + 8], Le = (35468 * T[M + 4] >> 16) - nr(T[M + 12]), tt = nr(T[M + 4]) + (35468 * T[M + 12] >> 16);
        he[le + 0] = ye + tt, he[le + 1] = xe + Le, he[le + 2] = xe - Le, he[le + 3] = ye - tt, le += 4, M++;
      }
      for (ee = le = 0; 4 > ee; ++ee) ye = (T = he[le + 0] + 4) + he[le + 8], xe = T - he[le + 8], Le = (35468 * he[le + 4] >> 16) - nr(he[le + 12]), yr(k, q, 0, 0, ye + (tt = nr(he[le + 4]) + (35468 * he[le + 12] >> 16))), yr(k, q, 1, 0, xe + Le), yr(k, q, 2, 0, xe - Le), yr(k, q, 3, 0, ye - tt), le++, q += 32;
    }
    function as(T, M, k, q) {
      var ee = T[M + 0] + 4, le = 35468 * T[M + 4] >> 16, he = nr(T[M + 4]), ye = 35468 * T[M + 1] >> 16;
      os(k, q, 0, ee + he, T = nr(T[M + 1]), ye), os(k, q, 1, ee + le, T, ye), os(k, q, 2, ee - le, T, ye), os(k, q, 3, ee - he, T, ye);
    }
    function Qn(T, M, k, q, ee) {
      Xn(T, M, k, q), ee && Xn(T, M + 16, k, q + 4);
    }
    function Ma(T, M, k, q) {
      Fr(T, M + 0, k, q, 1), Fr(T, M + 32, k, q + 128, 1);
    }
    function Ec(T, M, k, q) {
      var ee;
      for (T = T[M + 0] + 4, ee = 0; 4 > ee; ++ee) for (M = 0; 4 > M; ++M) yr(k, q, M, ee, T);
    }
    function ge(T, M, k, q) {
      T[M + 0] && fs(T, M + 0, k, q), T[M + 16] && fs(T, M + 16, k, q + 4), T[M + 32] && fs(T, M + 32, k, q + 128), T[M + 48] && fs(T, M + 48, k, q + 128 + 4);
    }
    function we(T, M, k, q) {
      var ee, le = l(16);
      for (ee = 0; 4 > ee; ++ee) {
        var he = T[M + 0 + ee] + T[M + 12 + ee], ye = T[M + 4 + ee] + T[M + 8 + ee], xe = T[M + 4 + ee] - T[M + 8 + ee], Le = T[M + 0 + ee] - T[M + 12 + ee];
        le[0 + ee] = he + ye, le[8 + ee] = he - ye, le[4 + ee] = Le + xe, le[12 + ee] = Le - xe;
      }
      for (ee = 0; 4 > ee; ++ee) he = (T = le[0 + 4 * ee] + 3) + le[3 + 4 * ee], ye = le[1 + 4 * ee] + le[2 + 4 * ee], xe = le[1 + 4 * ee] - le[2 + 4 * ee], Le = T - le[3 + 4 * ee], k[q + 0] = he + ye >> 3, k[q + 16] = Le + xe >> 3, k[q + 32] = he - ye >> 3, k[q + 48] = Le - xe >> 3, q += 64;
    }
    function Ve(T, M, k) {
      var q, ee = M - 32, le = to, he = 255 - T[ee - 1];
      for (q = 0; q < k; ++q) {
        var ye, xe = le, Le = he + T[M - 1];
        for (ye = 0; ye < k; ++ye) T[M + ye] = xe[Le + T[ee + ye]];
        M += 32;
      }
    }
    function _t(T, M) {
      Ve(T, M, 4);
    }
    function Kt(T, M) {
      Ve(T, M, 8);
    }
    function gn(T, M) {
      Ve(T, M, 16);
    }
    function Rn(T, M) {
      var k;
      for (k = 0; 16 > k; ++k) i(T, M + 32 * k, T, M - 32, 16);
    }
    function hi(T, M) {
      var k;
      for (k = 16; 0 < k; --k) r(T, M, T[M - 1], 16), M += 32;
    }
    function Ji(T, M, k) {
      var q;
      for (q = 0; 16 > q; ++q) r(M, k + 32 * q, T, 16);
    }
    function Ki(T, M) {
      var k, q = 16;
      for (k = 0; 16 > k; ++k) q += T[M - 1 + 32 * k] + T[M + k - 32];
      Ji(q >> 5, T, M);
    }
    function qn(T, M) {
      var k, q = 8;
      for (k = 0; 16 > k; ++k) q += T[M - 1 + 32 * k];
      Ji(q >> 4, T, M);
    }
    function Ml(T, M) {
      var k, q = 8;
      for (k = 0; 16 > k; ++k) q += T[M + k - 32];
      Ji(q >> 4, T, M);
    }
    function ho(T, M) {
      Ji(128, T, M);
    }
    function Vn(T, M, k) {
      return T + 2 * M + k + 2 >> 2;
    }
    function Js(T, M) {
      var k, q = M - 32;
      for (q = new Uint8Array([Vn(T[q - 1], T[q + 0], T[q + 1]), Vn(T[q + 0], T[q + 1], T[q + 2]), Vn(T[q + 1], T[q + 2], T[q + 3]), Vn(T[q + 2], T[q + 3], T[q + 4])]), k = 0; 4 > k; ++k) i(T, M + 32 * k, q, 0, q.length);
    }
    function ru(T, M) {
      var k = T[M - 1], q = T[M - 1 + 32], ee = T[M - 1 + 64], le = T[M - 1 + 96];
      $t(T, M + 0, 16843009 * Vn(T[M - 1 - 32], k, q)), $t(T, M + 32, 16843009 * Vn(k, q, ee)), $t(T, M + 64, 16843009 * Vn(q, ee, le)), $t(T, M + 96, 16843009 * Vn(ee, le, le));
    }
    function Zr(T, M) {
      var k, q = 4;
      for (k = 0; 4 > k; ++k) q += T[M + k - 32] + T[M - 1 + 32 * k];
      for (q >>= 3, k = 0; 4 > k; ++k) r(T, M + 32 * k, q, 4);
    }
    function Ll(T, M) {
      var k = T[M - 1 + 0], q = T[M - 1 + 32], ee = T[M - 1 + 64], le = T[M - 1 - 32], he = T[M + 0 - 32], ye = T[M + 1 - 32], xe = T[M + 2 - 32], Le = T[M + 3 - 32];
      T[M + 0 + 96] = Vn(q, ee, T[M - 1 + 96]), T[M + 1 + 96] = T[M + 0 + 64] = Vn(k, q, ee), T[M + 2 + 96] = T[M + 1 + 64] = T[M + 0 + 32] = Vn(le, k, q), T[M + 3 + 96] = T[M + 2 + 64] = T[M + 1 + 32] = T[M + 0 + 0] = Vn(he, le, k), T[M + 3 + 64] = T[M + 2 + 32] = T[M + 1 + 0] = Vn(ye, he, le), T[M + 3 + 32] = T[M + 2 + 0] = Vn(xe, ye, he), T[M + 3 + 0] = Vn(Le, xe, ye);
    }
    function Ui(T, M) {
      var k = T[M + 1 - 32], q = T[M + 2 - 32], ee = T[M + 3 - 32], le = T[M + 4 - 32], he = T[M + 5 - 32], ye = T[M + 6 - 32], xe = T[M + 7 - 32];
      T[M + 0 + 0] = Vn(T[M + 0 - 32], k, q), T[M + 1 + 0] = T[M + 0 + 32] = Vn(k, q, ee), T[M + 2 + 0] = T[M + 1 + 32] = T[M + 0 + 64] = Vn(q, ee, le), T[M + 3 + 0] = T[M + 2 + 32] = T[M + 1 + 64] = T[M + 0 + 96] = Vn(ee, le, he), T[M + 3 + 32] = T[M + 2 + 64] = T[M + 1 + 96] = Vn(le, he, ye), T[M + 3 + 64] = T[M + 2 + 96] = Vn(he, ye, xe), T[M + 3 + 96] = Vn(ye, xe, xe);
    }
    function Yo(T, M) {
      var k = T[M - 1 + 0], q = T[M - 1 + 32], ee = T[M - 1 + 64], le = T[M - 1 - 32], he = T[M + 0 - 32], ye = T[M + 1 - 32], xe = T[M + 2 - 32], Le = T[M + 3 - 32];
      T[M + 0 + 0] = T[M + 1 + 64] = le + he + 1 >> 1, T[M + 1 + 0] = T[M + 2 + 64] = he + ye + 1 >> 1, T[M + 2 + 0] = T[M + 3 + 64] = ye + xe + 1 >> 1, T[M + 3 + 0] = xe + Le + 1 >> 1, T[M + 0 + 96] = Vn(ee, q, k), T[M + 0 + 64] = Vn(q, k, le), T[M + 0 + 32] = T[M + 1 + 96] = Vn(k, le, he), T[M + 1 + 32] = T[M + 2 + 96] = Vn(le, he, ye), T[M + 2 + 32] = T[M + 3 + 96] = Vn(he, ye, xe), T[M + 3 + 32] = Vn(ye, xe, Le);
    }
    function li(T, M) {
      var k = T[M + 0 - 32], q = T[M + 1 - 32], ee = T[M + 2 - 32], le = T[M + 3 - 32], he = T[M + 4 - 32], ye = T[M + 5 - 32], xe = T[M + 6 - 32], Le = T[M + 7 - 32];
      T[M + 0 + 0] = k + q + 1 >> 1, T[M + 1 + 0] = T[M + 0 + 64] = q + ee + 1 >> 1, T[M + 2 + 0] = T[M + 1 + 64] = ee + le + 1 >> 1, T[M + 3 + 0] = T[M + 2 + 64] = le + he + 1 >> 1, T[M + 0 + 32] = Vn(k, q, ee), T[M + 1 + 32] = T[M + 0 + 96] = Vn(q, ee, le), T[M + 2 + 32] = T[M + 1 + 96] = Vn(ee, le, he), T[M + 3 + 32] = T[M + 2 + 96] = Vn(le, he, ye), T[M + 3 + 64] = Vn(he, ye, xe), T[M + 3 + 96] = Vn(ye, xe, Le);
    }
    function Kn(T, M) {
      var k = T[M - 1 + 0], q = T[M - 1 + 32], ee = T[M - 1 + 64], le = T[M - 1 + 96];
      T[M + 0 + 0] = k + q + 1 >> 1, T[M + 2 + 0] = T[M + 0 + 32] = q + ee + 1 >> 1, T[M + 2 + 32] = T[M + 0 + 64] = ee + le + 1 >> 1, T[M + 1 + 0] = Vn(k, q, ee), T[M + 3 + 0] = T[M + 1 + 32] = Vn(q, ee, le), T[M + 3 + 32] = T[M + 1 + 64] = Vn(ee, le, le), T[M + 3 + 64] = T[M + 2 + 64] = T[M + 0 + 96] = T[M + 1 + 96] = T[M + 2 + 96] = T[M + 3 + 96] = le;
    }
    function Rl(T, M) {
      var k = T[M - 1 + 0], q = T[M - 1 + 32], ee = T[M - 1 + 64], le = T[M - 1 + 96], he = T[M - 1 - 32], ye = T[M + 0 - 32], xe = T[M + 1 - 32], Le = T[M + 2 - 32];
      T[M + 0 + 0] = T[M + 2 + 32] = k + he + 1 >> 1, T[M + 0 + 32] = T[M + 2 + 64] = q + k + 1 >> 1, T[M + 0 + 64] = T[M + 2 + 96] = ee + q + 1 >> 1, T[M + 0 + 96] = le + ee + 1 >> 1, T[M + 3 + 0] = Vn(ye, xe, Le), T[M + 2 + 0] = Vn(he, ye, xe), T[M + 1 + 0] = T[M + 3 + 32] = Vn(k, he, ye), T[M + 1 + 32] = T[M + 3 + 64] = Vn(q, k, he), T[M + 1 + 64] = T[M + 3 + 96] = Vn(ee, q, k), T[M + 1 + 96] = Vn(le, ee, q);
    }
    function gi(T, M) {
      var k;
      for (k = 0; 8 > k; ++k) i(T, M + 32 * k, T, M - 32, 8);
    }
    function fa(T, M) {
      var k;
      for (k = 0; 8 > k; ++k) r(T, M, T[M - 1], 8), M += 32;
    }
    function ls(T, M, k) {
      var q;
      for (q = 0; 8 > q; ++q) r(M, k + 32 * q, T, 8);
    }
    function So(T, M) {
      var k, q = 8;
      for (k = 0; 8 > k; ++k) q += T[M + k - 32] + T[M - 1 + 32 * k];
      ls(q >> 4, T, M);
    }
    function Bl(T, M) {
      var k, q = 4;
      for (k = 0; 8 > k; ++k) q += T[M + k - 32];
      ls(q >> 3, T, M);
    }
    function Jo(T, M) {
      var k, q = 4;
      for (k = 0; 8 > k; ++k) q += T[M - 1 + 32 * k];
      ls(q >> 3, T, M);
    }
    function Ko(T, M) {
      ls(128, T, M);
    }
    function Ol(T, M, k) {
      var q = T[M - k], ee = T[M + 0], le = 3 * (ee - q) + pl[1020 + T[M - 2 * k] - T[M + k]], he = Xl[112 + (le + 4 >> 3)];
      T[M - k] = to[255 + q + Xl[112 + (le + 3 >> 3)]], T[M + 0] = to[255 + ee - he];
    }
    function Sc(T, M, k, q) {
      var ee = T[M + 0], le = T[M + k];
      return Ds[255 + T[M - 2 * k] - T[M - k]] > q || Ds[255 + le - ee] > q;
    }
    function Cc(T, M, k, q) {
      return 4 * Ds[255 + T[M - k] - T[M + 0]] + Ds[255 + T[M - 2 * k] - T[M + k]] <= q;
    }
    function su(T, M, k, q, ee) {
      var le = T[M - 3 * k], he = T[M - 2 * k], ye = T[M - k], xe = T[M + 0], Le = T[M + k], tt = T[M + 2 * k], ut = T[M + 3 * k];
      return 4 * Ds[255 + ye - xe] + Ds[255 + he - Le] > q ? 0 : Ds[255 + T[M - 4 * k] - le] <= ee && Ds[255 + le - he] <= ee && Ds[255 + he - ye] <= ee && Ds[255 + ut - tt] <= ee && Ds[255 + tt - Le] <= ee && Ds[255 + Le - xe] <= ee;
    }
    function ol(T, M, k, q) {
      var ee = 2 * q + 1;
      for (q = 0; 16 > q; ++q) Cc(T, M + q, k, ee) && Ol(T, M + q, k);
    }
    function yi(T, M, k, q) {
      var ee = 2 * q + 1;
      for (q = 0; 16 > q; ++q) Cc(T, M + q * k, 1, ee) && Ol(T, M + q * k, 1);
    }
    function Ks(T, M, k, q) {
      var ee;
      for (ee = 3; 0 < ee; --ee) ol(T, M += 4 * k, k, q);
    }
    function fo(T, M, k, q) {
      var ee;
      for (ee = 3; 0 < ee; --ee) yi(T, M += 4, k, q);
    }
    function Qs(T, M, k, q, ee, le, he, ye) {
      for (le = 2 * le + 1; 0 < ee--; ) {
        if (su(T, M, k, le, he)) if (Sc(T, M, k, ye)) Ol(T, M, k);
        else {
          var xe = T, Le = M, tt = k, ut = xe[Le - 2 * tt], At = xe[Le - tt], ct = xe[Le + 0], qt = xe[Le + tt], Ot = xe[Le + 2 * tt], nt = 27 * (jt = pl[1020 + 3 * (ct - At) + pl[1020 + ut - qt]]) + 63 >> 7, st = 18 * jt + 63 >> 7, jt = 9 * jt + 63 >> 7;
          xe[Le - 3 * tt] = to[255 + xe[Le - 3 * tt] + jt], xe[Le - 2 * tt] = to[255 + ut + st], xe[Le - tt] = to[255 + At + nt], xe[Le + 0] = to[255 + ct - nt], xe[Le + tt] = to[255 + qt - st], xe[Le + 2 * tt] = to[255 + Ot - jt];
        }
        M += q;
      }
    }
    function ji(T, M, k, q, ee, le, he, ye) {
      for (le = 2 * le + 1; 0 < ee--; ) {
        if (su(T, M, k, le, he)) if (Sc(T, M, k, ye)) Ol(T, M, k);
        else {
          var xe = T, Le = M, tt = k, ut = xe[Le - tt], At = xe[Le + 0], ct = xe[Le + tt], qt = Xl[112 + ((Ot = 3 * (At - ut)) + 4 >> 3)], Ot = Xl[112 + (Ot + 3 >> 3)], nt = qt + 1 >> 1;
          xe[Le - 2 * tt] = to[255 + xe[Le - 2 * tt] + nt], xe[Le - tt] = to[255 + ut + Ot], xe[Le + 0] = to[255 + At - qt], xe[Le + tt] = to[255 + ct - nt];
        }
        M += q;
      }
    }
    function Dl(T, M, k, q, ee, le) {
      Qs(T, M, k, 1, 16, q, ee, le);
    }
    function eo(T, M, k, q, ee, le) {
      Qs(T, M, 1, k, 16, q, ee, le);
    }
    function ku(T, M, k, q, ee, le) {
      var he;
      for (he = 3; 0 < he; --he) ji(T, M += 4 * k, k, 1, 16, q, ee, le);
    }
    function Pc(T, M, k, q, ee, le) {
      var he;
      for (he = 3; 0 < he; --he) ji(T, M += 4, 1, k, 16, q, ee, le);
    }
    function Ic(T, M, k, q, ee, le, he, ye) {
      Qs(T, M, ee, 1, 8, le, he, ye), Qs(k, q, ee, 1, 8, le, he, ye);
    }
    function Fl(T, M, k, q, ee, le, he, ye) {
      Qs(T, M, 1, ee, 8, le, he, ye), Qs(k, q, 1, ee, 8, le, he, ye);
    }
    function ou(T, M, k, q, ee, le, he, ye) {
      ji(T, M + 4 * ee, ee, 1, 8, le, he, ye), ji(k, q + 4 * ee, ee, 1, 8, le, he, ye);
    }
    function Nl(T, M, k, q, ee, le, he, ye) {
      ji(T, M + 4, 1, ee, 8, le, he, ye), ji(k, q + 4, 1, ee, 8, le, he, ye);
    }
    function Co() {
      this.ba = new it(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new Ye(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
    }
    function cs() {
      this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
    }
    function La() {
      this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
    }
    function Ra() {
      this.ua = 0, this.Wa = new Ue(), this.vb = new Ue(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new Me(), this.yc = new _e();
    }
    function au() {
      this.xb = this.a = 0, this.l = new Xo(), this.ca = new it(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new oe(), this.Pb = 0, this.wd = new oe(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new Ra(), this.ab = 0, this.gc = c(4, La), this.Oc = 0;
    }
    function us() {
      this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Xo(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
    }
    function kl(T, M, k, q, ee, le, he) {
      for (T = T == null ? 0 : T[M + 0], M = 0; M < he; ++M) ee[le + M] = T + k[q + M] & 255, T = ee[le + M];
    }
    function zl(T, M, k, q, ee, le, he) {
      var ye;
      if (T == null) kl(null, null, k, q, ee, le, he);
      else for (ye = 0; ye < he; ++ye) ee[le + ye] = T[M + ye] + k[q + ye] & 255;
    }
    function Po(T, M, k, q, ee, le, he) {
      if (T == null) kl(null, null, k, q, ee, le, he);
      else {
        var ye, xe = T[M + 0], Le = xe, tt = xe;
        for (ye = 0; ye < he; ++ye) Le = tt + (xe = T[M + ye]) - Le, tt = k[q + ye] + (-256 & Le ? 0 > Le ? 0 : 255 : Le) & 255, Le = xe, ee[le + ye] = tt;
      }
    }
    function Ba(T, M, k, q) {
      var ee = M.width, le = M.o;
      if (e(T != null && M != null), 0 > k || 0 >= q || k + q > le) return null;
      if (!T.Cc) {
        if (T.ga == null) {
          var he;
          if (T.ga = new us(), (he = T.ga == null) || (he = M.width * M.o, e(T.Gb.length == 0), T.Gb = l(he), T.Uc = 0, T.Gb == null ? he = 0 : (T.mb = T.Gb, T.nb = T.Uc, T.rc = null, he = 1), he = !he), !he) {
            he = T.ga;
            var ye = T.Fa, xe = T.P, Le = T.qc, tt = T.mb, ut = T.nb, At = xe + 1, ct = Le - 1, qt = he.l;
            if (e(ye != null && tt != null && M != null), ja[0] = null, ja[1] = kl, ja[2] = zl, ja[3] = Po, he.ca = tt, he.tb = ut, he.c = M.width, he.i = M.height, e(0 < he.c && 0 < he.i), 1 >= Le) M = 0;
            else if (he.$a = ye[xe + 0] >> 0 & 3, he.Z = ye[xe + 0] >> 2 & 3, he.Lc = ye[xe + 0] >> 4 & 3, xe = ye[xe + 0] >> 6 & 3, 0 > he.$a || 1 < he.$a || 4 <= he.Z || 1 < he.Lc || xe) M = 0;
            else if (qt.put = an, qt.ac = Ze, qt.bc = Yt, qt.ma = he, qt.width = M.width, qt.height = M.height, qt.Da = M.Da, qt.v = M.v, qt.va = M.va, qt.j = M.j, qt.o = M.o, he.$a) e: {
              e(he.$a == 1), M = ui();
              t: for (; ; ) {
                if (M == null) {
                  M = 0;
                  break e;
                }
                if (e(he != null), he.mc = M, M.c = he.c, M.i = he.i, M.l = he.l, M.l.ma = he, M.l.width = he.c, M.l.height = he.i, M.a = 0, gt(M.m, ye, At, ct), !Oi(he.c, he.i, 1, M, null) || (M.ab == 1 && M.gc[0].hc == 3 && fn(M.s) ? (he.ic = 1, ye = M.c * M.i, M.Ta = null, M.Ua = 0, M.V = l(ye), M.Ba = 0, M.V == null ? (M.a = 1, M = 0) : M = 1) : (he.ic = 0, M = _i(M, he.c)), !M)) break t;
                M = 1;
                break e;
              }
              he.mc = null, M = 0;
            }
            else M = ct >= he.c * he.i;
            he = !M;
          }
          if (he) return null;
          T.ga.Lc != 1 ? T.Ga = 0 : q = le - k;
        }
        e(T.ga != null), e(k + q <= le);
        e: {
          if (M = (ye = T.ga).c, le = ye.l.o, ye.$a == 0) {
            if (At = T.rc, ct = T.Vc, qt = T.Fa, xe = T.P + 1 + k * M, Le = T.mb, tt = T.nb + k * M, e(xe <= T.P + T.qc), ye.Z != 0) for (e(ja[ye.Z] != null), he = 0; he < q; ++he) ja[ye.Z](At, ct, qt, xe, Le, tt, M), At = Le, ct = tt, tt += M, xe += M;
            else for (he = 0; he < q; ++he) i(Le, tt, qt, xe, M), At = Le, ct = tt, tt += M, xe += M;
            T.rc = At, T.Vc = ct;
          } else {
            if (e(ye.mc != null), M = k + q, e((he = ye.mc) != null), e(M <= he.i), he.C >= M) M = 1;
            else if (ye.ic || yt(), ye.ic) {
              ye = he.V, At = he.Ba, ct = he.c;
              var Ot = he.i, nt = (qt = 1, xe = he.$ / ct, Le = he.$ % ct, tt = he.m, ut = he.s, he.$), st = ct * Ot, jt = ct * M, Zt = ut.wc, ft = nt < jt ? In(ut, Le, xe) : null;
              e(nt <= st), e(M <= Ot), e(fn(ut));
              t: for (; ; ) {
                for (; !tt.h && nt < jt; ) {
                  if (Le & Zt || (ft = In(ut, Le, xe)), e(ft != null), ot(tt), 256 > (Ot = Jt(ft.G[0], ft.H[0], tt))) ye[At + nt] = Ot, ++nt, ++Le >= ct && (Le = 0, ++xe <= M && !(xe % 16) && Er(he, xe));
                  else {
                    if (!(280 > Ot)) {
                      qt = 0;
                      break t;
                    }
                    Ot = An(Ot - 256, tt);
                    var Ut, yn = Jt(ft.G[4], ft.H[4], tt);
                    if (ot(tt), !(nt >= (yn = It(ct, yn = An(yn, tt))) && st - nt >= Ot)) {
                      qt = 0;
                      break t;
                    }
                    for (Ut = 0; Ut < Ot; ++Ut) ye[At + nt + Ut] = ye[At + nt + Ut - yn];
                    for (nt += Ot, Le += Ot; Le >= ct; ) Le -= ct, ++xe <= M && !(xe % 16) && Er(he, xe);
                    nt < jt && Le & Zt && (ft = In(ut, Le, xe));
                  }
                  e(tt.h == ze(tt));
                }
                Er(he, xe > M ? M : xe);
                break t;
              }
              !qt || tt.h && nt < st ? (qt = 0, he.a = tt.h ? 5 : 3) : he.$ = nt, M = qt;
            } else M = Pi(he, he.V, he.Ba, he.c, he.i, M, xs);
            if (!M) {
              q = 0;
              break e;
            }
          }
          k + q >= le && (T.Cc = 1), q = 1;
        }
        if (!q) return null;
        if (T.Cc && ((q = T.ga) != null && (q.mc = null), T.ga = null, 0 < T.Ga)) return alert("todo:WebPDequantizeLevels"), null;
      }
      return T.nb + k * ee;
    }
    function O(T, M, k, q, ee, le) {
      for (; 0 < ee--; ) {
        var he, ye = T, xe = M + (k ? 1 : 0), Le = T, tt = M + (k ? 0 : 3);
        for (he = 0; he < q; ++he) {
          var ut = Le[tt + 4 * he];
          ut != 255 && (ut *= 32897, ye[xe + 4 * he + 0] = ye[xe + 4 * he + 0] * ut >> 23, ye[xe + 4 * he + 1] = ye[xe + 4 * he + 1] * ut >> 23, ye[xe + 4 * he + 2] = ye[xe + 4 * he + 2] * ut >> 23);
        }
        M += le;
      }
    }
    function te(T, M, k, q, ee) {
      for (; 0 < q--; ) {
        var le;
        for (le = 0; le < k; ++le) {
          var he = T[M + 2 * le + 0], ye = 15 & (Le = T[M + 2 * le + 1]), xe = 4369 * ye, Le = (240 & Le | Le >> 4) * xe >> 16;
          T[M + 2 * le + 0] = (240 & he | he >> 4) * xe >> 16 & 240 | (15 & he | he << 4) * xe >> 16 >> 4 & 15, T[M + 2 * le + 1] = 240 & Le | ye;
        }
        M += ee;
      }
    }
    function Fe(T, M, k, q, ee, le, he, ye) {
      var xe, Le, tt = 255;
      for (Le = 0; Le < ee; ++Le) {
        for (xe = 0; xe < q; ++xe) {
          var ut = T[M + xe];
          le[he + 4 * xe] = ut, tt &= ut;
        }
        M += k, he += ye;
      }
      return tt != 255;
    }
    function Ke(T, M, k, q, ee) {
      var le;
      for (le = 0; le < ee; ++le) k[q + le] = T[M + le] >> 8;
    }
    function yt() {
      mo = O, Di = te, Zi = Fe, Cr = Ke;
    }
    function kt(T, M, k) {
      me[T] = function(q, ee, le, he, ye, xe, Le, tt, ut, At, ct, qt, Ot, nt, st, jt, Zt) {
        var ft, Ut = Zt - 1 >> 1, yn = ye[xe + 0] | Le[tt + 0] << 16, jn = ut[At + 0] | ct[qt + 0] << 16;
        e(q != null);
        var xn = 3 * yn + jn + 131074 >> 2;
        for (M(q[ee + 0], 255 & xn, xn >> 16, Ot, nt), le != null && (xn = 3 * jn + yn + 131074 >> 2, M(le[he + 0], 255 & xn, xn >> 16, st, jt)), ft = 1; ft <= Ut; ++ft) {
          var ri = ye[xe + ft] | Le[tt + ft] << 16, Fi = ut[At + ft] | ct[qt + ft] << 16, ai = yn + ri + jn + Fi + 524296, Ai = ai + 2 * (ri + jn) >> 3;
          xn = Ai + yn >> 1, yn = (ai = ai + 2 * (yn + Fi) >> 3) + ri >> 1, M(q[ee + 2 * ft - 1], 255 & xn, xn >> 16, Ot, nt + (2 * ft - 1) * k), M(q[ee + 2 * ft - 0], 255 & yn, yn >> 16, Ot, nt + (2 * ft - 0) * k), le != null && (xn = ai + jn >> 1, yn = Ai + Fi >> 1, M(le[he + 2 * ft - 1], 255 & xn, xn >> 16, st, jt + (2 * ft - 1) * k), M(le[he + 2 * ft + 0], 255 & yn, yn >> 16, st, jt + (2 * ft + 0) * k)), yn = ri, jn = Fi;
        }
        1 & Zt || (xn = 3 * yn + jn + 131074 >> 2, M(q[ee + Zt - 1], 255 & xn, xn >> 16, Ot, nt + (Zt - 1) * k), le != null && (xn = 3 * jn + yn + 131074 >> 2, M(le[he + Zt - 1], 255 & xn, xn >> 16, st, jt + (Zt - 1) * k)));
      };
    }
    function tn() {
      _o[Yl] = qu, _o[Bc] = Es, _o[ad] = Fc, _o[Jl] = pr, _o[cu] = ec, _o[ju] = Bo, _o[uu] = Nc, _o[Oc] = Es, _o[hu] = pr, _o[Dc] = ec, _o[Kl] = Bo;
    }
    function Tn(T) {
      return T & -16384 ? 0 > T ? 0 : 255 : T >> ud;
    }
    function kn(T, M) {
      return Tn((19077 * T >> 8) + (26149 * M >> 8) - 14234);
    }
    function ii(T, M, k) {
      return Tn((19077 * T >> 8) - (6419 * M >> 8) - (13320 * k >> 8) + 8708);
    }
    function ei(T, M) {
      return Tn((19077 * T >> 8) + (33050 * M >> 8) - 17685);
    }
    function wi(T, M, k, q, ee) {
      q[ee + 0] = kn(T, k), q[ee + 1] = ii(T, M, k), q[ee + 2] = ei(T, M);
    }
    function ir(T, M, k, q, ee) {
      q[ee + 0] = ei(T, M), q[ee + 1] = ii(T, M, k), q[ee + 2] = kn(T, k);
    }
    function Wi(T, M, k, q, ee) {
      var le = ii(T, M, k);
      M = le << 3 & 224 | ei(T, M) >> 3, q[ee + 0] = 248 & kn(T, k) | le >> 5, q[ee + 1] = M;
    }
    function Sr(T, M, k, q, ee) {
      var le = 240 & ei(T, M) | 15;
      q[ee + 0] = 240 & kn(T, k) | ii(T, M, k) >> 4, q[ee + 1] = le;
    }
    function hs(T, M, k, q, ee) {
      q[ee + 0] = 255, wi(T, M, k, q, ee + 1);
    }
    function br(T, M, k, q, ee) {
      ir(T, M, k, q, ee), q[ee + 3] = 255;
    }
    function po(T, M, k, q, ee) {
      wi(T, M, k, q, ee), q[ee + 3] = 255;
    }
    function Bs(T, M) {
      return 0 > T ? 0 : T > M ? M : T;
    }
    function pa(T, M, k) {
      me[T] = function(q, ee, le, he, ye, xe, Le, tt, ut) {
        for (var At = tt + (-2 & ut) * k; tt != At; ) M(q[ee + 0], le[he + 0], ye[xe + 0], Le, tt), M(q[ee + 1], le[he + 0], ye[xe + 0], Le, tt + k), ee += 2, ++he, ++xe, tt += 2 * k;
        1 & ut && M(q[ee + 0], le[he + 0], ye[xe + 0], Le, tt);
      };
    }
    function zu(T, M, k) {
      return k == 0 ? T == 0 ? M == 0 ? 6 : 5 : M == 0 ? 4 : 0 : k;
    }
    function Ul(T, M, k, q, ee) {
      switch (T >>> 30) {
        case 3:
          Fr(M, k, q, ee, 0);
          break;
        case 2:
          vr(M, k, q, ee);
          break;
        case 1:
          fs(M, k, q, ee);
      }
    }
    function jl(T, M) {
      var k, q, ee = M.M, le = M.Nb, he = T.oc, ye = T.pc + 40, xe = T.oc, Le = T.pc + 584, tt = T.oc, ut = T.pc + 600;
      for (k = 0; 16 > k; ++k) he[ye + 32 * k - 1] = 129;
      for (k = 0; 8 > k; ++k) xe[Le + 32 * k - 1] = 129, tt[ut + 32 * k - 1] = 129;
      for (0 < ee ? he[ye - 1 - 32] = xe[Le - 1 - 32] = tt[ut - 1 - 32] = 129 : (r(he, ye - 32 - 1, 127, 21), r(xe, Le - 32 - 1, 127, 9), r(tt, ut - 32 - 1, 127, 9)), q = 0; q < T.za; ++q) {
        var At = M.ya[M.aa + q];
        if (0 < q) {
          for (k = -1; 16 > k; ++k) i(he, ye + 32 * k - 4, he, ye + 32 * k + 12, 4);
          for (k = -1; 8 > k; ++k) i(xe, Le + 32 * k - 4, xe, Le + 32 * k + 4, 4), i(tt, ut + 32 * k - 4, tt, ut + 32 * k + 4, 4);
        }
        var ct = T.Gd, qt = T.Hd + q, Ot = At.ad, nt = At.Hc;
        if (0 < ee && (i(he, ye - 32, ct[qt].y, 0, 16), i(xe, Le - 32, ct[qt].f, 0, 8), i(tt, ut - 32, ct[qt].ea, 0, 8)), At.Za) {
          var st = he, jt = ye - 32 + 16;
          for (0 < ee && (q >= T.za - 1 ? r(st, jt, ct[qt].y[15], 4) : i(st, jt, ct[qt + 1].y, 0, 4)), k = 0; 4 > k; k++) st[jt + 128 + k] = st[jt + 256 + k] = st[jt + 384 + k] = st[jt + 0 + k];
          for (k = 0; 16 > k; ++k, nt <<= 2) st = he, jt = ye + Va[k], Ts[At.Ob[k]](st, jt), Ul(nt, Ot, 16 * +k, st, jt);
        } else if (st = zu(q, ee, At.Ob[0]), ya[st](he, ye), nt != 0) for (k = 0; 16 > k; ++k, nt <<= 2) Ul(nt, Ot, 16 * +k, he, ye + Va[k]);
        for (k = At.Gc, st = zu(q, ee, At.Dd), ba[st](xe, Le), ba[st](tt, ut), nt = Ot, st = xe, jt = Le, 255 & (At = k >> 0) && (170 & At ? Rc(nt, 256, st, jt) : Xr(nt, 256, st, jt)), At = tt, nt = ut, 255 & (k >>= 8) && (170 & k ? Rc(Ot, 320, At, nt) : Xr(Ot, 320, At, nt)), ee < T.Ub - 1 && (i(ct[qt].y, 0, he, ye + 480, 16), i(ct[qt].f, 0, xe, Le + 224, 8), i(ct[qt].ea, 0, tt, ut + 224, 8)), k = 8 * le * T.B, ct = T.sa, qt = T.ta + 16 * q + 16 * le * T.R, Ot = T.qa, At = T.ra + 8 * q + k, nt = T.Ha, st = T.Ia + 8 * q + k, k = 0; 16 > k; ++k) i(ct, qt + k * T.R, he, ye + 32 * k, 16);
        for (k = 0; 8 > k; ++k) i(Ot, At + k * T.B, xe, Le + 32 * k, 8), i(nt, st + k * T.B, tt, ut + 32 * k, 8);
      }
    }
    function Gl(T, M, k, q, ee, le, he, ye, xe) {
      var Le = [0], tt = [0], ut = 0, At = xe != null ? xe.kd : 0, ct = xe ?? new cs();
      if (T == null || 12 > k) return 7;
      ct.data = T, ct.w = M, ct.ha = k, M = [M], k = [k], ct.gb = [ct.gb];
      e: {
        var qt = M, Ot = k, nt = ct.gb;
        if (e(T != null), e(Ot != null), e(nt != null), nt[0] = 0, 12 <= Ot[0] && !t(T, qt[0], "RIFF")) {
          if (t(T, qt[0] + 8, "WEBP")) {
            nt = 3;
            break e;
          }
          var st = hn(T, qt[0] + 4);
          if (12 > st || 4294967286 < st) {
            nt = 3;
            break e;
          }
          if (At && st > Ot[0] - 8) {
            nt = 7;
            break e;
          }
          nt[0] = st, qt[0] += 12, Ot[0] -= 12;
        }
        nt = 0;
      }
      if (nt != 0) return nt;
      for (st = 0 < ct.gb[0], k = k[0]; ; ) {
        e: {
          var jt = T;
          Ot = M, nt = k;
          var Zt = Le, ft = tt, Ut = qt = [0];
          if ((xn = ut = [ut])[0] = 0, 8 > nt[0]) nt = 7;
          else {
            if (!t(jt, Ot[0], "VP8X")) {
              if (hn(jt, Ot[0] + 4) != 10) {
                nt = 3;
                break e;
              }
              if (18 > nt[0]) {
                nt = 7;
                break e;
              }
              var yn = hn(jt, Ot[0] + 8), jn = 1 + on(jt, Ot[0] + 12);
              if (2147483648 <= jn * (jt = 1 + on(jt, Ot[0] + 15))) {
                nt = 3;
                break e;
              }
              Ut != null && (Ut[0] = yn), Zt != null && (Zt[0] = jn), ft != null && (ft[0] = jt), Ot[0] += 18, nt[0] -= 18, xn[0] = 1;
            }
            nt = 0;
          }
        }
        if (ut = ut[0], qt = qt[0], nt != 0) return nt;
        if (Ot = !!(2 & qt), !st && ut) return 3;
        if (le != null && (le[0] = !!(16 & qt)), he != null && (he[0] = Ot), ye != null && (ye[0] = 0), he = Le[0], qt = tt[0], ut && Ot && xe == null) {
          nt = 0;
          break;
        }
        if (4 > k) {
          nt = 7;
          break;
        }
        if (st && ut || !st && !ut && !t(T, M[0], "ALPH")) {
          k = [k], ct.na = [ct.na], ct.P = [ct.P], ct.Sa = [ct.Sa];
          e: {
            yn = T, nt = M, st = k;
            var xn = ct.gb;
            Zt = ct.na, ft = ct.P, Ut = ct.Sa, jn = 22, e(yn != null), e(st != null), jt = nt[0];
            var ri = st[0];
            for (e(Zt != null), e(Ut != null), Zt[0] = null, ft[0] = null, Ut[0] = 0; ; ) {
              if (nt[0] = jt, st[0] = ri, 8 > ri) {
                nt = 7;
                break e;
              }
              var Fi = hn(yn, jt + 4);
              if (4294967286 < Fi) {
                nt = 3;
                break e;
              }
              var ai = 8 + Fi + 1 & -2;
              if (jn += ai, 0 < xn && jn > xn) {
                nt = 3;
                break e;
              }
              if (!t(yn, jt, "VP8 ") || !t(yn, jt, "VP8L")) {
                nt = 0;
                break e;
              }
              if (ri[0] < ai) {
                nt = 7;
                break e;
              }
              t(yn, jt, "ALPH") || (Zt[0] = yn, ft[0] = jt + 8, Ut[0] = Fi), jt += ai, ri -= ai;
            }
          }
          if (k = k[0], ct.na = ct.na[0], ct.P = ct.P[0], ct.Sa = ct.Sa[0], nt != 0) break;
        }
        k = [k], ct.Ja = [ct.Ja], ct.xa = [ct.xa];
        e: if (xn = T, nt = M, st = k, Zt = ct.gb[0], ft = ct.Ja, Ut = ct.xa, yn = nt[0], jt = !t(xn, yn, "VP8 "), jn = !t(xn, yn, "VP8L"), e(xn != null), e(st != null), e(ft != null), e(Ut != null), 8 > st[0]) nt = 7;
        else {
          if (jt || jn) {
            if (xn = hn(xn, yn + 4), 12 <= Zt && xn > Zt - 12) {
              nt = 3;
              break e;
            }
            if (At && xn > st[0] - 8) {
              nt = 7;
              break e;
            }
            ft[0] = xn, nt[0] += 8, st[0] -= 8, Ut[0] = jn;
          } else Ut[0] = 5 <= st[0] && xn[yn + 0] == 47 && !(xn[yn + 4] >> 5), ft[0] = st[0];
          nt = 0;
        }
        if (k = k[0], ct.Ja = ct.Ja[0], ct.xa = ct.xa[0], M = M[0], nt != 0) break;
        if (4294967286 < ct.Ja) return 3;
        if (ye == null || Ot || (ye[0] = ct.xa ? 2 : 1), he = [he], qt = [qt], ct.xa) {
          if (5 > k) {
            nt = 7;
            break;
          }
          ye = he, At = qt, Ot = le, T == null || 5 > k ? T = 0 : 5 <= k && T[M + 0] == 47 && !(T[M + 4] >> 5) ? (st = [0], xn = [0], Zt = [0], gt(ft = new oe(), T, M, k), Xt(ft, st, xn, Zt) ? (ye != null && (ye[0] = st[0]), At != null && (At[0] = xn[0]), Ot != null && (Ot[0] = Zt[0]), T = 1) : T = 0) : T = 0;
        } else {
          if (10 > k) {
            nt = 7;
            break;
          }
          ye = qt, T == null || 10 > k || !ha(T, M + 3, k - 3) ? T = 0 : (At = T[M + 0] | T[M + 1] << 8 | T[M + 2] << 16, Ot = 16383 & (T[M + 7] << 8 | T[M + 6]), T = 16383 & (T[M + 9] << 8 | T[M + 8]), 1 & At || 3 < (At >> 1 & 7) || !(At >> 4 & 1) || At >> 5 >= ct.Ja || !Ot || !T ? T = 0 : (he && (he[0] = Ot), ye && (ye[0] = T), T = 1));
        }
        if (!T || (he = he[0], qt = qt[0], ut && (Le[0] != he || tt[0] != qt))) return 3;
        xe != null && (xe[0] = ct, xe.offset = M - xe.w, e(4294967286 > M - xe.w), e(xe.offset == xe.ha - k));
        break;
      }
      return nt == 0 || nt == 7 && ut && xe == null ? (le != null && (le[0] |= ct.na != null && 0 < ct.na.length), q != null && (q[0] = he), ee != null && (ee[0] = qt), 0) : nt;
    }
    function Vl(T, M, k) {
      var q = M.width, ee = M.height, le = 0, he = 0, ye = q, xe = ee;
      if (M.Da = T != null && 0 < T.Da, M.Da && (ye = T.cd, xe = T.bd, le = T.v, he = T.j, 11 > k || (le &= -2, he &= -2), 0 > le || 0 > he || 0 >= ye || 0 >= xe || le + ye > q || he + xe > ee)) return 0;
      if (M.v = le, M.j = he, M.va = le + ye, M.o = he + xe, M.U = ye, M.T = xe, M.da = T != null && 0 < T.da, M.da) {
        if (!On(ye, xe, k = [T.ib], le = [T.hb])) return 0;
        M.ib = k[0], M.hb = le[0];
      }
      return M.ob = T != null && T.ob, M.Kb = T == null || !T.Sd, M.da && (M.ob = M.ib < 3 * q / 4 && M.hb < 3 * ee / 4, M.Kb = 0), 1;
    }
    function ql(T) {
      if (T == null) return 2;
      if (11 > T.S) {
        var M = T.f.RGBA;
        M.fb += (T.height - 1) * M.A, M.A = -M.A;
      } else M = T.f.kb, T = T.height, M.O += (T - 1) * M.fa, M.fa = -M.fa, M.N += (T - 1 >> 1) * M.Ab, M.Ab = -M.Ab, M.W += (T - 1 >> 1) * M.Db, M.Db = -M.Db, M.F != null && (M.J += (T - 1) * M.lb, M.lb = -M.lb);
      return 0;
    }
    function ga(T, M, k, q) {
      if (q == null || 0 >= T || 0 >= M) return 2;
      if (k != null) {
        if (k.Da) {
          var ee = k.cd, le = k.bd, he = -2 & k.v, ye = -2 & k.j;
          if (0 > he || 0 > ye || 0 >= ee || 0 >= le || he + ee > T || ye + le > M) return 2;
          T = ee, M = le;
        }
        if (k.da) {
          if (!On(T, M, ee = [k.ib], le = [k.hb])) return 2;
          T = ee[0], M = le[0];
        }
      }
      q.width = T, q.height = M;
      e: {
        var xe = q.width, Le = q.height;
        if (T = q.S, 0 >= xe || 0 >= Le || !(T >= Yl && 13 > T)) T = 2;
        else {
          if (0 >= q.Rd && q.sd == null) {
            he = le = ee = M = 0;
            var tt = (ye = xe * Sh[T]) * Le;
            if (11 > T || (le = (Le + 1) / 2 * (M = (xe + 1) / 2), T == 12 && (he = (ee = xe) * Le)), (Le = l(tt + 2 * le + he)) == null) {
              T = 1;
              break e;
            }
            q.sd = Le, 11 > T ? ((xe = q.f.RGBA).eb = Le, xe.fb = 0, xe.A = ye, xe.size = tt) : ((xe = q.f.kb).y = Le, xe.O = 0, xe.fa = ye, xe.Fd = tt, xe.f = Le, xe.N = 0 + tt, xe.Ab = M, xe.Cd = le, xe.ea = Le, xe.W = 0 + tt + le, xe.Db = M, xe.Ed = le, T == 12 && (xe.F = Le, xe.J = 0 + tt + 2 * le), xe.Tc = he, xe.lb = ee);
          }
          if (M = 1, ee = q.S, le = q.width, he = q.height, ee >= Yl && 13 > ee)
            if (11 > ee) T = q.f.RGBA, M &= (ye = Math.abs(T.A)) * (he - 1) + le <= T.size, M &= ye >= le * Sh[ee], M &= T.eb != null;
            else {
              T = q.f.kb, ye = (le + 1) / 2, tt = (he + 1) / 2, xe = Math.abs(T.fa), Le = Math.abs(T.Ab);
              var ut = Math.abs(T.Db), At = Math.abs(T.lb), ct = At * (he - 1) + le;
              M &= xe * (he - 1) + le <= T.Fd, M &= Le * (tt - 1) + ye <= T.Cd, M = (M &= ut * (tt - 1) + ye <= T.Ed) & xe >= le & Le >= ye & ut >= ye, M &= T.y != null, M &= T.f != null, M &= T.ea != null, ee == 12 && (M &= At >= le, M &= ct <= T.Tc, M &= T.F != null);
            }
          else M = 0;
          T = M ? 0 : 2;
        }
      }
      return T != 0 || k != null && k.fd && (T = ql(q)), T;
    }
    var rr = 64, al = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], ll = 24, Oa = 32, Mc = 8, As = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
    ln("Predictor0", "PredictorAdd0"), me.Predictor0 = function() {
      return 4278190080;
    }, me.Predictor1 = function(T) {
      return T;
    }, me.Predictor2 = function(T, M, k) {
      return M[k + 0];
    }, me.Predictor3 = function(T, M, k) {
      return M[k + 1];
    }, me.Predictor4 = function(T, M, k) {
      return M[k - 1];
    }, me.Predictor5 = function(T, M, k) {
      return _n(_n(T, M[k + 1]), M[k + 0]);
    }, me.Predictor6 = function(T, M, k) {
      return _n(T, M[k - 1]);
    }, me.Predictor7 = function(T, M, k) {
      return _n(T, M[k + 0]);
    }, me.Predictor8 = function(T, M, k) {
      return _n(M[k - 1], M[k + 0]);
    }, me.Predictor9 = function(T, M, k) {
      return _n(M[k + 0], M[k + 1]);
    }, me.Predictor10 = function(T, M, k) {
      return _n(_n(T, M[k - 1]), _n(M[k + 0], M[k + 1]));
    }, me.Predictor11 = function(T, M, k) {
      var q = M[k + 0];
      return 0 >= $n(q >> 24 & 255, T >> 24 & 255, (M = M[k - 1]) >> 24 & 255) + $n(q >> 16 & 255, T >> 16 & 255, M >> 16 & 255) + $n(q >> 8 & 255, T >> 8 & 255, M >> 8 & 255) + $n(255 & q, 255 & T, 255 & M) ? q : T;
    }, me.Predictor12 = function(T, M, k) {
      var q = M[k + 0];
      return (Mn((T >> 24 & 255) + (q >> 24 & 255) - ((M = M[k - 1]) >> 24 & 255)) << 24 | Mn((T >> 16 & 255) + (q >> 16 & 255) - (M >> 16 & 255)) << 16 | Mn((T >> 8 & 255) + (q >> 8 & 255) - (M >> 8 & 255)) << 8 | Mn((255 & T) + (255 & q) - (255 & M))) >>> 0;
    }, me.Predictor13 = function(T, M, k) {
      var q = M[k - 1];
      return (Wn((T = _n(T, M[k + 0])) >> 24 & 255, q >> 24 & 255) << 24 | Wn(T >> 16 & 255, q >> 16 & 255) << 16 | Wn(T >> 8 & 255, q >> 8 & 255) << 8 | Wn(T >> 0 & 255, q >> 0 & 255)) >>> 0;
    };
    var Da = me.PredictorAdd0;
    me.PredictorAdd1 = Yn, ln("Predictor2", "PredictorAdd2"), ln("Predictor3", "PredictorAdd3"), ln("Predictor4", "PredictorAdd4"), ln("Predictor5", "PredictorAdd5"), ln("Predictor6", "PredictorAdd6"), ln("Predictor7", "PredictorAdd7"), ln("Predictor8", "PredictorAdd8"), ln("Predictor9", "PredictorAdd9"), ln("Predictor10", "PredictorAdd10"), ln("Predictor11", "PredictorAdd11"), ln("Predictor12", "PredictorAdd12"), ln("Predictor13", "PredictorAdd13");
    var Hl = me.PredictorAdd2;
    Jn("ColorIndexInverseTransform", "MapARGB", "32b", function(T) {
      return T >> 8 & 255;
    }, function(T) {
      return T;
    }), Jn("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(T) {
      return T;
    }, function(T) {
      return T >> 8 & 255;
    });
    var Ei, Io = me.ColorIndexInverseTransform, Lc = me.MapARGB, Uu = me.VP8LColorIndexInverseTransformAlpha, lu = me.MapAlpha, cl = me.VP8LPredictorsAdd = [];
    cl.length = 16, (me.VP8LPredictors = []).length = 16, (me.VP8LPredictorsAdd_C = []).length = 16, (me.VP8LPredictors_C = []).length = 16;
    var ul, ds, $r, Qo, ea, Os, ta, Fr, vr, Rc, fs, Xr, Fa, Wl, Na, ma, hl, go, Mo, Zl, ka, oi, dl, Lo, mo, Di, Zi, Cr, Nr = l(511), za = l(2041), fl = l(225), Ua = l(767), $l = 0, pl = za, Xl = fl, to = Ua, Ds = Nr, Yl = 0, Bc = 1, ad = 2, Jl = 3, cu = 4, ju = 5, uu = 6, Oc = 7, hu = 8, Dc = 9, Kl = 10, du = [2, 3, 7], bh = [3, 3, 11], fu = [280, 256, 256, 256, 40], sr = [0, 1, 1, 1, 0], Ql = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Ro = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], vh = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], xh = 8, Gu = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], gl = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], _a = null, Vu = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], pu = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], wh = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], Ah = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], Th = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ld = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], ml = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], ya = [], Ts = [], ba = [], cd = 1, Eh = 2, ja = [], _o = [];
    kt("UpsampleRgbLinePair", wi, 3), kt("UpsampleBgrLinePair", ir, 3), kt("UpsampleRgbaLinePair", po, 4), kt("UpsampleBgraLinePair", br, 4), kt("UpsampleArgbLinePair", hs, 4), kt("UpsampleRgba4444LinePair", Sr, 2), kt("UpsampleRgb565LinePair", Wi, 2);
    var qu = me.UpsampleRgbLinePair, Fc = me.UpsampleBgrLinePair, Es = me.UpsampleRgbaLinePair, pr = me.UpsampleBgraLinePair, ec = me.UpsampleArgbLinePair, Bo = me.UpsampleRgba4444LinePair, Nc = me.UpsampleRgb565LinePair, Hu = 16, _l = 1 << Hu - 1, kc = -227, gu = 482, ud = 6, yl = 0, Ga = l(256), vn = l(256), hd = l(256), tc = l(256), dd = l(gu - kc), mu = l(gu - kc);
    pa("YuvToRgbRow", wi, 3), pa("YuvToBgrRow", ir, 3), pa("YuvToRgbaRow", po, 4), pa("YuvToBgraRow", br, 4), pa("YuvToArgbRow", hs, 4), pa("YuvToRgba4444Row", Sr, 2), pa("YuvToRgb565Row", Wi, 2);
    var Va = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], _u = [0, 2, 8], ci = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], zc = 1;
    this.WebPDecodeRGBA = function(T, M, k, q, ee) {
      var le = Bc, he = new Co(), ye = new it();
      he.ba = ye, ye.S = le, ye.width = [ye.width], ye.height = [ye.height];
      var xe = ye.width, Le = ye.height, tt = new mt();
      if (tt == null || T == null) var ut = 2;
      else e(tt != null), ut = Gl(T, M, k, tt.width, tt.height, tt.Pd, tt.Qd, tt.format, null);
      if (ut != 0 ? xe = 0 : (xe != null && (xe[0] = tt.width[0]), Le != null && (Le[0] = tt.height[0]), xe = 1), xe) {
        ye.width = ye.width[0], ye.height = ye.height[0], q != null && (q[0] = ye.width), ee != null && (ee[0] = ye.height);
        e: {
          if (q = new Xo(), (ee = new cs()).data = T, ee.w = M, ee.ha = k, ee.kd = 1, M = [0], e(ee != null), ((T = Gl(ee.data, ee.w, ee.ha, null, null, null, M, null, ee)) == 0 || T == 7) && M[0] && (T = 4), (M = T) == 0) {
            if (e(he != null), q.data = ee.data, q.w = ee.w + ee.offset, q.ha = ee.ha - ee.offset, q.put = an, q.ac = Ze, q.bc = Yt, q.ma = he, ee.xa) {
              if ((T = ui()) == null) {
                he = 1;
                break e;
              }
              if (function(At, ct) {
                var qt = [0], Ot = [0], nt = [0];
                t: for (; ; ) {
                  if (At == null) return 0;
                  if (ct == null) return At.a = 2, 0;
                  if (At.l = ct, At.a = 0, gt(At.m, ct.data, ct.w, ct.ha), !Xt(At.m, qt, Ot, nt)) {
                    At.a = 3;
                    break t;
                  }
                  if (At.xb = Eh, ct.width = qt[0], ct.height = Ot[0], !Oi(qt[0], Ot[0], 1, At, null)) break t;
                  return 1;
                }
                return e(At.a != 0), 0;
              }(T, q)) {
                if (q = (M = ga(q.width, q.height, he.Oa, he.ba)) == 0) {
                  t: {
                    q = T;
                    n: for (; ; ) {
                      if (q == null) {
                        q = 0;
                        break t;
                      }
                      if (e(q.s.yc != null), e(q.s.Ya != null), e(0 < q.s.Wb), e((k = q.l) != null), e((ee = k.ma) != null), q.xb != 0) {
                        if (q.ca = ee.ba, q.tb = ee.tb, e(q.ca != null), !Vl(ee.Oa, k, Jl)) {
                          q.a = 2;
                          break n;
                        }
                        if (!_i(q, k.width) || k.da) break n;
                        if ((k.da || ue(q.ca.S)) && yt(), 11 > q.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), q.ca.f.kb.F != null && yt()), q.Pb && 0 < q.s.ua && q.s.vb.X == null && !wn(q.s.vb, q.s.Wa.Xa)) {
                          q.a = 1;
                          break n;
                        }
                        q.xb = 0;
                      }
                      if (!Pi(q, q.V, q.Ba, q.c, q.i, k.o, Ln)) break n;
                      ee.Dc = q.Ma, q = 1;
                      break t;
                    }
                    e(q.a != 0), q = 0;
                  }
                  q = !q;
                }
                q && (M = T.a);
              } else M = T.a;
            } else {
              if ((T = new Xs()) == null) {
                he = 1;
                break e;
              }
              if (T.Fa = ee.na, T.P = ee.P, T.qc = ee.Sa, Ys(T, q)) {
                if ((M = ga(q.width, q.height, he.Oa, he.ba)) == 0) {
                  if (T.Aa = 0, k = he.Oa, e((ee = T) != null), k != null) {
                    if (0 < (xe = 0 > (xe = k.Md) ? 0 : 100 < xe ? 255 : 255 * xe / 100)) {
                      for (Le = tt = 0; 4 > Le; ++Le) 12 > (ut = ee.pb[Le]).lc && (ut.ia = xe * ci[0 > ut.lc ? 0 : ut.lc] >> 3), tt |= ut.ia;
                      tt && (alert("todo:VP8InitRandom"), ee.ia = 1);
                    }
                    ee.Ga = k.Id, 100 < ee.Ga ? ee.Ga = 100 : 0 > ee.Ga && (ee.Ga = 0);
                  }
                  sl(T, q) || (M = T.a);
                }
              } else M = T.a;
            }
            M == 0 && he.Oa != null && he.Oa.fd && (M = ql(he.ba));
          }
          he = M;
        }
        le = he != 0 ? null : 11 > le ? ye.f.RGBA.eb : ye.f.kb.y;
      } else le = null;
      return le;
    };
    var Sh = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
  };
  function y(me, Ge) {
    for (var ke = "", pe = 0; pe < 4; pe++) ke += String.fromCharCode(me[Ge++]);
    return ke;
  }
  function A(me, Ge) {
    return (me[Ge + 0] << 0 | me[Ge + 1] << 8 | me[Ge + 2] << 16) >>> 0;
  }
  function C(me, Ge) {
    return (me[Ge + 0] << 0 | me[Ge + 1] << 8 | me[Ge + 2] << 16 | me[Ge + 3] << 24) >>> 0;
  }
  new g();
  var I = [0], S = [0], F = [], U = new g(), V = n, W = function(me, Ge) {
    var ke = {}, pe = 0, _e = !1, De = 0, Me = 0;
    if (ke.frames = [], !/** @license
     * Copyright (c) 2017 Dominik Homberger
    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
    https://webpjs.appspot.com
    WebPRiffParser dominikhlbg@gmail.com
    */
    function(Re, ze, Xe, ot) {
      for (var rt = 0; rt < ot; rt++) if (Re[ze + rt] != Xe.charCodeAt(rt)) return !0;
      return !1;
    }(me, Ge, "RIFF", 4)) {
      var St, dt;
      for (C(me, Ge += 4), Ge += 8; Ge < me.length; ) {
        var Pt = y(me, Ge), gt = C(me, Ge += 4);
        Ge += 4;
        var Rt = gt + (1 & gt);
        switch (Pt) {
          case "VP8 ":
          case "VP8L":
            ke.frames[pe] === void 0 && (ke.frames[pe] = {}), (oe = ke.frames[pe]).src_off = _e ? Me : Ge - 8, oe.src_size = De + gt + 8, pe++, _e && (_e = !1, De = 0, Me = 0);
            break;
          case "VP8X":
            (oe = ke.header = {}).feature_flags = me[Ge];
            var Ft = Ge + 4;
            oe.canvas_width = 1 + A(me, Ft), Ft += 3, oe.canvas_height = 1 + A(me, Ft), Ft += 3;
            break;
          case "ALPH":
            _e = !0, De = Rt + 8, Me = Ge - 8;
            break;
          case "ANIM":
            (oe = ke.header).bgcolor = C(me, Ge), Ft = Ge + 4, oe.loop_count = (St = me)[(dt = Ft) + 0] << 0 | St[dt + 1] << 8, Ft += 2;
            break;
          case "ANMF":
            var mn, oe;
            (oe = ke.frames[pe] = {}).offset_x = 2 * A(me, Ge), Ge += 3, oe.offset_y = 2 * A(me, Ge), Ge += 3, oe.width = 1 + A(me, Ge), Ge += 3, oe.height = 1 + A(me, Ge), Ge += 3, oe.duration = A(me, Ge), Ge += 3, mn = me[Ge++], oe.dispose = 1 & mn, oe.blend = mn >> 1 & 1;
        }
        Pt != "ANMF" && (Ge += Rt);
      }
      return ke;
    }
  }(V, 0);
  W.response = V, W.rgbaoutput = !0, W.dataurl = !1;
  var X = W.header ? W.header : null, de = W.frames ? W.frames : null;
  if (X) {
    X.loop_counter = X.loop_count, I = [X.canvas_height], S = [X.canvas_width];
    for (var ie = 0; ie < de.length && de[ie].blend != 0; ie++) ;
  }
  var fe = de[0], Ae = U.WebPDecodeRGBA(V, fe.src_off, fe.src_size, S, I);
  fe.rgba = Ae, fe.imgwidth = S[0], fe.imgheight = I[0];
  for (var Te = 0; Te < S[0] * I[0] * 4; Te++) F[Te] = Ae[Te];
  return this.width = S, this.height = I, this.data = F, this;
}
(function(n) {
  var e = function() {
    return typeof E1 == "function";
  }, t = function(I, S, F, U) {
    var V = 4, W = c;
    switch (U) {
      case n.image_compression.FAST:
        V = 1, W = l;
        break;
      case n.image_compression.MEDIUM:
        V = 6, W = a;
        break;
      case n.image_compression.SLOW:
        V = 9, W = g;
    }
    I = i(I, S, F, W);
    var X = E1(I, { level: V });
    return n.__addimage__.arrayBufferToBinaryString(X);
  }, i = function(I, S, F, U) {
    for (var V, W, X, de = I.length / S, ie = new Uint8Array(I.length + de), fe = A(), Ae = 0; Ae < de; Ae += 1) {
      if (X = Ae * S, V = I.subarray(X, X + S), U) ie.set(U(V, F, W), X + Ae);
      else {
        for (var Te, me = fe.length, Ge = []; Te < me; Te += 1) Ge[Te] = fe[Te](V, F, W);
        var ke = C(Ge.concat());
        ie.set(Ge[ke], X + Ae);
      }
      W = V;
    }
    return ie;
  }, r = function(I) {
    var S = Array.apply([], I);
    return S.unshift(0), S;
  }, l = function(I, S) {
    var F, U = [], V = I.length;
    U[0] = 1;
    for (var W = 0; W < V; W += 1) F = I[W - S] || 0, U[W + 1] = I[W] - F + 256 & 255;
    return U;
  }, c = function(I, S, F) {
    var U, V = [], W = I.length;
    V[0] = 2;
    for (var X = 0; X < W; X += 1) U = F && F[X] || 0, V[X + 1] = I[X] - U + 256 & 255;
    return V;
  }, a = function(I, S, F) {
    var U, V, W = [], X = I.length;
    W[0] = 3;
    for (var de = 0; de < X; de += 1) U = I[de - S] || 0, V = F && F[de] || 0, W[de + 1] = I[de] + 256 - (U + V >>> 1) & 255;
    return W;
  }, g = function(I, S, F) {
    var U, V, W, X, de = [], ie = I.length;
    de[0] = 4;
    for (var fe = 0; fe < ie; fe += 1) U = I[fe - S] || 0, V = F && F[fe] || 0, W = F && F[fe - S] || 0, X = y(U, V, W), de[fe + 1] = I[fe] - X + 256 & 255;
    return de;
  }, y = function(I, S, F) {
    if (I === S && S === F) return I;
    var U = Math.abs(S - F), V = Math.abs(I - F), W = Math.abs(I + S - F - F);
    return U <= V && U <= W ? I : V <= W ? S : F;
  }, A = function() {
    return [r, l, c, a, g];
  }, C = function(I) {
    var S = I.map(function(F) {
      return F.reduce(function(U, V) {
        return U + Math.abs(V);
      }, 0);
    });
    return S.indexOf(Math.min.apply(null, S));
  };
  n.processPNG = function(I, S, F, U) {
    var V, W, X, de, ie, fe, Ae, Te, me, Ge, ke, pe, _e, De, Me, St = this.decode.FLATE_DECODE, dt = "";
    if (this.__addimage__.isArrayBuffer(I) && (I = new Uint8Array(I)), this.__addimage__.isArrayBufferView(I)) {
      if (I = (X = new nq(I)).imgData, W = X.bits, V = X.colorSpace, ie = X.colors, [4, 6].indexOf(X.colorType) !== -1) {
        if (X.bits === 8) {
          me = (Te = X.pixelBitlength == 32 ? new Uint32Array(X.decodePixels().buffer) : X.pixelBitlength == 16 ? new Uint16Array(X.decodePixels().buffer) : new Uint8Array(X.decodePixels().buffer)).length, ke = new Uint8Array(me * X.colors), Ge = new Uint8Array(me);
          var Pt, gt = X.pixelBitlength - X.bits;
          for (De = 0, Me = 0; De < me; De++) {
            for (_e = Te[De], Pt = 0; Pt < gt; ) ke[Me++] = _e >>> Pt & 255, Pt += X.bits;
            Ge[De] = _e >>> Pt & 255;
          }
        }
        if (X.bits === 16) {
          me = (Te = new Uint32Array(X.decodePixels().buffer)).length, ke = new Uint8Array(me * (32 / X.pixelBitlength) * X.colors), Ge = new Uint8Array(me * (32 / X.pixelBitlength)), pe = X.colors > 1, De = 0, Me = 0;
          for (var Rt = 0; De < me; ) _e = Te[De++], ke[Me++] = _e >>> 0 & 255, pe && (ke[Me++] = _e >>> 16 & 255, _e = Te[De++], ke[Me++] = _e >>> 0 & 255), Ge[Rt++] = _e >>> 16 & 255;
          W = 8;
        }
        U !== n.image_compression.NONE && e() ? (I = t(ke, X.width * X.colors, X.colors, U), Ae = t(Ge, X.width, 1, U)) : (I = ke, Ae = Ge, St = void 0);
      }
      if (X.colorType === 3 && (V = this.color_spaces.INDEXED, fe = X.palette, X.transparency.indexed)) {
        var Ft = X.transparency.indexed, mn = 0;
        for (De = 0, me = Ft.length; De < me; ++De) mn += Ft[De];
        if ((mn /= 255) === me - 1 && Ft.indexOf(0) !== -1) de = [Ft.indexOf(0)];
        else if (mn !== me) {
          for (Te = X.decodePixels(), Ge = new Uint8Array(Te.length), De = 0, me = Te.length; De < me; De++) Ge[De] = Ft[Te[De]];
          Ae = t(Ge, X.width, 1);
        }
      }
      var oe = function(Re) {
        var ze;
        switch (Re) {
          case n.image_compression.FAST:
            ze = 11;
            break;
          case n.image_compression.MEDIUM:
            ze = 13;
            break;
          case n.image_compression.SLOW:
            ze = 14;
            break;
          default:
            ze = 12;
        }
        return ze;
      }(U);
      return St === this.decode.FLATE_DECODE && (dt = "/Predictor " + oe + " "), dt += "/Colors " + ie + " /BitsPerComponent " + W + " /Columns " + X.width, (this.__addimage__.isArrayBuffer(I) || this.__addimage__.isArrayBufferView(I)) && (I = this.__addimage__.arrayBufferToBinaryString(I)), (Ae && this.__addimage__.isArrayBuffer(Ae) || this.__addimage__.isArrayBufferView(Ae)) && (Ae = this.__addimage__.arrayBufferToBinaryString(Ae)), { alias: F, data: I, index: S, filter: St, decodeParameters: dt, transparency: de, palette: fe, sMask: Ae, predictor: oe, width: X.width, height: X.height, bitsPerComponent: W, colorSpace: V };
    }
  };
})(ti.API), function(n) {
  n.processGIF89A = function(e, t, i, r) {
    var l = new iq(e), c = l.width, a = l.height, g = [];
    l.decodeAndBlitFrameRGBA(0, g);
    var y = { data: g, width: c, height: a }, A = new _y(100).encode(y, 100);
    return n.processJPEG.call(this, A, t, i, r);
  }, n.processGIF87A = n.processGIF89A;
}(ti.API), cc.prototype.parseHeader = function() {
  if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
    var n = this.colors === 0 ? 1 << this.bitPP : this.colors;
    this.palette = new Array(n);
    for (var e = 0; e < n; e++) {
      var t = this.datav.getUint8(this.pos++, !0), i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), l = this.datav.getUint8(this.pos++, !0);
      this.palette[e] = { red: r, green: i, blue: t, quad: l };
    }
  }
  this.height < 0 && (this.height *= -1, this.bottom_up = !1);
}, cc.prototype.parseBGR = function() {
  this.pos = this.offset;
  try {
    var n = "bit" + this.bitPP, e = this.width * this.height * 4;
    this.data = new Uint8Array(e), this[n]();
  } catch (t) {
    mr.log("bit decode error:" + t);
  }
}, cc.prototype.bit1 = function() {
  var n, e = Math.ceil(this.width / 8), t = e % 4;
  for (n = this.height - 1; n >= 0; n--) {
    for (var i = this.bottom_up ? n : this.height - 1 - n, r = 0; r < e; r++) for (var l = this.datav.getUint8(this.pos++, !0), c = i * this.width * 4 + 8 * r * 4, a = 0; a < 8 && 8 * r + a < this.width; a++) {
      var g = this.palette[l >> 7 - a & 1];
      this.data[c + 4 * a] = g.blue, this.data[c + 4 * a + 1] = g.green, this.data[c + 4 * a + 2] = g.red, this.data[c + 4 * a + 3] = 255;
    }
    t !== 0 && (this.pos += 4 - t);
  }
}, cc.prototype.bit4 = function() {
  for (var n = Math.ceil(this.width / 2), e = n % 4, t = this.height - 1; t >= 0; t--) {
    for (var i = this.bottom_up ? t : this.height - 1 - t, r = 0; r < n; r++) {
      var l = this.datav.getUint8(this.pos++, !0), c = i * this.width * 4 + 2 * r * 4, a = l >> 4, g = 15 & l, y = this.palette[a];
      if (this.data[c] = y.blue, this.data[c + 1] = y.green, this.data[c + 2] = y.red, this.data[c + 3] = 255, 2 * r + 1 >= this.width) break;
      y = this.palette[g], this.data[c + 4] = y.blue, this.data[c + 4 + 1] = y.green, this.data[c + 4 + 2] = y.red, this.data[c + 4 + 3] = 255;
    }
    e !== 0 && (this.pos += 4 - e);
  }
}, cc.prototype.bit8 = function() {
  for (var n = this.width % 4, e = this.height - 1; e >= 0; e--) {
    for (var t = this.bottom_up ? e : this.height - 1 - e, i = 0; i < this.width; i++) {
      var r = this.datav.getUint8(this.pos++, !0), l = t * this.width * 4 + 4 * i;
      if (r < this.palette.length) {
        var c = this.palette[r];
        this.data[l] = c.red, this.data[l + 1] = c.green, this.data[l + 2] = c.blue, this.data[l + 3] = 255;
      } else this.data[l] = 255, this.data[l + 1] = 255, this.data[l + 2] = 255, this.data[l + 3] = 255;
    }
    n !== 0 && (this.pos += 4 - n);
  }
}, cc.prototype.bit15 = function() {
  for (var n = this.width % 3, e = parseInt("11111", 2), t = this.height - 1; t >= 0; t--) {
    for (var i = this.bottom_up ? t : this.height - 1 - t, r = 0; r < this.width; r++) {
      var l = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var c = (l & e) / e * 255 | 0, a = (l >> 5 & e) / e * 255 | 0, g = (l >> 10 & e) / e * 255 | 0, y = l >> 15 ? 255 : 0, A = i * this.width * 4 + 4 * r;
      this.data[A] = g, this.data[A + 1] = a, this.data[A + 2] = c, this.data[A + 3] = y;
    }
    this.pos += n;
  }
}, cc.prototype.bit16 = function() {
  for (var n = this.width % 3, e = parseInt("11111", 2), t = parseInt("111111", 2), i = this.height - 1; i >= 0; i--) {
    for (var r = this.bottom_up ? i : this.height - 1 - i, l = 0; l < this.width; l++) {
      var c = this.datav.getUint16(this.pos, !0);
      this.pos += 2;
      var a = (c & e) / e * 255 | 0, g = (c >> 5 & t) / t * 255 | 0, y = (c >> 11) / e * 255 | 0, A = r * this.width * 4 + 4 * l;
      this.data[A] = y, this.data[A + 1] = g, this.data[A + 2] = a, this.data[A + 3] = 255;
    }
    this.pos += n;
  }
}, cc.prototype.bit24 = function() {
  for (var n = this.height - 1; n >= 0; n--) {
    for (var e = this.bottom_up ? n : this.height - 1 - n, t = 0; t < this.width; t++) {
      var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), l = this.datav.getUint8(this.pos++, !0), c = e * this.width * 4 + 4 * t;
      this.data[c] = l, this.data[c + 1] = r, this.data[c + 2] = i, this.data[c + 3] = 255;
    }
    this.pos += this.width % 4;
  }
}, cc.prototype.bit32 = function() {
  for (var n = this.height - 1; n >= 0; n--) for (var e = this.bottom_up ? n : this.height - 1 - n, t = 0; t < this.width; t++) {
    var i = this.datav.getUint8(this.pos++, !0), r = this.datav.getUint8(this.pos++, !0), l = this.datav.getUint8(this.pos++, !0), c = this.datav.getUint8(this.pos++, !0), a = e * this.width * 4 + 4 * t;
    this.data[a] = l, this.data[a + 1] = r, this.data[a + 2] = i, this.data[a + 3] = c;
  }
}, cc.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2018 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  n.processBMP = function(e, t, i, r) {
    var l = new cc(e, !1), c = l.width, a = l.height, g = { data: l.getData(), width: c, height: a }, y = new _y(100).encode(g, 100);
    return n.processJPEG.call(this, y, t, i, r);
  };
}(ti.API), B5.prototype.getData = function() {
  return this.data;
}, /**
* @license
* Copyright (c) 2019 Aras Abbasi
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  n.processWEBP = function(e, t, i, r) {
    var l = new B5(e), c = l.width, a = l.height, g = { data: l.getData(), width: c, height: a }, y = new _y(100).encode(g, 100);
    return n.processJPEG.call(this, y, t, i, r);
  };
}(ti.API), ti.API.processRGBA = function(n, e, t) {
  for (var i = n.data, r = i.length, l = new Uint8Array(r / 4 * 3), c = new Uint8Array(r / 4), a = 0, g = 0, y = 0; y < r; y += 4) {
    var A = i[y], C = i[y + 1], I = i[y + 2], S = i[y + 3];
    l[a++] = A, l[a++] = C, l[a++] = I, c[g++] = S;
  }
  var F = this.__addimage__.arrayBufferToBinaryString(l);
  return { alpha: this.__addimage__.arrayBufferToBinaryString(c), data: F, index: e, alias: t, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: n.width, height: n.height };
}, ti.API.setLanguage = function(n) {
  return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[n] !== void 0 && (this.internal.languageSettings.languageCode = n, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
  }), this.internal.languageSettings.isSubscribed = !0)), this;
}, Nd = ti.API, Kg = Nd.getCharWidthsArray = function(n, e) {
  var t, i, r = (e = e || {}).font || this.internal.getFont(), l = e.fontSize || this.internal.getFontSize(), c = e.charSpace || this.internal.getCharSpace(), a = e.widths ? e.widths : r.metadata.Unicode.widths, g = a.fof ? a.fof : 1, y = e.kerning ? e.kerning : r.metadata.Unicode.kerning, A = y.fof ? y.fof : 1, C = e.doKerning !== !1, I = 0, S = n.length, F = 0, U = a[0] || g, V = [];
  for (t = 0; t < S; t++) i = n.charCodeAt(t), typeof r.metadata.widthOfString == "function" ? V.push((r.metadata.widthOfGlyph(r.metadata.characterToGlyph(i)) + c * (1e3 / l) || 0) / 1e3) : (I = C && or(y[i]) === "object" && !isNaN(parseInt(y[i][F], 10)) ? y[i][F] / A : 0, V.push((a[i] || U) / g + I)), F = i;
  return V;
}, I5 = Nd.getStringUnitWidth = function(n, e) {
  var t = (e = e || {}).fontSize || this.internal.getFontSize(), i = e.font || this.internal.getFont(), r = e.charSpace || this.internal.getCharSpace();
  return Nd.processArabic && (n = Nd.processArabic(n)), typeof i.metadata.widthOfString == "function" ? i.metadata.widthOfString(n, t, r) / t : Kg.apply(this, arguments).reduce(function(l, c) {
    return l + c;
  }, 0);
}, M5 = function(n, e, t, i) {
  for (var r = [], l = 0, c = n.length, a = 0; l !== c && a + e[l] < t; ) a += e[l], l++;
  r.push(n.slice(0, l));
  var g = l;
  for (a = 0; l !== c; ) a + e[l] > i && (r.push(n.slice(g, l)), a = 0, g = l), a += e[l], l++;
  return g !== l && r.push(n.slice(g, l)), r;
}, L5 = function(n, e, t) {
  t || (t = {});
  var i, r, l, c, a, g, y, A = [], C = [A], I = t.textIndent || 0, S = 0, F = 0, U = n.split(" "), V = Kg.apply(this, [" ", t])[0];
  if (g = t.lineIndent === -1 ? U[0].length + 2 : t.lineIndent || 0) {
    var W = Array(g).join(" "), X = [];
    U.map(function(ie) {
      (ie = ie.split(/\s*\n/)).length > 1 ? X = X.concat(ie.map(function(fe, Ae) {
        return (Ae && fe.length ? `
` : "") + fe;
      })) : X.push(ie[0]);
    }), U = X, g = I5.apply(this, [W, t]);
  }
  for (l = 0, c = U.length; l < c; l++) {
    var de = 0;
    if (i = U[l], g && i[0] == `
` && (i = i.substr(1), de = 1), I + S + (F = (r = Kg.apply(this, [i, t])).reduce(function(ie, fe) {
      return ie + fe;
    }, 0)) > e || de) {
      if (F > e) {
        for (a = M5.apply(this, [i, r, e - (I + S), e]), A.push(a.shift()), A = [a.pop()]; a.length; ) C.push([a.shift()]);
        F = r.slice(i.length - (A[0] ? A[0].length : 0)).reduce(function(ie, fe) {
          return ie + fe;
        }, 0);
      } else A = [i];
      C.push(A), I = F + g, S = V;
    } else A.push(i), I += S + F, S = V;
  }
  return y = g ? function(ie, fe) {
    return (fe ? W : "") + ie.join(" ");
  } : function(ie) {
    return ie.join(" ");
  }, C.map(y);
}, Nd.splitTextToSize = function(n, e, t) {
  var i, r = (t = t || {}).fontSize || this.internal.getFontSize(), l = (function(A) {
    if (A.widths && A.kerning) return { widths: A.widths, kerning: A.kerning };
    var C = this.internal.getFont(A.fontName, A.fontStyle);
    return C.metadata.Unicode ? { widths: C.metadata.Unicode.widths || { 0: 1 }, kerning: C.metadata.Unicode.kerning || {} } : { font: C.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
  }).call(this, t);
  i = Array.isArray(n) ? n : String(n).split(/\r?\n/);
  var c = 1 * this.internal.scaleFactor * e / r;
  l.textIndent = t.textIndent ? 1 * t.textIndent * this.internal.scaleFactor / r : 0, l.lineIndent = t.lineIndent;
  var a, g, y = [];
  for (a = 0, g = i.length; a < g; a++) y = y.concat(L5.apply(this, [i[a], c, l]));
  return y;
}, function(n) {
  n.__fontmetrics__ = n.__fontmetrics__ || {};
  for (var e = "klmnopqrstuvwxyz", t = {}, i = {}, r = 0; r < e.length; r++) t[e[r]] = "0123456789abcdef"[r], i["0123456789abcdef"[r]] = e[r];
  var l = function(C) {
    return "0x" + parseInt(C, 10).toString(16);
  }, c = n.__fontmetrics__.compress = function(C) {
    var I, S, F, U, V = ["{"];
    for (var W in C) {
      if (I = C[W], isNaN(parseInt(W, 10)) ? S = "'" + W + "'" : (W = parseInt(W, 10), S = (S = l(W).slice(2)).slice(0, -1) + i[S.slice(-1)]), typeof I == "number") I < 0 ? (F = l(I).slice(3), U = "-") : (F = l(I).slice(2), U = ""), F = U + F.slice(0, -1) + i[F.slice(-1)];
      else {
        if (or(I) !== "object") throw new Error("Don't know what to do with value type " + or(I) + ".");
        F = c(I);
      }
      V.push(S + F);
    }
    return V.push("}"), V.join("");
  }, a = n.__fontmetrics__.uncompress = function(C) {
    if (typeof C != "string") throw new Error("Invalid argument passed to uncompress.");
    for (var I, S, F, U, V = {}, W = 1, X = V, de = [], ie = "", fe = "", Ae = C.length - 1, Te = 1; Te < Ae; Te += 1) (U = C[Te]) == "'" ? I ? (F = I.join(""), I = void 0) : I = [] : I ? I.push(U) : U == "{" ? (de.push([X, F]), X = {}, F = void 0) : U == "}" ? ((S = de.pop())[0][S[1]] = X, F = void 0, X = S[0]) : U == "-" ? W = -1 : F === void 0 ? t.hasOwnProperty(U) ? (ie += t[U], F = parseInt(ie, 16) * W, W = 1, ie = "") : ie += U : t.hasOwnProperty(U) ? (fe += t[U], X[F] = parseInt(fe, 16) * W, W = 1, F = void 0, fe = "") : fe += U;
    return V;
  }, g = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: a("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, y = { Unicode: { Courier: g, "Courier-Bold": g, "Courier-BoldOblique": g, "Courier-Oblique": g, Helvetica: g, "Helvetica-Bold": g, "Helvetica-BoldOblique": g, "Helvetica-Oblique": g, "Times-Roman": g, "Times-Bold": g, "Times-BoldItalic": g, "Times-Italic": g } }, A = { Unicode: { "Courier-Oblique": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": a("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": a("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": a("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: a("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: a("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": a("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: a("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": a("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": a("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": a("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": a("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
  n.events.push(["addFont", function(C) {
    var I = C.font, S = A.Unicode[I.postScriptName];
    S && (I.metadata.Unicode = {}, I.metadata.Unicode.widths = S.widths, I.metadata.Unicode.kerning = S.kerning);
    var F = y.Unicode[I.postScriptName];
    F && (I.metadata.Unicode.encoding = F, I.encoding = F.codePages[0]);
  }]);
}(ti.API), /**
* @license
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function(t) {
    for (var i = t.length, r = new Uint8Array(i), l = 0; l < i; l++) r[l] = t.charCodeAt(l);
    return r;
  };
  n.API.events.push(["addFont", function(t) {
    var i = void 0, r = t.font, l = t.instance;
    if (!r.isStandardFont) {
      if (l === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      if (typeof (i = l.existsFileInVFS(r.postScriptName) === !1 ? l.loadFile(r.postScriptName) : l.getFileFromVFS(r.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + r.postScriptName + "').");
      (function(c, a) {
        a = /^\x00\x01\x00\x00/.test(a) ? e(a) : e(Ap(a)), c.metadata = n.API.TTFFont.open(a), c.metadata.Unicode = c.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, c.metadata.glyIdsUsed = [0];
      })(r, i);
    }
  }]);
}(ti), /** @license
* Copyright (c) 2012 Willow Systems Corporation, https://github.com/willowsystems
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(n) {
  function e() {
    return (ni.canvg ? Promise.resolve(ni.canvg) : import("./index.es-BMA8JOAQ-DOQmf7K5.mjs")).catch(function(t) {
      return Promise.reject(new Error("Could not load canvg: " + t));
    }).then(function(t) {
      return t.default ? t.default : t;
    });
  }
  ti.API.addSvgAsImage = function(t, i, r, l, c, a, g, y) {
    if (isNaN(i) || isNaN(r)) throw mr.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(l) || isNaN(c)) throw mr.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var A = document.createElement("canvas");
    A.width = l, A.height = c;
    var C = A.getContext("2d");
    C.fillStyle = "#fff", C.fillRect(0, 0, A.width, A.height);
    var I = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, S = this;
    return e().then(function(F) {
      return F.fromString(C, t, I);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(F) {
      return F.render(I);
    }).then(function() {
      S.addImage(A.toDataURL("image/jpeg", 1), i, r, l, c, g, y);
    });
  };
}(), ti.API.putTotalPages = function(n) {
  var e, t = 0;
  parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e = new RegExp(n, "g"), t = this.internal.getNumberOfPages()) : (e = new RegExp(this.pdfEscape16(n, this.internal.getFont()), "g"), t = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
  for (var i = 1; i <= this.internal.getNumberOfPages(); i++) for (var r = 0; r < this.internal.pages[i].length; r++) this.internal.pages[i][r] = this.internal.pages[i][r].replace(e, t);
  return this;
}, ti.API.viewerPreferences = function(n, e) {
  var t;
  n = n || {}, e = e || !1;
  var i, r, l, c = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, a = Object.keys(c), g = [], y = 0, A = 0, C = 0;
  function I(F, U) {
    var V, W = !1;
    for (V = 0; V < F.length; V += 1) F[V] === U && (W = !0);
    return W;
  }
  if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(c)), this.internal.viewerpreferences.isSubscribed = !1), t = this.internal.viewerpreferences.configuration, n === "reset" || e === !0) {
    var S = a.length;
    for (C = 0; C < S; C += 1) t[a[C]].value = t[a[C]].defaultValue, t[a[C]].explicitSet = !1;
  }
  if (or(n) === "object") {
    for (r in n) if (l = n[r], I(a, r) && l !== void 0) {
      if (t[r].type === "boolean" && typeof l == "boolean") t[r].value = l;
      else if (t[r].type === "name" && I(t[r].valueSet, l)) t[r].value = l;
      else if (t[r].type === "integer" && Number.isInteger(l)) t[r].value = l;
      else if (t[r].type === "array") {
        for (y = 0; y < l.length; y += 1) if (i = !0, l[y].length === 1 && typeof l[y][0] == "number") g.push(String(l[y] - 1));
        else if (l[y].length > 1) {
          for (A = 0; A < l[y].length; A += 1) typeof l[y][A] != "number" && (i = !1);
          i === !0 && g.push([l[y][0] - 1, l[y][1] - 1].join(" "));
        }
        t[r].value = "[" + g.join(" ") + "]";
      } else t[r].value = t[r].defaultValue;
      t[r].explicitSet = !0;
    }
  }
  return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function() {
    var F, U = [];
    for (F in t) t[F].explicitSet === !0 && (t[F].type === "name" ? U.push("/" + F + " /" + t[F].value) : U.push("/" + F + " " + t[F].value));
    U.length !== 0 && this.internal.write(`/ViewerPreferences
<<
` + U.join(`
`) + `
>>`);
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = t, this;
}, /** ====================================================================
* @license
* jsPDF XMP metadata plugin
* Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
* ====================================================================
*/
function(n) {
  var e = function() {
    var i = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', r = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), l = unescape(encodeURIComponent(i)), c = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), a = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), g = unescape(encodeURIComponent("</x:xmpmeta>")), y = l.length + c.length + a.length + r.length + g.length;
    this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + y + " >>"), this.internal.write("stream"), this.internal.write(r + l + c + a + g), this.internal.write("endstream"), this.internal.write("endobj");
  }, t = function() {
    this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
  };
  n.addMetadata = function(i, r) {
    return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: i, namespaceuri: r || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", t), this.internal.events.subscribe("postPutResources", e)), this;
  };
}(ti.API), function(n) {
  var e = n.API, t = e.pdfEscape16 = function(l, c) {
    for (var a, g = c.metadata.Unicode.widths, y = ["", "0", "00", "000", "0000"], A = [""], C = 0, I = l.length; C < I; ++C) {
      if (a = c.metadata.characterToGlyph(l.charCodeAt(C)), c.metadata.glyIdsUsed.push(a), c.metadata.toUnicode[a] = l.charCodeAt(C), g.indexOf(a) == -1 && (g.push(a), g.push([parseInt(c.metadata.widthOfGlyph(a), 10)])), a == "0") return A.join("");
      a = a.toString(16), A.push(y[4 - a.length], a);
    }
    return A.join("");
  }, i = function(l) {
    var c, a, g, y, A, C, I;
    for (A = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, g = [], C = 0, I = (a = Object.keys(l).sort(function(S, F) {
      return S - F;
    })).length; C < I; C++) c = a[C], g.length >= 100 && (A += `
` + g.length + ` beginbfchar
` + g.join(`
`) + `
endbfchar`, g = []), l[c] !== void 0 && l[c] !== null && typeof l[c].toString == "function" && (y = ("0000" + l[c].toString(16)).slice(-4), c = ("0000" + (+c).toString(16)).slice(-4), g.push("<" + c + "><" + y + ">"));
    return g.length && (A += `
` + g.length + ` beginbfchar
` + g.join(`
`) + `
endbfchar
`), A += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`;
  };
  e.events.push(["putFont", function(l) {
    (function(c) {
      var a = c.font, g = c.out, y = c.newObject, A = c.putStream;
      if (a.metadata instanceof n.API.TTFFont && a.encoding === "Identity-H") {
        for (var C = a.metadata.Unicode.widths, I = a.metadata.subset.encode(a.metadata.glyIdsUsed, 1), S = "", F = 0; F < I.length; F++) S += String.fromCharCode(I[F]);
        var U = y();
        A({ data: S, addLength1: !0, objectId: U }), g("endobj");
        var V = y();
        A({ data: i(a.metadata.toUnicode), addLength1: !0, objectId: V }), g("endobj");
        var W = y();
        g("<<"), g("/Type /FontDescriptor"), g("/FontName /" + jd(a.fontName)), g("/FontFile2 " + U + " 0 R"), g("/FontBBox " + n.API.PDFObject.convert(a.metadata.bbox)), g("/Flags " + a.metadata.flags), g("/StemV " + a.metadata.stemV), g("/ItalicAngle " + a.metadata.italicAngle), g("/Ascent " + a.metadata.ascender), g("/Descent " + a.metadata.decender), g("/CapHeight " + a.metadata.capHeight), g(">>"), g("endobj");
        var X = y();
        g("<<"), g("/Type /Font"), g("/BaseFont /" + jd(a.fontName)), g("/FontDescriptor " + W + " 0 R"), g("/W " + n.API.PDFObject.convert(C)), g("/CIDToGIDMap /Identity"), g("/DW 1000"), g("/Subtype /CIDFontType2"), g("/CIDSystemInfo"), g("<<"), g("/Supplement 0"), g("/Registry (Adobe)"), g("/Ordering (" + a.encoding + ")"), g(">>"), g(">>"), g("endobj"), a.objectNumber = y(), g("<<"), g("/Type /Font"), g("/Subtype /Type0"), g("/ToUnicode " + V + " 0 R"), g("/BaseFont /" + jd(a.fontName)), g("/Encoding /" + a.encoding), g("/DescendantFonts [" + X + " 0 R]"), g(">>"), g("endobj"), a.isAlreadyPutted = !0;
      }
    })(l);
  }]), e.events.push(["putFont", function(l) {
    (function(c) {
      var a = c.font, g = c.out, y = c.newObject, A = c.putStream;
      if (a.metadata instanceof n.API.TTFFont && a.encoding === "WinAnsiEncoding") {
        for (var C = a.metadata.rawData, I = "", S = 0; S < C.length; S++) I += String.fromCharCode(C[S]);
        var F = y();
        A({ data: I, addLength1: !0, objectId: F }), g("endobj");
        var U = y();
        A({ data: i(a.metadata.toUnicode), addLength1: !0, objectId: U }), g("endobj");
        var V = y();
        g("<<"), g("/Descent " + a.metadata.decender), g("/CapHeight " + a.metadata.capHeight), g("/StemV " + a.metadata.stemV), g("/Type /FontDescriptor"), g("/FontFile2 " + F + " 0 R"), g("/Flags 96"), g("/FontBBox " + n.API.PDFObject.convert(a.metadata.bbox)), g("/FontName /" + jd(a.fontName)), g("/ItalicAngle " + a.metadata.italicAngle), g("/Ascent " + a.metadata.ascender), g(">>"), g("endobj"), a.objectNumber = y();
        for (var W = 0; W < a.metadata.hmtx.widths.length; W++) a.metadata.hmtx.widths[W] = parseInt(a.metadata.hmtx.widths[W] * (1e3 / a.metadata.head.unitsPerEm));
        g("<</Subtype/TrueType/Type/Font/ToUnicode " + U + " 0 R/BaseFont/" + jd(a.fontName) + "/FontDescriptor " + V + " 0 R/Encoding/" + a.encoding + " /FirstChar 29 /LastChar 255 /Widths " + n.API.PDFObject.convert(a.metadata.hmtx.widths) + ">>"), g("endobj"), a.isAlreadyPutted = !0;
      }
    })(l);
  }]);
  var r = function(l) {
    var c, a = l.text || "", g = l.x, y = l.y, A = l.options || {}, C = l.mutex || {}, I = C.pdfEscape, S = C.activeFontKey, F = C.fonts, U = S, V = "", W = 0, X = "", de = F[U].encoding;
    if (F[U].encoding !== "Identity-H") return { text: a, x: g, y, options: A, mutex: C };
    for (X = a, U = S, Array.isArray(a) && (X = a[0]), W = 0; W < X.length; W += 1) F[U].metadata.hasOwnProperty("cmap") && (c = F[U].metadata.cmap.unicode.codeMap[X[W].charCodeAt(0)]), c || X[W].charCodeAt(0) < 256 && F[U].metadata.hasOwnProperty("Unicode") ? V += X[W] : V += "";
    var ie = "";
    return parseInt(U.slice(1)) < 14 || de === "WinAnsiEncoding" ? ie = I(V, U).split("").map(function(fe) {
      return fe.charCodeAt(0).toString(16);
    }).join("") : de === "Identity-H" && (ie = t(V, F[U])), C.isHex = !0, { text: ie, x: g, y, options: A, mutex: C };
  };
  e.events.push(["postProcessText", function(l) {
    var c = l.text || "", a = [], g = { text: c, x: l.x, y: l.y, options: l.options, mutex: l.mutex };
    if (Array.isArray(c)) {
      var y = 0;
      for (y = 0; y < c.length; y += 1) Array.isArray(c[y]) && c[y].length === 3 ? a.push([r(Object.assign({}, g, { text: c[y][0] })).text, c[y][1], c[y][2]]) : a.push(r(Object.assign({}, g, { text: c[y] })).text);
      l.text = a;
    } else l.text = r(Object.assign({}, g, { text: c })).text;
  }]);
}(ti), /**
* @license
* jsPDF virtual FileSystem functionality
*
* Licensed under the MIT License.
* http://opensource.org/licenses/mit-license
*/
function(n) {
  var e = function() {
    return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0;
  };
  n.existsFileInVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0;
  }, n.addFileToVFS = function(t, i) {
    return e.call(this), this.internal.vFS[t] = i, this;
  }, n.getFileFromVFS = function(t) {
    return e.call(this), this.internal.vFS[t] !== void 0 ? this.internal.vFS[t] : null;
  };
}(ti.API), /**
* @license
* Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
* MIT License
*/
function(n) {
  n.__bidiEngine__ = n.prototype.__bidiEngine__ = function(i) {
    var r, l, c, a, g, y, A, C = e, I = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], S = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], F = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, U = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, V = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], W = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), X = !1, de = 0;
    this.__bidiEngine__ = {};
    var ie = function(pe) {
      var _e = pe.charCodeAt(), De = _e >> 8, Me = U[De];
      return Me !== void 0 ? C[256 * Me + (255 & _e)] : De === 252 || De === 253 ? "AL" : W.test(De) ? "L" : De === 8 ? "R" : "N";
    }, fe = function(pe) {
      for (var _e, De = 0; De < pe.length; De++) {
        if ((_e = ie(pe.charAt(De))) === "L") return !1;
        if (_e === "R") return !0;
      }
      return !1;
    }, Ae = function(pe, _e, De, Me) {
      var St, dt, Pt, gt, Rt = _e[Me];
      switch (Rt) {
        case "L":
        case "R":
          X = !1;
          break;
        case "N":
        case "AN":
          break;
        case "EN":
          X && (Rt = "AN");
          break;
        case "AL":
          X = !0, Rt = "R";
          break;
        case "WS":
          Rt = "N";
          break;
        case "CS":
          Me < 1 || Me + 1 >= _e.length || (St = De[Me - 1]) !== "EN" && St !== "AN" || (dt = _e[Me + 1]) !== "EN" && dt !== "AN" ? Rt = "N" : X && (dt = "AN"), Rt = dt === St ? dt : "N";
          break;
        case "ES":
          Rt = (St = Me > 0 ? De[Me - 1] : "B") === "EN" && Me + 1 < _e.length && _e[Me + 1] === "EN" ? "EN" : "N";
          break;
        case "ET":
          if (Me > 0 && De[Me - 1] === "EN") {
            Rt = "EN";
            break;
          }
          if (X) {
            Rt = "N";
            break;
          }
          for (Pt = Me + 1, gt = _e.length; Pt < gt && _e[Pt] === "ET"; ) Pt++;
          Rt = Pt < gt && _e[Pt] === "EN" ? "EN" : "N";
          break;
        case "NSM":
          if (c && !a) {
            for (gt = _e.length, Pt = Me + 1; Pt < gt && _e[Pt] === "NSM"; ) Pt++;
            if (Pt < gt) {
              var Ft = pe[Me], mn = Ft >= 1425 && Ft <= 2303 || Ft === 64286;
              if (St = _e[Pt], mn && (St === "R" || St === "AL")) {
                Rt = "R";
                break;
              }
            }
          }
          Rt = Me < 1 || (St = _e[Me - 1]) === "B" ? "N" : De[Me - 1];
          break;
        case "B":
          X = !1, r = !0, Rt = de;
          break;
        case "S":
          l = !0, Rt = "N";
          break;
        case "LRE":
        case "RLE":
        case "LRO":
        case "RLO":
        case "PDF":
          X = !1;
          break;
        case "BN":
          Rt = "N";
      }
      return Rt;
    }, Te = function(pe, _e, De) {
      var Me = pe.split("");
      return De && me(Me, De, { hiLevel: de }), Me.reverse(), _e && _e.reverse(), Me.join("");
    }, me = function(pe, _e, De) {
      var Me, St, dt, Pt, gt, Rt = -1, Ft = pe.length, mn = 0, oe = [], Re = de ? S : I, ze = [];
      for (X = !1, r = !1, l = !1, St = 0; St < Ft; St++) ze[St] = ie(pe[St]);
      for (dt = 0; dt < Ft; dt++) {
        if (gt = mn, oe[dt] = Ae(pe, ze, oe, dt), Me = 240 & (mn = Re[gt][F[oe[dt]]]), mn &= 15, _e[dt] = Pt = Re[mn][5], Me > 0) if (Me === 16) {
          for (St = Rt; St < dt; St++) _e[St] = 1;
          Rt = -1;
        } else Rt = -1;
        if (Re[mn][6]) Rt === -1 && (Rt = dt);
        else if (Rt > -1) {
          for (St = Rt; St < dt; St++) _e[St] = Pt;
          Rt = -1;
        }
        ze[dt] === "B" && (_e[dt] = 0), De.hiLevel |= Pt;
      }
      l && function(Xe, ot, rt) {
        for (var xt = 0; xt < rt; xt++) if (Xe[xt] === "S") {
          ot[xt] = de;
          for (var ht = xt - 1; ht >= 0 && Xe[ht] === "WS"; ht--) ot[ht] = de;
        }
      }(ze, _e, Ft);
    }, Ge = function(pe, _e, De, Me, St) {
      if (!(St.hiLevel < pe)) {
        if (pe === 1 && de === 1 && !r) return _e.reverse(), void (De && De.reverse());
        for (var dt, Pt, gt, Rt, Ft = _e.length, mn = 0; mn < Ft; ) {
          if (Me[mn] >= pe) {
            for (gt = mn + 1; gt < Ft && Me[gt] >= pe; ) gt++;
            for (Rt = mn, Pt = gt - 1; Rt < Pt; Rt++, Pt--) dt = _e[Rt], _e[Rt] = _e[Pt], _e[Pt] = dt, De && (dt = De[Rt], De[Rt] = De[Pt], De[Pt] = dt);
            mn = gt;
          }
          mn++;
        }
      }
    }, ke = function(pe, _e, De) {
      var Me = pe.split(""), St = { hiLevel: de };
      return De || (De = []), me(Me, De, St), function(dt, Pt, gt) {
        if (gt.hiLevel !== 0 && A) for (var Rt, Ft = 0; Ft < dt.length; Ft++) Pt[Ft] === 1 && (Rt = V.indexOf(dt[Ft])) >= 0 && (dt[Ft] = V[Rt + 1]);
      }(Me, De, St), Ge(2, Me, _e, De, St), Ge(1, Me, _e, De, St), Me.join("");
    };
    return this.__bidiEngine__.doBidiReorder = function(pe, _e, De) {
      if (function(St, dt) {
        if (dt) for (var Pt = 0; Pt < St.length; Pt++) dt[Pt] = Pt;
        a === void 0 && (a = fe(St)), y === void 0 && (y = fe(St));
      }(pe, _e), c || !g || y)
        if (c && g && a ^ y) de = a ? 1 : 0, pe = Te(pe, _e, De);
        else if (!c && g && y) de = a ? 1 : 0, pe = ke(pe, _e, De), pe = Te(pe, _e);
        else if (!c || a || g || y) {
          if (c && !g && a ^ y) pe = Te(pe, _e), a ? (de = 0, pe = ke(pe, _e, De)) : (de = 1, pe = ke(pe, _e, De), pe = Te(pe, _e));
          else if (c && a && !g && y) de = 1, pe = ke(pe, _e, De), pe = Te(pe, _e);
          else if (!c && !g && a ^ y) {
            var Me = A;
            a ? (de = 1, pe = ke(pe, _e, De), de = 0, A = !1, pe = ke(pe, _e, De), A = Me) : (de = 0, pe = ke(pe, _e, De), pe = Te(pe, _e), de = 1, A = !1, pe = ke(pe, _e, De), A = Me, pe = Te(pe, _e));
          }
        } else de = 0, pe = ke(pe, _e, De);
      else de = a ? 1 : 0, pe = ke(pe, _e, De);
      return pe;
    }, this.__bidiEngine__.setOptions = function(pe) {
      pe && (c = pe.isInputVisual, g = pe.isOutputVisual, a = pe.isInputRtl, y = pe.isOutputRtl, A = pe.isSymmetricSwapping);
    }, this.__bidiEngine__.setOptions(i), this.__bidiEngine__;
  };
  var e = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], t = new n.__bidiEngine__({ isInputVisual: !0 });
  n.API.events.push(["postProcessText", function(i) {
    var r = i.text, l = (i.x, i.y, i.options || {}), c = (i.mutex, l.lang, []);
    if (l.isInputVisual = typeof l.isInputVisual != "boolean" || l.isInputVisual, t.setOptions(l), Object.prototype.toString.call(r) === "[object Array]") {
      var a = 0;
      for (c = [], a = 0; a < r.length; a += 1) Object.prototype.toString.call(r[a]) === "[object Array]" ? c.push([t.doBidiReorder(r[a][0]), r[a][1], r[a][2]]) : c.push([t.doBidiReorder(r[a])]);
      i.text = c;
    } else i.text = t.doBidiReorder(r);
    t.setOptions({ isInputVisual: !0 });
  }]);
}(ti), ti.API.TTFFont = function() {
  function n(e) {
    var t;
    if (this.rawData = e, t = this.contents = new yh(e), this.contents.pos = 4, t.readString(4) === "ttcf") throw new Error("TTCF not supported.");
    t.pos = 0, this.parse(), this.subset = new yq(this), this.registerTTF();
  }
  return n.open = function(e) {
    return new n(e);
  }, n.prototype.parse = function() {
    return this.directory = new rq(this.contents), this.head = new oq(this), this.name = new hq(this), this.cmap = new E3(this), this.toUnicode = {}, this.hhea = new aq(this), this.maxp = new dq(this), this.hmtx = new fq(this), this.post = new cq(this), this.os2 = new lq(this), this.loca = new _q(this), this.glyf = new pq(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
  }, n.prototype.registerTTF = function() {
    var e, t, i, r, l;
    if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
      var c, a, g, y;
      for (y = [], c = 0, a = (g = this.bbox).length; c < a; c++) e = g[c], y.push(Math.round(e * this.scaleFactor));
      return y;
    }).call(this), this.stemV = 0, this.post.exists ? (i = 255 & (r = this.post.italic_angle), 32768 & (t = r >> 16) && (t = -(1 + (65535 ^ t))), this.italicAngle = +(t + "." + i)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (l = this.familyClass) === 1 || l === 2 || l === 3 || l === 4 || l === 5 || l === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
  }, n.prototype.characterToGlyph = function(e) {
    var t;
    return ((t = this.cmap.unicode) != null ? t.codeMap[e] : void 0) || 0;
  }, n.prototype.widthOfGlyph = function(e) {
    var t;
    return t = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(e).advance * t;
  }, n.prototype.widthOfString = function(e, t, i) {
    var r, l, c, a;
    for (c = 0, l = 0, a = (e = "" + e).length; 0 <= a ? l < a : l > a; l = 0 <= a ? ++l : --l) r = e.charCodeAt(l), c += this.widthOfGlyph(this.characterToGlyph(r)) + i * (1e3 / t) || 0;
    return c * (t / 1e3);
  }, n.prototype.lineHeight = function(e, t) {
    var i;
    return t == null && (t = !1), i = t ? this.lineGap : 0, (this.ascender + i - this.decender) / 1e3 * e;
  }, n;
}();
var Ac, yh = function() {
  function n(e) {
    this.data = e ?? [], this.pos = 0, this.length = this.data.length;
  }
  return n.prototype.readByte = function() {
    return this.data[this.pos++];
  }, n.prototype.writeByte = function(e) {
    return this.data[this.pos++] = e;
  }, n.prototype.readUInt32 = function() {
    return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
  }, n.prototype.writeUInt32 = function(e) {
    return this.writeByte(e >>> 24 & 255), this.writeByte(e >> 16 & 255), this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, n.prototype.readInt32 = function() {
    var e;
    return (e = this.readUInt32()) >= 2147483648 ? e - 4294967296 : e;
  }, n.prototype.writeInt32 = function(e) {
    return e < 0 && (e += 4294967296), this.writeUInt32(e);
  }, n.prototype.readUInt16 = function() {
    return this.readByte() << 8 | this.readByte();
  }, n.prototype.writeUInt16 = function(e) {
    return this.writeByte(e >> 8 & 255), this.writeByte(255 & e);
  }, n.prototype.readInt16 = function() {
    var e;
    return (e = this.readUInt16()) >= 32768 ? e - 65536 : e;
  }, n.prototype.writeInt16 = function(e) {
    return e < 0 && (e += 65536), this.writeUInt16(e);
  }, n.prototype.readString = function(e) {
    var t, i;
    for (i = [], t = 0; 0 <= e ? t < e : t > e; t = 0 <= e ? ++t : --t) i[t] = String.fromCharCode(this.readByte());
    return i.join("");
  }, n.prototype.writeString = function(e) {
    var t, i, r;
    for (r = [], t = 0, i = e.length; 0 <= i ? t < i : t > i; t = 0 <= i ? ++t : --t) r.push(this.writeByte(e.charCodeAt(t)));
    return r;
  }, n.prototype.readShort = function() {
    return this.readInt16();
  }, n.prototype.writeShort = function(e) {
    return this.writeInt16(e);
  }, n.prototype.readLongLong = function() {
    var e, t, i, r, l, c, a, g;
    return e = this.readByte(), t = this.readByte(), i = this.readByte(), r = this.readByte(), l = this.readByte(), c = this.readByte(), a = this.readByte(), g = this.readByte(), 128 & e ? -1 * (72057594037927940 * (255 ^ e) + 281474976710656 * (255 ^ t) + 1099511627776 * (255 ^ i) + 4294967296 * (255 ^ r) + 16777216 * (255 ^ l) + 65536 * (255 ^ c) + 256 * (255 ^ a) + (255 ^ g) + 1) : 72057594037927940 * e + 281474976710656 * t + 1099511627776 * i + 4294967296 * r + 16777216 * l + 65536 * c + 256 * a + g;
  }, n.prototype.writeLongLong = function(e) {
    var t, i;
    return t = Math.floor(e / 4294967296), i = 4294967295 & e, this.writeByte(t >> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t), this.writeByte(i >> 24 & 255), this.writeByte(i >> 16 & 255), this.writeByte(i >> 8 & 255), this.writeByte(255 & i);
  }, n.prototype.readInt = function() {
    return this.readInt32();
  }, n.prototype.writeInt = function(e) {
    return this.writeInt32(e);
  }, n.prototype.read = function(e) {
    var t, i;
    for (t = [], i = 0; 0 <= e ? i < e : i > e; i = 0 <= e ? ++i : --i) t.push(this.readByte());
    return t;
  }, n.prototype.write = function(e) {
    var t, i, r, l;
    for (l = [], i = 0, r = e.length; i < r; i++) t = e[i], l.push(this.writeByte(t));
    return l;
  }, n;
}(), rq = function() {
  var n;
  function e(t) {
    var i, r, l;
    for (this.scalarType = t.readInt(), this.tableCount = t.readShort(), this.searchRange = t.readShort(), this.entrySelector = t.readShort(), this.rangeShift = t.readShort(), this.tables = {}, r = 0, l = this.tableCount; 0 <= l ? r < l : r > l; r = 0 <= l ? ++r : --r) i = { tag: t.readString(4), checksum: t.readInt(), offset: t.readInt(), length: t.readInt() }, this.tables[i.tag] = i;
  }
  return e.prototype.encode = function(t) {
    var i, r, l, c, a, g, y, A, C, I, S, F, U;
    for (U in S = Object.keys(t).length, g = Math.log(2), C = 16 * Math.floor(Math.log(S) / g), c = Math.floor(C / g), A = 16 * S - C, (r = new yh()).writeInt(this.scalarType), r.writeShort(S), r.writeShort(C), r.writeShort(c), r.writeShort(A), l = 16 * S, y = r.pos + l, a = null, F = [], t) for (I = t[U], r.writeString(U), r.writeInt(n(I)), r.writeInt(y), r.writeInt(I.length), F = F.concat(I), U === "head" && (a = y), y += I.length; y % 4; ) F.push(0), y++;
    return r.write(F), i = 2981146554 - n(r.data), r.pos = a + 8, r.writeUInt32(i), r.data;
  }, n = function(t) {
    var i, r, l, c;
    for (t = S3.call(t); t.length % 4; ) t.push(0);
    for (l = new yh(t), r = 0, i = 0, c = t.length; i < c; i = i += 4) r += l.readUInt32();
    return 4294967295 & r;
  }, e;
}(), sq = {}.hasOwnProperty, iu = function(n, e) {
  for (var t in e) sq.call(e, t) && (n[t] = e[t]);
  function i() {
    this.constructor = n;
  }
  return i.prototype = e.prototype, n.prototype = new i(), n.__super__ = e.prototype, n;
};
Ac = function() {
  function n(e) {
    var t;
    this.file = e, t = this.file.directory.tables[this.tag], this.exists = !!t, t && (this.offset = t.offset, this.length = t.length, this.parse(this.file.contents));
  }
  return n.prototype.parse = function() {
  }, n.prototype.encode = function() {
  }, n.prototype.raw = function() {
    return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
  }, n;
}();
var oq = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return iu(e, Ac), e.prototype.tag = "head", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.revision = t.readInt(), this.checkSumAdjustment = t.readInt(), this.magicNumber = t.readInt(), this.flags = t.readShort(), this.unitsPerEm = t.readShort(), this.created = t.readLongLong(), this.modified = t.readLongLong(), this.xMin = t.readShort(), this.yMin = t.readShort(), this.xMax = t.readShort(), this.yMax = t.readShort(), this.macStyle = t.readShort(), this.lowestRecPPEM = t.readShort(), this.fontDirectionHint = t.readShort(), this.indexToLocFormat = t.readShort(), this.glyphDataFormat = t.readShort();
  }, e.prototype.encode = function(t) {
    var i;
    return (i = new yh()).writeInt(this.version), i.writeInt(this.revision), i.writeInt(this.checkSumAdjustment), i.writeInt(this.magicNumber), i.writeShort(this.flags), i.writeShort(this.unitsPerEm), i.writeLongLong(this.created), i.writeLongLong(this.modified), i.writeShort(this.xMin), i.writeShort(this.yMin), i.writeShort(this.xMax), i.writeShort(this.yMax), i.writeShort(this.macStyle), i.writeShort(this.lowestRecPPEM), i.writeShort(this.fontDirectionHint), i.writeShort(t), i.writeShort(this.glyphDataFormat), i.data;
  }, e;
}(), O5 = function() {
  function n(e, t) {
    var i, r, l, c, a, g, y, A, C, I, S, F, U, V, W, X, de;
    switch (this.platformID = e.readUInt16(), this.encodingID = e.readShort(), this.offset = t + e.readInt(), C = e.pos, e.pos = this.offset, this.format = e.readUInt16(), this.length = e.readUInt16(), this.language = e.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) {
      case 0:
        for (g = 0; g < 256; ++g) this.codeMap[g] = e.readByte();
        break;
      case 4:
        for (S = e.readUInt16(), I = S / 2, e.pos += 6, l = function() {
          var ie, fe;
          for (fe = [], g = ie = 0; 0 <= I ? ie < I : ie > I; g = 0 <= I ? ++ie : --ie) fe.push(e.readUInt16());
          return fe;
        }(), e.pos += 2, U = function() {
          var ie, fe;
          for (fe = [], g = ie = 0; 0 <= I ? ie < I : ie > I; g = 0 <= I ? ++ie : --ie) fe.push(e.readUInt16());
          return fe;
        }(), y = function() {
          var ie, fe;
          for (fe = [], g = ie = 0; 0 <= I ? ie < I : ie > I; g = 0 <= I ? ++ie : --ie) fe.push(e.readUInt16());
          return fe;
        }(), A = function() {
          var ie, fe;
          for (fe = [], g = ie = 0; 0 <= I ? ie < I : ie > I; g = 0 <= I ? ++ie : --ie) fe.push(e.readUInt16());
          return fe;
        }(), r = (this.length - e.pos + this.offset) / 2, a = function() {
          var ie, fe;
          for (fe = [], g = ie = 0; 0 <= r ? ie < r : ie > r; g = 0 <= r ? ++ie : --ie) fe.push(e.readUInt16());
          return fe;
        }(), g = W = 0, de = l.length; W < de; g = ++W) for (V = l[g], i = X = F = U[g]; F <= V ? X <= V : X >= V; i = F <= V ? ++X : --X) A[g] === 0 ? c = i + y[g] : (c = a[A[g] / 2 + (i - F) - (I - g)] || 0) !== 0 && (c += y[g]), this.codeMap[i] = 65535 & c;
    }
    e.pos = C;
  }
  return n.encode = function(e, t) {
    var i, r, l, c, a, g, y, A, C, I, S, F, U, V, W, X, de, ie, fe, Ae, Te, me, Ge, ke, pe, _e, De, Me, St, dt, Pt, gt, Rt, Ft, mn, oe, Re, ze, Xe, ot, rt, xt, ht, $t, Wt, on;
    switch (Me = new yh(), c = Object.keys(e).sort(function(hn, wn) {
      return hn - wn;
    }), t) {
      case "macroman":
        for (U = 0, V = function() {
          var hn = [];
          for (F = 0; F < 256; ++F) hn.push(0);
          return hn;
        }(), X = { 0: 0 }, l = {}, St = 0, Rt = c.length; St < Rt; St++) X[ht = e[r = c[St]]] == null && (X[ht] = ++U), l[r] = { old: e[r], new: X[e[r]] }, V[r] = X[e[r]];
        return Me.writeUInt16(1), Me.writeUInt16(0), Me.writeUInt32(12), Me.writeUInt16(0), Me.writeUInt16(262), Me.writeUInt16(0), Me.write(V), { charMap: l, subtable: Me.data, maxGlyphID: U + 1 };
      case "unicode":
        for (_e = [], C = [], de = 0, X = {}, i = {}, W = y = null, dt = 0, Ft = c.length; dt < Ft; dt++) X[fe = e[r = c[dt]]] == null && (X[fe] = ++de), i[r] = { old: fe, new: X[fe] }, a = X[fe] - r, W != null && a === y || (W && C.push(W), _e.push(r), y = a), W = r;
        for (W && C.push(W), C.push(65535), _e.push(65535), ke = 2 * (Ge = _e.length), me = 2 * Math.pow(Math.log(Ge) / Math.LN2, 2), I = Math.log(me / 2) / Math.LN2, Te = 2 * Ge - me, g = [], Ae = [], S = [], F = Pt = 0, mn = _e.length; Pt < mn; F = ++Pt) {
          if (pe = _e[F], A = C[F], pe === 65535) {
            g.push(0), Ae.push(0);
            break;
          }
          if (pe - (De = i[pe].new) >= 32768) for (g.push(0), Ae.push(2 * (S.length + Ge - F)), r = gt = pe; pe <= A ? gt <= A : gt >= A; r = pe <= A ? ++gt : --gt) S.push(i[r].new);
          else g.push(De - pe), Ae.push(0);
        }
        for (Me.writeUInt16(3), Me.writeUInt16(1), Me.writeUInt32(12), Me.writeUInt16(4), Me.writeUInt16(16 + 8 * Ge + 2 * S.length), Me.writeUInt16(0), Me.writeUInt16(ke), Me.writeUInt16(me), Me.writeUInt16(I), Me.writeUInt16(Te), rt = 0, oe = C.length; rt < oe; rt++) r = C[rt], Me.writeUInt16(r);
        for (Me.writeUInt16(0), xt = 0, Re = _e.length; xt < Re; xt++) r = _e[xt], Me.writeUInt16(r);
        for ($t = 0, ze = g.length; $t < ze; $t++) a = g[$t], Me.writeUInt16(a);
        for (Wt = 0, Xe = Ae.length; Wt < Xe; Wt++) ie = Ae[Wt], Me.writeUInt16(ie);
        for (on = 0, ot = S.length; on < ot; on++) U = S[on], Me.writeUInt16(U);
        return { charMap: i, subtable: Me.data, maxGlyphID: de + 1 };
    }
  }, n;
}(), E3 = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return iu(e, Ac), e.prototype.tag = "cmap", e.prototype.parse = function(t) {
    var i, r, l;
    for (t.pos = this.offset, this.version = t.readUInt16(), l = t.readUInt16(), this.tables = [], this.unicode = null, r = 0; 0 <= l ? r < l : r > l; r = 0 <= l ? ++r : --r) i = new O5(t, this.offset), this.tables.push(i), i.isUnicode && this.unicode == null && (this.unicode = i);
    return !0;
  }, e.encode = function(t, i) {
    var r, l;
    return i == null && (i = "macroman"), r = O5.encode(t, i), (l = new yh()).writeUInt16(0), l.writeUInt16(1), r.table = l.data.concat(r.subtable), r;
  }, e;
}(), aq = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return iu(e, Ac), e.prototype.tag = "hhea", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.ascender = t.readShort(), this.decender = t.readShort(), this.lineGap = t.readShort(), this.advanceWidthMax = t.readShort(), this.minLeftSideBearing = t.readShort(), this.minRightSideBearing = t.readShort(), this.xMaxExtent = t.readShort(), this.caretSlopeRise = t.readShort(), this.caretSlopeRun = t.readShort(), this.caretOffset = t.readShort(), t.pos += 8, this.metricDataFormat = t.readShort(), this.numberOfMetrics = t.readUInt16();
  }, e;
}(), lq = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return iu(e, Ac), e.prototype.tag = "OS/2", e.prototype.parse = function(t) {
    if (t.pos = this.offset, this.version = t.readUInt16(), this.averageCharWidth = t.readShort(), this.weightClass = t.readUInt16(), this.widthClass = t.readUInt16(), this.type = t.readShort(), this.ySubscriptXSize = t.readShort(), this.ySubscriptYSize = t.readShort(), this.ySubscriptXOffset = t.readShort(), this.ySubscriptYOffset = t.readShort(), this.ySuperscriptXSize = t.readShort(), this.ySuperscriptYSize = t.readShort(), this.ySuperscriptXOffset = t.readShort(), this.ySuperscriptYOffset = t.readShort(), this.yStrikeoutSize = t.readShort(), this.yStrikeoutPosition = t.readShort(), this.familyClass = t.readShort(), this.panose = function() {
      var i, r;
      for (r = [], i = 0; i < 10; ++i) r.push(t.readByte());
      return r;
    }(), this.charRange = function() {
      var i, r;
      for (r = [], i = 0; i < 4; ++i) r.push(t.readInt());
      return r;
    }(), this.vendorID = t.readString(4), this.selection = t.readShort(), this.firstCharIndex = t.readShort(), this.lastCharIndex = t.readShort(), this.version > 0 && (this.ascent = t.readShort(), this.descent = t.readShort(), this.lineGap = t.readShort(), this.winAscent = t.readShort(), this.winDescent = t.readShort(), this.codePageRange = function() {
      var i, r;
      for (r = [], i = 0; i < 2; i = ++i) r.push(t.readInt());
      return r;
    }(), this.version > 1)) return this.xHeight = t.readShort(), this.capHeight = t.readShort(), this.defaultChar = t.readShort(), this.breakChar = t.readShort(), this.maxContext = t.readShort();
  }, e;
}(), cq = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return iu(e, Ac), e.prototype.tag = "post", e.prototype.parse = function(t) {
    var i, r, l;
    switch (t.pos = this.offset, this.format = t.readInt(), this.italicAngle = t.readInt(), this.underlinePosition = t.readShort(), this.underlineThickness = t.readShort(), this.isFixedPitch = t.readInt(), this.minMemType42 = t.readInt(), this.maxMemType42 = t.readInt(), this.minMemType1 = t.readInt(), this.maxMemType1 = t.readInt(), this.format) {
      case 65536:
        break;
      case 131072:
        var c;
        for (r = t.readUInt16(), this.glyphNameIndex = [], c = 0; 0 <= r ? c < r : c > r; c = 0 <= r ? ++c : --c) this.glyphNameIndex.push(t.readUInt16());
        for (this.names = [], l = []; t.pos < this.offset + this.length; ) i = t.readByte(), l.push(this.names.push(t.readString(i)));
        return l;
      case 151552:
        return r = t.readUInt16(), this.offsets = t.read(r);
      case 196608:
        break;
      case 262144:
        return this.map = (function() {
          var a, g, y;
          for (y = [], c = a = 0, g = this.file.maxp.numGlyphs; 0 <= g ? a < g : a > g; c = 0 <= g ? ++a : --a) y.push(t.readUInt32());
          return y;
        }).call(this);
    }
  }, e;
}(), uq = function(n, e) {
  this.raw = n, this.length = n.length, this.platformID = e.platformID, this.encodingID = e.encodingID, this.languageID = e.languageID;
}, hq = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return iu(e, Ac), e.prototype.tag = "name", e.prototype.parse = function(t) {
    var i, r, l, c, a, g, y, A, C, I, S;
    for (t.pos = this.offset, t.readShort(), i = t.readShort(), g = t.readShort(), r = [], c = 0; 0 <= i ? c < i : c > i; c = 0 <= i ? ++c : --c) r.push({ platformID: t.readShort(), encodingID: t.readShort(), languageID: t.readShort(), nameID: t.readShort(), length: t.readShort(), offset: this.offset + g + t.readShort() });
    for (y = {}, c = C = 0, I = r.length; C < I; c = ++C) l = r[c], t.pos = l.offset, A = t.readString(l.length), a = new uq(A, l), y[S = l.nameID] == null && (y[S] = []), y[l.nameID].push(a);
    this.strings = y, this.copyright = y[0], this.fontFamily = y[1], this.fontSubfamily = y[2], this.uniqueSubfamily = y[3], this.fontName = y[4], this.version = y[5];
    try {
      this.postscriptName = y[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    } catch {
      this.postscriptName = y[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
    }
    return this.trademark = y[7], this.manufacturer = y[8], this.designer = y[9], this.description = y[10], this.vendorUrl = y[11], this.designerUrl = y[12], this.license = y[13], this.licenseUrl = y[14], this.preferredFamily = y[15], this.preferredSubfamily = y[17], this.compatibleFull = y[18], this.sampleText = y[19];
  }, e;
}(), dq = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return iu(e, Ac), e.prototype.tag = "maxp", e.prototype.parse = function(t) {
    return t.pos = this.offset, this.version = t.readInt(), this.numGlyphs = t.readUInt16(), this.maxPoints = t.readUInt16(), this.maxContours = t.readUInt16(), this.maxCompositePoints = t.readUInt16(), this.maxComponentContours = t.readUInt16(), this.maxZones = t.readUInt16(), this.maxTwilightPoints = t.readUInt16(), this.maxStorage = t.readUInt16(), this.maxFunctionDefs = t.readUInt16(), this.maxInstructionDefs = t.readUInt16(), this.maxStackElements = t.readUInt16(), this.maxSizeOfInstructions = t.readUInt16(), this.maxComponentElements = t.readUInt16(), this.maxComponentDepth = t.readUInt16();
  }, e;
}(), fq = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return iu(e, Ac), e.prototype.tag = "hmtx", e.prototype.parse = function(t) {
    var i, r, l, c, a, g, y;
    for (t.pos = this.offset, this.metrics = [], i = 0, g = this.file.hhea.numberOfMetrics; 0 <= g ? i < g : i > g; i = 0 <= g ? ++i : --i) this.metrics.push({ advance: t.readUInt16(), lsb: t.readInt16() });
    for (l = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function() {
      var A, C;
      for (C = [], i = A = 0; 0 <= l ? A < l : A > l; i = 0 <= l ? ++A : --A) C.push(t.readInt16());
      return C;
    }(), this.widths = (function() {
      var A, C, I, S;
      for (S = [], A = 0, C = (I = this.metrics).length; A < C; A++) c = I[A], S.push(c.advance);
      return S;
    }).call(this), r = this.widths[this.widths.length - 1], y = [], i = a = 0; 0 <= l ? a < l : a > l; i = 0 <= l ? ++a : --a) y.push(this.widths.push(r));
    return y;
  }, e.prototype.forGlyph = function(t) {
    return t in this.metrics ? this.metrics[t] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t - this.metrics.length] };
  }, e;
}(), S3 = [].slice, pq = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return iu(e, Ac), e.prototype.tag = "glyf", e.prototype.parse = function() {
    return this.cache = {};
  }, e.prototype.glyphFor = function(t) {
    var i, r, l, c, a, g, y, A, C, I;
    return t in this.cache ? this.cache[t] : (c = this.file.loca, i = this.file.contents, r = c.indexOf(t), (l = c.lengthOf(t)) === 0 ? this.cache[t] = null : (i.pos = this.offset + r, a = (g = new yh(i.read(l))).readShort(), A = g.readShort(), I = g.readShort(), y = g.readShort(), C = g.readShort(), this.cache[t] = a === -1 ? new mq(g, A, I, y, C) : new gq(g, a, A, I, y, C), this.cache[t]));
  }, e.prototype.encode = function(t, i, r) {
    var l, c, a, g, y;
    for (a = [], c = [], g = 0, y = i.length; g < y; g++) l = t[i[g]], c.push(a.length), l && (a = a.concat(l.encode(r)));
    return c.push(a.length), { table: a, offsets: c };
  }, e;
}(), gq = function() {
  function n(e, t, i, r, l, c) {
    this.raw = e, this.numberOfContours = t, this.xMin = i, this.yMin = r, this.xMax = l, this.yMax = c, this.compound = !1;
  }
  return n.prototype.encode = function() {
    return this.raw.data;
  }, n;
}(), mq = function() {
  function n(e, t, i, r, l) {
    var c, a;
    for (this.raw = e, this.xMin = t, this.yMin = i, this.xMax = r, this.yMax = l, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], c = this.raw; a = c.readShort(), this.glyphOffsets.push(c.pos), this.glyphIDs.push(c.readUInt16()), 32 & a; ) c.pos += 1 & a ? 4 : 2, 128 & a ? c.pos += 8 : 64 & a ? c.pos += 4 : 8 & a && (c.pos += 2);
  }
  return n.prototype.encode = function() {
    var e, t, i;
    for (t = new yh(S3.call(this.raw.data)), e = 0, i = this.glyphIDs.length; e < i; ++e) t.pos = this.glyphOffsets[e];
    return t.data;
  }, n;
}(), _q = function(n) {
  function e() {
    return e.__super__.constructor.apply(this, arguments);
  }
  return iu(e, Ac), e.prototype.tag = "loca", e.prototype.parse = function(t) {
    var i, r;
    return t.pos = this.offset, i = this.file.head.indexToLocFormat, this.offsets = i === 0 ? (function() {
      var l, c;
      for (c = [], r = 0, l = this.length; r < l; r += 2) c.push(2 * t.readUInt16());
      return c;
    }).call(this) : (function() {
      var l, c;
      for (c = [], r = 0, l = this.length; r < l; r += 4) c.push(t.readUInt32());
      return c;
    }).call(this);
  }, e.prototype.indexOf = function(t) {
    return this.offsets[t];
  }, e.prototype.lengthOf = function(t) {
    return this.offsets[t + 1] - this.offsets[t];
  }, e.prototype.encode = function(t, i) {
    for (var r = new Uint32Array(this.offsets.length), l = 0, c = 0, a = 0; a < r.length; ++a) if (r[a] = l, c < i.length && i[c] == a) {
      ++c, r[a] = l;
      var g = this.offsets[a], y = this.offsets[a + 1] - g;
      y > 0 && (l += y);
    }
    for (var A = new Array(4 * r.length), C = 0; C < r.length; ++C) A[4 * C + 3] = 255 & r[C], A[4 * C + 2] = (65280 & r[C]) >> 8, A[4 * C + 1] = (16711680 & r[C]) >> 16, A[4 * C] = (4278190080 & r[C]) >> 24;
    return A;
  }, e;
}(), yq = function() {
  function n(e) {
    this.font = e, this.subset = {}, this.unicodes = {}, this.next = 33;
  }
  return n.prototype.generateCmap = function() {
    var e, t, i, r, l;
    for (t in r = this.font.cmap.tables[0].codeMap, e = {}, l = this.subset) i = l[t], e[t] = r[i];
    return e;
  }, n.prototype.glyphsFor = function(e) {
    var t, i, r, l, c, a, g;
    for (r = {}, c = 0, a = e.length; c < a; c++) r[l = e[c]] = this.font.glyf.glyphFor(l);
    for (l in t = [], r) (i = r[l]) != null && i.compound && t.push.apply(t, i.glyphIDs);
    if (t.length > 0) for (l in g = this.glyphsFor(t)) i = g[l], r[l] = i;
    return r;
  }, n.prototype.encode = function(e, t) {
    var i, r, l, c, a, g, y, A, C, I, S, F, U, V, W;
    for (r in i = E3.encode(this.generateCmap(), "unicode"), c = this.glyphsFor(e), S = { 0: 0 }, W = i.charMap) S[(g = W[r]).old] = g.new;
    for (F in I = i.maxGlyphID, c) F in S || (S[F] = I++);
    return A = function(X) {
      var de, ie;
      for (de in ie = {}, X) ie[X[de]] = de;
      return ie;
    }(S), C = Object.keys(A).sort(function(X, de) {
      return X - de;
    }), U = function() {
      var X, de, ie;
      for (ie = [], X = 0, de = C.length; X < de; X++) a = C[X], ie.push(A[a]);
      return ie;
    }(), l = this.font.glyf.encode(c, U, S), y = this.font.loca.encode(l.offsets, U), V = { cmap: this.font.cmap.raw(), glyf: l.table, loca: y, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(t) }, this.font.os2.exists && (V["OS/2"] = this.font.os2.raw()), this.font.directory.encode(V);
  }, n;
}();
ti.API.PDFObject = function() {
  var n;
  function e() {
  }
  return n = function(t, i) {
    return (Array(i + 1).join("0") + t).slice(-i);
  }, e.convert = function(t) {
    var i, r, l, c;
    if (Array.isArray(t)) return "[" + function() {
      var a, g, y;
      for (y = [], a = 0, g = t.length; a < g; a++) i = t[a], y.push(e.convert(i));
      return y;
    }().join(" ") + "]";
    if (typeof t == "string") return "/" + t;
    if (t != null && t.isString) return "(" + t + ")";
    if (t instanceof Date) return "(D:" + n(t.getUTCFullYear(), 4) + n(t.getUTCMonth(), 2) + n(t.getUTCDate(), 2) + n(t.getUTCHours(), 2) + n(t.getUTCMinutes(), 2) + n(t.getUTCSeconds(), 2) + "Z)";
    if ({}.toString.call(t) === "[object Object]") {
      for (r in l = ["<<"], t) c = t[r], l.push("/" + r + " " + e.convert(c));
      return l.push(">>"), l.join(`
`);
    }
    return "" + t;
  }, e;
}();
const sv = { "circle-radius": 8, "circle-color": "red", "circle-stroke-width": 1, "circle-stroke-color": "black" }, qm = { style: { textSize: 16, textHaloColor: "#FFFFFF", textHaloWidth: 0.8, textColor: "#000000", fallbackTextFont: ["Open Sans Regular"] }, visibility: "visible", position: "bottom-right" }, Hm = { image: '<svg width="800px" height="800px" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--gis" preserveAspectRatio="xMidYMid meet"><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="none" stroke="white" stroke-width="1.5"/><path d="M47.655 1.634l-35 95c-.828 2.24 1.659 4.255 3.68 2.98l33.667-21.228l33.666 21.228c2.02 1.271 4.503-.74 3.678-2.98l-35-95C51.907.514 51.163.006 50 .008c-1.163.001-1.99.65-2.345 1.626zm-.155 14.88v57.54L19.89 91.461z" fill="#000000" fill-rule="evenodd"></path></svg>', imageName: "gl-export-north-icon", imageSizeFraction: 0.05, visibility: "visible", position: "top-right" };
class bq {
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. default is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : qh.A4, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Eu.PNG, l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : pf.mm, c = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "map", a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : "maplibregl-marker", g = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : sv, y = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : "maplibregl-ctrl-attrib-inner", A = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : qm, C = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : Hm;
    qi(this, "map"), qi(this, "width"), qi(this, "height"), qi(this, "dpi"), qi(this, "format"), qi(this, "unit"), qi(this, "fileName"), qi(this, "markerClassName"), qi(this, "markerCirclePaint"), qi(this, "attributionClassName"), qi(this, "attributionOptions"), qi(this, "northIconOptions"), this.map = e, this.width = t[0], this.height = t[1], this.dpi = i, this.format = r, this.unit = l, this.fileName = c, this.markerClassName = a, this.markerCirclePaint = g, this.attributionClassName = y, this.attributionOptions = A, this.northIconOptions = C;
  }
  renderMapPost(e) {
    return e;
  }
  getMarkers() {
    return this.map.getCanvasContainer().getElementsByClassName(this.markerClassName);
  }
  renderMarkers(e) {
    const t = this.getMarkers();
    for (let i = 0; i < t.length; i++) {
      const r = t.item(i);
      if (!r) continue;
      const l = r.getAttribute("style");
      if (!l) continue;
      const c = /translate\(([^,]+)px,\s*([^,]+)px\)/, a = l.match(c);
      if (!a) continue;
      const g = parseInt(a[1]), y = parseInt(a[2]), A = this.map.unproject([g, y]), C = `point${i}`;
      e.addSource(C, { type: "geojson", data: { type: "Point", coordinates: [A.lng, A.lat] } }), e.addLayer({ id: C, source: C, type: "circle", paint: this.markerCirclePaint });
    }
    return e;
  }
  /**
  * Generate and download Map image
  */
  generate() {
    const e = this;
    this.addLoader(), this.showLoader();
    const t = window.devicePixelRatio;
    Object.defineProperty(window, "devicePixelRatio", { get() {
      return e.dpi / 96;
    } });
    const i = document.createElement("div");
    i.className = "hidden-map", document.body.appendChild(i);
    const r = document.createElement("div");
    r.style.width = this.toPixels(this.width), r.style.height = this.toPixels(this.height), i.appendChild(r);
    const l = this.map.getStyle();
    if (l && l.sources) {
      const a = l.sources;
      Object.keys(a).forEach((g) => {
        const y = a[g];
        Object.keys(y).forEach((A) => {
          y[A] || delete y[A];
        });
      });
    }
    let c = this.getRenderedMap(r, l);
    c.on("load", () => {
      this.addNorthIconToMap(c).then(() => {
        c.once("idle", () => {
          this.addAttributions(c) ? c.once("idle", () => {
            c = this.renderMapPost(c), this.getMarkers().length === 0 ? this.exportImage(c, i, t) : (c = this.renderMarkers(c), c.once("idle", () => {
              this.exportImage(c, i, t);
            }));
          }) : (c = this.renderMapPost(c), this.getMarkers().length === 0 ? this.exportImage(c, i, t) : (c = this.renderMarkers(c), c.once("idle", () => {
            this.exportImage(c, i, t);
          })));
        });
      });
    });
  }
  stripHtml(e) {
    const t = document.createElement("div");
    return t.innerHTML = e, t.textContent || t.innerText || "";
  }
  /**
  * Get icon width against exported map size by using fraction rate
  * @param renderMap Map object
  * @param fraction adjust icon size by using this fraction rate. Default is 8%
  * @returns Icon width calculated
  */
  getIconWidth(e, t) {
    const i = e.getContainer(), r = parseInt(i.style.width.replace("px", ""));
    return parseInt(`${r * t}`);
  }
  /**
  * Get element position's pixel values based on selected position setting
  * @param renderMap Map object
  * @param position Position of element inserted
  * @param offset Offset value to adjust position
  * @returns Pixels [width, height]
  */
  getElementPosition(e, t) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const r = e.getContainer();
    let l = 0, c = 0;
    switch (t) {
      case "top-left":
        l = 0 + i, c = 0 + i;
        break;
      case "top-right":
        l = parseInt(r.style.width.replace("px", "")) - i, c = 0 + i;
        break;
      case "bottom-left":
        l = 0 + i, c = parseInt(r.style.height.replace("px", "")) - i;
        break;
      case "bottom-right":
        l = parseInt(r.style.width.replace("px", "")) - i, c = parseInt(r.style.height.replace("px", "")) - i;
        break;
    }
    return [l, c];
  }
  /**
  * Add North Icon SVG to map object
  * @param renderMap Map object
  * @returns void
  */
  addNorthIconImage(e) {
    const t = this.getIconWidth(e, this.northIconOptions.imageSizeFraction ?? 0.08);
    return new Promise((i) => {
      const r = new Image(t, t);
      r.onload = () => {
        this.northIconOptions.imageName && e.addImage(this.northIconOptions.imageName, r), i();
      };
      function l(c) {
        return "data:image/svg+xml;charset=utf-8," + encodeURIComponent(c);
      }
      this.northIconOptions.image && (r.src = l(this.northIconOptions.image));
    });
  }
  /**
  * Add North Icon Symbol layer to renderMap object
  * @param renderMap Map object
  * @returns
  */
  addNorthIconToMap(e) {
    let t = this.northIconOptions.visibility ?? "visible";
    return e.getZoom() < 2 && this.width > this.height && (t = "none"), new Promise((i) => {
      this.addNorthIconImage(e).then(() => {
        const r = this.getIconWidth(e, this.northIconOptions.imageSizeFraction ?? 0.08) * 0.8, l = this.getElementPosition(e, this.northIconOptions.position ?? "top-right", r), c = e.unproject(l), a = this.northIconOptions.imageName ?? "gl-export-north-icon";
        e.addSource(a, { type: "geojson", data: { type: "Feature", geometry: { type: "Point", coordinates: [c.lng, c.lat] }, properties: {} } }), e.addLayer({ id: a, source: a, type: "symbol", layout: { "icon-image": a, "icon-size": 1, "icon-rotate": e.getBearing() * -1, "icon-allow-overlap": !0, "icon-ignore-placement": !0, visibility: t }, paint: {} }), i();
      });
    });
  }
  addAttributions(e) {
    var t;
    if (!this.map.getStyle().glyphs) return !1;
    const i = e.getContainer(), r = this.attributionOptions.position ?? "bottom-right", l = this.getElementPosition(e, r, 5), c = l[0], a = e.unproject(l), g = i.getElementsByClassName(this.attributionClassName), y = [];
    if ((g == null ? void 0 : g.length) > 0) {
      const V = g.item(0);
      if (V) for (let W = 0; W < V.children.length; W++) {
        const X = V.children.item(W);
        X && y.push(this.stripHtml(X.outerHTML));
      }
    } else {
      const V = this.map.getStyle().sources;
      Object.keys(V).forEach((W) => {
        const X = V[W];
        if ("attribution" in X) {
          const de = X.attribution;
          y.push(this.stripHtml(de));
        }
      });
    }
    if (y.length === 0) return !1;
    const A = y.join(" | "), C = "attribution";
    e.addSource(C, { type: "geojson", data: { type: "Feature", geometry: { type: "Point", coordinates: [a.lng, a.lat] }, properties: { attribution: A } } });
    const I = this.map.getStyle().layers.filter((V) => V.type === "symbol" && V.layout && "text-font" in V.layout), S = I.length > 0 && I[0].layout ? I[0].layout["text-font"] : (t = this.attributionOptions.style) == null ? void 0 : t.fallbackTextFont;
    let F = this.attributionOptions.visibility ?? "visible";
    e.getZoom() < 2 && this.width > this.height && (F = "none");
    const U = this.attributionOptions.style;
    return e.addLayer({ id: C, source: C, type: "symbol", layout: { "text-field": ["get", "attribution"], "text-font": S, "text-max-width": parseInt(`${c / U.textSize}`), "text-anchor": r, "text-justify": ["top-right", "bottom-right"].includes(r) ? "right" : "left", "text-size": U.textSize, "text-allow-overlap": !0, visibility: F }, paint: { "text-halo-color": U.textHaloColor, "text-halo-width": U.textHaloWidth, "text-color": U.textColor } }), !0;
  }
  exportImage(e, t, i) {
    var r;
    const l = e.getCanvas(), c = `${this.fileName}.${this.format}`;
    switch (this.format) {
      case Eu.PNG:
        this.toPNG(l, c);
        break;
      case Eu.JPEG:
        this.toJPEG(l, c);
        break;
      case Eu.PDF:
        this.toPDF(e, c);
        break;
      case Eu.SVG:
        this.toSVG(l, c);
        break;
      default:
        console.error(`Invalid file format: ${this.format}`);
        break;
    }
    e.remove(), (r = t.parentNode) == null || r.removeChild(t), Object.defineProperty(window, "devicePixelRatio", { get() {
      return i;
    } }), t.remove(), this.hideLoader();
  }
  /**
  * Convert canvas to PNG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toPNG(e, t) {
    const i = document.createElement("a");
    i.href = e.toDataURL(), i.download = t, i.click(), i.remove();
  }
  /**
  * Convert canvas to JPEG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toJPEG(e, t) {
    const i = e.toDataURL("image/jpeg", 0.85), r = document.createElement("a");
    r.href = i, r.download = t, r.click(), r.remove();
  }
  /**
  * Convert Map object to PDF
  * @param map Map object
  * @param fileName file name
  */
  toPDF(e, t) {
    const i = e.getCanvas(), r = new ti({ orientation: this.width > this.height ? "l" : "p", unit: this.unit, compress: !0, format: [this.width, this.height] });
    r.addImage(i.toDataURL("image/png"), "png", 0, 0, this.width, this.height, void 0, "FAST");
    const { lng: l, lat: c } = e.getCenter();
    r.setProperties({ title: e.getStyle().name, subject: `center: [${l}, ${c}], zoom: ${e.getZoom()}`, creator: "Mapbox GL Export Plugin", author: "(c)Mapbox, (c)OpenStreetMap" }), r.save(t);
  }
  /**
  * Convert canvas to SVG
  * @param canvas Canvas element
  * @param fileName file name
  */
  toSVG(e, t) {
    const i = e.toDataURL("image/png"), r = Number(this.toPixels(this.width, this.dpi).replace("px", "")), l = Number(this.toPixels(this.height, this.dpi).replace("px", "")), c = `
    <svg xmlns="http://www.w3.org/2000/svg" 
      xmlns:xlink="http://www.w3.org/1999/xlink" 
      version="1.1" 
      width="${r}" 
      height="${l}" 
      viewBox="0 0 ${r} ${l}" 
      xml:space="preserve">
        <image style="stroke: none; stroke-width: 0; stroke-dasharray: none; stroke-linecap: butt; stroke-dashoffset: 0; stroke-linejoin: miter; stroke-miterlimit: 4; fill: rgb(0,0,0); fill-rule: nonzero; opacity: 1;"  
      xlink:href="${i}" width="${r}" height="${l}"></image>
    </svg>`, a = document.createElement("a");
    a.href = `data:application/xml,${encodeURIComponent(c)}`, a.download = t, a.click(), a.remove();
  }
  /**
  * Convert mm/inch to pixel
  * @param length mm/inch length
  * @param conversionFactor DPI value. default is 96.
  */
  toPixels(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 96;
    return this.unit === pf.mm && (t /= 25.4), `${t * e}px`;
  }
  /**
  * Add loader in the parent element of maplibre map.
  */
  addLoader() {
    var e;
    const t = (e = this.map.getCanvas().parentElement) == null ? void 0 : e.parentElement;
    if (!t || t.getElementsByClassName("map-export-loader").length > 0) return;
    const i = document.createElement("span");
    i.classList.add("map-export-loader"), i.classList.add("loader-default"), t.appendChild(i);
  }
  /**
  * Show loader
  */
  showLoader() {
    var e, t;
    const i = (e = this.map.getCanvas().parentElement) == null ? void 0 : e.parentElement;
    if (!i) return;
    const r = i.getElementsByClassName("map-export-loader");
    r && r.length > 0 && ((t = r.item(0)) == null || t.classList.add("is-active"));
  }
  /**
  * Hide loader
  */
  hideLoader() {
    var e, t;
    const i = (e = this.map.getCanvas().parentElement) == null ? void 0 : e.parentElement;
    if (!i) return;
    const r = i.getElementsByClassName("map-export-loader");
    r && r.length > 0 && ((t = r.item(0)) == null || t.classList.remove("is-active"));
  }
}
class vq extends bq {
  /**
  * Constructor
  * @param map MaplibreMap object
  * @param size layout size. default is A4
  * @param dpi dpi value. default is 300
  * @param format image format. default is PNG
  * @param unit length unit. default is mm
  * @param fileName file name. default is 'map'
  */
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : qh.A4, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 300, r = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Eu.PNG, l = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : pf.mm, c = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : "map", a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : sv, g = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : qm, y = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : Hm;
    super(e, t, i, r, l, c, "maplibregl-marker", a, "maplibregl-ctrl-attrib-inner", g, y);
  }
  getRenderedMap(e, t) {
    const i = new cT.Map({
      container: e,
      style: t,
      center: this.map.getCenter(),
      zoom: this.map.getZoom(),
      bearing: this.map.getBearing(),
      pitch: this.map.getPitch(),
      interactive: !1,
      canvasContextAttributes: { preserveDrawingBuffer: !0 },
      fadeDuration: 0,
      // attributionControl: false,
      // hack to read transform request callback function
      // eslint-disable-next-line
      // @ts-ignore
      transformRequest: this.map._requestManager._transformRequestFn
    });
    this.map.getTerrain() && (i.setMaxPitch(85), i.setPitch(this.map.getPitch()));
    const r = (this.map.style.imageManager || {}).images || [];
    return Object.keys(r).forEach((l) => {
      r[l].data && i.addImage(l, r[l].data);
    }), i;
  }
  renderMapPost(e) {
    const t = this.map.getTerrain();
    return t && e.setTerrain({ source: t.source, exaggeration: t.exaggeration }), e;
  }
}
class xq {
  constructor(e) {
    qi(this, "controlContainer"), qi(this, "exportContainer"), qi(this, "crosshair"), qi(this, "printableArea"), qi(this, "map"), qi(this, "exportButton"), qi(this, "options", { PageSize: qh.A4, PageOrientation: pp.Landscape, Format: Eu.PDF, DPI: v1[300], Crosshair: !1, PrintableArea: !1, Local: "en", AllowedSizes: Object.keys(qh), Filename: "map", markerCirclePaint: sv, attributionOptions: qm, northIconOptions: Hm }), qi(this, "MAPLIB_CSS_PREFIX", "maplibregl"), e && (e.attributionOptions = Object.assign(qm, e.attributionOptions), e.northIconOptions = Object.assign(Hm, e.northIconOptions), this.options = Object.assign(this.options, e)), this.onDocumentClick = this.onDocumentClick.bind(this);
  }
  getDefaultPosition() {
    return "top-right";
  }
  getTranslation() {
    const e = this.options.Local ?? "en";
    return xV(e);
  }
  onAdd(e) {
    var t;
    this.map = e, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl`), this.controlContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-group`), this.exportContainer = document.createElement("div"), this.exportContainer.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-list`), this.exportButton = document.createElement("button"), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-ctrl-icon`), this.exportButton.classList.add(`${this.MAPLIB_CSS_PREFIX}-export-control`), this.exportButton.type = "button", this.exportButton.addEventListener("click", () => {
      this.exportButton.style.display = "none", this.exportContainer.style.display = "block", this.toggleCrosshair(!0), this.togglePrintableArea(!0);
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.exportButton), this.controlContainer.appendChild(this.exportContainer);
    const i = document.createElement("TABLE");
    i.className = "print-table";
    const r = {};
    (t = this.options.AllowedSizes) == null || t.forEach((A) => {
      qh[A] && (r[A] = qh[A]);
    });
    const l = this.createSelection(r, this.getTranslation().PageSize, "page-size", this.options.PageSize, (A, C) => JSON.stringify(A[C]));
    i.appendChild(l);
    const c = this.createSelection(pp, this.getTranslation().PageOrientation, "page-orientation", this.options.PageOrientation, (A, C) => A[C]);
    i.appendChild(c);
    const a = this.createSelection(Eu, this.getTranslation().Format, "format-type", this.options.Format, (A, C) => A[C]);
    i.appendChild(a);
    const g = this.createSelection(v1, this.getTranslation().DPI, "dpi-type", this.options.DPI, (A, C) => A[C]);
    i.appendChild(g), this.exportContainer.appendChild(i);
    const y = document.createElement("button");
    return y.type = "button", y.textContent = this.getTranslation().Generate, y.classList.add("generate-button"), y.addEventListener("click", () => {
      const A = document.getElementById("mapbox-gl-export-page-size"), C = document.getElementById("mapbox-gl-export-page-orientation"), I = document.getElementById("mapbox-gl-export-format-type"), S = document.getElementById("mapbox-gl-export-dpi-type"), F = C.value;
      let U = JSON.parse(A.value);
      F === pp.Portrait && (U = U.reverse()), this.generateMap(e, U, Number(S.value), I.value, pf.mm, this.options.Filename);
    }), this.exportContainer.appendChild(y), this.controlContainer;
  }
  generateMap(e, t, i, r, l, c) {
    new vq(e, t, i, r, l, c, this.options.markerCirclePaint, this.options.attributionOptions, this.options.northIconOptions).generate();
  }
  createSelection(e, t, i, r, l) {
    const c = document.createElement("label");
    c.textContent = t;
    const a = document.createElement("select");
    a.setAttribute("id", `mapbox-gl-export-${i}`), a.style.width = "100%", Object.keys(e).forEach((C) => {
      const I = document.createElement("option");
      I.setAttribute("value", l(e, C)), I.appendChild(document.createTextNode(C)), I.setAttribute("name", i), r === e[C] && (I.selected = !0), a.appendChild(I);
    }), a.addEventListener("change", () => {
      this.updatePrintableArea();
    });
    const g = document.createElement("TR"), y = document.createElement("TD"), A = document.createElement("TD");
    return y.appendChild(c), A.appendChild(a), g.appendChild(y), g.appendChild(A), g;
  }
  onRemove() {
    !this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.exportButton || (this.exportButton.removeEventListener("click", this.onDocumentClick), this.controlContainer.parentNode.removeChild(this.controlContainer), document.removeEventListener("click", this.onDocumentClick), this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0), this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0), this.map = void 0);
  }
  onDocumentClick(e) {
    this.controlContainer && !this.controlContainer.contains(e.target) && this.exportContainer && this.exportButton && (this.exportContainer.style.display = "none", this.exportButton.style.display = "block", this.toggleCrosshair(!1), this.togglePrintableArea(!1));
  }
  toggleCrosshair(e) {
    this.options.Crosshair === !0 && (e === !1 ? this.crosshair !== void 0 && (this.crosshair.destroy(), this.crosshair = void 0) : (this.crosshair = new oV(this.map), this.crosshair.create()));
  }
  togglePrintableArea(e) {
    this.options.PrintableArea === !0 && (e === !1 ? this.printableArea !== void 0 && (this.printableArea.destroy(), this.printableArea = void 0) : (this.printableArea = new aV(this.map), this.updatePrintableArea()));
  }
  updatePrintableArea() {
    if (this.printableArea === void 0) return;
    const e = document.getElementById("mapbox-gl-export-page-size"), t = document.getElementById("mapbox-gl-export-page-orientation").value;
    let i = JSON.parse(e.value);
    t === pp.Portrait && (i = i.reverse()), this.printableArea.updateArea(i[0], i[1]);
  }
}
function yy(n, e, t, i) {
  function r(l) {
    return l instanceof t ? l : new t(function(c) {
      c(l);
    });
  }
  return new (t || (t = Promise))(function(l, c) {
    function a(A) {
      try {
        y(i.next(A));
      } catch (C) {
        c(C);
      }
    }
    function g(A) {
      try {
        y(i.throw(A));
      } catch (C) {
        c(C);
      }
    }
    function y(A) {
      A.done ? l(A.value) : r(A.value).then(a, g);
    }
    y((i = i.apply(n, e || [])).next());
  });
}
var Qg = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function h_(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var by, D5;
function C3() {
  if (D5) return by;
  D5 = 1, by = e;
  var n = Object.prototype.hasOwnProperty;
  function e() {
    for (var t = {}, i = 0; i < arguments.length; i++) {
      var r = arguments[i];
      for (var l in r)
        n.call(r, l) && (t[l] = r[l]);
    }
    return t;
  }
  return by;
}
var vy = {
  exports: {}
}, F5;
function wq() {
  return F5 || (F5 = 1, function(n, e) {
    (function() {
      var t = {};
      n.exports = t, t.simpleFilter = function(i, r) {
        return r.filter(function(l) {
          return t.test(i, l);
        });
      }, t.test = function(i, r) {
        return t.match(i, r) !== null;
      }, t.match = function(i, r, l) {
        l = l || {};
        var c = 0, a = [], g = r.length, y = 0, A = 0, C = l.pre || "", I = l.post || "", S = l.caseSensitive && r || r.toLowerCase(), F;
        i = l.caseSensitive && i || i.toLowerCase();
        for (var U = 0; U < g; U++)
          F = r[U], S[U] === i[c] ? (F = C + F + I, c += 1, A += 1 + A) : A = 0, y += A, a[a.length] = F;
        return c === i.length ? (y = S === i ? 1 / 0 : y, {
          rendered: a.join(""),
          score: y
        }) : null;
      }, t.filter = function(i, r, l) {
        return !r || r.length === 0 ? [] : typeof i != "string" ? r : (l = l || {}, r.reduce(function(c, a, g, y) {
          var A = a;
          l.extract && (A = l.extract(a));
          var C = t.match(i, A, l);
          return C != null && (c[c.length] = {
            string: C.rendered,
            score: C.score,
            index: g,
            original: a
          }), c;
        }, []).sort(function(c, a) {
          var g = a.score - c.score;
          return g || c.index - a.index;
        }));
      };
    })();
  }(vy)), vy.exports;
}
var xy, N5;
function Aq() {
  if (N5) return xy;
  N5 = 1;
  var n = function(e) {
    return this.component = e, this.items = [], this.active = e.options.noInitialSelection ? -1 : 0, this.wrapper = document.createElement("div"), this.wrapper.className = "suggestions-wrapper", this.element = document.createElement("ul"), this.element.className = "suggestions", this.wrapper.appendChild(this.element), this.selectingListItem = !1, e.el.parentNode.insertBefore(this.wrapper, e.el.nextSibling), this;
  };
  return n.prototype.show = function() {
    this.element.style.display = "block";
  }, n.prototype.hide = function() {
    this.element.style.display = "none";
  }, n.prototype.add = function(e) {
    this.items.push(e);
  }, n.prototype.clear = function() {
    this.items = [], this.active = this.component.options.noInitialSelection ? -1 : 0;
  }, n.prototype.isEmpty = function() {
    return !this.items.length;
  }, n.prototype.isVisible = function() {
    return this.element.style.display === "block";
  }, n.prototype.draw = function() {
    if (this.element.innerHTML = "", this.items.length === 0) {
      this.hide();
      return;
    }
    for (var e = 0; e < this.items.length; e++)
      this.drawItem(this.items[e], this.active === e);
    this.show();
  }, n.prototype.drawItem = function(e, t) {
    var i = document.createElement("li"), r = document.createElement("a");
    t && (i.className += " active"), r.innerHTML = e.string, i.appendChild(r), this.element.appendChild(i), i.addEventListener("mousedown", (function() {
      this.selectingListItem = !0;
    }).bind(this)), i.addEventListener("mouseup", (function() {
      this.handleMouseUp.call(this, e);
    }).bind(this));
  }, n.prototype.handleMouseUp = function(e) {
    this.selectingListItem = !1, this.component.value(e.original), this.clear(), this.draw();
  }, n.prototype.move = function(e) {
    this.active = e, this.draw();
  }, n.prototype.previous = function() {
    this.move(this.active <= 0 ? this.items.length - 1 : this.active - 1);
  }, n.prototype.next = function() {
    this.move(this.active >= this.items.length - 1 ? 0 : this.active + 1);
  }, n.prototype.drawError = function(e) {
    var t = document.createElement("li");
    t.innerHTML = e, this.element.appendChild(t), this.show();
  }, xy = n, xy;
}
var wy, k5;
function Tq() {
  if (k5) return wy;
  k5 = 1;
  var n = C3(), e = wq(), t = Aq(), i = function(r, l, c) {
    return c = c || {}, this.options = n({
      minLength: 2,
      limit: 5,
      filter: !0,
      hideOnBlur: !0,
      noInitialSelection: !0
    }, c), this.el = r, this.data = l || [], this.list = new t(this), this.query = "", this.selected = null, this.list.draw(), this.el.addEventListener("keyup", (function(a) {
      this.handleKeyUp(a.keyCode, a);
    }).bind(this), !1), this.el.addEventListener("keydown", (function(a) {
      this.handleKeyDown(a);
    }).bind(this)), this.el.addEventListener("focus", (function() {
      this.handleFocus();
    }).bind(this)), this.el.addEventListener("blur", (function() {
      this.handleBlur();
    }).bind(this)), this.el.addEventListener("paste", (function(a) {
      this.handlePaste(a);
    }).bind(this)), this.render = this.options.render ? this.options.render.bind(this) : this.render.bind(this), this.getItemValue = this.options.getItemValue ? this.options.getItemValue.bind(this) : this.getItemValue.bind(this), this;
  };
  return i.prototype.handleKeyUp = function(r, l) {
    if (!(r === 40 || r === 38 || r === 27 || r === 9)) {
      if (r === 13) {
        this.list.items[this.list.active] && (this.list.handleMouseUp(this.list.items[this.list.active]), l.stopPropagation());
        return;
      }
      this.handleInputChange(this.el.value);
    }
  }, i.prototype.handleKeyDown = function(r) {
    switch (r.keyCode) {
      case 13:
        this.list.active >= 0 && (this.list.selectingListItem = !0);
        break;
      case 9:
        this.list.isEmpty() || (this.list.isVisible() && r.preventDefault(), this.value(this.list.active >= 0 ? this.list.items[this.list.active].original : null), this.list.hide());
        break;
      case 27:
        this.list.isEmpty() || this.list.hide();
        break;
      case 38:
        this.list.previous();
        break;
      case 40:
        this.list.next();
        break;
    }
  }, i.prototype.handleBlur = function() {
    !this.list.selectingListItem && this.options.hideOnBlur && this.list.hide();
  }, i.prototype.handlePaste = function(r) {
    if (r.clipboardData)
      this.handleInputChange(r.clipboardData.getData("Text"));
    else {
      var l = this;
      setTimeout(function() {
        l.handleInputChange(r.target.value);
      }, 100);
    }
  }, i.prototype.handleInputChange = function(r) {
    if (this.query = this.normalize(r), this.list.clear(), this.query.length < this.options.minLength) {
      this.list.draw();
      return;
    }
    this.getCandidates((function(l) {
      for (var c = 0; c < l.length && (this.list.add(l[c]), c !== this.options.limit - 1); c++)
        ;
      this.list.draw();
    }).bind(this));
  }, i.prototype.handleFocus = function() {
    this.list.isEmpty() || this.list.show(), this.list.selectingListItem = !1;
  }, i.prototype.update = function(r) {
    this.data = r, this.handleKeyUp();
  }, i.prototype.clear = function() {
    this.data = [], this.list.clear();
  }, i.prototype.normalize = function(r) {
    return r = r.toLowerCase(), r;
  }, i.prototype.match = function(r, l) {
    return r.indexOf(l) > -1;
  }, i.prototype.value = function(r) {
    if (this.selected = r, this.el.value = this.getItemValue(r || {
      place_name: this.query
    }), document.createEvent) {
      var l = document.createEvent("HTMLEvents");
      l.initEvent("change", !0, !1), this.el.dispatchEvent(l);
    } else
      this.el.fireEvent("onchange");
  }, i.prototype.getCandidates = function(r) {
    var l = {
      pre: "<strong>",
      post: "</strong>",
      extract: (function(a) {
        return this.getItemValue(a);
      }).bind(this)
    }, c;
    this.options.filter ? (c = e.filter(this.query, this.data, l), c = c.map((function(a) {
      return {
        original: a.original,
        string: this.render(a.original, a.string)
      };
    }).bind(this))) : c = this.data.map((function(a) {
      var g = this.render(a);
      return {
        original: a,
        string: g
      };
    }).bind(this)), r(c);
  }, i.prototype.getItemValue = function(r) {
    return r;
  }, i.prototype.render = function(r, l) {
    if (l)
      return l;
    for (var c = r.original ? this.getItemValue(r.original) : this.getItemValue(r), a = this.normalize(c), g = a.lastIndexOf(this.query); g > -1; ) {
      var y = g + this.query.length;
      c = c.slice(0, g) + "<strong>" + c.slice(g, y) + "</strong>" + c.slice(y), g = a.slice(0, g).lastIndexOf(this.query);
    }
    return c;
  }, i.prototype.renderError = function(r) {
    this.list.drawError(r);
  }, wy = i, wy;
}
var Ay, z5;
function Eq() {
  if (z5) return Ay;
  z5 = 1;
  var n = Tq();
  return Ay = n, typeof window < "u" && (window.Suggestions = n), Ay;
}
var Sq = Eq(), Cq = /* @__PURE__ */ h_(Sq), _m = {
  exports: {}
}, Pq = _m.exports, U5;
function Iq() {
  return U5 || (U5 = 1, function(n) {
    (function(e, t, i) {
      n.exports ? n.exports = i() : e[t] = i();
    })(Pq, "subtag", function() {
      var e = "", t = /^([a-zA-Z]{2,3})(?:[_-]+([a-zA-Z]{3})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{4})(?=$|[_-]+))?(?:[_-]+([a-zA-Z]{2}|[0-9]{3})(?=$|[_-]+))?/;
      function i(g) {
        return g.match(t) || [];
      }
      function r(g) {
        return i(g).filter(function(y, A) {
          return y && A;
        });
      }
      function l(g) {
        return g = i(g), {
          language: g[1] || e,
          extlang: g[2] || e,
          script: g[3] || e,
          region: g[4] || e
        };
      }
      function c(g, y, A) {
        Object.defineProperty(g, y, {
          value: A,
          enumerable: !0
        });
      }
      function a(g, y, A) {
        function C(I) {
          return i(I)[g] || e;
        }
        c(C, "pattern", y), c(l, A, C);
      }
      return a(1, /^[a-zA-Z]{2,3}$/, "language"), a(2, /^[a-zA-Z]{3}$/, "extlang"), a(3, /^[a-zA-Z]{4}$/, "script"), a(4, /^[a-zA-Z]{2}$|^[0-9]{3}$/, "region"), c(l, "split", r), l;
    });
  }(_m)), _m.exports;
}
var Mq = Iq(), Lq = /* @__PURE__ */ h_(Mq), Ty, j5;
function Rq() {
  if (j5) return Ty;
  j5 = 1;
  var n = "Expected a function", e = NaN, t = "[object Symbol]", i = /^\s+|\s+$/g, r = /^[-+]0x[0-9a-f]+$/i, l = /^0b[01]+$/i, c = /^0o[0-7]+$/i, a = parseInt, g = typeof Qg == "object" && Qg && Qg.Object === Object && Qg, y = typeof self == "object" && self && self.Object === Object && self, A = g || y || Function("return this")(), C = Object.prototype, I = C.toString, S = Math.max, F = Math.min, U = function() {
    return A.Date.now();
  };
  function V(fe, Ae, Te) {
    var me, Ge, ke, pe, _e, De, Me = 0, St = !1, dt = !1, Pt = !0;
    if (typeof fe != "function")
      throw new TypeError(n);
    Ae = ie(Ae) || 0, W(Te) && (St = !!Te.leading, dt = "maxWait" in Te, ke = dt ? S(ie(Te.maxWait) || 0, Ae) : ke, Pt = "trailing" in Te ? !!Te.trailing : Pt);
    function gt(rt) {
      var xt = me, ht = Ge;
      return me = Ge = void 0, Me = rt, pe = fe.apply(ht, xt), pe;
    }
    function Rt(rt) {
      return Me = rt, _e = setTimeout(oe, Ae), St ? gt(rt) : pe;
    }
    function Ft(rt) {
      var xt = rt - De, ht = rt - Me, $t = Ae - xt;
      return dt ? F($t, ke - ht) : $t;
    }
    function mn(rt) {
      var xt = rt - De, ht = rt - Me;
      return De === void 0 || xt >= Ae || xt < 0 || dt && ht >= ke;
    }
    function oe() {
      var rt = U();
      if (mn(rt))
        return Re(rt);
      _e = setTimeout(oe, Ft(rt));
    }
    function Re(rt) {
      return _e = void 0, Pt && me ? gt(rt) : (me = Ge = void 0, pe);
    }
    function ze() {
      _e !== void 0 && clearTimeout(_e), Me = 0, me = De = Ge = _e = void 0;
    }
    function Xe() {
      return _e === void 0 ? pe : Re(U());
    }
    function ot() {
      var rt = U(), xt = mn(rt);
      if (me = arguments, Ge = this, De = rt, xt) {
        if (_e === void 0)
          return Rt(De);
        if (dt)
          return _e = setTimeout(oe, Ae), gt(De);
      }
      return _e === void 0 && (_e = setTimeout(oe, Ae)), pe;
    }
    return ot.cancel = ze, ot.flush = Xe, ot;
  }
  function W(fe) {
    var Ae = typeof fe;
    return !!fe && (Ae == "object" || Ae == "function");
  }
  function X(fe) {
    return !!fe && typeof fe == "object";
  }
  function de(fe) {
    return typeof fe == "symbol" || X(fe) && I.call(fe) == t;
  }
  function ie(fe) {
    if (typeof fe == "number")
      return fe;
    if (de(fe))
      return e;
    if (W(fe)) {
      var Ae = typeof fe.valueOf == "function" ? fe.valueOf() : fe;
      fe = W(Ae) ? Ae + "" : Ae;
    }
    if (typeof fe != "string")
      return fe === 0 ? fe : +fe;
    fe = fe.replace(i, "");
    var Te = l.test(fe);
    return Te || c.test(fe) ? a(fe.slice(2), Te ? 2 : 8) : r.test(fe) ? e : +fe;
  }
  return Ty = V, Ty;
}
var Bq = Rq(), Oq = /* @__PURE__ */ h_(Bq), Dq = C3(), uc = /* @__PURE__ */ h_(Dq), em = {
  exports: {}
}, G5;
function Fq() {
  if (G5) return em.exports;
  G5 = 1;
  var n = typeof Reflect == "object" ? Reflect : null, e = n && typeof n.apply == "function" ? n.apply : function(fe, Ae, Te) {
    return Function.prototype.apply.call(fe, Ae, Te);
  }, t;
  n && typeof n.ownKeys == "function" ? t = n.ownKeys : Object.getOwnPropertySymbols ? t = function(fe) {
    return Object.getOwnPropertyNames(fe).concat(Object.getOwnPropertySymbols(fe));
  } : t = function(fe) {
    return Object.getOwnPropertyNames(fe);
  };
  function i(ie) {
    console && console.warn && console.warn(ie);
  }
  var r = Number.isNaN || function(fe) {
    return fe !== fe;
  };
  function l() {
    l.init.call(this);
  }
  em.exports = l, em.exports.once = W, l.EventEmitter = l, l.prototype._events = void 0, l.prototype._eventsCount = 0, l.prototype._maxListeners = void 0;
  var c = 10;
  function a(ie) {
    if (typeof ie != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof ie);
  }
  Object.defineProperty(l, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return c;
    },
    set: function(ie) {
      if (typeof ie != "number" || ie < 0 || r(ie))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + ie + ".");
      c = ie;
    }
  }), l.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, l.prototype.setMaxListeners = function(fe) {
    if (typeof fe != "number" || fe < 0 || r(fe))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + fe + ".");
    return this._maxListeners = fe, this;
  };
  function g(ie) {
    return ie._maxListeners === void 0 ? l.defaultMaxListeners : ie._maxListeners;
  }
  l.prototype.getMaxListeners = function() {
    return g(this);
  }, l.prototype.emit = function(fe) {
    for (var Ae = [], Te = 1; Te < arguments.length; Te++) Ae.push(arguments[Te]);
    var me = fe === "error", Ge = this._events;
    if (Ge !== void 0) me = me && Ge.error === void 0;
    else if (!me) return !1;
    if (me) {
      var ke;
      if (Ae.length > 0 && (ke = Ae[0]), ke instanceof Error)
        throw ke;
      var pe = new Error("Unhandled error." + (ke ? " (" + ke.message + ")" : ""));
      throw pe.context = ke, pe;
    }
    var _e = Ge[fe];
    if (_e === void 0) return !1;
    if (typeof _e == "function")
      e(_e, this, Ae);
    else
      for (var De = _e.length, Me = F(_e, De), Te = 0; Te < De; ++Te) e(Me[Te], this, Ae);
    return !0;
  };
  function y(ie, fe, Ae, Te) {
    var me, Ge, ke;
    if (a(Ae), Ge = ie._events, Ge === void 0 ? (Ge = ie._events = /* @__PURE__ */ Object.create(null), ie._eventsCount = 0) : (Ge.newListener !== void 0 && (ie.emit("newListener", fe, Ae.listener ? Ae.listener : Ae), Ge = ie._events), ke = Ge[fe]), ke === void 0)
      ke = Ge[fe] = Ae, ++ie._eventsCount;
    else if (typeof ke == "function" ? ke = Ge[fe] = Te ? [Ae, ke] : [ke, Ae] : Te ? ke.unshift(Ae) : ke.push(Ae), me = g(ie), me > 0 && ke.length > me && !ke.warned) {
      ke.warned = !0;
      var pe = new Error("Possible EventEmitter memory leak detected. " + ke.length + " " + String(fe) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      pe.name = "MaxListenersExceededWarning", pe.emitter = ie, pe.type = fe, pe.count = ke.length, i(pe);
    }
    return ie;
  }
  l.prototype.addListener = function(fe, Ae) {
    return y(this, fe, Ae, !1);
  }, l.prototype.on = l.prototype.addListener, l.prototype.prependListener = function(fe, Ae) {
    return y(this, fe, Ae, !0);
  };
  function A() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function C(ie, fe, Ae) {
    var Te = {
      fired: !1,
      wrapFn: void 0,
      target: ie,
      type: fe,
      listener: Ae
    }, me = A.bind(Te);
    return me.listener = Ae, Te.wrapFn = me, me;
  }
  l.prototype.once = function(fe, Ae) {
    return a(Ae), this.on(fe, C(this, fe, Ae)), this;
  }, l.prototype.prependOnceListener = function(fe, Ae) {
    return a(Ae), this.prependListener(fe, C(this, fe, Ae)), this;
  }, l.prototype.removeListener = function(fe, Ae) {
    var Te, me, Ge, ke, pe;
    if (a(Ae), me = this._events, me === void 0) return this;
    if (Te = me[fe], Te === void 0) return this;
    if (Te === Ae || Te.listener === Ae)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete me[fe], me.removeListener && this.emit("removeListener", fe, Te.listener || Ae));
    else if (typeof Te != "function") {
      for (Ge = -1, ke = Te.length - 1; ke >= 0; ke--)
        if (Te[ke] === Ae || Te[ke].listener === Ae) {
          pe = Te[ke].listener, Ge = ke;
          break;
        }
      if (Ge < 0) return this;
      Ge === 0 ? Te.shift() : U(Te, Ge), Te.length === 1 && (me[fe] = Te[0]), me.removeListener !== void 0 && this.emit("removeListener", fe, pe || Ae);
    }
    return this;
  }, l.prototype.off = l.prototype.removeListener, l.prototype.removeAllListeners = function(fe) {
    var Ae, Te, me;
    if (Te = this._events, Te === void 0) return this;
    if (Te.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Te[fe] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Te[fe]), this;
    if (arguments.length === 0) {
      var Ge = Object.keys(Te), ke;
      for (me = 0; me < Ge.length; ++me)
        ke = Ge[me], ke !== "removeListener" && this.removeAllListeners(ke);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (Ae = Te[fe], typeof Ae == "function")
      this.removeListener(fe, Ae);
    else if (Ae !== void 0)
      for (me = Ae.length - 1; me >= 0; me--)
        this.removeListener(fe, Ae[me]);
    return this;
  };
  function I(ie, fe, Ae) {
    var Te = ie._events;
    if (Te === void 0) return [];
    var me = Te[fe];
    return me === void 0 ? [] : typeof me == "function" ? Ae ? [me.listener || me] : [me] : Ae ? V(me) : F(me, me.length);
  }
  l.prototype.listeners = function(fe) {
    return I(this, fe, !0);
  }, l.prototype.rawListeners = function(fe) {
    return I(this, fe, !1);
  }, l.listenerCount = function(ie, fe) {
    return typeof ie.listenerCount == "function" ? ie.listenerCount(fe) : S.call(ie, fe);
  }, l.prototype.listenerCount = S;
  function S(ie) {
    var fe = this._events;
    if (fe !== void 0) {
      var Ae = fe[ie];
      if (typeof Ae == "function")
        return 1;
      if (Ae !== void 0)
        return Ae.length;
    }
    return 0;
  }
  l.prototype.eventNames = function() {
    return this._eventsCount > 0 ? t(this._events) : [];
  };
  function F(ie, fe) {
    for (var Ae = new Array(fe), Te = 0; Te < fe; ++Te) Ae[Te] = ie[Te];
    return Ae;
  }
  function U(ie, fe) {
    for (; fe + 1 < ie.length; fe++) ie[fe] = ie[fe + 1];
    ie.pop();
  }
  function V(ie) {
    for (var fe = new Array(ie.length), Ae = 0; Ae < fe.length; ++Ae)
      fe[Ae] = ie[Ae].listener || ie[Ae];
    return fe;
  }
  function W(ie, fe) {
    return new Promise(function(Ae, Te) {
      function me(ke) {
        ie.removeListener(fe, Ge), Te(ke);
      }
      function Ge() {
        typeof ie.removeListener == "function" && ie.removeListener("error", me), Ae([].slice.call(arguments));
      }
      de(ie, fe, Ge, {
        once: !0
      }), fe !== "error" && X(ie, me, {
        once: !0
      });
    });
  }
  function X(ie, fe, Ae) {
    typeof ie.on == "function" && de(ie, "error", fe, Ae);
  }
  function de(ie, fe, Ae, Te) {
    if (typeof ie.on == "function")
      Te.once ? ie.once(fe, Ae) : ie.on(fe, Ae);
    else if (typeof ie.addEventListener == "function")
      ie.addEventListener(fe, function me(Ge) {
        Te.once && ie.removeEventListener(fe, me), Ae(Ge);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof ie);
  }
  return em.exports;
}
var Nq = Fq();
const V5 = {
  fr: {
    name: "France",
    bbox: [[-4.59235, 41.380007], [9.560016, 51.148506]]
  },
  us: {
    name: "United States",
    bbox: [[-171.791111, 18.91619], [-66.96466, 71.357764]]
  },
  ru: {
    name: "Russia",
    bbox: [[19.66064, 41.151416], [190.10042, 81.2504]]
  },
  ca: {
    name: "Canada",
    bbox: [[-140.99778, 41.675105], [-52.648099, 83.23324]]
  }
}, kq = {
  // list drawn from https://docs.mapbox.com/api/search/#language-coverage
  de: "Suche",
  // german
  it: "Ricerca",
  //italian
  en: "Search",
  // english
  nl: "Zoeken",
  //dutch
  fr: "Chercher",
  //french
  ca: "Cerca",
  //catalan
  he: "לחפש",
  //hebrew
  ja: "サーチ",
  //japanese
  lv: "Meklēt",
  //latvian
  pt: "Procurar",
  //portuguese 
  sr: "Претрага",
  //serbian
  zh: "搜索",
  //chinese-simplified
  cs: "Vyhledávání",
  //czech
  hu: "Keresés",
  //hungarian
  ka: "ძიება",
  // georgian
  nb: "Søke",
  //norwegian
  sk: "Vyhľadávanie",
  //slovak
  th: "ค้นหา",
  //thai
  fi: "Hae",
  //finnish
  is: "Leita",
  //icelandic
  ko: "수색",
  //korean
  pl: "Szukaj",
  //polish
  sl: "Iskanje",
  //slovenian
  fa: "جستجو",
  //persian(aka farsi)
  ru: "Поиск"
  //russian
}, zq = {
  en: "No results found",
  de: "Keine Ergebnisse gefunden"
}, Uq = {
  en: "There was an error reaching the server",
  de: "Verbindung fehlgeschlagen"
};
var lp = {
  placeholder: kq,
  errorNoResults: zq,
  errorConnectionFailed: Uq
};
const jq = /(-?\d+\.?\d*)[, ]+(-?\d+\.?\d*)[ ]*$/;
class Gq {
  constructor(e, t) {
    this.options = {
      zoom: 16,
      flyTo: !0,
      trackProximity: !0,
      showResultsWhileTyping: !1,
      minLength: 2,
      reverseGeocode: !1,
      limit: 5,
      enableEventLogging: !0,
      marker: !0,
      popup: !1,
      maplibregl: void 0,
      collapsed: !1,
      clearAndBlurOnEsc: !1,
      clearOnBlur: !1,
      proximityMinZoom: 9,
      getItemValue: (i) => i.text !== void 0 ? i.text : i.place_name,
      render: function(i) {
        if (!i.geometry) {
          const l = i.text, c = l.toLowerCase().indexOf(this.query.toLowerCase()), a = this.query.length, g = l.substring(0, c), y = l.substring(c, c + a), A = l.substring(c + a);
          return '<div class="maplibregl-ctrl-geocoder--suggestion"><svg class="maplibregl-ctrl-geocoder--suggestion-icon" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg"><path d="M22.8702 20.1258H21.4248L20.9125 19.6318C22.7055 17.546 23.785 14.8382 23.785 11.8925C23.785 5.32419 18.4608 0 11.8925 0C5.32419 0 0 5.32419 0 11.8925C0 18.4608 5.32419 23.785 11.8925 23.785C14.8382 23.785 17.546 22.7055 19.6318 20.9125L20.1258 21.4248V22.8702L29.2739 32L32 29.2739L22.8702 20.1258ZM11.8925 20.1258C7.33676 20.1258 3.65923 16.4483 3.65923 11.8925C3.65923 7.33676 7.33676 3.65923 11.8925 3.65923C16.4483 3.65923 20.1258 7.33676 20.1258 11.8925C20.1258 16.4483 16.4483 20.1258 11.8925 20.1258Z" fill="#687078"/></svg><div class="maplibregl-ctrl-geocoder--suggestion-info"><div class="maplibregl-ctrl-geocoder--suggestion-title">' + g + '<span class="maplibregl-ctrl-geocoder--suggestion-match">' + y + "</span>" + A + "</div></div></div>";
        }
        const r = i.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--result"><svg class="maplibregl-ctrl-geocoder--result-icon" viewBox="0 0 24 32" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 0C5.36571 0 0 5.38676 0 12.0471C0 21.0824 12 32 12 32C12 32 24 21.0824 24 12.0471C24 5.38676 18.6343 0 12 0ZM12 16.3496C9.63428 16.3496 7.71429 14.4221 7.71429 12.0471C7.71429 9.67207 9.63428 7.74454 12 7.74454C14.3657 7.74454 16.2857 9.67207 16.2857 12.0471C16.2857 14.4221 14.3657 16.3496 12 16.3496Z" fill="#687078"/></svg><div><div class="maplibregl-ctrl-geocoder--result-title">' + r[0] + '</div><div class="maplibregl-ctrl-geocoder--result-address">' + r.splice(1, r.length).join(",") + "</div></div></div>";
      },
      popupRender: (i) => {
        const r = i.place_name.split(",");
        return '<div class="maplibregl-ctrl-geocoder--suggestion popup-suggestion"><div class="maplibregl-ctrl-geocoder--suggestion-title popup-suggestion-title">' + r[0] + '</div><div class="maplibregl-ctrl-geocoder--suggestion-address popup-suggestion-address">' + r.splice(1, r.length).join(",") + "</div></div>";
      },
      showResultMarkers: !0,
      debounceSearch: 200
    }, this._eventEmitter = new Nq.EventEmitter(), this.options = uc({}, this.options, t), this.fresh = !0, this.lastSelected = null, this.geocoderApi = e;
  }
  /**
   * Add the geocoder to a container. The container can be either a `Map`, an `HTMLElement` or a CSS selector string.
   *
   * If the container is a [`Map`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map), this function will behave identically to [`Map.addControl(geocoder)`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#addcontrol).
   * If the container is an instance of [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement), then the geocoder will be appended as a child of that [`HTMLElement`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement).
   * If the container is a [CSS selector string](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors), the geocoder will be appended to the element returned from the query.
   *
   * This function will throw an error if the container is none of the above.
   * It will also throw an error if the referenced HTML element cannot be found in the `document.body`.
   *
   * For example, if the HTML body contains the element `<div id='geocoder-container'></div>`, the following script will append the geocoder to `#geocoder-container`:
   * @example
   * ```js
   * const GeoApi = {
   *   forwardGeocode: (config) => { return { features: [] } },
   *   reverseGeocode: (config) => { return { features: [] } }
   * }
   * const geocoder = new MaplibreGeocoder(GeoAPI, {});
   * geocoder.addTo('#geocoder-container');
   * ```
   * @param container - A reference to the container to which to add the geocoder
   */
  addTo(e) {
    function t(i, r) {
      if (!document.body.contains(r))
        throw new Error("Element provided to #addTo() exists, but is not in the DOM");
      const l = i.onAdd();
      r.appendChild(l);
    }
    if (e instanceof HTMLElement)
      t(this, e);
    else if (typeof e == "string") {
      const i = document.querySelectorAll(e);
      if (i.length === 0)
        throw new Error("Element " + e + "not found.");
      if (i.length > 1)
        throw new Error("Geocoder can only be added to a single html element");
      t(this, i[0]);
    } else if ("addControl" in e)
      e.addControl(this);
    else
      throw new Error("Error: addTo must be a maplibre-gl-js map, an html element, or a CSS selector query for a single html element");
  }
  onAdd(e) {
    if (e && typeof e != "string" && (this._map = e), this.setLanguage(), this.options.localGeocoderOnly && !this.options.localGeocoder)
      throw new Error("A localGeocoder function must be specified to use localGeocoderOnly mode");
    this._onChange = this._onChange.bind(this), this._onKeyDown = this._onKeyDown.bind(this), this._onPaste = this._onPaste.bind(this), this._onBlur = this._onBlur.bind(this), this._showButton = this._showButton.bind(this), this._hideButton = this._hideButton.bind(this), this._onQueryResult = this._onQueryResult.bind(this), this.clear = this.clear.bind(this), this._updateProximity = this._updateProximity.bind(this), this._collapse = this._collapse.bind(this), this._unCollapse = this._unCollapse.bind(this), this._clear = this._clear.bind(this), this._clearOnBlur = this._clearOnBlur.bind(this);
    const t = this.container = document.createElement("div");
    t.className = "maplibregl-ctrl-geocoder maplibregl-ctrl maplibregl-ctrl-geocoder maplibregl-ctrl";
    const i = this.createIcon("search", '<path d="M7.4 2.5c-2.7 0-4.9 2.2-4.9 4.9s2.2 4.9 4.9 4.9c1 0 1.8-.2 2.5-.8l3.7 3.7c.2.2.4.3.8.3.7 0 1.1-.4 1.1-1.1 0-.3-.1-.5-.3-.8L11.4 10c.4-.8.8-1.6.8-2.5.1-2.8-2.1-5-4.8-5zm0 1.6c1.8 0 3.2 1.4 3.2 3.2s-1.4 3.2-3.2 3.2-3.3-1.3-3.3-3.1 1.4-3.3 3.3-3.3z"/>');
    this._inputEl = document.createElement("input"), this._inputEl.type = "text", this._inputEl.className = "maplibregl-ctrl-geocoder--input", this.setPlaceholder(), this.options.collapsed && (this._collapse(), this.container.addEventListener("mouseenter", this._unCollapse), this.container.addEventListener("mouseleave", this._collapse), this._inputEl.addEventListener("focus", this._unCollapse)), (this.options.collapsed || this.options.clearOnBlur) && this._inputEl.addEventListener("blur", this._onBlur), this._inputEl.addEventListener("keydown", Oq(this._onKeyDown, this.options.debounceSearch)), this._inputEl.addEventListener("paste", this._onPaste), this._inputEl.addEventListener("change", this._onChange), this.container.addEventListener("mouseenter", this._showButton), this.container.addEventListener("mouseleave", this._hideButton);
    const r = document.createElement("div");
    r.classList.add("maplibregl-ctrl-geocoder--pin-right"), this._clearEl = document.createElement("button"), this._clearEl.setAttribute("type", "button"), this._clearEl.setAttribute("aria-label", "Clear"), this._clearEl.addEventListener("click", this.clear), this._clearEl.className = "maplibregl-ctrl-geocoder--button";
    const l = this.createIcon("close", '<path d="M3.8 2.5c-.6 0-1.3.7-1.3 1.3 0 .3.2.7.5.8L7.2 9 3 13.2c-.3.3-.5.7-.5 1 0 .6.7 1.3 1.3 1.3.3 0 .7-.2 1-.5L9 10.8l4.2 4.2c.2.3.7.3 1 .3.6 0 1.3-.7 1.3-1.3 0-.3-.2-.7-.3-1l-4.4-4L15 4.6c.3-.2.5-.5.5-.8 0-.7-.7-1.3-1.3-1.3-.3 0-.7.2-1 .3L9 7.1 4.8 2.8c-.3-.1-.7-.3-1-.3z"/>');
    return this._clearEl.appendChild(l), this._loadingEl = this.createIcon("loading", '<path fill="#333" d="M4.4 4.4l.8.8c2.1-2.1 5.5-2.1 7.6 0l.8-.8c-2.5-2.5-6.7-2.5-9.2 0z"/><path opacity=".1" d="M12.8 12.9c-2.1 2.1-5.5 2.1-7.6 0-2.1-2.1-2.1-5.5 0-7.7l-.8-.8c-2.5 2.5-2.5 6.7 0 9.2s6.6 2.5 9.2 0 2.5-6.6 0-9.2l-.8.8c2.2 2.1 2.2 5.6 0 7.7z"/>'), r.appendChild(this._clearEl), r.appendChild(this._loadingEl), t.appendChild(i), t.appendChild(this._inputEl), t.appendChild(r), this._typeahead = new Cq(this._inputEl, [], {
      filter: !1,
      minLength: this.options.minLength,
      limit: this.options.limit,
      noInitialSelection: !0
    }), this.setRenderFunction(this.options.render), this._typeahead.getItemValue = this.options.getItemValue, this.mapMarker = null, this.resultMarkers = [], this._handleMarker = this._handleMarker.bind(this), this._handleResultMarkers = this._handleResultMarkers.bind(this), this._map && (this.options.trackProximity && (this._updateProximity(), this._map.on("moveend", this._updateProximity)), this._maplibregl = this.options.maplibregl, !this._maplibregl && this.options.marker && (console.error("No maplibregl detected in options. Map markers are disabled. Please set options.maplibregl."), this.options.marker = !1)), t;
  }
  createIcon(e, t) {
    const i = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    if (i.setAttribute("class", "maplibregl-ctrl-geocoder--icon maplibregl-ctrl-geocoder--icon-" + e), i.setAttribute("viewBox", "0 0 18 18"), i.setAttribute("xml:space", "preserve"), i.setAttribute("width", "18"), i.setAttribute("height", "18"), "innerHTML" in i)
      i.innerHTML = t;
    else {
      const r = document.createElement("div");
      r.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>";
      const l = r.firstChild, c = l.firstChild;
      i.appendChild(c);
    }
    return i;
  }
  onRemove() {
    return this.container.remove(), this.options.trackProximity && this._map && this._map.off("moveend", this._updateProximity), this._removeMarker(), this._map = null, this;
  }
  _onPaste(e) {
    const t = (e.clipboardData || window.clipboardData).getData("text");
    t.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(t);
  }
  _onKeyDown(e) {
    if (e.keyCode === 27 && this.options.clearAndBlurOnEsc)
      return this._clear(e), this._inputEl.blur();
    const l = this._inputEl.value;
    if (!l)
      return this.fresh = !0, e.keyCode !== 9 && this.clear(e), this._clearEl.style.display = "none";
    if (!(e.metaKey || [9, 27, 37, 39, 38, 40].indexOf(e.keyCode) !== -1)) {
      if (e.keyCode === 13)
        if (!this.options.showResultsWhileTyping)
          this._typeahead.selected || this._geocode(l);
        else {
          this._typeahead.selected == null && this.geocoderApi.getSuggestions ? this._geocode(l, !0) : this._typeahead.selected == null && this.options.showResultMarkers && this._fitBoundsForMarkers();
          return;
        }
      l.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(l);
    }
  }
  _showButton() {
    this._inputEl.value.length > 0 && (this._clearEl.style.display = "block");
  }
  _hideButton() {
    this._typeahead.selected && (this._clearEl.style.display = "none");
  }
  _onBlur(e) {
    this.options.clearOnBlur && this._clearOnBlur(e), this.options.collapsed && this._collapse();
  }
  // Change events are fire by suggestions library whenever the enter key is pressed or input is blurred
  // This can sometimes cause strange behavior as this function is called before our own onKeyDown handler and thus
  //  we cannot depend on some internal values of the suggestion state like `selected` as those will change or before
  //  our onKeyDown handler.
  _onChange() {
    const e = this._typeahead.selected;
    if (e && !e.geometry)
      e.placeId ? this._geocode(e.placeId, !0, !0) : this._geocode(e.text, !0);
    else if (e && JSON.stringify(e) !== this.lastSelected) {
      if (this._clearEl.style.display = "none", this.options.flyTo) {
        let t;
        if (this._removeResultMarkers(), e.properties && V5[e.properties.short_code])
          t = uc({}, this.options.flyTo), this._map && this._map.fitBounds(V5[e.properties.short_code].bbox, t);
        else if (e.bbox) {
          const i = e.bbox;
          t = uc({}, this.options.flyTo), this._map && this._map.fitBounds([[i[0], i[1]], [i[2], i[3]]], t);
        } else {
          const i = {
            zoom: this.options.zoom
          };
          t = uc({}, i, this.options.flyTo), e.center ? t.center = e.center : e.geometry && e.geometry.type && e.geometry.type === "Point" && e.geometry.coordinates && (t.center = e.geometry.coordinates), this._map && this._map.flyTo(t);
        }
      }
      this.options.marker && this._maplibregl && this._handleMarker(e), this._inputEl.focus(), this._inputEl.scrollLeft = 0, this._inputEl.setSelectionRange(0, 0), this.lastSelected = JSON.stringify(e), this._typeahead.selected = null, this._eventEmitter.emit("result", {
        result: e
      });
    }
  }
  _getConfigForRequest() {
    return ["bbox", "limit", "proximity", "countries", "types", "language", "reverseMode"].reduce((i, r) => (this.options[r] && (["countries", "types", "language"].indexOf(r) > -1 ? i[r] = this.options[r].split(/[\s,]+/) : i[r] = this.options[r], r === "proximity" && this.options[r] && typeof this.options[r].longitude == "number" && typeof this.options[r].latitude == "number" && (i[r] = [this.options[r].longitude, this.options[r].latitude])), i), {});
  }
  _geocode(e) {
    return yy(this, arguments, void 0, function(t) {
      var i = this;
      let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      return function* () {
        i._loadingEl.style.display = "block", i._eventEmitter.emit("loading", {
          query: t
        });
        const c = i._getConfigForRequest(), a = i._createGeocodeRequest(c, t, r, l), g = i.options.localGeocoder ? i.options.localGeocoder(t) || [] : [];
        try {
          const y = yield a;
          yield i._handleGeocodeResponse(y, c, t, r, g);
        } catch (y) {
          i._handleGeocodeErrorResponse(y, g);
        }
        return a;
      }();
    });
  }
  _createGeocodeRequest(e, t, i, r) {
    return this.options.localGeocoderOnly ? Promise.resolve({}) : this.options.reverseGeocode && jq.test(t) ? this._createReverseGeocodeRequest(t, e) : (e.query = t, this.geocoderApi.getSuggestions ? i ? this.geocoderApi.searchByPlaceId && r ? this.geocoderApi.searchByPlaceId(e) : this.geocoderApi.forwardGeocode(e) : this.geocoderApi.getSuggestions(e) : this.geocoderApi.forwardGeocode(e));
  }
  _createReverseGeocodeRequest(e, t) {
    const i = e.split(/[\s(,)?]+/).map((r) => parseFloat(r)).reverse();
    return t.query = i, t.limit = 1, "proximity" in t && delete t.proximity, this.geocoderApi.reverseGeocode(t);
  }
  _handleGeocodeResponse(e, t, i, r, l) {
    return yy(this, void 0, void 0, function* () {
      this._loadingEl.style.display = "none";
      let c = {};
      e ? c = e : c = {
        type: "FeatureCollection",
        features: []
      }, c.config = t, this.fresh && (this.fresh = !1), c.features = c.features ? l.concat(c.features) : l;
      const a = this.options.externalGeocoder ? this.options.externalGeocoder(i, c.features, t) || Promise.resolve([]) : Promise.resolve([]);
      try {
        const y = yield a;
        c.features = c.features ? y.concat(c.features) : y;
      } catch {
      }
      this.options.filter && c.features.length && (c.features = c.features.filter(this.options.filter));
      let g = [];
      "suggestions" in c ? g = c.suggestions : "place" in c ? g = [c.place] : g = c.features, g.length ? (this._clearEl.style.display = "block", this._typeahead.update(g), (!this.options.showResultsWhileTyping || r) && this.options.showResultMarkers && (c.features.length > 0 || "place" in c) && this._fitBoundsForMarkers(), this._eventEmitter.emit("results", c)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderNoResults(), this._eventEmitter.emit("results", c));
    });
  }
  _handleGeocodeErrorResponse(e, t) {
    this._loadingEl.style.display = "none", t.length && this.options.localGeocoder ? (this._clearEl.style.display = "block", this._typeahead.update(t)) : (this._clearEl.style.display = "none", this._typeahead.selected = null, this._renderError()), this._eventEmitter.emit("results", {
      features: t
    }), this._eventEmitter.emit("error", {
      error: e
    });
  }
  /**
   * Shared logic for clearing input
   * @param ev - the event that triggered the clear, if available
   */
  _clear(e) {
    e && e.preventDefault(), this._inputEl.value = "", this._typeahead.selected = null, this._typeahead.clear(), this._onChange(), this._clearEl.style.display = "none", this._removeMarker(), this._removeResultMarkers(), this.lastSelected = null, this._eventEmitter.emit("clear"), this.fresh = !0;
  }
  /**
   * Clear and then focus the input.
   * @param ev - the event that triggered the clear, if available
   *
   */
  clear(e) {
    this._clear(e), this._inputEl.focus();
  }
  /**
   * Clear the input, without refocusing it. Used to implement clearOnBlur
   * constructor option.
   * @param ev - the blur event
   */
  _clearOnBlur(e) {
    e.relatedTarget && this._clear(e);
  }
  _onQueryResult(e) {
    if (!("features" in e) || !e.features.length) return;
    const t = e.features[0];
    this._typeahead.selected = t, this._inputEl.value = t.place_name, this._onChange();
  }
  _updateProximity() {
    if (this._map)
      if (this._map.getZoom() > this.options.proximityMinZoom) {
        const e = this._map.getCenter().wrap();
        this.setProximity({
          longitude: e.lng,
          latitude: e.lat
        });
      } else
        this.setProximity(null);
  }
  _collapse() {
    !this._inputEl.value && this._inputEl !== document.activeElement && this.container.classList.add("maplibregl-ctrl-geocoder--collapsed");
  }
  _unCollapse() {
    this.container.classList.remove("maplibregl-ctrl-geocoder--collapsed");
  }
  /**
   * Set & query the input
   * @param searchInput - location name or other search input
   */
  query(e) {
    return yy(this, void 0, void 0, function* () {
      const t = yield this._geocode(e);
      this._onQueryResult(t);
    });
  }
  _renderError() {
    const e = `<div class='maplibre-gl-geocoder--error'>${this._localize("errorConnectionFailed")}</div>`;
    this._renderMessage(e);
  }
  _renderNoResults() {
    const e = `<div class='maplibre-gl-geocoder--error maplibre-gl-geocoder--no-results'>
        ${this._localize("errorNoResults")}</div>`;
    this._renderMessage(e);
  }
  _renderMessage(e) {
    this._typeahead.update([]), this._typeahead.selected = null, this._typeahead.clear(), this._typeahead.renderError(e);
  }
  /**
   * Get a localised string for a given key
   *
   * If language is provided in options, attempt to return localized string (defaults to English)
   * @param key - key in the localization object
   * @returns localized string
   */
  _localize(e) {
    const t = Lq.language(this.options.language.split(",")[0]);
    return this.options.language && (lp != null && lp[e][t]) ? lp[e][t] : lp[e].en;
  }
  /**
   * Fits the map to the current bounds for the searched results
   */
  _fitBoundsForMarkers() {
    if (this._typeahead.data.length < 1) return;
    const e = this._typeahead.data.filter((t) => typeof t != "string").slice(0, this.options.limit);
    if (this._clearEl.style.display = "none", this.options.flyTo && this._maplibregl && this._map) {
      const i = uc({}, {
        padding: 100
      }, this.options.flyTo), r = new this._maplibregl.LngLatBounds();
      for (const l of e)
        r.extend(l.geometry.coordinates);
      this._map.fitBounds(r, i);
    }
    return e.length > 0 && this._maplibregl && this._handleResultMarkers(e), this;
  }
  /**
   * Set input
   * @param searchInput - location name or other search input
   */
  setInput(e) {
    return this._inputEl.value = e, this._typeahead.selected = null, this._typeahead.clear(), e.length >= this.options.minLength && this.options.showResultsWhileTyping && this._geocode(e), this;
  }
  /**
   * Set proximity
   * @param proximity - The new `options.proximity` value. This is a geographical point given as an object with `latitude` and `longitude` properties.
   */
  setProximity(e) {
    return this.options.proximity = e, this;
  }
  /**
   * Get proximity
   * @returns The geocoder proximity
   */
  getProximity() {
    return this.options.proximity;
  }
  /**
   * Set the render function used in the results dropdown
   * @param fn - The function to use as a render function. This function accepts a single {@link CarmenGeojsonFeature} object as input and returns a string.
   */
  setRenderFunction(e) {
    return e && typeof e == "function" && (this._typeahead.render = e), this;
  }
  /**
   * Get the function used to render the results dropdown
   *
   * @returns the render function
   */
  getRenderFunction() {
    return this._typeahead.render;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   *
   * Look first at the explicitly set options otherwise use the browser's language settings
   * @param language - Specify the language to use for response text and query result weighting. Options are IETF language tags comprised of a mandatory ISO 639-1 language code and optionally one or more IETF subtags for country or script. More than one value can also be specified, separated by commas.
   */
  setLanguage(e) {
    return this.options.language = e || this.options.language || navigator.language, this;
  }
  /**
   * Get the language to use in UI elements and when making search requests
   * @returns The language(s) used by the plugin, if any
   */
  getLanguage() {
    return this.options.language;
  }
  /**
   * Get the zoom level the map will move to when there is no bounding box on the selected result
   * @returns the map zoom
   */
  getZoom() {
    return this.options.zoom;
  }
  /**
   * Set the zoom level
   * @param zoom - The zoom level that the map should animate to when a `bbox` isn't found in the response. If a `bbox` is found the map will fit to the `bbox`.
   * @returns this
   */
  setZoom(e) {
    return this.options.zoom = e, this;
  }
  /**
   * Get the parameters used to fly to the selected response, if any
   * @returns The `flyTo` option
   */
  getFlyTo() {
    return this.options.flyTo;
  }
  /**
   * Set the flyTo options
   * @param flyTo - If false, animating the map to a selected result is disabled. If true, animating the map will use the default animation parameters. If an object, it will be passed as `options` to the map [`flyTo`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#flyto) or [`fitBounds`](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map#fitbounds) method providing control over the animation of the transition.
   */
  setFlyTo(e) {
    return this.options.flyTo = e, this;
  }
  /**
   * Get the value of the placeholder string
   * @returns The input element's placeholder value
   */
  getPlaceholder() {
    return this.options.placeholder;
  }
  /**
   * Set the value of the input element's placeholder
   * @param placeholder - the text to use as the input element's placeholder
   */
  setPlaceholder(e) {
    return this.placeholder = e || this.options.placeholder || this._localize("placeholder"), this._inputEl.placeholder = this.placeholder, this._inputEl.setAttribute("aria-label", this.placeholder), this;
  }
  /**
   * Get the bounding box used by the plugin
   * @returns the bounding box, if any
   */
  getBbox() {
    return this.options.bbox;
  }
  /**
   * Set the bounding box to limit search results to
   * @param bbox - a bounding box given as an array in the format [minX, minY, maxX, maxY].
   */
  setBbox(e) {
    return this.options.bbox = e, this;
  }
  /**
   * Get a list of the countries to limit search results to
   * @returns a comma separated list of countries to limit to, if any
   */
  getCountries() {
    return this.options.countries;
  }
  /**
   * Set the countries to limit search results to
   * @param countries - a comma separated list of countries to limit to
   */
  setCountries(e) {
    return this.options.countries = e, this;
  }
  /**
   * Get a list of the types to limit search results to
   * @returns a comma separated list of types to limit to
   */
  getTypes() {
    return this.options.types;
  }
  /**
   * Set the types to limit search results to
   * @param types - a comma separated list of types to limit to
   */
  setTypes(e) {
    return this.options.types = e, this;
  }
  /**
   * Get the minimum number of characters typed to trigger results used in the plugin
   * @returns The minimum length in characters before a search is triggered
   */
  getMinLength() {
    return this.options.minLength;
  }
  /**
   * Set the minimum number of characters typed to trigger results used by the plugin
   * @param minLength - the minimum length in characters
   */
  setMinLength(e) {
    return this.options.minLength = e, this._typeahead && (this._typeahead.options.minLength = e), this;
  }
  /**
   * Get the limit value for the number of results to display used by the plugin
   * @returns The limit value for the number of results to display used by the plugin
   */
  getLimit() {
    return this.options.limit;
  }
  /**
   * Set the limit value for the number of results to display used by the plugin
   * @param limit - the number of search results to return
   */
  setLimit(e) {
    return this.options.limit = e, this._typeahead && (this._typeahead.options.limit = e), this;
  }
  /**
   * Get the filter function used by the plugin
   * @returns the filter function
   */
  getFilter() {
    return this.options.filter;
  }
  /**
   * Set the filter function used by the plugin.
   * @param filter - A function which accepts a {@link CarmenGeojsonFeature} to filter out results from the Geocoding API response before they are included in the suggestions list. Return `true` to keep the item, `false` otherwise.
   */
  setFilter(e) {
    return this.options.filter = e, this;
  }
  /**
   * Set the geocoding api used by the plugin.
   */
  setGeocoderApi(e) {
    return this.geocoderApi = e, this;
  }
  /**
   * Get the geocoding endpoint the plugin is currently set to
   * @returns the geocoding API
   */
  getGeocoderApi() {
    return this.geocoderApi;
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param selected - the selected geojson feature
   */
  _handleMarker(e) {
    if (!this._map)
      return;
    this._removeMarker();
    const i = uc({}, {
      color: "#4668F2"
    }, this.options.marker);
    this.mapMarker = new this._maplibregl.Marker(i);
    let r;
    if (this.options.popup) {
      const c = uc({}, {}, this.options.popup);
      r = new this._maplibregl.Popup(c).setHTML(this.options.popupRender(e));
    }
    return e.center ? (this.mapMarker.setLngLat(e.center).addTo(this._map), this.options.popup && this.mapMarker.setPopup(r)) : e.geometry && e.geometry.type && e.geometry.type === "Point" && e.geometry.coordinates && (this.mapMarker.setLngLat(e.geometry.coordinates).addTo(this._map), this.options.popup && this.mapMarker.setPopup(r)), this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeMarker() {
    this.mapMarker && (this.mapMarker.remove(), this.mapMarker = null);
  }
  /**
   * Handle the placement of a result marking the selected result
   * @param results - the top results to display on the map
   */
  _handleResultMarkers(e) {
    if (!this._map)
      return;
    this._removeResultMarkers();
    let i = uc({}, {
      color: "#4668F2"
    }, this.options.showResultMarkers);
    for (const r of e) {
      let l;
      if (this.options.showResultMarkers) {
        this.options.showResultMarkers && this.options.showResultMarkers.element && (l = this.options.showResultMarkers.element.cloneNode(!0), i = uc(i, {
          element: l
        }));
        const c = new this._maplibregl.Marker(uc({}, i, {
          element: l
        }));
        let a;
        if (this.options.popup) {
          const y = uc({}, {}, this.options.popup);
          a = new this._maplibregl.Popup(y).setHTML(this.options.popupRender(r));
        }
        r.center ? (c.setLngLat(r.center).addTo(this._map), this.options.popup && c.setPopup(a)) : r.geometry && r.geometry.type && r.geometry.type === "Point" && r.geometry.coordinates && (c.setLngLat(r.geometry.coordinates).addTo(this._map), this.options.popup && c.setPopup(a)), this.resultMarkers.push(c);
      }
    }
    return this;
  }
  /**
   * Handle the removal of a result marker
   */
  _removeResultMarkers() {
    this.resultMarkers && this.resultMarkers.length > 0 && (this.resultMarkers.forEach(function(e) {
      e.remove();
    }), this.resultMarkers = []);
  }
  /**
   * Subscribe to events that happen within the plugin.
   * @param type - name of event. Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @param fn - function that's called when the event is emitted.
   */
  on(e, t) {
    return this._eventEmitter.on(e, t), this;
  }
  /**
   * Subscribe to events that happen within the plugin only once.
   * @param type - Event name.
   * Available events and the data passed into their respective event objects are:
   *
   * - __clear__ `Emitted when the input is cleared`
   * - __loading__ `{ query } Emitted when the geocoder is looking up a query`
   * - __results__ `{ results } Fired when the geocoder returns a response`
   * - __result__ `{ result } Fired when input is set`
   * - __error__ `{ error } Error as string`
   * @returns a Promise that resolves when the event is emitted.
   */
  once(e) {
    return new Promise((t) => {
      this._eventEmitter.once(e, t);
    });
  }
  /**
   * Remove an event
   * @param type - Event name.
   * @param fn - Function that should unsubscribe to the event emitted.
   */
  off(e, t) {
    return this._eventEmitter.removeListener(e, t), this;
  }
}
const Vq = {
  limitsUrl: "https://tilemaps.icgc.cat/vt/limits-tilejsonV3.json",
  geocoder: {
    peliasUrl1: "https://eines.icgc.cat/geocodificador/autocompletar?text=",
    peliasUrl2: "&layers=topo1%2Ctopo2%2Caddress&size=5"
  },
  mapOptions: {
    container: "map",
    center: {
      0: 1.537786,
      1: 41.837539
    },
    zoom: 7.5,
    bearing: 0,
    pitch: 0,
    hash: !1,
    style: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json.json",
    maxZoom: 18,
    maxPitch: 85
  },
  logoIcgcOptions: {
    logoUrlColor: "https://eines.icgc.cat/recursos/logos/icgc_logo_color.png",
    logoUrlWhite: "https://eines.icgc.cat/recursos/logos/icgc_logo_blanc.svg",
    logoLink: "https://www.icgc.cat",
    logoTitle: "Institut Cartogràfic i Geològic de Catalunya",
    logoWidth: 100,
    logoOpacity: 0.6
  },
  logoGencatOptions: {
    logoUrlColor: "https://eines.icgc.cat/recursos/logos/gencat_logo_color.png",
    logoUrlWhite: "https://eines.icgc.cat/recursos/logos/gencat_logo_blanc.png",
    logoLink: "https://web.gencat.cat/",
    logoTitle: "Generalitat de Catalunya",
    logoWidth: 100,
    logoOpacity: 0.6
  },
  map3dOptions: {
    spaceErrorFactor: 2,
    exaggeration: 1,
    zfactor: 48,
    minZoomRange: 15.5,
    maxZoomRange: 22,
    urlTilesetCities: "https://geoserveis.icgc.cat/servei/catalunya/ciutats/3dtiles/v1/tilesetV1.0.json",
    layerIdOrder: "place-isolated",
    sourceLayerFilterId: "place",
    minZoomFilter: 14,
    layerId3d: "edificisMapboxLayer",
    terrainSource: "ICGC5M",
    style3dName: "orto3d",
    imageIcon: "https://eines.icgc.cat/recursos//images/stick.png"
  },
  baseStyles: [
    {
      key: "TOPO",
      url: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_estandard.png"
    },
    {
      key: "ORTO",
      url: "https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"
    },
    {
      key: "ORTO3D",
      url: "https://eines.icgc.cat/recursos//styles/icgc_orto_3d.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_estandard.png"
    },
    {
      key: "ORTOHYBRID",
      url: "https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_orto_hibrida.png"
    },
    {
      key: "ADMIN",
      url: "https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_delimitacio_limits_administratius.png"
    },
    {
      key: "DARK",
      url: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_fosc.png"
    },
    {
      key: "LIGHT",
      url: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_mapa_base_gris.png"
    },
    {
      key: "GEOLOGY",
      url: "https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json",
      image: "https://visors.icgc.cat/contextmaps/imatges_estil/icgc_geologic_informacio.png"
    },
    {
      key: "RASTER",
      substyles: {
        TOPO: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_topo.jpg"
        },
        ADMIN: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_administratiu.jpg"
        },
        LIGHT: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic-gris/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_topo_gris.jpg"
        },
        STANDARD: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/estandard/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_estandard_0.jpg"
        },
        Simplified: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_simplificat.jpg"
        },
        ORTO: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto.jpg"
        },
        ORTOGREY: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-gris/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto_gris.jpg"
        },
        ORTOHYBRID: {
          url: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-hibrida/MON3857NW/{z}/{x}/{y}.png",
          image: "https://icgc-web-pro.s3.eu-central-1.amazonaws.com/produccio/s3fs-public/2024-10/mapabase_orto_hibida.jpg"
        }
      }
    }
  ],
  urlTerrainICGC: [
    {
      name: "ICGC5M",
      url: "https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png"
    },
    {
      name: "WORLD30M",
      url: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png",
      encoding: "terrarium"
    }
  ],
  ortoLayersICGC: [
    {
      name: "ortofotoColorProvisional",
      key: "ortofoto_color_provisional",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional"
    },
    {
      name: "ortofotoColor2023",
      key: "ortofoto_color_2023",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023"
    },
    {
      name: "ortofotoColor2022",
      key: "ortofoto_color_2022",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022"
    },
    {
      name: "ortofotoColor2021",
      key: "ortofoto_color_2021",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021"
    },
    {
      name: "ortofotoColor2020",
      key: "ortofoto_color_2020",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020"
    },
    {
      name: "ortofotoColor2019",
      key: "ortofoto_color_2019",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019"
    },
    {
      name: "ortofotoColor2018",
      key: "ortofoto_color_2018",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018"
    },
    {
      name: "ortofotoColor2017",
      key: "ortofoto_color_2017",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017"
    },
    {
      name: "ortofotoColor2016",
      key: "ortofoto_color_2016",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016"
    },
    {
      name: "ortofotoColor2015",
      key: "ortofoto_color_2015",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015"
    },
    {
      name: "ortofotoColor2014",
      key: "ortofoto_color_2014",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014"
    },
    {
      name: "ortofotoColor2013",
      key: "ortofoto_color_2013",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013"
    },
    {
      name: "ortofotoColor2012",
      key: "ortofoto_color_2012",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012"
    },
    {
      name: "ortofotoColor2011",
      key: "ortofoto_color_2011",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011"
    },
    {
      name: "ortofotoColor2010",
      key: "ortofoto_color_2010",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010"
    },
    {
      name: "ortofotoColor2009",
      key: "ortofoto_color_2009",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009"
    },
    {
      name: "ortofotoColor2008",
      key: "ortofoto_color_2008",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008"
    },
    {
      name: "ortofotoColor20062007",
      key: "ortofoto_color_2006-2007",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007"
    },
    {
      name: "ortofotoColor20042005",
      key: "ortofoto_color_2004-2005",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005"
    },
    {
      name: "ortofotoColor20002003",
      key: "ortofoto_color_2000-2003",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003"
    },
    {
      name: "ortofotoBlancINegre1998",
      key: "ortofoto_blanc_i_negre_1998",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998"
    },
    {
      name: "ortofotoBlancINegre19941997",
      key: "ortofoto_blanc_i_negre_1994-1997",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997"
    },
    {
      name: "ortofotoColor1993",
      key: "ortofoto_color_1993",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993"
    },
    {
      name: "ortofotoBlancINegre19831992",
      key: "ortofoto_blanc_i_negre_1983-1992",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992"
    },
    {
      name: "ortofotoBlancINegre19701977",
      key: "ortofoto_blanc_i_negre_1970-1977",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977"
    },
    {
      name: "ortofotoBlancINegre1956",
      key: "ortofoto_blanc_i_negre_1956",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956"
    },
    {
      name: "ortofotoBlancINegre1945",
      key: "ortofoto_blanc_i_negre_1945",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945"
    },
    {
      name: "ortofotoColorSerieAnual",
      key: "ortofoto_color_serie_anual",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual"
    },
    {
      name: "ortofotoInfraroigProvisional",
      key: "ortofoto_infraroig_provisional",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional"
    },
    {
      name: "ortofotoInfraroig2023",
      key: "ortofoto_infraroig_2023",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023"
    },
    {
      name: "ortofotoInfraroig2022",
      key: "ortofoto_infraroig_2022",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022"
    },
    {
      name: "ortofotoInfraroig2021",
      key: "ortofoto_infraroig_2021",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021"
    },
    {
      name: "ortofotoInfraroig2020",
      key: "ortofoto_infraroig_2020",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020"
    },
    {
      name: "ortofotoInfraroig2019",
      key: "ortofoto_infraroig_2019",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019"
    },
    {
      name: "ortofotoInfraroig2018",
      key: "ortofoto_infraroig_2018",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018"
    },
    {
      name: "ortofotoInfraroig2017",
      key: "ortofoto_infraroig_2017",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017"
    },
    {
      name: "ortofotoInfraroig2016",
      key: "ortofoto_infraroig_2016",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016"
    },
    {
      name: "ortofotoInfraroig2015",
      key: "ortofoto_infraroig_2015",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015"
    },
    {
      name: "ortofotoInfraroig2014",
      key: "ortofoto_infraroig_2014",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014"
    },
    {
      name: "ortofotoInfraroig2013",
      key: "ortofoto_infraroig_2013",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013"
    },
    {
      name: "ortofotoInfraroig2012",
      key: "ortofoto_infraroig_2012",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012"
    },
    {
      name: "ortofotoInfraroig2011",
      key: "ortofoto_infraroig_2011",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011"
    },
    {
      name: "ortofotoInfraroig2010",
      key: "ortofoto_infraroig_2010",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010"
    },
    {
      name: "ortofotoInfraroig2009",
      key: "ortofoto_infraroig_2009",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009"
    },
    {
      name: "ortofotoInfraroig2008",
      key: "ortofoto_infraroig_2008",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008"
    },
    {
      name: "ortofotoInfraroig20062007",
      key: "ortofoto_infraroig_2006-2007",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007"
    },
    {
      name: "ortofotoInfraroig19961997",
      key: "ortofoto_infraroig_1996-1997",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997"
    },
    {
      name: "ortofotoInfraroigSerieAnual",
      key: "ortofoto_infraroig_serie_anual",
      url: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"
    }
  ],
  vectorLayersICGC: [
    {
      name: "agrupacionsCensals2015",
      key: "agrupacions_censals_2015"
    },
    {
      name: "agrupacionsCensals2016",
      key: "agrupacions_censals_2016"
    },
    {
      name: "agrupacionsCensals2017",
      key: "agrupacions_censals_2017"
    },
    {
      name: "agrupacionsCensals2018",
      key: "agrupacions_censals_2018"
    },
    {
      name: "agrupacionsCensals2019",
      key: "agrupacions_censals_2019"
    },
    {
      name: "agrupacionsCensals2020",
      key: "agrupacions_censals_2020"
    },
    {
      name: "agrupacionsCensals2021",
      key: "agrupacions_censals_2021"
    },
    {
      name: "agrupacionsCensalsVigent",
      key: "agrupacions_censals_vigent"
    },
    {
      name: "agrupacionsCensalsVigentText",
      key: "agrupacions_censals_vigent_text"
    },
    {
      name: "areesBasiquesPolicials2019",
      key: "arees_basiques_policials_2019"
    },
    {
      name: "areesBasiquesPolicials2020",
      key: "arees_basiques_policials_2020"
    },
    {
      name: "areesBasiquesPolicials2022",
      key: "arees_basiques_policials_2022"
    },
    {
      name: "areesBasiquesPolicialsVigent",
      key: "arees_basiques_policials_vigent"
    },
    {
      name: "areesBasiquesPolicialsVigentText",
      key: "arees_basiques_policials_vigent_text"
    },
    {
      name: "areesBasiquesSalutVigent",
      key: "arees_basiques_salut_vigent"
    },
    {
      name: "areesBasiquesServeisSocialsVigent",
      key: "arees_basiques_serveis_socials_vigent"
    },
    {
      name: "areesBasiquesServeisSocialsVigentText",
      key: "arees_basiques_serveis_socials_vigent_text"
    },
    {
      name: "areesGestioAssistencialVigent",
      key: "arees_gestio_assistencial_vigent"
    },
    {
      name: "areesHidrogeologiquesAquifersVigent",
      key: "arees_hidrogeologiques_aquifers_vigent"
    },
    {
      name: "catalunyaVigent",
      key: "catalunya_vigent"
    },
    {
      name: "catalunyaVigentText",
      key: "catalunya_vigent_text"
    },
    {
      name: "comarques2022",
      key: "comarques_2022"
    },
    {
      name: "comarquesVigent",
      key: "comarques_vigent"
    },
    {
      name: "comarquesVigentText",
      key: "comarques_vigent_text"
    },
    {
      name: "districtesCensals2015",
      key: "districtes_censals_2015"
    },
    {
      name: "districtesCensals2016",
      key: "districtes_censals_2016"
    },
    {
      name: "districtesCensals2017",
      key: "districtes_censals_2017"
    },
    {
      name: "districtesCensals2018",
      key: "districtes_censals_2018"
    },
    {
      name: "districtesCensals2019",
      key: "districtes_censals_2019"
    },
    {
      name: "districtesCensals2020",
      key: "districtes_censals_2020"
    },
    {
      name: "districtesCensals2021",
      key: "districtes_censals_2021"
    },
    {
      name: "districtesCensals2022",
      key: "districtes_censals_2022"
    },
    {
      name: "districtesCensals2023",
      key: "districtes_censals_2023"
    },
    {
      name: "districtesCensalsVigent",
      key: "districtes_censals_vigent"
    },
    {
      name: "districtesCensalsVigentText",
      key: "districtes_censals_vigent_text"
    },
    {
      name: "incendisForestalsVigent",
      key: "incendis_forestals_vigent"
    },
    {
      name: "incendisForestalsVigentText",
      key: "incendis_forestals_vigent_text"
    },
    {
      name: "municipis2022",
      key: "municipis_2022"
    },
    {
      name: "municipis2022Text",
      key: "municipis_2022_text"
    },
    {
      name: "municipisVigent",
      key: "municipis_vigent"
    },
    {
      name: "municipisVigentText",
      key: "municipis_vigent_text"
    },
    {
      name: "partitsJudicialsVigent",
      key: "partits_judicials_vigent"
    },
    {
      name: "partitsJudicialsVigentText",
      key: "partits_judicials_vigent_text"
    },
    {
      name: "plaTerritorial2015",
      key: "pla_territorial_2015"
    },
    {
      name: "plaTerritorialVigent",
      key: "pla_territorial_vigent"
    },
    {
      name: "plaTerritorialVigentText",
      key: "pla_territorial_vigent_text"
    },
    {
      name: "provinciesVigent",
      key: "provincies_vigent"
    },
    {
      name: "provinciesVigentText",
      key: "provincies_vigent_text"
    },
    {
      name: "regionsPolicialsVigent",
      key: "regions_policials_vigent"
    },
    {
      name: "regionsPolicialsVigentText",
      key: "regions_policials_vigent_text"
    },
    {
      name: "regionsSanitariesVigent",
      key: "regions_sanitaries_vigent"
    },
    {
      name: "regionsSanitariesVigentText",
      key: "regions_sanitaries_vigent_text"
    },
    {
      name: "seccionsCensals2015",
      key: "seccions_censals_2015"
    },
    {
      name: "seccionsCensals2016",
      key: "seccions_censals_2016"
    },
    {
      name: "seccionsCensals2017",
      key: "seccions_censals_2017"
    },
    {
      name: "seccionsCensals2018",
      key: "seccions_censals_2018"
    },
    {
      name: "seccionsCensals2019",
      key: "seccions_censals_2019"
    },
    {
      name: "seccionsCensals2020",
      key: "seccions_censals_2020"
    },
    {
      name: "seccionsCensals2021",
      key: "seccions_censals_2021"
    },
    {
      name: "seccionsCensals2022",
      key: "seccions_censals_2022"
    },
    {
      name: "seccionsCensals2023",
      key: "seccions_censals_2023"
    },
    {
      name: "seccionsCensalsVigent",
      key: "seccions_censals_vigent"
    },
    {
      name: "seccionsCensalsVigentText",
      key: "seccions_censals_vigent_text"
    },
    {
      name: "sectorsSanitarisVigent",
      key: "sectors_sanitaris_vigent"
    },
    {
      name: "vegueriesVigent",
      key: "vegueries_vigent"
    },
    {
      name: "vegueriesVigentText",
      key: "vegueries_vigent_text"
    }
  ],
  vectorLayers: [
    {
      key: "cobertes2018",
      url: "https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json",
      legend: "https://eines.icgc.cat/recursos//images/llegendaCobertesSol2018.jpg"
    }
  ],
  wmsLayers: [
    {
      key: "espaisInteresGeologic",
      layer: "",
      url: "https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"
    },
    {
      key: "gravimetriaBouguer500000",
      layer: "",
      url: "https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"
    },
    {
      key: "cobertesSol2018",
      layer: "",
      url: "https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}"
    },
    {
      key: "administratiu",
      layer: "",
      url: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png"
    },
    {
      key: "simplificat",
      layer: "",
      url: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png"
    },
    {
      key: "cims",
      layer: "",
      url: "https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455"
    },
    {
      key: "cobertesSol",
      layer: "",
      url: "http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"
    }
  ],
  fgbLayers: [
    {
      name: "agrupacionsCensalsVigent",
      key: "agrupacions_censals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb"
    },
    {
      name: "agrupacionsCensalsVigentText",
      key: "agrupacions_censals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb"
    },
    {
      name: "areesBasiquesPolicialsVigent",
      key: "arees_basiques_policials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb"
    },
    {
      name: "areesBasiquesPolicialsVigentText",
      key: "arees_basiques_policials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb"
    },
    {
      name: "areesBasiquesSalutVigent",
      key: "arees_basiques_salut_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb"
    },
    {
      name: "areesBasiquesServeisSocialsVigent",
      key: "arees_basiques_serveis_socials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb"
    },
    {
      name: "areesBasiquesServeisSocialsVigentText",
      key: "arees_basiques_serveis_socials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb"
    },
    {
      name: "areesGestioAssistencialVigent",
      key: "arees_gestio_assistencial_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb"
    },
    {
      name: "areesHidrogeologiquesAquifersVigent",
      key: "arees_hidrogeologiques_aquifers_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb"
    },
    {
      name: "catalunyaVigent",
      key: "catalunya_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb"
    },
    {
      name: "catalunyaVigentText",
      key: "catalunya_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb"
    },
    {
      name: "comarquesVigent",
      key: "comarques_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb"
    },
    {
      name: "comarquesVigentText",
      key: "comarques_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb"
    },
    {
      name: "districtesCensalsVigent",
      key: "districtes_censals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb"
    },
    {
      name: "districtesCensalsVigentText",
      key: "districtes_censals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb"
    },
    {
      name: "incendisForestalsVigent",
      key: "incendis_forestals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb"
    },
    {
      name: "incendisForestalsVigentText",
      key: "incendis_forestals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb"
    },
    {
      name: "municipisVigent",
      key: "municipis_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb"
    },
    {
      name: "municipisVigentText",
      key: "municipis_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb"
    },
    {
      name: "partitsJudicialsVigent",
      key: "partits_judicials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb"
    },
    {
      name: "partitsJudicialsVigentText",
      key: "partits_judicials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb"
    },
    {
      name: "plaTerritorialVigent",
      key: "pla_territorial_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb"
    },
    {
      name: "plaTerritorialVigentText",
      key: "pla_territorial_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb"
    },
    {
      name: "provinciesVigent",
      key: "provincies_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb"
    },
    {
      name: "provinciesVigentText",
      key: "provincies_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb"
    },
    {
      name: "regionsPolicialsVigent",
      key: "regions_policials_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb"
    },
    {
      name: "regionsPolicialsVigentText",
      key: "regions_policials_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb"
    },
    {
      name: "regionsSanitariesVigent",
      key: "regions_sanitaries_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb"
    },
    {
      name: "regionsSanitariesVigentText",
      key: "regions_sanitaries_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb"
    },
    {
      name: "seccionsCensalsVigent",
      key: "seccions_censals_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb"
    },
    {
      name: "seccionsCensalsVigentText",
      key: "seccions_censals_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb"
    },
    {
      name: "sectorsSanitarisVigent",
      key: "sectors_sanitaris_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb"
    },
    {
      name: "vegueriesVigent",
      key: "vegueries_vigent",
      url: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb"
    },
    {
      name: "vegueriesVigentText",
      key: "vegueries_vigent_text",
      url: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"
    }
  ]
}, qq = {
  TOPO: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_topografic.json",
  ORTO: "https://geoserveis.icgc.cat/styles/icgc_orto_estandard.json",
  ORTO3D: "https://eines.icgc.cat/recursos//styles/icgc_orto_3d.json",
  ORTOHYBRID: "https://geoserveis.icgc.cat/styles/icgc_orto_hibrida.json",
  ADMIN: "https://geoserveis.icgc.cat/styles/icgc_limits_administratius_gris.json",
  DARK: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_fosc.json",
  LIGHT: "https://geoserveis.icgc.cat/styles/icgc_mapa_base_gris.json",
  GEOLOGY: "https://geoserveis.icgc.cat/styles/icgc_geologic_informacio.json",
  RASTER: {
    TOPO: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic/MON3857NW/{z}/{x}/{y}.png",
    ADMIN: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png",
    LIGHT: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/topografic-gris/MON3857NW/{z}/{x}/{y}.png",
    STANDARD: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/estandard/MON3857NW/{z}/{x}/{y}.png",
    SIMPLIFIED: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png",
    ORTO: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto/MON3857NW/{z}/{x}/{y}.png",
    ORTOGREY: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-gris/MON3857NW/{z}/{x}/{y}.png",
    ORTOHYBRID: "https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/orto-hibrida/MON3857NW/{z}/{x}/{y}.png"
  }
}, Hq = {
  ICGC5M: "https://tilemaps.icgc.cat/tileserver/tileserver/terreny-5m-30m-rgb-extent/{z}/{x}/{y}.png",
  WORLD30M: "https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png"
}, Wq = {
  Orto: {
    ortofotoColorProvisional: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_provisional",
    ortofotoColor2023: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2023",
    ortofotoColor2022: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2022",
    ortofotoColor2021: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2021",
    ortofotoColor2020: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2020",
    ortofotoColor2019: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2019",
    ortofotoColor2018: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2018",
    ortofotoColor2017: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2017",
    ortofotoColor2016: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2016",
    ortofotoColor2015: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2015",
    ortofotoColor2014: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2014",
    ortofotoColor2013: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2013",
    ortofotoColor2012: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2012",
    ortofotoColor2011: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2011",
    ortofotoColor2010: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2010",
    ortofotoColor2009: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2009",
    ortofotoColor2008: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2008",
    ortofotoColor20062007: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2006-2007",
    ortofotoColor20042005: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2004-2005",
    ortofotoColor20002003: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_2000-2003",
    ortofotoBlancINegre1998: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1998",
    ortofotoBlancINegre19941997: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1994-1997",
    ortofotoColor1993: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_1993",
    ortofotoBlancINegre19831992: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1983-1992",
    ortofotoBlancINegre19701977: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1970-1977",
    ortofotoBlancINegre1956: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1956",
    ortofotoBlancINegre1945: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_blanc_i_negre_1945",
    ortofotoColorSerieAnual: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_color_serie_anual",
    ortofotoInfraroigProvisional: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_provisional",
    ortofotoInfraroig2023: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2023",
    ortofotoInfraroig2022: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2022",
    ortofotoInfraroig2021: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2021",
    ortofotoInfraroig2020: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2020",
    ortofotoInfraroig2019: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2019",
    ortofotoInfraroig2018: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2018",
    ortofotoInfraroig2017: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2017",
    ortofotoInfraroig2016: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2016",
    ortofotoInfraroig2015: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2015",
    ortofotoInfraroig2014: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2014",
    ortofotoInfraroig2013: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2013",
    ortofotoInfraroig2012: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2012",
    ortofotoInfraroig2011: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2011",
    ortofotoInfraroig2010: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2010",
    ortofotoInfraroig2009: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2009",
    ortofotoInfraroig2008: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2008",
    ortofotoInfraroig20062007: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_2006-2007",
    ortofotoInfraroig19961997: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_1996-1997",
    ortofotoInfraroigSerieAnual: "https://geoserveis.icgc.cat/servei/catalunya/orto-territorial/wms?&bbox={bbox-epsg-3857}&format=image/png&service=WMS&version=1.1.1&request=GetMap&STYLES=&srs=EPSG:3857&transparent=true&width=256&height=256&layers=ortofoto_infraroig_serie_anual"
  },
  VectorAdmin: {
    agrupacionsCensals2015: "agrupacions_censals_2015",
    agrupacionsCensals2016: "agrupacions_censals_2016",
    agrupacionsCensals2017: "agrupacions_censals_2017",
    agrupacionsCensals2018: "agrupacions_censals_2018",
    agrupacionsCensals2019: "agrupacions_censals_2019",
    agrupacionsCensals2020: "agrupacions_censals_2020",
    agrupacionsCensals2021: "agrupacions_censals_2021",
    agrupacionsCensalsVigent: "agrupacions_censals_vigent",
    agrupacionsCensalsVigentText: "agrupacions_censals_vigent_text",
    areesBasiquesPolicials2019: "arees_basiques_policials_2019",
    areesBasiquesPolicials2020: "arees_basiques_policials_2020",
    areesBasiquesPolicials2022: "arees_basiques_policials_2022",
    areesBasiquesPolicialsVigent: "arees_basiques_policials_vigent",
    areesBasiquesPolicialsVigentText: "arees_basiques_policials_vigent_text",
    areesBasiquesSalutVigent: "arees_basiques_salut_vigent",
    areesBasiquesServeisSocialsVigent: "arees_basiques_serveis_socials_vigent",
    areesBasiquesServeisSocialsVigentText: "arees_basiques_serveis_socials_vigent_text",
    areesGestioAssistencialVigent: "arees_gestio_assistencial_vigent",
    areesHidrogeologiquesAquifersVigent: "arees_hidrogeologiques_aquifers_vigent",
    catalunyaVigent: "catalunya_vigent",
    catalunyaVigentText: "catalunya_vigent_text",
    comarques2022: "comarques_2022",
    comarquesVigent: "comarques_vigent",
    comarquesVigentText: "comarques_vigent_text",
    districtesCensals2015: "districtes_censals_2015",
    districtesCensals2016: "districtes_censals_2016",
    districtesCensals2017: "districtes_censals_2017",
    districtesCensals2018: "districtes_censals_2018",
    districtesCensals2019: "districtes_censals_2019",
    districtesCensals2020: "districtes_censals_2020",
    districtesCensals2021: "districtes_censals_2021",
    districtesCensals2022: "districtes_censals_2022",
    districtesCensals2023: "districtes_censals_2023",
    districtesCensalsVigent: "districtes_censals_vigent",
    districtesCensalsVigentText: "districtes_censals_vigent_text",
    incendisForestalsVigent: "incendis_forestals_vigent",
    incendisForestalsVigentText: "incendis_forestals_vigent_text",
    municipis2022: "municipis_2022",
    municipis2022Text: "municipis_2022_text",
    municipisVigent: "municipis_vigent",
    municipisVigentText: "municipis_vigent_text",
    partitsJudicialsVigent: "partits_judicials_vigent",
    partitsJudicialsVigentText: "partits_judicials_vigent_text",
    plaTerritorial2015: "pla_territorial_2015",
    plaTerritorialVigent: "pla_territorial_vigent",
    plaTerritorialVigentText: "pla_territorial_vigent_text",
    provinciesVigent: "provincies_vigent",
    provinciesVigentText: "provincies_vigent_text",
    regionsPolicialsVigent: "regions_policials_vigent",
    regionsPolicialsVigentText: "regions_policials_vigent_text",
    regionsSanitariesVigent: "regions_sanitaries_vigent",
    regionsSanitariesVigentText: "regions_sanitaries_vigent_text",
    seccionsCensals2015: "seccions_censals_2015",
    seccionsCensals2016: "seccions_censals_2016",
    seccionsCensals2017: "seccions_censals_2017",
    seccionsCensals2018: "seccions_censals_2018",
    seccionsCensals2019: "seccions_censals_2019",
    seccionsCensals2020: "seccions_censals_2020",
    seccionsCensals2021: "seccions_censals_2021",
    seccionsCensals2022: "seccions_censals_2022",
    seccionsCensals2023: "seccions_censals_2023",
    seccionsCensalsVigent: "seccions_censals_vigent",
    seccionsCensalsVigentText: "seccions_censals_vigent_text",
    sectorsSanitarisVigent: "sectors_sanitaris_vigent",
    vegueriesVigent: "vegueries_vigent",
    vegueriesVigentText: "vegueries_vigent_text"
  },
  FGBAdmin: {
    agrupacionsCensalsVigent: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent.fgb",
    agrupacionsCensalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/agrupacions_censals_vigent_text.fgb",
    areesBasiquesPolicialsVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent.fgb",
    areesBasiquesPolicialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_policials_vigent_text.fgb",
    areesBasiquesSalutVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_salut_vigent.fgb",
    areesBasiquesServeisSocialsVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent.fgb",
    areesBasiquesServeisSocialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/arees_basiques_serveis_socials_vigent_text.fgb",
    areesGestioAssistencialVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_gestio_assistencial_vigent.fgb",
    areesHidrogeologiquesAquifersVigent: "https://tilemaps.icgc.cat/vector/fgb/arees_hidrogeologiques_aquifers_vigent.fgb",
    catalunyaVigent: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent.fgb",
    catalunyaVigentText: "https://tilemaps.icgc.cat/vector/fgb/catalunya_vigent_text.fgb",
    comarquesVigent: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent.fgb",
    comarquesVigentText: "https://tilemaps.icgc.cat/vector/fgb/comarques_vigent_text.fgb",
    districtesCensalsVigent: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent.fgb",
    districtesCensalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/districtes_censals_vigent_text.fgb",
    incendisForestalsVigent: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent.fgb",
    incendisForestalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/incendis_forestals_vigent_text.fgb",
    municipisVigent: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent.fgb",
    municipisVigentText: "https://tilemaps.icgc.cat/vector/fgb/municipis_vigent_text.fgb",
    partitsJudicialsVigent: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent.fgb",
    partitsJudicialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/partits_judicials_vigent_text.fgb",
    plaTerritorialVigent: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent.fgb",
    plaTerritorialVigentText: "https://tilemaps.icgc.cat/vector/fgb/pla_territorial_vigent_text.fgb",
    provinciesVigent: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent.fgb",
    provinciesVigentText: "https://tilemaps.icgc.cat/vector/fgb/provincies_vigent_text.fgb",
    regionsPolicialsVigent: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent.fgb",
    regionsPolicialsVigentText: "https://tilemaps.icgc.cat/vector/fgb/regions_policials_vigent_text.fgb",
    regionsSanitariesVigent: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent.fgb",
    regionsSanitariesVigentText: "https://tilemaps.icgc.cat/vector/fgb/regions_sanitaries_vigent_text.fgb",
    seccionsCensalsVigent: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent.fgb",
    seccionsCensalsVigentText: "https://tilemaps.icgc.cat/vector/fgb/seccions_censals_vigent_text.fgb",
    sectorsSanitarisVigent: "https://tilemaps.icgc.cat/vector/fgb/sectors_sanitaris_vigent.fgb",
    vegueriesVigent: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent.fgb",
    vegueriesVigentText: "https://tilemaps.icgc.cat/vector/fgb/vegueries_vigent_text.fgb"
  },
  Vector: {
    cobertes2018: "https://tilemaps.icgc.cat/tileserver/cobertes_tilejson.json"
  },
  WMS: {
    espaisInteresGeologic: "https://geoserveis.icgc.cat/servei/catalunya/espais-interes-geologic/wms/service?&service=WMS&request=GetMap&layers=espais-interes-geologic&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}",
    gravimetriaBouguer500000: "https://geoserveis.icgc.cat/servei/catalunya/gravimetria/wms/service?&service=WMS&request=GetMap&layers=anomalia_bouguer_500000&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}",
    cobertesSol2018: "https://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms/service?&service=WMS&request=GetMap&layers=cobertes_2018&styles=&format=image%2Fpng&transparent=true&version=1.1.1&tipus=wms&width=512&height=512&srs=EPSG%3A3857&bbox={bbox-epsg-3857}",
    administratiu: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/administratiu/MON3857NW/{z}/{x}/{y}.png",
    simplificat: "http://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/simplificat/MON3857NW/{z}/{x}/{y}.png",
    cims: "https://geoserveis.icgc.cat/icc_100cims/wms/service?REQUEST=GetMap&SERVICE=WMS&VERSION=1.1.1&LAYERS=0&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&SRS=EPSG:25831&BBOX=137118.923076923,4488408.75,650959.076923077,4749634.75&WIDTH=895&HEIGHT=455",
    cobertesSol: "http://geoserveis.icgc.cat/servei/catalunya/cobertes-sol/wms?REQUEST=GetMap&SERVICE=WMS&VERSION=1.3.0&LAYERS=cobertes_2009&STYLES=&FORMAT=image/png&BGCOLOR=0xFFFFFF&TRANSPARENT=TRUE&CRS=EPSG:25831&BBOX=374110.828167253,4639230.79853085,452621.120632226,4703578.45000215&WIDTH=1020&HEIGHT=836"
  }
}, Hh = {
  defaultOptions: Vq,
  Styles: qq,
  Terrains: Hq,
  Layers: Wq
};
class Zq {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    let t = Hh.defaultOptions;
    return this._map = e, this._img1 = document.createElement("img"), this._img1.className = "maplibregl-ctrl", this._img1.src = this.options.color ? t.logoIcgcOptions.logoUrlColor : t.logoIcgcOptions.logoUrlWhite, this._img1.width = t.logoIcgcOptions.logoWidth, this._img1.title = t.logoIcgcOptions.logoTitle, this._img1.style.opacity = t.logoIcgcOptions.logoOpacity, this.link1 = document.createElement("a"), this.link1.href = t.logoIcgcOptions.logoLink, this.link1.target = "_blank", this.link1.appendChild(this._img1), this._container1 = document.createElement("div"), this._container1.className = "maplibregl-ctrl", this._container1.style.width = `${t.logoIcgcOptions.logoWidth}px`, this._container1.appendChild(this.link1), this._img2 = document.createElement("img"), this._img2.className = "maplibregl-ctrl", this._img2.src = this.options.color ? t.logoGencatOptions.logoUrlColor : t.logoGencatOptions.logoUrlWhite, this._img2.width = t.logoGencatOptions.logoWidth, this._img2.title = t.logoGencatOptions.logoTitle, this._img2.style.opacity = t.logoGencatOptions.logoOpacity, this.link2 = document.createElement("a"), this.link2.href = t.logoGencatOptions.logoLink, this.link2.target = "_blank", this.link2.appendChild(this._img2), this._container2 = document.createElement("div"), this._container2.className = "maplibregl-ctrl", this._container2.style.width = `${t.logoGencatOptions.logoWidth}px`, this._container2.appendChild(this.link2), this._mainContainer = document.createElement("div"), this._mainContainer.className = "divLogos", this._mainContainer.style = "display: flex", this._mainContainer.appendChild(this._container1), this._mainContainer.appendChild(this._container2), this._mainContainer;
  }
}
class $q {
  constructor(e) {
    this.options = e || {};
  }
  onAdd(e) {
    this._map = e, this._img1 = document.createElement("img"), this._img1.src = this.options.url, this._img1.width = 150, this._img1.title = 300, this.controlContainer = document.createElement("div"), this.controlContainer.classList.add("maplibregl-ctrl"), this.controlContainer.classList.add("maplibregl-ctrl-group"), this.legendContainer = document.createElement("div"), this.legendContainer.classList.add("maplibregl-legend-list"), this.legendButton = document.createElement("button"), this.legendButton.classList.add("maplibregl-ctrl-icon"), this.legendButton.classList.add("maplibregl-legend-switcher"), this.legendButton.addEventListener("click", () => {
      this.legendButton.style.display = "none", this.legendContainer.style.display = "block";
    }), document.addEventListener("click", this.onDocumentClick), this.controlContainer.appendChild(this.legendButton), this.controlContainer.appendChild(this.legendContainer), this.closeButton = document.createElement("button"), this.closeButton.textContent = "x", this.closeButton.classList.add("maplibregl-legend-close-button"), this.closeButton.addEventListener("click", () => {
      this.legendButton.style.display = "block", this.legendContainer.style.display = "none";
    }), this.legendContainer.appendChild(this.closeButton);
    const t = document.createElement("label");
    return t.classList.add("maplibregl-legend-title-label"), t.textContent = this.options.idLayer || "Llegenda", this.legendContainer.appendChild(t), this.legendContainer.appendChild(document.createElement("br")), this.legendContainer.appendChild(this._img1), this.controlContainer;
  }
}
var bf = P3.prototype, R1 = "WGS 84";
function P3(n) {
  n !== void 0 && (R1 = n), this.setEllipsoid(R1);
}
bf.convertLatLngToUtm = function(n, e, t) {
  var i;
  if (this.status)
    return "No ecclipsoid data associated with unknown datum: " + R1;
  if (!Number.isInteger(t))
    return "Precision is not integer number.";
  n = parseFloat(n), e = parseFloat(e);
  var r = e, l = this.toRadians(n), c = this.toRadians(r);
  r >= 8 && r <= 13 && n > 54.5 && n < 58 || n >= 56 && n < 64 && r >= 3 && r < 12 ? i = 32 : (i = (r + 180) / 6 + 1, n >= 72 && n < 84 && (r >= 0 && r < 9 ? i = 31 : r >= 9 && r < 21 ? i = 33 : r >= 21 && r < 33 ? i = 35 : r >= 33 && r < 42 && (i = 37))), i = parseInt(i);
  var a = (i - 1) * 6 - 180 + 3, g = this.toRadians(a), y = this.getUtmLetterDesignator(n), A = this.eccSquared / (1 - this.eccSquared), C = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(l) * Math.sin(l)), I = Math.tan(l) * Math.tan(l), S = A * Math.cos(l) * Math.cos(l), F = Math.cos(l) * (c - g), U = this.a * ((1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256) * l - (3 * this.eccSquared / 8 + 3 * this.eccSquared * this.eccSquared / 32 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(2 * l) + (15 * this.eccSquared * this.eccSquared / 256 + 45 * this.eccSquared * this.eccSquared * this.eccSquared / 1024) * Math.sin(4 * l) - 35 * this.eccSquared * this.eccSquared * this.eccSquared / 3072 * Math.sin(6 * l)), V = parseFloat(0.9996 * C * (F + (1 - I + S) * F * F * F / 6 + (5 - 18 * I + I * I + 72 * S - 58 * A) * F * F * F * F * F / 120) + 5e5), W = parseFloat(0.9996 * (U + C * Math.tan(l) * (F * F / 2 + (5 - I + 9 * S + 4 * S * S) * F * F * F * F / 24 + (61 - 58 * I + I * I + 600 * S - 330 * A) * F * F * F * F * F * F / 720)));
  return n < 0 && (W += 1e7), W = q5(W, t), V = q5(V, t), {
    Easting: V,
    Northing: W,
    ZoneNumber: parseInt(i),
    ZoneLetter: y
  };
};
bf.convertUtmToLatLng = function(n, e, t, i) {
  var r = (1 - Math.sqrt(1 - this.eccSquared)) / (1 + Math.sqrt(1 - this.eccSquared)), l = n - 5e5, c = e, a = t, g = i;
  if (n === void 0)
    return "Please pass the UTMEasting!";
  if (e === void 0)
    return "Please pass the UTMNorthing!";
  if (t === void 0)
    return "Please pass the UTMZoneNumber!";
  if (i === void 0)
    return "Please pass the UTMZoneLetter!";
  ["N", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"].indexOf(g) !== -1 || (c -= 1e7);
  var y = (a - 1) * 6 - 180 + 3, A = this.eccSquared / (1 - this.eccSquared), C = c / 0.9996, I = C / (this.a * (1 - this.eccSquared / 4 - 3 * this.eccSquared * this.eccSquared / 64 - 5 * this.eccSquared * this.eccSquared * this.eccSquared / 256)), S = I + (3 * r / 2 - 27 * r * r * r / 32) * Math.sin(2 * I) + (21 * r * r / 16 - 55 * r * r * r * r / 32) * Math.sin(4 * I) + 151 * r * r * r / 96 * Math.sin(6 * I);
  this.toDegrees(S);
  var F = this.a / Math.sqrt(1 - this.eccSquared * Math.sin(S) * Math.sin(S)), U = Math.tan(S) * Math.tan(S), V = A * Math.cos(S) * Math.cos(S), W = this.a * (1 - this.eccSquared) / Math.pow(1 - this.eccSquared * Math.sin(S) * Math.sin(S), 1.5), X = l / (F * 0.9996), de = S - F * Math.tan(S) / W * (X * X / 2 - (5 + 3 * U + 10 * V - 4 * V * V - 9 * A) * X * X * X * X / 24 + (61 + 90 * U + 298 * V + 45 * U * U - 252 * A - 3 * V * V) * X * X * X * X * X * X / 720);
  de = this.toDegrees(de);
  var ie = (X - (1 + 2 * U + V) * X * X * X / 6 + (5 - 2 * V + 28 * U - 3 * V * V + 8 * A + 24 * U * U) * X * X * X * X * X / 120) / Math.cos(S);
  return ie = y + this.toDegrees(ie), {
    lat: de,
    lng: ie
  };
};
bf.getUtmLetterDesignator = function(n) {
  return n = parseFloat(n), 84 >= n && n >= 72 ? "X" : 72 > n && n >= 64 ? "W" : 64 > n && n >= 56 ? "V" : 56 > n && n >= 48 ? "U" : 48 > n && n >= 40 ? "T" : 40 > n && n >= 32 ? "S" : 32 > n && n >= 24 ? "R" : 24 > n && n >= 16 ? "Q" : 16 > n && n >= 8 ? "P" : 8 > n && n >= 0 ? "N" : 0 > n && n >= -8 ? "M" : -8 > n && n >= -16 ? "L" : -16 > n && n >= -24 ? "K" : -24 > n && n >= -32 ? "J" : -32 > n && n >= -40 ? "H" : -40 > n && n >= -48 ? "G" : -48 > n && n >= -56 ? "F" : -56 > n && n >= -64 ? "E" : -64 > n && n >= -72 ? "D" : -72 > n && n >= -80 ? "C" : "Z";
};
bf.setEllipsoid = function(n) {
  switch (n) {
    case "Airy":
      this.a = 6377563, this.eccSquared = 667054e-8;
      break;
    case "Australian National":
      this.a = 6378160, this.eccSquared = 6694542e-9;
      break;
    case "Bessel 1841":
      this.a = 6377397, this.eccSquared = 6674372e-9;
      break;
    case "Bessel 1841 Nambia":
      this.a = 6377484, this.eccSquared = 6674372e-9;
      break;
    case "Clarke 1866":
      this.a = 6378206, this.eccSquared = 6768658e-9;
      break;
    case "Clarke 1880":
      this.a = 6378249, this.eccSquared = 6803511e-9;
      break;
    case "Everest":
      this.a = 6377276, this.eccSquared = 6637847e-9;
      break;
    case "Fischer 1960 Mercury":
      this.a = 6378166, this.eccSquared = 6693422e-9;
      break;
    case "Fischer 1968":
      this.a = 6378150, this.eccSquared = 6693422e-9;
      break;
    case "GRS 1967":
      this.a = 6378160, this.eccSquared = 6694605e-9;
      break;
    case "GRS 1980":
      this.a = 6378137, this.eccSquared = 669438e-8;
      break;
    case "Helmert 1906":
      this.a = 6378200, this.eccSquared = 6693422e-9;
      break;
    case "Hough":
      this.a = 6378270, this.eccSquared = 672267e-8;
      break;
    case "International":
      this.a = 6378388, this.eccSquared = 672267e-8;
      break;
    case "Krassovsky":
      this.a = 6378245, this.eccSquared = 6693422e-9;
      break;
    case "Modified Airy":
      this.a = 6377340, this.eccSquared = 667054e-8;
      break;
    case "Modified Everest":
      this.a = 6377304, this.eccSquared = 6637847e-9;
      break;
    case "Modified Fischer 1960":
      this.a = 6378155, this.eccSquared = 6693422e-9;
      break;
    case "South American 1969":
      this.a = 6378160, this.eccSquared = 6694542e-9;
      break;
    case "WGS 60":
      this.a = 6378165, this.eccSquared = 6693422e-9;
      break;
    case "WGS 66":
      this.a = 6378145, this.eccSquared = 6694542e-9;
      break;
    case "WGS 72":
      this.a = 6378135, this.eccSquared = 6694318e-9;
      break;
    case "ED50":
      this.a = 6378388, this.eccSquared = 672267e-8;
      break;
    case "WGS 84":
    case "EUREF89":
    case "ETRS89":
      this.a = 6378137, this.eccSquared = 669438e-8;
      break;
    default:
      this.status = !0;
  }
};
bf.toDegrees = function(n) {
  return n / Math.PI * 180;
};
bf.toRadians = function(n) {
  return n * Math.PI / 180;
};
function q5(n, e) {
  var t = Math.pow(10, e);
  return Math.round(n * t) / t;
}
var Xq = P3;
const Yq = /* @__PURE__ */ $m(Xq);
class Jq {
  constructor(e) {
    this.options = e || {}, this.options.utm = this.options.hasOwnProperty("utm") ? this.options.utm : !0, this.options.lonlat = this.options.hasOwnProperty("lonlat") ? this.options.lonlat : !0;
  }
  onAdd(e) {
    const t = new Yq();
    return this._map = e, this._container = document.createElement("div"), this._container.className = "maplibregl-ctrl coordControl", this._container.style.width = `${this.options.width || "225px"}`, this._map.on("mousemove", (i) => {
      const r = i.lngLat.lat, l = i.lngLat.lng;
      let c = "", a = "";
      const g = t.convertLatLngToUtm(r, l, 2), y = r > 0 ? "N" : "S";
      this.options.utm && (c = `ETRS89 UTM ${g.ZoneNumber}${y} X:<b> ${g.Easting}</b> Y:<b> ${g.Northing}</b> <br>`), this.options.lonlat && (a = `WGS 84 Lon:<b> ${l.toFixed(5)}</b>  Lat:<b> ${r.toFixed(5)}</b>`);
      const A = `${c}${a}`;
      this._container.innerHTML = A;
    }), this._container;
  }
  _lookUTM31(e, t) {
    var i = 0, r = 0, l = 6, c = 84;
    return e >= i && e <= l && t >= r && t <= c;
  }
  onRemove() {
    this._container.parentNode.removeChild(this._container), this._map = void 0;
  }
}
function I3(n, e) {
  return function() {
    return n.apply(e, arguments);
  };
}
const {
  toString: Kq
} = Object.prototype, {
  getPrototypeOf: ov
} = Object, d_ = /* @__PURE__ */ ((n) => (e) => {
  const t = Kq.call(e);
  return n[t] || (n[t] = t.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null)), Tc = (n) => (n = n.toLowerCase(), (e) => d_(e) === n), f_ = (n) => (e) => typeof e === n, {
  isArray: vf
} = Array, Fp = f_("undefined");
function Qq(n) {
  return n !== null && !Fp(n) && n.constructor !== null && !Fp(n.constructor) && il(n.constructor.isBuffer) && n.constructor.isBuffer(n);
}
const M3 = Tc("ArrayBuffer");
function eH(n) {
  let e;
  return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && M3(n.buffer), e;
}
const tH = f_("string"), il = f_("function"), L3 = f_("number"), p_ = (n) => n !== null && typeof n == "object", nH = (n) => n === !0 || n === !1, ym = (n) => {
  if (d_(n) !== "object")
    return !1;
  const e = ov(n);
  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in n) && !(Symbol.iterator in n);
}, iH = Tc("Date"), rH = Tc("File"), sH = Tc("Blob"), oH = Tc("FileList"), aH = (n) => p_(n) && il(n.pipe), lH = (n) => {
  let e;
  return n && (typeof FormData == "function" && n instanceof FormData || il(n.append) && ((e = d_(n)) === "formdata" || // detect form-data instance
  e === "object" && il(n.toString) && n.toString() === "[object FormData]"));
}, cH = Tc("URLSearchParams"), [uH, hH, dH, fH] = ["ReadableStream", "Request", "Response", "Headers"].map(Tc), pH = (n) => n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function Qp(n, e) {
  let {
    allOwnKeys: t = !1
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (n === null || typeof n > "u")
    return;
  let i, r;
  if (typeof n != "object" && (n = [n]), vf(n))
    for (i = 0, r = n.length; i < r; i++)
      e.call(null, n[i], i, n);
  else {
    const l = t ? Object.getOwnPropertyNames(n) : Object.keys(n), c = l.length;
    let a;
    for (i = 0; i < c; i++)
      a = l[i], e.call(null, n[a], a, n);
  }
}
function R3(n, e) {
  e = e.toLowerCase();
  const t = Object.keys(n);
  let i = t.length, r;
  for (; i-- > 0; )
    if (r = t[i], e === r.toLowerCase())
      return r;
  return null;
}
const Wh = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, B3 = (n) => !Fp(n) && n !== Wh;
function B1() {
  const {
    caseless: n
  } = B3(this) && this || {}, e = {}, t = (i, r) => {
    const l = n && R3(e, r) || r;
    ym(e[l]) && ym(i) ? e[l] = B1(e[l], i) : ym(i) ? e[l] = B1({}, i) : vf(i) ? e[l] = i.slice() : e[l] = i;
  };
  for (let i = 0, r = arguments.length; i < r; i++)
    arguments[i] && Qp(arguments[i], t);
  return e;
}
const gH = function(n, e, t) {
  let {
    allOwnKeys: i
  } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  return Qp(e, (r, l) => {
    t && il(r) ? n[l] = I3(r, t) : n[l] = r;
  }, {
    allOwnKeys: i
  }), n;
}, mH = (n) => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n), _H = (n, e, t, i) => {
  n.prototype = Object.create(e.prototype, i), n.prototype.constructor = n, Object.defineProperty(n, "super", {
    value: e.prototype
  }), t && Object.assign(n.prototype, t);
}, yH = (n, e, t, i) => {
  let r, l, c;
  const a = {};
  if (e = e || {}, n == null) return e;
  do {
    for (r = Object.getOwnPropertyNames(n), l = r.length; l-- > 0; )
      c = r[l], (!i || i(c, n, e)) && !a[c] && (e[c] = n[c], a[c] = !0);
    n = t !== !1 && ov(n);
  } while (n && (!t || t(n, e)) && n !== Object.prototype);
  return e;
}, bH = (n, e, t) => {
  n = String(n), (t === void 0 || t > n.length) && (t = n.length), t -= e.length;
  const i = n.indexOf(e, t);
  return i !== -1 && i === t;
}, vH = (n) => {
  if (!n) return null;
  if (vf(n)) return n;
  let e = n.length;
  if (!L3(e)) return null;
  const t = new Array(e);
  for (; e-- > 0; )
    t[e] = n[e];
  return t;
}, xH = /* @__PURE__ */ ((n) => (e) => n && e instanceof n)(typeof Uint8Array < "u" && ov(Uint8Array)), wH = (n, e) => {
  const i = (n && n[Symbol.iterator]).call(n);
  let r;
  for (; (r = i.next()) && !r.done; ) {
    const l = r.value;
    e.call(n, l[0], l[1]);
  }
}, AH = (n, e) => {
  let t;
  const i = [];
  for (; (t = n.exec(e)) !== null; )
    i.push(t);
  return i;
}, TH = Tc("HTMLFormElement"), EH = (n) => n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(t, i, r) {
  return i.toUpperCase() + r;
}), H5 = ((n) => {
  let {
    hasOwnProperty: e
  } = n;
  return (t, i) => e.call(t, i);
})(Object.prototype), SH = Tc("RegExp"), O3 = (n, e) => {
  const t = Object.getOwnPropertyDescriptors(n), i = {};
  Qp(t, (r, l) => {
    let c;
    (c = e(r, l, n)) !== !1 && (i[l] = c || r);
  }), Object.defineProperties(n, i);
}, CH = (n) => {
  O3(n, (e, t) => {
    if (il(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1)
      return !1;
    const i = n[t];
    if (il(i)) {
      if (e.enumerable = !1, "writable" in e) {
        e.writable = !1;
        return;
      }
      e.set || (e.set = () => {
        throw Error("Can not rewrite read-only method '" + t + "'");
      });
    }
  });
}, PH = (n, e) => {
  const t = {}, i = (r) => {
    r.forEach((l) => {
      t[l] = !0;
    });
  };
  return vf(n) ? i(n) : i(String(n).split(e)), t;
}, IH = () => {
}, MH = (n, e) => n != null && Number.isFinite(n = +n) ? n : e, Ey = "abcdefghijklmnopqrstuvwxyz", W5 = "0123456789", D3 = {
  DIGIT: W5,
  ALPHA: Ey,
  ALPHA_DIGIT: Ey + Ey.toUpperCase() + W5
}, LH = function() {
  let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 16, e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : D3.ALPHA_DIGIT, t = "";
  const {
    length: i
  } = e;
  for (; n--; )
    t += e[Math.random() * i | 0];
  return t;
};
function RH(n) {
  return !!(n && il(n.append) && n[Symbol.toStringTag] === "FormData" && n[Symbol.iterator]);
}
const BH = (n) => {
  const e = new Array(10), t = (i, r) => {
    if (p_(i)) {
      if (e.indexOf(i) >= 0)
        return;
      if (!("toJSON" in i)) {
        e[r] = i;
        const l = vf(i) ? [] : {};
        return Qp(i, (c, a) => {
          const g = t(c, r + 1);
          !Fp(g) && (l[a] = g);
        }), e[r] = void 0, l;
      }
    }
    return i;
  };
  return t(n, 0);
}, OH = Tc("AsyncFunction"), DH = (n) => n && (p_(n) || il(n)) && il(n.then) && il(n.catch), F3 = ((n, e) => n ? setImmediate : e ? ((t, i) => (Wh.addEventListener("message", (r) => {
  let {
    source: l,
    data: c
  } = r;
  l === Wh && c === t && i.length && i.shift()();
}, !1), (r) => {
  i.push(r), Wh.postMessage(t, "*");
}))(`axios@${Math.random()}`, []) : (t) => setTimeout(t))(typeof setImmediate == "function", il(Wh.postMessage)), FH = typeof queueMicrotask < "u" ? queueMicrotask.bind(Wh) : typeof process < "u" && process.nextTick || F3, zt = {
  isArray: vf,
  isArrayBuffer: M3,
  isBuffer: Qq,
  isFormData: lH,
  isArrayBufferView: eH,
  isString: tH,
  isNumber: L3,
  isBoolean: nH,
  isObject: p_,
  isPlainObject: ym,
  isReadableStream: uH,
  isRequest: hH,
  isResponse: dH,
  isHeaders: fH,
  isUndefined: Fp,
  isDate: iH,
  isFile: rH,
  isBlob: sH,
  isRegExp: SH,
  isFunction: il,
  isStream: aH,
  isURLSearchParams: cH,
  isTypedArray: xH,
  isFileList: oH,
  forEach: Qp,
  merge: B1,
  extend: gH,
  trim: pH,
  stripBOM: mH,
  inherits: _H,
  toFlatObject: yH,
  kindOf: d_,
  kindOfTest: Tc,
  endsWith: bH,
  toArray: vH,
  forEachEntry: wH,
  matchAll: AH,
  isHTMLForm: TH,
  hasOwnProperty: H5,
  hasOwnProp: H5,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors: O3,
  freezeMethods: CH,
  toObjectSet: PH,
  toCamelCase: EH,
  noop: IH,
  toFiniteNumber: MH,
  findKey: R3,
  global: Wh,
  isContextDefined: B3,
  ALPHABET: D3,
  generateString: LH,
  isSpecCompliantForm: RH,
  toJSONObject: BH,
  isAsyncFn: OH,
  isThenable: DH,
  setImmediate: F3,
  asap: FH
};
function mi(n, e, t, i, r) {
  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = n, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), i && (this.request = i), r && (this.response = r, this.status = r.status ? r.status : null);
}
zt.inherits(mi, Error, {
  toJSON: function() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: zt.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const N3 = mi.prototype, k3 = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((n) => {
  k3[n] = {
    value: n
  };
});
Object.defineProperties(mi, k3);
Object.defineProperty(N3, "isAxiosError", {
  value: !0
});
mi.from = (n, e, t, i, r, l) => {
  const c = Object.create(N3);
  return zt.toFlatObject(n, c, function(g) {
    return g !== Error.prototype;
  }, (a) => a !== "isAxiosError"), mi.call(c, n.message, e, t, i, r), c.cause = n, c.name = n.name, l && Object.assign(c, l), c;
};
const NH = null;
function O1(n) {
  return zt.isPlainObject(n) || zt.isArray(n);
}
function z3(n) {
  return zt.endsWith(n, "[]") ? n.slice(0, -2) : n;
}
function Z5(n, e, t) {
  return n ? n.concat(e).map(function(r, l) {
    return r = z3(r), !t && l ? "[" + r + "]" : r;
  }).join(t ? "." : "") : e;
}
function kH(n) {
  return zt.isArray(n) && !n.some(O1);
}
const zH = zt.toFlatObject(zt, {}, null, function(e) {
  return /^is[A-Z]/.test(e);
});
function g_(n, e, t) {
  if (!zt.isObject(n))
    throw new TypeError("target must be an object");
  e = e || new FormData(), t = zt.toFlatObject(t, {
    metaTokens: !0,
    dots: !1,
    indexes: !1
  }, !1, function(U, V) {
    return !zt.isUndefined(V[U]);
  });
  const i = t.metaTokens, r = t.visitor || A, l = t.dots, c = t.indexes, g = (t.Blob || typeof Blob < "u" && Blob) && zt.isSpecCompliantForm(e);
  if (!zt.isFunction(r))
    throw new TypeError("visitor must be a function");
  function y(F) {
    if (F === null) return "";
    if (zt.isDate(F))
      return F.toISOString();
    if (!g && zt.isBlob(F))
      throw new mi("Blob is not supported. Use a Buffer instead.");
    return zt.isArrayBuffer(F) || zt.isTypedArray(F) ? g && typeof Blob == "function" ? new Blob([F]) : Buffer.from(F) : F;
  }
  function A(F, U, V) {
    let W = F;
    if (F && !V && typeof F == "object") {
      if (zt.endsWith(U, "{}"))
        U = i ? U : U.slice(0, -2), F = JSON.stringify(F);
      else if (zt.isArray(F) && kH(F) || (zt.isFileList(F) || zt.endsWith(U, "[]")) && (W = zt.toArray(F)))
        return U = z3(U), W.forEach(function(de, ie) {
          !(zt.isUndefined(de) || de === null) && e.append(
            // eslint-disable-next-line no-nested-ternary
            c === !0 ? Z5([U], ie, l) : c === null ? U : U + "[]",
            y(de)
          );
        }), !1;
    }
    return O1(F) ? !0 : (e.append(Z5(V, U, l), y(F)), !1);
  }
  const C = [], I = Object.assign(zH, {
    defaultVisitor: A,
    convertValue: y,
    isVisitable: O1
  });
  function S(F, U) {
    if (!zt.isUndefined(F)) {
      if (C.indexOf(F) !== -1)
        throw Error("Circular reference detected in " + U.join("."));
      C.push(F), zt.forEach(F, function(W, X) {
        (!(zt.isUndefined(W) || W === null) && r.call(e, W, zt.isString(X) ? X.trim() : X, U, I)) === !0 && S(W, U ? U.concat(X) : [X]);
      }), C.pop();
    }
  }
  if (!zt.isObject(n))
    throw new TypeError("data must be an object");
  return S(n), e;
}
function $5(n) {
  const e = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function(i) {
    return e[i];
  });
}
function av(n, e) {
  this._pairs = [], n && g_(n, this, e);
}
const U3 = av.prototype;
U3.append = function(e, t) {
  this._pairs.push([e, t]);
};
U3.toString = function(e) {
  const t = e ? function(i) {
    return e.call(this, i, $5);
  } : $5;
  return this._pairs.map(function(r) {
    return t(r[0]) + "=" + t(r[1]);
  }, "").join("&");
};
function UH(n) {
  return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function j3(n, e, t) {
  if (!e)
    return n;
  const i = t && t.encode || UH;
  zt.isFunction(t) && (t = {
    serialize: t
  });
  const r = t && t.serialize;
  let l;
  if (r ? l = r(e, t) : l = zt.isURLSearchParams(e) ? e.toString() : new av(e, t).toString(i), l) {
    const c = n.indexOf("#");
    c !== -1 && (n = n.slice(0, c)), n += (n.indexOf("?") === -1 ? "?" : "&") + l;
  }
  return n;
}
class X5 {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(e, t, i) {
    return this.handlers.push({
      fulfilled: e,
      rejected: t,
      synchronous: i ? i.synchronous : !1,
      runWhen: i ? i.runWhen : null
    }), this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(e) {
    this.handlers[e] && (this.handlers[e] = null);
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    this.handlers && (this.handlers = []);
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(e) {
    zt.forEach(this.handlers, function(i) {
      i !== null && e(i);
    });
  }
}
const G3 = {
  silentJSONParsing: !0,
  forcedJSONParsing: !0,
  clarifyTimeoutError: !1
}, jH = typeof URLSearchParams < "u" ? URLSearchParams : av, GH = typeof FormData < "u" ? FormData : null, VH = typeof Blob < "u" ? Blob : null, qH = {
  isBrowser: !0,
  classes: {
    URLSearchParams: jH,
    FormData: GH,
    Blob: VH
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
}, lv = typeof window < "u" && typeof document < "u", D1 = typeof navigator == "object" && navigator || void 0, HH = lv && (!D1 || ["ReactNative", "NativeScript", "NS"].indexOf(D1.product) < 0), WH = typeof WorkerGlobalScope < "u" && // eslint-disable-next-line no-undef
self instanceof WorkerGlobalScope && typeof self.importScripts == "function", ZH = lv && window.location.href || "http://localhost", $H = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv: lv,
  hasStandardBrowserEnv: HH,
  hasStandardBrowserWebWorkerEnv: WH,
  navigator: D1,
  origin: ZH
}, Symbol.toStringTag, { value: "Module" })), Wo = {
  ...$H,
  ...qH
};
function XH(n, e) {
  return g_(n, new Wo.classes.URLSearchParams(), Object.assign({
    visitor: function(t, i, r, l) {
      return Wo.isNode && zt.isBuffer(t) ? (this.append(i, t.toString("base64")), !1) : l.defaultVisitor.apply(this, arguments);
    }
  }, e));
}
function YH(n) {
  return zt.matchAll(/\w+|\[(\w*)]/g, n).map((e) => e[0] === "[]" ? "" : e[1] || e[0]);
}
function JH(n) {
  const e = {}, t = Object.keys(n);
  let i;
  const r = t.length;
  let l;
  for (i = 0; i < r; i++)
    l = t[i], e[l] = n[l];
  return e;
}
function V3(n) {
  function e(t, i, r, l) {
    let c = t[l++];
    if (c === "__proto__") return !0;
    const a = Number.isFinite(+c), g = l >= t.length;
    return c = !c && zt.isArray(r) ? r.length : c, g ? (zt.hasOwnProp(r, c) ? r[c] = [r[c], i] : r[c] = i, !a) : ((!r[c] || !zt.isObject(r[c])) && (r[c] = []), e(t, i, r[c], l) && zt.isArray(r[c]) && (r[c] = JH(r[c])), !a);
  }
  if (zt.isFormData(n) && zt.isFunction(n.entries)) {
    const t = {};
    return zt.forEachEntry(n, (i, r) => {
      e(YH(i), r, t, 0);
    }), t;
  }
  return null;
}
function KH(n, e, t) {
  if (zt.isString(n))
    try {
      return (e || JSON.parse)(n), zt.trim(n);
    } catch (i) {
      if (i.name !== "SyntaxError")
        throw i;
    }
  return (0, JSON.stringify)(n);
}
const eg = {
  transitional: G3,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function(e, t) {
    const i = t.getContentType() || "", r = i.indexOf("application/json") > -1, l = zt.isObject(e);
    if (l && zt.isHTMLForm(e) && (e = new FormData(e)), zt.isFormData(e))
      return r ? JSON.stringify(V3(e)) : e;
    if (zt.isArrayBuffer(e) || zt.isBuffer(e) || zt.isStream(e) || zt.isFile(e) || zt.isBlob(e) || zt.isReadableStream(e))
      return e;
    if (zt.isArrayBufferView(e))
      return e.buffer;
    if (zt.isURLSearchParams(e))
      return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
    let a;
    if (l) {
      if (i.indexOf("application/x-www-form-urlencoded") > -1)
        return XH(e, this.formSerializer).toString();
      if ((a = zt.isFileList(e)) || i.indexOf("multipart/form-data") > -1) {
        const g = this.env && this.env.FormData;
        return g_(a ? {
          "files[]": e
        } : e, g && new g(), this.formSerializer);
      }
    }
    return l || r ? (t.setContentType("application/json", !1), KH(e)) : e;
  }],
  transformResponse: [function(e) {
    const t = this.transitional || eg.transitional, i = t && t.forcedJSONParsing, r = this.responseType === "json";
    if (zt.isResponse(e) || zt.isReadableStream(e))
      return e;
    if (e && zt.isString(e) && (i && !this.responseType || r)) {
      const c = !(t && t.silentJSONParsing) && r;
      try {
        return JSON.parse(e);
      } catch (a) {
        if (c)
          throw a.name === "SyntaxError" ? mi.from(a, mi.ERR_BAD_RESPONSE, this, null, this.response) : a;
      }
    }
    return e;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: Wo.classes.FormData,
    Blob: Wo.classes.Blob
  },
  validateStatus: function(e) {
    return e >= 200 && e < 300;
  },
  headers: {
    common: {
      Accept: "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
zt.forEach(["delete", "get", "head", "post", "put", "patch"], (n) => {
  eg.headers[n] = {};
});
const QH = zt.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), eW = (n) => {
  const e = {};
  let t, i, r;
  return n && n.split(`
`).forEach(function(c) {
    r = c.indexOf(":"), t = c.substring(0, r).trim().toLowerCase(), i = c.substring(r + 1).trim(), !(!t || e[t] && QH[t]) && (t === "set-cookie" ? e[t] ? e[t].push(i) : e[t] = [i] : e[t] = e[t] ? e[t] + ", " + i : i);
  }), e;
}, Y5 = Symbol("internals");
function cp(n) {
  return n && String(n).trim().toLowerCase();
}
function bm(n) {
  return n === !1 || n == null ? n : zt.isArray(n) ? n.map(bm) : String(n);
}
function tW(n) {
  const e = /* @__PURE__ */ Object.create(null), t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let i;
  for (; i = t.exec(n); )
    e[i[1]] = i[2];
  return e;
}
const nW = (n) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim());
function Sy(n, e, t, i, r) {
  if (zt.isFunction(i))
    return i.call(this, e, t);
  if (r && (e = t), !!zt.isString(e)) {
    if (zt.isString(i))
      return e.indexOf(i) !== -1;
    if (zt.isRegExp(i))
      return i.test(e);
  }
}
function iW(n) {
  return n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, i) => t.toUpperCase() + i);
}
function rW(n, e) {
  const t = zt.toCamelCase(" " + e);
  ["get", "set", "has"].forEach((i) => {
    Object.defineProperty(n, i + t, {
      value: function(r, l, c) {
        return this[i].call(this, e, r, l, c);
      },
      configurable: !0
    });
  });
}
class Sa {
  constructor(e) {
    e && this.set(e);
  }
  set(e, t, i) {
    const r = this;
    function l(a, g, y) {
      const A = cp(g);
      if (!A)
        throw new Error("header name must be a non-empty string");
      const C = zt.findKey(r, A);
      (!C || r[C] === void 0 || y === !0 || y === void 0 && r[C] !== !1) && (r[C || g] = bm(a));
    }
    const c = (a, g) => zt.forEach(a, (y, A) => l(y, A, g));
    if (zt.isPlainObject(e) || e instanceof this.constructor)
      c(e, t);
    else if (zt.isString(e) && (e = e.trim()) && !nW(e))
      c(eW(e), t);
    else if (zt.isHeaders(e))
      for (const [a, g] of e.entries())
        l(g, a, i);
    else
      e != null && l(t, e, i);
    return this;
  }
  get(e, t) {
    if (e = cp(e), e) {
      const i = zt.findKey(this, e);
      if (i) {
        const r = this[i];
        if (!t)
          return r;
        if (t === !0)
          return tW(r);
        if (zt.isFunction(t))
          return t.call(this, r, i);
        if (zt.isRegExp(t))
          return t.exec(r);
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(e, t) {
    if (e = cp(e), e) {
      const i = zt.findKey(this, e);
      return !!(i && this[i] !== void 0 && (!t || Sy(this, this[i], i, t)));
    }
    return !1;
  }
  delete(e, t) {
    const i = this;
    let r = !1;
    function l(c) {
      if (c = cp(c), c) {
        const a = zt.findKey(i, c);
        a && (!t || Sy(i, i[a], a, t)) && (delete i[a], r = !0);
      }
    }
    return zt.isArray(e) ? e.forEach(l) : l(e), r;
  }
  clear(e) {
    const t = Object.keys(this);
    let i = t.length, r = !1;
    for (; i--; ) {
      const l = t[i];
      (!e || Sy(this, this[l], l, e, !0)) && (delete this[l], r = !0);
    }
    return r;
  }
  normalize(e) {
    const t = this, i = {};
    return zt.forEach(this, (r, l) => {
      const c = zt.findKey(i, l);
      if (c) {
        t[c] = bm(r), delete t[l];
        return;
      }
      const a = e ? iW(l) : String(l).trim();
      a !== l && delete t[l], t[a] = bm(r), i[a] = !0;
    }), this;
  }
  concat() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return this.constructor.concat(this, ...t);
  }
  toJSON(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return zt.forEach(this, (i, r) => {
      i != null && i !== !1 && (t[r] = e && zt.isArray(i) ? i.join(", ") : i);
    }), t;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map((e) => {
      let [t, i] = e;
      return t + ": " + i;
    }).join(`
`);
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(e) {
    return e instanceof this ? e : new this(e);
  }
  static concat(e) {
    const t = new this(e);
    for (var i = arguments.length, r = new Array(i > 1 ? i - 1 : 0), l = 1; l < i; l++)
      r[l - 1] = arguments[l];
    return r.forEach((c) => t.set(c)), t;
  }
  static accessor(e) {
    const i = (this[Y5] = this[Y5] = {
      accessors: {}
    }).accessors, r = this.prototype;
    function l(c) {
      const a = cp(c);
      i[a] || (rW(r, c), i[a] = !0);
    }
    return zt.isArray(e) ? e.forEach(l) : l(e), this;
  }
}
Sa.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
zt.reduceDescriptors(Sa.prototype, (n, e) => {
  let {
    value: t
  } = n, i = e[0].toUpperCase() + e.slice(1);
  return {
    get: () => t,
    set(r) {
      this[i] = r;
    }
  };
});
zt.freezeMethods(Sa);
function Cy(n, e) {
  const t = this || eg, i = e || t, r = Sa.from(i.headers);
  let l = i.data;
  return zt.forEach(n, function(a) {
    l = a.call(t, l, r.normalize(), e ? e.status : void 0);
  }), r.normalize(), l;
}
function q3(n) {
  return !!(n && n.__CANCEL__);
}
function xf(n, e, t) {
  mi.call(this, n ?? "canceled", mi.ERR_CANCELED, e, t), this.name = "CanceledError";
}
zt.inherits(xf, mi, {
  __CANCEL__: !0
});
function H3(n, e, t) {
  const i = t.config.validateStatus;
  !t.status || !i || i(t.status) ? n(t) : e(new mi("Request failed with status code " + t.status, [mi.ERR_BAD_REQUEST, mi.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4], t.config, t.request, t));
}
function sW(n) {
  const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
  return e && e[1] || "";
}
function oW(n, e) {
  n = n || 10;
  const t = new Array(n), i = new Array(n);
  let r = 0, l = 0, c;
  return e = e !== void 0 ? e : 1e3, function(g) {
    const y = Date.now(), A = i[l];
    c || (c = y), t[r] = g, i[r] = y;
    let C = l, I = 0;
    for (; C !== r; )
      I += t[C++], C = C % n;
    if (r = (r + 1) % n, r === l && (l = (l + 1) % n), y - c < e)
      return;
    const S = A && y - A;
    return S ? Math.round(I * 1e3 / S) : void 0;
  };
}
function aW(n, e) {
  let t = 0, i = 1e3 / e, r, l;
  const c = function(y) {
    t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Date.now(), r = null, l && (clearTimeout(l), l = null), n.apply(null, y);
  };
  return [function() {
    const y = Date.now(), A = y - t;
    for (var C = arguments.length, I = new Array(C), S = 0; S < C; S++)
      I[S] = arguments[S];
    A >= i ? c(I, y) : (r = I, l || (l = setTimeout(() => {
      l = null, c(r);
    }, i - A)));
  }, () => r && c(r)];
}
const Wm = function(n, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3, i = 0;
  const r = oW(50, 250);
  return aW((l) => {
    const c = l.loaded, a = l.lengthComputable ? l.total : void 0, g = c - i, y = r(g), A = c <= a;
    i = c;
    const C = {
      loaded: c,
      total: a,
      progress: a ? c / a : void 0,
      bytes: g,
      rate: y || void 0,
      estimated: y && a && A ? (a - c) / y : void 0,
      event: l,
      lengthComputable: a != null,
      [e ? "download" : "upload"]: !0
    };
    n(C);
  }, t);
}, J5 = (n, e) => {
  const t = n != null;
  return [(i) => e[0]({
    lengthComputable: t,
    total: n,
    loaded: i
  }), e[1]];
}, K5 = (n) => function() {
  for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
    t[i] = arguments[i];
  return zt.asap(() => n(...t));
}, lW = Wo.hasStandardBrowserEnv ? /* @__PURE__ */ ((n, e) => (t) => (t = new URL(t, Wo.origin), n.protocol === t.protocol && n.host === t.host && (e || n.port === t.port)))(new URL(Wo.origin), Wo.navigator && /(msie|trident)/i.test(Wo.navigator.userAgent)) : () => !0, cW = Wo.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(n, e, t, i, r, l) {
      const c = [n + "=" + encodeURIComponent(e)];
      zt.isNumber(t) && c.push("expires=" + new Date(t).toGMTString()), zt.isString(i) && c.push("path=" + i), zt.isString(r) && c.push("domain=" + r), l === !0 && c.push("secure"), document.cookie = c.join("; ");
    },
    read(n) {
      const e = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
      return e ? decodeURIComponent(e[3]) : null;
    },
    remove(n) {
      this.write(n, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function uW(n) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n);
}
function hW(n, e) {
  return e ? n.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : n;
}
function W3(n, e) {
  return n && !uW(e) ? hW(n, e) : e;
}
const Q5 = (n) => n instanceof Sa ? {
  ...n
} : n;
function td(n, e) {
  e = e || {};
  const t = {};
  function i(y, A, C, I) {
    return zt.isPlainObject(y) && zt.isPlainObject(A) ? zt.merge.call({
      caseless: I
    }, y, A) : zt.isPlainObject(A) ? zt.merge({}, A) : zt.isArray(A) ? A.slice() : A;
  }
  function r(y, A, C, I) {
    if (zt.isUndefined(A)) {
      if (!zt.isUndefined(y))
        return i(void 0, y, C, I);
    } else return i(y, A, C, I);
  }
  function l(y, A) {
    if (!zt.isUndefined(A))
      return i(void 0, A);
  }
  function c(y, A) {
    if (zt.isUndefined(A)) {
      if (!zt.isUndefined(y))
        return i(void 0, y);
    } else return i(void 0, A);
  }
  function a(y, A, C) {
    if (C in e)
      return i(y, A);
    if (C in n)
      return i(void 0, y);
  }
  const g = {
    url: l,
    method: l,
    data: l,
    baseURL: c,
    transformRequest: c,
    transformResponse: c,
    paramsSerializer: c,
    timeout: c,
    timeoutMessage: c,
    withCredentials: c,
    withXSRFToken: c,
    adapter: c,
    responseType: c,
    xsrfCookieName: c,
    xsrfHeaderName: c,
    onUploadProgress: c,
    onDownloadProgress: c,
    decompress: c,
    maxContentLength: c,
    maxBodyLength: c,
    beforeRedirect: c,
    transport: c,
    httpAgent: c,
    httpsAgent: c,
    cancelToken: c,
    socketPath: c,
    responseEncoding: c,
    validateStatus: a,
    headers: (y, A, C) => r(Q5(y), Q5(A), C, !0)
  };
  return zt.forEach(Object.keys(Object.assign({}, n, e)), function(A) {
    const C = g[A] || r, I = C(n[A], e[A], A);
    zt.isUndefined(I) && C !== a || (t[A] = I);
  }), t;
}
const Z3 = (n) => {
  const e = td({}, n);
  let {
    data: t,
    withXSRFToken: i,
    xsrfHeaderName: r,
    xsrfCookieName: l,
    headers: c,
    auth: a
  } = e;
  e.headers = c = Sa.from(c), e.url = j3(W3(e.baseURL, e.url), n.params, n.paramsSerializer), a && c.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : "")));
  let g;
  if (zt.isFormData(t)) {
    if (Wo.hasStandardBrowserEnv || Wo.hasStandardBrowserWebWorkerEnv)
      c.setContentType(void 0);
    else if ((g = c.getContentType()) !== !1) {
      const [y, ...A] = g ? g.split(";").map((C) => C.trim()).filter(Boolean) : [];
      c.setContentType([y || "multipart/form-data", ...A].join("; "));
    }
  }
  if (Wo.hasStandardBrowserEnv && (i && zt.isFunction(i) && (i = i(e)), i || i !== !1 && lW(e.url))) {
    const y = r && l && cW.read(l);
    y && c.set(r, y);
  }
  return e;
}, dW = typeof XMLHttpRequest < "u", fW = dW && function(n) {
  return new Promise(function(t, i) {
    const r = Z3(n);
    let l = r.data;
    const c = Sa.from(r.headers).normalize();
    let {
      responseType: a,
      onUploadProgress: g,
      onDownloadProgress: y
    } = r, A, C, I, S, F;
    function U() {
      S && S(), F && F(), r.cancelToken && r.cancelToken.unsubscribe(A), r.signal && r.signal.removeEventListener("abort", A);
    }
    let V = new XMLHttpRequest();
    V.open(r.method.toUpperCase(), r.url, !0), V.timeout = r.timeout;
    function W() {
      if (!V)
        return;
      const de = Sa.from("getAllResponseHeaders" in V && V.getAllResponseHeaders()), fe = {
        data: !a || a === "text" || a === "json" ? V.responseText : V.response,
        status: V.status,
        statusText: V.statusText,
        headers: de,
        config: n,
        request: V
      };
      H3(function(Te) {
        t(Te), U();
      }, function(Te) {
        i(Te), U();
      }, fe), V = null;
    }
    "onloadend" in V ? V.onloadend = W : V.onreadystatechange = function() {
      !V || V.readyState !== 4 || V.status === 0 && !(V.responseURL && V.responseURL.indexOf("file:") === 0) || setTimeout(W);
    }, V.onabort = function() {
      V && (i(new mi("Request aborted", mi.ECONNABORTED, n, V)), V = null);
    }, V.onerror = function() {
      i(new mi("Network Error", mi.ERR_NETWORK, n, V)), V = null;
    }, V.ontimeout = function() {
      let ie = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded";
      const fe = r.transitional || G3;
      r.timeoutErrorMessage && (ie = r.timeoutErrorMessage), i(new mi(ie, fe.clarifyTimeoutError ? mi.ETIMEDOUT : mi.ECONNABORTED, n, V)), V = null;
    }, l === void 0 && c.setContentType(null), "setRequestHeader" in V && zt.forEach(c.toJSON(), function(ie, fe) {
      V.setRequestHeader(fe, ie);
    }), zt.isUndefined(r.withCredentials) || (V.withCredentials = !!r.withCredentials), a && a !== "json" && (V.responseType = r.responseType), y && ([I, F] = Wm(y, !0), V.addEventListener("progress", I)), g && V.upload && ([C, S] = Wm(g), V.upload.addEventListener("progress", C), V.upload.addEventListener("loadend", S)), (r.cancelToken || r.signal) && (A = (de) => {
      V && (i(!de || de.type ? new xf(null, n, V) : de), V.abort(), V = null);
    }, r.cancelToken && r.cancelToken.subscribe(A), r.signal && (r.signal.aborted ? A() : r.signal.addEventListener("abort", A)));
    const X = sW(r.url);
    if (X && Wo.protocols.indexOf(X) === -1) {
      i(new mi("Unsupported protocol " + X + ":", mi.ERR_BAD_REQUEST, n));
      return;
    }
    V.send(l || null);
  });
}, pW = (n, e) => {
  const {
    length: t
  } = n = n ? n.filter(Boolean) : [];
  if (e || t) {
    let i = new AbortController(), r;
    const l = function(y) {
      if (!r) {
        r = !0, a();
        const A = y instanceof Error ? y : this.reason;
        i.abort(A instanceof mi ? A : new xf(A instanceof Error ? A.message : A));
      }
    };
    let c = e && setTimeout(() => {
      c = null, l(new mi(`timeout ${e} of ms exceeded`, mi.ETIMEDOUT));
    }, e);
    const a = () => {
      n && (c && clearTimeout(c), c = null, n.forEach((y) => {
        y.unsubscribe ? y.unsubscribe(l) : y.removeEventListener("abort", l);
      }), n = null);
    };
    n.forEach((y) => y.addEventListener("abort", l));
    const {
      signal: g
    } = i;
    return g.unsubscribe = () => zt.asap(a), g;
  }
}, gW = function* (n, e) {
  let t = n.byteLength;
  if (t < e) {
    yield n;
    return;
  }
  let i = 0, r;
  for (; i < t; )
    r = i + e, yield n.slice(i, r), i = r;
}, mW = async function* (n, e) {
  for await (const t of _W(n))
    yield* gW(t, e);
}, _W = async function* (n) {
  if (n[Symbol.asyncIterator]) {
    yield* n;
    return;
  }
  const e = n.getReader();
  try {
    for (; ; ) {
      const {
        done: t,
        value: i
      } = await e.read();
      if (t)
        break;
      yield i;
    }
  } finally {
    await e.cancel();
  }
}, eT = (n, e, t, i) => {
  const r = mW(n, e);
  let l = 0, c, a = (g) => {
    c || (c = !0, i && i(g));
  };
  return new ReadableStream({
    async pull(g) {
      try {
        const {
          done: y,
          value: A
        } = await r.next();
        if (y) {
          a(), g.close();
          return;
        }
        let C = A.byteLength;
        if (t) {
          let I = l += C;
          t(I);
        }
        g.enqueue(new Uint8Array(A));
      } catch (y) {
        throw a(y), y;
      }
    },
    cancel(g) {
      return a(g), r.return();
    }
  }, {
    highWaterMark: 2
  });
}, m_ = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", $3 = m_ && typeof ReadableStream == "function", yW = m_ && (typeof TextEncoder == "function" ? /* @__PURE__ */ ((n) => (e) => n.encode(e))(new TextEncoder()) : async (n) => new Uint8Array(await new Response(n).arrayBuffer())), X3 = function(n) {
  try {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), i = 1; i < e; i++)
      t[i - 1] = arguments[i];
    return !!n(...t);
  } catch {
    return !1;
  }
}, bW = $3 && X3(() => {
  let n = !1;
  const e = new Request(Wo.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      return n = !0, "half";
    }
  }).headers.has("Content-Type");
  return n && !e;
}), tT = 64 * 1024, F1 = $3 && X3(() => zt.isReadableStream(new Response("").body)), Zm = {
  stream: F1 && ((n) => n.body)
};
m_ && ((n) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((e) => {
    !Zm[e] && (Zm[e] = zt.isFunction(n[e]) ? (t) => t[e]() : (t, i) => {
      throw new mi(`Response type '${e}' is not supported`, mi.ERR_NOT_SUPPORT, i);
    });
  });
})(new Response());
const vW = async (n) => {
  if (n == null)
    return 0;
  if (zt.isBlob(n))
    return n.size;
  if (zt.isSpecCompliantForm(n))
    return (await new Request(Wo.origin, {
      method: "POST",
      body: n
    }).arrayBuffer()).byteLength;
  if (zt.isArrayBufferView(n) || zt.isArrayBuffer(n))
    return n.byteLength;
  if (zt.isURLSearchParams(n) && (n = n + ""), zt.isString(n))
    return (await yW(n)).byteLength;
}, xW = async (n, e) => {
  const t = zt.toFiniteNumber(n.getContentLength());
  return t ?? vW(e);
}, wW = m_ && (async (n) => {
  let {
    url: e,
    method: t,
    data: i,
    signal: r,
    cancelToken: l,
    timeout: c,
    onDownloadProgress: a,
    onUploadProgress: g,
    responseType: y,
    headers: A,
    withCredentials: C = "same-origin",
    fetchOptions: I
  } = Z3(n);
  y = y ? (y + "").toLowerCase() : "text";
  let S = pW([r, l && l.toAbortSignal()], c), F;
  const U = S && S.unsubscribe && (() => {
    S.unsubscribe();
  });
  let V;
  try {
    if (g && bW && t !== "get" && t !== "head" && (V = await xW(A, i)) !== 0) {
      let fe = new Request(e, {
        method: "POST",
        body: i,
        duplex: "half"
      }), Ae;
      if (zt.isFormData(i) && (Ae = fe.headers.get("content-type")) && A.setContentType(Ae), fe.body) {
        const [Te, me] = J5(V, Wm(K5(g)));
        i = eT(fe.body, tT, Te, me);
      }
    }
    zt.isString(C) || (C = C ? "include" : "omit");
    const W = "credentials" in Request.prototype;
    F = new Request(e, {
      ...I,
      signal: S,
      method: t.toUpperCase(),
      headers: A.normalize().toJSON(),
      body: i,
      duplex: "half",
      credentials: W ? C : void 0
    });
    let X = await fetch(F);
    const de = F1 && (y === "stream" || y === "response");
    if (F1 && (a || de && U)) {
      const fe = {};
      ["status", "statusText", "headers"].forEach((Ge) => {
        fe[Ge] = X[Ge];
      });
      const Ae = zt.toFiniteNumber(X.headers.get("content-length")), [Te, me] = a && J5(Ae, Wm(K5(a), !0)) || [];
      X = new Response(eT(X.body, tT, Te, () => {
        me && me(), U && U();
      }), fe);
    }
    y = y || "text";
    let ie = await Zm[zt.findKey(Zm, y) || "text"](X, n);
    return !de && U && U(), await new Promise((fe, Ae) => {
      H3(fe, Ae, {
        data: ie,
        headers: Sa.from(X.headers),
        status: X.status,
        statusText: X.statusText,
        config: n,
        request: F
      });
    });
  } catch (W) {
    throw U && U(), W && W.name === "TypeError" && /fetch/i.test(W.message) ? Object.assign(new mi("Network Error", mi.ERR_NETWORK, n, F), {
      cause: W.cause || W
    }) : mi.from(W, W && W.code, n, F);
  }
}), N1 = {
  http: NH,
  xhr: fW,
  fetch: wW
};
zt.forEach(N1, (n, e) => {
  if (n) {
    try {
      Object.defineProperty(n, "name", {
        value: e
      });
    } catch {
    }
    Object.defineProperty(n, "adapterName", {
      value: e
    });
  }
});
const nT = (n) => `- ${n}`, AW = (n) => zt.isFunction(n) || n === null || n === !1, Y3 = {
  getAdapter: (n) => {
    n = zt.isArray(n) ? n : [n];
    const {
      length: e
    } = n;
    let t, i;
    const r = {};
    for (let l = 0; l < e; l++) {
      t = n[l];
      let c;
      if (i = t, !AW(t) && (i = N1[(c = String(t)).toLowerCase()], i === void 0))
        throw new mi(`Unknown adapter '${c}'`);
      if (i)
        break;
      r[c || "#" + l] = i;
    }
    if (!i) {
      const l = Object.entries(r).map((a) => {
        let [g, y] = a;
        return `adapter ${g} ` + (y === !1 ? "is not supported by the environment" : "is not available in the build");
      });
      let c = e ? l.length > 1 ? `since :
` + l.map(nT).join(`
`) : " " + nT(l[0]) : "as no adapter specified";
      throw new mi("There is no suitable adapter to dispatch the request " + c, "ERR_NOT_SUPPORT");
    }
    return i;
  },
  adapters: N1
};
function Py(n) {
  if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted)
    throw new xf(null, n);
}
function iT(n) {
  return Py(n), n.headers = Sa.from(n.headers), n.data = Cy.call(n, n.transformRequest), ["post", "put", "patch"].indexOf(n.method) !== -1 && n.headers.setContentType("application/x-www-form-urlencoded", !1), Y3.getAdapter(n.adapter || eg.adapter)(n).then(function(i) {
    return Py(n), i.data = Cy.call(n, n.transformResponse, i), i.headers = Sa.from(i.headers), i;
  }, function(i) {
    return q3(i) || (Py(n), i && i.response && (i.response.data = Cy.call(n, n.transformResponse, i.response), i.response.headers = Sa.from(i.response.headers))), Promise.reject(i);
  });
}
const J3 = "1.7.9", __ = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((n, e) => {
  __[n] = function(i) {
    return typeof i === n || "a" + (e < 1 ? "n " : " ") + n;
  };
});
const rT = {};
__.transitional = function(e, t, i) {
  function r(l, c) {
    return "[Axios v" + J3 + "] Transitional option '" + l + "'" + c + (i ? ". " + i : "");
  }
  return (l, c, a) => {
    if (e === !1)
      throw new mi(r(c, " has been removed" + (t ? " in " + t : "")), mi.ERR_DEPRECATED);
    return t && !rT[c] && (rT[c] = !0, console.warn(r(c, " has been deprecated since v" + t + " and will be removed in the near future"))), e ? e(l, c, a) : !0;
  };
};
__.spelling = function(e) {
  return (t, i) => (console.warn(`${i} is likely a misspelling of ${e}`), !0);
};
function TW(n, e, t) {
  if (typeof n != "object")
    throw new mi("options must be an object", mi.ERR_BAD_OPTION_VALUE);
  const i = Object.keys(n);
  let r = i.length;
  for (; r-- > 0; ) {
    const l = i[r], c = e[l];
    if (c) {
      const a = n[l], g = a === void 0 || c(a, l, n);
      if (g !== !0)
        throw new mi("option " + l + " must be " + g, mi.ERR_BAD_OPTION_VALUE);
      continue;
    }
    if (t !== !0)
      throw new mi("Unknown option " + l, mi.ERR_BAD_OPTION);
  }
}
const vm = {
  assertOptions: TW,
  validators: __
}, Wc = vm.validators;
class Yh {
  constructor(e) {
    this.defaults = e, this.interceptors = {
      request: new X5(),
      response: new X5()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(e, t) {
    try {
      return await this._request(e, t);
    } catch (i) {
      if (i instanceof Error) {
        let r = {};
        Error.captureStackTrace ? Error.captureStackTrace(r) : r = new Error();
        const l = r.stack ? r.stack.replace(/^.+\n/, "") : "";
        try {
          i.stack ? l && !String(i.stack).endsWith(l.replace(/^.+\n.+\n/, "")) && (i.stack += `
` + l) : i.stack = l;
        } catch {
        }
      }
      throw i;
    }
  }
  _request(e, t) {
    typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = td(this.defaults, t);
    const {
      transitional: i,
      paramsSerializer: r,
      headers: l
    } = t;
    i !== void 0 && vm.assertOptions(i, {
      silentJSONParsing: Wc.transitional(Wc.boolean),
      forcedJSONParsing: Wc.transitional(Wc.boolean),
      clarifyTimeoutError: Wc.transitional(Wc.boolean)
    }, !1), r != null && (zt.isFunction(r) ? t.paramsSerializer = {
      serialize: r
    } : vm.assertOptions(r, {
      encode: Wc.function,
      serialize: Wc.function
    }, !0)), vm.assertOptions(t, {
      baseUrl: Wc.spelling("baseURL"),
      withXsrfToken: Wc.spelling("withXSRFToken")
    }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
    let c = l && zt.merge(l.common, l[t.method]);
    l && zt.forEach(["delete", "get", "head", "post", "put", "patch", "common"], (F) => {
      delete l[F];
    }), t.headers = Sa.concat(c, l);
    const a = [];
    let g = !0;
    this.interceptors.request.forEach(function(U) {
      typeof U.runWhen == "function" && U.runWhen(t) === !1 || (g = g && U.synchronous, a.unshift(U.fulfilled, U.rejected));
    });
    const y = [];
    this.interceptors.response.forEach(function(U) {
      y.push(U.fulfilled, U.rejected);
    });
    let A, C = 0, I;
    if (!g) {
      const F = [iT.bind(this), void 0];
      for (F.unshift.apply(F, a), F.push.apply(F, y), I = F.length, A = Promise.resolve(t); C < I; )
        A = A.then(F[C++], F[C++]);
      return A;
    }
    I = a.length;
    let S = t;
    for (C = 0; C < I; ) {
      const F = a[C++], U = a[C++];
      try {
        S = F(S);
      } catch (V) {
        U.call(this, V);
        break;
      }
    }
    try {
      A = iT.call(this, S);
    } catch (F) {
      return Promise.reject(F);
    }
    for (C = 0, I = y.length; C < I; )
      A = A.then(y[C++], y[C++]);
    return A;
  }
  getUri(e) {
    e = td(this.defaults, e);
    const t = W3(e.baseURL, e.url);
    return j3(t, e.params, e.paramsSerializer);
  }
}
zt.forEach(["delete", "get", "head", "options"], function(e) {
  Yh.prototype[e] = function(t, i) {
    return this.request(td(i || {}, {
      method: e,
      url: t,
      data: (i || {}).data
    }));
  };
});
zt.forEach(["post", "put", "patch"], function(e) {
  function t(i) {
    return function(l, c, a) {
      return this.request(td(a || {}, {
        method: e,
        headers: i ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: l,
        data: c
      }));
    };
  }
  Yh.prototype[e] = t(), Yh.prototype[e + "Form"] = t(!0);
});
class cv {
  constructor(e) {
    if (typeof e != "function")
      throw new TypeError("executor must be a function.");
    let t;
    this.promise = new Promise(function(l) {
      t = l;
    });
    const i = this;
    this.promise.then((r) => {
      if (!i._listeners) return;
      let l = i._listeners.length;
      for (; l-- > 0; )
        i._listeners[l](r);
      i._listeners = null;
    }), this.promise.then = (r) => {
      let l;
      const c = new Promise((a) => {
        i.subscribe(a), l = a;
      }).then(r);
      return c.cancel = function() {
        i.unsubscribe(l);
      }, c;
    }, e(function(l, c, a) {
      i.reason || (i.reason = new xf(l, c, a), t(i.reason));
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason)
      throw this.reason;
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(e) {
    if (this.reason) {
      e(this.reason);
      return;
    }
    this._listeners ? this._listeners.push(e) : this._listeners = [e];
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(e) {
    if (!this._listeners)
      return;
    const t = this._listeners.indexOf(e);
    t !== -1 && this._listeners.splice(t, 1);
  }
  toAbortSignal() {
    const e = new AbortController(), t = (i) => {
      e.abort(i);
    };
    return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let e;
    return {
      token: new cv(function(r) {
        e = r;
      }),
      cancel: e
    };
  }
}
function EW(n) {
  return function(t) {
    return n.apply(null, t);
  };
}
function SW(n) {
  return zt.isObject(n) && n.isAxiosError === !0;
}
const k1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(k1).forEach((n) => {
  let [e, t] = n;
  k1[t] = e;
});
function K3(n) {
  const e = new Yh(n), t = I3(Yh.prototype.request, e);
  return zt.extend(t, Yh.prototype, e, {
    allOwnKeys: !0
  }), zt.extend(t, e, null, {
    allOwnKeys: !0
  }), t.create = function(r) {
    return K3(td(n, r));
  }, t;
}
const Rs = K3(eg);
Rs.Axios = Yh;
Rs.CanceledError = xf;
Rs.CancelToken = cv;
Rs.isCancel = q3;
Rs.VERSION = J3;
Rs.toFormData = g_;
Rs.AxiosError = mi;
Rs.Cancel = Rs.CanceledError;
Rs.all = function(e) {
  return Promise.all(e);
};
Rs.spread = EW;
Rs.isAxiosError = SW;
Rs.mergeConfig = td;
Rs.AxiosHeaders = Sa;
Rs.formToJSON = (n) => V3(zt.isHTMLForm(n) ? new FormData(n) : n);
Rs.getAdapter = Y3.getAdapter;
Rs.HttpStatusCode = k1;
Rs.default = Rs;
const CW = "https://eines.icgc.cat/recursos/mapicgc-gl-js/mapicgc-config.json", PW = 5e3;
class IW {
  static async getConfigICGC() {
    try {
      const e = await Rs.get(CW, {
        timeout: PW
      });
      return e.data ? e.data : (console.log("Resposta sense dades:", e), Hh);
    } catch (e) {
      return e.response ? (console.error("Error de resposta:", e.response.data), console.error("Codi d'estat:", e.response.status)) : e.request ? console.error("No s'ha rebut resposta del servidor:", e.request) : console.error("Error:", e.message), Hh;
    }
  }
}
const MW = {
  "fill-opacity": ["interpolate", ["exponential", 0.5], ["zoom"], 13.5, 1, 18, 0.4],
  "fill-outline-color": "rgba(0,0, 0, 0)",
  "fill-color": ["interpolate", ["cubic-bezier", 0.5, 1, 1, 1], ["get", "nivell_2"], 0, "#ffffff", 111, "#ffff00", 112, "#ccff33", 113, "#af5b15", 114, "#808000", 115, "#cdcd00", 116, "#ffffcc", 221, "#33cc33", 222, "#66ff33", 223, "#689018", 224, "#967d5f", 225, "#19e61e", 226, "#b4ff9b", 227, "#aaa500", 228, "#c3c3a0", 229, "#00ff9b", 230, "#ff9632", 231, "#282828", 232, "#79797a", 233, "#f5df78", 234, "#3296ff", 341, "#ff007d", 342, "#ff53cd", 343, "#ffa4e2", 344, "#ffc8e2", 345, "#ffb4b4", 346, "#0f3700", 347, "#730055", 348, "#6200c4", 349, "#4a9595", 350, "#ff00f0", 351, "#adaaca", 352, "#ffe6e6", 353, "#67629a", 354, "#4a466e", 355, "#2f2d46", 461, "#6f6fff", 462, "#0000dc", 463, "#000064", 464, "#185f94", 465, "#12466d", 466, "#000080"]
}, LW = {
  cobertesSol: MW
}, RW = "lines", tm = "labels";
let Fh, up, ns, Vi, XW = class {
  /**
   * Constructor for the Map class.
   * @param {Object} options - Options to initialize the map.
   */
  constructor(e) {
    IW.getConfigICGC().then((t) => {
      Fh = {
        ...t.Styles
      }, ns = {
        ...t.Layers
      }, up = {
        ...t.Terrains
      }, Vi = {
        ...t.defaultOptions
      }, this.initTheMap(e);
    }).catch((t) => {
      console.info("Configuracio per defecte", t), Fh = {
        ...Hh.Styles
      }, ns = {
        ...Hh.Layers
      }, up = {
        ...Hh.Terrains
      }, Vi = {
        ...Hh.defaultOptions
      }, this.initTheMap(e);
    });
  }
  initTheMap(e) {
    if (!e)
      e = Vi.mapOptions;
    else
      for (const i in Vi.mapOptions) {
        let r = [Vi.mapOptions.center[0], Vi.mapOptions.center[1]];
        Vi.mapOptions.center = r, e.hasOwnProperty(i) || (e[i] = Vi.mapOptions[i]);
      }
    e.maxPitch = 85, e.maplibreLogo = !1, e.attributionControl = !1;
    const t = e.style.includes("https://geoserveis.icgc.cat/servei/catalunya/mapa-base/wmts/");
    t ? (this.map = new so.Map({
      container: e.container,
      center: e.center,
      zoom: e.zoom,
      pitch: e.pitch || 0,
      hash: e.hash || !1,
      style: {
        version: 8,
        sources: {},
        layers: []
      }
    }), this.map.on("load", () => {
      this.map.addSource("raster-source", {
        type: "raster",
        tiles: [e.style],
        // URL del raster
        tileSize: 256
      }), this.map.addLayer({
        id: "raster-layer",
        type: "raster",
        source: "raster-source"
      });
    })) : this.map = new so.Map(e), this.map.on("load", () => {
      if (!t) {
        const i = this.map.getStyle().name, r = e.style;
        this.map.addControl(new Zq({
          color: r.indexOf("orto") === -1,
          defaultOptions: Vi
        }), "bottom-left"), this._dealOrto3dStyle(i);
      }
    });
  }
  /**
   * Add geocoder with customizable options.
   * @function addGeocoderICGC
   * @param {Object} [options={}] - Optional configuration options for the geocoder. Defaults to an empty object.
   * @param {string} [position='top-right'] - Position to add the geocoder control on the map. Defaults to 'top-right'.
   * @returns {Object} - The merged configuration options for the geocoder, including the position.
   * 
   */
  addGeocoderICGC() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top-right";
    try {
      e = {
        ...{
          collapsed: !0,
          marker: !0,
          zoom: 16,
          popup: !0,
          showResultMarkers: !0,
          maplibregl: so,
          showResultsWhileTyping: !0,
          minLength: 2
        },
        ...e
      };
      const r = {
        forwardGeocode: async (c) => {
          const a = [];
          try {
            const g = Vi.geocoder.peliasUrl1 + encodeURIComponent(c.query) + Vi.geocoder.peliasUrl2, A = await (await fetch(g)).json();
            for (const C of A.features) {
              const I = C.geometry.coordinates, S = {
                type: "Feature",
                geometry: {
                  type: "Point",
                  coordinates: I
                },
                place_name: C.properties.etiqueta,
                properties: C.properties,
                text: C.properties.etiqueta,
                place_type: ["place"],
                center: I
              };
              a.push(S);
            }
          } catch (g) {
            console.error(`Failed to forwardGeocode with error: ${g}`);
          }
          return {
            features: a
          };
        }
      };
      this.map.addControl(new Gq(r, e), t);
      let l = document.getElementsByClassName("maplibregl-ctrl-geocoder--input");
      l[0].attributes[2].nodeValue = "Cerca...", l[0].addEventListener("input", function(c) {
        c.target.value.length > 3;
      });
    } catch (i) {
      console.error(`Error adding ICGC geocoder: ${i.message}`);
    }
  }
  //geocoder ends
  async loadImage(e) {
    try {
      return this.map.loadImage(e);
    } catch (t) {
      console.error(`Error getting loadImage: ${t.message}`);
    }
  }
  /**
   * Retrieves the available base styles from default options.
   * @function getConfigStyles
   * @returns {Array} - Array containing the names of available base styles.
   */
  getConfigStyles() {
    try {
      let e = [];
      for (const t of Fh)
        e.push(t.name);
      return e;
    } catch (e) {
      console.error(`Error retrieving base styles: ${e.message}`);
    }
  }
  /**
   * Retrieves the available WMS image layers from default options.
   * @function getConfigWMSLayers
   * @returns {Array} - Array containing the keys of available WMS image layers.
   */
  getConfigWMSLayers() {
    try {
      let e = [];
      for (const t in ns.WMS)
        ns.WMS.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving WMS layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available orto image layers from default options.
   * @function getConfigOrtoLayers
   * @returns {Array} - Array containing the keys of available image layers.
   */
  getConfigOrtoLayers() {
    try {
      let e = [];
      for (const t in ns.Orto)
        ns.Orto.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving orto image layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorLayers
   * @returns {Array} - Array containing the keys of available vector layers.
   */
  getConfigVectorLayers() {
    try {
      let e = [];
      for (const t in ns.Vector)
        ns.Vector.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vector layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available vector layers from default options.
   * @function getConfigVectorAdminLayers
   * @returns {Array} - Array containing the keys of available vectorAdmin layers.
   */
  getConfigVectorAdminLayers() {
    try {
      let e = [];
      for (const t in ns.VectorAdmin)
        ns.VectorAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving vectorAdmin layers: ${e.message}`);
    }
  }
  /**
   * Retrieves the available fgb layers from default options.
   * @function getConfigFGBAdminLayers
   * @returns {Array} - Array containing the keys of available fgbadmin layers.
   */
  getConfigFGBAdminLayers() {
    try {
      let e = [];
      for (const t in ns.FGBAdmin)
        ns.FGBAdmin.hasOwnProperty(t) && e.push(t);
      return e;
    } catch (e) {
      console.error(`Error retrieving FGBAdmin layers: ${e.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The id for the layer.
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchData(e, t, i) {
    try {
      (!i || i === void 0) && (i = {
        type: "line",
        layout: {
          visibility: "visible"
        },
        paint: {
          "line-color": "grey",
          "line-width": 2
        },
        layerPosition: "top"
        // select: 'top', 'lines' or 'labels'
      });
      let r = i.layerPosition;
      if (e.includes(".fgb"))
        this.addFGBLayerICGC(e, t, i);
      else {
        const c = await (await fetch(e)).json();
        let a = t, g = this._dealOrderLayer(r), y = c.features[0].geometry.type;
        y.includes("ine") && (i !== void 0 ? this.map.addLayer({
          id: a,
          type: "line",
          source: {
            type: "geojson",
            data: c
          },
          layout: i.layout || {},
          paint: i.paint || {}
        }, g) : this.map.addLayer({
          id: a,
          type: "line",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "line-color": "black",
            "line-width": 2,
            "line-opacity": 1
          }
        }, g)), y.includes("olygon") && (i !== void 0 ? this.map.addLayer({
          id: a,
          type: "fill",
          source: {
            type: "geojson",
            data: c
          },
          layout: i.layout,
          paint: i.paint
        }, g) : this.map.addLayer({
          id: a,
          type: "fill",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "fill-color": "blue",
            "fill-opacity": 0.6
          }
        }, g)), y.includes("oint") && (i !== void 0 ? this.map.addLayer({
          id: a,
          type: "circle",
          source: {
            type: "geojson",
            data: c
          },
          layout: i.layout,
          paint: i.paint
        }, g) : this.map.addLayer({
          id: a,
          type: "circle",
          source: {
            type: "geojson",
            data: c
          },
          layout: {
            visibility: "visible"
          },
          paint: {
            "circle-color": "red",
            "circle-opacity": 0.85
          }
        }, g));
      }
    } catch (r) {
      console.error(`Error fetching data: ${r.message}`);
    }
  }
  /**
   * Fetches GeoJSON data from a URL and adds a corresponding layer to the map based on the specified geometry type and adds to the Menu as a checkbox item.
   * @param {string} url - The URL to fetch GeoJSON data from.
   * @param {string} idLayer - The geometry name (e.g., 'buildings').
   * @param {string} filterField - Import all features as unique or group based on a field ('all', 'field').
   * @param {Object} options - Additional options for configuring the layer.
   */
  async fetchDataAndMenu(e, t, i, r) {
    try {
      let l;
      r !== null ? l = r.layerPosition : l = tm;
      let c, a = document.getElementById("map");
      if (document.getElementById("menu-group") ? c = document.getElementById("menu-group") : (c = document.createElement("nav"), c.id = "menu-group", c.classList.add = "filter-group", a.appendChild(c)), c !== null) {
        let g = "visible", y = this._dealOrderLayer(l), A;
        if (e.includes(".fgb")) {
          let I = this._getKeyByUrlFGB(e);
          I === null && (I = "userFGB");
          const S = await fetch(e), F = {
            type: "FeatureCollection",
            features: []
          };
          for await (const V of ex(S.body)) F.features.push(V);
          A = F;
          let U = t;
          if (this.map.addSource(U, {
            type: "geojson",
            data: F
          }), e.includes("text"))
            r !== void 0 ? this.map.addLayer({
              id: t,
              type: "symbol",
              source: U,
              layout: r.layout,
              paint: r.paint
            }, y) : this.map.addLayer({
              id: t,
              type: "symbol",
              source: U,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: g,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, y);
          else {
            let V = t + "Text";
            this.map.addLayer({
              id: V,
              type: "symbol",
              source: U,
              layout: {
                "text-letter-spacing": 0.1,
                "text-size": {
                  base: 1.2,
                  stops: [[8, 0], [12, 14], [15, 15]]
                },
                "text-font": ["FiraSans-Regular"],
                "text-field": ["get", "NOM_AC"],
                "text-transform": "none",
                "text-max-width": 25,
                visibility: g,
                "text-justify": "right",
                "text-anchor": "top",
                "text-allow-overlap": !1,
                "symbol-spacing": 2,
                "text-line-height": 1
              },
              paint: {
                "text-halo-blur": 0.5,
                "text-color": "rgba(90, 7, 7, 1)",
                "text-halo-width": 2,
                "text-halo-color": "rgba(255, 255, 255,0.8)"
              }
            }, y);
          }
        } else
          A = await (await fetch(e)).json();
        if (i !== "all") {
          const I = document.createElement("div");
          I.id = "titleDivMenu", I.textContent = t, c.appendChild(I);
          const S = document.createElement("div");
          S.id = "titleDivMenuSub", S.textContent = `📂 ${i}`, c.appendChild(S);
        }
        let C;
        if (r.type ? C = r.type : C = A.features[0].geometry.type, i === "all")
          C.includes("ine") && (r !== void 0 ? this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: A
            },
            layout: r.layout,
            paint: r.paint
          }, y) : this.map.addLayer({
            id: t,
            type: "line",
            source: {
              type: "geojson",
              data: A
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "line-color": "black",
              "line-width": 2,
              "line-opacity": 1
            }
          }, y)), C.includes("olygon") && (r !== void 0 ? this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: A
            },
            layout: r.layout,
            paint: r.paint
          }, y) : this.map.addLayer({
            id: t,
            type: "fill",
            source: {
              type: "geojson",
              data: A
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "fill-color": "#0000FF",
              "fill-opacity": 0
            }
          }, y)), C.includes("oint") && (r !== void 0 ? this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: A
            },
            layout: r.layout,
            paint: r.paint
          }, y) : this.map.addLayer({
            id: t,
            type: "circle",
            source: {
              type: "geojson",
              data: A
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "circle-color": "red",
              "circle-opacity": 0.85
            }
          }, y)), C.includes("ymbol") && (r !== void 0 ? this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: A
            },
            layout: r.layout,
            paint: r.paint
          }, y) : this.map.addLayer({
            id: t,
            type: "symbol",
            source: {
              type: "geojson",
              data: A
            },
            layout: {
              visibility: "visible"
            },
            paint: {
              "text-halo-blur": 0.5,
              "text-color": "rgba(90, 7, 7, 1)",
              "text-halo-width": 2,
              "text-halo-color": "rgba(255, 255, 255,0.8)"
            }
          }, y)), this.addMenuItem(t);
        else {
          let I = i;
          const S = {};
          A.features.forEach((F) => {
            const U = F.properties[I], V = U + "-userFieldFilter-" + t;
            U !== null && (S[V] || (C.includes("ine") && (r !== void 0 ? this.map.addLayer({
              id: V,
              type: "line",
              source: {
                type: "geojson",
                data: A
              },
              layout: r.layout,
              paint: r.paint,
              filter: ["==", `${I}`, U]
            }, y) : this.map.addLayer({
              id: V,
              type: "line",
              source: {
                type: "geojson",
                data: A
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${I}`, U],
              paint: {
                "line-color": "black",
                "line-width": 2,
                "line-opacity": 1
              }
            }, y)), C.includes("olygon") && (r !== void 0 ? this.map.addLayer({
              id: V,
              type: "fill",
              source: {
                type: "geojson",
                data: A
              },
              filter: ["==", `${I}`, U],
              layout: r.layout,
              paint: r.paint
            }, y) : this.map.addLayer({
              id: V,
              type: "fill",
              source: {
                type: "geojson",
                data: A
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${I}`, U],
              paint: {
                "fill-color": "blue",
                "fill-opacity": 0.6
              }
            }, y)), C.includes("oint") && (r !== void 0 ? this.map.addLayer({
              id: V,
              type: "circle",
              source: {
                type: "geojson",
                data: A
              },
              filter: ["==", `${I}`, U],
              layout: r.layout,
              paint: r.paint
            }, y) : this.map.addLayer({
              id: V,
              type: "circle",
              source: {
                type: "geojson",
                data: A
              },
              layout: {
                visibility: "visible"
              },
              filter: ["==", `${I}`, U],
              paint: {
                "circle-color": "red",
                "circle-opacity": 0.85
              }
            }, y)), S[V] = !0, this.addMenuItem(V)));
          });
        }
      }
    } catch (l) {
      console.error(`Error fetching data: ${l.message}`);
    }
  }
  /**
   * Adds an event listener to the map.
   * @function on
   * @param {string} type - The type of the event.
   * @param {Function} func - The callback function to be executed when the event occurs.
   */
  on(e, t) {
    setTimeout(() => {
      try {
        return this.map.on(e, t);
      } catch (i) {
        console.error(`Error adding event ON listener: ${i.message}`);
      }
    }, 100);
  }
  /**
   * Sets the style of the map.
   * @function setStyle
   * @param {string} style - Name of the map style.
   * @param {Object} [options] - Options for setting the style.
   */
  setStyle(e, t) {
    try {
      t !== void 0 ? this.map.setStyle(e, t) : this.map.setStyle(e), this.map.on("styledata", () => {
        if (window.document.querySelector(".maplibregl-compact-show")) {
          var i = window.document.querySelector(".maplibregl-compact-show");
          i.classList.remove("maplibregl-compact-show");
        }
        this._dealOrto3dStyle(this.map.getStyle().name);
      });
    } catch (i) {
      console.error(`Error setting style: ${i.message}`);
    }
  }
  /**
   * Adds a control to the map with the specified position.
   * @function addControl
   * @param {Object} control - The control to add.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(e, t);
    } catch (i) {
      console.error(`Error adding control: ${i.message}`);
    }
  }
  /**
   * Sets the sky properties of the map.
   * @function setSky
   * @param {Object} options - Options to set the sky properties.
   * @param {string} [options.skyType='gradient'] - Type of sky to set (e.g., 'gradient', 'atmosphere').
   * @param {string} [options.color='lightblue'] - Color of the sky.
   * @param {Number} [options.horizonBlend=0.03] - Blend horizon value.
   * @param {Number} [options.starIntensity=0.5] - Intensity of stars in the sky.
   * @param {Number} [options.sunIntensity=0.1] - Intensity of the sun in the sky.
   * @param {Array<Number>} [options.sunPosition=[0, 0]] - Position of the sun in the sky.
   */
  setSky(e) {
    try {
      e === void 0 && (this.map.style.stylesheet.id.includes("orto") ? e = {
        "sky-color": "#86bbd5",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#ffffff33",
        "horizon-fog-blend": 0.1,
        "fog-ground-blend": 0.75,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("mapa_estandard_general") ? e = {
        "sky-color": "#a5f0f0",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#e1e3e3",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("icgc_mapa_vissir") ? e = {
        "sky-color": "#a5f0f0",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#e1e3e3",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#c5d6d6"
      } : this.map.style.stylesheet.id.includes("fosc") ? e = {
        "sky-color": "#232423",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#969996",
        "horizon-fog-blend": 0.9,
        "fog-ground-blend": 0.85,
        "fog-color": "#383838"
      } : e = {
        "sky-color": "#86bbd5",
        "sky-horizon-blend": 0.3,
        "horizon-color": "#ffffff33",
        "horizon-fog-blend": 0.1,
        "fog-ground-blend": 0.75,
        "fog-color": "#c5d6d6"
      }), this.map.setSky(e);
    } catch (t) {
      console.error(`Error setting sky properties: ${t.message}`);
    }
  }
  /**
   * Adds a mouse coordinate control to the map.
   * @function addMouseCoordControl
   * @param {Number} options.width - Width control i.
   * @param {Boolean} options.utm - Boolean to show coordinates in UTM.
   * @param {Boolean} options.lonlat - Boolean to show coordinates in Lon Lat.
   * @param {string} [position='bottom-left'] - Position to add the control on the map.
   */
  addMouseCoordControl(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "bottom-left";
    try {
      this.map.addControl(new Jq(e), t);
    } catch (i) {
      console.error(`Error adding mouse coordinate control: ${i.message}`);
    }
  }
  /**
   * Adds a geolocate control to the map.
   * @function addGeolocateControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addGeolocateControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new so.GeolocateControl({
        positionOptions: {
          enableHighAccuracy: !0
        },
        trackUserLocation: !0
      }), t) : this.map.addControl(new so.GeolocateControl(e), t);
    } catch (i) {
      console.error(`Error adding geolocate control: ${i.message}`);
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullscreenControl
   * @param {Object} options - Options for the geolocate control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullscreenControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), e === void 0 ? this.map.addControl(new so.FullscreenControl({
        container: HTMLElement
      }), t) : this.map.addControl(new so.FullscreenControl(e), t);
    } catch (i) {
      console.error(`Error adding fullscreen control: ${i.message}`);
    }
  }
  /**
   * Adds a layer to the map.
   * @function addLayer
   * @param {Object} layer - Options for the layer to add.
   * @param {string} layerIdOrder - Optional layer Id draw position.
   */
  addLayer(e, t) {
    try {
      this.map.addLayer(e, t);
    } catch (i) {
      console.error(`Error adding layer: ${i.message}`);
    }
  }
  //add maplibre methods
  /**
   * Adds an image to the map.
   * @function addImage
   * @param {string} id - The ID of the image.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The image object to add.
   * @param {Partial<StyleImageMetadata>} options - Optional metadata for the image.
   * @returns {this}
   */
  addImage(e, t, i) {
    try {
      this.map.addImage(e, t, i);
    } catch (r) {
      console.error(`Error adding image: ${r.message}`);
    }
    return this;
  }
  /**
   * Adds a source to the map.
   * @function addSource
   * @param {string} id - The ID of the source.
   * @param {SourceSpecification} source - The source object to add.
   * @returns {this}
   */
  addSource(e, t) {
    try {
      this.map.addSource(e, t);
    } catch (i) {
      console.error(`Error adding source: ${i.message}`);
    }
    return this;
  }
  /**
   * Adds a sprite to the map.
   * @function addSprite
   * @param {string} id - The ID of the sprite.
   * @param {string} url - The URL to load the sprite from.
   * @param {StyleSetterOptions} options - Options object.
   * @returns {this}
   */
  addSprite(e, t, i) {
    try {
      this.map.addSprite(e, t, i);
    } catch (r) {
      console.error(`Error adding sprite: ${r.message}`);
    }
    return this;
  }
  /**
   * Checks if all tiles in the viewport are loaded.
   * @function areTilesLoaded
   * @returns {boolean}
   */
  areTilesLoaded() {
    return this.map.areTilesLoaded();
  }
  /**
   * Calculates the camera position for given bounds.
   * @function cameraForBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {CameraForBoundsOptions} options - Options object.
   * @returns {CenterZoomBearing | undefined}
   */
  cameraForBounds(e, t) {
    return this.map.cameraForBounds(e, t);
  }
  /**
   * Eases the camera to a new position.
   * @function easeTo
   * @param {object} options - Options describing the animation.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  easeTo(e, t) {
    return this.map.easeTo(e, t), this;
  }
  /**
   * Fits the map to the given geographical bounds.
   * @function fitBounds
   * @param {LngLatBoundsLike} bounds - The geographical bounds to fit.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitBounds(e, t, i) {
    return this.map.fitBounds(e, t, i), this;
  }
  /**
   * Fits the map to the given screen coordinates.
   * @function fitScreenCoordinates
   * @param {PointLike} p0 - First point on screen, in pixel coordinates.
   * @param {PointLike} p1 - Second point on screen, in pixel coordinates.
   * @param {number} bearing - Desired map bearing at end of animation, in degrees.
   * @param {FitBoundsOptions} options - Options object.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  fitScreenCoordinates(e, t, i, r, l) {
    return this.map.fitScreenCoordinates(e, t, i, r, l), this;
  }
  /**
   * Flies the camera to a new position.
   * @function flyTo
   * @param {FlyToOptions} options - Options describing the flight.
   * @param {any} eventData - Additional properties for event objects.
   * @returns {this}
   */
  flyTo(e, t) {
    return this.map.flyTo(e, t), this;
  }
  /**
   * Gets the current bearing of the map.
   * @function getBearing
   * @returns {number}
   */
  getBearing() {
    return this.map.getBearing();
  }
  /**
   * Gets the current geographical bounds of the map.
   * @function getBounds
   * @returns {LngLatBounds}
   */
  getBounds() {
    return this.map.getBounds();
  }
  /**
   * Gets the elevation for the point where the camera is looking.
   * @function getCameraTargetElevation
   * @returns {number}
   */
  getCameraTargetElevation() {
    return this.map.getCameraTargetElevation();
  }
  /**
   * Gets the map's <canvas> element.
   * @function getCanvas
   * @returns {HTMLCanvasElement}
   */
  getCanvas() {
    return this.map.getCanvas();
  }
  /**
   * Gets the HTML element containing the map's <canvas> element.
   * @function getCanvasContainer
   * @returns {HTMLElement}
   */
  getCanvasContainer() {
    return this.map.getCanvasContainer();
  }
  /**
   * Returns the map's geographical centerpoint.
   * @function getCenter
   * @returns {LngLat} The map's geographical centerpoint.
   */
  getCenter() {
    return this.map.getCenter();
  }
  /**
   * Returns the map's containing HTML element.
   * @function getContainer
   * @returns {HTMLElement} The map's container.
   */
  getContainer() {
    return this.map.getContainer();
  }
  /**
   * Gets the state of a feature.
   * @function getFeatureState
   * @param {FeatureIdentifier} feature - Feature identifier.
   * @returns {any} The state of the feature.
   */
  getFeatureState(e) {
    return this.map.getFeatureState(e);
  }
  /**
   * Returns the filter applied to the specified style layer.
   * @function getFilter
   * @param {string} layerId - The ID of the style layer.
   * @returns {void | FilterSpecification} The layer's filter.
   */
  getFilter(e) {
    return this.map.getFilter(e);
  }
  /**
   * Returns the value of the style's glyphs URL.
   * @function getGlyphs
   * @returns {string} The glyphs Style's glyphs URL.
   */
  getGlyphs() {
    return this.map.getGlyphs();
  }
  /**
   * Returns an image currently available in the map.
   * @function getImage
   * @param {string} id - The ID of the image.
   * @returns {StyleImage} An image in the map with the specified ID.
   */
  getImage(e) {
    return this.map.getImage(e);
  }
  /**
   * Returns the layer with the specified ID in the map's style.
   * @function getLayer
   * @param {string} id - The ID of the layer to get.
   * @returns {StyleLayer} The layer with the specified ID.
   */
  getLayer(e) {
    return this.map.getLayer(e);
  }
  /**
   * Return the ids of all layers currently in the style, including custom layers, in order.
   * @function getLayersOrder
   * @returns {string[]} Ids of layers, in order.
   */
  getLayersOrder() {
    return this.map.getLayersOrder();
  }
  /**
   * Returns the value of a layout property in the specified style layer.
   * @function getLayoutProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of the layout property.
   * @returns {any} The value of the specified layout property.
   */
  getLayoutProperty(e, t) {
    return this.map.getLayoutProperty(e, t);
  }
  /**
   * Returns the value of the light object.
   * @function getLight
   * @returns {LightSpecification} Light properties of the style.
   */
  getLight() {
    return this.map.getLight();
  }
  /**
   * Returns the maximum geographical bounds the map is constrained to.
   * @function getMaxBounds
   * @returns {LngLatBounds} The map's maximum geographical bounds.
   */
  getMaxBounds() {
    return this.map.getMaxBounds();
  }
  /**
   * Returns the map's maximum allowable pitch.
   * @function getMaxPitch
   * @returns {number} The maxPitch.
   */
  getMaxPitch() {
    return this.map.getMaxPitch();
  }
  /**
   * Returns the map's maximum allowable zoom level.
   * @function getMaxZoom
   * @returns {number} The maxZoom.
   */
  getMaxZoom() {
    return this.map.getMaxZoom();
  }
  /**
   * Returns the map's minimum allowable pitch.
   * @function getMinPitch
   * @returns {number} The minPitch.
   */
  getMinPitch() {
    return this.map.getMinPitch();
  }
  /**
   * Returns the map's minimum allowable zoom level.
   * @function getMinZoom
   * @returns {number} The minZoom.
   */
  getMinZoom() {
    return this.map.getMinZoom();
  }
  /**
   * Returns the current padding applied around the map viewport.
   * @function getPadding
   * @returns {PaddingOptions} The current padding around the map viewport.
   */
  getPadding() {
    return this.map.getPadding();
  }
  /**
   * Returns the value of a paint property in the specified style layer.
   * @function getPaintProperty
   * @param {string} layerId - The ID of the layer.
   * @param {string} name - The name of a paint property.
   * @returns {unknown} The value of the specified paint property.
   */
  getPaintProperty(e, t) {
    return this.map.getPaintProperty(e, t);
  }
  /**
   * Returns the map's current pitch (tilt).
   * @function getPitch
   * @returns {number} The map's current pitch, measured in degrees away from the plane of the screen.
   */
  getPitch() {
    return this.map.getPitch();
  }
  /**
   * Returns the map's pixel ratio.
   * @function getPixelRatio
   * @returns {number} The pixel ratio.
   */
  getPixelRatio() {
    return this.map.getPixelRatio();
  }
  /**
   * Returns the state of renderWorldCopies.
   * @function getRenderWorldCopies
   * @returns {boolean} The renderWorldCopies.
   */
  getRenderWorldCopies() {
    return this.map.getRenderWorldCopies();
  }
  /**
   * Returns the source with the specified ID in the map's style.
   * @function getSource
   * @param {string} id - The ID of the source to get.
   * @returns {Source} The style source with the specified ID.
   */
  getSource(e) {
    return this.map.getSource(e);
  }
  /**
   * Returns the as-is value of the style's sprite.
   * @function getSprite
   * @returns {object[]} Style's sprite list of id-url pairs.
   */
  getSprite() {
    return this.map.getSprite();
  }
  /**
   * Returns the map's MapLibre style object.
   * @function getStyle
   * @returns {StyleSpecification} The map's style JSON object.
   */
  getStyle() {
    return this.map.getStyle();
  }
  /**
   * Get the terrain-options if terrain is loaded.
   * @function getTerrain
   * @returns {TerrainSpecification} The TerrainSpecification passed to setTerrain.
   */
  getTerrain() {
    return this.map.getTerrain();
  }
  //  Function getZoom()
  /**
   * Returns the map's current zoom level.
   * @function getZoom
   * @returns {number} The map's current zoom level.
   */
  getZoom() {
    return this.map.getZoom();
  }
  //  Function hasControl()
  /**
   * Checks if a control exists on the map.
   * @function hasControl
   * @param {IControl} control - The IControl to check.
   * @returns {boolean} true if map contains control.
   */
  hasControl(e) {
    return this.map.hasControl(e);
  }
  //  Function hasImage()
  /**
   * Check whether or not an image with a specific ID exists in the style.
   * @function hasImage
   * @param {string} id - The ID of the image.
   * @returns {boolean} A Boolean indicating whether the image exists.
   */
  hasImage(e) {
    return this.map.hasImage(e);
  }
  //  Function isMoving()
  /**
   * Returns true if the map is panning, zooming, rotating, or pitching due to a camera animation or user gesture.
   * @function isMoving
   * @returns {boolean} true if the map is moving.
   */
  isMoving() {
    return this.map.isMoving();
  }
  //  Function isRotating()
  /**
   * Returns true if the map is rotating due to a camera animation or user gesture.
   * @function isRotating
   * @returns {boolean} true if the map is rotating.
   */
  isRotating() {
    return this.map.isRotating();
  }
  //  Function isSourceLoaded()
  /**
   * Returns a Boolean indicating whether the source is loaded.
   * @function isSourceLoaded
   * @param {string} id - The ID of the source to be checked.
   * @returns {boolean} A Boolean indicating whether the source is loaded.
   */
  isSourceLoaded(e) {
    return this.map.isSourceLoaded(e);
  }
  //  Function isStyleLoaded()
  /**
   * Returns a Boolean indicating whether the map's style is fully loaded.
   * @function isStyleLoaded
   * @returns {boolean | void} A Boolean indicating whether the style is fully loaded.
   */
  isStyleLoaded() {
    return this.map.isStyleLoaded();
  }
  //  Function isZooming()
  /**
   * Returns true if the map is zooming due to a camera animation or user gesture.
   * @function isZooming
   * @returns {boolean} true if the map is zooming.
   */
  isZooming() {
    return this.map.isZooming();
  }
  //  Function jumpTo()
  /**
   * Changes any combination of center, zoom, bearing, and pitch, without an animated transition.
   * @function jumpTo
   * @param {JumpToOptions} options - Options object
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  jumpTo(e, t) {
    return this.map.jumpTo(e, t);
  }
  //  Function listImages()
  /**
   * Returns an Array of strings containing the IDs of all images currently available in the map.
   * @function listImages
   * @returns {string[]} An Array of strings containing the names of all sprites/images currently available in the map.
   */
  listImages() {
    return this.map.listImages();
  }
  //  Function listens()
  /**
   * Returns a true if this instance of Evented or any forwardeed instances of Evented have a listener for the specified type.
   * @function listens
   * @param {string} type - The event type.
   * @returns {boolean} true if there is at least one registered listener for specified event type, false otherwise.
   */
  listens(e) {
    return this.map.listens(e);
  }
  //  Function loadImage()
  /**
   * Load an image from an external URL to be used with Map#addImage.
   * @function loadImage
   * @param {string} url - The URL of the image file. Image file must be in png, webp, or jpg format.
   * @returns {Promise<GetResourceResponse<ImageBitmap | HTMLImageElement>>} A promise that is resolved when the image is loaded.
   */
  loadImage(e) {
    return this.map.loadImage(e);
  }
  //  Function loaded()
  /**
   * Returns a Boolean indicating whether the map is fully loaded.
   * @function loaded
   * @returns {boolean} A Boolean indicating whether the map is fully loaded.
   */
  loaded() {
    return this.map.loaded();
  }
  //  Function new LngLatBounds()
  /**
   * Constructs a new LngLatBounds object representing a geographical bounding box.
   * @class LngLatBounds
   * @constructor
   * @param {LngLatLike} [sw] - The southwest corner of the bounding box. Can be specified as an array of 4 numbers in the order of west, south, east, north, or an array of 2 LngLatLike representing [sw,ne].
   * @param {LngLatLike} [ne] - The northeast corner of the bounding box.
   */
  LngLatBounds(e, t) {
    return new so.LngLatBounds(e, t);
  }
  //  Function addProtocol()
  /**
   * Adds a custom load resource function that will be called when using a URL that starts with a custom URL schema.
   * @function addProtocol
   * @param {string} customProtocol - The protocol to hook, for example 'custom'.
   * @param {AddProtocolAction} loadFn - The function to use when trying to fetch a resource specified by the customProtocol.
   * @returns {void}
   */
  addProtocol(e, t) {
    return this.map.addProtocol(e, t);
  }
  //  Function moveLayer()
  /**
   * Moves a layer to a different z-position.
   * @function moveLayer
   * @param {string} id - The ID of the layer to move.
   * @param {string} [beforeId] - The ID of an existing layer to insert the new layer before.
   * @returns {this}
   */
  moveLayer(e, t) {
    return this.map.moveLayer(e, t);
  }
  //  Function panBy()
  /**
   * Pans the map by the specified offset.
   * @function panBy
   * @param {PointLike} offset - x and y coordinates by which to pan the map.
   * @param {AnimationOptions} [options] - Options object.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panBy(e, t, i) {
    return this.map.panBy(e, t, i);
  }
  //  Function panTo()
  /**
   * Pans the map to the specified location with an animated transition.
   * @function panTo
   * @param {LngLatLike} lnglat - The location to pan the map to.
   * @param {AnimationOptions} [options] - Options describing the destination and animation of the transition.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  panTo(e, t, i) {
    return this.map.panTo(e, t, i);
  }
  //  Function project()
  /**
   * Returns a Point representing pixel coordinates, relative to the map's container, that correspond to the specified geographical location.
   * @function project
   * @param {LngLatLike} lnglat - The geographical location to project.
   * @returns {Point} The Point corresponding to lnglat, relative to the map's container.
   */
  project(e) {
    return this.map.project(e);
  }
  //  Function queryRenderedFeatures()
  /**
   * Queries rendered features within a specified geometry or bounding box.
   * @function queryRenderedFeatures
   * @param {GeometryLike | Array | Object} [geometryOrOptions] - The geometry or options for the query.
   * @param {Object} [options] - Options for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features that intersect the query geometry.
   */
  queryRenderedFeatures(e, t) {
    return this.map.queryRenderedFeatures(e, t);
  }
  //  Function querySourceFeatures()
  /**
   * Queries source features within a specified source.
   * @function querySourceFeatures
   * @param {string} sourceId - The ID of the source to query.
   * @param {Object} parameters - Parameters for the query.
   * @returns {Array} An array of GeoJSON Feature objects representing the features in the source that satisfy the query parameters.
   */
  querySourceFeatures(e, t) {
    return this.map.querySourceFeatures(e, t);
  }
  //  Function queryTerrainElevation()
  /**
   * Queries the terrain elevation at a specified geographical location.
   * @function queryTerrainElevation
   * @param {LngLatLike} lngLatLike - The geographical location to query.
   * @returns {number} The elevation (in meters) at the specified location.
   */
  queryTerrainElevation(e) {
    return this.map.queryTerrainElevation(e);
  }
  //  Function redraw()
  /**
   * Redraws the map.
   * @function redraw
   * @returns {this}
   */
  redraw() {
    return this.map.redraw();
  }
  //  Function remove()
  /**
   * Removes the map from the DOM.
   * @function remove
   * @returns {this}
   */
  remove() {
    return this.map.remove();
  }
  //  Function removeControl()
  /**
   * Removes a control from the map.
   * @function removeControl
   * @param {Object} control - The control to remove.
   * @returns {this}
   */
  removeControl(e) {
    return this.map.removeControl(e);
  }
  //  Function removeFeatureState()
  /**
   * Removes the state of a feature.
   * @function removeFeatureState
   * @param {Object} target - The target feature.
   * @param {string} [key] - The key of the state to remove.
   * @returns {this}
   */
  removeFeatureState(e, t) {
    return this.map.removeFeatureState(e, t);
  }
  //  Function removeImage()
  /**
   * Removes an image from the style's sprite.
   * @function removeImage
   * @param {string} id - The ID of the image to remove.
   * @returns {this}
   */
  removeImage(e) {
    return this.map.removeImage(e);
  }
  /**
   * Removes a layer from the map.
   * @function removeLayer
   * @param {string} idLayer - Identifier of the layer to remove.
   */
  removeLayer(e) {
    try {
      this.map.removeLayer(e);
    } catch (t) {
      console.error(`Error removing layer: ${t.message}`);
    }
  }
  /**
   * Removes a source from the map.
   * @function removeSource
   * @param {string} idLayer - Identifier of the source to remove.
   */
  removeSource(e) {
    try {
      this.map.removeSource(e);
    } catch (t) {
      console.error(`Error removing source: ${t.message}`);
    }
  }
  //  Function removeSprite()
  /**
   * Removes a sprite from the style.
   * @function removeSprite
   * @param {string} id - The ID of the sprite to remove.
   * @returns {this}
   */
  removeSprite(e) {
    return this.map.removeSprite(e);
  }
  //  Function resetNorth()
  /**
   * Resets the map orientation so that north is up.
   * @function resetNorth
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorth(e, t) {
    return this.map.resetNorth(e, t);
  }
  //  Function resetNorthPitch()
  /**
   * Resets the map orientation so that north is up and pitch is set to 0°.
   * @function resetNorthPitch
   * @param {Object} [options] - Options for the reset.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resetNorthPitch(e, t) {
    return this.map.resetNorthPitch(e, t);
  }
  //  Function resize()
  /**
   * Resizes the map to fit its container.
   * @function resize
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  resize(e) {
    return this.map.resize(e);
  }
  //  Function rotateTo()
  /**
   * Rotates the map to the specified bearing with an animated transition.
   * @function rotateTo
   * @param {number} bearing - The desired bearing (in degrees) to rotate the map to.
   * @param {Object} [options] - Options for the rotation.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  rotateTo(e, t, i) {
    return this.map.rotateTo(e, t, i);
  }
  //  Function setBearing()
  /**
   * Sets the map's bearing with an optional animated transition.
   * @function setBearing
   * @param {number} bearing - The desired bearing (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setBearing(e, t) {
    return this.map.setBearing(e, t);
  }
  //  Function setCenter()
  /**
   * Sets the map's center coordinates with an optional animated transition.
   * @function setCenter
   * @param {LngLatLike} center - The desired center coordinates to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setCenter(e, t) {
    return this.map.setCenter(e, t);
  }
  //  Function setEventedParent()
  /**
   * Sets the parent of the map's event emitter.
   * @function setEventedParent
   * @param {any} [parent] - The parent object to set for the event emitter.
   * @param {any} [data] - Additional data to pass to the parent.
   * @returns {this}
   */
  setEventedParent(e, t) {
    return this.map.setEventedParent(e, t);
  }
  //  Function setFeatureState()
  /**
   * Sets the state of a feature.
   * @function setFeatureState
   * @param {Object} feature - The feature to set the state for.
   * @param {Object} state - The state object to set for the feature.
   * @returns {this}
   */
  setFeatureState(e, t) {
    return this.map.setFeatureState(e, t);
  }
  //  Function setFilter()
  /**
   * Sets the filter for a specified layer.
   * @function setFilter
   * @param {string} layerId - The ID of the layer to set the filter for.
   * @param {Array} [filter] - The filter array to apply to the layer.
   * @param {Object} [options] - Options for the filter.
   * @returns {this}
   */
  setFilter(e, t, i) {
    return this.map.setFilter(e, t, i);
  }
  //  Function setGlyphs()
  /**
   * Sets the glyphs for the map's style.
   * @function setGlyphs
   * @param {string} glyphsUrl - The URL to the glyphs.
   * @param {Object} [options] - Options for setting the glyphs.
   * @returns {this}
   */
  setGlyphs(e, t) {
    return this.map.setGlyphs(e, t);
  }
  //  Function setLayerZoomRange()
  /**
   * Sets the zoom range for a specified layer.
   * @function setLayerZoomRange
   * @param {string} layerId - The ID of the layer to set the zoom range for.
   * @param {number} minzoom - The minimum zoom level for the layer.
   * @param {number} maxzoom - The maximum zoom level for the layer.
   * @returns {this}
   */
  setLayerZoomRange(e, t, i) {
    return this.map.setLayerZoomRange(e, t, i);
  }
  //  Function setLayoutProperty()
  /**
   * Sets a layout property for a specified layer.
   * @function setLayoutProperty
   * @param {string} layerId - The ID of the layer to set the layout property for.
   * @param {string} name - The name of the layout property to set.
   * @param {any} value - The value to set for the layout property.
   * @param {Object} [options] - Options for setting the layout property.
   * @returns {this}
   */
  setLayoutProperty(e, t, i, r) {
    return this.map.setLayoutProperty(e, t, i, r);
  }
  //  Function setLight()
  /**
   * Sets the light for the map's style.
   * @function setLight
   * @param {Object} light - The light object to set for the map.
   * @param {Object} [options] - Options for setting the light.
   * @returns {this}
   */
  setLight(e, t) {
    return this.map.setLight(e, t);
  }
  //  Function setMaxBounds()
  /**
   * Sets the maximum bounds for the map.
   * @function setMaxBounds
   * @param {Array} bounds - The maximum bounds for the map.
   * @returns {this}
   */
  setMaxBounds(e) {
    return this.map.setMaxBounds(e);
  }
  //  Function setMaxPitch()
  /**
   * Sets the maximum pitch for the map.
   * @function setMaxPitch
   * @param {number} maxPitch - The maximum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMaxPitch(e) {
    return this.map.setMaxPitch(e);
  }
  //  Function setMaxZoom()
  /**
   * Sets the maximum zoom level for the map.
   * @function setMaxZoom
   * @param {number} maxZoom - The maximum zoom level for the map.
   * @returns {this}
   */
  setMaxZoom(e) {
    return this.map.setMaxZoom(e);
  }
  //  Function setMinPitch()
  /**
   * Sets the minimum pitch for the map.
   * @function setMinPitch
   * @param {number} minPitch - The minimum pitch (in degrees) for the map.
   * @returns {this}
   */
  setMinPitch(e) {
    return this.map.setMinPitch(e);
  }
  //  Function setMinZoom()
  /**
   * Sets the minimum zoom level for the map.
   * @function setMinZoom
   * @param {number} minZoom - The minimum zoom level for the map.
   * @returns {this}
   */
  setMinZoom(e) {
    return this.map.setMinZoom(e);
  }
  //  Function setPadding()
  /**
   * Sets padding for the map's container.
   * @function setPadding
   * @param {Object} padding - The padding object to set for the map's container.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPadding(e, t) {
    return this.map.setPadding(e, t);
  }
  //  Function setPaintProperty()
  /**
   * Sets a paint property for a specified layer.
   * @function setPaintProperty
   * @param {string} layerId - The ID of the layer to set the paint property for.
   * @param {string} name - The name of the paint property to set.
   * @param {any} value - The value to set for the paint property.
   * @param {Object} [options] - Options for setting the paint property.
   * @returns {this}
   */
  setPaintProperty(e, t, i, r) {
    return this.map.setPaintProperty(e, t, i, r);
  }
  //  Function setPitch()
  /**
   * Sets the map's pitch angle with an optional animated transition.
   * @function setPitch
   * @param {number} pitch - The desired pitch angle (in degrees) to set for the map.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setPitch(e, t) {
    return this.map.setPitch(e, t);
  }
  //  Function setPixelRatio()
  /**
   * Sets the pixel ratio for the map.
   * @function setPixelRatio
   * @param {number} pixelRatio - The desired pixel ratio for the map.
   * @returns {this}
   */
  setPixelRatio(e) {
    return this.map.setPixelRatio(e);
  }
  //  Function setRenderWorldCopies()
  /**
   * Sets whether the map should render world copies when the center longitude is greater than or less than ±180 degrees.
   * @function setRenderWorldCopies
   * @param {boolean} renderWorldCopies - A boolean indicating whether to render world copies.
   * @returns {this}
   */
  setRenderWorldCopies(e) {
    return this.map.setRenderWorldCopies(e);
  }
  //  Function setSprite()
  /**
   * Sets the sprite for the map's style.
   * @function setSprite
   * @param {string} spriteUrl - The URL to the sprite.
   * @param {Object} [options] - Options for setting the sprite.
   * @returns {this}
   */
  setSprite(e, t) {
    return this.map.setSprite(e, t);
  }
  //  Function setTerrain()
  /**
   * Loads a 3D terrain mesh based on a "raster-dem" source.
   * @function setTerrain
   * @param {TerrainSpecification} options - Options object specifying the terrain source.
   * @returns {this}
   */
  setTerrain(e) {
    return this.map.setTerrain(e);
  }
  //  Function setTransformRequest()
  /**
   * Updates the requestManager's transform request with a new function.
   * @function setTransformRequest
   * @param {RequestTransformFunction} transformRequest - The callback function to update the transform request.
   * @returns {this}
   */
  setTransformRequest(e) {
    return this.map.setTransformRequest(e);
  }
  //  Function setZoom()
  /**
   * Sets the map's zoom level.
   * @function setZoom
   * @param {number} zoom - The zoom level to set (0-20).
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  setZoom(e, t) {
    return this.map.setZoom(e, t);
  }
  //  Function snapToNorth()
  /**
   * Snaps the map so that north is up (0° bearing), if the current bearing is close enough to it.
   * @function snapToNorth
   * @param {Object} [options] - Options for snapping to north.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  snapToNorth(e, t) {
    return this.map.snapToNorth(e, t);
  }
  //  Function stop()
  /**
   * Stops any animated transition underway.
   * @function stop
   * @returns {this}
   */
  stop() {
    return this.map.stop();
  }
  //  Function triggerRepaint()
  /**
   * Triggers the rendering of a single frame.
   * @function triggerRepaint
   * @returns {void}
   */
  triggerRepaint() {
    return this.map.triggerRepaint();
  }
  //  Function unproject()
  /**
   * Returns geographical coordinates corresponding to the specified pixel coordinates.
   * @function unproject
   * @param {PointLike} point - The pixel coordinates to unproject.
   * @returns {LngLat} The geographical coordinates corresponding to the specified pixel coordinates.
   */
  unproject(e) {
    return this.map.unproject(e);
  }
  //  Function updateImage()
  /**
   * Updates an existing image in the style's sprite.
   * @function updateImage
   * @param {string} id - The ID of the image to update.
   * @param {ImageBitmap | HTMLImageElement | ImageData | StyleImageInterface | object} image - The new image data.
   * @returns {this}
   */
  updateImage(e, t) {
    return this.map.updateImage(e, t);
  }
  //  Function zoomIn()
  /**
   * Increases the map's zoom level by 1.
   * @function zoomIn
   * @param {Object} [options] - Options for zooming in.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomIn(e, t) {
    return this.map.zoomIn(e, t);
  }
  //  Function zoomOut()
  /**
   * Decreases the map's zoom level by 1.
   * @function zoomOut
   * @param {Object} [options] - Options for zooming out.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomOut(e, t) {
    return this.map.zoomOut(e, t);
  }
  //  Function zoomTo()
  /**
   * Zooms the map to the specified zoom level with an animated transition.
   * @function zoomTo
   * @param {number} zoom - The zoom level to transition to.
   * @param {Object} [options] - Options for zooming to.
   * @param {any} [eventData] - Additional properties to be added to event objects of events triggered by this method.
   * @returns {this}
   */
  zoomTo(e, t, i) {
    return this.map.zoomTo(e, t, i);
  }
  // end maplibre methods
  /**
   * Adds a GeoJSON layer to the map.
   * @function addLayerGeoJSON
   * @param {Object} layer - Options for the GeoJSON layer to add.
   * @param {string} layer.id - Unique identifier for the layer.
   * @param {Object} layer.data - GeoJSON data for the layer.
   * @param {string} layer.type - Map layer type (e.g., 'symbol', 'circle', 'fill').   *
   * @param {Object} layer.layout - Layer layout configuration.
   * @param {Object} layer.paint - Layer paint configuration.
   * @param {string} layerPosition - Position of the layer: 'top', below 'labels' or below 'lines'.
   */
  addLayerGeoJSON(e, t) {
    try {
      let i = this._dealOrderLayer(t);
      this.map.addSource(`${e.id}`, {
        type: "geojson",
        data: e.data
      }), this.map.addLayer({
        id: `${e.id}-layerIcgcMap`,
        type: e.type,
        source: `${e.id}`,
        layout: e.layout,
        paint: e.paint
      }, i);
    } catch (i) {
      console.error(`Error adding GeoJSON layer: ${i.message}`);
    }
  }
  /**
   * Adds a WMS layer to the map.
   * @function addLayerWMS
   
   * @param {string[]} tiles - Tiles for the raster layer.
   * @param {string} idLayer - Unique identifier for the layer.
   * @param {Object} options - Options of the layer: layout, paint and layerPosition.
   */
  addLayerWMS(e, t, i) {
    try {
      let r = this._dealOrderLayer(i.layerPosition);
      i ? (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, r), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        layout: i.layout,
        paint: i.paint
      }, r)) : (this.map.addSource(`${t}`, {
        type: "raster",
        tiles: [e],
        tileSize: 256
      }, r), this.map.addLayer({
        id: t,
        type: "raster",
        source: t,
        paint: {}
      }, r));
    } catch (r) {
      console.error(`Error adding WMS layer: ${r.message}`);
    }
  }
  /**
   * Adds a logo to the map.
   * @function addLogo
   * @param {Object} options - Options for the logo to add.
   * @param {string} options.id - Unique identifier for the logo.
   * @param {string} options.url - URL of the logo image.
   * @param {string} options.href - URL to navigate to when the logo is clicked.
   * @param {string} options.height - Height of the logo.
   */
  addLogo(e) {
    try {
      let t = document.getElementById("map"), i;
      i = document.createElement("div"), i.id = "logos", t.appendChild(i);
      const r = document.createElement("img");
      r.src = e.url, r.style.height = e.height;
      const l = document.getElementById("logos"), c = document.createElement("a");
      c.id = e.id, c.href = e.href, c.target = "_blank", c.style.position = "relative", c.style.bottom = "1px", c.appendChild(r), l.appendChild(c);
    } catch (t) {
      console.error(`Error adding logo: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemapsICGC
   * @param {Object[]} basesArray - Array of base layer objects.
   */
  addBasemapsICGC(e) {
    try {
      const t = (c) => {
        this.map.setStyle(c);
      };
      let i = document.getElementById("map"), r;
      r = document.createElement("div"), r.id = "basemap-group", r.classList.add = "filter-group", i.appendChild(r);
      const l = document.getElementById("basemap-group");
      for (const c of e)
        for (const a of Object.keys(Vi.baseStyles)) {
          const g = Vi.baseStyles[a];
          if (c === g.url) {
            const y = document.createElement("div");
            y.className = "basemap-item", y.title = g.key, y.style.backgroundImage = `url('${g.image}')`, l.appendChild(y), y.addEventListener("click", () => t(g.url));
          }
        }
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds base layers to the map.
   * @function addBasemaps
   * @param {Object[]} baseLayers - Array of base layer objects.
   * @param {string} baseLayers.label - Label for the base layer.
   * @param {string} baseLayers.image - URL of the image representing the base layer.
   * @param {string} baseLayers.url - URL of the base layer style.
   */
  addBasemaps(e) {
    try {
      const t = (c) => {
        map.setStyle(c.url);
      };
      let i = document.getElementById("map"), r;
      r = document.createElement("div"), r.id = "basemap-group", r.classList.add = "basemap-group", i.appendChild(r);
      const l = document.getElementById("basemap-group");
      e.forEach((c) => {
        const a = document.createElement("div");
        a.className = "basemap-item", a.title = c.label, a.style.backgroundImage = `url('${c.image}')`, l.appendChild(a), a.addEventListener("click", () => t(c));
      });
    } catch (t) {
      console.error(`Error adding basemaps: ${t.message}`);
    }
  }
  /**
   * Adds feature query function to a layer.
   * @function addFeatureQuery
   * @param {string} idLayer - name of the layer
   * @param {objetc} queryFields - optional indications for the popup
   * @param {objetc} popupStyle - optional indications for the popup style
   */
  addFeatureQuery(e, t, i) {
    try {
      let r;
      this.map.on("mouseenter", e, () => {
        this.map.getCanvas().style.cursor = "pointer";
      }), this.map.on("mouseleave", e, () => {
        this.map.getCanvas().style.cursor = "";
      }), this.map.on("click", (l) => {
        let c = this.map.queryRenderedFeatures(l.point);
        if (c && c[0].source.includes(e)) {
          let a = [l.lngLat.lng, l.lngLat.lat];
          if (t !== void 0 && t.length > 0 && t !== "all") {
            if (t !== null) {
              let g = "";
              t.forEach((y) => {
                let A = c[0].properties[y];
                g = g + `<h4>${A}</h4>`;
              }), r = g, this.addPopup(a, r, i);
            }
          } else {
            let g = "";
            for (const y in c[0].properties)
              g += "<b>" + y + "</b>:" + c[0].properties[y] + "<br>";
            r = g, this.addPopup(a, r, i);
          }
        }
      });
    } catch (r) {
      console.error(`Error adding feature query: ${r.message}`);
    }
  }
  /**
   * Adds a scale control to the map.
   *  * @function addScaleControl
   * @param {Object} options - Options for configuring the scale control.
   * @param {string} position - The position on the map to place the scale control (e.g., 'top-left', 'bottom-right').
   */
  addScaleControl(e, t) {
    try {
      var i = new so.ScaleControl(e);
      this.map.addControl(i, t);
    } catch (r) {
      console.error(`Error adding scale: ${r.message}`);
    }
  }
  /**
   * Adds an export control to the map with the provided options and position.
   * @function addExportControl
   * @param {Object|string} options - Options for the export control or position if provided as a string.
   * @param {string} [position] - Position to place the export control (e.g., 'top-right').
   */
  addExportControl(e, t) {
    try {
      typeof e == "string" && (t = e, e = void 0), e === void 0 && (e = {
        PageSize: qh.A4,
        PageOrientation: pp.Landscape,
        Format: Eu.PNG,
        DPI: v1[300],
        Crosshair: !0,
        PrintableArea: !0,
        Local: "ca"
      }, t = "top-right"), this.map.addControl(new xq(e), t);
    } catch (i) {
      console.error(`Error adding export control: ${i.message}`);
    }
  }
  /**
   * Adds a marker to the map.
   * @function addMarker
   * @param {Object} options - Options for the marker to add.
   * @param {string} options.text - Text content for the marker popup.
   * @param {Object} options.options - Marker options.
   * @param {LngLatLike} options.coord - Coordinates for placing the marker.
   * @param {Object} options.textOffset - Text offset for the marker popup.
   * @returns {Object} - Instance of the added marker.
   */
  addMarker(e) {
    try {
      let t, i;
      return e.text === void 0 ? t = new so.Marker(e.options).setLngLat(e.coord).addTo(this.map) : (i = new so.Popup({
        offset: e.textOffset
      }).setHTML(e.text), t = new so.Marker(e.options).setLngLat(e.coord).setPopup(i).addTo(this.map)), t;
    } catch (t) {
      return console.error(`Error adding marker: ${t.message}`), null;
    }
  }
  /**
   * Adds a popup to the map.
   * @function addPopup
   * @param {Object} options - Options for the popup to add.
   * @param {LngLatLike} coord - Coordinates for placing the popup.
   * @param {string} text - HTML content for the popup.
   * @param {string} popupStyle - css content for the popup style.
   * @returns {Object} - Instance of the added popup.
   */
  addPopup(e, t, i) {
    try {
      return i.image === void 0 ? new so.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${i.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
 ${t}
          </div>
          <div class="popupBottomDown">
          </div>
          </div>
        </div>
      `).addTo(this.map) : new so.Popup().setLngLat(e).setHTML(`
        <div class="popupBody">
          <div class="popupTop">
          ${i.title}
          </div>
          <div class="popupBottom">
          <div class="popupBottomUp">
          ${t}
          </div>
          <div class="popupBottomDown">
             <img style="  padding: 8px;  width: 50%;" src=${i.image} />
          </div>
          </div>
        </div>
      `).addTo(this.map);
    } catch (r) {
      return console.error(`Error adding popup: ${r.message}`), null;
    }
  }
  /**
   * Adds a fullscreen control to the map.
   * @function addFullScreen
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addFullScreen(e) {
    try {
      e === void 0 && (e = "top-right"), this.map.addControl(new so.FullscreenControl(), e);
    } catch (t) {
      console.error(`Error adding fullscreen control: ${t.message}`);
    }
  }
  /**
   * Adds a menu item with a checkbox for controlling the visibility of a layer on the map.
   * @function addMenuItem
   * @param {string} name - The name of the layer corresponding to the menu item.
   */
  addMenuItem(e) {
    try {
      let t;
      if (e.includes("-userFieldFilter-") ? t = e.split("-userFieldFilter-")[0] : t = e, e.length > 0) {
        const i = document.getElementById("menu-group"), r = document.createElement("input");
        r.type = "checkbox", r.id = e, r.checked = !0, i.appendChild(r);
        const l = document.createElement("label");
        l.setAttribute("for", e), l.textContent = t, i.appendChild(l), r.addEventListener("change", (c) => {
          this.map.setLayoutProperty(e, "visibility", c.target.checked ? "visible" : "none");
        });
      }
    } catch (t) {
      console.error(`Error adding menu item: ${t.message}`);
    }
  }
  /**
   * Adds a layer tree to the map.
   * @function addLayerTree
   * @param {Object} options - Options for the layer tree to add.
   * @param {Object} options.features - Features for the layer tree.
   * @param {string} options.id - Unique identifier for the layer tree.
   * @param {string} options.type - Type of layer tree ('geojson', 'raster', etc.).
   */
  addLayerTree(e) {
    try {
      let t = e.features, i = document.getElementById("map"), r = document.createElement("nav");
      r.id = "filter-group", i.appendChild(r);
      const l = document.getElementById("filter-group");
      this.map.addSource(`${e.id}`, {
        type: e.type,
        data: t
      }), t.features.forEach((c) => {
        const a = c.properties.icon, g = `poi-${a}`;
        if (!this.map.getLayer(g)) {
          this.map.addLayer({
            id: g,
            type: "circle",
            source: `${e.id}`,
            paint: {
              "circle-radius": 6,
              "circle-color": "#B42222"
            },
            filter: ["==", "icon", a]
          }, this._firstSymbolLayer());
          const y = document.createElement("input");
          y.type = "checkbox", y.id = g, y.checked = !0, l.appendChild(y);
          const A = document.createElement("label");
          A.setAttribute("for", g), A.textContent = a, l.appendChild(A), y.addEventListener("change", (C) => {
            this.map.setLayoutProperty(g, "visibility", C.target.checked ? "visible" : "none");
          });
        }
      });
    } catch (t) {
      console.error(`Error adding layer tree: ${t.message}`);
    }
  }
  /**
   * Creates a navigation control with the provided options.
   * @function createNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   * @returns {Object} - Instance of the created navigation control.
   */
  createNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new so.NavigationControl(e), t);
    } catch (i) {
      return console.error(`Error creating navigation control: ${i.message}`), null;
    }
  }
  /**
   * Adds a navigation control to the map with the provided options.
   * @function addNavigationControl
   * @param {Object} options - Options for the navigation control.
   * @param {string} [position='top-right'] - Position to add the control on the map.
   */
  addNavigationControl(e, t) {
    try {
      t === void 0 && (t = "top-right"), this.map.addControl(new so.NavigationControl(e), t);
    } catch (i) {
      console.error(`Error adding navigation control: ${i.message}`);
    }
  }
  /**
   * Adds an attribution control to the map with the provided options.
   * @function addAttributionControl
   * @param {Object} options - Options for the attribution control.
   * @param {string} [position='bottom-right'] - Position to add the control on the map.
   */
  addAttributionControl(e, t) {
    try {
      this.map.addControl(new so.AttributionControl(e), t);
    } catch (i) {
      console.error(`Error adding attribution control: ${i.message}`);
    }
  }
  /**
   * Adds an ICGC image layer to the map based on the specified name and year.
   * @function addImageLayerICGC
   * @param {string} url - The url of the  layer.
   * @param {string} idLayer - The user id for the  layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   */
  addImageLayerICGC(e, t, i) {
    try {
      let r = null, l, c;
      i ? (c = i, l = i.layerPosition) : c = {
        type: "raster",
        layout: {
          visibility: "visible"
        },
        paint: {
          "raster-opacity": 1
        },
        layerPosition: tm
      }, r = this._findImageType(e, ns.Orto, ns.VectorAdmin, ns.WMS, ns.Vector), r || console.log("❌ %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
      let a = {
        id: t,
        tiles: e
      };
      this.addLayerWMS(e, t, c);
    } catch (r) {
      console.error(`Error adding ICGC image layer: ${r.message}`);
    }
  }
  /**
   * Adds an ICGC vector layer to the map based on the specified name and year.
   * @function addVectorLayerICGC
   * @param {string} url - The url of the vector layer.
   * @param {string} idLayer - The user id for the vector layer.
   * @param {object} options - Type, position,layout and paint options for the layer
   *
   */
  async addVectorLayerICGC(e, t, i) {
    try {
      let {
        type: r = "line",
        layerPosition: l = tm,
        layoutOptions: c = {
          visibility: "visible"
        },
        paintOption: a
      } = i || {}, g = this._dealOrderLayer(l);
      if (!e) {
        console.log("❌ %c The layer: %c%s%c does not exist in the ICGC DB. Consult the documentation.", "font-weight: bold; font-style: italic;", "font-weight: normal; font-style: normal; color: red;", e, "font-weight: bold; font-style: italic;");
        return;
      }
      if (e.includes("https")) {
        let y = this._getKeyByUrlVector(e);
        this.map.addSource(y, {
          type: "vector",
          url: e
        });
        let A = {
          id: y,
          type: "fill",
          source: y,
          "source-layer": "cobertes",
          maxzoom: 18,
          layout: i.layout,
          paint: LW.cobertesSol
        };
        if (y === "cobertes2018" && this.map.addLayer(A, g), c.visibility === "visible") {
          let C = this._getLegendByName(y);
          this.addLegend(C, y);
        }
      } else {
        let y = t;
        this.map.addSource(y, {
          type: "vector",
          url: Vi.limitsUrl
        });
        let A = {
          id: t,
          type: r,
          source: y,
          "source-layer": e,
          layout: i.layout,
          paint: i.paint || {}
        };
        r === "fill" || r === "polygon" ? A.paint = a || {
          "fill-color": "#0000FF",
          "fill-opacity": 0
        } : r === "line" && (A.paint = a || {
          "line-color": "#4832a8",
          "line-opacity": 1,
          "line-width": 1
        }), this.map.addLayer(A, g);
      }
    } catch (r) {
      console.error(`Error adding ICGC vector layer: ${r.message}`);
    }
  }
  /**
   * Adds an ICGC FGB layer to the map based on the specified name and year.
   * @function addFGBLayerICGC
   * @param {string} url - The url of the FGB layer.
   * @param {string} idLayer - Id for the layer.
   * @param {object} options - Paint option for the layer
   *
   */
  async addFGBLayerICGC(e, t, i) {
    try {
      i || (i.layout = {
        visibility: !0
      }, i.paint = {
        "line-color": "#4832a8",
        "line-opacity": 1,
        "line-width": 1
      }, i.type = "lines", i.layerPosition = "labels");
      let r = this._dealOrderLayer(i.layerPosition);
      const l = await fetch(e), c = {
        type: "FeatureCollection",
        features: []
      };
      for await (const g of ex(l.body)) c.features.push(g);
      let a = t;
      this.map.addSource(a, {
        type: "geojson",
        data: c
      }), e.includes("text") ? this.map.addLayer({
        id: t,
        type: "symbol",
        source: a,
        layout: {
          "text-letter-spacing": 0.1,
          "text-size": {
            base: 1.2,
            stops: [[8, 0], [12, 14], [15, 15]]
          },
          "text-font": ["FiraSans-Regular"],
          "text-field": ["get", "NOM_AC"],
          "text-transform": "none",
          "text-max-width": 25,
          visibility: i.layout.visibility,
          "text-justify": "right",
          "text-anchor": "top",
          "text-allow-overlap": !1,
          "symbol-spacing": 2,
          "text-line-height": 1
        },
        paint: {
          "text-halo-blur": 0.5,
          "text-color": "rgba(90, 7, 7, 1)",
          "text-halo-width": 2,
          "text-halo-color": "rgba(255, 255, 255,0.8)"
        }
      }, r) : this.map.addLayer({
        id: t,
        type: i.type,
        source: a,
        layout: i.layout,
        paint: i.paint
      }, r);
    } catch (r) {
      console.error(`Error adding ICGC FGB layer: ${r.message}`);
    }
  }
  /**
   * Adds 3D terrain to the map using hillshade.
   * @function addTerrainICGC
   * @param {string} url - dataset url of the terrain
   * @param {string} controlPosition - Position to add the control on the map.
   */
  addTerrainICGC(e, t) {
    try {
      let i;
      for (const l in up)
        if (up.hasOwnProperty(l)) {
          const c = up[l];
          c === e && (i = c);
        }
      let r = i;
      this.getSource("terrainICGC") !== void 0 && (this.getStyle().layers.forEach((c) => {
        c.source === "terrainICGC" && this.removeLayer(c.id);
      }), this.removeSource("terrainICGC")), this.getSource("terrainICGC") === void 0 && (e.includes("terrarium") ? this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [r],
        tileSize: 512,
        encoding: "terrarium",
        maxzoom: 16
      }) : this.map.addSource("terrainICGC", {
        type: "raster-dem",
        tiles: [r],
        tileSize: 256,
        maxzoom: 14,
        minzoom: 7
      })), this.map.setTerrain({
        source: "terrainICGC",
        exaggeration: 1.5
      }), t == null || this.map.addControl(new _I({
        pitch: 90,
        bearing: null,
        minpitchzoom: null
      }), t);
    } catch (i) {
      console.error(`Error adding 3D terrain: ${i.message}`);
    }
  }
  /**
   * Add image legend.
   * @function addLegend
   * @param {string} url - image legend url.
   * @param {string} idLayer - layer's name.
   */
  addLegend(e, t) {
    try {
      this.map.addControl(new $q({
        url: e,
        idLayer: t
      }));
    } catch (i) {
      console.error(`Error adding legend: ${i.message}`);
    }
  }
  //Internal methods
  /**
   * Finds the type of image based on the provided URL and specified vectors.
   * @function _findImageType
   * @param {string} url - The URL of the image to find the type for.
   * @param {Object} var1 - The first vector object containing key-value pairs.
   * @param {Object} var2 - The second vector object containing key-value pairs.
   * @param {Object} var3 - The third vector object containing key-value pairs.
   * @param {Object} var4 - The fourth vector object containing key-value pairs.
   * @returns {string|null} - The type of image if found, otherwise null.
   */
  _findImageType(e, t, i, r, l) {
    const c = [t, i, r, l];
    for (const a of c)
      for (const [g, y] of Object.entries(a))
        if (y === e)
          return g;
    return null;
  }
  /**
   * Gets the key by URL from the FGBAdmin layers.
   * @function _getKeyByUrlFGB
   * @param {string} url - The URL to find the key for in the FGBAdmin layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlFGB(e) {
    for (const t in ns.FGBAdmin)
      if (ns.FGBAdmin.hasOwnProperty(t) && ns.FGBAdmin[t] === e)
        return t;
    return null;
  }
  /**
   * Gets the legend by name from the default vector layers.
   * @function _getLegendByName
   * @param {string} name - The name of the vector layer to get the legend for.
   * @returns {string|null} - The legend if found, otherwise null.
   */
  _getLegendByName(e) {
    for (const t in Vi.vectorLayers) {
      const i = Vi.vectorLayers[t];
      if (i.key === e)
        return i.legend;
    }
    return null;
  }
  /**
   * Gets the key by URL from the Vector layers.
   * @function _getKeyByUrlVector
   * @param {string} url - The URL to find the key for in the Vector layers.
   * @returns {string|null} - The key if found, otherwise null.
   */
  _getKeyByUrlVector(e) {
    for (const t in ns.Vector)
      if (ns.Vector.hasOwnProperty(t) && ns.Vector[t] === e)
        return t;
    return null;
  }
  /**
   * Raises text 3D style on the map.
   * @function _raiseText3DStyle
   * @async
   * @returns {Promise<void>} - A promise that resolves after updating the text 3D style on the map.
   */
  async _raiseText3DStyle() {
    try {
      const e = await this.map.loadImage(Vi.map3dOptions.imageIcon);
      this.map.hasImage("stick") || this.map.addImage("stick", e.data), this.map.getStyle().layers.forEach((t) => {
        if (t["source-layer"] === Vi.map3dOptions.sourceLayerFilterId && t.minzoom >= Vi.map3dOptions.minZoomFilter && e) {
          const i = t.id;
          this.map.setLayoutProperty(i, "icon-image", "stick"), this.map.setLayoutProperty(i, "text-offset", [0, -9]), this.map.setLayoutProperty(i, "symbol-placement", "point"), this.map.setLayoutProperty(i, "symbol-avoid-edges", !1), this.map.setLayoutProperty(i, "text-allow-overlap", !0), this.map.setLayoutProperty(i, "text-ignore-placement", !1), this.map.setLayoutProperty(i, "text-pitch-alignment", "auto"), this.map.setLayoutProperty(i, "text-rotation-alignment", "auto"), this.map.setLayoutProperty(i, "text-justify", "center"), this.map.setLayoutProperty(i, "text-anchor", "bottom"), this.map.setLayoutProperty(i, "icon-anchor", "bottom"), this.map.setPaintProperty(i, "text-color", "#ffffff"), this.map.setPaintProperty(i, "text-halo-color", "#000000"), this.map.setPaintProperty(i, "text-halo-width", 2);
        }
      });
    } catch (e) {
      return console.error(`Error dealing orto 3D: ${e.message}`), null;
    }
  }
  /**
   * Deals with map styles based on the name.
   * @function _dealStyleMaps
   * @param {string} name - The name of the map style.
   * @returns {Object|string|null} - The map style object if found, or the input name if not found, or null if an error occurs.
   */
  _dealStyleMaps(e) {
    try {
      if (e && e.indexOf("icgc.cat") != -1) {
        for (const t in Fh)
          if (Fh.hasOwnProperty(t)) {
            const i = Fh[t];
            if (t === e)
              return i;
          }
        return Fh[0];
      } else
        return e;
    } catch (t) {
      return console.error(`Error dealing with map styles: ${t.message}`), null;
    }
  }
  /**
   * Deals with the 3D ortho style based on the name.
   * @function _dealOrto3dStyle
   * @param {string} name - The name of the orto3D style.
   * @returns {void|null} - Returns null if an error occurs.
   */
  _dealOrto3dStyle(e) {
    try {
      if (e == "orto3d") {
        console.log("map"), this.map.setMaxZoom(18.8), this.map.easeTo({
          pitch: 45
        });
        const t = new ME({
          intensity: 4
        }), i = new Eb({
          ambientLight: t
        });
        this.map.setTerrain({
          source: Vi.map3dOptions.terrainSource,
          exaggeration: Vi.map3dOptions.exaggeration
        });
        const r = this._createCitiesMapboxLayer();
        this.map.getLayer(Vi.map3dOptions.layerId3d) || (this.map.addLayer(r, Vi.map3dOptions.layerIdOrder), this.map.setLayerZoomRange(Vi.map3dOptions.layerId3d, Vi.map3dOptions.minZoomRange, Vi.map3dOptions.maxZoomRange), r.deck.setProps({
          effects: [i]
        }), this._raiseText3DStyle()), this.map.setSky({
          "sky-color": "#86bbd5",
          "sky-horizon-blend": 0.3,
          "horizon-color": "#ffffff33",
          "horizon-fog-blend": 0.1,
          "fog-ground-blend": 0.75,
          "fog-color": "#c5d6d6"
        });
      } else
        this.map.getLayer(Vi.map3dOptions.layerId3d) && (this.map.removeLayer(Vi.map3dOptions.layerId3d), this.map.setTerrain(null));
    } catch (t) {
      return console.error(`Error dealing orto 3D: ${t.message}`), null;
    }
  }
  /**
   * Deals with the order of the layer.
   * @function _dealOrderLayer
   * @param {string} order - The order of the layer.
   * @returns {string} - The id of the first symbol layer if the order is 'symbol', the id of the first line layer if the order is 'line', otherwise an empty string.
   */
  _dealOrderLayer(e) {
    return e === tm ? this._firstSymbolLayer() : e === RW ? this._firstLineLayer() : "";
  }
  /**
   * Retrieves the id of the first symbol layer.
   * @function _firstSymbolLayer
   * @returns {string|undefined} - The id of the first symbol layer if found, otherwise undefined.
   */
  _firstSymbolLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let i = 0; i < e.length; i++)
        if (e[i].type === "symbol" && e[i].id.indexOf("contour") === -1 && e[i].id.indexOf("water") === -1) {
          t = e[i].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Retrieves the id of the first line layer.
   * @function _firstLineLayer
   * @returns {string|undefined} - The id of the first line layer if found, otherwise undefined.
   */
  _firstLineLayer() {
    try {
      const e = this.map.getStyle().layers;
      let t;
      for (let i = 0; i < e.length; i++)
        if (e[i].type === "line") {
          t = e[i].id;
          break;
        }
      return t;
    } catch (e) {
      console.error(`Error getting first symbol layer: ${e.message}`);
    }
  }
  /**
   * Creates a Mapbox layer for displaying cities in 3D.
   * @function _createCitiesMapboxLayer
   * @returns {MapboxLayer|null} - The Mapbox layer for displaying cities in 3D if created successfully, otherwise null.
   */
  _createCitiesMapboxLayer() {
    try {
      return new W8({
        id: Vi.map3dOptions.layerId3d,
        type: tv,
        data: Vi.map3dOptions.urlTilesetCities,
        loader: ev,
        loadOptions: {
          tileset: {
            viewDistanceScale: 1,
            updateTransforms: !0,
            maximumScreenSpaceError: Vi.map3dOptions.spaceErrorFactor
          }
        },
        onTilesetLoad: (t) => {
          t.options.maximumScreenSpaceError = Vi.map3dOptions.spaceErrorFactor;
        },
        onTileLoad: (t) => {
          t.content.cartographicOrigin.z -= Vi.map3dOptions.zfactor;
        },
        operation: "terrain+draw"
      });
    } catch (e) {
      return console.error(`Error adding MapboxLayer: ${e.message}`), null;
    }
  }
};
var Q3 = { exports: {} };
function BW(n, e) {
  var t = n.getCenter(), i = n.getZoom(), r = n.getBearing(), l = n.getPitch();
  e.forEach(function(c) {
    c.jumpTo({
      center: t,
      zoom: i,
      bearing: r,
      pitch: l
    });
  });
}
function OW() {
  var n, e = arguments.length;
  if (e === 1)
    n = arguments[0];
  else {
    n = [];
    for (var t = 0; t < e; t++)
      n.push(arguments[t]);
  }
  var i = [];
  n.forEach(function(a, g) {
    i[g] = c.bind(null, a, n.filter(function(y, A) {
      return A !== g;
    }));
  });
  function r() {
    n.forEach(function(a, g) {
      a.on("move", i[g]);
    });
  }
  function l() {
    n.forEach(function(a, g) {
      a.off("move", i[g]);
    });
  }
  function c(a, g) {
    l(), BW(a, g), r();
  }
  return r(), function() {
    l(), i = [], n = [];
  };
}
var DW = OW, uv = { exports: {} }, nf = typeof Reflect == "object" ? Reflect : null, sT = nf && typeof nf.apply == "function" ? nf.apply : function(e, t, i) {
  return Function.prototype.apply.call(e, t, i);
}, xm;
nf && typeof nf.ownKeys == "function" ? xm = nf.ownKeys : Object.getOwnPropertySymbols ? xm = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : xm = function(e) {
  return Object.getOwnPropertyNames(e);
};
function FW(n) {
  console && console.warn && console.warn(n);
}
var eC = Number.isNaN || function(e) {
  return e !== e;
};
function fr() {
  fr.init.call(this);
}
uv.exports = fr;
uv.exports.once = UW;
fr.EventEmitter = fr;
fr.prototype._events = void 0;
fr.prototype._eventsCount = 0;
fr.prototype._maxListeners = void 0;
var oT = 10;
function y_(n) {
  if (typeof n != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n);
}
Object.defineProperty(fr, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return oT;
  },
  set: function(n) {
    if (typeof n != "number" || n < 0 || eC(n))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n + ".");
    oT = n;
  }
});
fr.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
fr.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || eC(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function tC(n) {
  return n._maxListeners === void 0 ? fr.defaultMaxListeners : n._maxListeners;
}
fr.prototype.getMaxListeners = function() {
  return tC(this);
};
fr.prototype.emit = function(e) {
  for (var t = [], i = 1; i < arguments.length; i++) t.push(arguments[i]);
  var r = e === "error", l = this._events;
  if (l !== void 0) r = r && l.error === void 0;
  else if (!r) return !1;
  if (r) {
    var c;
    if (t.length > 0 && (c = t[0]), c instanceof Error)
      throw c;
    var a = new Error("Unhandled error." + (c ? " (" + c.message + ")" : ""));
    throw a.context = c, a;
  }
  var g = l[e];
  if (g === void 0) return !1;
  if (typeof g == "function")
    sT(g, this, t);
  else
    for (var y = g.length, A = oC(g, y), i = 0; i < y; ++i) sT(A[i], this, t);
  return !0;
};
function nC(n, e, t, i) {
  var r, l, c;
  if (y_(t), l = n._events, l === void 0 ? (l = n._events = /* @__PURE__ */ Object.create(null), n._eventsCount = 0) : (l.newListener !== void 0 && (n.emit("newListener", e, t.listener ? t.listener : t), l = n._events), c = l[e]), c === void 0)
    c = l[e] = t, ++n._eventsCount;
  else if (typeof c == "function" ? c = l[e] = i ? [t, c] : [c, t] : i ? c.unshift(t) : c.push(t), r = tC(n), r > 0 && c.length > r && !c.warned) {
    c.warned = !0;
    var a = new Error("Possible EventEmitter memory leak detected. " + c.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a.name = "MaxListenersExceededWarning", a.emitter = n, a.type = e, a.count = c.length, FW(a);
  }
  return n;
}
fr.prototype.addListener = function(e, t) {
  return nC(this, e, t, !1);
};
fr.prototype.on = fr.prototype.addListener;
fr.prototype.prependListener = function(e, t) {
  return nC(this, e, t, !0);
};
function NW() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function iC(n, e, t) {
  var i = {
    fired: !1,
    wrapFn: void 0,
    target: n,
    type: e,
    listener: t
  }, r = NW.bind(i);
  return r.listener = t, i.wrapFn = r, r;
}
fr.prototype.once = function(e, t) {
  return y_(t), this.on(e, iC(this, e, t)), this;
};
fr.prototype.prependOnceListener = function(e, t) {
  return y_(t), this.prependListener(e, iC(this, e, t)), this;
};
fr.prototype.removeListener = function(e, t) {
  var i, r, l, c, a;
  if (y_(t), r = this._events, r === void 0) return this;
  if (i = r[e], i === void 0) return this;
  if (i === t || i.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[e], r.removeListener && this.emit("removeListener", e, i.listener || t));
  else if (typeof i != "function") {
    for (l = -1, c = i.length - 1; c >= 0; c--)
      if (i[c] === t || i[c].listener === t) {
        a = i[c].listener, l = c;
        break;
      }
    if (l < 0) return this;
    l === 0 ? i.shift() : kW(i, l), i.length === 1 && (r[e] = i[0]), r.removeListener !== void 0 && this.emit("removeListener", e, a || t);
  }
  return this;
};
fr.prototype.off = fr.prototype.removeListener;
fr.prototype.removeAllListeners = function(e) {
  var t, i, r;
  if (i = this._events, i === void 0) return this;
  if (i.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : i[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete i[e]), this;
  if (arguments.length === 0) {
    var l = Object.keys(i), c;
    for (r = 0; r < l.length; ++r)
      c = l[r], c !== "removeListener" && this.removeAllListeners(c);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = i[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (r = t.length - 1; r >= 0; r--)
      this.removeListener(e, t[r]);
  return this;
};
function rC(n, e, t) {
  var i = n._events;
  if (i === void 0) return [];
  var r = i[e];
  return r === void 0 ? [] : typeof r == "function" ? t ? [r.listener || r] : [r] : t ? zW(r) : oC(r, r.length);
}
fr.prototype.listeners = function(e) {
  return rC(this, e, !0);
};
fr.prototype.rawListeners = function(e) {
  return rC(this, e, !1);
};
fr.listenerCount = function(n, e) {
  return typeof n.listenerCount == "function" ? n.listenerCount(e) : sC.call(n, e);
};
fr.prototype.listenerCount = sC;
function sC(n) {
  var e = this._events;
  if (e !== void 0) {
    var t = e[n];
    if (typeof t == "function")
      return 1;
    if (t !== void 0)
      return t.length;
  }
  return 0;
}
fr.prototype.eventNames = function() {
  return this._eventsCount > 0 ? xm(this._events) : [];
};
function oC(n, e) {
  for (var t = new Array(e), i = 0; i < e; ++i) t[i] = n[i];
  return t;
}
function kW(n, e) {
  for (; e + 1 < n.length; e++) n[e] = n[e + 1];
  n.pop();
}
function zW(n) {
  for (var e = new Array(n.length), t = 0; t < e.length; ++t)
    e[t] = n[t].listener || n[t];
  return e;
}
function UW(n, e) {
  return new Promise(function(t, i) {
    function r(c) {
      n.removeListener(e, l), i(c);
    }
    function l() {
      typeof n.removeListener == "function" && n.removeListener("error", r), t([].slice.call(arguments));
    }
    aC(n, e, l, {
      once: !0
    }), e !== "error" && jW(n, r, {
      once: !0
    });
  });
}
function jW(n, e, t) {
  typeof n.on == "function" && aC(n, "error", e, t);
}
function aC(n, e, t, i) {
  if (typeof n.on == "function")
    i.once ? n.once(e, t) : n.on(e, t);
  else if (typeof n.addEventListener == "function")
    n.addEventListener(e, function r(l) {
      i.once && n.removeEventListener(e, r), t(l);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n);
}
var GW = uv.exports;
(function(n) {
  var e = DW, t = GW.EventEmitter;
  function i(r, l, c, a) {
    if (this.options = a || {}, this._mapA = r, this._mapB = l, this._horizontal = this.options.orientation === "horizontal", this._onDown = this._onDown.bind(this), this._onMove = this._onMove.bind(this), this._onMouseUp = this._onMouseUp.bind(this), this._onTouchEnd = this._onTouchEnd.bind(this), this._ev = new t(), this._swiper = document.createElement("div"), this._swiper.className = this._horizontal ? "compare-swiper-horizontal" : "compare-swiper-vertical", this._controlContainer = document.createElement("div"), this._controlContainer.className = this._horizontal ? "maplibregl-compare maplibregl-compare-horizontal" : "maplibregl-compare", this._controlContainer.className = this._controlContainer.className, this._controlContainer.appendChild(this._swiper), typeof c == "string" && document.body.querySelectorAll) {
      var g = document.body.querySelectorAll(c)[0];
      if (!g)
        throw new Error("Cannot find element with specified container selector.");
      g.appendChild(this._controlContainer);
    } else if (c instanceof Element && c.appendChild)
      c.appendChild(this._controlContainer);
    else
      throw new Error("Invalid container specified. Must be CSS selector or HTML element.");
    this._bounds = l.getContainer().getBoundingClientRect();
    var y = (this._horizontal ? this._bounds.height : this._bounds.width) / 2;
    this._setPosition(y), this._clearSync = e(r, l), this._onResize = (function() {
      this._bounds = l.getContainer().getBoundingClientRect(), this.currentPosition && this._setPosition(this.currentPosition);
    }).bind(this), l.on("resize", this._onResize), this.options && this.options.mousemove && (r.getContainer().addEventListener("mousemove", this._onMove), l.getContainer().addEventListener("mousemove", this._onMove)), this._swiper.addEventListener("mousedown", this._onDown), this._swiper.addEventListener("touchstart", this._onDown);
  }
  i.prototype = {
    _setPointerEvents: function(r) {
      this._controlContainer.style.pointerEvents = r, this._swiper.style.pointerEvents = r;
    },
    _onDown: function(r) {
      r.touches ? (document.addEventListener("touchmove", this._onMove), document.addEventListener("touchend", this._onTouchEnd)) : (document.addEventListener("mousemove", this._onMove), document.addEventListener("mouseup", this._onMouseUp));
    },
    _setPosition: function(r) {
      r = Math.min(r, this._horizontal ? this._bounds.height : this._bounds.width);
      var l = this._horizontal ? "translate(0, " + r + "px)" : "translate(" + r + "px, 0)";
      this._controlContainer.style.transform = l, this._controlContainer.style.WebkitTransform = l;
      var c = this._horizontal ? "rect(0, 999em, " + r + "px, 0)" : "rect(0, " + r + "px, " + this._bounds.height + "px, 0)", a = this._horizontal ? "rect(" + r + "px, 999em, " + this._bounds.height + "px,0)" : "rect(0, 999em, " + this._bounds.height + "px," + r + "px)";
      this._mapA.getContainer().style.clip = c, this._mapB.getContainer().style.clip = a, this.currentPosition = r;
    },
    _onMove: function(r) {
      this.options && this.options.mousemove && this._setPointerEvents(r.touches ? "auto" : "none"), this._horizontal ? this._setPosition(this._getY(r)) : this._setPosition(this._getX(r));
    },
    _onMouseUp: function() {
      document.removeEventListener("mousemove", this._onMove), document.removeEventListener("mouseup", this._onMouseUp), this.fire("slideend", {
        currentPosition: this.currentPosition
      });
    },
    _onTouchEnd: function() {
      document.removeEventListener("touchmove", this._onMove), document.removeEventListener("touchend", this._onTouchEnd), this.fire("slideend", {
        currentPosition: this.currentPosition
      });
    },
    _getX: function(r) {
      r = r.touches ? r.touches[0] : r;
      var l = r.clientX - this._bounds.left;
      return l < 0 && (l = 0), l > this._bounds.width && (l = this._bounds.width), l;
    },
    _getY: function(r) {
      r = r.touches ? r.touches[0] : r;
      var l = r.clientY - this._bounds.top;
      return l < 0 && (l = 0), l > this._bounds.height && (l = this._bounds.height), l;
    },
    /**
     * Set the position of the slider.
     *
     * @param {number} x Slider position in pixels from left/top.
     */
    setSlider: function(r) {
      this._setPosition(r);
    },
    /**
     * Adds a listener for events of a specified type.
     *
     * @param {string} type The event type to listen for; one of `slideend`.
     * @param {Function} listener The function to be called when the event is fired.
     * @returns {Compare} `this`
     */
    on: function(r, l) {
      return this._ev.on(r, l), this;
    },
    /**
     * Fire an event of a specified type.
     *
     * @param {string} type The event type to fire; one of `slideend`.
     * @param {Object} data Data passed to the event listener.
     * @returns {Compare} `this`
     */
    fire: function(r, l) {
      return this._ev.emit(r, l), this;
    },
    /**
     * Removes an event listener previously added with `Compare#on`.
     *
     * @param {string} type The event type previously used to install the listener.
     * @param {Function} listener The function previously installed as a listener.
     * @returns {Compare} `this`
     */
    off: function(r, l) {
      return this._ev.removeListener(r, l), this;
    },
    remove: function() {
      this._clearSync(), this._mapB.off("resize", this._onResize);
      var r = this._mapA.getContainer();
      r && (r.style.clip = null, r.removeEventListener("mousemove", this._onMove));
      var l = this._mapB.getContainer();
      l && (l.style.clip = null, l.removeEventListener("mousemove", this._onMove)), this._swiper.removeEventListener("mousedown", this._onDown), this._swiper.removeEventListener("touchstart", this._onDown), this._controlContainer.remove();
    }
  }, window.maplibregl ? maplibregl.Compare = i : n.exports = i;
})(Q3);
var VW = Q3.exports;
const qW = /* @__PURE__ */ $m(VW);
class JW {
  /**
   * Constructor for the map comparison class.
   * @class MapComparison
   * @param {Object} map1 - The first map object to compare.
   * @param {Object} map2 - The second map object to compare.
   * @param {string} container - The HTML container element ID for displaying the comparison.
   * @param {Object} options - Additional options for map comparison (if needed).
   */
  constructor(e, t, i, r) {
    const l = this;
    setTimeout(function() {
      l.mapCompare = new qW(e.map, t.map, i, {});
    }, 1e3);
  }
}
export {
  JW as C,
  XW as M,
  IW as a,
  or as d
};
